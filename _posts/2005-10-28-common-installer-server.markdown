---

title: Common installer server
abstract: Systems and techniques to provide for software installation. In general, in one implementation, the technique includes detecting selection of one or more applications by a user; creating a manifest for the one or more applications, the manifest including a reference to the one or more applications and a reference to one or more installers, where each of the one or more applications is associated with a unique one of the one or more installers; and providing the manifest to a target system where each of the one or more applications can be installed, none of the applications or installers being provided in the manifest.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274774&OS=09274774&RS=09274774
owner: Google Inc.
number: 09274774
owner_city: Mountain View
owner_country: US
publication_date: 20051028
---
This application is related to the following co pending patent application which is hereby incorporated by reference in its entirety 

Downloading software applications over the Internet is a popular way to obtain software. Many software publishers and third parties have websites that allow users to download applications. However different websites present different user interfaces making for varying user experiences. Furthermore applications from different software publishers can utilize different installation programs with their own user interfaces and click wrap end user license agreements.

This disclosure generally describes systems methods and computer programs for implementing a client server model for installing software applications.

In one aspect selection of one or more applications by a user is detected. A manifest is created for the one or more applications the manifest including a reference to the one or more applications and a reference to one or more installers where each of the one or more applications is associated with a unique one of the one or more installers. The manifest is provided to a target system where each of the one or more applications can be installed none of the applications or installers being provided in the manifest.

Implementations may include one or more of the following features. The detecting and the providing are for a second user and a second target system the second user different from the user and the second target system different from the target system. Providing a user interface for allowing a user to select the one or more applications from a set of available applications. Determining the set of available applications based on at least one of the following an application installed on the target system a characteristic of the user or a characteristic of a group of users to which the user belongs. Providing the manifest includes providing information to the target system so that a process on the target system can determine whether the manifest is genuine. Providing a single end user license agreement encompassing the one or more applications that a user can interactively accept or reject. The manifest is an XML document. The manifest is signed. Each associated installer is signed.

In another aspect detecting of addition by a user of a reference to a first application to a set of references to applications the set being on a first system each application referred to by the set having an associated installation framework. Providing an indication of the addition to a target system the target system being distinct from the first system. Providing the target system with a location of the associated installation framework for the first application.

Implementations may include one or more of the following features. Accepting the deletion by the user of a reference to a second application from the set and notifying the target system of the deletion. Providing the indication in response to a request by the target system.

In another aspect detecting selection of a plurality of applications by a user for installation on a target system each one of the plurality of applications being associated with an installer each associated installer being unable to provide an end user license agreement that the user can interactively accept or reject each one of the plurality of applications being associated with a different publisher. Presenting a single end user license agreement encompassing the plurality of applications that the user can interactively accept or reject.

Implementations may include one or more of the following features. Each associated publisher being identified in a file used by the associated installer on the target system. Detecting whether the user accepted the license agreement and if the user accepted the license agreement providing the target system with the location of each associated installer. Each associated installer is signed.

In another aspect detecting selection of one or more applications. Creating an install stub for the one or more applications the install stub including a reference to the one or more applications each of the one or more applications having an associated installer. And providing the install stub to a target system where each of the one or more applications will be installed.

Implementations may include one or more of the following features. None of the applications or associated installers are provided in the install stub. Activating the install stub the install stub configured to install the one or more applications on the target system using the associated installer for each application. Obtaining the associated installer for each of the one or more applications. The reference is a manifest. The reference refers to a manifest on a server. Signing the install stub. The install stub includes a copy of the one or more applications and a copy of the associated installer for each of the one or more applications.

Particular implementations can realize one or more of the following advantages. A common user interface and procedure is provided to install applications from different publishers. A user interface can present a user or a target system with a list of applications that is customized for the user. A software installation process can be automatic and can run unattended. A user can be notified of new software from different publishers as it is made available for downloading. A target system can background downloading of new applications ahead of time and notify the user that new software is available to install. This makes the process of installing new applications easier since the user does not have to wait for downloading to complete.

A common installer runtime CIR makes the process of downloading and installing software reliable by resuming downloads and installs after network disconnects or computer crashes. Another advantage is the ability to run newly installed and previously installed applications while continuing to download and install additional applications and the ability to detect an application that is already installed on a target system and only download and install the application if the server has a newer version of the application available. The CIR can automatically download and install updates or new software without requiring user intervention.

The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features aspects and advantages will be apparent from the description drawings and claims.

Table illustrates how a target system responds to changes made to a set of selected applications by a user over time. An application includes functionality or information that can be executed interpreted or used by another application on a target system. By way of illustration and without limitation an application can include one or more of the following a word processor a dynamically or statically linked software library a distributed object a plug in for another application such as a web browser or mail program programming language source code an XML document an image audio visual information and data. An application can be compressed encrypted and or digitally signed. Moreover an application can be a different version or edition of a previously installed application.

Column shows additions and deletions made to the set of selected applications on a server by a user on a target system for each time period in column . Column shows the applications installed on the target system before changes to the set of selected applications are incorporated or mirrored on the target system. A target system can include without limitation a workstation a personal computer a wireless mobile computer e.g. a personal digital assistant and a device incorporating a cellular telephone a digital media player or an electronic game system. In one implementation the server and the target system are the same system. Column shows action s the target system can take to mirror changes to the selected applications. And column shows the applications installed on the target system after the changes to the set of selected applications are incorporated.

In period 1 the set of selected applications is empty and no applications are installed on the target system. An application Ain an inventory of available applications is added by a user to the set of selected applications in period 2 . This prompts the target system to obtain an installer Ifor Aand use Ito install Aon the target system denoted as I A . The resulting state of the target system now shows the presence of application A. In period 3 two applications A A from the inventory of available applications are added by a user to the set of selected applications. The target system obtains and invokes the installers for A I A and A I A . As a result the target system has A Aand Ainstalled.

In period 4 application Ais removed by a user from the set of selected applications. In one embodiment removed applications remain on the target system until the user chooses to uninstall them. In another embodiment this prompts the target system to invoke an uninstaller for A I A . In this case the resulting applications on the target system would be Aand A. In yet a further embodiment an installer for a new version of an application automatically uninstalls the prior version from the target system.

In period 5 version two of application A A is selected. For example this might be an upgrade or a downgrade to application Aon the target system. The applications available on the target system before selection of Aare version one of A A and A. The target system uninstalls demotes or replaces Awith Aby installing A indicated by A A . In one embodiment a given version of an application is not downloaded and or replaced until the user provides confirmation. The version of an application can indicate different product lines and different kinds of versions e.g. free versions premium versions enterprise versions or corporate versions . Rules can be utilized to make decisions based on version information such as whether a given application version can be downloaded installed uninstalled or upgraded. For example if a user has already installed a premium version of an application it would not make sense to replace it with a lesser version.

Adding and removing applications to or from the set of selected applications by a user can cause the applications to be installed or in one embodiment uninstalled from target system . A user s set of selected applications can be saved in one embodiment so that other target systems can be configured using the saved selections. Moreover adding applications or new versions of applications to the inventory of available applications can cause the user of the target system to be notified that new software is available to potentially add to the set of selected applications . See .

In one embodiment the user interface can present a personalized inventory of available applications from which the user can choose to install on the target system . For example applications can be chosen for the inventory that would complement or upgrade the applications already installed on the target system. The inventory can include applications not already installed on the target system . Alternatively the inventory of applications can be personalized based on the country or region the target system s Internet Protocol IP address maps to. For example an IP address can be mapped to a physical location using a geolocation service such as hostip.info.

In one embodiment the server can maintain a list of applications that have been installed on a given target system. The target system can be identified based on a user login an IP address an HTTP cookie or through other suitable means. User selected applications can be stored in the list and used to customize the inventory of available applications presented to the user. In another embodiment the list of installed applications can be provided to the server by the target system using for example a URL an HTTP cookie or other suitable means.

In another embodiment the user interface can present a list of applications from which the user can choose to add to the set of selected applications based on a characteristic of the user and or a characteristic of a group of users to which the user belongs. By way of illustration applications can be chosen by a process for the list of applications based on what other users similar to the user selected and or what family members friends or associates of the user purchased or recommend. By way of a further illustration applications can be chosen that would be of interest to the user given the user s profile. A user profile can contain information describing a user s occupation interests income location tastes in food music electronics and other consumer items and other suitable traits. In further embodiments the inventory of applications can be personalized based on any suitable factors including a combination of the factors discussed above.

In another embodiment related applications can be grouped logically as bundles from which the user can select individual applications. For example a new user bundle could contain applications a new user might need on their system and an advanced user bundle could contain applications that require more training and user sophistication.

Applications in the inventory of available applications can be provided by different software publishers e.g. Google Mozilla . The applications that are added to the set of selected applications can be installed by different installation frameworks e.g. InstallShield Microsoft Installer NullSoft . In one embodiment an application installer or installer contains both the application and its installation framework. In another embodiment the installer is embodied in one or more files where the files can be located on the same or different servers. Alternatively the installer contains the installation framework but has the capability of locating and downloading a representation of the application from one or more locations.

An installation framework can establish an application on the target system by installing the application in stages. Early stages can notify processes on the target system of the installation test for system compatibility and determine whether or not the target system has sufficient resources. Later stages can allocate any resources on the target system that the application may need to properly function e.g. space on a file system logical devices registry values ports and any other suitable resource and extract application components from the installer. Some installation frameworks allow for rolling back installation stages upon user cancellation or failure of the installation process. Installation frameworks can also create an uninstaller based on the installation. When invoked the uninstaller will safely remove an application from the target system and free any resources the installer had allocated for it.

A manifest describes the selected applications i.e. Aand A . Each application referred to in the manifest has an associated installer which in one embodiment is located on a server that is accessible to the target system . In another embodiment an installer can be located on the target system. For example if the installer was distributed on a compact disc or other media which is accessible to the target system. As a further example an installer can be included in the install stub see below . An installer is responsible for installing its associated application on the target system . In this illustration the installer I for application Ais located on server . The installer I for application Ais located on server . The manifest also includes the location of each application s associated installer. In one embodiment and referring to Table 1 below the manifest can include the following information for each selected application 

In one embodiment the manifest is represented as an Extensible Markup Language XML document. The manifest can be digitally signed to protect against tampering that would alter the information in the manifest and potentially cause malicious code to be installed on the target system . Alternatively the server can provide other suitable information to the target system such that the target system can determine of the manifest is genuine.

Once the user has selected the applications for installation on the target system the user is presented with a single end user license agreement EULA encompassing all of the selected applications. The user can interactively accept or reject the EULA. If the user accepts the EULA a new manifest is generated representing the selected applications. The manifest is then provided to the target system . The target system obtains the installers from the locations specified in the manifest if they have not already been obtained and uses the installers to install each application referred to in the manifest i.e. Aand A . A target system user interface can be used to show the status of the installations as they progress see .

As discussed earlier the server system user interface allows a user to select applications for installation on a target system. The user interface implements a protocol for interaction between the server and a user of the target system . In one embodiment the user interface is rendered with Dynamic Hypertext Markup Language DHTML and JavaScript. The user interface could be personalized based on the user s target system configuration and other factors by means of an ActiveX control Netscape Plug in or another suitable method. A web browser or other suitable application on the target system can present the user interface to the user so that the user can select the applications to be installed on the target system.

A manifest generator on the server generates a manifest based on the user s selections. The manifest is provided to a common installer runtime CIR on the target system . The CIR is a program that continually runs on the target system. In one embodiment the manifest generator digitally signs the manifest before it is provided to the CIR . In another embodiment all possible manifests are precomputed i.e. based on all possible combinations of the user s selections signed and stored such that no computationally expensive signing is required before sending the manifest to the CIR .

A notification service allows the CIR to discover new applications or newly available version of applications available for installation on the target system . In one embodiment the notification service is a web service that accepts messages encoded as XML documents that the CIR can send to discover new applications. In another embodiment the notification service pushes notification messages to the CIR without requiring the CIR to query the notification service . In one embodiment the CIR can obtain installers quietly in the background as the CIR learns of new software from the server . This means that installation can begin immediately if a user selects to have these new programs installed e.g. through user interface .

The target system user interface can present a notification to the user of new programs or program version that are available and present the server user interface to the user e.g. by the user selecting the notification or so that the user can select the applications for installation on a target system . See . For example the notification can be implemented using a Microsoft Windows system tray icon notification or other suitable indicator. In one embodiment the target system can invoke the server user interface by customizing HTTP requests to the server. For example user or target system information can be encoded in the URL either directly by using a browser helper object to rewrite the URLs or by using HTTP cookies. In another embodiment browser plugins such as ActiveX Netscape Plugin Application Programming Interface NPAPI plugins or Cross Platform Component Object Model XPCOM plugins can be used to facilitate communication between the CIR and the web browser.

An auto update service allows the CIR to update itself when a new version of the CIR becomes available. The auto update service can push notification messages to the CIR to alert the CIR that a new version is available. Alternatively the CIR can query the auto update service to learn of updates. In one embodiment the CIR can download a new version of itself from the auto update service using the download manager or other suitable means.

A browser integration component on the target system provides a link between the web browser and the CIR . In one embodiment the server sends the manifest or CIR install stub see below to the target system using the web browser . For example this can be accomplished with a Microsoft Windows Shell file extension and Multipurpose Internet Mail Extensions MIME type registration. If the CIR is not installed on the target system at the time when the server needs to send the manifest to the target system the server will send the CIR and the manifest or manifest handle to the target system. A manifest handle is a value e.g. a number or a string that uniquely identifies a manifest on the server .

In one embodiment the server prepares a CIR install stub including the manifest or manifest handle . An install stub is a small executable module e.g. an EXE or DLL that is provided to the target system . An install stub can be compressed and or digitally signed. The install stub installs the CIR on the target system and then activates the CIR so that the installation of applications on the target system can commence. The install stub includes an embedded CIR module and a manifest file or a manifest handle that identifies a specific manifest on the server . The install stub is executed on the target system . It extracts the CIR module installs the CIR on the target system and then invokes the CIR passing the manifest or manifest handle as a command line argument. If a manifest handle is passed to the CIR the CIR can download the corresponding manifest from the server . In one embodiment the install stub can include the installers referenced by the manifest. In this embodiment the CIR does not need to download the installers.

The install manager can also utilize a security manager component to verify the integrity of the installers. In one embodiment the security manager component determines if an installer is genuine i.e. has not been tampered with . For example an installer can be digitally signed. A digital signature is information that is encrypted with a private key and included with the installer to ensure the integrity and authenticity of the installer. If the security manager component determines that an installer is not authentic the install manager will not invoke the installer. In this way the install manager prevents malicious code from being executed by the target system .

If an installer is genuine the install manager invokes the installer so that the installer installs its associated applications in silent mode. Silent mode means that an installer is not permitted to present its own user interface. A persistent store can be used by the install manager to store information describing the applications it has installed. In one embodiment the install manager installs applications in sets of size x. For example if x is one then as soon as the download manager has downloaded the first installer the installation can begin. If x is five then five installers will be downloaded before they are invoked to install their associated applications. If x is one this gives the user access to installed programs sooner than having to wait for other installers to be downloaded first and can reduce any side effects of running different installers at the same time.

In one embodiment each installer can have 1 to N number of error codes it returns upon execution. The install manager can capture these error codes after each installer executes and present different user interfaces based on the associated meaning of each code. For example installers can return 0 for success or 1 for failure. But they can also return another number that indicates the program was installed successfully except for a particular condition e.g. not being able to create a desktop icon requiring that the target machine be rebooted and requiring that a particular program be closed . In certain cases the error code might dictate that the user be offered the option to run the visual or interactive installation framework that users would normally encounter were they to try and install a application without using the CIR . In another embodiment each installer can optionally present a user interface.

A maintainer component can download installers for new application versions in the background as long as there is disk space available. In one embodiment the downloading happens without asking for the user s permission. The installer manager implements logic to detect program versions so that it does not download programs that the user already has. In one embodiment applications can advertise a version checking policy in the manifest. In another embodiment applications can provide application programming interfaces that allow the CIR to query their version.

A notification client calls the server notification service to discover new applications or updates to applications already installed i.e. new versions . In one embodiment the protocol can be based on simple XML messages that are communicated between the notification client and the notification service . In another embodiment the protocol can be based on the Rich Site Summary RSS protocol to deliver notifications as RSS news. In one embodiment the header of each message includes a protocol version a server build number and a message identifier to easily correlate the requests and the responses for logging and debugging purposes. The responses can be optionally digitally signed for data integrity protection.

In one embodiment the notification client can generate user notifications e.g. and based on the applications installed on the target system or other criteria. See . For example the notification client can recognize whether the user has installed the Google Toolbar but has chosen not to install a complimentary application e.g. Google Desktop. The notification client can let the user know about this condition and give the user the option of downloading related applications.

The auto update component communicates periodically with the server auto update service . A set of messages can be exchanged between the auto update service and the auto update component by which the auto update component discovers if there is an update available. If an update is available the auto update component can utilize the install manager to download and install it. In one embodiment the update is a package of code and data that upgrades the CIR .

The embodiments and all of the functional operations described in this specification can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Apparatus of the embodiments can be implemented in a computer program product tangibly embodied in a machine readable storage device for execution by a programmable processor and method steps of the embodiments can be performed by a programmable processor executing a program of instructions to perform functions of the embodiments by operating on input data and generating output.

The embodiments can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. Each computer program can be implemented in a high level procedural or object oriented programming language or in assembly or machine language if desired and in any case the language can be a compiled or interpreted language.

Suitable processors include by way of example both general and special purpose microprocessors. Generally a processor will receive instructions and data from a read only memory and or a random access memory. Generally a computer will include one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks a magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM disks. Any of the foregoing can be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with a user the embodiments can be implemented on a computer system having a display device such as a monitor or LCD screen for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer system. The computer system can be programmed to provide a graphical user interface through which computer programs interact with users.

A number of embodiment have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the disclosure. Accordingly other embodiments are within the scope of the following claims.

