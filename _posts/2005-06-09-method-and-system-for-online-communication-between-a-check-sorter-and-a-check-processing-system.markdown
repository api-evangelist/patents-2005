---

title: Method and system for online communication between a check sorter and a check processing system
abstract: A system for handling checks is provided that includes a sorter operable to retrieve MICR data from a plurality of checks. An emulator is coupled to the sorter. The emulator is operable to access the MICR data, to generate a process buffer based on the MICR data, and to generate a plurality of feature instructions for each check based on the process buffer. A communication engine is coupled between the emulator and a check processing system. The communication engine is operable to communicate between the emulator and the check processing system in real-time. The check processing system is operable to receive the process buffer from the emulator through the communication engine. The emulator is further operable to communicate the feature instructions to the sorter. The sorter is further operable to process the checks based on the feature instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07555156&OS=07555156&RS=07555156
owner: VECTORsgi, Inc.
number: 07555156
owner_city: Addison
owner_country: US
publication_date: 20050609
---
This application is a divisional of application Ser. No. 10 616 117 filed Jul. 9 2003 now U.S. Pat. No. 6 924 450 which is a divisional of application Ser. No. 09 553 228 filed Apr. 20 2000 now U.S. Pat. No. 6 608 274 which is related to application Ser. No. 09 558 749 filed Apr. 20 2000 now U.S. Pat. No. 6 985 617.

This invention relates generally to the field of document processing in the financial industry and more particularly to a method and system for online communication between a check sorter and a check processing system.

Within the financial industry document processing is an important part of the daily management of a business. Document processing systems include sorters for physically handling and retrieving data from checks and other items and data processors for analyzing and storing the retrieved data. The sorters and data processors intercommunicate data and instructions to individually read and process each check.

Conventional check sorters for document processing such as the IBM 3890 and 3890 XP series of check sorters are relatively large and expensive machines. Thus purchasing one of these check sorters may place a great financial strain on a small business or may be unreasonable for a larger business needing to process a relatively small number of checks over the business current capacity. Smaller and less expensive check sorters typically cannot communicate with existing data processing systems that are designed to operate in connection with the IBM 3890 and 3890 XP series of check sorters. As a result the smaller check sorters are not a viable solution in many applications.

Attempts to solve this problem have included customized emulators which allow a specific check sorter which may be smaller and less expensive to emulate the IBM 3890 and 3890 XP series of check sorters so that the data processing system may communicate with the specific check sorter. However these emulators are hardware specific solutions. Thus a different emulator must be designed programmed and proved out for each different type of check sorter. This customization is time consuming and expensive and is thus not a practical solution.

Both traditional and customized document processing systems typically use LU 6.2 or channel connect standards to connect to and to communicate with a mainframe running the data processor. These types of connections are expensive to configure and maintain and this limits the viability of these systems.

Yet another disadvantage relates to code line data matching. Typical sorters and typical emulators as well provide approximately sixteen lines of memory for code line data matching which may be used to save time when processing a document for a second time. This limited amount of memory allows data to be saved for a relatively small number of documents. In addition the processor that searches the memory for code line data matches is generally not fast enough to allow the memory to be expanded. If more lines of data were available to be searched the processor would not have enough time to search the additional lines of data before the amount of time for processing the document had expired.

In accordance with the present invention a method and system for online communication between a check sorter and a check processing system are provided that substantially eliminate or reduce disadvantages and problems associated with previously developed systems and methods. In particular a communication engine provides real time communication between a check sorter and a processing system using a TCP IP connection.

In one embodiment of the present invention a system for handling checks is provided that includes a sorter operable to retrieve MICR data from a plurality of checks. An emulator is coupled to the sorter. The emulator is operable to access the MICR data to generate a process buffer based on the MICR data and to generate a plurality of feature instructions for each check based on the process buffer. A communication engine is coupled between the emulator and a check processing system. The communication engine is operable to communicate between the emulator and the check processing system in real time. The check processing system is operable to receive the process buffer from the emulator through the communication engine. The emulator is further operable to communicate the feature instructions to the sorter. The sorter is further operable to process the checks based on the feature instructions.

Technical advantages of the present invention include providing an improved check handling system. In particular the check sorter and the processing system communicate in real time over a TCP IP connection. As a result costs are reduced greater interaction between components is provided and links are easier to configure.

Another technical advantage of the present invention includes an improved code line data matching system. The code line data matching is provided in a personal computer or other similar device. As a result both the memory available for storing data and the processor speed are substantially increased. Accordingly data may be saved for thousands of documents while the increased processor speed allows the increased amount of data to be searched in the time available for processing the check.

Still another technical advantage of the present invention includes providing a dynamic check processing system. In particular search algorithms including elements of the algorithms may be dynamically adjusted during a check processing run based on run time parameters. As a result accuracy and efficiency are improved.

Other technical advantages will be readily apparent to one skilled in the art from the following figures description and claims.

The sorter may be any one of a plurality of disparate types of suitable sorters. The modular emulator thereby allows a check processing system that is configured to communicate with a specific type of sorter to communicate with other types of sorters that are not directly compatible. For the exemplary embodiment the sorter may comprise a sorter available from NCR BancTec Unisys or Digital Check or other sorter capable of reading and exchanging MICR data through standardized processes.

The sorter comprises a MICR reader for retrieving MICR data from the checks an endorser for endorsing checks a microfilm camera for recording microfilm images of checks a digital camera for recording digital images of checks and a plurality of pockets for receiving sorted checks. The endorser may endorse a check by printing endorsement information on the check. The endorsement information may comprise the name of the bank or other financial institution processing the check. The digital camera may record an image of the front and or the back of each check and may record these images in black and white gray scale and or color. Thus different imaging data may be obtained for different checks. For example the digital camera may record a black and white image of the front of a first check and a gray scale image of the back of the first check and may record a color image of the front and the back of a second check. It will be understood that the digital camera may comprise one or more devices for recording digital images of checks being processed by the system .

The sorter also comprises a shared memory that is shared with the emulator and that comprises a MICR buffer . As described in more detail below in connection with the MICR buffer comprises the MICR data retrieved from the checks by the MICR reader . The MICR buffer may be a copy or adaptation of the retrieved data. The MICR data in the MICR buffer is thus in a format that is specific to the particular sorter and need not be customized for the system .

The sorter also comprises an interface for interpreting emulator data provided by the emulator . This emulator data may comprise feature instructions for the sorter regarding the features of the endorser the microfilm camera the digital camera and the pockets . The interface may be device specific and maps instructions from the emulator domain to the sorter domain. Thus based on the emulator data the interface determines for each check whether or not to endorse the check record a microfilm image of the check and record a digital image of the check. The interface also determines for each check which digital images and what types of digital images to record if any and which pocket is to receive the check.

The emulator comprises an emulator application programming interface API a communication engine and a code executing emulator for executing code provided by the check processing system that is programmed in a language specific to the sorter compatible with the check processing system . For the embodiment in which the compatible sorter comprises an IBM 3890 series sorter the code executing emulator comprises a stacker control instructions SCI emulator . The emulator may be compiled for execution on a Windows NT OS 2 or other suitable platform.

The sorter transmits a message to the API for each check being processed by the sorter . The API may then access the shared memory to retrieve the MICR data for the check from the MICR buffer . Alternatively the sorter may pass the MICR buffer to the emulator for processing. The API converts the MICR buffer into a standardized process buffer by reformatting the MICR data into a format that may be processed by the check processing system . The process buffer is standardized in that the format of the process buffer is the same regardless of the format of the MICR buffer for the sorter . In one embodiment the standardized process buffer is in the same format as the data provided by a compatible sorter with which the check processing system is designed to operate. In this embodiment the emulator emulates the compatible sorter for the check processing system . Thus for the embodiment in which the compatible sorter comprises an IBM 3890 series sorter the API converts the MICR buffer into the standardized process buffer based on IBM standards for the IBM 3890 series of sorters.

After processing is completed by the check processing system for the check the API updates the MICR buffer in the shared memory with the emulator data which includes instructions for processing the check. The API then notifies the sorter that the update is complete allowing the interface to begin interpreting the emulator data in the MICR buffer to complete the processing of the check.

According to one embodiment the API comprises logic for performing the functions described above. The logic may be encoded in hardware such as a field programmable gate array an application specific integrated circuit or the like and or software instructions stored in RAM ROM and or other suitable computer readable media for performing the functions associated with the API .

The communication engine receives the process buffer from the API for each check being processed by the sorter . As used herein each means every one of at least a subset of the identified items. As the process buffer is passed between components of the system it will be understood that any suitable portion of or the entire process buffer may be passed based on the data in the process buffer required by the receiving component.

After receiving the process buffer the communication engine calls a code line data match CLDM engine which attempts to match an identifier for the check in the process buffer to an identifier in a CLDM module . The CLDM module may store any suitable identifying information as an identifier and other data such as MICR data emulator data or any other suitable data relating to the check for each of a plurality of checks previously processed by the check processing system . Thus for example if a tray of checks being processed by the sorter is dropped or if the sorter jams or if any other situation results in the checks being re ordered after a portion of the checks have been processed the CLDM module is able to provide the previously generated emulator data for each of the checks which have already been processed thereby eliminating the need to fully process those checks a second time.

According to one embodiment the CLDM module is stored in a personal computer or other suitable device operable to store and process data. The CLDM module may store any suitable number of identifiers and related data for previously processed checks. According to one embodiment the CLDM module may store up to 20 000 identifiers. The number of identifiers stored in the CLDM module may be changed by the check processing system at any suitable time. Thus for example the number may be changed based on the number of checks being processed by the sorter at any particular time. If the number of identifiers to be stored has been embedded into a processing program the embedded number may be overwritten to allow extended searching capabilities.

If the CLDM engine finds no match in the CLDM module the communication engine calls the SCI emulator which may executed SCI code stored in a SCI module . According to one embodiment the check processing system provides executable SCI code to the emulator for storage in the SCI module . The SCI module may also comprise tables of data received from the check processing system .

The SCI code in the SCI module comprises a programming language for communicating between a check processing system and an IBM 3890 of 3890 XP. According to one embodiment the check processing system may provide new SCI code for storage in the SCI module at any suitable time. Thus for example new SCI code may be provided by the check processing system for each set of checks processed by the sorter .

When the communication engine calls the SCI emulator the SCI emulator accesses the SCI module and begins executing the SCI code stored in the SCI module . The SCI emulator may comprise a program file that identifies one or more auxiliary programs in the emulator . The auxiliary programs comprise programs in languages other than SCI code which may be easier to maintain. For example the auxiliary programs may be in C C Cobol Fortran or any other suitable programming language. According to one embodiment these auxiliary programs provide an entry point for special endorsement. The SCI emulator may use the data in the program file to call any one of the auxiliary programs instead of or in addition to the SCI code in the SCI module . The SCI emulator provides the results from the execution of the SCI code and or the auxiliary programs to the communication engine . According to one embodiment these results comprise instructions for the endorser the microfilm camera and the digital camera .

The communication engine incorporates the results from the SCI emulator into the process buffer received from the API in accordance with a specified format for the check processing system . This format may comprise a header trailer and or any other suitable information for providing to the check processing system a return address for the communication engine . The formatting is based on the type of communication between the check processing system and the communication engine . According to one embodiment this communication type is TCP IP. Alternatively LU 6.2 channel connect or any other suitable communication type may be used. However LU 6.2 and channel connect are more expensive and complex types of communication than TCP IP. The communication engine also provides online connectivity to the check processing system which allows real time communication between these two components and . Real time communication may include an instruction to disengage the pass for re orienting or other instructions between the communication engine and the check processing system to dynamically change run time parameters or operations.

According to one embodiment the communication engine comprises logic for performing the functions described above. The logic may be encoded in hardware such as a field programmable gate array an application specific integrated circuit or the like and or software instructions stored in RAM ROM and or other suitable computer readable media for performing the functions associated with the communication engine .

According to one embodiment the API and the communication engine communicate with TCP IP. Thus although the embodiment shown in illustrates the API local to the communication engine it will be understood that other suitable embodiments may be implemented without departing from the scope of the present invention. For example the API may be local to the sorter and remote from the communication engine . As used herein remote means that the two components may be located anywhere in the world with respect to each other and may communicate with each other over a communication link. Alternatively the API may be local to the communication engine and local to the sorter . In accordance with one embodiment the communication engine may communicate with a plurality of APIs that are remote from the communication engine and each other and that are each local to a sorter . Thus the emulator may be used to emulate a plurality of different types of sorters simultaneously through the use of a plurality of APIs .

The check processing system may comprise any suitable combination of one or more of Vector Sort Check Processing Control System SuperMICR or any other suitable check processing system and may be implemented on a mainframe. The check processing system receives the process buffer from the communication engine and makes decisions as to the processing of the check based on the process buffer . The check processing system also provides data to the CLDM module for the CLDM engine to use for matching.

In operation a set of checks is provided to the sorter for processing. As each check is passed through the sorter the MICR reader retrieves the MICR data from the check and copies this data to the MICR buffer in the shared memory . The sorter then notifies the API that the MICR buffer is available for processing. The API accesses the MICR buffer and converts the MICR data into a process buffer . The process buffer is then provided to the communication engine . The communication engine calls the CLDM engine which attempts to match an identifier in the process buffer to an identifier in the CLDM module . If a match is found the CLDM engine retrieves previously generated emulator data for the check and provides this information to the communication engine . However if no match is found the communication engine calls the SCI emulator . The SCI emulator then begins executing the SCI code in the SCI module and or an auxiliary program and provides the results to the communication engine .

The communication engine includes these results in the process buffer before providing the process buffer to the check processing system . The check processing system makes decisions regarding how to process the check based on the data in the process buffer .

The API generates emulator data based on the updated process buffer from the check processing system and copies the emulator data into the MICR buffer of the shared memory for the sorter . The API then notifies the sorter that the emulator data is available for the check. The interface interprets the updated MICR buffer that includes the emulator data in order to determine how to process the check. The emulator data instructs the interface whether or not to endorse the check to record a microfilm image of the check and to record a digital image of the check. The interface then signals the endorser the microfilm camera and or the digital camera in accordance with the feature instructions. According to one embodiment the interface provides a signal to each of the features and or which are to be activated and provides no signal to the features and or which are not to be activated.

For the digital camera the interface also notifies the digital camera which images to record front and or back what type of image black and white gray scale or color to record for the front and what type of image to record for the back. The interface also identifies a pocket to the sorter for the check. After any requested endorsement is performed and images are recorded the sorter directs the check to the pocket identified by the interface .

In accordance with one embodiment the header comprises two field validity bytes and . The first field validity byte comprises a bit to indicate an end of file for code line data matching and seven bits to indicate a digit error in one of seven corresponding fields. The second field validity byte comprises one bit to indicate that either the opening symbol for the first field was missing from the check or the leading edge of the check was damaged. The second field validity byte also comprise seven bits to indicate an invalid length or a special symbol sequence error in one of seven corresponding fields. An invalid length or special symbol sequence error indicates that the opening or closing symbol for a field was either missing or incorrect or that the number of digits detected in the field was incorrect.

The header also comprises two SCI results bytes and . These bytes and both comprise data generated by the SCI emulator through the execution of SCI code in the SCI module and or an auxiliary program .

The error feature data byte comprises a bit to indicate the validity of endorsement data a bit to indicate the validity of INF data a bit to indicate a power encoder error a bit to indicate a time out error a bit to indicate an image request a bit to indicate that an OCR3 feature was initialized on and two bits for communicating any suitable data.

The feature control byte comprises a bit to indicate that a predetermined number of checks have been recorded by the microfilm camera causing a pause to occur while the microfilm is spaced. The feature control byte also comprises a bit to enable a flash for lighting the check as the microfilm camera records a microfilm image of the check. The feature control byte also comprises a bit that may cause a one to be added to the value of a high order segment of an index number while the low order segment is reset to zero. The feature control byte also comprises a bit that may cause a one to be added to the low order segment of the index number. The feature control byte also comprises a bit to inhibit the printing of endorsement data by the endorser and a bit to inhibit the printing of INF data. Similar to the bits relating to the index number the feature control byte comprises a bit to increment the INF high order segment while resetting the INF low order segment to zero and a bit to increment the INF low order segment.

The pocket selection byte comprises three bits for module selection three bits for pocket selection and two bits for communicating any suitable data. The feature data byte comprises a bit to indicate that the endorsement feature was initialized on a bit that forces the check to be directed to the first pocket of the first module a bit to indicate that power encoding was not done or was invalid a bit to indicate that no code line data matching was attempted by the CLDM engine a bit to indicate that the process buffer was modified by specified macros or functions a bit to indicate that the microfilm camera was initialized on a bit to indicate that the INF feature was initialized on and a bit to identify a first document processed after a microfilm space.

The special condition data byte comprises a bit to indicate a hardware detected autoselect. A hardwaredetected autoselect indicates that at least one of the following conditions occurred multiple checks a distance between checks less than a predetermined amount a check length greater than a predetermined amount a check length less than a predetermined amount a distance between the leading edges of consecutive checks less than a predetermined amount and a special symbol sequence error. The special condition data byte also comprises a bit to indicate an invalid module pocket code autoselect a bit to indicate a late module pocket code autoselect a bit to indicate a SCI error a bit to indicate a merged document a bit to indicate that the CLDM engine found no match in the CLDM module a bit to indicate that a high order zero correction occurred and a bit to indicate that a symbol error correction occurred.

The routing SCI data byte comprises four bits for a routing number self check digit one bit to indicate an invalid routing number self check digit a bit to indicate a SCI pause and two bits for communicating any suitable data. The document number byte comprises a document sequence number for the check. According to one embodiment this number ranges from X00 to XFF.

The header type byte identifies the type of header for the process buffer . According to one embodiment the header type may comprise a document data header an exception header a SCI error header a data management header or any other suitable header type.

At step the API generates and provides a standardized process buffer which is based on the MICR buffer to the communication engine . The standardized process buffer is in a format that is compatible with the check sorter that is being emulated by the emulator . In one embodiment data is mapped from a hardware specific domain to a standard domain. At step decisions are made for the check based on the process buffer . At step these decisions are provided to the communication engine .

At step the communication engine provides the process buffer incorporating the decisions to the API . At the API updates the MICR buffer with emulator data based on the process buffer received back from the communication engine . In one embodiment the emulator data is copied to predefined fields in the MICR buffer .

At step the interface interprets the emulator data in the MICR buffer . At step the interface activates the appropriate features and or in accordance with the emulator data. At decisional step a determination is made regarding whether or not the endorser has been activated. If the endorser has been activated the methods follows the Yes branch from decisional step to step where the endorser endorses the check. However if the endorser has not been activated the method follows the No branch from decisional step to decisional step .

At decisional step a determination is made regarding whether or not the microfilm camera has been activated. If the microfilm camera has been activated the method follows the Yes branch from decisional step to step where the microfilm camera records a microfilm image of the check. However if the microfilm camera has not been activated the method follows the No branch from decisional step to decisional step .

At decisional step a determination is made regarding whether or not the digital camera has been activated. If the digital camera has been activated the method follows the Yes branch from decisional step to step where the digital camera records one or more digital images of the check. As described in more detail above the digital camera may record an image of the front and or an image of the back of the check. In addition each image recorded by the digital camera may be either black and white gray scale or color. Thus one or more of a number of indicators may be set for the digital camera . Returning to decisional step if the digital camera has not been activated the method follows the No branch from decisional step to step .

At step the interface provides a pocket selection for the check. At step the sorter directs the check to the identified pocket . At decisional step the sorter makes a determination regarding whether there are more checks to process. If there are more checks to process the method follows the Yes branch from decisional step and returns to step where the MICR reader retrieves MICR data from a subsequent check. However if there are no more checks to process the method follows No branch from decisional step at which point the method comes to an end. Thus each check passing through the sorter is individually processed by the check processing system through the use of the emulator that allows the check processing system to communicate with the sorter as though the sorter were a different type of sorter.

At step the API receives the process buffer incorporating decisions made by the check processing system back from the communication engine . At step the API generates emulator data based on the process buffer . At step the API provides the emulator data to the sorter by updating the MICR buffer in the shared memory with the emulator data. At step the API notifies the sorter that the MICR buffer has been updated at which point the method comes to an end.

If a matching identifier was found the method follows the Yes branch from decisional step to step where the process buffer is updated with data stored in the CLDM module . At step the communication engine provides the updated process buffer to the API at which point the method comes to an end.

Returning to decisional step if no matching identifier was found the method follows the No branch from decisional step to step . At step the communication engine calls the SCI emulator which may execute SCI code stored in the SCI module and or one or more auxiliary programs identified in the program file . At step the communication engine incorporates results received from the SCI emulator into the process buffer . At step the communication engine provides the updated process buffer to the check processing system .

At step the communication engine receives decisions regarding the check from the check processing system . At step the communication engine incorporates the decisions received from the check processing system into the process buffer . At step the communication engine provides the process buffer to the API and to the CLDM engine . At step the CLDM engine stores the process buffer in the CLDM module for future matching at which point the method comes to an end.

Although the present invention has been described with several embodiments various changes and modifications may be suggested to one skilled in the art. It is intended that the present invention encompasses such changes and modifications as fall within the scope of the appended claims.

