---

title: Data allocation within a storage system architecture
abstract: Provided is a method and system for data allocation within a storage system architecture. One or more nodes of the storage system architecture provides access to striped data stored on a striped volume set. Each node can store a volume of the striped volume set. Further, the striped volume set is identified by a striping table. When modifying the storage system architecture, such as adding a volume to, or removing a volume from, the striped volume set, the striping table is rearranged to accurately identify the location of striped data on the striped volume set. At least one restriping process implemented on the striping table affects the volume utilization efficiency, hot-spotting behavior, and distribution efficiency of the striped volume set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07617370&OS=07617370&RS=07617370
owner: NetApp, Inc.
number: 07617370
owner_city: Sunnyvale
owner_country: US
publication_date: 20050429
---
This application is related to U.S. patent application Ser. No. 11 119 278 entitled Storage System Architecture for Striping Data Container Content Across Volumes of a Cluster filed on Apr. 29 2005 and U.S. patent application Ser. No. 11 119 118 entitled System and Method for Restriping Data Across a Plurality of Volumes filed on Apr. 29 2005 which are hereby incorporated by reference in their entirety.

Embodiments of the present invention relate to storage systems and in particular to allocating data across a plurality of volumes of a storage system cluster.

Typically a storage system provides access to information that is stored on one or more storage devices connected to the storage system. Access to the information is possible by organizing the storage devices into volumes which logically organize the information stored on the storage devices. The storage devices are typically disk drives organized as a disk array such that the term disk describes a self contained rotating magnetic media storage device. Further the term disk in this context is synonymous with a hard disk drive HDD or direct access storage device DASD .

The storage system may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network LAN wide area network WAN or virtual private network VPN implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file based and block based protocol messages in the form of packets to the system over the network.

A plurality of storage systems may be interconnected to provide a storage system environment configured to service many clients. Each storage system may be configured to service one or more volumes wherein each volume stores one or more data containers. Yet often a large number of data access requests issued by the clients may be directed to a small number of data containers serviced by a particular storage system of the environment. A solution to such a problem is to distribute the volumes serviced by the particular storage system among all of the storage systems of the environment. This in turn distributes the data access requests along with the processing resources needed to service such requests among all of the storage systems thereby reducing the individual processing load on each storage system. However a noted disadvantage arises when only a single data container such as a file is heavily accessed by clients of the storage system environment. As a result the storage system attempting to service the requests directed to that data container may exceed its processing resources and become overburdened with a concomitant degradation of speed and performance.

Embodiments of the present invention provide a method and a system for data allocation within a storage system architecture. Specifically the present invention overcomes the disadvantages of the prior art by providing a storage system architecture comprising one or more volumes distributed across a plurality of nodes interconnected as a cluster. The volumes are organized as a striped volume set SVS and configured to store content of data containers such as files and logical units served by the cluster in response to multi protocol data access requests issued by clients. Each node of the cluster includes i a storage server adapted to service a volume of the SVS and ii a multi protocol engine adapted to redirect the data access requests to any storage server of the cluster. Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster. It should be appreciated that the present invention can be implemented in numerous ways such as a process an apparatus a system a device or a method on a computer readable medium. Several inventive embodiments of the present invention are described below.

In an exemplary embodiment of a method of data allocation the method includes identifying a storage system architecture for allocating data among a plurality of storage systems. The method further includes determining an allocation structure such that the allocation structure describes the distribution of chunks of data. The method also includes updating the allocation structure when modifying the storage system architecture.

In yet another exemplary embodiment of a system for data allocation within a storage system architecture the system includes an allocation structure that identifies multiple volumes for distributing chunks of data. Each of the multiple volumes is organized by at least one storage system of the storage system architecture. Further the embodiment of the system includes multiple restriping processes such that each of the multiple restriping processes rearranges contents of the allocation structure in response to the modification of the storage system architecture.

In an embodiment of a computer readable medium that includes instructions for data allocation within a storage system architecture the embodiment includes instructions for allocating data among multiple storage systems of the storage system architecture. The embodiment also includes instructions for determining an allocation structure such that the allocation structure describes the distribution of chunks of data. Further the embodiment includes instructions for updating the allocation structure when modifying the storage system architecture.

In an embodiment of a computing environment for allocating data the embodiment includes means for identifying multiple volumes for distributing chunks of data. Each of the multiple volumes is organized by at least one system of the computing environment. Further the embodiment includes means for rearranging contents of an allocation structure in response to the modification of the computing environment.

Other aspects of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings which illustrates by way of example the principles of the invention.

The following embodiments describe a method and a system for data allocation within a storage system architecture. Specifically the present invention overcomes the disadvantages of the prior art by providing a storage system architecture comprising one or more volumes distributed across a plurality of nodes interconnected as a clustered computing environment. The volumes are organized as a striped volume set SVS and configured to store content of data containers such as files and logical units served by the cluster in response to multi protocol data access requests issued by clients. Each node of the cluster includes i a storage server adapted to service a volume of the SVS and ii a multi protocol engine adapted to redirect the data access requests to any storage server of the cluster. Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster. It will be obvious however to one skilled in the art that embodiments of the present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail to prevent obscuring the embodiments of the present invention described herein.

The computing environment illustrated in the diagram of comprises a plurality of nodes interconnected as a cluster of a clustered computing environment in accordance with an embodiment of the invention. The nodes are configured to provide storage services relating to the organization of information on storage devices such as the disk array . The nodes comprise various functional components that cooperate to provide a distributed storage system architecture of the cluster. Further each node is organized as a network element N blade and a disk element D blade . The N blade includes functionality that enables the node to connect to clients over a connection system while each D blade connects to one or more storage devices such as disks of a disk array . The nodes are interconnected by a cluster switching fabric which in the illustrative embodiment may be embodied as a Gigabit Ethernet switch. An exemplary distributed file system architecture is generally described in U.S. Patent Application Publication No. US 2002 0116593 titled METHOD AND SYSTEM FOR RESPONDING TO FILE SYSTEM REQUESTS by M. Kazar et al. published Aug. 22 2002. It should be noted that while there is shown an equal number of N and D blades in the illustrative cluster there may be differing numbers of N andlor D blades in accordance with various embodiments of the present invention. For example there may be a plurality of N blades and or D blades interconnected in a cluster configuration that does not reflect a one to one correspondence between the N and D blades. As such the description of a node comprising one N blade and one D blade should be taken as illustrative only.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the connection system . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

Each node may be embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However it will be apparent to those of ordinary skill in the art that the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N blade on the node while the other processor executes the functions of the D blade .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node . It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises a plurality of ports adapted to couple the node to one or more clients over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network of the connection system . Illustratively the connection system may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over the connection system by exchanging discrete frames or packets of data according to pre defined protocols such as TCP IP.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients . The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of the disk array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance Fibre Channel FC link topology.

Storage of information on each disk array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein. It should also be appreciated that such data stripes are different from the allocated data that are distributed as chunks of data among the plurality of storage systems with respect to the exemplary embodiments of the present invention. Striped data of the exemplary embodiments will be further described in reference to .

The storage operating system facilitates access to the disks . Specifically the storage operating system implements a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks . Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. of Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term WAFL is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module that organizes any number of volumes such as volume volume volume and volume N a RAID system module and a disk driver system module . A volume striping module VSM not shown of the file system implements a striped volume set SVS later described in reference to . The VSM cooperates with the file system to enable the storage server to service a volume of the SVS. In particular the VSM computes the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster. The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework see in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the iSCSI and FC drivers respectively and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as the disks . That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte kB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store meta data describing the layout of its file system these meta data files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the connection system and onto the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from the disk if it is not resident in core i.e. in memory . If the information is not in the memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the connection system .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by the node in response to a request issued by the client . Moreover in another alternate embodiment of the invention the processing elements of the adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processors to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows NT or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write anywhere file system the teachings of the present invention may be utilized with any suitable file system including a write in place file system.

In an exemplary embodiment the storage server is embodied as D blade of the storage operating system to service one or more volumes of disk array . In addition the multi protocol engine is embodied as N blade to i perform protocol termination with respect to a client issuing incoming data access request packets over the connection system as well as ii redirect those data access requests to any storage server of the cluster. Moreover the N blade and D blade cooperate to provide a highly scalable distributed storage system architecture of a clustered computing environment implementing exemplary embodiments of the present invention. To that end each blade includes a cluster fabric CF interface module adapted to implement intra cluster communication among the blades including D blade to D blade communication for data container striping operations described herein.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers of the N blade function as protocol servers that translate file based and block based data access requests from clients into CF protocol messages used for communication with the D blade . That is the N blade servers convert the incoming data access requests into file system primitive operations commands that are embedded within CF protocol messages by the CF interface module for transmission to the D blades of the cluster. Notably the CF interface modules cooperate to provide a single file system image across all D blades in the cluster. Thus any network port of an N blade that receives a client request can access any data container within the single file system image located on any D blade of the cluster.

Further to the illustrative embodiment the N blade and D blade are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the blades may be implemented as pieces of code within a single operating system process. Communication between an N blade and D blade is thus illustratively effected through the use of message passing between the blades although in the case of remote communication between an N blade and D blade of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between blades processes is the Inter Process Communication IPC mechanism. The protocol used with the IPC mechanism is illustratively a generic file and or block based agnostic CF protocol that comprises a collection of methods functions constituting a CF application programming interface API . Examples of such agnostic protocols are the SpinFS and SpinNP protocols available from Network Appliance Inc. The SpinFS protocol is described in the above referenced U.S. Patent Application Publication No. US 2002 0116593.

The CF interface module implements the CF protocol for communicating file system commands among the blades of cluster. Communication is illustratively effected by the D blade exposing the CF API to which an N blade or another D blade issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N blade encapsulates a CF message as i a local procedure call LPC when communicating a file system command to a D blade residing on the same node or ii a remote procedure call RPC when communicating the command to a D blade residing on a remote node of the cluster. In either case the CF decoder of CF interface on D blade de encapsulates the CF message and processes the file system command.

The volumes organized by the file system of the D blade are further organized as aggregates. is a diagram illustrating an exemplary aggregate in accordance with an embodiment of the invention. Luns blocks directories qtrees and files may be contained within volumes such as dual vbn flexible volumes that in turn are contained within the aggregate . The aggregate is illustratively layered on top of the RAID system which is represented by at least one RAID plex depending upon whether the storage configuration is mirrored wherein each plex comprises at least one RAID group . Each RAID group further comprises a plurality of disks e.g. one or more data D disks and at least one P parity disk.

Whereas the aggregate is analogous to a physical volume of a conventional storage system the volume such as a flexible volume is analogous to a file within that physical volume. That is the aggregate may include one or more files wherein each file contains a flexible volume and wherein the sum of the storage space consumed by the flexible volumes is physically smaller than or equal to the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume while each embedded flexible volume within a file utilizes a logical vvbn space to organize those blocks e.g. as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file which locations are then translated to dbns on disks. Since the flexible volume is also a logical volume it has its own block allocation structures e.g. active space and summary maps in its vvbn space.

A container file is a file in the aggregate that contains all blocks used by a flexible volume. The container file is an internal to the aggregate feature that supports a flexible volume illustratively there is one container file per flexible volume. Similar to a pure logical volume in a file approach the container file is a hidden file not accessible to a user in the aggregate that holds every block in use by the flexible volume. The aggregate includes an illustrative hidden meta data root directory that contains subdirectories of flexible volumes 

Specifically a physical file system WAFL directory includes a subdirectory for each flexible volume in the aggregate with the name of subdirectory being a file system identifier fsid of the flexible volume. Each fsid subdirectory flexible volume contains at least two files a filesystem file and a storage label file. The storage label file is illustratively a 4 kB file that contains meta data similar to that stored in a conventional raid label. In other words the storage label file is the analog of a raid label and as such contains information about the state of the flexible volume such as e.g. the name of the flexible volume a universal unique identifier uuid and fsid of the flexible volume whether it is online being created or being destroyed etc.

In an exemplary embodiment a data container is represented in the write anywhere file system as an inode data structure adapted for storage on the disks . An inode not shown includes a meta data section not shown and a data section not shown . The information stored in the meta data section of each inode describes the data container e.g. a file and as such includes the type e.g. regular directory vdisk of file its size time stamps e.g. access and or modification time and ownership i.e. user identifier UID and group ID GID of the file. The meta data section also includes a generation number and a meta data invalidation flag field. As described further herein the meta data invalidation flag field is used to indicate whether meta data in this inode is usable or whether it should be re acquired from the MDV see . The contents of the data section of each inode may be interpreted differently depending upon the type of file inode defined within the type field. For example the data section of a directory inode contains meta data controlled by the file system whereas the data section of a regular inode contains file system data. In this latter case the data section includes a representation of the data associated with the file.

Specifically the data section of a regular on disk inode may include file system data or pointers the latter referencing 4 kB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks. Given the restricted size e.g. 128 bytes of the inode file system data having a size that is less than or equal to 64 bytes is represented in its entirety within the data section of that inode. However if the length of the contents of the data container exceeds 64 bytes but less than or equal to 64 kB then the data section of the inode e.g. a first level inode comprises up to pointers each of which references a 4 kB block of data on the disk.

Moreover if the size of the data is greater than 64 kB but less than or equal to 64 megabytes MB then each pointer in the data section of the inode e.g. a second level inode references an indirect block e.g. a first level L block that contains 1024 pointers each of which references a 4 kB data block on disk. For file system data having a size greater than 64 MB each pointer in the data section of the inode e.g. a third level L inode references a double indirect block e.g. a second level L block that contains 1024 pointers each referencing an indirect e.g. a first level L block. The indirect block in turn that contains 1024 pointers each of which references a 4 kB data block on disk. When accessing a file each block of the file may be loaded from disk into the memory .

When an on disk inode or block is loaded from disk into memory its corresponding in core structure embeds the on disk structure. The in core structure is a block of memory that stores the on disk structure plus additional information needed to manage data in the memory but not on disk . The additional information may include e.g. a dirty bit. After data in the inode or block is updated modified as instructed by e.g. a write operation the modified data is marked dirty using the dirty bit so that the inode block can be subsequently flushed stored to disk. The in core and on disk format structures of the WAFL file system including the inodes and inode file are disclosed and described in the previously incorporated U.S. Pat. No. 5 819 292 titled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER ACCESSIBLE READ ONLY COPIES OF A FILE SYSTEM by David Hitz et al. issued on Oct. 6 1998.

A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes or flexible volume of a storage system such as node . An example of such a file system layout is described in U.S. patent application Ser. No. 10 836 817 titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT by John K. Edwards et al. and assigned to Network Appliance Inc. The underlying physical volume is the aggregate comprising one or more groups of disks such as RAID groups of the node . The aggregate has its own physical volume block number pvbn space and maintains meta data such as block allocation structures within that pvbn space. Each flexible volume has its own virtual volume block number vvbn space and maintains meta data such as block allocation structures within that vvbn space. Each flexible volume is a file system that is associated with a container file the container file is a file in the aggregate that contains all blocks used by the flexible volume. Moreover each flexible volume comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.

In one embodiment pvbns are used as block pointers within buffer trees of files such as file stored in a flexible volume. This hybrid flexible volume embodiment involves the insertion of only the pvbn in the parent indirect block e.g. inode or indirect block . On a read path of a logical volume a logical volume vol info block has one or more pointers that reference one or more fsinfo blocks each of which in turn points to an inode file and its corresponding inode buffer tree. The read path on a flexible volume is generally the same following pvbns instead of vvbns to find appropriate locations of blocks in this context the read path and corresponding read performance of a flexible volume is substantially similar to that of a physical volume. Translation from pvbn to disk dbn occurs at the file system RAID system boundary of the storage operating system .

In an illustrative dual vbn hybrid flexible volume embodiment both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a file. That is the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks e.g. level L indirect blocks inode file level L blocks. is a diagram illustrating another exemplary buffer tree in accordance with an embodiment of the invention. A root top level inode such as an embedded inode references indirect e.g. level blocks . Note that there may be additional levels of indirect blocks e.g. level level depending upon the size of the file. The indirect blocks and inode contain pvbn vvbn pointer pair structures that ultimately reference data blocks used to store the actual data of the file.

The pvbns reference locations on disks of the aggregate whereas the vvbns reference locations within files of the flexible volume. The use of pvbns as block pointers in the indirect blocks provides efficiencies in the read paths while the use of vvbn block pointers provides efficient access to required meta data. That is when freeing a block of a file the parent indirect block in the file contains readily available vvbn block pointers which avoids the latency associated with accessing an owner map to perform pvbn to vvbn translations yet on the read path the pvbn is available.

In addition to being embodied as a container file having level blocks organized as a container map the filesystem file includes block pointers that reference various file systems embodied as flexible volumes . The aggregate maintains these flexible volumes at special reserved inode numbers. Each flexible volume also has special reserved inode numbers within its flexible volume space that are used for among other things the block allocation bitmap structures. As noted the block allocation bitmap structures e.g. active map summary map and space map are located in each flexible volume.

Specifically each flexible volume has the same inode file structure content as the aggregate with the exception that there is no owner map and no WAFL fsid filesystem file storage label file directory structure in a hidden meta data root directory . To that end each flexible volume has a volinfo block that points to one or more fsinfo blocks each of which may represent a snapshot along with the active file system of the flexible volume. Each fsinfo block in turn points to an inode file that as noted has the same inode structure content as the aggregate with the exceptions noted above. Each flexible volume has its own inode file and distinct inode space with corresponding inode numbers as well as its own root fsid directory and subdirectories of files that can be exported separately from other flexible volumes.

The storage label file contained within the hidden meta data root directory of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system such as the volume name that information is loaded into the storage label file . Illustratively the storage label file includes the name of the associated flexible volume the online offline status of the flexible volume and other identity and state information of the associated flexible volume whether it is in the process of being created or destroyed .

In an exemplary embodiment the N blade of each node accesses a configuration table that maps the SVS ID of a data container handle to a D blade that owns services the data container within the clustered computing environment. A volume location database VLDB is capable of tracking the locations of volumes and aggregates of nodes . Specifically the VLDB includes a plurality of entries which in turn provide the contents of entries in the configuration table among other things these VLDB entries keep track of the locations of the flexible volumes hereinafter generally volumes 510 and aggregates within the clustered computing environment. is a diagram illustrating an exemplary VLDB volume entry in accordance with an embodiment of the invention. Further is a diagram illustrating an exemplary VLDB aggregate entry in accordance with an embodiment of the invention. Thus examples of VLDB entries include the VLDB volume entry and the VLDB aggregate entry .

The VLDB entry of includes a volume ID field an aggregate ID field and in alternate embodiments additional fields . The volume ID field contains an ID that identifies a volume used in a volume location process. The aggregate ID field identifies the aggregate containing the volume identified by the volume ID field . Likewise illustrates an exemplary VLDB aggregate entry . The VLDB aggregate entry includes an aggregate ID field a D blade ID field and in alternate embodiments additional fields . The aggregate ID field contains an ID of a particular aggregate in the clustered computing environment. The D blade ID field contains an ID of the D blade hosting the particular aggregate identified by the aggregate ID field .

The VLDB illustratively implements a RPC interface e.g. a Sun RPC interface which allows the N blade to query the VLDB. When encountering contents of a data container handle that are not stored in its configuration table the N blade sends an RPC to an VLDB process as described in reference to . In response the VLDB process returns to the N blade the appropriate mapping information including an ID of the D blade that owns the data container. The N blade caches the information in its configuration table and uses the D blade ID to forward the incoming request to the appropriate data container. All functions and interactions between the N blade and D blade are coordinated on a cluster wide basis through the collection of management processes and the RDB library user mode applications further described herein.

The present invention relates to a storage system architecture illustratively comprising two or more volumes distributed across a plurality of nodes of a clustered computing environment. The volumes are organized as a SVS and configured to store content of data containers such as files and luns served by the cluster in response to multi protocol data access requests issued by clients . Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the clustered computing environment. To facilitate a description and understanding of the present invention data containers are hereinafter referred to generally as files. 

According to an embodiment of the invention the SVS comprises a meta data volume MDV and one or more data volumes DV . The MDV is configured to store a canonical copy of meta data including access control lists ACLs and directories associated with all files stored on the SVS whereas each DV is configured to store at least data content of those files. For each file stored on the SVS one volume is designated the CAV and to that end is configured to store cache certain rapidly changing attribute meta data associated with that file to thereby offload access requests that would otherwise be directed to the MDV. In the illustrative embodiment described herein determination of the CAV for a file is based on a simple rule designate the volume holding the first stripe of content data for the file as the CAV for the file. Not only is this simple rule convenient but it also provides an optimization for small files. That is a CAV may be able to perform certain operations without having to communicate with other volumes of the SVS if the file is small enough to fit within the specified stripe width. Ideally the first stripes of data for files are distributed among the DVs of the SVS to thereby facilitate even distribution of CAV designations among the volumes of the SVS. In an alternate embodiment data for files is striped across the MDV and the DVs.

To manage the allocated data which are striped across multiple volumes illustrates a collection of management processes in accordance with an embodiment of the invention. The management processes execute as user mode applications on the storage operating system to provide management of configuration information i.e. management data for the nodes of the clustered computing environment. To that end the management processes include a management framework process and a volume location database VLDB process each utilizing a data replication service RDB linked as a library. The management framework provides a user to an administrator interface via a command line interface CLI and or a web based graphical user interface GUI . The management framework is illustratively based on a conventional common interface model CIM object manager that provides the entity to which users system administrators interact with a node in order to manage the cluster. The VLDB process is a database process that tracks the locations of various storage components e.g. SVSs flexible volumes aggregates etc. within the cluster to thereby facilitate routing of requests throughout the cluster.

The management processes have interfaces to are closely coupled to RDB . The RDB comprises a library that provides a persistent object store storing of objects for the management data processed by the management processes. Notably the RDB replicates and synchronizes the management data object store access across all nodes of the cluster to thereby ensure that the RDB database image is identical on all of the nodes . At system startup each node records the status state of its interfaces and IP addresses those IP addresses it owns into the RDB database.

According to the storage system architecture described herein a plurality of SVS operations enable efficient and accurate serving of file and other data container content distributed across volumes of a SVS. These SVS operations include among others create file delete file retrieve attributes of file write modify attributes of file read file and write file operations. is a diagram illustrating a striped volume set SVS in accordance with an embodiment of the invention. The SVS illustratively comprises three volumes namely MDV and two DVs . It should be noted that in alternate embodiments additional and or differing numbers of volumes may be utilized in accordance with the present invention. Illustratively the MDV stores a plurality of inodes including a root directory RD inode a directory DIR inode file F inodes and an ACL inode . Each of these inodes illustratively includes meta data M associated with the inode. In the illustrative embodiment each inode on the MDV does not include data D however in alternate embodiments the MDV may include user data.

In contrast each DV stores only file F inodes and ACL inode . According to the inventive architecture a DV does not store directories or other device inodes constructs such as symbolic links however each DV does store F inodes and may store cached copies of ACL inodes that are arranged in the same locations as their respective inodes in the MDV . A particular DV may not store a copy of an inode until an I O request for the data container associated with the inode is received by the D blade serving a particular DV. Moreover the contents of the files denoted by these F inodes are periodically sparse according to SVS striping rules as described further herein. In addition since one volume is designated the CAV for each file stored on the SVS DV is designated the CAV for the file represented by inode and DV is the CAV for the files identified by inodes . Accordingly these CAVs cache certain rapidly changing attribute meta data M associated with those files such as e.g. file size as well as access and or modification time stamps.

According to another aspect of the invention the SVS is associated with a set of striping rules that define a stripe algorithm a stripe width and an ordered list of volumes within the SVS. The striping rules for each SVS are illustratively stored as an entry of VLDB process and accessed by SVS ID. is a diagram illustrating a VLDB SVS entry in accordance with an embodiment the invention. The VLDB entry includes a SVS ID field and one or more sets of striping rules . In alternate embodiments additional fields may be included. The SVS ID field contains the ID of a SVS which in operation is specified in data container handle .

Each set of striping rules illustratively includes a stripe width field a stripe algorithm ID field an ordered list of volumes field and in alternate embodiments additional fields . The striping rules contain information for identifying the organization of a SVS. For example the stripe algorithm ID field identifies a striping algorithm used with the SVS. In the illustrative embodiment multiple striping algorithms could be used with a SVS accordingly stripe algorithm ID is needed to identify which particular algorithm is utilized. Each striping algorithm in turn specifies the manner in which file content is apportioned as stripes across the plurality of volumes of the SVS.

The stripe width field specifies the size width of each stripe. The ordered list of volumes field contains the IDs of the volumes comprising the SVS. In an illustrative embodiment the ordered list of volumes comprises a plurality of tuples comprising of a flexible volume ID and the aggregate ID storing the flexible volume. Moreover the ordered list of volumes may specify the function and implementation of the various volumes and striping rules of the SVS. For example the first volume in the ordered list may denote the MDV of the SVS whereas the ordering of volumes in the list may denote the manner of implementing a particular striping algorithm e.g. round robin. To determine the location of a D blade to which to transmit a CF message the N blade may first retrieve a SVS entry to acquire the striping rules and list of volumes associated with the SVS. The N blade then executes a process to locate such as a Locate function not shown to identify the appropriate volume to which to direct an operation. Thereafter the N blade may retrieve the appropriate VLDB volume entry to identify the aggregate containing the volume and the appropriate VLDB aggregate entry to ultimately identify the appropriate D blade . The protocol server of N blade then transmits the CF message to the D blade .

In accordance with an illustrative round robin striping algorithm volume A contains a stripe of file content or data D followed in sequence by two stripes of sparseness S another stripe of data D and two stripes of sparseness S . Volume B on the other hand contains a stripe of sparseness S followed in sequence by a stripe of data D two stripes of sparseness S another stripe of data D and a stripe of sparseness S . Volume C continues the round robin striping pattern and to that end contains two stripes of sparseness S followed in sequence by a stripe of data D two stripes of sparseness S and another stripe of data D .

Moreover is a diagram illustrating an exemplary striping table in accordance with an embodiment of the invention. The striping table is an allocation structure that describes the distribution of the chunks of striped data among the volumes. Alternatively described each location of a chunk of data among the volumes is identified by the striping table . Thus the striping table illustrates that striped data is located at a first location on DV at a second location on DV at a third location on DV and a fourth location at DV . In the illustrated embodiment the striped data comprise a file that is striped across multiple volumes of a striped file system. Thus a geometry or organization of the striped file system is illustrated by .

Advantageously by striping files across multiple volumes that are distributed among multiple storage systems volume utilization efficiency can be increased and hot spotting can be prevented or mitigated. Further by implementing restriping processes of exemplary embodiments of the present invention as further described herein the restriping processes can limit the amount of data movement among the D blades . Increasing volume utilization efficiency results from distributing data evenly throughout the volumes. Specifically any one volume should not be visited more frequently during a data access operation than any other volume. Preventing hot spotting results from preventing the storage of two contiguous stripes of data for the same file. Thus one volume should not become a bottleneck when accessing particular regions of the file. Further the restriping processes are implemented when changing the geometry of the striped file system illustrated by . For example when adding a volume to or removing a volume from the striped file system each of the restriping processes rearrange the contents of the allocation structure which correspondingly moves striped data around the volumes. At least one restriping process is implemented in response to the modification of the clustered computing environment by adding or removing volumes. The restriping processes will be further described in reference to .

Accordingly the striping table of illustrates that the sequence of striped data of a file striped across three volumes is located on DV DV DV DV DV DV DV DV DV DV DV and DV . Specifically exemplary restriping processes are now described when adding and subsequently removing one volume such as DV not shown . Specifically when adding a volume to a cluster the restriping process is an evolving algorithm. Alternatively when removing a volume from a cluster the restriping process is a devolving algorithm. Thus by implementing at least one restriping process when changing a geometry data can be distributed optimally while preventing hot spotting behavior. Further the restriping process minimizes the amount of time to modify the striping table.

During an exemplary evolving algorithm illustrated by the length of the striping table is increased wherein locations equate to the total number of volumes added. Further the contents of the striping table are grouped by the total number of volumes. Within each group counters are determined such that the counters identify the number of times an identifier appears in the group. Thus in group count equals two because the identifier for DV appears twice. The identifier for DV appears once resulting in count equal to one and the identifier for DV appears once resulting in count equal to one. However in group the identifier for DV appears once the identifier for DV appears twice and the identifier for DV appears once. Subsequently within each group the counter with the highest value is replaced with an identifier corresponding to the newly added fourth volume DV . Thus as illustrated by striping table the duplicate reference within each group is replaced by the new identifier 3. It should be appreciated that the evolving algorithm is implemented each time a volume is added to the cluster which correspondingly modifies the striping table .

When removing a volume from the cluster a restriping process is also implemented for each volume removed from the cluster. Such a restriping process is a devolving algorithm. The striping table is once more grouped wherein each group is the total number of volumes resulting from the volume removal. Here the total is three because the striping table identifies the location of striped data among four volumes. In each group that includes an identifier to the now removed fourth volume the identifier should be replaced. The replacement identifier is selected from the volume that is least represented within the group. For example by keeping a count of the number of references to a volume within a group the counter having the least number of references can be replaced. Specifically group includes an identifier for DV and DV but no identifier for DV . Thus the identifier 1 is inserted as a content of the striping table . Correspondingly group includes an identifier for DV and DV but no identifier for DV . Thus the identifier 2 is inserted in the striping table .

In other exemplary embodiments of the present invention implementing the evolving and devolving algorithms illustrated in it should be appreciated that the striping table need not increase or decrease in size. Particularly the striping table can remain a constant size. Such an exemplary striping table size can include entries. Thus other striping table sizes are possible that remain constant during the implementation of processes that change the allocation of data among the striped volume set.

Subsequently in operation a decision is made whether to add or remove volumes. If multiple volumes are added and or removed then the modifications to the SVS results in the implementation of a restriping process. The restriping process rearranges the contents of the striping table which correspondingly moves the chunks of data within the SVS. A restriping process is said to be an evolving algorithm when adding a volume and a devolving algorithm when removing a volume. For each volume modification the appropriate restriping process is implemented once. Accordingly when adding four volumes four implementations of an evolving algorithm occur. For example when adding a volume operation describes the operations for applying an evolving algorithm for each added volume. Alternatively when removing a volume operation describes the operations for applying a devolving algorithm for each removed volume. After applying a restriping process for each modification to the SVS both operations and return to operation which determines whether to add or remove volumes.

In yet another exemplary embodiment of the present invention there may be only one replacement of a volume reference within a group. Thus although multiple volume reference replacements within a group may slightly improve data distribution among the striped volume set there may be an incurred cost of significantly worsening restriping characteristics. Such a worsening restriping characteristic is the lessening of a round robin distribution of data among the striped volume set.

The restriping processes described above are implemented by exemplary embodiments of the present invention. However other restriping process may be implemented instead of or in conjunction with the restriping process previously described. For example another restriping process involves the replacement of every N 1 th reference in the striping table. With reference to the striping table is rearranged when adding a volume to the SVS. Thus for a three volume set with one added volume the 3 1 th i.e. fourth volume reference in the striping table is replaced by the new volume reference. For example the fourth identifier of 0 is changed to 3 the fourth identifier of 1 is changed to 3 and the fourth identifier of 2 is changed to 3. However for larger SVS sizes hot spotting increases and volume utilization decreases when implementing this restriping process. Thus improvements to this restriping process are illustrated by other restriping processes described below.

For example illustrate other restriping processes that may be implemented by other exemplary embodiments of the present invention. Specifically is a diagram illustrating another restriping process in accordance with an embodiment of the invention. The illustrated striping table can be labeled for clarity with A through L. Further the contents of the striping table illustrate a round robin distribution of the striped data among the SVS. Thus A through C D though F G through I etc. illustrate that volumes and are identified as containing striped data. Following the N 1 th restriping process above the fourth identifier is replaced with the new volume identifier of 3. However to improve the distribution of volume usage a permutation operation e.g. a shuffle operation similar to shuffling a deck of playing cards is added to further reorder the location of striped data. The permutation can be a fixed permutation deterministically generated by pseudorandom techniques as described below. If the assignment of stripes to volumes is recorded in table form then the permutation could reorder the entries of the table in a pseudorandom but deterministic fashion. The result will have exactly the same overall distribution of the data among the volumes but may achieve a better localized distribution and balance.

Specifically a shuffle operation may include a permutation of identifiers of the striping table of by moving an identifier at a first location I to a second location 2 I for I

In other exemplary embodiments a predetermined permutation stored as a linear array in memory e.g. computed in advance of establishing the SVS can be applied to the striping table. Thus a striping table can be developed using the shuffle operation described above and subsequently applying the predetermined permutation. Further multiple predetermined permutations can be stored whether determined randomly or pseudo randomly generated for application to the striping table.

The next restriping process as illustrated by does not involve shuffling. Specifically the process applies a permutation to sort one striping table of an SVS with having an exemplary size into round robin order while applying exactly the same permutation to another striping table for a different size SVS. For example any two tables are generated by any of the processes herein described. Preferably the process results in a striping table that describes an SVS with a round robin layout since round robin layouts have many good properties such as an even distribution of data in the SVS. However when modifying the SVS the goal is to only move I V 1 of the stripes of an SVS with V number of volumes. It should be appreciated that although the processes described herein are applied to obtain round robin layouts other suitable layouts are possible that have good properties. Such good properties are those that were previously described regarding hot spotting etc.

In yet another embodiment is a diagram illustrating another restriping process in accordance with an embodiment of the invention. In this exemplary embodiment two striping tables table and table are utilized wherein table l represents the current number of volumes in the SVS and table represents the SVS with the additional volume. Table illustrates growing the striping table one volume at a time to three volumes. Initially the striping table is populated by identifiers to volume on striping table . After adding one volume striping table illustrates a round robin of two volumes having identifiers of and . Specifically by replacing the N 1 th volume reference round robin load balancing occurs. Upon the addition of a third volume and the insertion of the identifier 2 to table striping table results.

Correspondingly table is grown from an initial SVS having one volume on striping table . With each additional volume the N 1 th occurrence of each unique identifier is replaced in table . Thus striping table illustrates identifiers for volumes and striping table illustrates identifiers for volumes and and striping table illustrates identifiers for volumes and . Consequently the contents of striping table are rearranged during a swap operation along with the contents of striping table . The rearrangement of table to illustrate identifiers for round robin striped data is thus mimicked on table to also obtain round robin striped data. However this restriping process while an improvement over the restriping process of may experience volume utilization efficiency degradation for larger volume sets.

In another embodiment of the process using two tables includes generating the two tables for the two values of V e.g. Table and V 1 e.g. Table using any process described herein. Then when adding volume d the process involves moving every 1 d remaining stripes. A permutation of Table results in a striping table that describes a round robin layout. One method of permutation is the reordering of the striping table by selecting the next unmoved entry with value I modulo v when filling location L During the performance of a set of moves on Table for the number of volumes V to coerce it to be round robin simultaneous moves on Table are performed for the number of volumes V 1. The result of this permutation will be a layout table which has the desired properties of being close to the table for V. The desired properties result because most of the entries in the two tables were the same initially and simultaneous or near simultaneous permutations occurred for all the entries in the two tables in exactly the same way. Further by using the above technique a striping table for an SVS of size V 1 would require the movement of 1 V 1 of the data. Thus for any striping table representing a layout of identifiers in some number of V volumes the striping table can be reordered permuted in one or more ways to produce a round robin layout of identifiers among the volumes.

Another restriping process is illustrated by in accordance with an embodiment of the invention. This restriping process is similar to the replacement of N 1 volume references as described above with respect to but instead of replacing the N 1 th volume reference the N 1 th identifier on the striping table is replaced regardless of the contents. For example after adding a fourth volume to the three volume SVS referenced by striping table the fourth identifier is replaced with a 3 regardless of the volume reference already identified in the three volume SVS. Regarding this restriping process although identifiers are now scattered throughout the striping table which increases the distribution of volume references overall volume utilization efficiency may not be optimal.

Accordingly is a diagram illustrating another restriping process in accordance with an embodiment of the invention. For example after generating N 1 groups counters are recorded on a counter list that count the total number of volume references that exist in striping table . Specifically volume is referenced eight times while volumes and are referenced six times each on the striping table . By examining the counter list the process can replace the volume reference having the highest counter. Thus volume is replaced three times until the counter is decreased to five volume references which is less than the other counters on the counter list . While volume utilization efficiency is slightly reduced from the process illustrated by multiple replacements in the same group increase hot spotting behavior. Further the process may suffer from sub optimal restriping behavior because of multiple replacements that can occur for each group.

Although the various restriping processes described above can be classified as evolving and devolving algorithms other embodiments of the present invention can implement evolving algorithms without ever implementing devolving algorithms. For example is a flowchart of operations for evolving a striping table in accordance with an embodiment of the invention. The operations begin in operation by creating a striping table for one volume. As the SVS grows by adding one volume at a time to the SVS operation evolves the striping table and store each striping table per number of volumes. For example a record is stored of the configuration of a striping table of one volume of two volumes of three volumes etc. If a volume is removed from the SVS then the records can be examined. Specifically in operation if devolving the striping table then the evolution of the striping table requires access to a previously stored striping table.

Alternatively in other exemplary embodiments of the present invention not shown operations for devolving a striping table can be implemented without the implementation of an evolving algorithm. For example a striping table can be implemented with round robin for some arbitrary striped volume set having a maximum amount of volumes. Such a maximum amount of volumes can be 255 volumes. Thus when shrinking e.g. if starting from 255 volumes the SVS when removing volumes the various configurations of striping tables resulting from implementing devolving algorithms can be stored for future use similar to the use of recorded striping table configurations of . Specifically if evolving the striping table then the devolution of the striping table requires access to previously stored striping tables. It should be appreciated that any suitable number of volumes for a maximum sized SVS is possible as long as only devolving algorithms are implemented to achieve striping table configurations.

The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Specifically it should be noted that the principles of the present invention may be implemented on non distributed file systems. Furthermore while this description has been written in terms of N and D blades the teachings of the present invention are equally suitable to systems where the functionality of the N and D blades are implemented in a single system. The single system relates to a device or an apparatus for performing these operations. The apparatus can be specially constructed for the required purpose or the apparatus can be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines can be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations. Alternately the functions of the N and D blades may be distributed among any number of separate systems wherein each system performs one or more of the functions.

Embodiments of the present invention can be managed by a computing environment management system. For example a computing environment management system such as Data Fabric Manager DFM and the like developed by Network Appliance Inc. of Sunnyvale Calif. can manage the clustered computing environment. With the above embodiments in mind it should be understood that the invention can employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical magnetic optical signals or the like that are capable of being stored transferred combined compared and otherwise manipulated. Any of the operations described herein that form part of the invention are useful machine operations. Additionally the procedures processes and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

