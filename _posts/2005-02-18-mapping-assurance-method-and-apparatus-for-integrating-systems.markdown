---

title: Mapping assurance method and apparatus for integrating systems
abstract: A method and apparatus is provided to assure transformations between applications in an integration project. This assurance of transformations between applications includes mapping one or more related fields from a set of fields between the one or more source applications and the one or more target applications according to a set of integration objectives, checking a type compatibility for each of the one or more related fields mapped between the one or more source applications and the one or more target applications and indicating a mapping status according to the type compatibility between the source applications and the target applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09052879&OS=09052879&RS=09052879
owner: International Business Machines Corporation
number: 09052879
owner_city: Armonk
owner_country: US
publication_date: 20050218
---
Many companies leverage computer systems and software applications to improve their efficiency and organization in business. Often these systems are integrated together allowing information from one software application or system to be used or analyzed by another software application or system. Benefits associated with integrating and using these computer systems and software in business are numerous and include tighter control over inventory improved financial forecasting streamlined information flow internally and externally and sales force automation.

The various benefits of leveraging computer technology generally justifies the hiring of large information technology IT staff to keep these computer systems operational and communicating with each other. Often these IT departments are saddled with the task of integrating many disparate computer systems and software applications in attempt to make corporate information flow more freely and securely.

Unfortunately the complexity of integrating these large computer systems and software applications in a company has made systems integration a daunting and expensive task. Systems integration projects have become increasingly complicated requiring specialized knowledge of applications protocols communications hardware and other areas that the IT staff at a given company may not possess. Even with the proper knowledge and training most IT departments are too small to complete large scale systems integration projects in a reasonable time frame.

Consequently a large number of system integration projects require customized development completed using consultants or outsourced to system integrators that specialize in integrating these large scale systems. The solutions involve integrating the data and business logic between several existing applications and frequently involve complex solutions. Because the work is outsourced and or complex these customized solutions can also be very expensive. Maintaining software as the companies grow and their needs change may also cost a great deal of money as the same consultants may be needed after the initial systems integration effort is put in place.

In attempt to reduce costs and expedite the integration many companies are exploring system integration tools methodologies as an alternative to customized software development. These solutions include enterprise application integration EAI solutions and application server technologies. The EAI solution provides a solution to some of the system integration problems but requires a company to commit to a proprietary platform. Application server solutions are also useful but also involve proprietary protocols. Scalability is also a problem with these methodologies as companies grow and demand more processing power and throughput from their systems.

One aspect of the present invention includes a method apparatus and computer program product to assure transformations between applications in an integration project. This assurance of transformations between applications includes mapping one or more related fields from a set of fields between the one or more source applications and the one or more target applications according to a set of integration objectives checking a type compatibility for each of the one or more related fields mapped between the one or more source applications and the one or more target applications and indicating a mapping status according to the type compatibility between the source applications and the target applications.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features and advantages of the invention will become apparent from the description the drawings and the claims.

Aspects of the present invention provide one or more of the following advantages. Source and target applications can be integrated together in a given integration project with fewer errors. Issues with type compatibility between the fields in a source application and a target application are checked prior to run time. Type compatibility problems are flagged as the fields from the source application are mapped to certain specific fields in the target application. Resolving errors and warnings in advance makes errors due to type compatibility between fields in a source and target application less likely to occur during runtime.

In certain cases implementations of the present invention can be configured to disallow compilation or further processing if a source and target application have field or type compatibility problems. Conditionally compiling the mapping in this manner keeps field type compatibility issues to a minimum. Type compatibility related issues are necessarily addressed during the mapping phase rather than later during the runtime operation when they are more subtle and difficult to detect.

Aspects of the present invention provide visual indicators to make the mapping tools in an integration project easier to use. For example type compatibility problems between the source applications and the target applications are displayed visually as mappings between the fields are made. A user can utilize these visual indicators to address each type compatibility problems in sequence until an acceptable mapping status is indicated. To measure overall mapping progress a completion status indicator considers the mapping completed and the additional mapping required to complete the project. Both indicators provide immediate visual feedback to guide a user through the mapping of fields and application integration.

In either implementation above or in other configurations it is often necessary for applications in one or more application sets to communicate across application network in accordance with implementations of the present invention to other applications in other application sets. Typically enterprise applications need to share critical information about a company or business as well as integrate different workflow requirements. For example a manufacturing or shipping application providing just in time services may need to receive information gathered from purchase orders in a sales force automation application. Workflow in the manufacturing application may require payment to be made in advance before starting manufacturing and also may need to coordinate the manufacturing with another materials procurement or inventory management application located elsewhere in an enterprise. At each junction applications need to accurately and efficiently share information and ensure certain steps are performed according to specific workflow requirements needed in each area. This complex process of exchanging data and coordinating workflow requirements is facilitated and automated in accordance with the present invention.

Application network can also provides secure communications capabilities between the applications in application sets and and users operating these various applications. In this example implementation application network includes application router application router application router application router and application router configured to transmit application data to each other over conventional network using secure methods involving encryption authentication and authorization of users and applications. Application level security features implemented within application routers allows access or denies access based on detailed transactional and or application information in addition to storage partitions file distinctions or other logical storage boundaries that may exist.

For example a first application may be granted access to data from a second application if the data associated with the second application was previously or originally created by the first application. Of course the first application can be granted various levels or read and or write permissions by the second application explicitly after data in an application has been created. Application level security granularity allows application data to be securely administered based on transactions or records even if the data is under the same enterprise applications. Alternatively if lower security is required then application routers can be configured to share all data between different applications associated with one or more application routers.

Once security is determined and processed application data travels over conventional network carried by TCP IP SNA Novell Netware or any other similar network protocol capable of providing access to a layered network communication model or any other equivalent general purpose networking protocol. In practice conventional network also includes conventional routers switches repeaters and other networking devices familiar to those skilled in the art and used for general purpose broadband or local area networking.

Application routers and include conventional routing technology along with application routing functionality in accordance with implementations of the present invention. Application routing operations receive application data convert the application data into a neutral format and then route the data to the appropriate application through one or more application routers in application network . Further application routers convert the neutral format data back into the proprietary application protocol when communicating data back to an application.

Published information facilitates associating one application in the application network with one or more other applications on the application network . Application routers exchange metadata and other information about different applications and then associates the different applications together. This association process maps data fields from the data structures used in a first application the source application with corresponding data fields from the data structures of a second application the target application. Field type and other type processing performed in accordance with the implementations of the present invention ensures these field mappings are going to be compatible during run time. Many of the type compatibility issues deal with data formats and cardinality issues associated with groups of data. In some cases lower level compatibility may require swapping byte order or filing data with default values to accommodate low level formatting differences that may exist between data in the various data structures. Once the mapping has been assured application routing commences between the source and target applications as they are processing application data .

The fields in source application work area include a hierarchical arrangement of fields including a purchase order PO header to describe the overall purchase order and an item list with a sequence of individual items. The PO header and item list can further be classified as complex types as they contain additional fields rather than directly holding data from the source application. In contrast PO identifier name and data can be classified as primitive types as they contain substantive information from the particular application. Likewise item identifier description and quantity are primitive types as they include substantive information about each individual item in item list .

Fields in target application work area also include a hierarchical arrangement of fields including order header for describing details of the purchase order and product list with the sequential listing of individual products and descriptive information. This example illustrates that the source application and the target application may contain similar information but define fields differently or potentially have different types associated with the fields as described below. In this part of the example each order header is a complex type containing primitive types name data and order identifier . Product list and product are both complex types as they both include additional fields as illustrated. Each product includes product details product quantity and product id . Of course these are only examples provided to assist in describing aspects of the invention and many more complex or different examples can also be created other than those depicted and described in relationship to .

In operation completion indicator measures how many mappings in the integration project have been completed with an acceptable or guaranteed mapping compared with those not yet completed or resulting in an error. In general the completion indicator indicates the mapping is complete when all of the required mappings have been made between the source application and target application without any errors indicated. Compared to the required mappings optional mappings are not required to complete a mapping operation. However any optional mapping that is attempted also need be done without error to achieve completion status for the mapping.

In one implementation the mapping may also be considered complete according to completion indicator even when some of the mappings result in a warning or guaranteed status as long as none has errors. Alternatively completion indicator can be configured to indicate completion only when all of the mappings have been made with a guaranteed status and no warnings. This latter approach would more likely result in fewer errors during runtime compared with the former approach as a result of more rigorous type checking requirements to reach completion. In either of these above or alternate approaches completion indicator can be used to disallow compilation and proceeding further if the indicator does not indicate completion status however defined.

As depicted in this example mapping status analyzes one or more mappings as specified between source application work area and target application work area . Each mapping between primitive types in the source application is compared with the primitive type in the target application to ensure data compatibility at runtime. For example PO identifier having a string type generates a warning as it may not be compatible with its mapped counterpart order identifier at runtime. This is because not all possible string types contain data compatible with an integer type.

A cardinality based warning is another different type of warning generated between item list and product list . This type of warning indicates a mismatch between the potential number of enumerated items in the target application compared with the source application. In this example item list in source application indicates a possibility of up to 10 different items yet the product list only has allocated storage for up to 5 items and thus may result in an error at runtime depending on the exact number of items being transacted. Many other types of potential mismatches between the numbers of items or types of items could be the basis of different cardinality type warnings.

Errors indicated in mapping status results when the type analysis shows no possible overlap of acceptable values in the field of a source application compared with the field of a target application. In this example date from the source application generates an error when mapped to date of the target application as it is not possible for a date type field to fit into an integer field without performing converting or manipulating the data. Similarly item identifier containing a string type in the source application also generates an error when mapped to product id of the target application as it has an integer type.

As a result of the above processing mapping status can be configured to stop further processing as errors due to cardinality type or other mismatch are likely to have negative effect on subsequent runtime processing. Alternatively one or more warnings as indicated by mapping status can be configured to allow further processing as it is not certain that a mismatch will occur during runtime and whether it could cause a runtime error. Of course a guaranteed status from mapping status indicates no warnings or errors and processing continues from the mapping to other operations needed in the overall integration project.

Alternatively some source and target applications may not be described using XML compatible languages and instead may require one or more conversion operations. If this occurs either the source the target or both the source and target applications may first be converted from a non XML based language into XML or an XML compatible language. Example non XML compatible languages can include SQL based databases variable or fixed delimited text files unformatted free form datasets and even raster images with text data. Converting the source and target applications into an XML compatible language provides a neutral language and allows for a more direct comparison of the various fields and types between the source and target applications. Instead of using XML an alternative approach would convert the source and target applications into another neutral language other than XML and a then perform a similar comparison of fields and types between the source and target applications.

Next implementations of the present invention display the fields and data types from the metadata in the source applications and target applications . Displaying the set of fields and data types exposes data relationship information between the source applications and the target applications. In one implementation the field and data types are displayed in a graphical user interface as illustrated in . For example a field may be identified as a PO Identifier and the corresponding type can be a string that holds the PO Identifier information.

Once the field and type information is understood a mapping of related fields from the source applications to the target applications occurs according to a set of integration objectives . Each field and type in the one or more source applications are associated with a field and type in one or more target applications. Mapping ensures a correspondence exists between a field in at least one source application and another field in at least one target application. The interface can be designed to enable a user or operator to identify a field and type in the source application and draw a connection to a corresponding field and type in the target application. Visually the example interface in shows this relationship with a line and arrow connected between the fields.

The set of integration objectives may provide information for integrating applications including a description of fields and guidelines for matching up different data types. For example integrating a purchase order between a source application and a target application may define both a PO Identifier and the Order Identifier as a field to hold the unique identifier for the source application and the target application respectively. One of the integration objectives may also provide details on acceptable and unacceptable type matches between different fields. If a source field PO Identifier has a type String then the integration objectives may indicate a warning when mapping this source field to an Order Identifier field in a target application as the Order Identifier field has a potentially incompatible field type of integer as illustrated in .

Mapping may also include performing one or more transformations between fields in the source and target applications. These transformations may include casting operations that change the type associated with the data in one field into another type before being stored in a second or target field. Alternatively these transformations may also include executing more complex macros JavaScript or other programs to massage the data passing between the field of a source application over to the field of a target application.

Once an initial mapping is completed implementations of the present invention check the type compatibility of the mapped fields between the source applications and the target applications . This analysis compares a potential set of values in the fields of the source application again a potential set of acceptable values in the fields of the target application. Further details on this type checking are described later herein.

Depending on the type compatibility results implementations of the present invention indicates a mapping status according to the type compatibility between the source applications and the target applications . An error status indication means one or more fields between the source applications and target applications are incompatible and cannot be mapped. The error status indication is flagged for each field mapping falling into this category of analysis. Because the error status is certain to create run time errors later when the integration is performed these failed mappings need immediate attention and correction.

Alternatively a warning indication is provided if at least one acceptable value is possible between a field mapped between a source and target application. These warning status indications are also flagged for the fields falling into this category of analysis however the integration can continue as it is not certain that a run time error will occur. To eliminate even the possibility of a run time error even the warning status indications should be investigated and resolved before actually performing the integration in a production environment. If the error indication or warning indication are not applied then the mapping between the fields is assured and the integration operations can be commenced.

Similarly it is equally important to identify acceptable values capable of being stored by the target applications . The analysis examines the type of each related field in the target application and identifies an acceptable range of values to be stored. As previously described the string type may include both alpha and numeric values while the integer value may only include numeric values. Floating point array and any other types are analyzed in a similar manner and set of rules for checking the type of each field are generated accordingly. Cardinality of the target application fields are also checked and noted for later comparison. For example a purchase order in a target application may allow for as many as 5 different items and thus has a cardinality of 5or as little as 1. In many cases the purchase order on a target application having a cardinality of 5 items would be compatible with a source application having a cardinality of 10 items or greater unless 6 or more items are actually being provided or requested in the purchase order of the source application.

Type compatibility analysis between the mapped fields in the source application and target application determines the type of indicators to provide. Initially a comparison determines if all the potential field values between the mapped fields of the target and source application are compatible . A set of type compatibility rules are generated to determine when values to be generated by the source applications overlaps with the acceptable set of values capable of being stored by the target applications. For example the type compatibility rules can include comparing the individual fields in the source application against corresponding mapped fields in the target application. It may also include comparing the cardinality between the fields in the source application and target application. For example assuming the types are compatible a cardinality of 10 items on a purchase order from a source application is always compatible with a cardinality of IO or greater on the target application since any valid number of items from the source application can be contained by the target application based on cardinality. If this situation occurs a mapping guarantee is indicated as all possible values between the mapped fields of the source and target application are compatible .

However if not all of the mapped fields are compatible then a determination is made whether at least one potential field value between each of the mapped fields is compatible . A similar analysis as previously described is performed except at least one but not all possible field values between one or more mapped fields need be compatible. If this occurs one implementation of the present invention provides a map warning as at least one field value between one or more mapped fields are compatible. Alternatively in the event no potential field values between the mapped fields are compatible then a map error is indicated as no possible field value between one or more mapped fields is compatible. In addition to the map error implementations of the present invention also prevents the mapping rule between mapped fields in source application and target application from being set as it is certain to result in a run time error when the integration is performed. Accordingly a user or operator must further investigate and resolve these mapping error indications to continue forward in integrating the source and target applications in the integration project.

The completion operation analyzes the fields and other information to identify the required fields and optional fields to be mapped between the source and target application . It is important to distinguish between required and optional mappings as the latter optional mappings can be omitted and the mapping still considered complete. For example the required fields may correspond to all of the fields in the target application as the target application may not be able to function properly without these target application fields mapped from the source application. Similarly the source application can also specify the required fields even if the required fields are in fact a small subset of all the fields in the source application. Generally the target application is used to determine the required fields as the target application can be populated from numerious different fields and locations within the source application. Essentially optional fields are those fields included in the mapping or potential mappings but not required by the target application the source application or anywhere else.

Once the required fields are identified the completion operation compares the required fields between the source application and target application with the set of fields already indicated as mapped . In the event all required fields are mapped then a completion indicator is set to indicate the mapping has been completed However if not all the required fields are mapped then partial completion is indicated typically in a percentage basis . For example if there are 100 required mappings and only 45 of them are completed than the completion indicator will provide a 45 completion indication.

In one implementation memory includes a mapping interface for source and target applications a mapping status indication component a completion indication component a type compatibility component a type transformation and analysis component and a run time module that manages system resources used when processing one or more of the above components on system .

Mapping interface for source and target applications is used to map fields between source and target applications. This interface can be implemented as a graphic user interface to enable a user to visualize and associate the fields of the applications. Alternatively the mapping interface can also include an application programming interface API that allows an initial mapping to be driven by a program having artificial intelligence fuzzy logic genetic programming or other routines capable of complex problem solving.

Mapping status indication component provides indicators for individual mappings between fields in a integration project as well as an overall status of the mappings in the integration project. For example mapping status indication component flags specific mappings between fields with warnings or errors depending on the type compatibility analysis. No indication between fields of the source and target applications indicates the individual mapping is assured to be type compatible during runtime. The overall integration project receives a warning or error status if at least one warning or error is contained within the integration project and an mapping assurance if no warnings or errors are present.

Completion indication component provides a relative measure of completion through the mapping interface depending on the status of the individual mappings. For example the completion indicator is 100 if all the mappings in an integration project are completed and there are no errors or warnings. Even if a few warnings exist it is also possible that the completion indicator is 100 as long as every source field is mapped to a target field without an error status. Conversely the completion indicator registers less than 100 completion when one or more errors exist or one or more fields from the field of a source application are not yet mapped to a field in a target application.

Type compatibility component performs type checking between fields in a source application and a target application. In one implementation a set of type compatibility rules are used to determine when the values to be generated by the one or more source applications overlap with the acceptable set of values capable of being stored by the one or more target applications. For example this includes comparing the data types of the target and source fields as well as the cardinality of the fields indicated in the complex data types.

Type transformation and analysis component identifies type transformations using casting functions macros JavaScript and other scripting routines and assist in determining type compatibility. In some cases the type transformations can be performed to correct otherwise incompatible types between a pair of fields from a source and target application.

While examples and implementations have been described they should not serve to limit any aspect of the present invention. Accordingly implementations of the invention can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Apparatus of the invention can be implemented in a computer program product tangibly embodied in a machine readable storage device for execution by a programmable processor and method steps of the invention can be performed by a programmable processor executing a program of instructions to perform functions of the invention by operating on input data and generating output. The invention can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. Each computer program can be implemented in a high level procedural or object oriented programming language or in assembly or machine language if desired and in any case the language can be a compiled or interpreted language. Suitable processors include by way of example both general and special purpose microprocessors. Generally a processor will receive instructions and data from a read only memory and or a random access memory. Generally a computer will include one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM disks. Any of the foregoing can be supplemented by or incorporated in ASICs.

While specific embodiments have been described herein for purposes of illustration various modifications may be made without departing from the spirit and scope of the invention. Accordingly the invention is not limited to the above described implementations but instead is defined by the appended claims in light of their full scope of equivalents.

