---

title: Decorating surfaces with textures
abstract: Surfaces can be decorated with texture tiling and/or texture painting using one or more sample textures, such as BTFs. In a described implementation of texture tiling, a patch-based BTF synthesis algorithm is utilized. In an example embodiment, a mesh of a target surface is re-sampled to produce a dense mesh such that there is a one-to-one correspondence between vertices of the dense mesh and pixels of an image. Patch matching is then employed with a working image that corresponds to a working patch. In an example embodiment, the patch matching is effectuated using translations and rotations of the sample texture. In a described implementation of texture painting, irregular feature(s) of a sample texture are synthesized onto a target surface. In an example embodiment, user-specified constraints as to a desired foreground feature of a sample texture and an intended foreground region of a targeted surface are factored into a graphcut operation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07602398&OS=07602398&RS=07602398
owner: Microsoft Corporation
number: 07602398
owner_city: Redmond
owner_country: US
publication_date: 20050128
---
This disclosure relates in general to decorating surfaces with textures such as bidirectional texture functions BTFs and in particular by way of example but not limitation to i tiling regular BTF samples onto a target surface and or ii painting irregular BTF samples onto a e.g. tiled surface.

Texture mapping was introduced about three decades ago as a way to add surface detail without adding geometry. Texture mapped polygons have since become the basic primitives of the standard graphics pipeline. Unfortunately texture mapped surfaces have a distinctive look that sets them apart from reality. For example they cannot accurately respond to changes in illumination and viewpoint.

Real world surfaces are usually not smooth instead they are covered with textures that arise from both spatially variant reflectance and fine scale geometry details that are often termed mesostructures . Real surfaces also exhibit imperfections e.g. dirt cracks and scratches that typically result from relatively complicated physical processes. Even three decades later capturing these surface characteristics is a challenging goal for computer graphics.

Accordingly there is a need for schemes mechanisms techniques etc. that can efficiently and or conveniently enable computer graphics to better capture spatially variant reflectance and or fine scale geometric mesostructures.

Surfaces can be decorated with one or more sample textures such as bidirectional texture functions BTFs . The decorating can involve texture tiling and or texture painting. In a described implementation of texture tiling a patch based BTF synthesis algorithm is utilized. In an example embodiment a mesh of a target surface is re sampled to produce a dense mesh such that there is a one to one correspondence between vertices of the dense mesh and pixels of an image. A working patch is found. Patch matching is then employed with a working image that corresponds to the working patch. In an example embodiment the patch matching is effectuated using both translations and rotations of the sample texture. Patch fitting is then effectuated with the corresponding working patch. In a described implementation of texture painting irregular feature s of a sample texture are synthesized onto a target surface. In an example embodiment user specified constraints as to the desired foreground feature of a sample texture and the intended foreground region of a targeted surface are factored into a graphcut operation. For instance defined constraint energy may be minimized as part of the graphcut operation.

Other method system approach apparatus device media procedure API arrangement etc. implementations are described herein.

Schemes mechanisms techniques etc. for decorating arbitrary surfaces with bidirectional texture functions BTFs are described herein. In a described implementation BTF decorated surfaces are generated in two steps. First a BTF is automatically tiled or synthesized over a target surface from a given BTF sample. Second the user is enabled to interactively paint BTF patches onto the tiled surface such that the painted patches seamlessly integrate with the background patterns.

In a described implementation a patch based texture synthesis approach known as quilting is employed. More specifically a graphcut algorithm for BTF tiling or synthesis on surfaces is employed. The described graphcut algorithm works well for a wide variety of BTF samples including at least some of those that present problems for existing algorithms. In another described implementation a graphcut texture painting algorithm for creating new surface irregularities such as imperfections e.g. dirt cracks scratches etc. from existing irregularities found in input BTF samples is employed.

Using the algorithms described herein surfaces can be decorated with real world textures that have spatially variant reflectance fine scale geometry details and or surfaces imperfections. For example BTF tiling enables a BTF to be synthesized onto a target surface of a geometric model and BTF painting allows imperfections of real materials to be captured and then painted onto geometric models including those models that have already been tiled.

In the following section decorating surfaces with texture samples is described qualitatively with reference to . In the section thereafter decorating surfaces with texture samples is described quantitatively with particular reference to .

In a described implementation surface tiler T is capable of applying a surface texture to all or a part of a target surface . Surface tiler T synthesizes a relatively homogenous texture that can still maintain spatially variant reflectance mesostructures and so forth. Surface painter P is capable of applying specially identified irregular features to a target surface . Surface painter P in accordance with user specified constraints synthesizes irregular features as a foreground texture such that they are realistically merged with a background texture.

A target surface is obtained and a selected regular BTF sample R is applied thereto. Surface tiler T tiles or synthesizes regular BTF sample R onto target surface to produce tiled surface . Tiled surface can be further enhanced or augmented with irregular BTF sample I which can be imperfections or other special foreground features. Surface painter P paints or synthesizes irregular BTF sample I onto tiled surface to produce tiled and painted surface .

Although implementations are primarily described herein with regard to BTF type textures other textures may alternatively be utilized. Also a single texture sample may include both regular and irregular aspects.

During surface tiling work patches from dense surface mesh are identified with each work patch being associated with a respective work image or portion thereof from image charts . As a result of the re sampling that constructs dense surface mesh vertices of dense surface mesh correspond to grid points or pixels of image charts . More specifically there is a one to one correspondence between each vertex of dense surface mesh and each pixel of image charts . It should be understood that image resolution ratio realities mathematical remainders etc. can prevent the creation of a 100 one to one correspondence nevertheless a substantially one to one correspondence can usually be created.

As a consequence of the one to one correspondence some operations can be performed in the image space on image charts with pixels and other operations can be performed in the mesh space on mesh patches with vertices . Moreover results can be moved between the image space and the mesh space.

In a described implementation for example patch matching is performed and accomplished in the image space with respect to a work image . To account for the three dimensional 3D nature of the original input surface mesh patch matching may involve rotations as well as translations. Patch fitting on the other hand is performed and accomplished in the mesh space with respect to a work patch . The patch fitting may be effectuated with a graphcuts operation.

Feature painting is part of surface painter P . Hence an irregular texture feature is applied to an input surface mesh . A graphcuts operation is employed to effectuate the feature painting. However in a described implementation the graphcuts operation is constrained by user input s . For example a user may specify constraints as to a desired foreground feature of a sample texture I and an intended foreground region of a targeted surface . In an example embodiment the constraint energy as defined by the user is minimized as part of the graphcut operation.

At block a dense mesh is constructed from an input target mesh such that mesh vertices of the dense mesh have a one to one correspondence with pixels of an image. For example dense surface mesh may be constructed from input surface mesh of a target surface such that vertices have a one to one correspondence with pixels . This construction may be effectuated using for instance a multi chart geometric image mesh MCGIM derived from target surface .

At block a work patch is built around a vertex of the dense mesh. For example a work patch may be built around a most constrained vertex of vertices of dense surface mesh . At block a work image is created from a work patch using image charts. For example work image may be created from work patch using image charts that are derived responsive to a texture atlas .

At block a sample patch is matched to pre existing pixels in the work image using rotations as well as translations of the sample patch. For example a regular texture sample R may be matched to pixels that have already been added to work image . The matching investigation may utilize rotations as well as translations to find an acceptable if not optimum sample patch position.

At block the matched sample patch is fit into the work patch using a graph cuts algorithm. For example regular texture sample R may be fit to work patch using a graphcuts procedure in dependence on a seam cost threshold and responsive to the position located during the patch matching of block .

At block texture values are assigned to vertices based on the matched and fitted patches. For example texture values from regular texture sample R may be assigned to vertices of dense surface mesh in accordance with the results of patch matching and patch fitting . At block the regular texture sample is synthesized onto the originally input target mesh. For example regular texture sample R is therefore synthesized onto input surface mesh of target surface .

At block user input is accepted as demarcating a foreground feature of a texture sample. For example an imperfection may be demarcated by a user as a foreground feature in an irregular texture sample I . At block user input is accepted as delineating a foreground region of an output texture. For example a region that is to receive the irregular feature of irregular texture sample I may be delineated by a user as a foreground region of the ultimate output texture on target surface . The input foreground feature and foreground region are user constraints for the irregular feature painting process .

At block graphcuts are implemented as constrained by the user specified foreground feature and region. For example a graphcuts operation is effectuated responsive to the demarcated irregular feature of irregular texture sample I and the delineated foreground region of the ultimate output texture on target surface .

In a described implementation and as indicated by block A this graphcuts operation is further effectuated by minimizing the constraint energy. The constraint energy measures how well the synthesized texture satisfies the user specified constraint. Moreover both the smoothness energy and the constraint energy may be minimized during the graphcuts operation. These energies and a graphcuts operation for irregular texture painting are described further herein below with particular reference to .

At block the irregular texture sample is synthesized onto the originally input target mesh. For example irregular texture sample I is therefore synthesized onto input surface mesh of target surface . For improved blending and aesthetic appearance input surface mesh in this context can comprise a tiled surface .

With respect to texture synthesis algorithms for synthesizing textures on surfaces can be divided into two categories. A first category is based on per pixel non parametric sampling. However per pixel sampling is susceptible to the problems caused by the fact that the commonly used L2 norm is actually a poor measure of perceptual similarity. Consequently algorithms in this first category have difficulty maintaining texture patterns with certain types for textures. Although there have been remedies proposed for various specific scenarios there is no prior general solution.

Algorithms in a second category synthesize textures by copying patches of the input texture sample. Because texture patterns are directly copied onto the target surface these second category algorithms are not seriously affected by the problems related to the L2 norm. Earlier second category algorithms randomly paste patches and use alpha blending to hide patch seams. Quilting however generates significantly better results by carefully placing patches to minimize the discontinuity across patch seams. After placing patches in addition to using alpha blending to hide patch seams it is possible to further enhance the smoothness across the seams by searching for the min cut seams. It has been shown that for image textures quilting with graph cuts produces arguably the best visible results on the largest variety of textures. Implementations disclosed herein describe how to perform graph cuts on surfaces.

With respect to decorating surfaces with imperfections it has been proposed to use a set of texturing operations that include tiling and positioning of small images onto surfaces. Existing techniques generally focus on generating synthetic surface imperfections. Implementations disclosed herein describe how to synthesize imperfections from real world as well as synthetic samples.

Described herein are schemes mechanisms techniques etc. that enable the decoration of arbitrary surfaces with BTFs. Two relatively high level texturing operations are supported tiling and painting. Given a BTF sample the tiling operation can automatically synthesize a BTF that fits the target surface naturally and seamlessly. The BTF can model spatially variant reflectance and mesostructures. Moreover the BTF can be derived e.g. measured from real materials. Hence the tiling operation provides a convenient way to cover a surface with fairly realistic textures. shows an example of a surface that has been tiled with a relatively realistic texture. The painting operation further enhances realism by introducing irregular features and other imperfections. FIG. B shows an example of the tiled surface of after being augmented with an irregular feature. In other words the painting operation has introduced surface imperfections into the homogeneous BTF.

The painting operation is valuable because BTFs generated by described synthesis algorithm s as well as by other synthesis algorithms are typically homogeneous across the whole decorated surface. With the painting operation the global homogeneity can be broken by adding irregular local features. In particular imperfections of real materials can be captured and then painted onto the surface such that the painted imperfections fit in seamlessly with the e.g. tiled background patterns.

Three dimensional 3D painting in general is a well established technique for creating patterns on surfaces. BTF painting extends traditional techniques in two ways. First it provides a way to achieve superior realism by applying BTFs that are measured from real materials. Second BTF painting reduces the demand on artistic talents and the tedium that is needed for creating realistic imperfections.

Two primary challenges were addressed in the development of the described system. First BTF synthesis on surfaces remains difficult for many BTF samples. Typically the most difficult problem is maintaining the mesostructures of the input BTF sample. An existing algorithm addresses this problem with partial success by synthesizing the BTF pixel by pixel. However synthesizing a BTF pixel by pixel leads to fundamental problems in maintaining mesostructures because L2 norm is a poor measure of perceptual similarity.

An alternative is to synthesize BTFs by copying patches of the input sample i.e. to employ quilting . Because mesostructures are copied along with the patches this approach is particularly effective for maintaining mesostructures. Unfortunately patch seams still present a problem for BTFs being applied with patches. Although techniques exist for hiding seams in surface textures these techniques do not generalize well to the mesostructure containing BTFs. For example blending can be used to hide patch seams but such blending creates inconsistent mesostructures in the blended areas.

Described herein are algorithm s for quilting BTF patches by using graphcuts to minimize the discontinuity across patch seams on arbitrary surface meshes. A straightforward extension and application of graphcuts to hierarchical pattern mapping can be used to generate texture coordinates for each triangle of an arbitrary surface mesh. However such an approach leads to textures that reveal patch seams at least when viewed close up. This is a potential problem for any attempt to apply graphcuts to surface meshes.

In described implementation s this problem is addressed by densely re sampling the surfaces using geometry images. This approach is termed GIM based sampling herein. Specifically given an input mesh a dense mesh is created by densely sampling the input mesh using multi chart geometric images MCGIM . The texture synthesis is accomplished by using graphcuts to generate texture coordinates for each vertex of the dense mesh. Because a texture value is computed for each vertex of the dense mesh the synthesized textures can be viewed from any distance to a similar extent as those that are obtained with pixel based algorithms.

As is apparent from a straightforward extension of graphcuts to hierarchical pattern mapping leads to suboptimal quality at least when the synthesis results are viewed from a close distance. is an enlarged version of the area of that is delineated by a black box. These results are obtained by incorporating graphcuts into pattern mapping which works directly on the original input mesh. In and too patch seams are visible as a disjointed zigzagged or stair stepped border between patches.

As is apparent from applying the GIM based sampling approach to BTF sample tiling results in a visually improved texture even from close up. is an enlarged version of the area of that is delineated by a black box. The seams are significantly less visible if visible at all in as compared to .

A second primary challenge addressed in the development of the described system is the difficulty of introducing irregular features into a background pattern especially in a user friendly manner. A straightforward approach with graph cut techniques is to merge a foreground feature with the background pattern. For example the feature may be constrained to a desired location and graph cuts may be used to find the merging seam. However this approach only supports verbatim copying of existing features.

To enable a user to generate new features in described implementation s a constrained graph cut procedure for texture and BTF painting is presented. For texture synthesis smoothness energy is considered for finding seams that minimize discontinuity. For texture painting on the other hand both smoothness energy and constraint energy are used. Consequently a user s stipulation of the new feature is incorporated into the graph cut problem as one or more constraints. Generating a new feature with the graphcut painting algorithm is thusly facilitated the user specifies the rough shape and location of the desired new feature and a software realization for a described implementation can then synthesize the actual feature and have it merged seamlessly with the background pattern.

It should be noted that the described schemes mechanisms techniques etc. are also applicable to ordinary color textures which may be regarded as BTFs with a single viewing direction and a single lighting direction.

Given a mesh M and an input BTF sample a dense mesh Mis built first and then a BTF value for each vertex of Mis synthesized by quilting patches of the input BTF sample on M.

As explained herein above graphcut techniques can be incorporated into a synthesis algorithm that works directly on an original input mesh. For example texture coordinates can be generated for each triangle of the input mesh. Unfortunately the synthesis results are not ideal at least when viewed from a close distance as shown in . The seams become visible with the pattern mapping approach because two adjacent triangles on the input mesh may be far apart in the texture space. During texture synthesis textures on two such adjacent triangles are matched at a fixed sampling resolution which is a parameter of the synthesis algorithm . When synthesis results are viewed at a higher resolution the seam between the two triangles becomes even more noticeable.

The GIM based sampling approach described herein provides an effective and general solution for applying graphcut techniques to surfaces. From the input mesh M the dense mesh Mis constructed as an MCGIM. MCGIMs are described further in Multi chart geometry images by P. V. Sander Z. Wood S. J. Gortler J. Synder and H. Hoppe in Symposium on Geometry Processing 2003 pages 146 155 2003 which is hereby incorporated by reference in its entirety herein. The MCGIM uses a texture atlas to resample M and zippers chart boundaries to obtain a watertight mesh M.

The texture atlas may be created for example using the methods described in Iso charts Stretch driven mesh parameterization using spectral analysis by Kun Zhou John Synder Baining Guo and Heung Yeung Shum in Symposium on Geometry Processing 2004 pages 47 56 2004 which is hereby incorporated by reference in its entirety herein. Using these described methods for creating the texture atlas the input mesh is partitioned into relatively large charts with the charts being parameterized with minimized stretch.

The dense mesh Mmay be created such that there is a one to one correspondence between vertices of Mand pixels of the texture atlas. Because of this correspondence synthesizing BTF values for vertices on Mis equivalent to synthesizing BTF values for pixels of the charts of the texture atlas. The pixel vertex correspondence makes it easy to flatten a large patch of Mwithout introducing noticeable texture distortion. In fact for a pixel in the interior of a chart the interior pixel s 2D neighborhood can directly provide neighboring samples and a local flattening. This pixel vertex correspondence enables i simultaneous work on a surface patch of Mand its corresponding image and ii switching freely between the two.

With reference to an example texture atlas is illustrated over a 3D rabbit. shows the assembled texture atlas and shows the image patches of the texture atlas after disassembly. With reference to an example multi chart geometry image mesh MCGIM is illustrated for the 3D rabbit. shows the 3D mesh formed from triangles for the rabbit and shows the densely sampled mesh with the image patches flattened into charts. Thus each chart of the MCGIM corresponds to an image patch of the texture atlas. The charts show the surface being sampled using a regular grid. As indicated by the two dots and the double headed arrow each mesh vertex corresponds to a grid point.

From the input of an MCGIM Mand a BTF sample S the following pseudo code can produce BTF values for all vertices of M 

The algorithm synthesizes the surface BTF by copying patches of the sample BTF. Each time the next BTF patch Pthat is to be generated is around the un synthesized vertex v which is the most constrained. The most constrained vertex is the vertex v having the largest number of immediate vertex neighbors that are already synthesized.

Work Patch Image To determine the next BTF patch P a work patch P v centered at v is built first. A breadth first traversal is conducted starting at v to ascertain P v . The number of levels in the breadth first traversal is defined as a user supplied parameter called the work patch size r. For a 512 512 MCGIM M for example a typical working patch size is r 32 but other working patch sizes rmay be selected. Intuitively the work patch P v may be thought of as a disk of radius r.

From the work patch P v a work image I v may be derived using a continuous parameterization of P v by considering two cases. The first case is simpler If the work patch P v lies completely inside a chart of the MCGIM M then the work image I v is the corresponding sub image of the chart image and no parameterization or resampling is necessary. The second case is more complex If the work patch P v crosses one or more chart boundaries then P v is parameterized using a least squares conformal mapping LSCM technique and the result is resampled to obtain the work image I v . An example of an LSCM technique is provided in Least squares conformal maps for automatic texture atlas generation by B. L evy S. Petitjean N. Ray and J. L. Mallet in Proceedings of SIGGRAPH 2002 pages 362 371 2002 which is hereby incorporated by reference in its entirety herein.

To reduce if not minimize the texture distortion caused by LSCM the area distortion is monitored by a distortion threshold T. Although other values may be used an example value for distortion threshold Tis 4. For resampling the sampling step is set to the average edge length of the work patch.

If a sampling point p is located in a triangle with three synthesized vertices the BTF value at point p is interpolated from these three vertices and the sampling point is marked as synthesized. Otherwise the point p is marked as un synthesized. In this manner a partially synthesized work image T v is obtained.

After building the work patch and image the next BTF patch Pcan be determined using graph cuts. For quilting with graph cuts the main tasks are patch matching and patch fitting. Patch matching places a candidate patch e.g. the input sample over a target area by comparing the candidate patch and the synthesized pixels in the target area. Patch fitting applies graph cuts to select a piece of the candidate patch to be the next synthesized BTF patch P.

Patch Matching Patch matching is performed in the work image I v . An example of a suitable general patch matching technique is presented in Graphcut textures Image and video synthesis using graph cuts by Vivek Kwatra Arno Sch dl Irfan Essa Greg Turk and Aaron Bobick in ACM Transactions on Graphics 22 3 277 286 July 2003 which is hereby incorporated by reference in its entirety herein. The sum of squared differences SSD cost for the BTF is normalized within the area of the overlap region between the input sample and the work image and the patch placement with the minimal cost is selected for patch fitting. The SSD based search may be accelerated using Fast Fourier Transform FFT .

However patch matching need not be limited solely to translation as in general approaches. In described implementation s instead of relying on only translations patch matching employs both translations and rotations. The rotation capability helps to handle the 3D nature of the original target surface.

In other words surface quilting involves a vector field and the described rotational aspect of patch matching accommodates the difference. The vector field aides in orienting anisotropic textures on surfaces and for BTF rendering which involves a local frame at each surface point. In an implementation of a software program for BFT texture synthesis a user interface is provided to let the user specify vectors at a few relatively key faces. These vectors are then interpolated to other faces using radial basis functions.

During patch matching an average orientation for the work image is calculated using the vector field on the work patch. The average orientation is then used to align the input BTF sample S for patch matching. For computational efficiency a predetermined number of rotated versions of S may be pre computed. For the illustrated examples 72 pre computed rotation versions are used. During patch matching the best pre computed rotated version of S is selected for use during patch fitting.

Patch Fitting After the input sample S is placed over the work image I v by patch matching the input sample S can be mapped onto the work patch P v using the correspondence between I v and P v i.e. each grid point or pixel of work image I v corresponds to a vertex of work patch P v .

Each vertex of the work patch P v that is covered by the mapped and rotated input sample S is assigned a new BTF value. Each already synthesized vertex of the work patch P v also has an old BTF value. Based on these old and new BFT values a graph cuts technique is applied to select a piece of the input sample S by regarding the vertices of the work patch P v as graph nodes and the edges of the work patch P v as graph edges. The new BTF values of the selected piece of the input sample S are copied or assigned to the vertices of the work patch P v if the seam cost is below a predetermined cost threshold T. It should be noted that the Kwatra document as referenced hereinabove presents an approach for accounting for old seams from previous graph cut steps.

Hierarchical Search To achieve relatively higher quality results a piece of the input sample S that is selected by the graph cuts technique is utilized if the seam cost is below a seam cost threshold TIf the seam cost exceeds the seam cost threshold T the work patch size ris decreased and the search process is repeated. For example the work patch size rmay be reduced by a constant factor and then the search for another better piece of the input sample S is commenced. For the illustrated examples the constant reduction factor is set to 0.8. 

The work patch size rmay be decreased one or more times until the seam cost falls below the seam cost threshold T or until the work patch size rreaches a minimum size. For the illustrated examples the minimum size of the work patch size ris 4. The same hierarchical search strategy can be employed to control the area distortion of the LSCM parameterization when the work patch is built.

Handling BTF Values The BTF sample is a six dimensional 6D function x v l where x x y is the texture coordinate. v and l are the viewing and lighting directions respectively in spherical coordinates.

For each texel x x y the BTF value is a 4D function that is discretized into a high dimensional vector. Careful treatment of this high dimensional vector can be beneficial when storing BTFs and or calculating SSD costs during patch matching and patch fitting. For example for efficient storage of various BTFs including rotated copies of the input sample S and the synthesized surface BTFs storage can be limited to the texture coordinates. Upon request the actual BTF value is retrieved from the input sample S using texture coordinates.

For efficient SSD cost calculation the BTF may be factorized as a sum of products of 2D and 4D functions using singular value decomposition SVD . An example equation representing such an SVD is 

The geometry maps depend on texture coordinates only but the PAFs are a function of the viewing and lighting directions. An algorithm that synthesizes a surface BTF using the corresponding geometry maps may be used. In fact for the illustrated examples this algorithm is adopted for surface quilting with n 40 and the SSD costs are calculated with low dimensional vectors.

For ordinary color textures vertex colors are stored directly into Mto thereby create a texture map e.g. usually of a size of 512 512 or 1024 1024 for the examples included herein . With this created texture map the synthesized surface texture can be rendered using the standard texture mapping pipeline.

BTF painting can be applicable for example in the following scenario A sample texture S has a foreground feature over a background pattern. The background pattern is already synthesized onto a target mesh M. In accordance with described implementation s a BTF painting system enables a user to interactively synthesize new foreground features on the target mesh M by roughly specifying their shapes and locations. In this scenario it is assumed that prior to the foreground synthesis the user has roughly specified the foreground feature s in the BTF sample S.

As noted herein above in the qualitative section a described implementation of the painting system utilizes a graphcut texture painting algorithm that minimizes both smoothness energy and constraint energy to build a quilt of patches.

The graphcut texture painting in this example results in the construction of a constrained quilt Q. The input sample texture S has been partitioned into two parts by a user a background pattern Sand a foreground feature S. In the target mesh M the user has also specified a foreground region F. The constrained quilt Q F is a quilt consisting of patches of M such that Q F covers F and each patch of Q F is directly texture mapped from a patch in the input sample S. The constraint on Q F is that F is textured by the foreground feature S.

To construct the constrained quilt Q F using graph cuts the user specified constraints are encoded as constraint functions. A function mis defined on the target mesh M such that m p 1 if point p belongs to F and m p 0 otherwise. Similarly for every patch P of the constraint quilt Q F a function mis defined such that m p 1 if point p belongs to the foreground feature and m p 0 otherwise. With these functions defined a constrained graph cut technique which is a part of graphcut texture painting is described.

Constrained Graph Cuts For the sake of clarity constrained graph cuts is described for image textures. By way of explanation only two overlapping constrained patches A and B are addressed. Each pixel p of patch A has a texture value p and a constraint value m P . Similarly each pixel p of patch B has a texture value p and a constraint value m P . Finally for each pixel p of the overlapping region there is a user specified constraint value m p .

A goal is to assign a patch label to every pixel p in the overlapping region A or B so that the region is divided into two parts by a seam of minimum cost energy . The energy that is minimized is defined as . In general graph cut problems the smoothness energy Emeasures the extent to which is not smooth and the data energy Emeasures the difference between and some known data. On the other hand for graphcut texture painting Emeasures how well the patches fit together along their seams and E E measures how well the synthesized texture satisfies the user specified constraint m.

Fitting patches together while minimizing Ealong the seams is performed in the same manner as graphcut texture synthesis. The energy Eis defined as

For graphcut texture painting the user specified constraint mis also satisfied. This is how graphcut texture painting differs from graphcut texture synthesis which uses Ebut not the user specified constraint m. The user specified constraint mis incorporated into graphcut texture painting or quilting by making use of the energy E. The energy Eis defined as

An optimal swap move approach is used to minimize the energy E . An example of a suitable optimal swap move technique is presented in Fast approximate energy minimization via graph cuts by Yuri Boykov Olga Veksler and Ramin Zabih in IEEE Trans on Pattern Analysis and Machine Intelligence 23 11 1 18 November 2001 which is hereby incorporated by reference in its entirety herein.

The bottom portion of illustrates a graph construction for implementing an optimal swap move technique. The nodes of the graph are i the pixels numbered in the overlapping region and ii the two terminals A and B. Each pixel p in the overlapping region is connected to the terminals A and B by edges tand t respectively. These edges are referred to as t links terminal links . Each pair of the adjacent pixels p q in the overlapping region is connected by an edge ecalled an n link neighbor link . The weights of the edges are weight weight t and weight .

Applying the min cut algorithm to the constructed graph produces the minimum cost cut that separates node A from node B. In a described implementation any cut in the graph is to include exactly one t link for any pixel p. Thus any cut leaves each pixel p in the overlapping region with exactly one t link which defines a natural label according to the minimum cost cut C such that is

Quilting on Surfaces The surface quilting algorithm described herein above in the context of graphcut texture synthesis can be adopted for graphcut texture painting on surfaces with modifications to the patch matching and patch fitting phases. For patch matching both the BTF values and the constraint values the mand mvalues are used to perform a joint search for optimal patch placement. For patch fitting a constrained graph cut is employed.

Implementation s as described herein can be realized as a painting system software program that has for example a graphical user interface GUI . For user interactivity reasons surfaces are not immediately rendered with the BTF. Instead an ordinary color texture is displayed that provides a quick preview of the actual BTF. The color texture is obtained from one of the BTF images e.g. the one with the front parallel view and head on lighting .

The example painting system modifies the user specified constraint function mto improve the quality of the constrained quilt. As described above the user specifies the foreground region F on the target surface and thus defines the constraint msuch that that m 1 over F and m 0 elsewhere. Unfortunately mdefined in this way can result in an abrupt change along the boundary of F. This abrupt change often leads to destroyed texture patterns in nearby areas.

One relatively naive approach to ameliorating this problem is to weaken mas m over F and m 0 elsewhere for some small . From the definition of the data energy E if mis set to a small value Eplays a less important role in the total objective energy. However when is small mceases to be fully effective and some background elements may start to appear in F as shown in .

Another approach that reduces if not eliminates the appearance of background elements in the foreground is as follows A transition zone from the boundary of F is expanded and the values of min the transition zone are interpolated using linear interpolation. The transition zone with an interpolated constraint function mis shown in as a blurring of the black and white division between the background and the foreground. Optionally an example of painting system software may permit the width of the transition zone to be a user adjustable parameter. shows a synthesis result when a transition zone established by an interpolated constraint function mis employed.

In addition to synthesizing new foreground features an example of the painting system software also supports verbatim copying of the foreground feature from the input sample onto the target surface. An optional useful feature of the example painting system provides previews with verbatim copying operations by directly projecting a stipulated foreground feature onto the targeted surface. Although the projected foreground feature is not seamlessly merged with the background the preview still provides valuable visual feedback. Thus the user can slide the foreground feature around the surface to find a desired pasting location the foreground feature can then be mapped onto the surface relatively quickly using the work patch image at the target location.

The devices actions aspects features functions procedures modules data structures components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown is not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs arrangements etc. for decorating surfaces with textures. Furthermore although the description herein includes references to specific implementations including a general device of the illustrated and or described implementations can be implemented in any suitable hardware software firmware or combination thereof and using any suitable texture sample s graphcut algorithm s mesh density increasing mechanism s patch fitting technique s user interface approach es and or energy minimization procedure s and so forth.

Example operating environment is only one example of an environment and is not intended to suggest any limitation as to the scope of use or functionality of the applicable device including computer network node entertainment device mobile appliance general electronic device etc. architectures. Neither should operating environment or the devices thereof be interpreted as having any dependency or requirement relating to any one or to any combination of components as illustrated in .

Additionally implementations for decorating surfaces with textures may be realized with numerous other general purpose or special purpose device including computing system environments or configurations. Examples of well known devices systems environments and or configurations that may be suitable for use include but are not limited to personal computers server computers thin clients thick clients personal digital assistants PDAs or mobile telephones watches hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics video game machines game consoles portable or handheld gaming units network PCs videoconferencing equipment minicomputers mainframe computers network nodes distributed or multi processing computing environments that include any of the above systems or devices some combination thereof and so forth.

Implementations for decorating surfaces with textures may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs protocols objects functions interfaces components data structures etc. that perform and or enable particular tasks and or implement particular abstract data types. Realizations of surface decorating with textures as described in certain implementations herein may also be practiced in distributed processing environments where tasks are performed by remotely linked processing devices that are connected through a communications link and or network. Especially but not exclusively in a distributed computing environment processor executable instructions may be located in separate storage media executed by different processors and or propagated over transmission media.

Example operating environment includes a general purpose computing device in the form of a computer which may comprise any e.g. electronic device with computing processing capabilities. The components of computer may include but are not limited to one or more processors or processing units a system memory and a system bus that couples various system components including processor to system memory .

Processors are not limited by the materials from which they are formed or the processing mechanisms employed therein. For example processors may be comprised of semiconductor s and or transistors e.g. electronic integrated circuits ICs . In such a context processor executable instructions may be electronically executable instructions. Alternatively the mechanisms of or for processors and thus of or for computer may include but are not limited to quantum computing optical computing mechanical computing e.g. using nanotechnology and so forth.

System bus represents one or more of any of many types of wired or wireless bus structures including a memory bus or memory controller a point to point connection a switching fabric a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. By way of example such architectures may include an Industry Standard Architecture ISA bus a Micro Channel Architecture MCA bus an Enhanced ISA EISA bus a Video Electronics Standards Association VESA local bus a Peripheral Component Interconnects PCI bus also known as a Mezzanine bus some combination thereof and so forth.

Computer typically includes a variety of processor accessible media. Such media may be any available media that is accessible by computer or another e.g. electronic device and it includes both volatile and non volatile media removable and non removable media and storage and transmission media.

System memory includes processor accessible storage media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules instructions that are immediately accessible to and or being presently operated on by processing unit .

Computer may also include other removable non removable and or volatile non volatile storage media. By way of example illustrates a hard disk drive or disk drive array for reading from and writing to a typically non removable non volatile magnetic media not separately shown a magnetic disk drive for reading from and writing to a typically removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from and or writing to a typically removable non volatile optical disk such as a CD DVD or other optical media. Hard disk drive magnetic disk drive and optical disk drive are each connected to system bus by one or more storage media interfaces . Alternatively hard disk drive magnetic disk drive and optical disk drive may be connected to system bus by one or more other separate or combined interfaces not shown .

The disk drives and their associated processor accessible media provide non volatile storage of processor executable instructions such as data structures program modules and other data for computer . Although example computer illustrates a hard disk a removable magnetic disk and a removable optical disk it is to be appreciated that other types of processor accessible media may store instructions that are accessible by a device such as magnetic cassettes or other magnetic storage devices flash memory compact disks CDs digital versatile disks DVDs or other optical storage RAM ROM electrically erasable programmable read only memories EEPROM and so forth. Such media may also include so called special purpose or hard wired IC chips. In other words any processor accessible media may be utilized to realize the storage media of the example operating environment .

Any number of program modules or other units or sets of processor executable instructions may be stored on hard disk magnetic disk optical disk ROM and or RAM including by way of general example an operating system one or more application programs other program modules and program data . These processor executable instructions may include for example one or more of a surface decorator a surface tiler a surface painter a target surface a BTF sample a tiled surface a tiled and painted surface patches images or other intermediate data some combination thereof and so forth.

A user may enter commands and or information into computer via input devices such as a keyboard and a pointing device e.g. a mouse . Other input devices not shown specifically may include a microphone joystick game pad satellite dish serial port video camera scanner and or the like. These and other input devices are connected to processing unit via input output interfaces that are coupled to system bus . However input devices and or output devices may instead be connected by other interface and bus structures such as a parallel port a game port a universal serial bus USB port an infrared port an IEEE 1394 Firewire interface an IEEE 802.11 wireless interface a Bluetooth wireless interface and so forth.

A monitor view screen or other type of display device may also be connected to system bus via an interface such as a video adapter . Video adapter or another component may be or may include a graphics card for processing graphics intensive calculations and for handling demanding display requirements. Typically a graphics card includes a graphics processing unit GPU video RAM VRAM etc. to facilitate the expeditious display of graphics and performance of graphics operations. In addition to monitor other output peripheral devices may include components such as speakers not shown and a printer which may be connected to computer via input output interfaces .

Computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computing device . By way of example remote computing device may be a peripheral device a personal computer a portable computer e.g. laptop computer tablet computer PDA mobile station etc. a palm or pocket sized computer a watch a gaming device a server a router a network computer a peer device another network node or another device type as listed above and so forth. However remote computing device is illustrated as a portable computer that may include many or all of the elements and features described herein with respect to computer .

Logical connections between computer and remote computer are depicted as a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets the Internet fixed and mobile telephone networks ad hoc and infrastructure wireless networks mesh networks other wireless networks gaming networks some combination thereof and so forth. Such networks and logical and physical communications connections are additional examples of transmission media.

When implemented in a LAN networking environment computer is usually connected to LAN via a network interface or adapter . When implemented in a WAN networking environment computer typically includes a modem or other component for establishing communications over WAN . Modem which may be internal or external to computer may be connected to system bus via input output interfaces or any other appropriate mechanism s . It is to be appreciated that the illustrated network connections are examples and that other manners for establishing communication link s between computers and may be employed.

In a networked environment such as that illustrated with operating environment program modules or other instructions that are depicted relative to computer or portions thereof may be fully or partially stored in a remote media storage device. By way of example remote application programs reside on a memory component of remote computer but may be usable or otherwise accessible via computer . Also for purposes of illustration application programs and other processor executable instructions such as operating system are illustrated herein as discrete blocks but it is recognized that such programs components and other instructions reside at various times in different storage components of computing device and or remote computing device and are executed by processor s of computer and or those of remote computing device .

Although systems media devices methods procedures apparatuses techniques schemes approaches procedures arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or diagrams described. Rather the specific features and diagrams are disclosed as exemplary forms of implementing the claimed invention.

