---

title: Delayed loading and instantiation of resources defined in markup
abstract: Techniques for delayed loading and instantiation of resources in a resource dictionary are provided. These techniques can be used to delay or defer the loading of values (or “value records”) into the resource dictionary until the values are actually needed or requested by an application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07823063&OS=07823063&RS=07823063
owner: Microsoft Corporation
number: 07823063
owner_city: Redmond
owner_country: US
publication_date: 20051115
---
Markup documents have simplified the creation of resources while at the same time improving their usability. Markup languages such as extensible markup language XML are relatively easy to understand which makes the creation of markup documents relatively simple. The use of XML technology has expanded beyond browser applications to database operating system and other applications.

In many applications much of the code pertains to creating and updating the User Interface UI of the application. Recently many developers have learned to write and some developers prefer to define an application s UI by using markup languages such as XML based markup languages etc. One example of an XML based markup language is the Extensible Application Markup Language XAML . XAML is a declarative programming model which maps XML markup to objects. XAML provides a consistent model for object construction which can allow programmers to encode operating system application and other elements in an object rooted hierarchical format. XAML is especially useful for implementing an application s UI since XAML separates UI design from the underlying code. XAML allows a UI to be declaratively represented or specified as a hierarchy of objects with properties and logic. This enables graphical designers to create compelling highly refined user interfaces while allowing developers to focus on the application logic.

XML based representations of documents or objects are typically larger than other formats such as binary files or others. As such XML XAML based data may demand significant amounts of time to load onto a client machine or download over a network. Techniques which make the XML XAML based platforms more efficient in storage and reduce application load times are highly desirable. To help achieve this at compilation time XAML can be compiled into a binary representation of the XML.

In one resource model a presentation framework has objects with a Resources property that can refer to resources in large files that contain resource dictionaries RDs . A resource dictionary RD can include various resources which are defined in markup. In this context the term resource refers to a way of reusing commonly defined objects and values. RDs allow developers to create one instance of a piece of data in either markup or code and re use that data by referring to it from one or more locations within an element tree. RDs are used to store large amounts of data in random access memory RAM that may not be needed or used immediately. When a RD is specified the entire RD and all resources in that RD would be created or instantiated at the same time. Instantiating and loading all of this data into RAM unnecessarily consumes valuable space in the memory and can for example increase application startup time.

Techniques for delayed the loading and instantiation of resources in a resource dictionary are provided. These techniques can be used to defer or delay the loading of values or value records into the resource dictionary until the values are actually needed or requested by an application. According to these techniques key information can be read into the resource dictionary at load time and loading of the values into the resource dictionary can be delayed until an application requests the values.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

The following detailed description is merely exemplary in nature and is not intended to limit the invention or the application and uses of the invention. Furthermore there is no intention to be bound by any expressed or implied theory presented in the preceding background brief summary or the following detailed description.

In this example the source or input file is a XAML file stream including RD and an application definition . The source XAML file stream may be used to represent or generate a set of XAML nodes corresponding to the structure of an object tree not shown . The object tree may represent for example user interface elements such as dialog boxes icons buttons borders or other elements or resources used in operating systems or other code. While the following description describes encapsulating user interface elements it should be appreciated that the source XAML file stream may comprise other types of code data or interfaces.

The RD can include various resources which are defined in markup. To define a particular RD a parent chain is marked up as a hierarchy of elements in a given page. An example of XAML markup for a typical RD is shown below in Expression 1.

Each XAML tag corresponds to an object model class. A XAML tag also usually has a collection of attributes that corresponds to the properties of the tag s associated class. Each XAML tag becomes an instance of the corresponding object model class and the tag s attribute values are assigned to the corresponding object properties.

In this particular example the resources of the RD are different types of visual definitions VDs corresponding to the different types of interface elements specified in the application definition . Each visual definition refers to the style template and other resources which define what a particular interface element looks like. The resources can be referenced in a property value for example by putting the resource name in braces. Each visual definition can be specified as a value of the property. The interface elements can be controls such as dialog boxes icons buttons borders or other elements or resources used in operating systems or other code etc. Each resource has a particular key associated with it that can be used to identify the resource within the parent chain. The type of each interface element can be specified as a key. To find the resource within the RD and apply it the parent chain is searched for the associated key thereby allowing the resource to be found.

A given resource is instantiated in memory as an object . The objects are used to store large amounts of data in memory RAM that may not be needed or used immediately. For instance in the system theme each particular theme has its own RD which might include for instance all of the different default styles for each of the controls used in that theme. Each style may require certain resources. As a result the RD for a particular theme can include large amounts of information. ly when the RD is specified the entire RD and all resources in that RD are created or instantiated at the same time. Instantiating and loading all of this data into memory RAM unnecessarily consumes valuable space in the memory and can for example increase application startup time.

The XAML file stream includes a number of key value pairs X X X X X X X X which are sent to markup compiler module . In the XAML file stream each key and its corresponding value are arranged sequentially so that consecutive XAML key value pairs are arranged in an alternating format e.g key value key value etc. .

At compilation time the compiler module detects the incoming XAML file stream and compiles the incoming XAML file stream into a corresponding binary representation . The compiler module encapsulates the information characterizing the object tree in binary form to produce the binary representation of the XAML file stream . In this example as shown in the second column of the compiler module receives the XAML file stream and maps 1 1 the XAML key value pairs X X X X X X X X into a binary representation of the XAML file stream including a number of binary key value pairs B B B B B B B B. For sake of clarity the simplified representation of the formats of the binary stream and corresponding binary records B B in show only the relative position of keys with respect to values. In actual implementations however it should be appreciated that the binary stream and corresponding binary records B B would also include other information and records as will be described below with reference to .

The XAML file stream has a first file format the arrangement of which is substantially identical to a second file format of the binary file . In other words the arrangement of the XAML key value pairs X X X X X X X X is identical to that of the binary key value pairs B B B B B B B B e.g key value key value etc. .

Each binary key B B and its corresponding binary value B B are stored sequentially in sequential order on disk as binary data. The binary key value pairs B B and B B represent binary key value pairs within the object tree which are not currently being used by the application module .

At run time the run time engine interprets the sequential binary data as binary key records X X and binary value records X X and loads the binary records B B B B B B B B into memory where the binary records B B B B B B B B are instantiated as objects . As shown in column of the binary key objects and the binary value objects B B are arranged in memory in the same order that the binary key value pairs B B are stored on the disk .

Notably all of the binary records B B are instantiated in memory when the markup document is loaded. Thus although the binary key value pairs B B and B B are not currently being used the key value pairs B B and B B are nevertheless instantiated in memory as objects and . This can be extremely inefficient especially when a particular visual definition corresponding to a particular value X X is not presently being used by an application since it can waste memory capacity and slow application start up times.

The AssemblyInfo record specifies the full name or strong name of an assembly PresentationFramework whose types will be used in the binary stream. When the PresentationFramework assembly is loaded it contains Types used in the construction of an object tree. The TypeInfo records specify the full name of the type of an object or type names with a reference to the Assembly record where it is defined. For example the TypeInfo record specifies the full name ResourceDictionary the TypeInfo record specifies the full name ClassOne and the TypeInfo record specifies the full name ClassTwo. The AttributeInfo record specifies the full name of an attribute or property on an object with a reference to the Type record that defines this attribute and the type record that defines the type of the property. In this example AttributeInfo record specifies the full name of a property Propertyone that is to be set on an object with a reference to the Type record that defines this attribute and the type record that defines the type of PropertyOne. 

The dictionary element bounds DB records are structure records which contain information about the object tree structure and make references to the info records for specific types and attributes. The ElementStart on Type record indicates the start of a root object in the XAML file stream whereas the ElementEnd record indicates the end of the root object in the XAML file stream. The XmlnsDefinitionProperty record specifies information about an xmlns declaration encountered in a XAML file.

The ElementStart of Type record specifies that an object of Type ClassOne should be instantiated. The DefAttributeKeyString record specifies the key for the key value pair associating Key with the object instantiated by . The Property of AttributeInfo record specifies the value for the property specified in Propertyone ValueOne . The ElementEnd record is a scope delimiter indicating that the parser is done interacting with the object created by and will be moving on to whatever is next. The ElementStart of Type record specifies that an object of type should be instantiated. A set of types within PresentationFramework are pre defined with numbers so that they don t have to be duplicated in all binary files. The DefAttributeKeyType of Type record is the key associated with the object instantiated by . Unlike the key defined in the key in the DefAttributeKeyType of Type record is not a string but of the type defined by ClassTwo . Since the key is not a string the ElementStart of Type record indicates that an object of type ClassTwo should be instantiated and the ElementEnd record ends the scope defining that object. The ElementEnd record ends the scope defining the object started in .

The compiler module interleaves or interposes the type and attribute TA information and dictionary element bounds DB information with key records DK and value records DV in the binary file . Consequently type and attribute records TA key records DK and value records DV are not arranged or sorted in any particular order.

As used herein the word exemplary means serving as an example instance or illustration. Any implementation described herein as exemplary is not necessarily to be construed as preferred or advantageous over other implementations. All of the implementations described below are exemplary implementations provided to enable persons skilled in the art to make or use the invention and are not intended to limit the scope of the invention which is defined by the claims.

The processing unit may be implemented or performed with a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any processor controller microcontroller or state machine. The processing unit may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Depending on the exact configuration and type of computing device system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory includes an operating system one or more program modules and may include program data . Examples of program modules include a browser application a finance management application a word processor and the like. Additional data storage devices such as removable storage and or non removable storage can include for example magnetic disks optical disks or tape.

Input device s may include for example a keyboard a mouse a pen a voice input device a touch input device etc. Output device s such as a display speakers printer etc. may also be included.

Communication connections are one example of communication media which allow the computing device to communicate with other computing devices not shown such as over a network over a wired or wireless communications link . Communication media may be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.

In this particular implementation the markup compiler receives an Extensible Application Markup Language XAML file stream which comprises a resource dictionary RD and an application definition . Although the foregoing description uses an XAML file stream as an example of an input to the markup compiler it should be appreciated that the input to the markup compiler could generally comprise other types of markup documents including other extensible markup language XML based documents. Moreover the input to the markup compiler can generally comprise markup language information comprising keys and corresponding values for each key.

The source XAML file stream may be used to represent a set of XAML nodes corresponding to the structure of an object tree not shown which represents for example user interface elements such as dialog boxes icons buttons borders or other elements or resources used in operating systems or other code. While the following example describes XAML nodes which correspond to interface elements it should be appreciated that the source XAML file stream may comprise other types of code data or interfaces.

The RD represents a tree of elements that can include various resources which are defined in markup. To define a particular RD a parent chain is marked up as a hierarchy of elements in a given page. In this particular example the resources of the RD are different types of visual definitions VDs corresponding to the different types of interface elements specified in the application definition . Each visual definition refers to the style template and other resources which define what a particular interface element looks like. The resources can be referenced in a property value for example by putting the resource name in braces. Each visual definition can be specified as a value of the property. The interface elements can be controls such as dialog boxes icons buttons borders or other elements or resources used in operating systems or other code etc. Each resource has a particular key associated with it that can be used to identify the resource within the parent chain. The type of each interface element can be specified as a key. To find the resource within the RD and apply it the parent chain is searched for the associated key thereby allowing the resource to be found.

The XAML file stream comprises markup information which includes tags not shown that define the elements of the markup based page or application the keys e.g. interface element types and the corresponding values e.g. visual definitions for each key. The XAML file stream has a first format as will be described below with reference to .

Each tag corresponds to an object model class. Each tag also usually has a collection of attributes that corresponds to the properties of the tag s associated class. Each tag becomes an instance of the corresponding object model class and the tag s attribute values are assigned to the corresponding object properties.

The markup compiler module and parser module can be implemented as a software module such as program module shown in . In the functionality provided by the parser module is shown as being provided within markup compiler . In another embodiment the functionality provided by the parser module may be provided as a separate module or component. The markup compiler module and parser module can be implemented using a software module which compiles the XAML into binary. When instructed to compile the XAML file stream the markup compiler examines the tags and compiles the XAML file stream to generate a binary representation of the XAML file stream which is described below with reference to . In the example the file stream generally comprises a binary representation of the XAML information however it should be appreciated that the binary representation of the XAML file stream may alternatively comprise a tokenized binary stream of information based on the markup text within the XAML file stream . The markup complier module receives the XAML file stream calls the and passes the XAML file stream to the .

The parser module receives the XAML text records of the XAML file stream converts tokenizes them into binary records and generates a modified binary representation of the XAML file stream . The modified binary representation of the XAML file stream comprises binary key records binary value records and offsets from each binary key record to its corresponding binary value record. The modified binary representation of the XAML file stream has a binary record format as will be described below with reference to . The parser module eventually writes the binary records of the modified binary representation of the XAML file stream to disk .

The parser module includes among other things an interpreter sub module not shown for classifying each XAML record of the XAML file stream buffer sub modules not shown and an assembly sub module not shown . To begin generating modified binary representation of the XAML file stream when the parser module encounters a start tag for the RD the interpreter sub module examines and classifies each XAML record in the XAML file stream . The parser module converts or tokenizes each XAML key record into a corresponding binary key record and converts or tokenizes each XAML value record into a corresponding binary value record. The parser module begins buffering binary key records and binary value records into separate buffer sub modules. For instance the parser module can buffer the binary key records in a first buffer sub module not shown and can buffer the corresponding binary value records in a second buffer sub module not shown . The parser module also generates and stores offset values or offsets from each binary key record to each corresponding binary value record. As will be described below the offsets can eventually be used to locate binary value records which correspond to particular binary key records. The offsets specify the location of each binary key record with respect to its corresponding binary value record.

Once an end tag of the RD is encountered the parser module stops buffering and the assembly sub module arranges the binary key records the offsets and the corresponding binary value records into the binary record format of the modified binary representation of the XAML file stream . In one implementation as will be described below with reference to the binary record format of the modified binary representation of the XAML file stream comprises a first portion comprising binary key records and offsets and a second portion comprising the binary value records. The assembly sub module builds the modified binary representation of the XAML file stream such that the first portion precedes the second portion so that second portion can be loaded and instantiated in the resource dictionary after the first portion. This way the binary key records and offset information can be stored in a contiguous section at the front of the RD . This format allows the binary key records and offsets to be instantiated in the memory at load time while allowing the instantiation of the binary value records in the memory to be deferred to a later time when the application module requests particular binary value records. In one arrangement of the modified binary representation of the XAML file stream the offsets can be interleaved with the binary key records such that the offsets are interposed between the binary key records. This way binary key record offset pairs can be processed together in a sequential manner.

The parser module sends the modified binary representation of the XAML file stream to disk where it can be stored until run time.

At load time the run time engine receives the modified binary representation of the XAML file stream stored at disk and interprets and converts the binary key records and offsets to code. The run time engine then loads the binary key records and offsets into the RD in memory where the binary key records are instantiated as key objects.

At run time when the application module requests a specific binary value record the run time engine determines its corresponding binary key record and a specific offset corresponding to the specific binary key record . The run time engine can use the specific offset to locate the specific binary value record. Once located the specific binary value record requested by the application module can be loaded into and interpreted by the run time engine . The specific binary value record can then be instantiated as a value object in the RD stored in memory . For example the first offset corresponding to the first binary key record can be used to locate the first binary value record in response to a request from the application module at run time for the first binary value record corresponding to the first binary key record. The first binary value record requested by the application module can be then loaded interpreted instantiated in the resource dictionary stored in the memory as a first value object.

Thus the resources e.g. values or binary value records in the RD are selectively created or instantiated as objects in the RD in memory on an as requested or as needed basis. Selectively loading and instantiating the resources tends to save valuable space in the memory and can for example reduce application startup times. By delaying the loading and instantiation of the binary value records in memory until the binary value records are actually needed valuable space in the memory can be conserved and application module startup time can be reduced.

As noted above to implement delayed loading and instantiation of resources e.g. binary value records in the RD an alternate arrangement format or packing of the binary value records and binary key records can be implemented which allows the binary key records to be read into a RD at binary load time while loading of binary value records into the RD can be delayed or deferred until an application module requests the binary value records.

The XAML file stream includes a number of key value pairs X X X X X X X X which are sent to markup compiler module . In the XAML file stream each key and its corresponding value are arranged sequentially so that consecutive XAML key value pairs are arranged in an alternating format e.g key value key value etc. .

At compilation time the compiler module detects incoming XAML file stream calls the parser module and passes the XAML file stream to the parser module . The parser module uses the XAML file stream to generate a modified binary representation of the XAML file stream . The binary XAML stream file encapsulates the information characterizing the object tree in binary form. In this example as shown in the second column of the compiler module receives the XAML file stream and passes the XAML key value pairs X X X X X X X X to the parser module which recompiles them to generate the modified binary representation of the XAML file stream . The parser module can also add a deferrable content record B at the beginning of the binary stream to provide a mechanism for designating the values as deferrable content. For sake of clarity the simplified representation of the formats of the binary stream and corresponding binary records B B in show only the relative position of keys with respect to values. In actual implementations however it should be appreciated that the binary stream and corresponding binary records B B can also include other information and records as will be described below with reference to .

As shown in the format e.g. arrangement and content of the binary stream file stored on the disk is considerably different than that shown in . The binary stream file separates the binary key records B B from the binary value records B B by placing the binary key records B B and corresponding offset records B B at the beginning of the binary stream file and by placing the binary value records B B at the end of the binary stream file after the binary key records B B. The offset records B B allow the run time engine module to know which binary value record is associated with a particular binary key when the run time engine module reads one of the binary key records B B from disk .

The object tree for the resource dictionary is obtained from the binary stream stored on the disk . At run time the run time engine module interprets the sequential binary data as binary key records X X and binary value records X X and loads the binary records B B B B B B B B into memory . When the binary stream file is loaded into memory only the binary key records B B and corresponding offset records B B are instantiated in memory as key objects and offset objects which can be understood by a software module. The size of the offset objects is negligible in comparison to the size of the other records.

The binary value records B B are instantiated in memory only when the particular or selected ones of the binary value records B B are requested by the application . When a particular binary value record is requested by the application the offset record corresponding to that particular binary value record is replaced with that particular binary value record. The particular binary value record is then instantiated in memory as a value object 

The deferrable content record B designates the binary value records B B as being deferrable content and specifies the offset to the end of the binary stream . This deferrable content record B allows the run time engine module to avoid loading binary value records B B when the RD is loaded by telling the run time engine module how far to skip ahead to reach the end of the RD . Consequently at run time when the RD is loaded into memory the run time engine module loads only the key record offset record pairs B B B B B B B B into memory and skips to the end of the binary stream bypassing the binary value records B B and continues loading the other elements .

The example shown in assumes that only binary value records B and B have been requested by the application module . As such when binary value records B B were requested the offset records B B corresponding to binary value records B B are replaced with those particular binary value records B B. The particular binary value records B B can then be instantiated in memory as value objects . As such only the items in the resource dictionary that are currently needed are instantiated. Because fewer items tend to be instantiated in an application startup time and memory usage can be improved. For example in contrast to the techniques implemented in the memory saved block demonstrates that this technique can save a substantial amount of the memory by delaying the loading and instantiation of binary value records B B. For binary value records B B which are not used or requested by the application module only key objects and offset objects are instantiated. This saves space in memory which would otherwise be occupied by binary value objects corresponding to binary value records B B according to techniques. Moreover the time required to load those objects can also be eliminated.

The AssemblyInfo record specifies the full name of an assembly PresentationFramework that when loaded contains Types used in the construction of an object tree. The TypeInfo records specify the full name of the type of an object with a reference to the Assembly record where it is defined. For example the TypeInfo record specifies the full name ResourceDictionary the TypeInfo record specifies the full name ClassOne and the TypeInfo record specifies the full name ClassTwo. The AttributeInfo record specifies the full name of an attribute or property on an object with a reference to the Type record that defines this attribute and the type record that defines the type of the property. In this example AttributeInfo record specifies the full name PropertyOne on an object with a reference to the Type record that defines this attribute and the type record that defines the type of PropertyOne. 

The dictionary element bounds DB records are structure records which contain information about the object tree structure and make references to the info records for specific types and attributes. The ElementStart on Type record indicates the start of a DependencyObject whereas the ElementEnd record indicates the end of the Dependency Object. The XmlnsDefinitionProperty record specifies information about an xmlns declaration encountered in a XAML file.

The dictionary key DK information or records include offset or position information Position 0 Position 22 indicating which of the dictionary value DVs information or records in the values section corresponds to a particular dictionary key DK information or records .

The ElementStart of Type record indicates that an object of type should be instantiated. This is the first value and if Key were queried this object would be instantiated. The DefAttributeKeyString record defines a string key that if matched would lead to instantiating the object defined by beginning at record . The Property of AttributeInfo record defines the value ValueOne for the property defined in record . The ElementEnd record ends the scope defining the object started at . The ElementStart of Type record indicates that an element of type should be instantiated. The DefAttributeKeyType of Type record defines the key that if matched would lead to instantiating the object starting at record . The ElementStart of Type record starts the object and the ElementEnd record ends the object creating the object that is the key. The ElementEnd record ends the object starting at record .

In contrast to the approach shown in the binary file of this embodiment also includes the defer start DS information or record which indicates the start of the section for which loading can be deferred and the total size of the contents within this deferrable section. APIs which can be used to implement the defer start DS information or record will be described below with reference to . When the parser module detects the defer start DS information or record the parser module signals that loading of the content defined by the defer start DS information or record can be deferred. The size information Size 64 allows the parser to know how far to jump to skip the values section. The offset or position information Position 0 Position 22 in the dictionary key DK information or records indicates which of the dictionary value DVs information or records in the values section corresponds to a particular dictionary key DK information or records . This allows loading of the value records to be delayed. As such dictionary value DVs information or records do not require parsing until dictionary value DVs information or records are actually requested by the application module .

Moreover type and attribute records TA key records DK and value records DV are arranged or sorted in a particular order which facilitates more efficient reading of data. For example in the binary file of this implementation type and attribute TA information or records and or dictionary key DK information or records are not interleaved with or interposed with dictionary value DVs information or records . Rather the type and attribute TA information or records dictionary key DK information or records and dictionary value DVs information or records are arranged sorted for more efficient reading of data.

To build the binary file when the parser module detects the start tag of the resource dictionary in the binary file it will start buffering type and attribute TA information or records dictionary key DK information or records and dictionary value DVs information or records into separate buffers. The parser module also generates and stores offset values or offsets for locating dictionary value DVs information or records which correspond to particular dictionary key DK information or records . When the end tag of the dictionary is reached the parser module stops buffering and the binary records can be flushed to the binary stream according to a predetermined order so that the keys offsets and values are arranged in the file format shown in . For example type and attribute TA information or records can be flushed first. The start tag of the resource dictionary can be flushed second. The defer start DS information or record can be flushed third. Each of the dictionary key DK information or records can be flushed fourth. The dictionary key DK information or records include an offset labeled Position or other indicia as to the relative stream positions of the dictionary value DVs information or records associated with dictionary key DK information or records . In this implementation the stream positions are relative to the start of the values section. A list of dictionary value DVs information or records can be flushed fifth. An end tag of the stream resource dictionary can be flushed sixth.

The internal void SetDeferableContent indicates the method name on ResourceDictionary. The byte buffer specifies an array that is filled with unparsed binary records. This can apply when the parser can not keep the binary stream open so the data is actually in memory but not read or instantiated.

The ParserContext context indicates parser configuration and state data needed to correctly parse the binary records. The object rootElement is parser state data usually the resource dictionary. The ArrayList keycollection indicates a collection of binary key records and the corresponding offsets inside the section containing binary value records.

The Stream bamlStream applies when the binary stream can be kept open and indicates that the data from the binary value records in the binary stream are not read into memory until needed. The Int64 startPosition indicates the starting location of the binary value records in the binary stream. This piece of data allows a seek operation to be performed on the stream to get to the beginning of the section. The Int32 contentSize indicates the size of the binary value record section so that reading occurs only within the binary value record section and not outside of it.

When the parser module encounters a DeferableContentStart record at runtime it will read the section containing the binary key records.

The internal void SetDeferableContent indicates the method name on ResourceDictionary. The ParserContext context indicates parser configuration and state data needed to correctly parse the binary records. The ArrayList keycollection indicates a collection of binary key records and the corresponding offsets inside the section containing binary value records. The parser module will call SetDeferableContent on the resource dictionary passing the parser context a collection of keys and a buffer or stream that contains the section containing binary value records. The binary key records can contain offsets relative to the start of the binary value records section and this can be used at runtime to load the binary value records. The parser module will skip this block of binary and will continue after the ElementEnd record.

When a RD lookup is initiated for one of the items that have not yet been read in the RD will call the parser module giving it the stream or buffer containing the binary value record s and an offset into that stream. The parser module will then read the binary value record s and create the value object tree and return it. The RD will then return the binary value record s to the caller.

Typically resources or RD values in a RD are shared. When a resource or RD value is shared the same instance of that resource in the RD is used in different locations by different processes. The RD value remains in the binary stream and the value object will be stored in the RD. Subsequent lookups for that key will return the same object.

However in some cases RD values are non shared or unshared. When a resource or RD value is unshared each time that resource is requested a new instance or copy of the resource is created. For example if the same RD value is used multiple times in the same document once the RD value has been interpreted and instantiated then the RD value can not be shared. In this case a copy of that RD value needs to be made instead of handing out the same instance of that RD value as would be done with a shared resource . If RD value is marked as non shared then the RD value is not held by the RD. Each time a request for a non shared RD value is received the RD value is re instantiated instead of obtaining the non shared RD value and overwriting the offset . The offset is retained and its value is recalculated. This way the next time the non shared RD value is requested the new offset value can be used to obtain the RD value. Each lookup will result in reparsing the binary value section creating a new object to return. In this way the dictionary value serves as a factory for creating new objects.

At step markup language information is received. The markup language information comprises a plurality of keys and corresponding values for each key. At step using the markup language information a binary representation of markup language information is generated. The binary representation of markup language information comprises key records value records and offsets. Each offset can be a number indicating the relative location of each value record in the binary representation of markup language information with respect to its corresponding key record. At step at compile time the binary representation of markup language information is stored for example on a disk.

At step at load time the key records and offsets are loaded into memory. The key records are instantiated in memory as key objects. At step in response to a request for a specific value record at run time a specific value record corresponding to a specific key record can be located using the offset associated with the specific key record. At step the specific value record can be instantiated in memory as a value object.

The various illustrative logical blocks modules and algorithm steps described in connection with the technique of may be implemented as computer software modules executed by a processor and have been described above generally in terms of their functionality. A software module may reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of storage medium known in the art. An exemplary storage medium can be coupled to the processor such the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. The implementation of this functionality depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.

The techniques described herein may be embodied as logic instructions on a computer readable medium implemented in any suitable software or firmware or may be reduced to hardware. When executed on a processor the logic instructions cause a general purpose computing device to be programmed as a special purpose machine that implements the described techniques. The processor when configured by the logic instructions to execute the techniques recited herein constitutes structure for performing the described techniques. Generally various different general purpose or special purpose computing system configurations can be used. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs network ready devices minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The functionality of the computers is embodied in many cases by computer executable instructions such as software components that are executed by the computers. Generally software components include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Tasks might also be performed by remote processing devices that are linked through a communications network. In a distributed computing environment software components may be located in both local and remote computer storage media.

The instructions and or software components are stored at different times in the various computer readable media that are either part of the computer or that can be read by the computer. Programs are distributed for example on floppy disks CD ROMs DVD or some form of communication media such as a modulated signal. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

The sequence of the text in any of the claims does not imply that process steps must be performed in a temporal or logical order according to such sequence unless it is specifically defined by the language of the claim. The process steps may be interchanged in any order without departing from the scope of the invention as long as such an interchange does not contradict the claim language and is not logically nonsensical. Furthermore numerical ordinals such as first second third etc. simply denote different singles of a plurality and do not imply any order or sequence unless specifically defined by the claim language.

Furthermore words such as connect or coupled to used in describing or showing a relationship between different elements do not imply that a direct connection must be made between these elements. For example two elements may be connected to each other electronically logically or in any other manner through one or more additional elements without departing from the scope of the invention.

The previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the invention. While at least one exemplary embodiment has been presented in the foregoing detailed description it should be appreciated that a vast number of variations exist. It should also be appreciated that the exemplary embodiment or exemplary embodiments are only examples and are not intended to limit the scope applicability or configuration of the invention in any way. Rather the foregoing detailed description will provide those skilled in the art with a convenient road map for implementing the exemplary embodiments and implementations. For instance while the invention has generally been described in terms of the generation of a binary representation of source XAML which both exist or load on a client machine in embodiments either of the source XAML or binary representation and binary tree could for instance be distributed locally or remotely for instance to serve binary representation from a remote server to a client or other machine.

It should also be understood that various changes can be made in the function and arrangement of elements without departing from the scope of the invention as set forth in the appended claims and the legal equivalents thereof. Thus the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

