---

title: Platform management techniques of handling providers
abstract: Techniques described herein are directed toward side-by-side handling of providers on a 64-bit system. The request for loading a particular version of the provider may include a provider architecture flag that specifies a 32-bit or 64-bit version of a provider for managing the requested service. The request may also include a required architecture flag specifying that the given instantiation of the provider is required and to be forced. The platform manager loads a particular provider instantiation as a function of the provider architecture flag and the required architecture flag.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07765287&OS=07765287&RS=07765287
owner: Microsoft Corporation
number: 07765287
owner_city: Redmond
owner_country: US
publication_date: 20050825
---
The Windows operating system includes the Windows Management Instrumentation WMI infrastructure that enables devices and systems in a network to be managed and controlled. More specifically WMI allows a calling application to access operating system information services and processes running on a given machine as well as on a remote machine on the network. WMI also allows the calling application to start and stop services terminate processes and create new processes.

Providers are written for use by WMI to surface instrumented data and events for a particular managed entity on a system. The providers are loadable by the WMI subsystem upon request of calling applications. A loaded instantiation of a provider enables a particular service e.g. managed object to surface instrument data and events. Each managed entity instrumented via a WMI provider is compiled to a specific platform architecture e.g. 32 bit host machine . For example a 32 bit version of a provider is utilized to surface instrumented data and event of a 32 bit version of a service.

With the introduction of 64 bit platform architectures and 64 bit versions of the Windows operating system a network may now contain both 32 bit and 64 bit machines. The 64 bit version of the Windows system will offer a 32 bit Windows 32 on Windows 64 e.g. WOW64 compatibility modes so as to enable 32 bit compiled programs to be run without requiring any modification.

Techniques described herein are directed toward side by side handling of providers on a 64 bit system. The request for loading a particular version of the provider may include a provider architecture flag that specifies a 32 bit or 64 bit version of a provider for managing the requested service. The request may also include a required architecture flag specifying that the given instantiation of the provider is required and to be forced. The platform manager loads a particular provider instantiation as a function of the provider architecture flag and the required architecture flag.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Techniques are described herein for handling providers in a system management component. The techniques include a transport mechanism for invoking a particular instantiation of a provider. The transport mechanism includes a provider architecture flag for specifying a desired version of a provider and an optional required architecture flag for specifying that a given instantiation of the provider is required. The provider architecture flag and optionally the required architecture flag of the transport mechanism enable cross invoking of 32 bit services on a 64 bit host server.

The input output devices may include one or more communication ports for communicatively coupling the computing device to one or more other computing devices . The one or more other devices may be directly coupled to one or more of the communication ports of the computing device . In addition the one or more other devices may be indirectly coupled through a network to one or more of the communication ports of the computing device . The networks may include an intranet an extranet the Internet a wide area network WAN a local area network LAN and or the like. The communication ports of the computing device may include any type of interface such as a network adapter modem radio transceiver or the like. The communication ports may implement any connectivity strategies such as broadband connectivity modem connectivity digital subscriber link DSL connectivity wireless connectivity or the like.

The computing device may also include additional input output devices such as one or more display devices keyboards and pointing devices e.g. a mouse . The input output devices may further include one or more speakers microphones printers joysticks game pads satellite dishes scanners card reading devices digital cameras video cameras or the like. The input output devices may be coupled to the bus through any kind of input output interface and bus structures such as a parallel port serial port game port universal serial bus USB port video adapter or the like.

The computer readable media may include system memory and one or more mass storage devices . The mass storage devices may include a variety of types of volatile and non volatile media each of which can be removable or non removable. For example the mass storage devices may include a hard disk drive for reading from and writing to non removable non volatile magnetic media. The one or more mass storage devices may also include a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and or an optical disk drive for reading from and or writing to a removable non volatile optical disk such as a compact disk CD digital versatile disk DVD or other optical media. The mass storage devices may further include other types of computer readable media such as magnetic cassettes or other magnetic storage devices flash memory cards electrically erasable programmable read only memory EEPROM or the like. Generally the mass storage devices provide for non volatile storage of computer readable instructions data structures program modules code segments and other data for use by the computing device . For instance the mass storage device may store an operating system one or more applications and other code and data .

The system memory may include both volatile and non volatile media such as random access memory RAM and read only memory ROM . The ROM typically includes a basic input output system BIOS that contains routines that help to transfer information between elements within the computing device such as during startup. The BIOS instructions executed by the processor for instance causes the operating system to be loaded from a mass storage device into the RAM . The BIOS then causes the processor to begin executing the operating system from the RAM . One or more applications may then be loaded into the RAM under control of the operating system .

The operating system includes the system manager that provides the means to manage and monitor the health of the system . The system manager may be called by an application running locally on the computing device or remotely by an application running on another computing device . Referring again to the system manager includes an application program interface a providers manager one or more loadable instantiations of providers and storage for the management data . The one or more loadable instantiations of providers collectively form a provider subsystem . A particular provider instantiation is a loadable software component utilized to expose a particular managed object such as a service. In one implementation the system manager is a Windows Management Instrumentation WMI component and the providers manager is a Common Information Model Object Manager CIMOM . A given provider functions as a mediator between the CIM Object Manager and a given managed objects e.g. system components . Providers supply the CIM Object Manager with data from managed objects handle request on behalf of managed application and generate event notifications. Accordingly the WMI subsystem enables management capabilities by supplying a standard storage component e.g. CIM the means to set and get information to and from storage and the ability to dock third party providers to the CIM Object Manager .

Based upon the state of the one or more API level flags the providers manager loads a particular provider instantiation . In one implementation the API level flags include a provider architecture flag and a required architecture flag . The provider architecture flag can be a small integer value that specifies a 32 bit or 64 bit provider version that the calling application would like to invoke regardless of the callers bitness. In particular the provider architecture flag may be set to a first value e.g. 32 to indicate that a calling application is interested in invoking a 32 bit version of a provider instantiation or the provider architecture flag may be set to a second value e.g. 64 to indicate that the calling application is interested in invoking a 64 bit version of the provider. Accordingly the provider architecture flag may be utilized to provide side by side handling of 32 bit and 64 bit providers on 64 bit host platforms.

The required architecture flag can be a Boolean value that may be utilized to force the provider architecture requested in the provider architecture flag to be loaded. More specifically the requested architecture indicated by the state of the provider architecture flag is loaded if available when the required architecture flag is set to a first state e.g. true . If the required architecture flag is set to the first state and the requested architecture indicated by the state of the provider architecture flag is not available an indication that the requested architecture failed to load is returned. If the required architecture flag is set to a second state e.g. false the requested architecture indicated by the state of the provider architecture flag is loaded if available otherwise a default architecture e.g. 64 bit version of a provider instantiation is loaded.

Optionally if the required architecture flag is set to the second state and the requested architecture indicated by the state of the provider architecture flag is not available a particular version of a provider may be loaded based upon an observed bitness of the calling application. For example if the default provider instantiation is a 64 bit version but the bitness of the caller is a 32 bit environment a 32 bit version of the provider may be loaded if the required architecture flag is set to the second state.

By way of illustration consider the exemplary provider handling scenarios shown in . The various provider handling scenarios illustrate possible permutations of a calling application trying to access a service such as a registry via registry providers in both local and remote cases. In a first scenario a 32 bit application running locally on a 32 bit platform invokes a registry service without the provider architecture and required architecture flags set. On a 32 bit host platform a 32 bit registry provider instantiation handles the request by default. On a 64 bit host platform a WOW64 e.g. a 64 bit version of Windows emulating a 32 bit version of Windows registry provider instantiation handles the request by default. The bitness of the calling application is observed to determine that the WOW64 version of the registry provider should be invoked.

In a second scenario a remote 32 bit application invokes the registry service with no flags set. On a 32 bit host platform a 32 bit registry provider instantiation handles the remote request by default. On a 64 bit host platform a 64 bit registry provider instantiation handles the request by default.

In a third scenario a local 32 bit application invokes the registry service. The provider architecture flag indicates that a 32 bit version of the registry service is desired. On a 32 bit host platform a 32 bit registry provider instantiation handles the request. On a 64 bit host platform a WOW64 registry provider instantiation handles the request. Accordingly the calling application may cross invoke a 64 bit version of the registry service utilizing the provider architecture flag.

In a fourth scenario a remote 32 bit application invokes the registry service. The provider architecture flag indicates that a 32 bit version of the registry service is desired. On a 32 bit host platform a 32 bit registry provider instantiation handles the remote request. On a 64 bit host platform the WOW64 registry provider instantiation handles the request. Accordingly the calling application may cross invoke a 64 bit version of the registry provider utilizing the provider architecture flag.

In a fifth scenario a local 64 bit application invokes the registry service with no flags set. For the 32 bit platform it is appreciated that a 64 bit application cannot run locally. On a 64 bit platform the 64 bit registry provider instantiation handles the request by default.

In a sixth scenario a remote 64 bit application invokes the registry service with no flags set. On the 32 bit platform the 32 bit registry provider instantiation may handle the remote request or an error may be returned. On the 64 bit platform the 64 bit registry provider instantiation handles the request by default.

In a seventh scenario a local 64 bit application invokes the registry service. The provider architecture flag indicates that a 64 bit version of the registry service is desired. For the 32 bit platform the 64 bit application cannot run locally. On the 64 bit platform the 64 bit registry provider instantiation handles the request by default .

In an eighth scenario a remote 64 bit application invokes the registry service. The provider architecture flag indicates that a 64 bit version of the registry service is desired. On the 32 bit platform the 32 bit registry provider instantiation may handle the remote request or an error may be returned. It is appreciated that the conventional 32 bit Windows Management Instrumentation infrastructure will ignore the flags. On the 64 bit platform the 64 bit registry provider instantiation handles the request.

In a ninth scenario a local 32 bit application running on a 64 bit platform invokes the registry service. The provider architecture flag indicates that a 64 bit version of the registry provider is desired. On the 32 bit machine the 32 bit registry provider instantiation may handle the local request or an error may be returned. It is appreciated that the conventional 32 bit Windows Management Instrumentation infrastructure will ignore the flags. On the 64 bit platform the 64 bit registry provider instantiation handles the request.

In a tenth scenario a remote 32 bit application running on a 64 bit platform invokes the registry service. The provider architecture flag indicates that a 64 bit version of the registry service is desired. On the 32 bit platform the 32 bit registry provider instantiation may handle the remote request or an error may be returned. It is appreciated that the conventional 32 bit Windows Management Instrumentation infrastructure will ignore the flags. On the 64 bit platform the 64 bit registry provider instantiation handles the request. Accordingly the calling application may cross invoke a 64 bit version of the registry service utilizing the provider architecture flag.

In an eleventh scenario a local 64 bit application invokes the registry service. The provider architecture flag indicates that a 32 bit version of the registry service is desired. For the 32 bit platform the 64 bit application cannot run locally. On the 64 bit platform a WOW64 registry provider instantiation handles the request.

In a twelfth scenario a remote 64 bit application invokes the registry service. The provider architecture flag indicates that a 32 bit version of the registry service is desired. For the 32 bit platform the 32 bit registry provider instantiation handles the request. On the 64 bit platform the 32 bit registry provider instantiation handles the request.

The technique for handling providers is further described with reference to the method shown in . The method of handling providers may be implemented by some or all of the functional elements of the system and or various combinations of the functional elements. However the method may be implemented independently of the system . Likewise the system for handling providers may be implemented independently of the illustrated method .

In accordance with the method a request to invoke a provider is received by a provider subsystem on the server side at . In one implementation the provider subsystem is the Windows Management Instrumentation WMI component. At optional process a first indication that a caller is interested in invoking a 32bit or 64 bit version of the provider is received by the provider subsystem. In one implementation the first indication is a provider architecture flag that is a small integer value of either 32 or 64 for specifying a 32 or 64 bit instantiation of the provider to be invoked. At optional process a second indication that the requested version is required is received by the provider subsystem. In one implementation the second indication is a required architecture flag that is a Boolean value of either true or false for forcing the specific version of the provider. In one instance of process the provider subsystem inspects two flags to decide the appropriate version of a provider to load in response to a request.

At optional process a bitness of the calling application is observed by the provider subsystem. Thus the request for a version of the provider need not be made explicitly via the flags. In such cases the provider subsystem will make an appropriate determination based on the caller s architecture bitness.

At a provider instantiation is loaded by the provider subsystem. Providers are dynamic linked lists DLLs or executables EXEs that render a layer of abstraction between a managed object and the provider subsystem infrastructure. Instantiations of providers hide the implementation details that are unique to a given management methodology or protocol e.g. Application Programming Interface API Windows Driver Model WDM Simple Network Management Protocol SNMP Desktop Management Interface DMI and the like . The particular provider instantiation may be selected as a function of the first indicator. The particular provider instantiation may further be selected as a function of the second indicator. If a first indicator is not received a default instantiation of the provider is invoked. Alternatively if the first indicator is not received but a bitness of the calling application is observed the particular provider instantiation may be selected as a function of the observed bitness.

Utilizing the first indicator the provider subsystem may be configured to cross invoke a non default provider. Cross invoking a non default provider for example allows access for side by side handling of 32 bit and 64 bit providers on a 64 bit host. Furthermore the invoking of a particular provider may be forced utilizing the second indicator.

Thereafter the provider subsystem enables the calling application to mine data subscribe to events or perform other management related tasks at . The provider subsystem retrieved data in real time from native repositories such as AD e.g. ntds.dit event logs .evt files registry hives and Win32 or Win64 APIs. The provider subsystem also provides asynchronous notification about the changes occurring in the managed system. Accordingly the provider subsystem enables devices and systems in a network to be managed and controlled.

Generally any of the systems and methods for implementing platform management techniques for handling providers as described above can be implemented using software firmware hardware or any combination of these implementations. The term logic module or functionality as used herein generally represents software firmware hardware or any combination thereof. For instance in the case of a software implementation the term logic module or functionality represents computer executable program code and data that performs specified tasks when executed on a computing device or devices. For instance a processor of the computing device executes various instructions and acts upon data encoded in one or more computer readable media e.g. computer memory . The program code can be stored in one or more computer readable media e.g. computer memory . It is also appreciated that the illustrated separation of logic modules and functionality into distinct units may reflect an actual physical grouping and allocation of such software firmware and or hardware or can correspond to a conceptual allocation of different tasks performed by a single software program firmware routine or hardware unit. The illustrated logic modules and functionality can be located at a single site or can be distributed over a plurality of locations.

Although techniques for application handling in a system management component have been described in language specific to structural features and or methods it is to be understood that the subject of the appended claims is not necessarily limited to the specific features or methods described. Rather the specific features and methods are disclosed as exemplary implementations of techniques for handling providers in a platform management component.

