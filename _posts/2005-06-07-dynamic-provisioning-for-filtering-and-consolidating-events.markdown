---

title: Dynamic provisioning for filtering and consolidating events
abstract: Systems and methods provide identification services over a distributed network. Systems and methods provide the tools to receive data from reader devices, process the received data, and provide the processed data to users. Enhanced event handling and dynamic service provisioning enable robust and flexible deployment of identification services in a distributed network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07792874&OS=07792874&RS=07792874
owner: Oracle America, Inc.
number: 07792874
owner_city: Redwood City
owner_country: US
publication_date: 20050607
---
This application is a continuation in part of U.S. patent application Ser. No. 10 767 345 for Dynamic Provisioning of Identification Services in a Distributed System filed Jan. 30 2004 and incorporated herein by reference. This application also relates to U.S. patent application Ser. No. 09 947 528 for Dynamic Provisioning of Service Components in a Distributed System filed Sep. 7 2001 U.S. patent application Ser. No. 09 947 549 for Distributed Metric Discovery and Collection in a Distributed System filed Sep. 7 2001 and U.S. patent application Ser. No. 10 390 895 for Systems and Methods for Providing Dynamic Quality of Service for a Distributed System filed Mar. 19 2003 which are relied upon and incorporated herein by reference.

This invention relates to techniques for dynamically filtering and consolidating events from identification service providers and more particularly to methods and systems for provisioning services to process identification data received from a device.

Distributed systems today enable a device connected to a communications network to take advantage of services available on other devices located throughout the network. Each device in a distributed system may have its own internal data types its own address alignment rules and its own operating system. To enable such heterogeneous devices to communicate and interact successfully developers of distributed systems can employ a remote procedure call RPC communication mechanism.

RPC mechanisms provide communication between processes e.g. programs applets etc. running on the same machine or different machines. In a simple case one process i.e. a client sends a message to another process i.e. a server. The server processes the message and in some cases returns a response to the client. In many systems the client and server do not have to be synchronized. That is the client may transmit the message and then begin a new activity or the server may buffer the incoming message until the server is ready to process the message.

The Java programming language is an object oriented programming language frequently used to implement such a distributed system. A program written in the Java programming language is compiled into a platform independent format using a bytecode instruction set which can be executed on any platform supporting the Java virtual machine JVM . The JVM may be implemented on any type of platform greatly increasing the ease with which heterogeneous machines can be federated into a distributed system.

The Jini architecture has been developed using the Java programming language to enable devices in a distributed system to share services using remote method invocation RMI . Traditional Jini systems use RMI to enable a client device to request and receive a service provided by a server device on a remote machine. While conventional Jini systems provide a basic architecture for providing services in a distributed system they do not provide tools specifically directed to providing complex services. Current systems do not address provisioning a service such as application software to make it available to the distributed system in the first place. Furthermore conventional systems do not consider the requirements of a specific service before provisioning the service to make it available in the distributed system.

For example one such distributed system may include reader devices using Radio Frequency Identification RFID technology and services that receive and process identification data from the reader devices and synthesize the processed data into meaningful business data. Although RFID technology is well known conventional RFID systems do not operate satisfactorily in a distributed system where network changes such as the failure of a computer resource or the introduction of a new resource are common. Furthermore conventional RFID systems do not discover reader devices dynamically. It is therefore desirable to provide RFID systems that operate in a distributed robust reliable scalable manner.

Methods and systems consistent with the present invention provide identification services over a distributed network. Systems and methods provide the tools to receive data from reader devices process the received data and provide the processed data to users. Enhanced event handling and dynamic service provisioning enable robust and flexible deployment of identification services in a distributed network.

According to an aspect of the invention a method provides an identification service in a distributed system comprising providing a set of one or more service elements each service element including an adapter a filter and a logger and receiving by a filter criteria in accordance with predetermined instructions and receiving by an adapter identification data from a reader. The identification data is provided by the adapter to a filter and the filter processes the identification data based on the criteria. The processed data is provided by the filter to a logger and the logger provides notification of the processed data. The service elements are monitored to determine whether any service element fails.

In accordance with another aspect of the invention a method provides an identification service in a distributed system by dynamically creating an application corresponding to each of a plurality of service elements each service element including an adapter a filter and a logger. The filter application receives criteria specified by a user and the adapter application receives identification information corresponding to an item from a reader and provides the identification information to the filter application. The filter application processes the identification information application based on the criteria to create processed information including at least an identification code for the item and provides the processed information to the logger application. The logger application provides the processed information to a recipient. The application corresponding to each service element is monitored to determine whether any application fails.

According to another embodiment of the present invention a system provides a distributed identification service comprising a reader service having service elements comprising an adapter that receives identification information from one or more reader based on predetermined criteria a filter that processes the identification information based on the criteria and a logger that provides notification of the processed information. The system further comprises a registry service that establishes the reader service and its service elements and a monitor service that determines whether the application service or any of the service elements fails.

Additional features of the invention will be set forth in part in the description which follows and in part will be obvious from the description or may be learned by practice of the invention.

The following description of embodiments of this invention refers to the accompanying drawings. Where appropriate the same reference numbers in different drawings refer to the same or similar elements.

Systems consistent with the present invention provide identification services over a distributed network through a collection of service components that interface with identification devices and process data received from the devices. For example items may be uniquely identified by an electronic product code EPC encoded in RFID tags. A reader device may detect the presence of an RFID tag and scan the EPC and any other information contained in the RFID tag. The data may then be used by applications such as an inventory system or a retail system to track and manage the items. One such identification network is described in the Auto ID Savant Specification 1.0 available at www.autoidcenter.org.

An identification service consistent with an embodiment of the present invention provides a distributed middleware component between reader devices and users of identification data such as applications databases etc. By its nature an identification service using RFID technology is typically widely distributed. Readers may be separated by a great distance from the users of identification data. For example an international retailer may need to track inventory in stores around the world using computer systems located in a central headquarters. In another example a shipping company may use RFID readers throughout a series of processing facilities and transportation hubs to track shipments.

One embodiment of the present invention can be implemented using the Rio architecture developed by Sun Microsystems and described in greater detail below. Rio uses tools provided by the Jini architecture such as discovery and event handling to provision and monitor complex services such as identification services in a distributed system. Systems consistent with the present invention provide identification services that may be deployed in a distributed system including tools to deconstruct a complex identification service into service elements provision service elements that are needed to make up the complex identification service and monitor the service elements to ensure that the complex identification service is supported in a dynamic robust fashion.

The computers and devices of distributed system provide services to one another. A service is a resource data or functionality that can be accessed by a user program device or another service. Typical services include devices such as reader devices printers displays and disks software such as applications or utilities and information managers such as databases and file systems. These services may appear programmatically as objects of the Java programming environment and may include other objects software components written in different programming languages or hardware devices. As such a service typically has an interface defining the operations that can be requested of that service.

Memory can be for example a random access memory. Secondary storage device can be for example a CD ROM. CPU can support any platform compatible with JVM . Input device can be for example a keyboard or mouse. Output device can be for example a printer.

JVM acts like an abstract computing machine receiving instructions from programs in the form of bytecodes and interpreting these bytecodes by dynamically converting them into a form for execution such as object code and executing them. RMI facilitates remote method invocation by allowing objects executing on one computer or device to invoke methods of an object on another computer or device. Lookup Service and Discovery Server are described in detail below. Java space is an object repository used by programs within distributed system to store objects. Programs use Java space to store objects persistently as well as to make them accessible to other devices within distributed system .

The Jini environment enables users to build and maintain a network of services running on computers and devices. Jini is an architectural framework provided by Sun Microsystems that provides an infrastructure for creating a flexible distributed system. In particular the Jini architecture enables users to build and maintain a network of services on computers and or devices. The Jini architecture includes Lookup Service and Discovery Server that enable services on the network to find other services and establish communications directly with those services.

Lookup Service defines the services that are available in distributed system . Lookup Service contains one object for each service within the system and each object contains various methods that facilitate access to the corresponding service. Discovery Server detects when a new device is added to distributed system during a process known as boot and join or discovery. When a new device is detected Discovery Server passes a reference to the new device to Lookup Service . The new device may then register its services with Lookup Service making the device s services available to others in distributed system . One skilled in the art will appreciate that exemplary distributed system may contain many Lookup Services and Discovery Servers.

Service provider discovers and joins lookup service making the services provided by service provider available to other computers and devices in the distributed system. When service consumer requires a service it discovers lookup service and sends a lookup request specifying the needed service to lookup service . In response lookup service returns a proxy that corresponds to service provider to service consumer . The proxy enables service consumer to establish contact directly with service provider . Service provider is then able to provide the service to service consumer as needed. An implementation of the lookup service is explained in The Jini Lookup Service Specification contained in Arnold et al. Addison Wesley 1999 pp. 217 231.

Distributed systems that use the Jini architecture often communicate via an event handling process that allows an object running on one Java virtual machine i.e. an event consumer or event listener to register interest in an event that occurs in an object running on another Java virtual machine i.e. an event generator or event producer . An event can be for example a change in the state of the event producer. When the event occurs the event consumer is notified. This notification can be provided by for example the event producer.

The Rio architecture enhances the basic Jini architecture to provision and monitor complex services by considering a complex service as a collection of service elements. To provide the complex service the Rio architecture instantiates and monitors a service instance corresponding to each service element. A service element might correspond to for example an application service or an infrastructure service. In general an application service is developed to solve a specific application problem such as processing identification information word processing or spreadsheet management. An infrastructure service such as the Jini lookup service provides the building blocks on which application services can be used. One implementation of the Jini lookup service is described in U.S. Pat. No. 6 185 611 for Dynamic Lookup Service in a Distributed System which is incorporated herein by reference.

Consistent with the present invention a complex service can be represented by an operational string. depicts an exemplary operational string that includes one or more service elements and another operational string B . Operational string B in turn includes additional service elements 3 4 . . . n . For example operational string might represent an identification service. Service element might be an interface with a reader device and service element might be an interface with a user of identification data. Operational string B might be a service to process data received from the reader device. Service element might then be a filter to remove unnecessary data service element might be a queue storing filtered data etc. In an embodiment of the present invention an operational string can be expressed as an XML document. It will be clear to one of skill in the art that an operational string can contain any number of service elements and operational strings.

A Jini Service Bean JSB is a Java object that provides a service in a distributed system. As such a JSB implements one or more remote methods that together constitute the service provided by the JSB. A JSB is defined by an interface that declares each of the JSBs remote methods using Jini Remote Method Invocation RMI conventions. In addition to its remote methods a JSB may include a proxy and a user interface consistent with the Jini architecture.

A JSB is created and receives fundamental life cycle support from an infrastructure service called a cybernode. A cybernode runs on a compute resource such as a computer or other data processing device. In one embodiment of the present invention a cybernode runs as a Java virtual machine such as JVM on a computer such as computer . Consistent with the present invention a compute resource may run any number of cybernodes at a time and a cybernode may support any number of JSBs.

Service instantiator object is used by cybernode to register its availability to support JSBs and to receive requests to instantiate JSBs. For example using the Jini event handling process service instantiator object can register interest in receiving service provision events from a service provisioner discussed below. A service provision event is typically a request to create a JSB. The registration process might include declaring QoS capabilities to the service provisioner. These capabilities can be used by the service provisioner to determine what compute resource and therefore what cybernode should instantiate a particular JSB as described in greater detail below. In some instances when a compute resource is initiated its capabilities are declared to the cybernode running on the compute resource and stored as QoS capabilities .

Service bean instantiator object is used by cybernode to create JSBs when service instantiator object receives a service provision event. Using JSB attributes contained in the service provision event cybernode instantiates the JSB and ensures that the JSB and its corresponding service remain available over the network. Service bean instantiator object can be used by cybernode to download JSB class files from a code server as needed.

As described above JSBs and cybernodes comprise the basic tools to provide a service corresponding to a service element in an operational string consistent with the present invention. A service provisioner for managing the operational string itself will now be described.

A service provisioner is an infrastructure service that provides the capability to deploy and monitor operational strings. As described above an operational string is a collection of service elements that together constitute a complex service in a distributed system. To manage an operational string a service provisioner determines whether a service instance corresponding to each service element in the operational string is running on the network. The service provisioner dynamically provisions an instance of any service element not represented on the network. The service provisioner also monitors the service instance corresponding to each service element in the operational string to ensure that the complex service represented by the operational string is provided correctly.

If an instance of the next service is not running on the network step then service provisioner determines a target cybernode that matches the next service step . The process of matching a service instance to a cybernode is discussed below. Service provisioner fires a service provision event to the target cybernode requesting creation of a JSB to perform the next service step . In one embodiment the service provision event includes service bean attributes object from service element . Service provisioner then uses a lookup service to discover the newly instantiated JSB step and starts a monitor corresponding to that JSB step .

Once a service instance is running service provisioner monitors it and directs its recovery if the service instance fails for any reason. For example if a monitor detects that a service instance has failed service provisioner may issue a new service provision event to create a new JSB to provide the corresponding service. In one embodiment of the present invention service provisioner can monitor services that are provided by objects other than JSBs. The service provisioner therefore provides the ability to deal with damaged or failed resources while supporting a complex service.

Service provisioner also ensures quality of service by distributing a service provision request to the compute resource best matched to the requirements of the service element. A service such as a software component has requirements such as hardware requirements response time throughput etc. In one embodiment of the present invention a software component provides a specification of its requirements as part of its configuration. These requirements are embodied in service provision management object of the corresponding service element. A compute resource may be for example a computer or a device with capabilities such as CPU speed disk space connectivity capability bandwidth etc.

In one implementation consistent with the present invention the matching of software component to compute resource follows the semantics of the Class.isAssignable method a known method in the Java programming language. If the class or interface represented by QoS class object of the software component is either the same as or is a superclass or superinterface of the class or interface represented by the class parameter of the QoS class object of the compute resource then a cybernode resident on the compute resource is invoked to instantiate a JSB for the software component. Consistent with the present invention additional analysis of the compute resource may be performed before the match is complete. For example further analysis may be conducted to determine the compute resource s capability to process an increased load or adhere to service level agreements required by the software component.

Systems consistent with the present invention may expand upon traditional Jini event handling by employing flexible dispatch mechanisms selected by an event producer. When more than one event consumer has registered interest in an event the event producer can use any policy it chooses for determining the order in which it notifies the event consumers. The notification policy can be for example round robin notification in which the event consumers are notified in the order in which they registered interest in an event beginning with the first event consumer that registered interest. For the next event notification the round robin notification will begin with the second event consumer in the list and proceed in the same manner. Alternatively an event producer could select a random order for notification or it could reverse the order of notification with each event.

In an embodiment of the present invention a service provisioner is an event producer and cybernodes register with it as event consumers. When the service provisioner needs to have a JSB instantiated to complete an operational string the service provisioner fires a service provision event to all of the cybernodes that have registered using an event notification scheme of its choosing.

Readers may be for example any type of device that reads or senses data such as identification data. For example readers may be conventional RFID readers such as the Alien Nanoscanner Reader the ThingMagic Mercury 3 RFID Reader or the Matrics Advanced Reader. A large identification system may have hundreds or even thousands of readers so readers are typically simple inexpensive devices that perform only basic data processing. Identification service may provide extensive data processing to transform the largely untouched scanned data from readers into useful data customized to meet the preferences and requirements of individual users . One skilled in the art will appreciate that the system of may include any number of readers identification services and users . Readers may also include devices that sense data such as motion sensors proximity sensors or temperature sensors. Other types of devices may also be used without departing from the spirit and scope of the present invention.

Identification service may also include a monitor service a registry service and a code server to support the provisioning of service components for identification service . In one embodiment of the present invention monitor service may be a Rio monitor implemented for example by service provisioner . As discussed above a Rio monitor may detect when a service fails to ensure robust service provision. In this embodiment registry service may be implemented as a Jini lookup service described above that enables services to establish communications with other services and code server may be implemented as a code server described above that stores Java code files. Although shows two reader services one application service one monitor service one registry service and one code server one skilled in the art will appreciate that identification service may have any number including zero of each of these components. In addition readers may be adapted to run reader services and application service instead of identification service .

Using the Rio architecture identification service may be implemented using an operational string as described above. Service elements of the operational string may be reader service and application service . In this way monitor service registry service and code server may be used to provision and monitor identification service to ensure a robust and flexible distributed implementation.

Application service may receive a report definition from users . Users may use a web interface such as an enterprise gateway not shown to generate report definitions and subscribe to reports generated by a report definition. For example a user may define a report that provides notification of a number of items at a particular location the location of a specific item or the path an item has taken. A report definition derived from user input may be an XML based report definition. Based on criteria specified in an XML based report definition one or more adapters data filter report filter and one or more loggers may be generated during run time.

Adapter may be for example a service element for interfacing with a reader service . Adapter may receive RFID data from reader services as an event consumer using the enhanced event handling described above. This increases the feasibility and economy of identification service . Adapter may function as an event listener e.g. for data from readers and or an event producer e.g. for data for a filter using the enhanced event handling described above. An adapter may include a unique name a Java class that implements the adapter a set of properties and a set of outputs. The properties may be for example a sequence of name value pairs that are passed to the adapter s constructor. The outputs may be for example a sequence of component names to be registered as event listeners to the adapter. The outputs may designate for example filter logger or a queue not shown .

Criteria in a report definition may include reader identities which may correspond to physical readers and or logical readers. A logical reader identity may correspond to one or more physical reader identities. A user may wish to specify a logical reader when for example identities of physical readers are unknown or have been changed due to replacement. A logical reader identity may also be specified when it is possible to discern a physical location of an item by triangulating results from several physical readers. In such cases a unique logical reader identity may correspond to each discernible location. Reader services may continually monitor registry service to discover physical and logical reader identities and maintain a list of discovered reader identities. Thus application service may include one or more adapters for receiving RFID data from the reader services that support reader identities specified in a report definition.

Data filter may be used to process RFID data received from readers . Data filter may include a unique name a Java class that implements the filter a set of properties and a set of outputs. The properties may be for example a sequence of name value pairs that are passed to the filter s constructor. The outputs may be for example a sequence of component names that will be registered as event listeners to the filter. The outputs may designate for example report filter .

Data filter may process RFID data received from reader based on criteria specified in a report definition i.e. instructions which may come from or on behalf of user . Criteria specified in the report definition may include identification code patterns and external triggers. Identification code patterns may be used to include or exclude identification codes that match the specified identification code patterns. External triggers may include start and stop triggers for defining a period of time in which RFID data is collected i.e. an event cycle . Alternatively an event cycle may be defined by a start trigger and a duration. A report definition may specify start and stop triggers as Universal Resource Identifiers URIs . Valid URIs may include Java Message Service JMS URIs HTTP URIs file URIs and TCP URIs. A URI may specify an EPC pattern so that RFID data collection is triggered to start and or stop upon detecting a match for the specified EPC pattern. An exemplary payload of a URI for a start trigger or a stop trigger may be an XML document such as or . If a URI is not specified a default may be to continually collect data until detection of a predetermined event.

RFID tags generate a much larger amount of data than traditional bar codes much of which is often considered to be noise meaning that it is of little or no use. Therefore in addition to filtering data specified in a report definition data filter may be designed to automatically filter out data from mis read RFID tags and noise. Such automatic filtering may increase the accuracy of the resulting data.

Data filter may link to report filter using the enhanced event handling described above. Like data filter report filter may include a unique name a Java class that implements the filter a set of properties and a set of outputs. The properties may be for example a sequence of name value pairs that are passed to the filter s constructor. The outputs may be for example a sequence of component names that will be registered as event listeners to the filter. The outputs may designate for example other filters logger or queue not shown .

The processed data received from data filter may be a list of RFID tags and a list of readers that produced the RFID tags. Therefore report filter may organize the processed data according to criteria specified in a report definition. The criteria may include a report set definition and a report output definition. A report set definition may define a set of EPCs to be considered for reporting. For example a set of reported EPCs may be all currently read EPCs additions from a previous event cycle or deletions from a previous event cycle. A report output definition may define whether to include a list of EPCs in the report and whether to calculate and include a total number of EPCs in the report.

Logger may be implemented to notify users of reports of data from readers and may function as an event listener e.g. for data from filters and or an event producer e.g. for data for users . Logger may also be configured to transmit reports to users of RFID and non RFID events using a protocol specified by individual users for example by logging information to a file system a JMS queue a TCP socket or a XML HTTP file. For example when a user registers a report subscription an appropriate logger may be created during run time and dynamically linked to report filter . Similarly when a report subscription is removed by a user the corresponding logger may be terminated and disconnected from report filter . Logger may include for example a unique name a Java class that implements the logger and a set of properties. The properties may be for example a sequence of name value pairs that are passed to the logger s constructor.

A report definition specifying criteria for adapter data filter report filter and logger may be expressed using for example an XML document. The following is program code for an exemplary report definition written as an XML document 

In this exemplary code the report definition is referred to as an Event Cycle Specification ECSpec . The report definition above includes a section for specifying logical readers e.g. Dock Door 1 . The report definition also includes a section for specifying an event cycle temporal boundary e.g. start trigger URI and duration of 60000 milliseconds . Finally it includes a section for specifying data to be included in a report e.g. ADDITIONS meaning EPCs not read in a previous event cycle and an indication to include a count of a total number of EPCs in the report.

Because adapter data filter report filter and logger may be implemented as event handler components their component properties may be pre configured with report definition criteria. In this manner adapter data filter report filter and logger may be permanently associated with a particular reader . The following is program code written as an XML document for an exemplary configuration file to support an application service permanently associated with a particular reader 

In this exemplary code the adapter section specifies a particular reader e.g. Matrics Reader . The first filter section specifies report definition criteria for a data filter e.g. a start trigger URI and a duration . The second filter section specifies report definition criteria for a report filter e.g. CURRENT meaning EPCs read in a current event cycle and an indication to include a list of EPCs in the report. The logger section specifies a notification URI e.g. a JMS queue .

The foregoing description of an implementation of the invention has been presented for purposes of illustration and description. It is not exhaustive and does not limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practicing of the invention. Additional modifications and variations of the invention may be for example the described implementation includes software but the present invention may be implemented as a combination of hardware and software or in hardware alone. The invention may be implemented with both object oriented and non object oriented programming systems.

For example identification services consistent with the present invention may be implemented using for example the Java Management Extensions JMX technology to provide identification services that are accessible by management and monitoring applications. JMX Managed Beans may be created to implement components of the identification service and may be registered with a Jini lookup service. In this way the JMX Managed Beans could be discovered and accessed by management applications. The JMX technology is described further at http java.sun.com products JavaManagement . The JMX technology may be implemented for example using the Java Dynamic Management Kit JDMK .

Identification services consistent with embodiments of the present invention may also be implemented using Simple Network Management Protocol SNMP Management Beans that may be accessible to network management systems such as Openview Tivoli and BMC Patrol. In this way an identification service may be provided with unique management and monitoring capabilities.

Furthermore one skilled in the art would recognize the ability to implement the present invention in many different situations. For example the present invention can be applied to the telecommunications industry. A complex service such as a telecommunications customer support system may be represented as a collection of service elements such as customer service phone lines routers to route calls to the appropriate customer service entity and billing for customer services provided. The present invention could also be applied in any event processing system.

