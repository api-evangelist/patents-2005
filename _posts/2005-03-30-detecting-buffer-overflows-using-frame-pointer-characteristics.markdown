---

title: Detecting buffer overflows using frame pointer characteristics
abstract: A method makes use of positional relationships in a memory stack between the frame pointer, such as the Extended Base Pointer (EBP) in Windows®-based systems, of a critical call initiating function making a call to a critical operating system (OS) function, the top of stack position, such as the Process Environment Block (PEB) in Windows® based systems, and the bottom of stack position, such as the Extended Stack pointer (ESP) in a Windows® based system, to detect and block buffer overflows.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08037526&OS=08037526&RS=08037526
owner: Symantec Corporation
number: 08037526
owner_city: Mountain View
owner_country: US
publication_date: 20050330
---
The present invention relates to the protection of computer systems. More particularly the present invention relates to a system and method of detecting buffer overflows and Return to LIBC attacks.

Buffer overflow techniques have often been used by malicious hackers and virus writers to attack computer systems. Buffers are data storage areas that typically hold a predefined finite amount of data. A buffer overflow occurs when a program attempts to store more data into a buffer than the buffer can accommodate i.e. the program attempts to store more than the predefined finite amount of data.

One category of buffer overflow sometimes called stack based buffer overflow involves overwriting stack memory sometimes called the stack. Stack based buffer overflow is typically caused by programs that do not verify the length of the data being copied into a buffer.

When the data exceeds the size of the buffer the extra data can overflow into the adjacent memory locations. In this manner it is possible to corrupt valid data and possibly change the execution flow and instructions.

In the particular case of a Return to LIBC attack hereinafter also referred to as a RLIBC attack the attacker overflows the stack in such a way that a return address will be replaced to point to a library function in a loaded library inside the process address space. Thus when the return address is used by the overflowed process a library function will be executed. This way the attacker runs at least one call function such as an Application Programming Interface API to make operating system function calls and run a command shell on the compromised system remotely.

A method according to one embodiment of the invention makes use of positional relationships between the frame pointer of the critical call initiating function making the call to the critical OS function also referred to herein as simply a frame pointer such as the Extended Base Pointer EBP in Windows based systems the top of stack position such as the Process Environment Block PEB in Windows based systems and the bottom of stack position such as the Extended Stack pointer ESP in a Windows based system.

In particular in one embodiment of the invention the of a critical call initiating function making a call to a critical operating system OS function is examined to determine if the frame pointer of the critical call initiating function has a logical positional relationship in the memory stack also called simply the stack.

According to one embodiment of the present invention a method includes stalling a call to a critical OS function and checking to ensure that the frame pointer of critical call initiating function making the call to the critical OS function has a logical relationship to the top of stack position i.e. that the value pointed to by the frame pointer of the critical call initiating function represents a position in the stack below the top of the stack. If it is determined that the value pointed to by the frame pointer of the critical call initiating function represents a position in the stack above the top of the stack the method further includes taking protective action to protect the computer system.

According to one embodiment of the present invention a method includes stalling a call to a critical OS function and checking to ensure that the frame pointer of the critical call initiating function making the call to the critical OS function has a logical relationship to the bottom of stack position i.e. that the value pointed to by the frame pointer of the critical call initiating function represents a position in the stack above the bottom of the stack. If it is determined that the value pointed to by the frame pointer of the critical call initiating function represents a position in the stack below the bottom of the stack the method further includes taking protective action to protect the computer system.

According to one embodiment of the present invention a method includes stalling a call to a critical OS function and checking to ensure that the frame pointer of the critical call initiating function making the call to the critical OS function has a logical relationship to the known function parameters in the stack and is above a position in the stack of the function parameters block i.e. that the value pointed to by the frame pointer of the critical call initiating function represents a position in the stack above the function parameters block and not within or below the function parameters block. If it is determined that the value pointed to by the frame pointer of the critical call initiating function represents a position in the stack that is within or below the function parameters block the method further includes taking protective action to protect the computer system.

According to one embodiment of the present invention a method includes stalling a call to a critical OS function and checking the frame pointer of the critical call initiating function making the call to the critical OS function using all three tests described above and if the frame pointer of the critical call initiating function fails any one of the three tests the method further includes taking protective action to protect the computer system.

According to one embodiment of the present invention a method includes repeating any or all of the three tests described above for each function section in the chain of function sections resulting in a call to the critical OS function until the entire relevant portion of the stack has been walked .

Embodiments in accordance with the present invention are best understood by reference to the following detailed description when read in conjunction with the accompanying drawings.

Common reference numerals are used throughout the drawings and detailed description to indicate like elements.

In the following discussion call instructions are defined as instructions used to invoke a routine or function in a programming language. Calling a routine or function consists of specifying the routine or function name and optionally parameters. Calling a routine or function is referred to herein as the routine or function being called or called by a call instruction . As an example in a Windows NT and Windows 2000 environment the instruction CALL is a call instruction.

In addition in the following discussion a call function includes operating system function call instruction s i.e. the instruction or set of instructions that originates a call to an operating system function. Herein the process whereby a call function originates a call to an operating system function is referred to as a call to an operating system function and the call function making a call to an operating system function is referred to as a call initiating function . Call functions may be malicious or non malicious. A parent application may include the call function or the parent application may itself be a call function. In addition a function making a call to a critical OS function is referred to herein as a critical call initiating function .

A method according to one embodiment of the invention makes use of positional relationships between the frame pointer of a critical call initiating function making a call to the critical OS function also referred to herein as simply a frame pointer and in such as the Extended Base Pointer EBP in Windows based systems the top of the stack position in such as the Process Environment Block PEB in Windows based systems and the bottom of the stack position in such as the Extended Stack pointer ESP in a Windows based system.

Referring briefly to according to the present invention a method includes hooking critical OS functions HOOK CRITICAL OS FUNCTION S OPERATION in stalling calls to critical OS functions STALL CALL OPERATION in and checking to ensure that the positional relationships between the frame pointer in of the critical call initiating function in and the top of the stack position in and or the bottom of the stack position in are logical i.e. checking to ensure the value pointed to by the frame pointer of the critical call initiating function represents an address that is logical and within the boundaries of the memory stack in also called stack .

Referring briefly to in one embodiment of the present invention a method includes stalling a call to a critical OS function and checking to ensure that the frame pointer of critical call initiating function making the call to the critical OS function has a logical relationship to the top of stack position IS FRAME POINTER BELOW TOP OF STACK OPERATION A in i.e. that the value pointed to by the frame pointer of critical call initiating function making the call to the critical OS function represents a position below the top of stack position. If it is determined that the value pointed to by the frame pointer of the critical call initiating function represents an address above the top of the stack the method further includes taking protective action to protect the computer system GO TO IN OPERATION A .

Referring briefly to according to the present invention a method includes stalling a call to a critical OS function and checking to ensure that the frame pointer of the critical call initiating function making the call to the critical OS function has a logical relationship to the bottom of stack position IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B in i.e. that the value pointed to by the frame pointer of the critical call initiating function making the call to the critical OS function represents a position above the bottom of stack position. If it is determined that the value pointed to by the frame pointer of critical call initiating function making the call to the critical OS function represents an address below the bottom of the stack the method further includes taking protective action to protect the computer system GO TO IN OPERATION B .

Referring briefly to according to one embodiment of the present invention a method includes stalling a call to a critical OS function and checking to ensure that the frame pointer of the critical call initiating function making the call to the critical OS function has a logical relationship to the function parameters block in the stack IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C in i.e. that the value pointed to by the frame pointer of the critical call initiating function represents a position above the function parameters block and not within or below the function parameters block. If it is determined that the value pointed to by the frame pointer of the critical call initiating function represents a position that is within or below the function parameters block the method further includes taking protective action to protect the computer system GO TO IN OPERATION C .

Referring briefly to according to one embodiment of the present invention a method includes stalling a call to a critical OS function and checking the frame pointer of the critical call initiating function making a call to a critical OS function using all three tests described above IS FRAME POINTER BELOW TOP OF STACK OPERATION A IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B and IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C in . According to this embodiment of the invention if the frame pointer of the critical call initiating function fails any of the three tests the method further includes taking protective action to protect the computer system GO TO IN OPERATION D .

Referring briefly to according to one embodiment of the present invention a method includes stalling a call to a critical OS function and checking the frame pointer of the critical call initiating function making the call to a critical OS function using all three tests described above IS FRAME POINTER BELOW TOP OF STACK OPERATION A IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B and IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C in . According to this embodiment of the invention if the frame pointer of the critical call initiating function fails any of the three tests the method further includes taking protective action to protect the computer system GO TO IN OPERATION E . In addition according to this embodiment of the invention if the frame pointer of the critical call initiating function passes all of the three tests a determination is made as to whether the present function is the only function or the last function in a series of functions LAST FUNCTION IN SERIES OPERATION IN . If the critical call initiating function is not the last or only member of the series the process is repeated for each function in the chain of functions resulting in a call to a critical OS function until the entire relevant portion of the stack has been walked .

More particularly is a diagram of a client server system that includes a buffer overflow blocking application executing on a host computer system e.g. a first computer system in accordance with one embodiment of the present invention.

Host computer system sometimes called a client or user device typically includes a central processing unit CPU hereinafter processor an input output I O interface and a memory . In one embodiment memory includes a page based virtual memory system that uses pages e.g. memory areas.

For example Windows NT and Windows 2000 are 32 bit operating systems widely used on home and business computer systems. Windows NT and Windows 2000 provide page based virtual memory management schemes that permit programs to realize a 4 GB gigabyte virtual memory address space. In one embodiment when processor is running in virtual memory mode all addresses are assumed to be virtual addresses and are translated or mapped to physical addresses each time processor executes a new instruction to access memory.

Conventionally the 4 GB virtual memory address space is divided into two parts a lower 2 GB user address space also referred to as user mode address space or ring 3 available for use by a program and a high 2 GB system address space also referred to as kernel address space or ring 0 reserved for use by the operating system.

To protect the integrity of the operating system code and other kernel address space code and data structures from errant or malicious programs and to provide efficient system security user rights management Windows NT and Windows 2000 separate code executing in the user address space e.g. user mode from code executing in the kernel address space e.g. kernel mode. User mode code typically does not have direct access to kernel mode code and has restricted access to computer system resources and hardware. To utilize kernel mode code functionalities such as access to disk drives and network connections user mode programs utilize system calls sometimes called operating system OS function calls which interface between the user mode and kernel mode functions.

Host computer system may further include standard devices like a keyboard a mouse a printer and a display device as well as one or more standard input output I O devices such as a compact disk CD or DVD drive floppy disk drive or other digital or waveform port for inputting data to and outputting data from host computer system . In one embodiment Buffer overflow blocking application is loaded into host computer system via I O device such as from a CD DVD or floppy disk containing buffer overflow blocking application .

Host computer system is coupled to a server system of client server system by a network . Server system typically includes a display device a processor a memory and a network interface .

Further host computer system is also coupled to a hacker computer system of client server system by network . In one embodiment hacker computer system is similar to host computer system and for example includes a central processing unit an input output I O interface and a memory. Hacker computer system may further include standard devices like a keyboard a mouse a printer a display device and an I O device s . The various hardware components of hacker computer system are not illustrated to avoid detracting from the principals of the invention.

Network can be any network or network system that is of interest to a user. In various embodiments network interface and I O interface include analog modems digital modems or a network interface card.

In one embodiment of the invention buffer overflow blocking application is typically stored in memory of host computer system and executed on host computer system . The particular type and configuration of host computer system hacker computer system and server system are not essential to the present invention.

In one embodiment of the invention a pointer marks stack bottom position . In one embodiment of the invention stack is part of a Windows based system and pointer is an Extended Stack pointer ESP . In one embodiment of the invention a pointer marks stack top position . In one embodiment of the invention stack is part of a Windows based system and pointer is a Process Environment Block PEB .

As also shown in stack includes a third function section . Third function section includes a third frame pointer . In one embodiment of the invention stack is part of a Windows based system and third frame pointer is an Extended Base Pointer EBP . In one embodiment of the invention the relative position of third frame pointer within third function section remains constant throughout the life of third function section . Third function section also includes a local variables block made up of one or more local variable positions A holding local variable values associated with the third function. In one embodiment of the invention all positions A of local variables block are below third frame pointer and are therefore at positions in stack of third frame pointer minus a predetermined value. Third function section also includes a function parameters block made up of one or more parameters positions A holding parameter values associated with the third function. In one embodiment of the invention all positions A of function parameters block are above third frame pointer and are therefore at positions in stack of third frame pointer plus a predetermined value. In addition as shown in third frame pointer points to third return address which in turn holds a value linked with second frame pointer second return address and second function .

As also shown in stack includes a second function section . Second function section includes a second frame pointer . In one embodiment of the invention stack is part of a Windows based system and second frame pointer is an Extended Base Pointer EBP . In one embodiment of the invention the relative position of second frame pointer within second function section remains constant throughout the life of second function section . Second function section also includes a local variables block made up of one or more local variable positions A holding local variable values associated with the second function. In one embodiment of the invention all positions A of local variables block are below second frame pointer and are therefore at positions of second frame pointer minus a predetermined value. Second function section also includes a function parameters block made up of one or more parameter positions A holding parameter values associated with the second function. In one embodiment of the invention all positions A of function parameters block are above second frame pointer and are therefore at positions of second frame pointer plus a predetermined value. In addition as shown in second frame pointer points to second return address which in turn holds a value linked to first frame pointer first return address and first function .

As also shown in stack includes a first function section . First function section includes a first frame pointer . In one embodiment of the invention stack is part of a Windows based system and first frame pointer is an Extended Base Pointer EBP . In one embodiment of the invention the relative position of First frame pointer within first function section remains constant throughout the life of first function section . First function section also includes a local variables block made up of one or more local variable positions A holding local variable values associated with the first function. In one embodiment of the invention all positions A of local variables block are below first frame pointer and are therefore at positions of first frame pointer minus a predetermined value. First function section also includes a function parameters block made up of one or more parameter positions A holding parameter values associated with the first function. In one embodiment of the invention all positions A of function parameters block are above first frame pointer and are therefore at positions of first frame pointer plus a predetermined value. In addition as shown in first frame pointer points to first return address which in turn holds a value linked with zero frame pointer zero return address and zero function .

As also shown in stack includes a zero function section . zero function section includes a zero frame pointer . In one embodiment of the invention stack is part of a Windows based system and zero frame pointer is an Extended Base Pointer EBP . In one embodiment of the invention the relative position of zero frame pointer within zero function section remains constant throughout the life of zero function section . Zero function section also includes a local variables block made up of one or more local variable positions A holding local variable values associated with the zero function. In one embodiment of the invention all positions A of local variables block are below zero frame pointer and are therefore at positions of zero frame pointer minus a predetermined value. Zero function section also includes a function parameters block made up of one or more parameter positions A holding parameter values associated with the zero function. In one embodiment of the invention all positions A of function parameters block are above zero frame pointer and are therefore at positions of zero frame pointer plus a predetermined value.

Those of skill in the art will recognize that the organizational relationships shown in and discussed above can be varied from application to application and operating system environment to operating system environment. In addition the number of function sections of stack can be more or less than the four function sections shown in and discussed above. Consequently the number of function sections and the organizational relationships of stack shown in and discussed above were chosen for illustrative purposes only and do not limit the invention in any way.

The structure and operation of stack function sections frame pointers local variable blocks return addresses and function parameters blocks is well know to those of skill in the art. Consequently a more detailed discussion of these elements and their operation is omitted here to avoid detracting from the invention.

As discussed in more detail below the present invention makes use of positional relationships between a frame pointer of the critical call initiating function making the call to the critical OS function or also referred to herein as simply frame pointer or top of the stack position bottom of stack position and the position of function parameters blocks and to determine if a frame pointer or for a critical call initiating function or is logically positioned within stack .

For instance each of frame pointers and points to a corresponding return address or . Each return address or should hold a value for a position within stack that is below top of stack position otherwise the position addressed would be outside stack and illogical. Consequently as discussed in more detail below in one embodiment of the invention frame pointer or of a critical call initiating function or making a call to a critical operating system OS function is examined to determine if the frame pointer or has a logical relationship to top of the stack position i.e. that the value pointed to by frame pointer or of the function or making the call to the critical OS function represents an position below top of stack position .

As discussed in more detail below if it is determined that the value pointed to by frame pointer or of critical call initiating function or represents an address above top of stack position the invention includes taking protective action to protect the computer system.

As another example a given return address or should hold a value for a position within stack that is above bottom of stack position otherwise the position addressed would be outside stack and illogical. Consequently as discussed in more detail below in one embodiment of the invention frame pointer or of a critical call initiating function or is examined to determine if the frame pointer or has a logical relationship to bottom of stack position i.e. that the value pointed to by frame pointer or of the function or represents a position above bottom of stack position .

As discussed in more detail below if it is determined that the value pointed to by frame pointer or of a critical call initiating function or represents an address below bottom of stack position the invention includes taking protective action to protect the computer system.

As another example a given return address or should hold a value for a position within stack that is above the function parameters block and associated with the critical call initiating function or otherwise the position addressed would be inside or below the associated function parameters block or and would be illogical. Consequently as discussed in more detail below in one embodiment of the invention frame pointer or of a critical call initiating function or is examined to determine if frame pointer or has a logical relationship to the associated function parameters block and i.e. that the value pointed to by frame pointer or of the critical call initiating function or represents a position that is neither within or below the associated function parameters block and .

As discussed in more detail below if it is determined that the value pointed to by frame pointer or of a critical call initiating function or represents a position within or below the associated function parameters block and the invention includes taking protective action to protect the computer system.

A more detailed discussion of how the present invention makes use of positional relationships between frame pointers and top of the stack position bottom of stack position and the position of function parameters blocks and to determine if a frame pointer or for a critical call initiating function or is logically positioned within stack is provided below.

From an ENTER OPERATION flow moves to a HOOK CRITICAL OS FUNCTION S OPERATION . In one embodiment of the invention ENTER OPERATION takes place following previously conducted tests not shown that are used in conjunction with Host Computer Process and are part of a chain of related tests. In HOOK CRITICAL OS FUNCTION S OPERATION the critical operating system OS functions e.g. at least one critical OS function of host computer system is are hooked. In one embodiment a system level e.g. a kernel mode module or kernel mode driver hooks the critical OS functions. Further in one embodiment a critical OS function is hooked by redirecting calls to the critical OS function to a hook module.

In one embodiment of the invention an OS function is deemed critical if it is necessary for a first application e.g. a parent application or critical call initiating function to cause execution of a second application e.g. a child application. In one particular embodiment an OS function is deemed critical if it is necessary or likely to be used by a malicious parent application e.g. an application which contains or uses malicious code e.g. located on the stack to execute a child application where the child application allows remote access e.g. remote system level access. Examples of child applications include the command prompt or cmd.exe on a Windows operating system and bin sh on a UNIX or UNIX like e.g. FreeBSD or MacOS x operating system. As used herein a child application is not dependent upon a parent application i.e. once the child application is executed the parent application can be terminated without termination of the child application.

In one embodiment of the invention typically run on a Windows operating system the CreateProcess and System are deemed critical OS functions. In yet another embodiment critical OS functions are located in the C library hence the name Return to LIBC attack.

As is well known to those of skill in the art System calls expose all kernel functionality that user mode programs require. User mode programs need to utilize the functionality provided by the kernel for example to access disk drives network connections and shared memory. More particularly because the processor prevents direct access to kernel mode functions by user mode programs user mode programs use System calls which form the only permitted interface between user mode and kernel mode. In accordance with one embodiment of the invention System calls include calls to critical OS functions and calls to non critical OS function.

From HOOK CRITICAL OS FUNCTION S OPERATION flow moves to a CALL TO CRITICAL OS FUNCTION OPERATION . In CALL TO CRITICAL OS FUNCTION OPERATION a call to sometimes called a call to critical OS function or a critical OS function call invoking a critical OS function is made by a call function of a parent application also called a critical call initiating function. The parent application and or the critical call initiating function may be malicious or non malicious. More particularly a call to a critical OS function is made by a critical call initiating function of a parent application to an OS function that was hooked in HOOK CRITICAL OS FUNCTION S OPERATION .

In accordance with one embodiment of the present invention a call function includes the critical OS function call instruction s i.e. the instruction or set of instructions that originates the call to a critical OS function. Herein the process whereby a call function originates a call to an operating system function is referred to as a call to an operating system function and the call function making a call to an operating system function or a critical operating system function is referred to as a critical call initiating function. The critical call initiating function may be malicious or non malicious. The parent application may include the call function or in one embodiment the parent application is the call function.

From CALL TO CRITICAL OS FUNCTION OPERATION flow moves to a STALL CALL OPERATION . In STALL CALL OPERATION the call to a critical OS function of CALL TO CRITICAL OS FUNCTION OPERATION is stalled i.e. is prevented from reaching the operating system. By stalling the call to the critical OS function execution of the critical OS function is stalled.

From STALL CALL OPERATION flow moves to an IS FRAME POINTER LOGICAL OPERATION . In IS FRAME POINTER LOGICAL OPERATION a determination is made as to whether the frame pointer of the critical call initiating function making the call to the critical OS function also referred to herein as the frame pointer e.g. the Extended Base Pointer EBP in Windows based systems of the critical call initiating function making the call to a critical OS function has a logical positional relationship in the stack.

If a determination is made in IS FRAME POINTER LOGICAL OPERATION that the frame pointer of the critical call initiating function making the call to the critical OS function does have a logical relationship to the stack flow moves an ALLOW CALL TO PROCEED OPERATION .

In ALLOW CALL TO PROCEED OPERATION the call to the critical OS function is allowed to proceed. More particularly the call to the critical OS function is passed to the operating system or other tests not shown in a chain of related tests. As discussed above the call to the critical OS function was stalled in STALL CALL OPERATION . From ALLOW CALL TO PROCEED OPERATION flow moves to an EXIT OPERATION or waits for the next call to a critical OS function and returns to CALL TO CRITICAL OS FUNCTION OPERATION .

In one embodiment of the invention malicious code is defined as any computer program module set of modules or code that enters a computer system without an authorized user s knowledge and or without an authorized user s consent. A determination at IS FRAME POINTER LOGICAL OPERATION that the frame pointer of the critical call initiating function making the call to the critical OS function does have a logical positional relationship to the stack does not necessarily mean that the critical call initiating function is not malicious code. This is because of the possibility of false positive results. Consequently a YES determination at IS FRAME POINTER LOGICAL OPERATION indicating that the frame pointer of the critical call initiating function making the call to the critical OS function does have a logical positional relationship to the stack is according to one embodiment of the invention considered an indeterminate result and in one embodiment of the invention flow would proceed to ALLOW CALL TO PROCEED OPERATION then to EXIT OPERATION and then on to another test or tests not shown to try and make a more conclusive determination about the call to the critical OS function.

On the other hand if a determination is made at IS FRAME POINTER LOGICAL OPERATION that the frame pointer of the critical call initiating function making the call to a critical OS function does not have a logical positional relationship to the stack i.e. the results at IS FRAME POINTER LOGICAL OPERATION are NO there is a good possibility that the critical call initiating function is the result of a buffer overflow or is attempting to create a buffer overflow condition. Consequently if the results at IS FRAME POINTER LOGICAL OPERATION are NO the critical call initiating function and the critical OS function call itself become suspect the method of the invention further includes taking action to protect host computer system in and flow moves in optionally to a KNOWN FALSE POSITIVE OPERATION or directly to a TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

In KNOWN FALSE POSITIVE OPERATION a determination is made as to whether the call to a critical OS function is a known false positive . A known false positive call to a critical OS function is a call to a critical OS function that triggers a NO result at IS FRAME POINTER LOGICAL OPERATION but is in fact safe i.e. is not associated with malicious code. Illustratively a user defined or downloadable exclusion and or inclusion list is used to determine whether the call to a critical OS function is a known false positive .

If a determination is made in KNOWN FALSE POSITIVE OPERATION that the call to a critical OS function is a known false positive call to a critical OS function flow moves to ALLOW CALL TO PROCEED OPERATION which is performed as discussed above and EXIT OPERATION . Conversely if a determination is made at KNOWN FALSE POSITIVE OPERATION that the call to a critical OS function is not a known false positive call to a critical OS function flow moves to a TAKE PROTECTIVE ACTION OPERATION .

In TAKE PROTECTIVE ACTION OPERATION protective action is taken to prevent the malicious code of or used by the critical call initiating function from causing damage to or exploiting host computer system in . For example the call to a critical OS function is terminated. More particularly the call to a critical OS function is not passed to the operating system but is terminated. As discussed above the call to a critical OS function was stalled in STALL CALL OPERATION in .

By terminating the call to a critical OS function the malicious code of the critical call initiating function is prevented from exploiting and or damaging host computer system in . In one embodiment by terminating the call to a critical OS function the child application is prevented from being executed. By preventing execution of the child application remote access is denied thus preventing unauthorized access by malicious hackers as well as by replicating malware e.g. worms.

As discussed above if the results at IS FRAME POINTER LOGICAL OPERATION are NO the critical call initiating function as well as the critical OS function call itself become suspect. By terminating the call to a critical OS function the critical OS function is prevented from being executed. As another example of protective action the parent application including the call function and or a malicious thread running within the context of the parent application is terminated. Termination of applications is well known to those of skill in the art and so is not discussed further for clarity of discussion.

Returning to flow moves from TAKE PROTECTIVE ACTION OPERATION optionally to a NOTIFY OPERATION or directly to EXIT OPERATION if NOTIFY OPERATION is not performed . In NOTIFY OPERATION the user of host computer system in and or the administrator are notified that protective action has been taken on host computer system e.g. that a call a parent application and or a call function have been terminated. The user and or administrator can be notified using any one of a number of techniques e.g. by using a pop up window by generating an e mail by writing to a file and or otherwise by logging the event. Further a notification can be provided to a security center.

From NOTIFY OPERATION in flow moves to EXIT OPERATION or waits for the next call to a critical OS function and returns to CALL TO CRITICAL OS FUNCTION OPERATION .

More particularly in a hooked system service table routes calls to non critical OS functions directly to the operating system not shown . However hooked system service table routes calls to critical OS functions to hook module e.g. a kernel mode module or kernel mode driver.

As is well known to those of skill in the art a system service table sometimes called a dispatch table or a system call table relates system calls to specific addresses within the operating system kernel. Hooked system service table in accordance with one embodiment of the present invention redirects calls to critical OS functions to hook module and from the specific addresses within the operating system kernel to which the calls to critical OS functions would otherwise be directed.

Although describes one example of a hooked operating system function call path in light of this disclosure those of skill in the art will understand that other techniques can be used to hook operating system function s . The particular technique used depends for example on the particular operating system.

In one embodiment hook module is used to stall a call to a critical OS function during STALL CALL OPERATION of . Further hook module continues to stall calls to the critical OS function during IS FRAME POINTER LOGICAL OPERATION and KNOWN FALSE POSITIVE OPERATION if performed. Hook module allows the calls to a critical OS function to proceed to the operating system and thus to critical OS function during ALLOW CALL TO PROCEED OPERATION . Conversely hook module terminates the call to a critical OS function and or takes other protective action during TAKE PROTECTIVE ACTION OPERATION .

In accordance with this embodiment of the invention a call to a critical OS function originates from a call function during CALL TO CRITICAL OS FUNCTION OPERATION . Critical OS function call is routed by hooked system service table to hook module . Critical OS function call is stalled by hook module in STALL CALL OPERATION .

Hooking and hooking operations are well known to those of skill in the art. Consequently a more detailed discussion of hooking and hooking operations is omitted here to avoid detracting from the present invention.

Returning to as discussed above if the results at IS FRAME POINTER LOGICAL OPERATION are NO the critical call initiating function becomes suspect. According to one embodiment of the invention IS FRAME POINTER LOGICAL OPERATION of host computer process of determines whether the frame pointer of the critical call initiating function making the call to the critical OS has a logical relationship to the top of stack position.

Referring to and together is a flow diagram of one embodiment of IS FRAME POINTER LOGICAL OPERATION of the host computer process of in which the frame pointer or of a critical call initiating function or making a call to a critical OS function is examined to determine if the frame pointer or such as the Extended Base Pointer EBP in Windows based systems has a logical relationship to top of stack position and pointer such as the Process Environment Block PEB in Windows based systems.

According to one embodiment of the present invention a method includes stalling a call to a critical OS function at STALL CALL OPERTAION IN as described above. Flow then moves from STALL CALL OPERTAION IN to IS FRAME POINTER LOGICAL OPERATION and to ENTER OPERATION A in . From ENTER OPERATION A flow moves to IS FRAME POINTER BELOW TOP OF STACK OPERATION A. At IS FRAME POINTER BELOW TOP OF STACK OPERATION A the frame pointer or of the critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of the critical call initiating function or has a logical positional relationship to top of stack position i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of the critical call initiating function or represents a position in stack below top of stack position .

If at IS FRAME POINTER BELOW TOP OF STACK OPERATION A it is determined that the return address value or pointed to by the frame pointer or of the critical call initiating function or represents a position above top of stack position i.e. a NO result is found at IS FRAME POINTER BELOW TOP OF STACK OPERATION A the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION A to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER BELOW TOP OF STACK OPERATION A it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position below top of stack position i.e. a YES result is found at IS FRAME POINTER BELOW TOP OF STACK OPERATION A the result is considered indeterminate because of the possibility of false positive results and flow moves through GO TO IN OPERATION A in to ALLOW CALL TO PROCEED OPERATION in .

Returning to as discussed above if the results at IS FRAME POINTER LOGICAL OPERATION are NO the critical call initiating function becomes suspect. According to one embodiment of the invention IS FRAME POINTER LOGICAL OPERATION of host computer process of determines whether the frame pointer of the critical call initiating function making the call to the critical OS has a logical relationship to the bottom of stack position.

Referring to and together is a flow diagram of one embodiment of IS FRAME POINTER LOGICAL OPERATION of the host computer process of in which the frame pointer or of a critical call initiating function or making a call to a critical OS function is examined to determine if the frame pointer or such as the Extended Base Pointer EBP in Windows based systems has a logical positional relationship to bottom of stack position and pointer such as the Extended Stack Pointer ESP in Windows based systems.

According to one embodiment of the present invention a method includes stalling a call to a critical OS function at STALL CALL OPERTAION IN as described above. Flow then moves from STALL CALL OPERTAION IN to IS FRAME POINTER LOGICAL OPERATION and ENTER OPERATION B in . From ENTER OPERATION B flow moves to IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B. At IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B the frame pointer or of the critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of a critical call initiating function or has a logical positional relationship to bottom of stack position and pointer i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position in stack above bottom of stack position .

If at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position below bottom of stack position i.e. a NO result is found at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION B to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above bottom of stack position i.e. a YES result is found at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B the result is considered indeterminate because of the possibility of false positive results and flow moves through GO TO IN OPERATION B in to ALLOW CALL TO PROCEED OPERATION in .

Returning to as discussed above if the results at IS FRAME POINTER LOGICAL OPERATION are NO the critical call initiating function becomes suspect. According to one embodiment of the invention IS FRAME POINTER LOGICAL OPERATION of host computer process of determines whether the frame pointer of a critical call initiating function has a logical positional relationship to the function parameters block of the critical call initiating function.

Referring to and together is a flow diagram of one embodiment of IS FRAME POINTER LOGICAL OPERATION of the host computer process of in which the frame pointer or of a critical call initiating function or making a call to a critical OS function is examined to determine if the frame pointer or such as the Extended Base Pointer EBP in Windows based systems has a logical relationship to the function parameters block or of the critical call initiating function or .

According to one embodiment of the present invention a method includes stalling a call to a critical OS function at STALL CALL OPERTAION IN as described above. Flow then moves from STALL CALL OPERTAION IN to IS FRAME POINTER LOGICAL OPERATION and ENTER OPERATION C in . From ENTER OPERATION C flow moves to IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C. At IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the frame pointer or of a critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of a critical call initiating function or making the call to the critical OS function has a logical relationship to the function parameters block or associated with the critical call initiating function or i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of the associated critical call initiating function or represents a position above the function parameters block or associated with the critical call initiating function.

If at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position within or below the function parameters block or associated with the critical call initiating function or i.e. a NO result is found at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION B to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above the function parameters block or associated with the critical call initiating function or i.e. a YES result is found at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the result is considered indeterminate because of the possibility of false positive results and flow moves through GO TO IN OPERATION B in to ALLOW CALL TO PROCEED OPERATION in .

Returning to as discussed above if the results at IS FRAME POINTER LOGICAL OPERATION are NO the critical call initiating function becomes suspect. According to one embodiment of the invention IS FRAME POINTER LOGICAL OPERATION of host computer process of uses all three tests A B and C discussed above to determine whether the frame pointer of the critical call initiating function has a logical positional relationship to the stack.

Referring to and together is a flow diagram of one embodiment of IS FRAME POINTER LOGICAL OPERATION of the host computer process of . As seen in according to one embodiment of the present invention a method includes stalling a call to a critical OS function at STALL CALL OPERTAION IN as described above. Flow then moves from STALL CALL OPERTAION IN to IS FRAME POINTER LOGICAL OPERATION and to ENTER OPERATION D in . From ENTER OPERATION D flow moves to IS FRAME POINTER BELOW TOP OF STACK OPERATION A. At IS FRAME POINTER BELOW TOP OF STACK OPERATION A the frame pointer or of a critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of a critical call initiating function or making the call to the critical OS function has a logical positional relationship to top of stack position i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position below top of stack position .

If at IS FRAME POINTER BELOW TOP OF STACK OPERATION A it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above top of stack position i.e. a NO result is found at IS FRAME POINTER BELOW TOP OF STACK OPERATION A the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION D to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER BELOW TOP OF STACK OPERATION A it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position below top of stack position i.e. a YES result is found at IS FRAME POINTER BELOW TOP OF STACK OPERATION A the result is considered indeterminate because of the possibility of false positive results and flow moves to IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B.

At IS FRAME POINTER BELOW BOTTOM OF STACK OPERATION B the frame pointer or of the critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of the critical call initiating function or has a logical relationship to bottom of stack position and pointer i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above bottom of stack position .

If at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position below bottom of stack position i.e. a NO result is found at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION B to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above bottom of stack position i.e. a YES result is found at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B the result is considered indeterminate because of the possibility of false positive results and flow moves to IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C.

At IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the frame pointer or of the critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of a critical call initiating function or making the call to the critical OS function has a logical relationship the function parameters block or associated with the critical call initiating function or i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of the associated critical call initiating function or represents a position above the function parameters block or associated with the critical call initiating function or .

If at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C it is determined that the return address value or pointed to by the frame pointer or of the critical call initiating function or represents a position within or below the function parameters block or associated with the critical call initiating function or i.e. a NO result is found at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION B to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C it is determined that the return address value or pointed to by the frame pointer or of the critical call initiating function or represents a position above the function parameters block or associated with the critical call initiating function or i.e. a YES result is found at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the result is considered indeterminate because of the possibility of false positive results and flow moves through GO TO IN OPERATION B in to ALLOW CALL TO PROCEED OPERATION in .

Returning to as discussed above if the results at IS FRAME POINTER LOGICAL OPERATION are NO the critical call initiating function becomes suspect. According to one embodiment of the invention IS FRAME POINTER LOGICAL OPERATION of host computer process of uses all three tests A B C discussed above to determine whether the frame pointer of the critical call initiating function has a logical relationship to the stack. Then the process is repeated for each function in the chain of functions resulting in the call to a critical OS function until the entire relevant portion of the stack has been walked .

Referring to and together is a flow diagram of one embodiment of IS FRAME POINTER LOGICAL OPERATION of the host computer process of . As seen in according to one embodiment of the present invention a method includes stalling a call to a critical OS function at STALL CALL OPERTAION IN as described above. Flow then moves from STALL CALL OPERTAION IN to IS FRAME POINTER LOGICAL OPERATION and to ENTER OPERATION E in . From ENTER OPERATION E flow moves to IS FRAME POINTER BELOW TOP OF STACK OPERATION A. At IS FRAME POINTER BELOW TOP OF STACK OPERATION A the frame pointer or of a critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of a critical call initiating function or making the call to the critical OS function has a logical relationship to top of stack position i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position in stack below top of stack position .

If at IS FRAME POINTER BELOW TOP OF STACK OPERATION A it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above top of stack position i.e. a NO result is found at IS FRAME POINTER BELOW TOP OF STACK OPERATION A the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION D to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER BELOW TOP OF STACK OPERATION A it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position below top of stack position i.e. a YES result is found at IS FRAME POINTER BELOW TOP OF STACK OPERATION A the result is considered indeterminate because of the possibility of false positive results and flow moves through to IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B.

At IS FRAME POINTER BELOW BOTTOM OF STACK OPERATION B the frame pointer or of the critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of a critical call initiating function or making the call to the critical OS function has a logical relationship to bottom of stack position and pointer i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above bottom of stack position .

If at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position below bottom of stack position i.e. a NO result is found at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION B to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B it is determined that the return address value or pointed to by the frame pointer or of the critical call initiating function or represents a position above bottom of stack position i.e. a YES result is found at IS FRAME POINTER ABOVE BOTTOM OF STACK OPERATION B the result is considered indeterminate because of the possibility of false positive results and flow moves through to IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C.

At IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the frame pointer or of a critical call initiating function or making the call to the critical OS function is examined to determine if the frame pointer or of a critical call initiating function or making the call to the critical OS function has a logical relationship the function parameters block or associated with the critical call initiating function or i.e. a check is made to ensure that the return address value or pointed to by the frame pointer or of the associated critical call initiating function or represents a position above the function parameters block or associated with the critical call initiating function or .

If at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position within or below the function parameters block or associated with the critical call initiating function or i.e. a NO result is found at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the method of the invention further includes taking action to protect the computer system as flow moves through GO TO IN OPERATION B to KNOWN FALSE POSITIVE OPERATION or directly to TAKE PROTECTIVE ACTION OPERATION if KNOWN FALSE POSITIVE OPERATION is not performed .

On the other hand if at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C it is determined that the return address value or pointed to by the frame pointer or of a critical call initiating function or represents a position above the function parameters block or associated with the critical call initiating function or i.e. a YES result is found at IS FRAME POINTER ABOVE FUNCTION PARAMETERS BLOCK OPERATION C the result is considered indeterminate because of the possibility of false positive results and flow moves through to LAST FUNCTION IN SERIES OPERATION .

At LAST FUNCTION IN SERIES OPERATION a determination is made as to whether the present function or is the only function or the last function in a series of functions. If at LAST FUNCTION IN SERIES OPERATION it is determined that the critical call initiating function or is not the last or only member of the series flow moves to RETRIVE NEXT FUNCTION SECTION FROM STACK OPERATION .

At RETRIVE NEXT FUNCTION SECTION FROM STACK OPERATION the next function or up stack from the present function or is targeted and the process described above is repeated for each function or in the chain of functions resulting in the call to a critical OS function until the entire relevant portion of stack has been walked .

On the other hand if at LAST FUNCTION IN SERIES OPERATION it is determined that the critical call initiating function or is the last or only member of the series flow moves to GO TO IN OPERATION B in to ALLOW CALL TO PROCEED OPERATION in .

As discussed above a method according to one embodiment of the invention makes use of positional relationships between the frame pointer such as the Extended Base Pointer EBP in Windows based systems the top of stack position such as the Process Environment Block PEB in Windows based systems and the bottom of stack position such as the Extended Stack pointer ESP in a Windows based system.

In particular in one embodiment of the invention the frame pointer of a critical call initiating function is examined to determine if the frame pointer of the critical call initiating function has a logical relationship to the stack.

According to one embodiment of the present invention a method includes checking to ensure that the frame pointer of a critical call initiating function has a logical relationship to the top of the stack position.

According to one embodiment of the present invention a method includes checking to ensure that the frame pointer of a critical call initiating function has a logical relationship to the bottom of stack position.

According to one embodiment of the present invention a method includes checking to ensure that the frame pointer of a critical call initiating function has a logical relationship to the function parameters block associated with the critical call initiating function.

According to one embodiment of the present invention a method includes checking the frame pointer of a critical call initiating function using all three tests described above and if the frame pointer of a function making a call to a critical OS function fails any one of the three tests the method further includes taking protective action to protect the computer system.

According to one embodiment of the present invention a method includes repeating any or all of the three tests described above for each function in the chain of functions resulting in a call to a critical OS function until the entire relevant portion of the stack has been walked .

Referring again to in one embodiment of the invention buffer overflow blocking application is in computer memory . As used herein a computer memory refers to a volatile memory a non volatile memory or a combination of the two.

Although buffer overflow blocking application is referred to as an application this is illustrative only. Buffer overflow blocking application should be capable of being called from an application or the operating system. In one embodiment an application is generally defined to be any executable code. Moreover those of skill in the art will understand that when it is said that an application or an operation takes some action the action is the result of executing one or more instructions by a processor. In one embodiment buffer overflow blocking application is implemented as a system level e.g. kernel mode driver.

While embodiments in accordance with the present invention have been described for a client server configuration an embodiment of the present invention may be carried out using any suitable hardware configuration or means involving a personal computer a workstation a portable device or a network of computer devices. Other network configurations other than client server configurations e.g. peer to peer web based intranet internet network configurations are used in other embodiments.

Herein a computer program product comprises a medium configured to store or transport computer readable code in accordance with an embodiment of the present invention. Some examples of computer program products are CD ROM discs DVDs ROM cards floppy discs magnetic tapes computer hard drives servers on a network and signals transmitted over a network representing computer readable code.

As illustrated in this medium may belong to the computer system itself. However the medium also may be removed from the computer system. For example buffer overflow blocking application may be stored in memory that is physically located in a location different from processor . Processor should be coupled to the memory . This could be accomplished in a client server system or alternatively via a connection to another computer via modems and analog lines or digital interfaces and a digital carrier line.

More specifically in one embodiment host computer system and or server system is a portable computer a workstation a two way pager a cellular telephone a digital wireless telephone a personal digital assistant a server computer an Internet appliance or any other device that includes components that can execute the Return to LIBC attack blocking functionality in accordance with at least one of the embodiments as described herein. Similarly in another embodiment host computer system and or server system is comprised of multiple different computers wireless devices cellular telephones digital telephones two way pagers or personal digital assistants server computers or any desired combination of these devices that are interconnected to perform the methods as described herein.

In view of this disclosure the buffer overflow blocking functionality in accordance with one embodiment of present invention can be implemented in a wide variety of computer system configurations. In addition the buffer overflow blocking functionality could be stored as different modules in memories of different devices. For example buffer overflow blocking application could initially be stored in server system and then as necessary a portion of buffer overflow blocking application could be transferred to host computer system and executed on host computer system . Consequently part of the buffer overflow blocking functionality would be executed on processor of server system and another part would be executed on processor of host computer system . In view of this disclosure those of skill in the art can implement various embodiments of the present invention in a wide variety of physical hardware configurations using an operating system and computer programming language of interest to the user.

In yet another embodiment buffer overflow blocking application is stored in memory of server system . Buffer overflow blocking application is transferred over network to memory in host computer system . In this embodiment network interface and I O interface would include analog modems digital modems or a network interface card. If modems are used network includes a communications network and buffer overflow blocking application is downloaded via the communications network.

This disclosure provides exemplary embodiments of the present invention. The scope of the present invention is not limited by these exemplary embodiments. For example for illustrative purposes specific operations and flow of operations were described above and set forth in the FIG.s. However those of skill in the art will readily recognize that the operations and flow of operations can be varied to meet the specific user s needs and to accommodate differing implementations of the invention.

As another example those of skill in the art will recognize that the organizational relationships of the stack discussed above can be varied from application to application and operating system environment to operating system environment. In addition the number of function sections of the stack can be more or less than the function sections discussed above. Consequently the number of function sections and the organizational relationships of the stack discussed above were chosen for illustrative purposes only and are not intended to limit the invention in any way.

Consequently numerous variations whether explicitly provided for by the specification or implied by the specification or not may be implemented by one of skill in the art in view of this disclosure.

