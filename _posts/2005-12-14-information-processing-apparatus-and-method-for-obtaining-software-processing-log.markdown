---

title: Information processing apparatus and method for obtaining software processing log
abstract: In an information processing apparatus for relaying a calling from a first module to a function inside a second module in software divided into a plurality of modules, the calling is relayed from the first module to the function inside the second module. A log in the second module corresponding to the calling is obtained. The log includes at least a write starting address of binary data and a data size thereof. An area where the binary data is written is determined based on the write starting address and the data size thereof. Whether or not writing into the decided area is permitted is determined. On the basis of the determination result, writing into the decided area of the binary data is controlled. As a result, writing into an invalid area of the log is prevented without modifying the software.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743228&OS=07743228&RS=07743228
owner: Canon Kabushiki Kaisha
number: 07743228
owner_city: Tokyo
owner_country: JP
publication_date: 20051214
---
The present invention relates to an information processing apparatus for obtaining a software processing log and an information processing method for use therewith.

Software failures with a low reproducibility rate are often dealt with by obtaining a software processing log. Hitherto a processing log is obtained by modifying the application software module so as to add a processing log obtaining routine. However in the above described method requiring a modification of application software such as embedding log obtaining code the modification processing becomes complicated.

Accordingly there is proposed a method in which in software that is divided into a plurality of modules by providing a log obtaining module for relaying the calling of a function from a module corresponding to application software the module being present within another module and for obtaining a processing log in the other module corresponding to that calling the log of processing can be obtained without performing complex modifications of application software refer to for example Japanese Patent Laid Open No. 2004 38311 .

When a log is to be obtained as binary data using such a log obtaining module access is made to data on the basis of a memory pointer defined in a parameter for a function and the data is stored. At this time when part or all of the binary data is placed in an invalid area where access is prohibited due to a failure etc. of application software as a result of the log obtaining software accessing the area an exception occurs. Therefore corresponding exception processing needs to be performed.

In regard to the above a method in which the application software itself is changed and an invalid access to memory is detected has been proposed. However since the change of the application software is complex this is not effective.

Accordingly the present invention aims to be capable of preventing a log from being written into an invalid area without the need to modify application software.

The present invention provides an information processing apparatus for relaying a calling from a first module to a function inside a second module in software divided into a plurality of modules the information processing apparatus including a log obtaining unit configured to relay the calling from the first module to the function inside the second module and obtain a log in the second module corresponding to the calling the log including at least a write starting address of binary data and a data size thereof an area deciding unit configured to decide an area where the binary data is written based on the write starting address and the data size a determination unit configured to determine whether writing into the area decided by the area deciding unit is permitted and a write control unit configured to control writing into the decided area of the binary data based on a determination result by the determination unit.

The present invention provides an information processing method for relaying a calling from a first module to a function inside a second module in software divided into a plurality of modules the information processing method including an obtaining step of relaying the calling from the first module to the function inside the second module and obtaining a log in the second module corresponding to the calling the log including at least a write starting address of binary data and a data size thereof a deciding step of deciding an area where the binary data is written based on the write starting address and the data size a determining step of determining whether writing into the area decided by the deciding step is permitted and a write control step of controlling writing of the binary data into the area decided by the deciding step based on a determination result in the determining step.

Other features in addition those discussed above shall be apparent to those skilled in the art from the description of exemplary embodiments of the invention which follow. In the description reference is made to accompanying drawings which form a part thereof and which illustrate an example of the invention. Such examples however are not exhaustive of the various embodiments of the invention and therefore reference is made to the claims which follow the description for determining the scope of the invention.

An embodiment of the present invention will now be described below in detail with reference to the accompanying drawings.

In this information processing apparatus a central processing unit CPU a chip set a random access memory RAM a hard disk controller a display controller a hard disk drive HDD a compact disk read only memory CD ROM drive and a display are incorporated. The CPU and the chip set are connected to each other via a signal line and the chip set and the RAM are connected to each other via a signal line . The chip set and various kinds of peripheral devices and are connected to one another via a peripheral device bus . The hard disk controller and the hard disk drive are connected to each other via a signal line and the hard disk controller and the CD ROM drive are connected to each other via a signal line . The display controller and the display are connected to each other via a signal line .

In order to describe the information processing apparatus corresponding to this embodiment first referring to a description is given of how software divided into a plurality of modules is loaded into a memory in a normal state. shows an example of the internal structure of a RAM.

Usually software divided into a plurality of modules exists in such a manner as to be divided into an executable file EXE for performing the overall control and a dynamic link library DLL that exists as a module and shares the supplementary role of the EXE. In the RAM both the EXE and the DLL are loaded. The EXE is composed of a code segment a data segment and an import function address table . The import function address table is further divided and according to the DLL to which a function belongs and an address at which each function is loaded for each DLL is written to .

The entity of the function of the DLL is loaded differently for each DLL and and each function is loaded as a part of the corresponding DLL to . shows an example in which one EXE uses functions inside two dynamic link libraries of A.DLL and B.DLL and the number of functions that are actually used are six that is Func AA Func AB Func AC Func BA Func BB and Func BC.

When code inside a code segment of an EXE calls the function Func AA first the address of Func AA written inside the import function address table is read. At the address the address of the Func AA code that is read as part of A.DLL is written and by calling the address the code of the EXE can call Func AA of A.DLL.

Next referring to a description is given of an example of the memory structure of an information processing apparatus when a function call is relayed using a technique of an Import Address Table IAT Patch as log obtaining code.

When a log is begun to be obtained C.DLL which is a DLL for IAT Patch is loaded into memory. The C.DLL rewrites the address of the function written into an import function address table into the address of Func CAA Func CAB Func CAC Func CBA Func CBB and Func CBC which are log obtaining codes inside C.DLL. Code to of Func CAA Func CAB Func CAC Func CBA Func CBB and Func CBC inside C.DLL record a log and call corresponding functions Func AA Func AB Func AC Func BA Func BB and Func BC that are loaded into memory so as to receive the original function calling.

When an EXE calls Func AA the log obtaining code inside C.DLL stores the DLL name and the function name in memory stores the calling time in memory stores the parameter during calling in memory and stores the memory content indicated by the pointer parameter during calling in memory . Thereafter C.DLL calls Func AA inside A.DLL which should have been originally called .

When the Func AA processing of A.DLL is completed and control is returned to C.DLL C.DLL stores the time of return time in memory stores the return value in memory and stores the memory content indicated by the pointer parameter at return time in memory . Thereafter C.DLL writes the stored log information in a file and control is returned to the EXE as if Func AA of A.DLL is normally terminated .

Usually when an instance of an interface is created inside the COM server requested interfaces and and methods to thereof are created and they are loaded into memory. Here a virtual address table is created for each interface and and the virtual address table is passed to the EXE that has requested that they be created. In this virtual address table the address created with respect to each method to is written. The EXE calls each interface by using these pieces of information. shows an example in which one EXE creates instances of two interfaces of Interface A and the Interface B and a method inside the interface is used. Methods that are actually used are Method AA Method AB Method AC Method BA Method BB and Method BC.

When the code of the EXE calls the function Method AA first the address of the Method AA written inside the virtual address table is read. At the address the address of the Method AA code created as part of the Interface A of the COM server is written. By calling the address the code of the EXE can call the Method AA of the Interface A.

When obtaining a log is begun DLL for the VTable Patch is loaded into memory. This DLL rewrites the addresses of the methods written inside the virtual address tables and with the addresses of Method A A Method A B Method A C Method B A Method B B and Method B C. which are log obtaining codes inside the DLL. Code of Method A A Method A B Method A C. Method B A Method B B and Method B C inside the DLL record a log and call Method AA and Method AB Method AC Method BA and Method BB Method BC that are loaded into memory so as to receive the original method calling.

When an EXE calls the Method AA the log obtaining code inside the DLL stores the module name the interface name and the method name in memory stores the calling time in memory stores the parameter at calling time in memory and stores the memory content indicated by the pointer parameter at calling time in memory . Thereafter the DLL calls the Method AA inside the COM server which should have been originally called .

When the Method AA processing of the COM server is completed and control is returned to the DLL the DLL stores the time of return time in memory stores the return value in memory and stores the memory content indicated by the pointer parameter at return time in memory . Thereafter the DLL writes the stored log information in a file and control is returned to the EXE as if the Method AA of the COM server is normally terminated .

The exemplary function definition file shown in includes the DLL name and the function method name the parameters and the types of the return values for the function method. In this embodiment on the basis of the content indicated by the function definition file a determination is made as to what kind of parameter return value each function method has and the content is obtained as a log.

As an example the function definition for the function Func AB inside the A.DLL shown in is described below. Func AB includes as arguments a pointer pBuf which points to the data storage target write starting address and dwBufSize which indicates the size of the data. Func AB also indicates the correlation between pBuf and dwBufSize that is the correlation such that the size of the data stored in pBuf is indicated by dwBufSize.

As an example the log of calling the function Func AB inside the A.DLL shown in is described next. When calling Func AB on the basis of the function definition file shown in not only the value 0x5034206D of pBuf as an argument but also data for the amount of dwBufSize i.e. for 24 bytes which exists at the address indicated by that value are stored as another binary log separately from the normal log. An ID for calling the corresponding Func AB which is stored inside the binary log file that is DataID is stored in the log as additional information.

The function definition file the log and the binary log shown in are effective without depending on whether the indication data is input data output data or a return value. For example when the data address is returned as an output parameter from the function and furthermore a data size is output as a return value from the function it is also possible to obtain the log of the data main body in a similar manner.

A description is given of processing performed in the information processing apparatus of the present invention on the basis of the above configuration. are flowcharts corresponding to examples of processing related to the storage of a binary log in this embodiment.

In when processing is started as a result of the set function method being called S the DLL name the function name and the calling time are stored in an HDD S and the parameter for the calling is stored in the HDD S . Next it is determined whether or not the parameter is defined as a memory address on the basis of the function definition file shown in S and a binary storing process is performed S when it is determined that the parameter is defined as a memory address.

The details of the binary storing process S are as shown in and described next. The data size is obtained from the argument indicating the size of the function definition S . The memory area corresponding to the amount of data size is computed from the memory address write starting address indicated by the pointer pBuf and then an inquiry is made to the operating system OS as to whether the computed memory area is a valid area S . Only when the computed memory area is determined to be a valid area data corresponding to the amount of size is read from the memory S and the data to which the DataID is attached is stored in the binary log file of the HDD S . The binary storing process is then ended and processing returns to . On the other hand when the computed memory area is determined to be not a valid area S the binary storing process is directly terminated and storage as a binary log file for the corresponding data is not performed. When the parameter is not defined as a memory address the data storing process is not performed. The binary storing process is then ended and processing returns to .

Referring back to the original function is then called S . When the processing inside the function is completed S the DLL name the function name and the time of termination time are stored in the HDD S and the parameter and the return value are stored in the HDD S . Next it is determined whether or not a parameter is defined as a memory address on the basis of the function definition file shown in S . When the parameter is defined a binary storing process S is performed. The binary storing process is identical to the above described processing shown in . Processing for an abnormality is continued until the program for which an evaluation is made is completed S .

As has thus been described according to this embodiment an inquiry is made in advance as to whether or not the data writing area is a valid area on the basis of the memory address at which data is to be written and the data size. After the data writing area is determined to be a valid area writing is performed. As a result it does not occur that data is erroneously written into an invalid area thus preventing exception processing that should occur when data is written into an invalid area from occurring.

In the above described first embodiment unless the entire binary area where storage is performed is a valid area the process for storing the binary data is not performed at all. However in this embodiment even if some portions of the binary area are invalid the binary data up to that immediately before an invalid memory address exists can be stored.

A description is given below of processing performed in the information processing apparatus of the present invention. are flowcharts corresponding to an example of processing related to the storage of a binary log in this embodiment.

In when processing is started as a result of a set function method being called S the DLL name the function name and the time of calling time are stored in an HDD S and the parameter for the calling is stored in the HDD S . Next it is determined whether or not the parameter is defined as a memory address on the basis of the function definition file shown in S . When it is determined that the parameter is defined as a memory address a binary storing process S is performed.

The details of the binary storing process are as shown in and are described next. The data size is obtained from the argument indicating the size of the function definition S . In loop processing S to S corresponding to the amount of the data size the data area is written in a valid area in one byte units. An inquiry is made to the OS as to whether or not the memory area for one byte at the n th byte from the beginning of the memory address at which the data is obtained is a valid area S . When the memory area is determined to be a valid area n is incremented to make a determination of the next data area S and processing proceeds to S. When the memory area is determined to be an invalid area the determination of the data area is terminated at that point in time and processing proceeds to S. In S it is determined whether n is smaller than the data size. When it is determined that the n is smaller than the data size processing returns to S. When it is determined that the n is not smaller than the data size processing proceeds to S.

When the loop processing from S to S is completed the number of bytes of the valid area becomes n. Next a determination is made as to whether or not there is a valid area according to whether or not n is 0 S . When the memory area is determined that there is a valid area n 0 n byte data which corresponds to the amount of the size is read from the beginning of the memory area S . The data to which DataID is attached is stored in the binary log file of the HDD S . The binary storing process then ends and processing returns to . On the other hand when n 0 and it is determined that the entire area is erroneous the data is not stored and the binary storing process ends and processing returns to . When the parameter is not defined as a memory address the data storing process is not performed.

Referring to the original function is then called S . When the processing inside the function is completed S the DLL name the function name and the time of termination time are stored in an HDD S and the parameters and the return values for the calling are stored in the HDD S . Next it is determined whether or not the parameter is defined as a memory address on the basis of the function definition file shown in S . When it is determined that the parameter is defined as a memory address a binary storing process is performed. The binary storing process is identical to the above described processing in . The above processing is continued until the program for which an evaluation is made is completed S .

According to the foregoing even if some portions of the binary area are invalid the binary data up to that immediately before an invalid memory address exists can be stored.

The present invention may be applied to a system composed of a plurality of devices for example a host computer an interface device a reader and a printer and may further be applied to an apparatus composed of one device for example a copier or a facsimile .

The present invention can be achieved by supplying a storage medium or a recording medium storing software program code that achieves the functions of the above described embodiments to a system or an apparatus. That is the present invention can be achieved by enabling a computer or a CPU or a micro processing unit MPU of the system or apparatus to read and to execute the program code stored in the storage medium. In this case the program code itself read out of the storage medium realizes the functions of the above described embodiments and the storage medium storing the program code can realize the present invention. Also in addition to the functions of the above described embodiments being realized by the computer by executing the read out program code the functions of the above described embodiments may be realized by the OS running on the computer performing part or all of the actual processing based on instructions of the program code.

Moreover the functions described above may be realized in such a way that the program code read out from the storage medium is written to memory provided to a function expansion board inserted to the computer or a function expansion unit connected to the computer and thereafter the CPU provided in the function expansion board or in the function expansion unit performs part or all of the actual processing based on instructions of the program code.

Although the present invention has been described with reference to exemplary embodiments with a certain degree of particularity many apparently widely different embodiments of the invention can be made without departing from the spirit and the scope thereof. It is to be understood that the invention is not limited to the specific embodiments thereof except as defined in the appended claims.

This application claims the benefit of Japanese Application No. 2004 364783 filed Dec. 16 2004 which is hereby incorporated by reference herein in its entirety.

