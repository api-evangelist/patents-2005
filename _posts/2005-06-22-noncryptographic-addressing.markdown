---

title: Non-cryptographic addressing
abstract: To allow down-level devices to participate in a network controlled by a protocol including CGAS or ECGAs, the CGA or ECGA authentication may be made optional to allow the down-level devices to execute non-CGA or non-ECGA versions of network protocols, while at the same time allowing the use of CGA- and/or ECGA-authenticated versions of the same protocols. To identify non-cryptographic addresses (e.g., non-CGA and non-ECGA), the address bits of a non-CGA or non-ECGA such that the address cannot be or is probably not an encoding of the hash of a public key. In this manner, a receiving node may properly identify the capabilities of the sending node, perform an appropriate authentication of the message containing the non-cryptographic address, and/or prioritize processing of information contained in the message with the non-cryptographic address.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08261062&OS=08261062&RS=08261062
owner: Microsoft Corporation
number: 08261062
owner_city: Redmond
owner_country: US
publication_date: 20050622
---
This application is a continuation in part of and claims priority to U.S. patent application Ser. No. 10 401 241 filed Mar. 27 2003 now U.S. Pat. No. 7 409 544 which is incorporated herein by reference.

Authentication is an important issue in many types of network communications. Many messages are meaningful only if the recipient can verify the identity of the sender. For example in network communications an often used form of identity is the network address used by a device to identify itself on the network. Messages are typically tagged with this form of identity which can be used by a recipient to address a message in response. One form of authenticating a message includes authenticating a message that includes a cryptographically generated address CGA . The parent application U.S. application Ser. No. 10 401 241 filed Mar. 27 2003 describes one form of generating an extensible cryptographically generated address and the IETF Request for Comment No. 3972 Cryptographically Generated Addresses March 2005 at http www.ietf.org rfc rfc3972.txt both of which are incorporated herein by reference describe example forms of cryptographically generated addresses and their authentication.

The foregoing examples of the related art and limitations related therewith are intended to be illustrative and not exclusive. Other limitations of the related art will become apparent to those of skill in the art upon a reading of the specification and a study of the drawings.

The following presents a simplified summary of the disclosure in order to provide a basic understanding to the reader. This summary is not an extensive overview of the disclosure and it does not identify key critical elements of the invention or delineate the scope of the invention. Its sole purpose is to present some concepts disclosed herein in a simplified form as a prelude to the more detailed description that is presented later.

Cryptographically generated addresses CGAs including extensible CGAs ECGAs implement one example of authentication services. In one example a CGA or ECGA under the Internet Protocol version 6 IPv6 protocol has some of the network address bits usually parts of the 64 bit interface identifier created from a cryptographic hash of the address owner s public key. Any IPv6 node capable of basic cryptographic operations could generate a CGA for itself and send cryptographically signed messages from this address. In this manner a CGA can be created and verified locally and the receiving node may only need the sender s address and public key to authenticate the messages. In this manner no third parties or additional infrastructure such as a public key infrastructure PKI is needed to verify signatures. Though initially promising earlier contemplated CGA proposals present a major security weakness inherent in the 64 bit limit on the hash length. ECGA solves this weakness with a technique called hash extension.

However some network nodes do not have sufficient computing power to use CGAs or ECGAs. For example embedded devices hand held devices wearable computers and the like may be connected to the network but may not be able to compute public key signatures. Moreover legacy implementations of the protocol stack such as Internet Protocol version 6 IPv6 stack may not have a cryptographically generated address and or may not implement CGA or ECGA based protocols. In this manner down level nodes will not be able to operate in networks and protocols where CGA and or ECGA based authentication of some messages is required.

To allow down level devices to participate in a network controlled by a protocol including CGAS or ECGAs the CGA or ECGA authentication may be made optional to allow the down level devices to execute non CGA or non ECGA versions of network protocols while at the same time allowing the use of CGA and or ECGA authenticated versions of the same protocols. However the peer nodes may not be able to tell securely whether the device that behaves as a down level device is really a down level device. For example an attacking node may claim that the device is a down level device in order to cause other nodes to fall back to less secure protocols. In particular the attacking node may spoof messages from a CGA or ECGA of another node and claim that it is not a CGA or ECGA. In this manner the attacking node may send messages that will not be authenticated by a CGA or ECGA authentication method by pretending to not be capable of CGAs or ECGAs.

In the parent application U.S. application Ser. No. 10 401 241 filed Mar. 27 2003 a CGA or ECGA may be indicated in the network address such as by setting both the u and g bits of an IPv6 interface identifier to 1. In another example the address bits of a non CGA or non ECGA hereinafter non cryptographic address such that the address cannot be or is probably not an encoding of the hash of a public key.

A generic and extensible format for CGAs and an associated authentication mechanism may provide much of the security of heavyweight authentication mechanisms. In some cases the extensible format of a CGA may lower administrative and communicative overhead. The extensible CGAs may effectively remove or reduce the 64 bit limit on the length of a cryptographic hash value. Although extensible CGAs may increase the cost of address generation extensible CGAs may correspondingly increase the cost of brute force attacks i.e. exhaustive searches for hash collisions or creation of large pre computed databases of interface identifiers from an attacker s own public key s used to find matches for many addresses . In many cases extensible CGAs may maintain or slightly increase the cost of address use and verification as compared to prior CGA use and verification. For purposes of brevity extensible CGAs will hereinafter be referred to as ECGAs.

In one example of generating an ECGA an address owner computes two hash values using the public key and other parameters. A second hash value sets an input parameter for a first hash value and at least a portion of the network address is derived from the first hash value. The combination of the two hash values increases the computational complexity of generating new addresses and consequently the cost of brute force attacks. The combination of two hash values allows the address owner to select levels of security above the 64 bit limit of prior CGA based authentication mechanisms.

As another measure against brute force attacks the routing prefix i.e. the portion which is not selectable by the address owner of the address may be included in the first hash input. Including the routing prefix in the first hash calculation increases the cost of pre computation attacks by making some brute force attacks against global scope addresses more expensive because the attacker must do a separate brute force search for each address prefix. Should the address owner move between networks and thereby change the corresponding routing prefix the second hash value can be reused because it may be independent of the value of the routing prefix. In this manner a computationally expensive part of address generation may be avoided and or reduced. Because the high overhead of re calculating the second hash function may not be necessary when the routing prefix changes ECGAs may be suitable for mobile communications applications.

The input to either or both of the first and second hash functions may be formatted as defined in IETF Request For Comments 3972 or as another data structure that contains the public key and possibly other parameters. In another example the input to either or both of the first and second hash functions may be formatted as part of a self signed certificate. A self signed certificate is a standard format for storing and transferring public keys in Internet protocols. The signature on the certificate proves that the public key owner wants to use the ECGA. Additionally certificates make it easier to use ECGA based and Public Key Infrastructure PKI based address authentication side by side in the same protocols. Some protocols however may need to save octets and transfer only the public key and other parameters rather than a full self signed certificate. An optimized parameter format for example one similar to the format in RFC 3972 may be defined for this purpose. Moreover protocols may optimize the transfer of the parameters by avoiding retransmission of parameters already known the receiver or ones sent in other parts of the protocol.

The address owner may use the ECGA as its own address when sending a message or if sending the digitally signed message from another address may indicate that the message is being sent on behalf of the owner of the ECGA. The recipient of the message with the public signature key and other CGA parameters may authenticate the source of the message by performing two hash functions on the public key and other parameters and by verifying the signature on the message.

In an ECGA based authentication mechanism the recipient of the message may be either an separate entity or the same entity that created the message. An example of the latter is the message creator storing messages for retrieval at a later time. When the creator of the message retrieves the message the authentication mechanism assures that the integrity of the message has not been compromised while it has been stored.

In the various examples discussed below one or more of the various problems described above have been reduced or eliminated while other examples are directed to other improvements. Many of the features described above and or other features will be more readily appreciated as the same becomes better understood by reference to the following detailed description considered in connection with the accompanying drawings.

The detailed description provided below in connection with the appended drawings is intended as a description of the present examples and is not intended to represent the only forms in which the present example may be constructed or utilized. The description sets forth the functions of the example and the sequence of steps for constructing and operating the example. However the same or equivalent functions and sequences may be accomplished by different examples.

Although the present examples are described and illustrated herein as being implemented in an authentication mechanism system the system described is provided as an example and not a limitation. As those skilled in the art will appreciate the present examples are suitable for application in a variety of different types of authentication authorization and access control systems.

The following description will introduce generation of an extensible CGA hereinafter ECGA and how the ECGA may be authenticated by an authentication mechanism. Implementation options will then be discussed and how the authentication mechanism may operate in other cases. Features of ECGAs may be used to provide a simple lightweight and or deployable authentication mechanism such as to authenticate a message or other information. For example the authentication mechanism may determine whether the information can be trusted to be from the sender address or other entity it purports to be from. All or a portion of the authentication mechanism may be applied to any type of message or information to enhance security and or authentication.

An authentication mechanism may be deployable within a network environment such as the example network of . As shown in a computing device on a local area network LAN may be accompanied by a server and or a router . The router allows the devices on the LAN to communicate over an internetwork to remote computing devices such as device . The Internet is one example of an internetwork. Any of the devices including the router in may send a message to any other device. In protocols typically used today the message contains the network address of the sender the FROM address the network address of the recipient the TO address .

Consider as a first example that device is operated by a systems administrator authorized to reconfigure the router . For security s sake the router does not accept commands from devices other than device . But when the router receives a reconfiguration command message with a FROM address set to the address of device the router believes the message is authentic and carries out the command. This example is for illustrative purposes only Router communications are generally much more secure than is depicted here. However it is very easy to create and send a message with a deceptive FROM address. For example device could create a router reconfiguration command message and put device s network address in the FROM address field. Without a mechanism for authenticating a message the router cannot know which device actually sent the message. The router does not know that the message is not authentic and carries out the command possibly compromising the security of all of the devices on the LAN. As a second example device uses a Neighbor Discovery protocol to resolve the network address of a router to a link layer address i.e. MAC address and then uses the router when communicating with remote devices such as device . Without an authentication mechanism in place device may impersonate router . Messages from device intended for device would then go to device which may read the contents of the messages discard the messages thus launching a denial of service attack against device and or alter the messages before sending them on to device . As a third example device may interfere with the process in which device obtains a network address. For example if device executes a Duplicate Address Detection protocol to check that no other network node is using the same address as device device may generate messages that make it appear as if all addresses were already in use i.e. owned by some other network node. This way device can prevent device from obtaining an address on the network. These are just three examples illustrating the ubiquitous need for authentication. The examples are extendable to any sort of message sent to any sort of device using any sort of communications method or protocol.

To fend off attacks such as those described in the first two examples of the previous paragraph a recipient of a message may authenticate the sender of the message that is determine if the message was actually sent by the sender indicated in the message. When the recipient is able to reliably determine the true sender of a message then the recipient can choose to act on the message only if it is sent by an appropriate or trusted device. To fend off attacks of the sort described in the third example of the previous paragraph a network node needs a method of generating a new network address and for proving that it has with high probability generated the address itself. Such a method prevents malicious network nodes from falsely claiming ownership of the new address with a significant success rate.

In the description that follows the authentication mechanism is described with reference to acts and symbolic representations of operations that are performed by one or more computers unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of a computing device of electrical signals representing data in a structured form. This manipulation transforms the data or maintains the data at locations in the memory system of the computing device which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data are maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the authentication mechanism is being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.

Referring to the authentication mechanism may be implemented in communications between network nodes on connected computer networks. Each of the network nodes resides in a computing device that may have one of many different computer architectures. For descriptive purposes shows a schematic diagram of an example computing device architecture usable for these devices. The architecture portrayed is only one example of a suitable environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing devices be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in . The authentication mechanism is operational with numerous other general purpose or special purpose computing or communications environments or configurations. Examples of well known computing systems environments and configurations suitable for use with the invention include but are not limited to mobile telephones pocket computers personal computers laptop devices handheld devices set top boxes servers routers network address translators switches wireless access points multiprocessor systems microprocessor based systems minicomputers mainframe computers and distributed computing environments that include any of the above systems or devices.

In a basic configuration as shown in a computing device typically includes at least one processing unit and memory . The memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. The basic configuration is illustrated in by the dashed line .

The storage media devices may have additional features and or functionality. For example the storage media devices may include additional storage removable and non removable including but not limited to PCMCIA cards magnetic and optical disks magnetic tape external hard drives and any other suitable removable or non removable storage. Such additional storage is illustrated in by removable storage and non removable storage .

Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media include but are not limited to HDD RAM ROM EEPROM flash memory other memory technology CD ROM zip drives digital versatile disks other optical storage magnetic cassettes magnetic tape magnetic disk storage other magnetic storage devices and any other media that can be used to store the desired information and that can be accessed by the computing device.

Computing device may also contain communication channel that allow the host to communicate with other devices. Communication channel may include one or more communication channels and is an example of communications media. Communications media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communications media includes wired media such as wired networks and direct wired connections and wireless media such as acoustic radio infrared and other wireless media. The term computer readable media as used herein include both storage media and communications media.

The computing device may also have input components such as a keyboard mouse pen a voice input component a touch input device etc. Output components include screen displays speakers printer etc. and rendering modules often called adapters for driving them. The computing device has a power supply .

A device such as the computing device may write a message in a way that the message could only have been written by this particular device e.g. the message may be authenticated as coming from the sending computing device such as by using an authentication mechanism. The authentication mechanism may be unilateral in that the recipient does not need to have further communications with the sender for completing the authentication process. For example the message may contain everything the message recipient such as the router of needs to decode the message and to determine that it must have come from a particular device such as the computing device .

The authentication mechanism may be based on public key cryptography used in combination with the selection of a network address of the message sender. The selected network address may include an extensible Cryptographically Generated Address ECGA which is based on the public key and other parameters. In the example of the ECGA address is an address of the computing device . One way this address may be derived from the public key of the device is described in connection with and .

The ECGA may be generated in any suitable manner such as by an ECGA generator shown in . An ECGA generator which may be implemented in the computing device of may take one or more inputs or any combination thereof which may include one or more of the public key of the address owner the routing prefix of the network of the address owner a collision count data value which may be initially set to zero a modifier data value a security parameter Sec a time parameter and the like. The modifier may be any suitable modifier which in one example may be a random 16 octet string. The security parameter may be any suitable security input which may be an unsigned 3 bit integer having a value between 0 and 7. The value of the security parameter may be selected by the sending device address owner such as by computing device . The time parameter may define the time to compute a second hash value in generating the ECGA. The ECGA generator outputs a new ECGA address . The output ECGA address may be in accordance with any appropriate protocol including without limitation Internet Protocol version 6 IPv6 a link layer address MAC address and the like. The ECGA generator may output associated CGA parameters and an optional self signed certificate.

In one example the output ECGA may be in accordance with the IPv6 protocol. As shown in an IPv6 address is 128 bits long. It is generally divided into two parts. The leftmost 64 bits are the routing prefix which are used for routing Internet Protocol IP packets across the Internet to the destination network. The rightmost 64 bits are the interface identifier which identifies an individual node within a local network. The interface identifier part of the address is referred to as the node selectable portion because the sending device is free to set this part as it sees fit. The interface identifiers may be chosen in any suitable way e.g. randomly as long as no two nodes on the same network share the same value assigned by a local administrator and the like. While the division of the 128 bit IPv6 address into two 64 bit parts is typical the division can be done in some other proportion. For example the length of the interface identifier may be increased at the expense of decreasing the length of the routing prefix or some parts of the interface identifier may be determined by a routing protocol making them effectively a part of the address prefix.

The network address of the sending node may be identified as an ECGA in any suitable manner including without limitation one or more of a preset portion of the routing prefix a preset portion of the interface identifier a header or message content in the message and the like. For example the network address itself may identify the address as an ECGA. In one example the interface identifier may include two bits which may be set to indicate that the network address is an ECGA. In IPv6 addresses the 7th bit from the left in the 64 bit interface identifier is the Universal Local bit or u bit. It is usually set to 1 to mean that the interface identifier is configured from an EUI 64 identifier from the interface hardware and thus is globally unique. The 8th bit from the left is the Individual Group or g bit which is usually set to 1 for multicast addresses. The bit combination u 1 g 1 is currently unused because a multicast address as indicated by g 1 cannot be globally unique as indicated by u 1 . In this manner the bit combination of u 1 g 1 may be allocated for indicating ECGA addresses. Allocating one or more bits of the network address such and the u and or g bits of an IPv6 address may facilitate mixed use of cryptographically generated and non cryptographically generated addresses in any security protocol without weakening the security of either address type. However it is to be appreciated that ECGA addresses and authentication may be used even if such allocation is not made.

The routing prefix or the interface identifier portion of the ECGA may include a hash indicator indicating the type or length or both of the hash value used in generating the ECGA. In one example the hash indicator includes the security parameter Sec which may indicate the level of security. If a time parameter is used to determine the security level when generating the address the determined security level may be indicated by the security parameter or hash indicator exactly in the same way as if no time parameter were used. That is the mechanism for determining the security level may be independent of the mechanism for communicating the security level in the address. However it is to be appreciated that any suitable hash indicator may be used to indicate the selected second hash value or a set of possible hash values.

If the hash indicator value is encoded into the address bits an attacker may not be able to change the value of the security parameters or other inputs to the first and or second hash values without also changing the address. In one example the hash indicator is an unsigned integer. Although any suitable bit length may be selected for the hash indicator illustrates one example length of the security parameter as 3 bits. The hash indicator may be in any suitable portion of the interface identifier . For example as shown in the hash indicator may be encoded in the leftmost bit position s of the interface identifier or node selectable portion of the ECGA. The hash indicator may allow the address owner to increase the computational cost of address generation and thus to also correspondingly increase the cost of brute force attacks against the address. Thus in some cases as described further below incrementing Sec by one may add 16 bits to the length of the hash that the attacker must break.

To generate an ECGA the network address such as an IPv6 address may include a hash value based on public key information. However the node selectable portion of the network address in IPv6 is typically 64 bits. In some special protocols the node selectable portion may be longer at the at the expense of decreasing the length of the routing prefix. In other protocols such as NAT and firewall traversal protocols the node selectable portion may be shorter such as 48 bits because the routing prefix is longer or some bits of the interface identifier are determined by the protocol. In this manner the length of a hash output is limited to approximately 64 bits and sometimes to as little as 48 bits in IPv6. However in some cases approximately 48 or 64 bits may not provide sufficient security and or may not contain a sufficiently strong cryptographic hash value.

The ECGA includes a hash of the public key as a portion of the network address. As shown in at least a portion of the interface identifier may include at least a portion of a hash of the public key . The hash of the public key may be generated by any suitable first hash function including without limitation MD5 SHA 1 N hash and the like.

With reference to the flowchart of generating an ECGA may begin with determining the address owner s public key. The address owner s public key may be determined in any suitable manner. For example the public key may be determined by the ECGA generator such as by retrieving the public key from memory of the address owner s computing device retrieving the public key from a certification authority and the like. Determining the public key may include transforming or encoding the public key into a format usable by the ECGA generator. For example as shown in operation of the public key of the address owner may be DER encoded as an ASN.1 structure which may have a type such as SubjectPublicKeyInfo.

The ECGA parameters may be determined . For example as shown in operation of the example flowchart of the modifier data value e.g. modifier of may be initialized as 16 random octets or any other appropriate modifier value. The routing prefix e.g. routing prefix of may be set to the routing prefix value advertised by the router at the address owner s local subnet. The collision count e.g. collision count of may be initialized to zero. The public key may be set to the DER encoded public key of the address owner. The determination of the ECGA parameters may include transforming or encoding the ECGA parameter values into a format usable by the ECGA generator. For example as shown in operation of each ECGA parameter may be concatenated to form a CGA Parameters data structure as defined in IETF RFC 3972 which is incorporated herein by reference. In another example the CGA parameters may be DER encoded as an ASN.1 structure.

The second hash value may be computed . Although called the second hash value herein it is actually the first hash value calculated in time. The second hash value may be a hash of a combination of the public key and the one or more of the CGA parameters determined in operation . For example the second hash value may be a hash of a combination of the modifier and the public key of . For example the modifier and public key may be concatenated with zero valued routing prefix and collision count to form a CGA Parameters data structure as defined in IETF RFC 3972 as shown in and the method of . The concatenation may be hashed by a second hash function shown in to provide a second hash value shown in . The second hash function may be any suitable hash function such as the SHA 1 algorithm and may be the same as or different from the first hash function .

The authentication mechanism may use the SHA 1 hash function for the implementation of both the first and second hash functions. The output of the hash function may be longer than is required by the algorithm such as the 160 bits output of SHA 1. In that case the hash value may be truncated to the appropriate length for example by taking the required number of leftmost bits of the hash function output. The SHA 1 algorithm is a one way hash function meaning that it takes a message and converts it into a fixed length string of digits also called a message digest. The speed of the hash function may not be important with respect to the address generation process. The purpose of the second hash function is to set the value of at least one input parameter for the first hash function such as the modifier and it is the combination of the two hash values that increases the computational complexity of generating new addresses. Since the second hash function exponentially increases the cost of hashing the small speed differences between SHA 1 and other hash functions may be irrelevant in the present invention. While SHA 1 is used here as an example of a hash function any other cryptographic function with the second preimage resistance property may be used instead.

In one example the result of the second hash function may be the second hash value in . The bits of a portion of the second hash value may be compared to zero as shown in . For example as shown in the N Sec leftmost bits of the second hash value may be compared with zero and in . For example a second hash value of 00001ccd45bfe68e38b8d47bab2cd070781d765f has a count value of 19 left most 0 bits. If N 16 this corresponds to Sec 1 and N Sec 16. The modifier and the determined count value may be stored in any suitable manner such as in a data store.

The value N may be any suitable value which may depend on the protocol for which the ECGA is used. As shown in step of the value of N may be 16 however it is to be appreciated that any suitable value for N may be used such as 4 8 12 and the like. If the N Sec leftmost bits are all zero or if Sec 0 step and the process continues with the step of respectively. Otherwise the value of the modifier or other CGA parameter that is an input to both the first and second hash values is modified in any suitable manner as shown in . For example another random number may be chosen for the modifier. In another example as shown in the modifier may be incremented in step . The process of computing the second hash value continues again with step of respectively of determining the second hash value using the newly modified modifier and the public key.

The initial value of the CGA parameters such as the modifier in step and the method of modifying the modifier in step can be chosen arbitrarily. In order to avoid repeatedly trying the same value for modifier the initial value may be chosen randomly. The quality of the random number generator may not be important as long as the same values are not repeated frequently. One way to modify modifier is to increment the content octets as if they were a 128 bit integer with any byte order .

For values of the security parameter Sec greater than zero this process is not guaranteed to terminate after a certain number of iterations. The brute force search in steps takes on the average approximately 2iterations to complete the median number of iterations is 0.69 2 .

The value of Sec may be difficult to determine. For example the greater the value of Sec the greater the processing cost may be to generate the ECGA. However if Sec is static increases in computational speed in the marketplace may reduce the security of the resulting ECGA over a period of time. For example if the cost of computing power halves every 18 months the number of zero bits N Sec required in the second hash value should be incremented by 1 every 18 months to maintain the same level of security against brute force attacks. However the prediction of computing power over the next 5 50 years may be difficult. Moreover asking the user or administrator to increase the value of N Sec may be impossible or impracticable if the ECGA is generated automatically at the time the operating system installation or bootstrapping. Moreover a predetermined value of N Sec may be too small which may cause the security of the generated ECGA to be less than desired. Conversely a predetermined value of N Sec may be too large which may cause unacceptable delays in address generation.

A future cost of brute force attacks may be implied by the cost of generating the ECGA e.g. the computing power of the computing system generating the ECGA. For example the input N Sec e.g. Sec of may be replaced by a time input parameter indicating a time to be used for the address generation. In this manner the generation of the second hash value may be based on the speed of the computing device generating the second hash value. The time input parameter may be set or initialized such as in step by any suitable party such as a device manufacturer or operating system vendor or by the user and may be set to the time that the user may be willing to spend on ECGA generation. For example the time input may be set within a range of approximately 1 60 seconds if the user is waiting for the computations to approximately 1 CPU day or more if the computation is done slowly in the background. If the ECGA generation is done by a fast computer or dedicated machine other than the device for which the address in intended the computation time may be set depending on the capacity of the machine used for the ECGA generation. More particularly rather than having an input N Sec based on a number referring to a number of bits the time parameter which is input to the ECGA generator may refer to the time to compute the second hash value of . The time parameter may be in any suitable form and or units such as an integer or real number value in seconds CPU cycles and the like. The ECGA generator may compute multiple second hash values during a time period defined by the time parameter input and the output second hash value may be selected as the most secure hash value generated in that time. The most secure hash value may be determined in any suitable manner such as by the generated hash value in the input time which has the greatest number of zero bits. If the number of zero bits is expressed as N Sec where Sec is a security parameter encoded in some bits of the address the most secure hash value may be determined by selecting the hash value that has the greatest number of zero bits rounded down to the nearest integer multiple of N. The greatest number of zero bits may be in a predetermined portion of the hash value such as a predetermined number of the left most bits may be the greatest number of zero bits within the complete computed hash value may be the greatest number of sequential zero bits within the computed hash value the greatest hash extension and the like.

If the time parameter has been exceeded in the hash value generation the second hash value may be selected from the one or more generated hash values computed by step . In one example one or more of the most secure generated hash values may be stored in a hash value data store. Each hash value may be stored associated with the CGA parameter s used to compute the hash value. The second hash value may be selected in any suitable manner such as by selecting the most secure hash value generated in the time period specified by the time parameter. For example after each hash value is generated the number of zero bits may be counted in the selected portion and compared to the number of count of zero bits of a previous computed hash value. The CGA parameters used to compute the hash value with the greatest number of zero bits in the selected portion may be stored. In this manner the stored CGA parameters at the end of the time defined by the time parameter may be selected for input to the first hash function . The stored and selected values may be stored in any suitable manner such as in a data store and may be associated with one or more other values which may be stored in a data matrix of the data store.

The flowchart in shows an example of how the process of may be implemented in the particular case of the ECGA format defined in RFC 3972. Compared to the flowchart of where the security parameter Sec value is an input to the ECGA generation process is the Sec value in is an output of the computation and a time parameter is received as input. The generation will end if the time parameter is exceeded . During the brute force search loop steps and the hash value that matches the highest found Sec value is stored . After the time parameter is exceeded and the loop terminates the modifier value that produced the highest found Sec value will be used for the remainder of the address generation.

The time parameter limits the maximum time that the CGA generation may take. The address generator may further reduce the average time consumed by the address generation by stopping the search for new modifiers if it is unlikely that a stronger address than has already been found would be found in the remaining time. That is if a second hash value corresponding to security parameter Sec i.e. N Sec zero bits in the second hash value has been found the generator may calculate the probability of finding a second hash value with the next higher security parameter Sec 1 in the remaining time within the limits of the time parameter. This probability may be compared with a predetermined threshold such as 1 50 or 99 . If the probability is below the threshold the generator may stop trying further modifier values and use the most secure hash value and modifier found so far i.e. one with security parameter Sec . When N 8 or N 16 a CGA parameters value such as a modifier value that produces a reasonably secure Sec value may be found early in the process and continuing the brute force search loop until the time parameter is exceeded is very unlikely to find a CGA parameters value such as a modifier value that produces an even higher Sec value. Therefore the early stopping has the potential of significantly reducing the average time spent on ECGA generation.

The early stopping condition may be evaluated as a part of the brute force search loop in . In that case the termination condition for the loop may be triggered not only when the time parameter is exceeded but also when the early stopping condition holds as shown in . The differences between and illustrate the differences between the ECGA generation algorithm such as defined in IETF RFC 3972 and the present example when the time parameter implementation is applied to the standard CGA addresses of RFC 3972.

Given a threshold probability p for finding more secure CGA parameter values maximum time for address generation MaxTime and the already elapsed time t the number of modifier values tried so far n and largest already found security parameter Sec the early stopping condition may be computed in the logarithmic scale i.e. in terms of bit counts . For example the generator may terminate the brute force search if t MaxTime or if t MinTime and N Sec 1 log 2 Max t n t log 2 In 1 1 p . MinTime is a minimum time for which the computation should take. The appropriate minimum time depends on the amount of variation in the CPU power available to the computation and should be set to be large enough to prevent random variations in the computation speed to have an effect on the stopping condition. Alternatively the rate at which hashes are computed n t may be estimated by other means such as by measuring the performance of the CPU s prior to the ECGA generation.

For a given probability threshold p the termination condition may be approximated by computing the numeric value of the last term and by rounding the terms up or down to the nearest integer i.e. to full bits . For example if N 16 and p 99 the above stopping condition can be approximated as t Max or t Min and 16 Sec 1 RoundDown log 2 Max t n t 7 .

The early stopping condition may increase the probability that the search for Sec 1 will continue only if there is a high probability of finding a match in the remaining time. The 16 or 8 bit increments in hash length N 16 or N 8 are relatively large steps. Therefore the generator often stops early because it has found a match for one level of security Sec and has little change of reaching the next level Sec 1 . In the majority of cases this will cause the address generation to terminate much before the allocated time. On some machines however the address generation will take the full allocated time MaxTime.

Once the second hash value has been generated as illustrated in either through a security parameter and through a time parameter the extensible cryptographic address generation can be generated by determining the first hash value. Any suitable process may be used to determine the first hash value based on the second hash value.

For example steps through of or may be used to determine the first hash value using the first hash function. For example the public key may be concatenated with one or more other parameters as shown in and such as a composite of one or more data fields including any one or more of CGA parameters such as the modifier used to generate the second hash value the routing prefix and or the collision count . The modifier value is set in the preceding steps of the second hash computation and may be retrieved from a suitable data store. The collision count is initially set to zero and may be incremented when an address collision occurs as explained further below. The routing prefix may be obtained by the address creator in any suitable manner such as from the network . For example the routing prefix may be determined by listening on the node s network link for advertisements from the local router . For details on how this works on an IPv6 network see the IETF RFC 2462 IPv6 Stateless Address Autoconfiguration and IETF RFC 3971 Secure Neighbor Discovery SEND which are herein incorporated in their entirety for everything they describe.

The combined public key and CGA parameter s may be hashed such as by the first hash function which may include the SHA 1 algorithm step if . The result is the first hash value shown in .

It is to be appreciated that the routing prefix is not an essential input to the first hash function of the above step. The omission of the routing prefix from the input to the first hash function could result in the first and second hash values being identical if all parts of the first and second hash inputs are identical. One solution to prevent two identical hash results is to use a different hash function for the first and second hash functions. Additionally or alternatively two completely different hash values may be instantiated from the SHA 1 algorithm by appending a predetermined and static second modifier e.g. a byte with the value one or zero to the inputs of the first and or second hash value computation. As another example the two hash values may be computed by dividing a longer hash value such as a 160 bit SHA 1 hash into two parts. In this manner one portion of the hash value may be used as the first hash value and a second portion of the hash value may be used as the second hash value.

As shown in the ECGA may be generated based on at least a portion of the computed first hash value. For example at least a portion of the first hash value may be used as at least a portion of the interface identifier or other portion of the ECGA. In one example as shown in and the 64 bit routing prefix and the leftmost 64 bits of the first hash value may be concatenated to form a 128 bit IPv6 address . It is to be appreciated that other protocols may require or allow that the routing prefix and or interface identifier portions may be selected as other bit lengths as appropriate.

In step and as illustrated in the schematic diagram of the address may be modified to indicate that the address is an ECGA. For example as noted above the u and g bits in the address i.e. the user interface portion formed by the first hash value may be both set to 1 which may identify the address as an ECGA. In one example the address may be modified to include the hash indicator. For example where a security parameter Sec is used as described above with reference to the security parameter or count value may be included in at least a portion of the ECGA such as the interface identifier. In one example the three leftmost bits of the interface identifier may be set to the value for Sec. In this manner the first three bits of the first hash value may be replaced by the security value or the portion of the first hash value inserted into the interface identifier portion of the ECGA may be shifted over to make room for insertion of the security value in the ECGA. If the time parameter is used to generate the ECGA the value of Sec or other hash indicator is determined by the allowed computation time and speed of the CPU s used for the ECGA generation. After the Sec value or other hash indicator value is determined the value may be treated exactly as if it had been received as input to the ECGA generation. That is the time parameter need not be encoded into the address bits or communicated when the address is used. Instead the selected Sec value or other hash indicator is encoded into the address or communicated by other means. The hash indicator may be encoded into any portion of the interface identifier such as the three leftmost bits of the interface identifier or the node selectable portion of the ECGA. It is to be appreciated that the u bit the g bit the hash indicator and the like encoded into the interface identifier of the ECGA may replace those bits in those locations of the first hash value or alternatively may be placed in the ECGA and the first hash value located around the encoded parameters. Rather than encoding the ECGA indicator e.g. u and g bits the hash indicator and the like into the ECGA address one or more of the indicators may be sent in protocol messages implied by the protocol specification implied by the context of the communication sent in a certificate sent in the CGA Parameters data structure defined in IETF RFC 3972 discussed further below and the like.

The computing device may check whether the address in step of also shown as step in is already in use by another node in the network i.e. is there an address collision. For example the computing device may check whether there is an address conflict with respect to the generated ECGA . An address collision may be detected in any suitable manner. For example different protocols may provide different ways of determining collisions. In the Dynamic Host Configuration Protocol DHCP which is a protocol for assigning dynamic IP addresses to devices on a network the server keeps track of IP addresses and collisions between the addresses it leases. For IPv6 the mechanism is called duplicate address detection. 

If the device that uses the ECGA as its address moves to another network the ECGA parameters used to compute one or more of the first and second hash values may be modified and a new ECGA may be computed based on one or more modified ECGA parameters by returning to computing the second hash value or returning to computing the first hash value. The CGA Parameters may be modified in any suitable manner. For example the modifier may be incremented or recomputed the collision count may be reset to zero or incremented and the like.

In one example the collision count value allowed in ECGA generation may be capped. For example as shown in and the encoded CGA Parameters structure may be incremented in step . The collision count may be compared to a predetermined maximum number of allowed collisions such as three. If there have been a predetermined number of collisions such as three the process may terminate. If the process terminates an error may be reported at step . If the process does not terminate the address generation process may begin anew with computing a new first hash value with the incremented collision count value.

If no address collision has been detected the process may terminate successfully as shown in . In a successful termination in one example shown in a CGA Parameters data structure defined in IETF RFC 3972 is created by concatenating the modifier routing prefix collision count public key which may be stored in a DER encoded ASN.1 SubjectPublicKey data item and possible extension fields.

A self signed certificate e.g. a X.509 v3 certificate or any other suitable certificate may be created and signed using the public key . The certificate may be in any suitable form and may include any appropriate parameters to aid in verifying the ECGA. For example the certificate may be created using the public key which may be stored in a SubjectPublicKey data item . The certificate may include an extension such as an extnValue data item which encodes one or more of the CGA parameters used in generating either or both the first hash value and the second hash value. The CGA parameters included in the certificate or optimized parameter format may include the hash indicator in addition to or alternative to including the second hash indicator in the ECGA.

In some cases for example in protocols using an optimized parameter format e.g. the CGA Parameters data structure defined in IETF RFC 3972 rather than a certificate creating and signing may be skipped and the optimized parameter format may be created instead. The certificate and or optimized parameter format may be generated in the methods illustrated in either or both .

As explained above the first hash value may create a portion of such as 59 bits of an interface identifier which may have 64 bits in the address . The second hash function increases the cost of brute force attacks i.e. where the attacker varies the hash input in order to match its own public key with somebody else s address. In addition to matching the 59 address bits with the first hash value an attacker must match the predetermined number of zero bits e.g. the left most zero bits with a second hash value as indicated by a security parameter and or a zero count parameter which may be included in the ECGA as noted above. As noted above the predetermined number of zero bits may be N Sec or the number of zero bits in the selected second hash value using a time parameter. This technique called hash extension effectively increases the hash length beyond the 64 bit boundary of earlier proposals. In the N Sec example the resulting level of security is equal to a hash length of 59 N Sec bits.

In some cases if the routing prefix of the address changes but the address owner s public key does not the old value of the modifier may be used. In this manner it may be unnecessary to repeat the brute force search of steps through of or steps if the routing prefix is not included in the computation of the second hash value .

The authentication of ECGAs may be performed as defined in IETF RFC3972 which is incorporated herein by reference. The procedure for the authentication is the same regardless of whether the ECGA generation procedure takes as input a Sec value that determines the number of zero bits in the second hash value or a time parameter that determines the time used for the ECGA generation.

By constructing the unique ECGA of the computing device based on its public key an association between the ECGA of the computing device and its public key is created. This association allows a recipient in of a message to authenticate the computing device as the sender of the message by verifying the association and a signature on the message. In order to authenticate a message as coming from a specific ECGA address as the address owner the computing device may sign the message with its public key . As illustrated in the computing device then sends to the computing device the packet which may include the message the signature and the CGA parameters data structure . The receiving computing device may verify the ECGA such as by using the public key of the sender one or more of the CGA parameters used to generate the first and or second hash values and or the hash indicator such as the number of zero bits in a predetermined portion of the second hash value.

Referring now to and the computing device sends the message to the recipient computing device which may be configured similarly to or different form the computing device illustrated in . The message may contain any suitable content among other things such as one or more of a standard and or non standard IP header and a message body . The IP header may include one or more of the source address the destination address and any other suitable header information . The body of the message may include one or more of a message a CGA parameters data structure a digital signature such as that created during the address generation process and any other suitable information. The message content data may be in plain text i.e. not hashed or encrypted . The digital signature may be generated from data included in the message.

When the computing device receives the authenticated message the receiving computing device may employ a verifier to attempt to authenticate the identity of the sender of the message. The CGA verifier in may take one or more inputs from the received message to verify the sender. For example the ECGA verifier may take the senders address and the CGA parameters .

The verifier may output an indication that the message is trustworthy. If the verifier provides the indication that the message is trustworthy the verifier knows that the CGA parameters contain the public key of the address owner . The verifier may then use the public key to authenticate signed messages from the address owner or to exchange a session key with the address owner . If the sender cannot be verified the verifier may output an indication that the message cannot be authenticated.

In step the CGA parameters such as the CGA Parameters data structure may be found and decoded. For example the CGA parameters may be received from the address owner with the signed message or it may be communicated in some other way such as via an online database. The value of the collision count may checked to determine if it is less than the predetermined maximum number of collisions which as noted above may be three. Thus in one example the value of the collision count may be checked to determine if it is 0 1 or 2. If not verification fails in step . Next in step the value of the data for the routing prefix which may be stored in the CGA Parameters structure may be checked to determine whether it is equal to the routing prefix i.e. the leftmost 64 bits or another number of bits depending on the protocol of the address in the message . If they differ the verification may fail in step . If verification fails any suitable responsive action may be taken such as the verifier may issue an indication of that the authentication of the message of has failed verification.

The public key and one or more data values of the CGA parameters which may be stored in the CGA Parameters structure may be combined such as concatenated in step . The appropriate first hash algorithm e.g. SHA 1 algorithm may then be executed on the combination. The result is the value for first hash value.

In step the predetermined part e.g. leftmost 64 bits of the computed first hash value may be compared with the interface identifier of the address i.e. the rightmost 64 bits of the address . Differences in predetermined bit settings such as the u and g bits and in the predetermined bits storing the security parameter time parameter e.g. the three leftmost bits of the interface identifier may be ignored. If the 64 bit values differ other than in the predetermined bit values the verification may fail and in response the verifier may issue the indication that the ECGA verification process has failed.

If the interface identifier of the ECGA matches the selected portion of the computed first hash value the data values for the public key and the modifier may be combined . For example the public key and the modifier from the CGA Parameters data structure may be concatenated. For another example the routing prefix and collision count in the CGA parameters may be set to zero. The second hash function e.g. the SHA 1 algorithm is then executed on the combination. The result is a value for the second hash value. In step the bits in a predetermined portion e.g. left most bits of the second hash value may be compared to zero or to another predetermined value. In one example the number of zero bits in the predetermined portion may be compared to the value N Sec where the security parameter Sec may be extracted from the ECGA. If any one of the N Sec bits is non zero the verification may fail . In response the verifier may issue the indication which says the authentication process has failed. If Sec equals zero then authentication or verification never fails from step since the number of leftmost bits of the second hash value to compare is zero i.e. 16 0 0 .

If the address authentication succeeds at step the verifier knows that the public key belongs to the owner of the address . The verifier of the computing device has authenticated the address as the ECGA of the computing device which sent the packet . The recipient computing device may then be free to accept the message content data as authentic and may act accordingly.

Referring to an example full life cycle of the authentication process is illustrated as a message sequence diagram. The process begins with the address owner i.e. the computing device providing the input to the address creator i.e. generator . The input may include the public key the security value and or time parameter the initial collision count of zero and or an appropriate routing prefix. The address creator receiving the inputs may generate a protocol compliant ECGA based upon the inputs and the public key. The address generator may return the computed ECGA and the CGA parameters to the address owner. The address owner may determine if a collision has occurred with the generated ECGA. If so the address owner may increment the collision count and request a new ECGA from the address creator. The request may contain one or more of the input parameters and or the address creator may store the input parameters for a time until no collision is detected. If no collisions are detected the address owner can start using the address for communication. The ECGA may then be used to route a message through the network. For example the address owner may create a message and may sign the message with its public key. The message may be sent to a recipient which may access a verifier to authenticate the message. The sent message may contain the sender s network address e.g. the ECGA the CGA parameters the message and the signature of the message. The verifier may verify the message e.g. verify that the ECGA corresponds to the CGA parameters and that the signature is verifiable and the like.

While using a value for security value and or time parameter above zero is optional when the computing device generates the packet for transmission to the recipient computing device the address verifier may support all security parameter values. More particularly the authentication procedure may require a constant amount of computation and or may be relatively fast regardless of the value of the security or time parameters. Moreover if verifiers did not support higher security values there may be less incentive for an address owner to use ECGAs.

The values of modifier and collision count in the CGA Parameters data structure may be ignored in the process of authentication executed by the verifier except for checking that collision count is in the allowed range in step and including both values in the appropriate hash inputs in steps and .

The verifying party can be the same entity as the message creating party. For example the computing device creates messages and stores them locally or remotely in one of the storage device or in . At a later time the computing device retrieves the messages and employs the verifier which may be local to authenticate the retrieved messages. In fact the present invention is employable in any situation in which a message is retrieved and its integrity needs to be checked in order to provide some enhanced level of confidence that it is safe to process.

In protocols where the self signed certificate is used rather than the optimized parameter format e.g. CGA Parameters data structure defined in IETF RFC 3972 the signature verification may be added. For simplicity it is suggested that all protocols that use the certificate require the verification of its signature and validity period.

ECGA based authentication may be attractive for performance and cost. For example ECGAs may be used as a backup when there is no appropriate PKI certificate available or when contacting an on line authority has too high a performance penalty. In many cases there may be no or reduced problems in combining ECGA based authentication with other equally strong authentication methods.

As described above the authentication mechanism for ECGAs associates an authenticated message with its creator. ECGA authentication of ownership may be applicable to applications other than those described above. Potential applications for ECGA based authentication include proof of address ownership in secure neighbor discovery and duplicate address collision detection Mobile IPv6 binding update authentication key exchange for opportunistic IPSec encryption and authentication and the like.

The protocol such as IPv6 address autoconfiguration duplicate address collision detection DAD and neighbor discovery ND may be threatened by denial of service attacks. One vulnerability of protocols is that it is not clear who owns an IP address and who is authorized to control the mapping between an IP address and link layer addresses. For example in stateless autoconfiguration an IPv6 node picks an arbitrary IPv6 address in the network where it is located and sends a broadcast message to check that nobody else is already using the same address. An attacker can prevent other nodes from obtaining an IP address by responding to all duplicate address detection messages and claiming to be using any address that the target nodes pick. Implementation of ECGAs may reduce this dilemma in that duplicate address detection messages could be authenticated using the message address and associated public key.

Neighbor discovery is the IPv6 equivalent of ARP i.e. a protocol for mapping IP addresses into link layer addresses. One vulnerability of mapping IP addresses to link layer addresses is that an attacker can redirect packets away from their right next hop destination by spoofing neighbor discovery messages. ECGA addresses can reduce or prevent the attacks described above. In many cases ECGA addresses may be particularly suitable for securing these protocols because the goal is to authenticate an IP address and not some higher level identifier. A node can create a new ECGA address and then prove its ownership of the address by signing the DAD messages. Similarly signatures on ND messages may prevent or reduce the spoofing attacks. In both protocols individual IP packets are signed. Thus the optimized parameter format may be appropriate for these applications.

In an example of the Mobile IPv6 draft specification the mobile node informs its correspondents about its current location by sending binding updates which must be authenticated to prevent denial of service attacks. The current Mobile IPv6 draft uses a relatively weak non cryptographic authentication method based on the assumption that some network routes are likely to be secure. An alternative may be to use ECGA based public key authentication. ECGA addresses may be particularly suitable for this purpose because Mobile IP uses IP addresses as the only node identifier. ECGA based authentication may also reduce the number of protocol messages. Thus there may be a case for specifying ECGA based authentication as an optional optimization to Mobile IPv6. If both end nodes of a connection have an ECGA address the end nodes may use the ECGAs in a key exchange and create an IPSec security association for encryption and data authentication. This kind of authentication may be done opportunistically i.e. whenever both end nodes support ECGA. The benefits of opportunistic protection may include one or more of preventing IP source spoofing attacks privacy against passive eavesdropping and reducing filtering of IP packets by network intermediaries. In many cases the sending and receiving nodes are authenticating each other s IPv6 addresses not the host names or users. In this case the ECGA based authentication may prevent IP source address spoofing but not DNS spoofing where the attacker interferes with the mapping of domain names to IP addresses. In the future Secure DNS may give a reasonable assurance of the authenticity of IP addresses. Together Secure DNS and ECGA may provide strong authentication of hosts by their domain names. There have also been proposals for storing PKI certificates or public keys in the DNS. An advantage of combining ECGAs with Secure DNS is that the name service need not store the public keys. It only needs to provide a reliable binding between host names and addresses which is its original function.

For further information see Tuomas Aura Cryptographically Generated Address CGA January 2003 submitted for publication which is herein incorporated in its entirety for everything it describes.

As noted above a CGA or ECGA may be indicated within the network address itself such as by setting both the u and g bits of an IPv6 interface identifier to 1. Likewise a network address containing a u or g bit which is not equal to one is not a CGA or ECGA. In this manner a receiving node may identify a network address as compliant or non compliant with a CGA or ECGA authentication protocol which may imply that the sending node associated with the address is compliant or non compliant with CGA or ECGA authentication protocols.

Proper identification of an address and its associated node as non compliant with CGA or ECGA may allow use of non CGA or non ECGA authentication methods in message traffic over the same network or protocol which may require or allow CGA or ECGA authentication for some nodes. In this manner down level nodes may use a CGA or ECGA network while still limiting the ability of attacking nodes to present a CGA or ECGA as a non cryptographic address.

The identification of an address as a CGA ECGA non cryptographic address or other type of address may be used to prioritize the messages for processing. For example messages where the sender address is an authentic CGA or ECGa may be ranked above processing of other message and or address types. Messages with an authentic non cryptographic address may have a priority below that of a CGA or ECGa but may have priority in processing above messages that do not contain a sender s address or which do not have an authenticated CGA ECGA or non cryptographic address. It is to be appreciated that any other prioritization of processing and or authentication of messages based on the sender s address type may be used.

Any suitable method may be used to identify a non CGA or non ECGA hereinafter non cryptographic address while decreasing the ability of an attacking node to spoof a down level node to gain access to possibly less secure authentication methods. For example the address bits of a non cryptographic address may be generated such that the non cryptographic address cannot be or is probably not an encoding of the hash of a public key. In this manner a receiving node may properly identify the capabilities of the sending node.

In one example a non cryptographic address may be generated such that one or more node selectable bits of the non cryptographic address are constant or filled with a predetermined value which is known to peer nodes. Node selectable bits of a network address may include any hits of the network address which are not mandated or controlled by the protocol. For example in IPv6 the interface identifier is node selectable except for some mandated bits which identify features of the address such as the u and g bits discussed above. Thus the node selectable bits of an IPv6 address include those bits of the interface identifier not including bits such as the u and g bits. The predetermined value set within at least a portion of the node selectable portion of the network address may be any suitable value such as a series of zeros or any other suitable value. In one example as shown in the example address of the 32 48 leading bits of the interface identifier of an IPv6 non cryptographic address may be set to zero however it is to be appreciated that any suitable portion of the non selectable bits may be preset to indicate a non cryptographic address. The predetermined value such as a series of zeros in a predetermined location of the node selectable portion of the address may decrease the likelihood that the interface identifier matches a hash of a public key.

The address owner may then use the non cryptographic address to identify itself when sending messages to a receiving node of the network. illustrates an example method of authenticating a message identifying a sending node with a non cryptographic address. The receiving node may receive the message and extract the network address of the sending node. The predetermined portion of the network address may be compared to the predetermined value indicating a non cryptographic address. The predetermined value may be retrieved in any suitable manner such as through a request to a certified authority or address allocation authority retrieval from memory through a request to the sending node and the like. If the predetermined portion of the network address equals the predetermined value the receiving node may determine that the sending address is a non cryptographic address and take appropriate action which may be to accept the message without authentication to initiate an authentication method that is acceptable by down level devices and the like. If the predetermined portion of the network address does not indicate a non cryptographic address the receiving node may initially determine that the sending address may be a CGA or non CGA and initiate the appropriate CGA or ECGA authentication method such as one of those described above.

In another example the non cryptographic address may be generated by computing the hash of a value hereinafter called a non cryptographic value other than the public key of the address owner. The non cryptographic value to be hashed may be any suitable value that may not be confused with a public key such as a random number link layer address a string identifying the node as non CGA or non ECGA compliant and the like. For CGAs governed by RFC 3972 the public key has a specific ASN.1 encoding that may be avoided in selecting the non cryptographic value.

With reference to the non cryptographic address may include a routing prefix and an interface identifier . The interface identifier may include one or more bits which are not node selectable such as the u and g bits . At least a portion of the node selectable portion of the network address e.g. the portion and portion of the interface identifier which may exclude the set bits may contain a hash of the non cryptographic value. The portion of the node selectable portion containing the hash of the cryptographic value may be the same portion of the network address which contains a hash of the public key in accordance with the CGA or ECGA protocol.

The address owner may then use the non cryptographic address to identify itself when sending messages to a receiving node of the network. illustrates an example method of authenticating a message sent by a sending node identified by a non cryptographic address such as that illustrated in . The sending node may generate a message. The message may include the non cryptographic address as the sending node identifier. The message may also contain the non cryptographic value used to generated the address of the sending node. The non cryptographic value may be included in any suitable location and or manner in the message. For example the non cryptographic value may be included in a certificate in the body of the message the non cryptographic value may be included in a header and or body of the message and the like. Alternatively the non cryptographic value may be omitted from the message. For example the receiving node may have prior knowledge of the non cryptographic value and may retrieve the non cryptographic value from a data store the receiving node may retrieve the non cryptographic value from a source other than the message and the like.

The receiving node may receive the message and extract the network address of the sending node. The receiving node may determine the non cryptographic value in any suitable manner. For example the receiving node may extract the non cryptographic value from the message may retrieve the non cryptographic value from memory may request that the sending node or other node send the non cryptographic value in a subsequent message may receive a separate message from the sending node indicating the non cryptographic value and the like. The receiving node may hash the non cryptographic value. The predetermined portion of the network address may be compared to at least a portion of the computed hash of the non cryptographic value. If the predetermined portion of the network address equals the portion of the predetermined value the receiving node may determine that the sender s address is a non cryptographic address and take appropriate action. Appropriate action may include any suitable action such as accepting the message without authentication to initiate an authentication method that is acceptable by down level devices and the like. If the predetermined portion of the network address does not indicate a non cryptographic address the receiving node may determine that the sending address may be a CGA or ECGA and initiate the appropriate CGA or ECGA authentication method such as one of those described above. It is to be appreciated that the extension to CGAs described above may be implemented in generating and authenticating a non cryptographic address including a hash of a non cryptographic value.

At least a portion of the non cryptographic value may be known to or discoverable by the receiving node to authenticate the non cryptographic address. For example the non cryptographic value may be a combination such as a concatenation of a plurality of input values. For example the non cryptographic value may be a concatenation of a first input value and a second input value such as a random number a counter value or an identifier specific to the node that will use the address. The receiving node may have prior knowledge of the first input value e.g. through determination from an authorized provider through determination from information in a prior or related communication through determination from context information or through knowledge of a predetermined value for that sending node or for all non CGA identifier nodes. Any suitable first and second input values may be used as noted above such that the resulting combination in the non cryptographic value may not be confused with or be similar to a public key and or the input string used in generating a corresponding CGA and or ECGA.

The message may include the hash of the non cryptographic value and the second input value e.g. random number used as a portion of the non cryptographic value which as noted above may be included in the sender s address in a header of the message and or body of the message. In this manner the message may not include an unencoded reference to the first input value e.g. in plain text. Similarly if the receiving node has prior knowledge of the second input value such as the random number the message may include the hash of the non cryptographic value and the first input value which as noted above may be included in the sender s address in a header of the message and or body of the message. In this manner the message may not include the second input value. Similarly if the receiving node has prior knowledge of both the first and second input values of the non cryptographic value neither the first nor the second input values may be included in the message other than in their encoded versions within the hash of the non cryptographic value. Although the description here includes a first and second input value it is to be appreciated that more than two input values may be used as appropriate to form the non cryptographic value.

In one example the first input value may be predetermined for a particular node or type of node and known to a receiving node. The second input value of the non cryptographic value may be one of a plurality of possible second input values. The receiving node may know the plurality of possible second input values but may not know which one of the possible second input values was used to generate the non cryptographic value. If the number of possible second input values is small as compared to the computational power of the receiving node the receiving node may try one or more of the possible second input values to determine if any one of the possible second input values was used.

In one example as shown in a first input value and a second input value may be concatenated to form a non cryptographic value . The first input value may be any suitable value such as one or more of a subnet prefix a link layer address NetBIOS DNS name DNS domain suffix of the sending node a predetermined non cryptographic address identifier and the like. The second input value may be any appropriate value such as a random number a member of a set of possible second input values and the like which may be generated and or modified in a manner similar to that described above with reference to the modifier value. The non cryptographic value may be input to a hash function which may be the same as or different from the first or second hash functions described above with reference to . The result of the hash function may be used to determine the hash of the non cryptographic value such as by selecting from the plurality of results of the hash function over a period of time specified by a time parameter discussed further below using a security value or the direct result of the hash function . If the time parameter is set to approximately zero the method may select the first hash result generated. In this manner the computation time spent in generating the non cryptographic address may be limited.

At least a portion of the hash of the non cryptographic value may be inserted into at least a portion of the non cryptographic address. For example as shown in at least a portion of the selected value may be concatenated with the routing prefix and the preset bits in accordance with the governing protocol . In this manner a portion of the selected hash value may be inserted as portion of the non cryptographic address another portion may be inserted as portion of the non cryptographic address and or another portion may be inserted as portion of the non cryptographic address.

As noted above the first and or second input value may be communicated to the receiving node in any suitable manner such as through a header in the message in the body of the message such as in a certificate or may be known to the receiving node. For example as shown in the second input value may be communicated to the receiving node through the sender s non cryptographic address by inserting the second input value in the portion of the non cryptographic address. It is to be appreciated that the order and lengths of the concatenations to form the non cryptographic address may be modified to meet the needs and or concerns of a particular protocol and or node. In one example the second input value may be inserted into an address portion having 16 bits and the portion of the result may be inserted into address portions and which together may have 48 bits. At least a portion of the non cryptographic value e.g. the first input value and or the second input value used to generate the non cryptographic address may be saved in an appropriate data store.

The hash parameters may be initialized in any suitable manner. For example the second input value may be initialized such as by generating a random number selecting a random number from a predetermined set of numbers and the like. The time to compute the hash value may be set to zero and started running to track the time used in computing the hash value. The collision count may be set to zero. The first and second input values may be combined such as concatenated. The combination of the first and second hash values may be hashed to generate a hash output. The time to compute the hash output may be compared to a predetermined or input time parameter. If the time parameter has not been exceeded one or more portions of the non cryptographic value may be modified . For example the first and or second input values may be modified such as by incrementing the value by 1 selecting the next input value in the set of possible input values generating another random number and the like. The newly modified input value may be combined and another hash value computed . This process may repeat until the time parameter has been exceeded. If the time parameter has been exceeded the hash value of the non cryptographic value may be selected from the generated hash values as described above with reference to .

The non cryptographic address may be generated in any suitable manner based on the hash of the non cryptographic value. For example the routing prefix may be concatenated with at least a portion of the selected hash of the non cryptographic value. If the second input value is known to or can be determined by a receiving node such as by trying one or more of a set of possible second input values the second input value may be omitted from the non cryptographic address. In another example the second input value may be concatenated with the routing prefix and the hash of the non cryptographic value to form the non cryptographic address.

The generated non cryptographic address may be compared to existing addresses to determine if an address collision occurs. If a collision occurs one or both of the first and second input values may be modified and the process returned to combining the first and second input values. This process may be repeated until no collision with the generated non cryptographic address is detected or the number of collisions exceeds a maximum collision parameter. If no collision is detected the generation of the non cryptographic address may end . The resulting non cryptographic address may be provided to the address owner stored in a data store and the like. Additionally one or more of the input values and or the non cryptographic value used to generate the cryptographic address may be stored in an appropriate data store. In one if address owner is a down level node a network administrator or address service may compute the non cryptographic address for the address owner and communicate the address to the address owner such as through a network connection or configuration interface such as a user interface or network management tool. The non cryptographic address may be used by the address owner.

As noted above the sending node as the owner of a non cryptographic address may be a down level device. As such the sending node may not be able to hash a public key and or form a certificate. Rather the sending node may itself use legacy protocols to authenticate messages from other nodes e.g. responses sent by receiving nodes . In some cases the address owner may not even know that the receiving node may verify its address as a non cryptographic address. It is to be appreciated that the hash extension method described above may be used to extend the non cryptographic generation and authentication. In this manner the sending node may indicate that it is a down level device and as such unable to verify a CGA or ECGA and the receiving node may determine that the sending node has a non cryptographic address.

In one example the receiving node may initiate authentication of a message based on the non cryptographic address of the sending node. However during the process of authentication the receiving node may identify the address of the sending node as a non cryptographic address. In some cases if a non cryptographic address is detected the authentication of the non cryptographic address may include no further action to authenticate or alternative or legacy protocols may be implemented.

The receiving node may receive the message and extract the network address of the sending node. The receiving node may determine the first input value in any suitable manner. For example the receiving node may extract the subnet prefix or link layer address and the like from the address as the first input value may retrieve a predetermined non cryptographic identifier from memory as the first input value may request that the sending node send the first input value in a subsequent message may receive a separate message from the sending node indicating the first input value and the like. The receiving node may determine the second input value. For example the receiving node may select one second input value from a set of possible second input values extract the second input value from the address of the sending node and the like. In one example the set of possible input values may be a set of integers from 0 16 and the receiving node may select one of the possible second input values. It is to be appreciated that the number range and or values of the possible second input values may be predetermined based on one or more factors including the length of the second input value computational power of down level nodes and or receiving nodes the size of the network the number of down level nodes and the like.

The receiving node may generate the non cryptographic value in any suitable manner such as by concatenating the first and second input values hashing the first and or second input value in accordance with an extended method as discussed above with ECGAs and the like. The receiving node may hash the non cryptographic value. The predetermined portion of the network address may be compared to at least a portion of the computed hash of the non cryptographic value. If the predetermined portion of the network address equals the portion of the hash of the non cryptographic value the receiving node may identify that the sending address is a non cryptographic address and take appropriate action which may be to accept the message without authentication to initiate an authentication method that is acceptable by down level devices and the like. If the predetermined portion of the network address does not indicate a non cryptographic address the receiving node may return to determining the second input value and select the next possible second input value in the set of input values and continue. If after all possible second input values are used and none of the generated hash values indicate a non cryptographic address the receiving node may take appropriate action. For example the receiving node may determine that the sending address may be a CGA or ECGA and initiate the appropriate CGA or ECGA authentication method such as one of those described above. Alternatively the receiving node may determine that the address is neither a non cryptographic address a CGA nor an ECGA and may take appropriate action such as by dropping the received message sending an error message and the like.

It is to be appreciated that the extension to CGAs described above may be implemented in generating and authenticating a non cryptographic address including a hash of a non cryptographic value. For example the first and second input values may be concatenated and hashed by a second hash function. The security parameter or time parameter may be used to select the second hash value. A hash indicator such as a security parameter Sec may be encoded into the address bits or communicated in another way to specify the set of permissible values of the second hash function. The non cryptographic value may include one or more of the routing prefix the first input value the second input value a collision count and the second hash value. The non cryptographic value may be hashed by a first hash function and at least a portion of the result of the first hash function may be inserted into the non cryptographic address. A similar process may be used to authenticate the non cryptographic address.

Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively the local computer may download pieces of the software as needed or distributively process by executing some software instructions at the local terminal and some at the remote computer or computer network . Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all or a portion of the software instructions may be carried out by a dedicated circuit such as a DSP programmable logic array or the like.

Having described and illustrated the principles of our invention with reference to the illustrated embodiments it will be recognized that certain modifications permutations additions and sub combinations thereof of the illustrated embodiments can be made without departing from such principles. It is therefore intended that the following appended claims and claims hereafter introduced are interpreted to include all such modifications permutations additions sub combinations and their equivalents as are within their true spirit and scope.

In view of the many possible embodiments to which the principles of this invention may be applied it should be recognized that the embodiments described herein with respect to the drawing figures are meant to be illustrative only and should not be taken as limiting the scope of invention. For example for performance reasons the cryptographic operations may be implemented in hardware such as on a network card rather than in software. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

