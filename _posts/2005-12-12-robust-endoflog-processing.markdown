---

title: Robust end-of-log processing
abstract: A method of invalidating an unused log file in a database includes examining a discard log information storage area and determining if a discard log exists. If the discard log exists, the log is invalidated. The headers of each of the log files that have been fully invalidated are then invalidated. The discard log is then fully invalidated and a new log file may be generated on top of the discarded log. The method may be interrupted by a failure, a changeover, or crash and will be repeated until it completes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07756838&OS=07756838&RS=07756838
owner: Microsoft Corporation
number: 07756838
owner_city: Redmond
owner_country: US
publication_date: 20051212
---
Determining the end of log is a condition necessary to correctly perform the recovery of a database. Normally database management system preserves state in checkpoints that establish the point in the transaction log from where the recovery processing must begin. But the end of the log is determined by reading the log itself. Traditional methods for finding the end of log are based on two premises. First there is a capability in most database management systems to discover that a log record is not well formed. This not well formed log detection marks the last complete log record. The last well formed log records is deemed the end of log. Second there is a maximum size of I O operations that the database can expect. So by formatting the tail of the log using this maximum I O size in a manner that invalidates the log buffers the system is assured of being able to find an invalid log buffer should a new crash occur and the need to find the end of log arise.

In mirroring systems the mirror is processing the log being sent to it by the principal. In addition the principal and the mirror establish and update the end of log of interest . For example the mirror can tell the principal how far in the log it has committed to disk and vice versa. Given the intercommunication technologies available and the processing of shipping buffers containing log records it is possible for the mirror to be ahead of the principal in committing the log.

When transactional consistency is desired between the principal and the mirror there is additional coordination of log hardening saving to disk that occurs. In particular before declaring that a transaction has committed the principal has to receive from the mirror that it has hardened the log through the records for the transaction being committed. Long running transactions produce many log records before they commit. The processing of transactional statements that manage bulk data produces large volumes of log records before the transaction commits. Thus the mirror can have an arbitrary large amount of log records that are beyond what would be useful in case of a crash and failover. So in case of mirroring when the system fails over to the mirror the log may contain an arbitrary log of records that are not of interest.

For purposes of example assume a mirroring database scenario with a principal sending log records to the mirror. Here the principal is allowed to operate in a mode where the mirror is trailing on a best effort manner to accept transactions and commit them. In this mode there is no guarantee that the mirror is processing the log at a point a logical sequence number LSN which is close to where the principal is processing. In other words the LSN of the log record being processed by the mirror can be much smaller than the LSN of the last log record being produced by the principal. In one example the mirror may be offline for a period of time and then reconnect. Thus the processing of log records between the principal and mirror can vary widely. Throughout this period the principal continues operating undisturbed. It should be clear that in this style of circumstance the amount of log records at the principal may be substantially longer than those at the mirror. Even when full transactional consistency is required between the mirror and the server a long running transaction may also provoke this same circumstance of log records.

In one embodiment a forced failover may be initiated. In such a forced failover the principal fails and the mirror database becomes the principal even though the mirror can be way behind in processing the transaction log. When such a request arrives in a principal System P having a log arbitrarily larger than the log present in the mirror System M data loss may occur. But from the perspective of the database the only challenge is to provide the required internal consistency that is expected. At the mirror database one may apply the traditional method to find the end of log to complete recovery and accept new transactions. System M can do this using the traditional methods.

Some time later system P reconnects to system M. System P starts acting as the mirror and must detect how far ahead of the old mirror it was undo the changes falling in that time range and then beginning synching the log to catch up with the old mirror new principal system M. The system M will have started serving the database as of some point specified by a LSN LSN Fail. The system P will know that it was in step with the mirror up to some LSN LSN PLow up to which it can trust the log as being identical to system M s log. This LSN will be less than or equal to LSN Fail. The system P will also detect the end of its log by traditional scanning the end of log being some LSN LSN PHigh. The log range between LSN PLow and LSN PHigh is subject to the aforementioned undo and subsequently must be discarded. This discard is where problems with the traditional method arise.

If system P were to begin receiving log blocks from system M and simply overlaying the existing discarded log the log would not be scanable via the traditional method as the end would not be detectable. In one instance the log would potentially look corrupt or to complicate things further through lucky block alignment the log might be scanable yet not internally consistent. Thus a problem exists in properly dealing with unusable log records.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In one aspect of the invention an unusable transaction log file called a logical discard log file may be invalidated in a database. The invalidation of the discard log begins after the existence of the discard log is verified by reading information in a storage area. The discard log is data pattern invalidated one log block at a time until the complete discard log file is invalidated. Headers for completely invalidated log blocks are then also invalidated. The storage area information is then reset to no longer indicate that a discard log exists. New log transactions can then be processed.

In another aspect of the invention the above method is modified so that only the first log record is invalidated. Then new log transactions may be processed. This allows the database to come on line faster. The remaining discard log content is invalidated and the header information invalidated at a later time asynchronous from the current processing operations.

In one aspect of the invention dealing with the cleanup of a log that has an arbitrary region of log records that are of no interest in a manner that is robust to multiple failures and backup switches is considered. In one approach the system P described above has to either cleanup the discard log files before receiving new log from system M or process the new log starting from LSN PLow in a new manner to avoid the potential log malformations as described above.

In one embodiment of the invention as part of reconnecting system P as a mirror of system M system P processes the log records in the range LSN PLow to LSN PHigh in a manner that the old discardable log files do not get confused with good current log records. A log record is a virtually contiguous portion of a log block including a log record header and optionally a log record body. A log block is a virtually contiguous portion of a logical log file consisting of a whole number of physical disk blocks and including a block header and one or more log records. A logical log file is a virtually contiguous portion of a physical log file including a logical file header and space for one or more log blocks. Each logical log file is wholly contained within one physical log file. A physical log file is a virtually contiguous file on disk. A physical disk block is the smallest addressable unit of space on a disk volume and is also the unit of atomic input output. Typically it is 512 bytes.

A stable store of database information is checked to determine if a discard log file exists step . In one embodiment the discard log file contains a flag that a discard log exists an log invalidation starting point an ending point and a range of log blocks to be invalidated or discarded. The log invalidation starting point and the ending point are the beginning of the transaction log and the end of the transaction log to be discarded respectively. If a discard log file does not exist then the database may begin accepting new log records representing database use step . If a discard file does exist then the log invalidation starting point is loaded.

In one aspect of the invention a failover or change in database principal may occur between steps and and the method repeats at step until completion at step . If no failovers or changeovers occur the method runs from step to step without being interrupted for a failover. As a result the method does not explicitly test for failover it simply provides that if failovers occur a mechanism exists for the return of the method to step . For example if a failover occurs after or during the read of the discard log file in step the failover event would cause a return to step .

Once step is complete and no failovers occur step the discard log file data is replaced with a data pattern that is identifiable as being invalid step . Examples of invalid data patterns are all zeros all ones or a fixed combination of zero and ones. Invalidating the discard log file is the writing of a selected invalid data pattern into the discard log file to replace the old discard log file contents. Data pattern invalidation begins at the log invalidation starting point read from the stable store. The invalidation of the discard log file is performed in physical block order within each logical file from the log invalidation point LSN PLow to the end of the discard file LSN PHigh .

Once step is complete and no failovers occur step the headers in the discard log files are eliminated. step . The logical block headers are invalidated within the invalidation range. For example if the invalidation range is 8.5 to 10.10 then the logical block headers occurring at 9.0 and 10.0 are replaced with an invalid data pattern to completely invalidate the block 9 and 10 without disturbing block 8.0 which is a committed record. In one aspect of the invention the logical lock headers are invalidated from highest block to lowest block to allow for a recovery if a failover changeover or crash occurred.

Once step is complete and no failovers occur step the discard log existence information is reset step . Resetting the stable store containing the flag indicating that there is a log discard file to invalidate prevents the method from invalidating any more logs. Thus if a failover changeover or crash occurred at this point then no discard file existence flag would restart the invalidating process. Specifically if a crash occurred at or after step then decision block would route the method to step . Resetting the stable store also clears the log invalidation starting point and the end of the discard log file to be invalidated.

Once the existence of a discard log file is reset step then any failover would allow the method to start a new transaction log step . Thus user transactions records are permitted at this point because the database is synchronized and old transaction logs have been discarded.

Improvements to the method are shown in which depicts an example method . Initially a changeover from one database to another is initiated step . This step may include a transfer of information from a principal database to the mirror database. This transfer of information could be done by implication rather than explicit exchange. The transfer of information includes end of log file information which is the last committed record common to both the primary and mirror databases.

A stable store of database information is checked to determine if a discard log file exists step . In one embodiment the discard log file contains a flag that a discard log exists an log invalidation starting point and a range of logs to be invalidated or discarded. If a discard log file does not exist then the database may begin accepting new transaction log records representing database use step . If a discard file does exist then the log invalidation starting point is loaded.

As in in one aspect of the invention a failover or change in database principal may occur between steps and and the method repeats at step until completion at step . If no failovers or changeovers occur the method runs from step to step without being interrupted for a failover. As a result the method does not explicitly test for failover it simply provides that if failovers occur a mechanism exists for the return of the method to step .

Once step is complete and no failovers occur step the discard log file is invalidated step . Invalidating the discard log file begins at the log invalidation starting point read from the stable store. The invalidation of the discard log file is performed in physical file order within each logical file from the log invalidation point LSN Plow to the end of the same logical log file. So the invalidation of the discard log file is abbreviated as compared to the method of .

Once step is complete and no failovers occur step then an update of the log invalidation starting point in stable storage may occur step . For example this changes the log invalidation starting point from 8.5 to 9.0. After the update step a new transaction log may be generated. Thus the database can begin processing new transaction log files. This method provides faster startup times than the previous method .

The rest of the old log invalidation or cleanup may be scheduled by the database management system asynchronously step from the rest of the log operations. Going forward the next logical log file in the range of the discarded log would be invalidated then its header invalidated until the discarded log is fully discarded.

A basic improvement to methods and may occur if the database management system stores in stable storage the values of LSN PLow and LSN PHigh and each time it hardens its log to disk it updates the lower bound of this range. The system then has in stable storage the knowledge of the exact range of log that contains well formed records from a prior epoch. This approach may require additional I O time each time the log is hardened. Some workloads may not be able to tolerate this additional overhead. However because of the increased efficiency of detecting uncommitted log records this approach provides the fastest startup time if combined with methods or .

All of the above approaches enable a system upon recovering from a failure to determine the range if any of the log that is well formed but has records from a prior epoch that are to be ignored or discarded. This knowledge enables determination of the end of log for purposes of recovery.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

Although not required embodiments of the invention can also be implemented via an operating system for use by a developer of services for a device or object and or included within application software. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs appliances lights environmental control elements minicomputers mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.

With reference to an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the form of a computer system . Components of computer system may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer system typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to Random Access Memory RAM Read Only Memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disk Read Only Memory CDROM compact disc rewritable CDRW digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer system such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer system may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM CDRW DVD or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer system . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer system through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory not shown . In addition to monitor computer systems may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer system may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer system although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer system is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer system typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web enabled interface for applications and computing devices making computing activities increasingly Web browser or network oriented.

For example MICROSOFT s .NET platform available from Microsoft Corporation includes servers building block services such as Web based data storage and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device one or more portions of an embodiment of the invention may also be implemented via an operating system application programming interface API or a middle man object between any of a coprocessor a display device and a requesting object such that operation may be performed by supported in or accessed via all of .NET s languages and services and in other distributed computing frameworks as well.

As mentioned above while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any computing device or system in which it is desirable to implement a log file cleanup method. Thus the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same similar or equivalent systems and methods achieved by embodiments of the invention.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention.

While aspects of the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the claimed invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

