---

title: Method and system for an incidental feedback platform
abstract: A vertical can be a series of computer-executable instructions that, in response to an incident, collect information regarding that incident and transmit the information for analysis and possible helpful feedback to the user. A general purpose vertical can address types of incidents, such as crashes or hangs, across a variety of applications, while a custom vertical can be written to address application-specific incidents. Verticals can access underlying support mechanisms through an infrastructure, which can also enable applications to request that additional data be collected by the verticals, and set other preferences. Once the data is collected and transmitted, a vertical may receive feedback, that can be a request for additional information or feedback to the user. The feedback to the user can attempt to identify the incident and aid the user in recovering from it and avoiding it in the future.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07391312&OS=07391312&RS=07391312
owner: Microsoft Corporation
number: 07391312
owner_city: Redmond
owner_country: US
publication_date: 20050422
---
This invention relates generally to program incident handling and more particularly relates to mechanisms for collecting and transmitting information regarding program incidents and providing ameliorating feedback.

All too frequently application programs experience incidents which result in the loss of information forcing users to perform the frustrating and inefficient task of re entering all of the lost information into the application program. Additional inefficiency is created by the need to restart the application program or even the computing device itself in an attempt to recover from the incident or to attempt to prevent further incidents. Unfortunately the vast majority of users are ill equipped to determine why the incident occurred and are therefore generally powerless to prevent its reoccurrence.

The programmers of the application programs and others tasked with supporting the programs after their release are often in a worse position to assess the causes of various incidents because users either cannot adequately describe the circumstances under which those incidents occurred or do not even bother to report them. Consequently many programmers and application support personnel are not even aware of the majority of such incidents and of those incidents of which they are aware they do not possess sufficient information upon which to provide useful feedback. Additionally because many users do not bother to report such incidents the application support personnel often underestimate the existence of the applications faults or receive an insufficient quantity of user reports from which to detect similarities among the incidents and thereby attempt to resolve them.

To address such shortcomings modern operating systems have recently begun to incorporate a rudimentary incident reporting mechanism by which a small pre selected amount of data is saved when an incident occurs and then subsequently data is transmitted to a central repository which can be accessed by programmers and other support personnel so that they may attempt to ascertain a cause and provide a solution to prevent further incidents. Unfortunately such incident reporting mechanisms are often too general to provide useful information regarding the incidents of particular applications. For example an incident reporting mechanism that detects an application incident where the application stops responding commonly referred to as a hang may collect data from an area of memory that the operating system believes is most relevant. However the programmers and support personnel of that particular application may not learn anything useful from the saved data and might have preferred to save a different collection of data which may have provided more useful information. Of course the above assumes that the programmers and support personnel of that particular application would even seek to obtain the data collected by the operating system. Generally such information is reported to the support personnel supporting the operating system and there may exist inefficiencies of communication between the operating system support personnel and the application support personnel.

Therefore what is needed is a mechanism by which application developers programmers and support personnel can specify which information is collected from their applications in the case of particular incidents. In addition the developers and programmers should be provided with default mechanisms which can collect a minimum of information to record those incidents that may not have been foreseen by the developers and programmers of the application or which may be the result of an interaction between the applications of two or more different groups of developers and programmers.

Therefore in one embodiment of the present invention an interface and support structures are provided by which application program developers and programmers can create their own specialized mechanisms to collect and transmit a predetermined set of data in the event that their application program experiences a predefined incident that is relevant to their application.

In another embodiment of the present invention existing mechanisms can be provided to collect a predetermined set of data and can utilize the same interface and support structures but can be directed to more universal incidents that might not be particular to a given application program. Such existing mechanisms can be leveraged by application program developers and programmers without the need to create their own mechanisms should they choose to do so.

In a further embodiment of the present invention the information collected after an application incident can be transmitted to one or more locations for additional automated or manual analysis.

In a still further embodiment of the present invention the predetermined set of data collected after an application incident can be appended to as part of an incident reporting feedback mechanism.

In yet another embodiment of the present invention existing mechanisms provided to collect a predetermined set of data can be extensible so as to enable application programs to register for the collection of additional sets of data.

In yet another embodiment of the present invention a user can receive information in response to the transmission of the collected information which can include instructions or guidelines to avoid or ameliorate the future occurrence of the application incident.

Although the description herein focuses primarily on the collection of information in the event of incidents in the context of application programs it will be appreciated that the description is equally applicable to incidents in the context of any set or sets of computer executable instructions including drivers plug ins modules libraries and the like. Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments which proceeds with reference to the accompanying figures.

Many application programs can for reasons that are not immediately evident to the average user cease to operate in a proper and expected fashion. One such incident can be what is commonly referred to as a hang where the application program ceases to respond to user input and appears to no longer be performing any useful computations. Another such incident is commonly referred to as a crash and can involve a sudden and unexpected termination of some or all of the application program and in some instances the termination of some or all of the operating system processes or other application programs processes. Additionally applications can also experience incidents unique to the particular application. For example complex image editing applications can require the execution of one or more components known as plug ins . Such plug ins can themselves be the cause of one or more incidents which would be unique to those applications that rely on the plug in.

For more universal incidents a single component can be provided for detecting that type of incident irrespective of the suspect application or applications and in response collecting a predetermined set of data to aid in analyzing the incident. Thus a single component can detect a crash by any application and can collect a predetermined set of data about that crash. Similarly a single component can detect a hang by any application and can collect a predetermined set of data about that hang. However for incidents that may be relevant to only a single application a custom component using a standard set of interfaces and support structures can be created to detect those types of incidents and collect a predetermined set of data appropriate for that type of incident. Additionally both the components directed to universal incidents and those directed to application specific incidents are capable of collecting more than the predetermined set of data. The predetermined set of data is a minimum which those components can collect but additional data points can be collected at the request of the application prior to any incident as part of any feedback received after the predetermined set of data has been transmitted or at the request of another process either during or after the incident.

In the description that follows the term vertical will be used to refer to a component process or other collection of executing or non executing computing instructions whose purpose is to respond to a particular incident or types of incidents by collecting at least a default set of data. Verticals as will be described in detail below can use a set of interfaces and other support structures that can be provided by for example the operating system or other lower level code to collect the data. Application developers and programmers will also be able to use those interfaces and support structures to request that existing general purpose verticals such as a crash vertical or a hang vertical collect additional data. Alternatively they could create their own vertical which can access the interfaces and support structures to collect the sets of data deemed important for the particular incident or type of incident to which the custom vertical would be directed to.

Turning to the drawings wherein like reference numerals refer to like elements the invention is illustrated as being implemented in a suitable computing environment. Although not required the invention will be described in the general context of computer executable instructions such as program modules being executed by a personal computing device. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the invention may be practiced with other computing configurations including hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device which can include but is not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Associate VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computing device typically includes a variety of computer readable media which can include any available media that can be accessed by computing device and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computing device . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computing device such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computing device may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used with the exemplary computing device include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computing device . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers hereto illustrate that at a minimum they are different copies. A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computing devices may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computing device may operate in a networked environment using logical connections to one or more remote computers such as a remote computing device . The remote computing device may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computing device is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computing device or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

In the description that follows the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computing devices unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the invention is being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.

Turning to a layer diagram illustrates the interaction of some of the components contemplated by embodiments of the present invention. As will be known by those skilled in the art layer diagrams such as the one illustrated in are generally oriented such that higher level user mode processes appear at the top of the diagram while operating system or kernel mode processes appear at the bottom of the diagram. Thus layer diagram illustrates a series of applications at the top of the diagram namely applications and . As previously described while embodiments of the present invention are described in the context of application programs such as applications and they are equally applicable to any type of computer executable code library or process including drivers plug ins system service threads applets and the like.

Applications and can take advantage of the abilities of lower level components and services such as those illustrated in the lower half of layer diagram through one or more verticals including a Crash Vertical a Hang Vertical a Blue Screen Vertical all collectively referred to as General Purpose Verticals and a Custom Vertical . For example application is illustrated in as being layered on top of Crash Vertical Hang Vertical and Blue Screen Vertical . General purpose verticals such as the General Purpose Verticals illustrated in which comprise the Crash Vertical the Hang Vertical or the Blue Screen Vertical can be made available to all applications such as application or application by default. Consequently absent specific instructions from an application all applications will be able to take advantage of general purpose verticals and application is therefore illustrated as being layered on top of them.

The General Purpose Verticals including the Crash Vertical the Hang Vertical and the Blue Screen Vertical can perform their designated functions by invoking one or more infrastructure . For example the infrastructure can provide a convenient mechanism by which the function of the queue subsystem or the data collection mechanisms can be accessed. As will be described in more detail below the queue subsystem can manage the information that was collected by verticals and enqueued for transmission. In addition the queue subsystem can also retain records of information that was previously enqueued and subsequently transmitted and it can interface with the transport layer to ensure that the enqueued information is transmitted properly and in a timely manner. Similarly the data collection mechanisms can interface with core operating system components to access the information and data requested by verticals and return such information and data to the vertical. The core operating system components can include the operating system registry memory manager thread manager shell display subsystems file system and the like and each such component can receive requests from the data collection mechanisms using known interfaces and can similarly return the requested information to the data collection mechanisms using those same interfaces.

As indicated above application can take advantage of General Purpose Verticals and as such is illustrated as being layered on top of them. In fact in one embodiment of the present invention general purpose verticals can operate without explicit instruction from an application enabling application developers and support personnel to derive benefit from them without modifying their application or explicitly accounting for such general purpose verticals. For example as will be described in further detail below if the application were to crash the core operating system components would detect such a crash and could notify the Crash Vertical . The Crash Vertical could then collect information regarding the crash from the application or from the core operating system components such as the registry or memory manager and then save that information by using the infrastructure to access the data collection mechanisms . The Crash Vertical can then request again via the infrastructure that the queue subsystem transmit the data. If the transport layer already has an active network connection the queue subsystem can request that the collected data be transmitted. Alternatively the queue subsystem can enqueue the data for subsequent transmission.

In addition to general purpose verticals such as the Crash Vertical or the Hang Vertical custom verticals can also be created for an incident that can be experienced by a particular application or class of applications. Such custom verticals would often be created by the developers or programmers of that particular application or class of applications and would be able to specify sets of data to be collected that may be more relevant to the particular incident to which the custom vertical is directed. illustrates one such custom vertical as custom vertical that is illustrated as being used by application . Because custom vertical can be application specific only application is illustrated as being layered on top of it. This is in contrast to more general purpose verticals such as Crash Vertical or the Hang Vertical which are illustrated as layered under both application and application . A custom vertical such as custom vertical can utilize the same infrastructure as the General Purpose Verticals as described above. Alternatively an application such as application can opt out of any reliance on general purpose verticals. Thus as illustrated in application need not be layered above any verticals.

Rather than creating a custom vertical such as custom vertical to collect specific sets of data that might be more useful than the default data collected by a general purpose vertical another alternative contemplated by embodiments of the present invention enables an application such as application or to specify additional data for a vertical to collect. For example an application can register for data that a general purpose vertical such as one of the General Purpose Verticals can collect in the event of an incident to which that vertical is addressed. Such additional elements of data can include a larger segment of the application s memory different locations of the application s memory various files from the file system the values of specific registers other application data maintained by the core operating system components and similar such information.

General purpose verticals and custom verticals can also be invoked directly by an application. Such an invocation can also be a mechanism by which the application specifies one or more additional elements of data for the verticals to collect and transmit.

Turning to a flow of the operation of the Crash Vertical the Hang Vertical and the custom vertical is illustrated in a layered perspective. An application such as application can be executing as illustrated at the top of . Subsequently an incident can occur that can either be a fatal incident or a non fatal incident. As will be known by those skilled in the art a fatal incident generally refers to an incident which renders the application program no longer capable of operating properly. Fatal incidents can include crashes hangs and other similar incidents. A non fatal incident on the other hand can be any improper or unexpected operation on the part of the application program that does not render the program incapable. For example the failure to load a plug in properly display a menu or update a part of the screen can all be non fatal incidents.

Because the application can continue operating after a non fatal incident the application itself can invoke a vertical. Thus as illustrated in the application can call the custom vertical which can then collect information from various information sources generically referred to in as application memory information related to application . Once collected the vertical can transmit the information as illustrated by step for further analysis.

For fatal incidents however because the application can be rendered inoperable external processes can be called upon to detect the incident and invoke an appropriate vertical which can similarly be a separately executing process. For example as illustrated in if the application experiences a crash such an incident can be detected by the operating system unhandled exception filter . The unhandled exception filter as will be known by those skilled in the art is a common element of many modern operating systems that is invoked when an application program crashes. If the unhandled exception filter detects that the application has crashed the filter can invoke the Crash Vertical . The Crash Vertical can collect a predetermined set of data from the application memory information related to application .

As a general purpose vertical the Crash Vertical can collect a default set of data unless the application previously registered for the collection of additional data. The default set of data collected by a general purpose vertical can be selected to balance the need for efficiency with the need to collect a sufficiently broad sample of data such that a wide variety of potential causes can be analyzed. One exemplary set of data collected by a Crash Vertical can comprise 1 the name of the faulting application 2 the version of the faulting application 3 the timestamp when the application was created 4 the name of the faulting module 5 the version of the faulting module 6 the timestamp when the module was created 7 the offset in bytes where the fault occurred in the module calculated by obtaining the location of the instruction pointer at the time of the crash and subtracting from it the load address of the module where the crash occurred and 8 the exception code documenting the type of exception that occurred.

If instead of crashing the application instead experienced a hang the operating system shell or other operating system components could detect the non responsiveness of the application and could invoke the Hang Vertical in a manner analogous to the invocation of the Crash Vertical described in detail above. The Hang Vertical could then similarly collect a predetermined set of data from the application memory information related to application . As with the Crash Vertical a Hang Vertical being a general purpose vertical can collect a default set of data unless the application registered for more wherein the default set of data is selected to provide as much information as can efficiently be collected and which is likely to aid in identifying the cause of the hang. For example the Hang Vertical can collect the same or very similar set of data as the default set of data collected by the Crash Vertical described in detail above.

Returning to the infrastructure as can be seen from the above descriptions provide a rich set of mechanisms and structures through which the verticals can perform their intended tasks whether the verticals are general purpose verticals intended to handle a class of incidents or custom verticals intended to handle application or class specific incidents. While the precise interfaces are not relevant to the present invention the following description is provided to illustrate an exemplary set of interfaces that is not intended to be complete nor limiting but rather provides details about exemplary interfaces that could be made available through the infrastructure as contemplated by one embodiment of the present invention.

One type of interface contemplated by one embodiment of the present invention can be used by verticals to collect information create a report and transmit the report. For example an interface exemplarily called WerReportCreate in Table 1 below can be used to cerate a report about an incident for transmission. More specifically the interface can create a report object which can be populated with all the information about a report as required by the platform in order to complete the reporting process.

In addition to providing interfaces for verticals to perform various reporting functions the infrastructure can also provide interfaces by which those verticals register for callbacks such as can be used for document recovery in a manner to be described in detail below. For example one type of callback interface can enable a vertical to register to be made aware of any attempt to recover the user s work after the incident that resulted in the vertical preparing a report in the first place. Such a callback can provide the vertical with the opportunity to for example prevent the recovery if it would conflict with the vertical or otherwise produce undesirable results prepare for document recovery or even handle the document recovery itself. One such callback illustratively entitled WerReportSetReadyForDocumentRecoveryCallback is described in greater detail in Table 10 below.

In addition to providing interfaces for verticals to perform various reporting functions and receive various callbacks the infrastructure can also provide interfaces by which applications can register for various options and features to be implemented when a vertical irrespective of exactly which vertical it may be handles any of the incidents that may affect that application. For example one such interface can provide a mechanism by which an application can register for some form of recovery. If an application had called this interface during its lifetime and it crashes hangs or encounters any other fatal event that can be handled by a general purpose vertical it can be called at the appropriate time to allow for data recovery. Generally the actual recovery would be handled by the application itself. Table 11 below provides further details of one such interface exemplarily entitled RegsiterSetRecovery .

As can be seen the infrastructure as contemplated by one embodiment of the present invention can provide access to a number of mechanisms and underlying support systems to enable verticals and applications to collect information regarding various incidents and access other attendant alternatives. To illustrate one exemplary use of these interfaces a flow diagram describing the operations performed by verticals according to one embodiment of the present invention is shown in and

Turning to an initiating incident can occur at step as shown. In one alternative contemplated by an embodiment of the present invention if the incident at step was a hang incident a determination of whether the incident was fatal can be made at step . If the incident at step was a non hang incident then steps could be bypassed as will be described in further detail below and the first step after the non hang incident at step would be the determination of whether the incident was fatal at step . In another alternative contemplated by an embodiment of the present invention steps can be performed irrespective of whether the incident at step was a hang incident or a non hang incident. In such a case all incidents can trigger an evaluation at step of whether the incident was fatal. As described in detail above a fatal incident can be one in which the application having the incident ceases to operate properly and cannot be relied upon to execute future instructions properly without being restarted. If at step it is determined that the incident is not fatal an appropriate vertical can use the infrastructure described above to create a default report at step . However if at step it is determined that the incident is fatal then a subsequent determination at step can determine if the application experiencing the incident currently posses the top level window if the application is being run in a windowing operating system. If the application experiencing the incident does not currently possess the top level window then an appropriate vertical can use the infrastructure described above to create a default report at step .

However if the application is determined to have the top level window at step that window can be frosted at step and a notification can be presented to the user indicating the incident and the anticipated vertical behavior in order to aid the user in better selecting an appropriate course of action. As will be known by those skilled in the art the act of frosting a window comprises removing some of the color intensity of the window to visually indicate that the window corresponds to an application or process that is either operating in the background or has ceased operation. Additionally a frosted window enables a more recent window such as the user notification of step to be more noticeable to a user.

If the application experiencing the incident at step is not being run in a windowing operating system then a user interface analogous to that at step can be presented to the user in whichever mechanisms such a non windowing operating system allows for. Alternatively the vertical could use the infrastructure described above to create a default report at step without presenting any user notifications.

Because a user may be concerned about any information that might be transmitted without their consent embodiments of the present invention contemplate a user interface which can convey to the user the nature of the information that will be collected and the potential benefits including possible solutions to the incident that the user may derive from allowing the vertical to send all of the information it collects. If the user closes the user interface then the vertical can operate using a limited behavior as shown at step . Such limited behavior may comprise a reduction in the amount of information collected the type of information collected or the feedback provided as a result of the information collection. However if the user in response to the notification provided at step enables the vertical to operate fully a default behavior can be used as shown at step .

In addition embodiments of the present invention contemplate that the user s authorization to send information can be stored on a per vertical basis. Thus for example if the user had authorized via the user interface presented at step the vertical to send all of the information it collected that explicit authorization could be stored in such a manner that the particular vertical that was authorized would no longer need to request authorization to send an equivalent amount of information. Similarly the user could have a default setting which a vertical could use if the user did not explicitly authorize the collection of a particular level of information. In such a case the limited behavior of step would be commensurate with the user s default authorization.

Initially all verticals can have a default setting that requires the user to be prompted every time the vertical seeks to collect information. The user can be provided with the ability to select different default settings including for example settings that enable the vertical to only send the report parameters or all of the data collected or only safe additional data. For example the user interface presented at step can serve as a mechanism by which the user can select a default setting for the vertical presenting the user interface. Alternatively a common user interface can be presented at a time prior to the incident at step .

Irrespective of whether the vertical executes using a default behavior or a limited behavior however the user notification aspect of the vertical s operations can still be dependent upon whether the incident was a fatal incident as shown at step and whether the application experiencing the incident owned the top level window as shown at step . While illustrates steps and as independent of steps and one of skill in the art will recognize that only a single determination need be made for each of steps and and again for steps and . Thus for example if an initial determination was made as to whether the incident was fatal at step then step or step could be performed immediately after steps or because the system would already know whether the incident was fatal.

As indicated above an alternative contemplated by an embodiment of the present invention skips steps for incidents other than hang incidents. Thus according to that alternative after a non hang incident at step a determination could be made whether the incident was fatal at step and whether it owned the top level window at step without performing steps . In such a case steps and would be the only determinations made of whether the incident was fatal and whether the application experiencing the incident owned the top level window since steps and would not have been performed. As explained in detail above a vertical may already have authorization from a user to collect information such as through a previously presented user interface or a default setting and a user interface would not need to be presented. Consequently steps could be bypassed as indicated. Alternatively the incident experienced at step may not be of a type that necessitates the performance of steps . For example if incident was a hang incident there may be benefits to performing steps . However if the incident was an application specific incident such as the failure to load a plug in it could be very inconvenient for the user to have the application s window frosted as indicated by step . In such a case the application could continue to operate after the incident steps could be bypassed and subsequent steps such as steps and could be performed in the background without affecting the user s ability to continue to use the application.

As shown in if the application experiencing the incident was being run in a windowing operating system and owned the top level window and if the incident was fatal then subsequent to either step or step a progress indicator can be displayed to the user together with additional relevant information as illustrated at step . However if either the incident was non fatal or if the application experiencing the incident did not own the top level window then the vertical need not display any user notifications and can simply collect the information as illustrated in step . If the application experiencing the incident was not being run in a windowing operating system then a user interface analogous to that at step can be presented to the user in whichever mechanisms such a non windowing operating system allows for. Alternatively the vertical could simply collect information as illustrated at step without presenting any user notifications.

Once the information requested by the vertical has been collected it can be enqueued for transmission at step and the vertical can end at step as shown. Those of skill in the art will recognize that steps and can be performed using the infrastructure described in detail above. For example step can comprise invoking one or more interfaces such as the WerReportCreate WerReportSetParameter or WerReportAddFile interfaces described in detail above while step can comprise using an interface such as the WerReportSubmit interface also described in detail above.

If however a progress user interface or some other user notification was presented at step then continuing to the vertical can collect information to prepare a report at step . As above with step step can comprise invoking one or more interfaces such as the WerReportCreate WerReportSetParameter or WerReportAddFile interfaces which were previously described in detail. After collecting the information for the report to be submitted by the vertical a check can be made at step to determine if the host computing device is online. As will be recognized by those skilled in the art the term online refers only to the existence of connectivity between the host computing device and whatever computing device is the destination for the vertical s report and is not intended to signify the use of any particular network or protocol.

If the computing device is not currently online then the information collected by the vertical can be enqueued for transmission at step in a matter analogous to that described above with respect to step . However if the host computing device is online then one embodiment of the present invention contemplates a user feedback mechanism by which the information gathered by the vertical may be able to present the user with a solution to the incident immediately. Additionally another embodiment of the present invention contemplates that the infrastructure can receive real time requests for additional information that may be deemed to be particularly relevant given the information already collected.

Therefore as shown in if the host computing device is currently online then the information collected by the vertical can be transmitted for analysis at step . At step the infrastructure may receive a request for additional data. Additionally as described in detail above the vertical can register for a callback such as the WerReportSetAdditionalDataCallback described in detail above such that if additional information is requested after the vertical has already completed gathering information and submitting its report it can be made aware of the request. The ability to request the collection of additional information can be especially useful for developers and application support personnel if the information commonly collected by a vertical identifies the incident as one of a handful of possibilities but additional information not collected by the vertical by default is required to precisely identify the cause of the incident.

As shown in if a request for additional data is received at step the infrastructure can collect the additional information requested at step and submit a subsequent report at step . As will be recognized by those skilled in the art the additional data can be collected in much the same manner as the preparation of the original report. Specifically rather than responding to a vertical s requests such as via the APIs described in detail above the infrastructure can utilize the routines exposed via those APIs to collect the requested information itself. Additionally as illustrated by the loop comprising steps and there can exist multiple requests for additional data. For example if the additional data requested may be large it may be more efficient to request only a subset initially especially if that subset may rule out a particular analysis that would have required significantly more data collection.

If there are no requests for additional data at step or no further requests the infrastructure may receive a response that provides the user with additional information regarding the incident. For example if the incident is a known or common incident the user can be provided with information regarding its cause and possible solutions. Alternatively the user may be informed that an updated version of the application that experienced the incident is available that no longer shares the same issue. If the incident is one that has not yet been solved by the application s support personnel then the user may be presented with generalized information regarding possible causes or possible preventative steps that the user can take. The infrastructure can receive the response for the user in much the same manner as it receives the requests for additional data.

The infrastructure can display any responses to the user at step as shown in . Such responses can provide the user with information that can reduce or eliminate future occurrences of the incident at step . For example if the incident was caused by a known problem that may have been corrected in a newer version of the application experiencing the incident the user can be informed of the availably of the newer version. Similarly if the incident was caused by a known problem what was corrected by additional computer readable instructions commonly referred to as a patch the user can be presented with a location from which the user can download the patch and install it. For those users who wish to minimize their efforts an option can be provided by which such patches are automatically downloaded and installed. Alternatively if the cause of the incident at step is unknown then the user can be presented with a series of suggestions that may be generally helpful when dealing with incidents similar to the incident at step . Once the user has been presented with any responses that may have been received the process can end such as in step and the vertical it can signal its completion to other processes so that the memory used by the vertical can be released and if the application experienced a fatal incident the application can be restarted. One such interface that can be used by the vertical to end properly can be the WerReportCloseHandle interface described in detail above.

As can be seen the infrastructure can provide mechanisms by which general purpose verticals such as the Crash Vertical or the Hang Vertical can be created to collect information regarding specific incident types and transmit that information to application support personnel so that a solution may be found. In addition the infrastructure can be used to create custom verticals such as custom vertical that can be used to collect information for a specific incident. Applications can request the verticals to collect additional information and can request to be notified when the vertical has completed in order to attempt to recover from the incident. Once a vertical has sent the information it has collected the infrastructure may receive a request for additional information to which it can similarly respond or it can receive feedback that can be presented to the user.

In view of the many possible embodiments to which the principles of this invention may be applied it should be recognized that the embodiments described herein with respect to the drawing figures are meant to be illustrative only and should not be taken as limiting the scope of invention. For example those of skill in the art will recognize that some elements of the illustrated embodiments shown in software may be implemented in hardware and vice versa or that the illustrated embodiments can be modified in arrangement and detail without departing from the spirit of the invention. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

