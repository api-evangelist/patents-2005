---

title: Automated rootkit detector
abstract: Embodiments of a RootKit detector are directed to identifying a RootKit on a computer that is designed to conceal malware. Aspects of the RootKit detector leverage services provided by kernel debugger facilities to automatically obtain data in specified data structures that are maintained by an operating system. Then the data obtained from the kernel debugger facilities is processed with an integrity checker that determines whether the data contains properties sufficient to declare that a RootKit is resident on the computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07571482&OS=07571482&RS=07571482
owner: Microsoft Corporation
number: 07571482
owner_city: Redmond
owner_country: US
publication_date: 20050628
---
As more and more computers and other computing devices are interconnected through various networks such as the Internet computer security has become increasingly more important particularly from invasions or attacks delivered over a network or over an information stream. As those skilled in the art and others will recognize these attacks come in many different forms including but certainly not limited to computer viruses computer worms system component replacements Trojans RootKits spy ware denial of service attacks even misuse abuse of legitimate computer system features all of which exploit one or more computer system vulnerabilities for illegitimate purposes. While those skilled in the art will recognize that the various computer attacks are technically distinct from one another for purposes of the present invention and for simplicity in description all malicious computer programs that spread on computer networks such as the Internet will be generally referred to hereinafter as computer malware or more simply malware.

When a computer system is attacked or infected by computer malware the adverse results are varied including disabling system devices erasing or corrupting firmware applications or data files transmitting potentially sensitive data to another location on the network shutting down the computer system or causing the computer system to crash. Yet another pernicious aspect of many though not all computer malware is that an infected computer system is used to infect other computer systems that are communicatively connected by a network connection.

A traditional defense against computer malware and particularly against computer viruses and worms is antivirus software that is available from numerous software vendors. Most antivirus software identifies malware by matching patterns within data to what is referred to as a signature of the malware. Typically antivirus software scans for malware signatures when certain events are scheduled to occur such as when data is going to be written or read from a storage device on the computer. As known to those skilled in the art and others computer users have ongoing needs to read and write data to storage devices such as a hard drive. For example a common operation provided by some software applications is to open a file stored on a hard drive and display the contents of the file on a computer display. However since opening a file may cause malware associated with the file to be executed antivirus software typically performs a scan or other analysis of the file before the open operation is satisfied. If malware is detected the antivirus software that performed the scan may prevent the malware from being executed for example by causing the open operation to fail.

Increasingly malware is being distributed with one or more programs specifically designed to hide the malware from software designed to protect a computer e.g. antivirus software anti spyware software and the like . Similar to other types of applications installed on a computer software designed to protect a computer from malware relies on services provided by an operating system to search for malware. However if a malware is able to infect components of a computer operating system the malware may control the information that is provided to software designed to protect a computer. Malware that is specifically designed to conceal other malware on a computer will be generally referred to hereinafter as a RootKit. 

For illustrative purposes and by way of example only depicts how a RootKit is able to control the information that is made available to software designed to protect a computer from malware. As illustrated in the computer includes an application program an operating system a storage device and a RootKit . Also the operating system includes an interface that provides services in the form of an Application Programming Interface API to application programs installed on the computer . The application program performs actions designed to protect the computer from malware. For example the application program may scan files for malware on access when a user attempts to access a file stored on the storage device . However as illustrated in the application program performs operations in user mode and relies on services provided by the operating system that operates at least partially in kernel mode. Moreover the computer is infected with the RootKit that hooks into the operating system where it intercepts calls used to perform basic functions on the computer . Stated differently the RootKit acts as a man in the middle monitoring and altering communications between the operating system and application programs installed on the computer . If an application program attempts to list the contents of a directory containing one or more files used by the RootKit the RootKit will censor the file name from the list. Similarly the RootKit may hide entries in the system registry process list and the like thereby controlling all of the information that the RootKit wants hidden.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

The foregoing problems discussed in the Summary are overcome by a RootKit detector embodiments of which are directed to identifying a program on a computer that is designed to conceal malware installed on the computer. More specifically in one embodiment the RootKit detector performs a method that leverages services provided by kernel debugger facilities to obtain data from data structures maintained by an operating system. Those skilled in the art will recognize that kernel debugger facilities allow a kernel debugger application to troubleshoot a program as it executes by stepping line by line through the program and providing the value of variables registers stacks and the like in order to identify improper logic in the program. The kernel debugger facilities are used by the RootKit detector to automatically obtain data that is maintained by an operating system. Then the data obtained is processed with an integrity checker that determines whether the data has properties sufficient to declare that a RootKit is resident on a computer.

In another embodiment the RootKit detector acts as a software system that searches a computer for a RootKit. More specifically the software system includes 1 kernel debugger facilities operative to obtain data stored in data structures maintained by a computer operating system 2 an integrity checker that determines whether data obtained by the kernel debugger facilities contains properties characteristic of a RootKit and 3 a detection module that coordinates obtaining data maintained by the operating system with the actions performed by the integrity checker in order to automate the process of determining whether a RootKit exists on the computer.

In still another embodiment a computer readable medium is provided with contents i.e. a program that causes a computer to operate in accordance with the methods described herein.

Embodiments of a RootKit detector described herein are directed to identifying a RootKit on a computer that is designed to conceal malware that is resident on the computer. Aspects of the RootKit detector leverage services provided by kernel debugger facilities to automatically obtain data from specified data structures that are maintained by an operating system. Then the data obtained from the kernel debugger facilities is processed with an integrity checker that determines whether the data contains properties sufficient to declare that a RootKit is resident on the computer. While the RootKit detector will be described primarily in the context of identifying a malware commonly known as a RootKit those skilled in the art and others with recognize that the concepts described herein may be applicable in other contexts.

Now with reference to a computer with software components that implement a RootKit detector will be described. The computer illustrated in contains many of the same components of like name described above with reference to . In this regard the computer includes an application program an operating system and a storage device . Also the operating system includes an interface kernel debugger facilities an integrity checker and a detection module . Collectively the components included in the operating system that implement the RootKit detector provide a way to identify a RootKit that is resident on the computer .

The operating system may be a general purpose operating system such as a Microsoft operating system UNIX operating system or Linux operating system. As known to those skilled in the art and others the operating system controls the general operation of the computer and is responsible for management of hardware and basic system operations as well as executing application programs. More specifically the operating system insures that computer programs such as application program are able to use hardware resources like the storage device . Modern computers allow application programs to extend the functionality of the operating system by providing mechanisms for code to execute in the memory space reserved for the operating system . The problem with these types of systems is that a RootKit may compromise the integrity of the data provided by the operating system to application programs.

As illustrated in the operating system includes kernel debugger facilities operative to obtain data stored in data structures maintained by the operating system . As mentioned previously the kernel debugger facilities have traditionally been used by kernel debugger applications to troubleshoot a program as it executes by stepping line by line through the program and providing the value of variables registers stacks and the like. Typically the kernel debugger facilities are used to analyze and identify improper logic in the core components of the operating system as well as drivers and kernel mode extensions and services. In this regard the kernel debugger facilities support setting breakpoints manipulating program execution using a variety of commands formatting the display of operating system data structures and the like. However those skilled in the art and others will recognize that the kernel debugger facilities include but are not limited to all of the services provided by an operating system firmware and hardware resources that have been provided to kernel debugger applications.

As described in further detail below aspects of the RootKit detector may operate in a variety of contexts of which the following are only examples. As illustrated in the kernel debugger facilities may be used on a stand alone computer to obtain and analyze data in a live debug session. In this instance the kernel debugger facilities take a snapshot of the data maintained by the operating system and perform a read only analysis of the data obtained to determine whether a RootKit is resident on the computer . If a RootKit is resident on the computer aspects of the RootKit detector attempt to clean the infection by changing the configuration of the computer for example by modifying data in a system registry. Alternatively aspects of the RootKit detector including the kernel debugger facilities may be located on a remote computer or computing device not illustrated . In this instance a target computer such as computer maintains a connection with a host computer or computing device that stores software routines that implement the RootKit detector. The connection between the host and target computers may be direct or a network connection. In either instance the host computer is configured to suspend execution of the target computer for example by using services provided by kernel debugger facilities. Then an online session is initiated in which data maintained by the operating system on the target computer is analyzed to determine whether a RootKit is resident on the target computer. Moreover data in kernel memory on the target computer may be modified by the RootKit detector so that software routines implemented by a RootKit may be bypassed. As a result signature based techniques for detecting and cleaning a RootKit from a computer may be employed. Finally the RootKit detector may be used solely in the context of determining whether a target computer is infected with RootKit. For example the RootKit detector may be configured to obtain and analyze a memory dump of the data maintained by the operating system on a target computer. In this instance the kernel debugging facilities extract relevant information from the memory dump that is analyzed offline to determine the extent to which a network of computers has been infected with a RootKit.

As illustrated in the operating system also maintains an integrity checker and a detection module . In one embodiment of the RootKit detector described herein the integrity checker and the detection module are provided as an extension to the kernel debugger facilities . In this instance the kernel debugger facilities expose functionality typically in the form of library routines to the integrity checker and the detection module . In an alternative embodiment the software routines that implement the RootKit detector including the integrity checker and detection module are contained in a driver. In this instance the driver is configured to communicate with one or more user mode applications e.g. antivirus software anti spyware software system utilities and the like to identify programs designed to conceal malware on the computer when called by the user mode application.

In the embodiment of the RootKit detector illustrated in the operating system also maintains an integrity checker for determining whether data obtained by the kernel debugger facilities contains properties that are characteristics of a RootKit. Generally described there are three primary techniques in which the integrity checker may identify a RootKit on a computer. In one technique the integrity checker compares data as reported by the interface to the actual properties as identified by the kernel debugger facilities . In this instance a request is made to the interface to provide data that describes the state of the computer . For example a request may be made to the interface to generate a report regarding files stored on the computer that may include file name size date created time last modified checksum and the like. Then the file properties as reported by the interface are compared to actual file properties as identified in the data obtained by the kernel debugger facilities . In this regard a more detailed explanation of a system that identifies a RootKit by comparing differences between actual and reported data may be found in commonly assigned co pending U.S. patent application Ser. No. 10 997 768 filed Nov. 23 2004 titled Method and System for Detecting Infection of an Operating System the content of which is expressly incorporated herein by reference.

In a second technique heuristics are employed to analyze suspicious modifications that are made in data structures maintained by the operating system to determine whether the modifications were generated by a RootKit. In this regard the integrity checker may identify jump instructions in unexpected locations search for hidden processes check references to memory addresses that are outside of a normal range and the like in order to identify behaviors that are characteristic of a RootKit. For example some operating systems maintain a data structure sometimes referred to as a process table that contains a list of programs that are scheduled to be executed. Those skilled in the art and others will recognize that legitimate reasons exist for programs to read data from the process table. However removing an entry from a process table or a similar data structure may be a strong heuristic indicator that a RootKit is attempting to conceal and malware. As described in further detail below the RootKit detector may use the kernel debugger facilities to set breakpoints when a modification to a kernel data structure occurs so that the entries in these data structures may be analyzed at a later point in time. Those skilled in the art and others will recognize that heuristic techniques that search for behaviors characteristic of malware are particularly effective in identifying previously unknown RootKit.

In a third technique the integrity checker employs traditional signature based techniques for detecting a RootKit on the computer . For example file data that implements a RootKit may be identified by matching patterns within the data to what is referred to as a signature of the RootKit. In this regard data that is known to implement a RootKit or a characteristic subset of the data is processed with a function that converts the data into a signature that may be used to identify the RootKit. For example data that implements a RootKit may be processed using the Message Digest algorithm 5 MD5 hashing algorithm to generate a signature. Once the signature is generated the integrity checker searches data in the memory of the computer for a matching signature.

The operating system illustrated in also contains a detection module . Since aspects and different embodiments of the detection module are described below with reference to the detection module will not be described in detail here. However generally described the detection module coordinates obtaining data maintained by the operating system with checking the data for properties that are characteristic of a RootKit. Moreover the detection module performs actions to prevent the occurrence of false positives in which a benevolent application program is incorrectly identified as a RootKit.

As known to those skilled in the art and others is a simplified example of one computer capable of performing the functions of the RootKit detector. Actual embodiments of the computer will have additional components not illustrated in or described in the accompanying text. Also shows one component architecture of software modules that may be used to identify a RootKit. Thus the software components illustrated in should be construed as exemplary and not limiting.

In accordance with one embodiment of the RootKit detector when a suspicious modification is scheduled to be made in a data structure maintained by the operating system the RootKit detector causes the kernel debugger facilities to set a breakpoint before the modification is completed. Those skilled in the art and others will recognize that the state of the computer where the breakpoint is set may be re created at a later point in time. By using the kernel debugger facilities to set a breakpoint before a suspicious modification is made the RootKit detector is able to rollback the state of a computer in order to more accurately determine whether a RootKit is resident on the computer.

Now with reference to an exemplary embodiment of a detection module illustrated in that determines whether a RootKit is resident on a computer will be described.

As illustrated in the detection module begins at decision block where it remains idle until a scanning event is identified. Those skilled in the art and others will appreciate that programs designed to protect a computer from malware may initiate a scan for malware in many different circumstances. For example existing programs in which the RootKit detector may be integrated such as antivirus software anti spyware software system utilities and the like may be configured to perform a scan for malware on demand when a user or software system generates a command using a Graphical User Interface or similar input system. However as mentioned previously a scan for malware may also be performed on access when a user or software system selects an application program for execution. Since executing an application program may expose a computer to malware the scan is performed before execution is initiated. However those skilled in the art and others will recognize that the scanning events described above should be construed as exemplary and not limiting as the detection module may begin functioning in other instances not described herein.

At block the detection module causes the kernel debugger facilities to obtain data in specified data structures maintained by the operating system. At block entries in data structures that have a high probability of being modified by a RootKit are obtained using the kernel debugger facilities. When the data is obtained it is available to a software module that performs an integrity check in order to determine whether a RootKit is resident on the computer. Significantly the functionality of the kernel debugger facilities may be exposed to the detection module as a set of routines so that the data may be obtained automatically without requiring input from a user or software developer. Moreover since the kernel debugger facilities may directly access data in the data structures without using an Application Programming Interface a RootKit that hooks into the operating system or otherwise intercepts calls made to the operating system is bypassed. As a result using the kernel debugger facilities to obtain the necessary data prevents malware that uses traditional techniques from altering the data before the properties of the data may be analyzed.

As illustrated in at block the detection module causes an integrity check to be performed on the data obtained by the kernel debugger facilities at block . As mentioned previously one aspect of the RootKit detector is a software module e.g. the integrity checker that is configured to perform an integrity check on data maintained by an operating system to determine whether a RootKit is resident on a computer. For example a data structure typically known as a process table is used by modern operating systems to track programs that are actively performing operations on a computer e.g. processes . Those skilled in the art and others will recognize that a process table contains all of the information that is saved when a Central Processing Unit CPU switches from executing one process to another process in an operating system that supports multitasking. The information in the process table allows a suspended process to be restarted at a later time as though the process had not been suspended. Frequently a RootKit will obscure a malware process by hooking into one or more API calls that access the process table. Thus in this example the integrity checker performs an analysis that compares the data obtained by the kernel debugger facilities at block which contains the actual contents of the process table with data that is returned in response to an API call that may have been modified by a RootKit. If data obtained by the kernel debugger facilities contains a reference to a process that is not identified in response to the appropriate API call then the computer is infected with a RootKit. However it should be well understood that the example provided above should be construed as exemplary and not limiting. For example as mentioned previously with reference to the integrity checker is also configured to analyze data for purposes of RootKit detection using other types of techniques such as traditional signature based scanning techniques and heuristics.

While blocks and are illustrated in as being performed sequentially in alternative embodiments the detection module coordinates an exchange of information between a kernel debugger facilities and the software module that performs an integrity check e.g. the integrity checker . For example the integrity checker may perform an analysis at block and determine that additional data is needed to accurately determine whether a RootKit is resident on a computer. In this instance the detection module may proceed back to block so that kernel debugger facilities may obtain additional data. By way of another example the integrity checker may perform an integrity check at block and determine that entries in a data structure when a breakpoint was set are needed to determine whether a RootKit is resident on a computer. In this instance the detection module may proceed back to block and cause the kernel debugger facilities to obtain data from a data structure that represents the state of the computer at a previous point in time.

At decision block the detection module determines whether the integrity check performed at block identified a RootKit that is concealing malware on the computer. In one embodiment the software module that performed the integrity check e.g. the integrity checker notifies the detection module when data characteristic of RootKit is identified using techniques that are generally known in the art. If the detection module is not notified that a RootKit is resident on the computer then the detection module proceeds to block described below. Conversely if data characteristic of a RootKit was identified the detection module proceeds to block .

At block the detection module compares data obtained by the kernel debugger facilities at block with a white list of good or benevolent application programs. Those skilled in the art and others will recognize that legitimate application programs frequently perform operations that hook into an operating system to perform legitimate operations. For example antivirus software will typically intercept a file open command to scan data in the selected file for malware before the command is satisfied. Since legitimate application programs frequently perform actions that are similar to the actions that are performed by a RootKit false positives or instances in which a RootKit is incorrectly identified have been known to occur. To prevent the occurrence of false positives the detection module compares data obtained by the kernel debugger facilities with a set of data that represents a white list of benevolent applications. For example in one embodiment the data obtained by the kernel debugger facilities at block is processed with a hash function to generate a signature that uniquely represents the software state of a computer. Then the signature is compared to a white list of signatures generated using the same technique on computers with a legitimate application program installed. In this regard developers generate a white list of signatures by identifying legitimate application programs that perform hooking operations that may be incorrectly identified as a RootKit. Since techniques for generating a signature using a hash function are generally known in the art further description of this technique will not be provided here.

At decision block the detection module determines whether a match to a signature maintained in a white list was identified a block . If a match was identified then the detection module determines that a RootKit is not resident on the computer and proceeds to block where it terminates. Conversely if a match was not identified the detection module proceeds to block described below.

At block the detection module compares data obtained by the kernel debugger facilities at block with a black list of application programs that are known to be a RootKit. Aspects of the RootKit detector described herein are configured to identify RootKit that conceals malware using a plurality of techniques. In one technique described above with reference to block data available from an operating system is analyzed for inconsistencies. In another technique employed at block a signature generated from data that represents the current state of a computer is compared to signatures generated using the same technique on known RootKit. In one embodiment the data obtained by the kernel debugger facilities at block is processed with a hash function to generate a signature. Then the signature is compared to a blacklist of signatures generated using the same technique from computers infected with known RootKit.

At decision block the detection module determines whether a match to a signature maintained in a black list was identified a block . If a match was identified then the detection module determines that a RootKit is resident on the computer and proceeds to block described below. Conversely if a match was not identified the detection module proceeds to block where it terminates.

As illustrated in at block the detection module removes any RootKit that was detected on the computer. One technique for removing RootKit from a computer includes but is not limited to 1 killing or terminating processes associated with the RootKit 2 removing RootKit generated entries in configuration files such as the system registry and 3 deleting files that contain RootKit program code and data. However those skilled in the art and others will recognize that a RootKit may be removed from a computer using other techniques and that the examples described above should be construed as exemplary and not limiting.

As illustrated in a RootKit sample is reported to a remote computer associated with a trusted entity at block . As described previously with reference to block aspects of the RootKit detector obtains data that describes the state of a computer. If block is reached a RootKit was detected on the computer that implements a RootKit detector. In this instance data obtained that describes the state of the computer infected with RootKit is reported to a trusted entity so that developers may perform an analysis of the data. In one embodiment the data is reported in an open and extensible format so that third party application programs may cause a RootKit sample to be transmitted to the trusted entity.

The detection module described with reference to is one exemplary embodiment of a software module configured to automatically search a computer for a RootKit. Those skilled in the art and others will recognize that additional steps may be added to the detection module without departing from the scope of the concepts described herein. Similarly in alternative embodiments the detection module may function with fewer steps than described above or with steps performed in a different order.

Referring to the following is intended to provide an exemplary overview of one suitable computer environment in which different aspects of the RootKit detector may be implemented. The illustrated computer environment is comprised of a client computer an enterprise server and a backend server . As further illustrated in the client computer is associated with a plug in device that is communicatively connected to the client computer . Moreover the enterprise server and the backend server are each associated with a backend database and respectively. The client computer and the enterprise server are communicatively connected via the intranet which may be implemented as a Local Area Network LAN or Wide Area Network WAN . As known to those skilled in the art and others the computers connected to the intranet may be configured to exchange documents commands and other types of data over the intranet . Also as illustrated in the backend server is communicatively connected to the enterprise server and the client computer via the Internet . Similar to the intranet the computers connected to the Internet may be configured to exchange documents commands and other types of data.

The RootKit detector described herein may be implemented in a number of different contexts of which the following are only examples. In one embodiment described above with reference to the RootKit detector is implemented on a stand alone computer to search the computer for a RootKit. In other embodiments logic for implementing the RootKit detector is contained on a separate device or computer that does not rely on components installed on the computer that is being analyzed for RootKit. In this regard the logic of the RootKit detector that searches the computer may be located on the plug in device that is connected to the computer using any number of direct communication interfaces including but not limited to a serial interface parallel interface Firewire or other peer to peer based interface Universal Serial Bus USB or other master slave based interface and the like. By having the logic that implements the RootKit detector on the plug in device a RootKit may be identified without relying on software components in an operating system that may have been compromised by a RootKit.

In an alternative embodiment the RootKit detector is contained on a remote computer. In this regard the RootKit detector uses network communication protocols that are generally known in the art to obtain data needed to determine whether a computer is infected with a RootKit. For example the enterprise server may initiate an online session so that data structures maintained on the client computer may be analyzed for properties characteristic of a RootKit. In this instance a software component on the enterprise server suspends execution of the client computer in order to initiate the session. Then using kernel debugger facilities on the enterprise server entries in data structures maintained by the client computer are identified and transmitted to the enterprise server over the intranet .

In another alternative embodiment a memory dump file that contains the contents of data structures maintained by the client computer is transmitted to a remote computer. For example a memory dump file generated from the client computer may be transmitted over the intranet to the enterprise server for storage in the backend database . Similarly a memory dump file may be transmitted over the Internet to the backend server where it is stored in the backend database . In this embodiment data in the memory dump files transmitted from one or more remote computers may be automatically analyzed by the RootKit detector. In this regard the memory dump files may be processed in bulk to determine whether a RootKit is spreading over a communication network.

Now with reference to another alternative embodiment of the RootKit detector in which the backend server is used to search a computer for a RootKit will be described. One system that facilitates the communication of data between computers using protocols developed for the Internet is a Web service. Those skilled in the art and others will recognize that a Web service refers to a software system with a network accessible interface that performs actions on behalf of other software systems. A Web service is typically accessed using standard protocols such as the Simple Object Access Protocol SOAP . A software system located on a remote computer may interact with a Web service in a manner prescribed by definitions that are provided in a service description. Also interactions between software systems typically occur using Extensible Markup Language XML based messages exchanged via Internet based protocols such as the HyperText Transfer Protocol HTTP . In this way a Web service may expose processes to a remote computer in order to execute operations on a computer or cluster of computers that provide the Web service. Typically a Web service supports interactions with other software systems at a specified location on a network that may be identified using a Uniform Resource Indicator URI .

In this instance invoking the function will cause program code to be executed on the backend server . When the function invoked on the Web service completes at event the flow of program execution is transferred back to the client computer . Typically the Web service will cause data in the form of a response to be transmitted to the client computer using standard network protocols.

In one embodiment the client computer issues a request to the backend server when the client computer needs to be searched for a RootKit. Using kernel debugger facilities the backend server obtains data maintained in data structures on the client computer . Then in response to the request the backend server performs an analysis of the data obtained to determine whether the client computer is infected with a RootKit. Finally a response is transmitted from the backend server to the client computer that indicates whether a RootKit was identified.

While the preferred embodiment of the invention has been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

