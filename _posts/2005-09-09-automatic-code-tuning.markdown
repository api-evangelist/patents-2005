---

title: Automatic code tuning
abstract: Automatically executing commands to process code (e.g., compile commands, interpret commands, etc.) and recording code characteristic metric values (e.g., file size, execution time, etc.) allows automatic code tuning. The automatic turning system may execute predefined commands on codes, automatically intelligently build commands, both execute predefined commands and intelligently build upon those predefined commands, etc. With the automatic intelligent building of commands to build more effective commands, an automatic tuning system can efficiently and judiciously search through available code development tool options to find the more effective combinations of options to generate executable codes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07895585&OS=07895585&RS=07895585
owner: Oracle America, Inc.
number: 07895585
owner_city: Redwood City
owner_country: US
publication_date: 20050909
---
The present invention relates to the field of code optimization. More specifically the present invention relates to automatically tuning code.

Tools for improving code performance are frequently not fully utilized. For example compilers such as that provided in the Sun Java System Services Suite previously Sun ONE Studio from Sun Microsystems Inc. provide extensive functionality for improving code performance. However many users of the compilers do not utilize the functionality. Users may not be entirely familiar with a compiler and its complexities may not possess the resources to become familiar with the compiler or to utilize the extensive functionality may not have the time within their code delivery schedule to apply the feature s to their code etc. Hence the default compilation environment is typically used. The default compilation environment will most likely have features enabled that are generally applicable to code. Relying on the default setting alone prevents discovery and utilization of the feature s available to improve performance of their code essentially foregoing the capability to tailor a compilation environment for their code.

Numerous features and capabilities encumber a compiler tool because of the amount of manual effort required to select a set of optimization flags for an application. Sifting through the numerous combinations of optimization flags available for a compiler even with the benefit of experience and knowledge about the compiler may require significant investment in time of personnel for each code to be tuned.

It has been discovered that code can be automatically tuned with automatic execution of commands for processing code e.g. translating optimizing etc. along with recording code characteristic metric values e.g. execution time file size number of delay events etc. . An automatic tuning system automatically executes different translation commands and perhaps instruments code for runtime feedback. The automatic tuning system may execute predefined commands on codes automatically intelligently build commands both execute predefined commands and intelligently build upon those predefined commands etc. Although various implementations are possible for an automatic tuning system an extensible automatic tuning system can be configured to allow a more customized compilation environment for a code e.g. configured to various target machines configured to evolve the automatic tuning system etc. . Configuration options may include frequency of runtime feedback runs i.e. the number of runs for collecting feedback frequency of non feedback runs etc. Although the automatic tuning system can tune source code an executable binary that includes an intermediate representation of source code such as portable executable code provides information sufficient for tuning.

These and other aspects of the described invention will be better described with reference to the Description of Embodiment s and accompanying Figures.

The description that follows includes exemplary systems methods techniques instruction sequences and computer program products that embody techniques of the present invention. However it is understood that the described invention may be practiced without these specific details. For instance realizations of the invention are described with reference to compilers but other source code transformation mechanisms such as interpreters virtual machines etc. may incorporate code tuning functionality. In other instances well known protocols structures and techniques have not been shown in detail in order not to obscure the invention.

The term source code is used throughout the following description. The term source code is not limited to code written in a traditional high level language but includes any unit of code that is the source for another code unit. In other words source code describes a code unit that can be translated compiled interpreted optimized etc. thus generating one or more other code units whether those other code units are separate from the source code unit the source code unit as modified embedded into the source code unit etc. In addition the term run is used herein to refer to execution of one or more executable codes. Throughout the description run is typically employed for referring to the portion of code tuning that executes an executable code generated from executing a command regardless of whether the generated executable code is instrumented for runtime feedback or not instrumented for runtime feedback.

The network element also transmits tuning parameters along with or subsequent to the non source code over the network cloud to the code tuning service provider . The tuning parameters include location of the non source code commands e.g. verification commands run commands number of delay events etc. metrics for measuring a characteristic of the code level of tuning etc. Although most metrics measure performance of a code some metrics such as file size may be more adequately classified as a code characteristic measurement which also includes performance. A code characteristic is used herein to refer to a measurable characteristic of code which can be used to distinguish one executable representation of code from another. Run commands convey commands for executing executable code generated from the non source code. The code tuning service uses provided verification commands to verify that a generated executable code produced correct results allowing those that fail verification to be flagged perhaps for further examination to determine the cause of the failure. Any number of metrics can be indicated including runtime various benchmarks etc. A code tuning service can provide any number of levels of tuning. As the level of tuning increases more resources are expended in tuning the code.

Those of ordinary skill in the art will appreciate that web portals to display and receive information as described herein can be implemented with any one or combination of the multitude of web portal development techniques. Web portals may be implemented partially or completely with web portal building applications and or languages such as HTML SGML XML the Java programming language etc.

The example input for the extra build field is depicted in as lm xlinkopt . A check box labeled as Link libraries automatically accompanies the extra build options field. Similarly a checkbox labeled Lower metric is better accompanies the Performance metric command field. The Application timeout in seconds field is accompanied by selectable input for an exit code assignment for the timeout. The selections include a zero for pass and one for fail upon timeout. The stop time field labeled Stop on allows as user to indicate an amount of time to allow code being tuned to continue running before terminating execution. Checkboxes Dryrun and debug accompany the Stop on field. These checkboxes allow a user to indicate whether the code being tuned is to be executed as a dry run and or as a debug. For example selecting Dryrun causes presentation of one or more command line commands for tuning code but does not actually tune the code while selection of the debug causes tunes the code and supplies debug information about the tuning runs.

Referring again to the non source code and tuning parameters submitted by a user from the network element is received by the code tuning service server . The code tuning service server invokes tuning of the received non source code by the code tuning grid . Functionality for providing the code tuning service may be installed on the code tuning service server e.g. as a cgi script on a different private server etc.

A code tuning service may employ an application that automatically tunes code may tune code with personnel or use both personnel and an automatic code tuning application. Personnel familiar with the code development tool will use the code development tool and their knowledge of its features and capabilities to generate several executable codes depending upon the level of tuning selected by the user. If automatic tuning is performed then the automatic tuning application invokes the code development tool several times with different features selected to generate several executable codes again as dictated by the level of tuning selected by the user. A web based tuning service may use both an automatic tuning application and personnel to tailor a code development environment for each code unit or set of code units. After initial tuning by the automatic tuning application personnel may examine the results and determine whether the code can be further tuned. For this illustration it is assumed that the code is being tuned with an automatic code tuning application.

After tuning the tuning grid provides the results to the tuning service server . Either the results are provided for presentation over the web or the web service server prepares the provided results for presentation over the web. For example the tuning grid generates data that includes metrics and file locations and perhaps selected code development tool options. The code tuning service server accepts the data and generates a corresponding web page that presents the results and links the results to the respective executable code.

Referring again to the code tuning service server transmits the results for presentation of the tuning output at the network element via the network cloud although the results may be transmitted to a different destination if so desired. In one or more of the tuned executables are supplied to the network element in response to one or more selections by the user at the network element .

Both developer users and non developer users can take advantage of a web based code tuning service to benefit from the abundance of capabilities available in code development tools. Concentrating knowledge and familiarity of these capabilities into a web based code tuning service recovers the benefits offered from these capabilities previously lost due to their overwhelming abundance and complexity. These recovered benefits allow each tuned code to utilize capabilities beneficial to code on an individual basis. The benefit to code offered by a web based tuning service impacts code development delivery and maintenance by introducing a new stage in the life cycle of code. After initial development and testing a web based code tuning service can tune the code prior to delivery. After delivery a user of the code may request additional tuning to target that user s needs address third party modifications or additions to the code take advantage of new capabilities of the code development tool request a higher level of tuning etc. A tuning service also affects maintenance since maintenance additions or modifications to the code may be tuned by a web based tuning service separately and or in conjunction with the original code.

As already stated above a web based tuning service may utilize personnel an automatic tuning system or both personnel and an automatic tuning system. An automatic tuning system may be implemented as a single application on a single machine a distributed system an open extensible system etc. Regardless of the specific implementation an automatic tuning system initially generates executable code from one or more runs with various code development tool options and intelligently selects additional and or alternative options based on runtime feedback of the initially generated executable code.

At block generated executables and associated commands and collected metric values are indicated. For example selectable indications e.g. hyperlinks for the generated executables and the associated commands and perhaps collected metric values are transmitted to another machine for packaging or formatting so that the information can be presented to a user. In another example the machine generating the executable codes also hosts a module that prepares the information for presentation via a web portal such as a web browser.

At block it is determined whether there are additional primer commands. If there are additional primer commands then control flows to block . If there are not additional primer commands then control flows to block .

At block a new command is built. The automatic tuning system examines the collected metric values and builds a command using examination of the collected metric values from previous runs.

Although the above example depictions store generated executables the generated executables may only be stored temporarily and then discarded. Instead of maintaining two versions of executable codes a version instrumented for collection of runtime feedback and a version for delivery to a user the instrumented generated executables are stored temporarily and then discarded e.g. discarded immediately after their run after a time period after a given number of runs etc. . In response to a user selecting a run i.e. selecting the executed command with the performance results desired by the user the code tuning service executes the command again to generate a non instrumented executable code and delivers this generated executable code.

The automatic tuning of code presented in may be performed with various techniques. The automatic tuning may be performed on a single system with a single code development tool a single system with multiple code development tools a single system with a single code development tool but with multiple threaded support multiple systems etc. Embodiments may tune code serially in parallel partially in parallel etc. In addition various techniques may be implemented to judiciously adapt dispatching of tasks throughout a system to the current load conditions of the system. For example an automatic tuning system may utilize task queue monitoring for dynamic adaptive parallel computing to dispatch multiple compile tasks e.g. compile commands to be executed for processing units of a system.

To reap the benefits of a system with multiple processing units e.g. cores central processing units co processors etc. without overloading or underutilizing the system information about current queued pending or ready tasks are monitored against a system wide task threshold. The system wide task threshold represents a boundary between conditions for optimal resource utilization over a system and conditions for overload of the system. Of course the system wide task threshold may be configured to represent a boundary that is below optimal resource utilization slightly above optimal resource utilization etc. In addition the optimal resource utilization for a system may vary within a range differ between system administrators etc. Regardless of what optimal resource utilization may be for particular systems monitoring system wide against a system wide task threshold allows throttling of task dispatch to the system for dynamic adaptation of parallel computing to current conditions of the system.

Regardless of the exact technique or mechanism for maintaining task information the task information is communicated to a system wide task monitor . In each of the processing units A C reports their task information to the system wide task monitor . The system wide task monitor may be implemented one of the processing units A C another processing unit of the system a different system etc.

At block throttling of task dispatch is caused. Throttling of task dispatch can be performed with various techniques. For example a system wide task monitor prevents processes from dispatching tasks for a given period of time a system wide task monitor prevents all processes from dispatching more than a given number of tasks within a given time period a system wide task monitor limits task dispatch to a single task per a given time period or tasks dequeued etc. Processes may be limited to dispatching a single task for each task dequeued. The responsibility for the throttling can be implemented in the individual processes in an application programming interface in the system wide task monitor etc. For example prior to task dispatch each process checks a store location for a flag. The system wide task monitor sets the flag to a triggering value if throttling should be imposed and resets the flag to a default value if throttling should not be performed. In another example tasks are dispatched to the system wide task monitor. If the task threshold is not exceeded then the tasks are forwarded to the processing units. If the task threshold is exceeded then tasks are delayed at the task monitor. Control flows from block to block .

At block task information for the system is listened for. Upon receiving task information the tracked system wide task information is updated to reflect current tasks imposed on the system. Control flows from block back to block .

Monitoring task load on a system prevents a code tuning system from overloading the system while allowing the code tuning system to optimally utilize the system. For example an automatic tuning system may have 7 predefined primer commands. The automatic tuning system dispatches compile tasks for each of the predefined primer commands. If a system is constrained with the example task threshold discussed above and the system includes 3 processing units then the automatic tuning system can dispatch 6 of the first 7 compile tasks to the system before throttling is imposed. Hence the dispatching of compile tasks from the automatic tuning system can properly utilize the system without overloading the system and dynamically adapt or be dynamically adapted to conditions on the system which may vary from tasks dispatched by other applications changes in operating characteristics complexity of various compile tasks etc.

Whether or not compiler tasks for tuning code are dispatched to a system with multiple processing units or the compiler tasks for tuning code are assigned to a single processing unit the automatic tuning system builds new commands for compiling code which result in new tasks to be dispatched. To build new commands the automatic tuning system examines the runtime feedback of code generated from previously executed commands. The automatic tuning system then builds a new command from the compiler options of the previous commands based on the examined runtime feedback.

At block the metric value s of the current run is compared against the metric value s of the previous run. At block it is determined which of the current run and the previous run is more effective according to the comparison of metric values. If the current run is more effective than the previous run then control flows to block . If the current run is not more effective than the previous run then control flows to block .

At block the next most effective option with respect to those options already occurring in the executed command is selected as a candidate option and used to replace the last added option of the executed command to build a candidate command. Control flows from block to block .

At block the next most effective option with respect to those options already occurring in the executed command is selected and added to the executed command as a candidate option to build a candidate command. At block it is determined whether the candidate command is allowed by rules governing commands. For example certain options may be required to appear in a certain order with respect to each other some options may conflict with other options etc. In addition heuristics for code development tool options may be consulted for command building and or command verification e.g. re ordering options of a command replacing an option of a command in accordance with heuristics etc. . If the candidate command is permitted by the rules then control flows to block . If the candidate command violates the rules then control flows to block .

At block the candidate command is replaced with a next most effective option with respect to the candidate option. Control flows from block back to block .

At block it is determined whether the candidate command has previously been built. If the candidate command has already been built then control flows to block . If the candidate command has not already been built then control flows to block .

At block the recorded commands and recorded runtime feedback are presented. For example a representation of the recorded information transmitted to a web server for display to a user.

At block a candidate command is built for stage N with the N 1 most effective options in accordance with the rules for command building. At block it is determined whether the candidate command has been built previously. If the candidate command has previously been built then control flows to block . If the candidate command has not been built previously then control flows back to block . At block the least effective option of the candidate command is replaced with an option that is the next most effective option with respect to the option being replaced.

At block it is determined whether the current stage is the last stage of an iteration. If the current stage is the last stage of an iteration then control flows to block . If the current stage is not the last stage of an iteration then control flows to block .

At block it is determined whether the current run is more efficient than the previous run i.e. the runtime feedback of the currently generated executable is compared against the runtime feedback of the previously generated executable . If the current run is more effective than the previous run then control flows to block . If the current run is not more effective than the previous run then control flows to block .

At block the next most effective option with respect to those options already occurring in the executed command is selected as a candidate option and used to replace the last added option of the executed command to build a candidate command. Control flows from block to block .

At block the next most effective option with respect to those options already occurring in the executed command is selected and added to the executed command as a candidate option to build a candidate command. At block it is determined whether the candidate command has previously been executed. If the candidate command has already been executed then control flows to block . If the candidate command has not already been executed then control flows to block .

At block it is determined whether the candidate command is allowed by rules governing commands. If the candidate command is permitted by the rules then control flows to block . If the candidate command violates the rules then control flows to block .

At block the candidate command is replaced with a next most effective option with respect to the candidate option. Control flows from block back to block .

At block the candidate option is replaced with the next most effective option with respect to the candidate option. Control flows from block back to block .

With the automatic intelligent building of progressively more efficient commands an automatic tuning system can efficiently and judiciously search through the available compile options to find the more effective combinations of options to generate executable codes. With the automatic command building an automatic tuning system sifts through numerous options and combinations of options in accordance with one or more metrics to measure performance to generate optimized executable codes with substantially more efficiency than manual command building. An automatic tuning system with or without automatic intelligent command building can be deployed to various sites allowing code to be posted to local servers or server farms for code tuning instead of transmitting the code externally. Hence code tuning would be available locally without external exposure of the code. Furthermore locally deployed code tuning can be coupled with a code tuning service to provide local tuning of source code and subsequent tuning of delivered executable code that conveys information sufficient for tuning e.g. portable executable code .

A code tuning service that utilizes an automatic tuning system implementing automatic intelligent progressive command building perhaps with some input from code tuning engineers provides a service that facilitates availability of features and capabilities of a code development tool without the substantial cost of educating users about the code development tool. Such a service is also provided with reduced investment of personnel since the variety of numerous option combinations is sifted through automatically. Furthermore extensibility of the automatic tuning system allows the automatic tuning system to be tailored for particular codes or target machines.

The described invention may be provided as a computer program product or software possibly encoded in a machine readable medium as instructions used to program a computer system or other electronic devices to perform a process according to the present invention. A machine readable medium includes any mechanism for storing or transmitting information in a form e.g. software processing application readable by a machine e.g. a computer . The machine readable medium may include but is not limited to magnetic storage medium e.g. floppy diskette optical storage medium e.g. CD ROM magneto optical storage medium read only memory ROM random access memory RAM erasable programmable memory e.g. EPROM and EEPROM flash memory or other types of medium suitable for storing electronic instructions.

While the invention has been described with reference to various realizations it will be understood that these realizations are illustrative and that the scope of the invention is not limited to them. Many variations modifications additions and improvements are possible. More generally realizations in accordance with the present invention have been described in the context of particular realizations. These realizations are meant to be illustrative and not limiting. Accordingly plural instances may be provided for components described herein as a single instance. Boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of claims that follow. Finally structures and functionality presented as discrete components in the exemplary configurations may be implemented as a combined structure or component. These and other variations modifications additions and improvements may fall within the scope of the invention as defined in the claims that follow.

