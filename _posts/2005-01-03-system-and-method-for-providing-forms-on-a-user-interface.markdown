---

title: System and method for providing forms on a user interface
abstract: A system and method for configuring a user formset for display on a user interface of a client computer, the client computer coupled by a network to a formset server, the user formset for providing interaction with a network transaction, the user formset described in a structured definition language. The system and method comprise: requesting the user formset from the server according to at least one formset generation criterion; selecting a first overlay for application to a master formset, the first overlay including first components based on a role of the user; applying the first overlay to the content of the master formset for generating a role based version of the master formset; selecting a second overlay for application to the role based version, the second overlay including second components based on settings particular for the user functioning in the role; and applying the second overlay to the content of the role based version for generating the user formset; wherein the user formset is subsequently rendered on the user interface of the client computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07734999&OS=07734999&RS=07734999
owner: Emergis Inc.
number: 07734999
owner_city: Longueuil
owner_country: CA
publication_date: 20050103
---
Current forms implemented on a graphical user interface of a user computer have to be coded for operation by a variety of different users. The current implementation of the form variety is to have these different role specific formsets all be coded by hand and named appropriately. One disadvantage for hard coded forms is maintenance as any changes in one of the Formsets requires that all the other similar Formsets be examined and also changed if necessary.

It is an object of the present invention to provide a claims processing system to obviate or mitigate some of the above presented disadvantages.

The current implementation of the form variety is to have different role specific formsets all be coded by hand and named appropriately. One disadvantage for hard coded forms is maintenance as any changes in one of the Formsets requires that all the other similar Formsets be examined and also changed if necessary. Contrary to current formset setup there is provided a method and system for configuring a user formset for display on a user interface of a client computer the client computer coupled by a network to a formset server the user formset for providing interaction with a network transaction the user formset described in a structured definition language the method comprising the steps of requesting the user formset from the server according to at least one formset generation criterion selecting a first overlay for application to a master formset the first overlay including first components based on a role of the user applying the first overlay to the content of the master formset for generating a role based version of the master formset selecting a second overlay for application to the role based version the second overlay including second components based on settings particular for the user functioning in the role and applying the second overlay to the content of the role based version for generating the user formset wherein the user formset is subsequently rendered on the user interface of the client computer.

According to the present invention there is provided a method for configuring a customized formset for display on a user interface of a client computer the client computer coupled by a network to a formset server the customized formset described in a structured definition language the method comprising the steps of selecting a customize overlay by the formset server for application to a role based formset the customize overlay including components based on a predefined configuration of the customized formset particular for the user functioning in the role as defined by the role based formset and applying the components of the customize overlay to the content of the role based formset for generating the customized formset wherein the customized formset is subsequently rendered on the user interface of the client computer.

According to a further aspect of the present invention there is provided a system for configuring a customized formset for display on a user interface of a client computer the client computer coupled by a network to a formset server the customized formset described in a structured definition language the system comprising a server application for selecting a customize overlay by the formset server for application to a role based formset the customize overlay including components based on a predefined configuration of the customized formset particular for the user functioning in the role as defined by the role based formset and a utility for applying the components of the customize overlay to the content of the role based formset for generating the customized formset wherein the customized formset is subsequently rendered on the user interface of the client computer.

A further feature is a table for storing objects representing at least one of the customize overlay components the table coupled to the formset server.

A further feature is a workflow manipulator for embedding in a transaction using metadata the manipulation of the formset workflow the transaction associated with the formset and exchanged between the client application and the server application.

Referring to the system provides an interactive interface environment to modem and or legacy systems tier or layer through the use of client formsets i.e. a plurality of forms presented as multiple screens that are interconnected by defined workflow provided on a client from a formset server . The system can be defined as a generalised forms processing system that configures a presentation layer and the associated business rules as data rather than as hard coded forms. The client formsets are dynamically configurable i.e. customisable based on user setting type and priorities in relation to a master formset s stored on a database and or the form server . The clients can be resident in the presentation tier layer connected through a network such as a LAN and or WAN Internet to a middle tier layer . The system as a frame work is designed to serve up application formsets on the client based on a role assigned to the user of the client . The backend database has the single development master formset that can be used by the formset server to facilitate the creatation of multiple versions of the production formsets base on the single development master formset . Each of the generated production formsets are assigned to a role via static overlays see and served up to the users of the client in that role such that the formset look and functionality is changed based on the type role of user as well as individual settings via dynamic overlays see as further described below. It is recognised that the formset includes a number of formatted data fields presentation format as well as associated actions for data input output of the fields as well as intra screen and inter screen navigation. Further it is recognised that the master formset can contain the total generically described i.e. not specifically named for individual roles workflow of the user formsets as well as can refer to other master formsets as desired. For example the master formsets can contain generic definitions of actions and events that are further specified by role category specific definitions when the contents of the master formsets are operated on by the static overlays as further described below.

Referring again to the system can be modelled as a 3 tier formset application organized into three parts each of which is distributed to a different place s in the network . The three parts are a client workstation or presentation interface in the presentation tier the business logic of the client formset generation and processing in the middle or application tier and the database containing data content of the formset as well as programming related to managing the database in the database tier . The application user s workstation computer see of the client can contain programming that provides the graphical user interface GUI and application specific entry forms or interactive windows of the client formset whereby some data that is local or unique for the workstation user is also kept on a local data storage . The business logic of the client formset i.e. presentation and behaviour is located on the server or other shared computer connected to the formset of the client . The business logic of the server acts as the server for client requests transactions from workstations user system events related to operation of the formsets as well as their generation determines what data is needed and where it is located in relation to the events and acts as a client in relation to programming of the database that might be shared on the tiers . The third tier can include the database and a database management engine to manage read and write access to the database . For example the formsets can be implemented in any Windows Linux Unix based operating system and the database can be a SQL based system. Communication protocols between the tiers can be such as but not limited to XML HTTP S and JDBC. Communication between the components and objects in the tiers can be through interfaces such as but not limited to XML data transactions SOAP etc. Further the business logic of the tier can communicate with the database using business objects whose default implementations communicate with the database using JDBC or other SQL Databases IDL based CORBA and RM IIOP systems Legacy Databases J2EE SAP RFCs and COM DCOM components as desired.

Referring to the clients can be represented by workstation computers including such as but not limited to mobile telephones PDAs or dual mode communication devices and desktop computers. The computers include a network connection interface such as a wireless transceiver or a wired network interface card or a modem coupled via connection to a device infrastructure . The connection interface is connectable during operation of the computer to the network such as to a wireless network by wireless links e.g. RF IR etc. which enables the computer to communicate with each other and with external systems such as the server via the network and to have requests response messages transactions between the formset s and the database .

Referring again to the computers also have a user interface coupled to the device infrastructure by connection to interact with a user not shown . The user interface includes one or more user input devices such as but not limited to a QWERTY keyboard a keypad a track wheel a stylus a mouse a microphone and the user output device such as an LCD screen display and or a speaker. If the screen is touch sensitive then the display can also be used as the user input device as controlled by the device infrastructure . The user interface is employed by the user of the computers to coordinate the requests response messages transactions over the network see as employed by formsets further described below.

Referring again to operation of the computer is enabled by the device infrastructure . The device infrastructure includes a computer processor and the associated memory module . The computer processor manipulates the operation of the network interface the user interface and the formset content format and behaviour by executing related instructions which are provided by an operating system and a client application see located in the memory module . The client application communicates with a server application located on the server as further described below. The client application can be represented as an applet that runs inside of a Virtual Machine e.g. Java Virtual Machine such as Sun JVM provided by the infrastructure . For the example the JVM applet would be applicable for running on a number of computer platforms. Further it is recognized that the device infrastructure can include a computer readable storage medium coupled to the processor for providing instructions to the processor and or to load update client application programs in the memory module . The computer readable medium can include hardware and or software such as by way of example only magnetic disks magnetic tape optically readable medium such as CD DVD ROMS and memory cards. In each case the computer readable medium may take the form of a small disk floppy diskette cassette hard disk drive solid state memory card or RAM provided in the memory module . It should be noted that the above listed example computer readable mediums can be used either alone or in combination. The client application can be transmitted via the network and loaded into the memory module of a device infrastructure . Alternatively the client application may be loaded via a serial connection a USB connection or a short range wireless communication system such as IR 802.11 x Bluetooth not shown . Once loaded onto the computer the client application can be executed by the processor in the device infrastructure for operating the formsets .

Referring to the client application can be a Java applet or other application that runs in connection with a browser presented on the UI see . The application operates to dynamically render configurable client formsets e.g. an editable collection of UI presented electronic forms on the browser that communicate with the server application in connection to user and system events in relation to the content of the formset . The workflow e.g. actions and events as well as layout of the formsets can be defined in the same XML file representing the formset as rendered on the UI of the client . The formsets provide for the layout on the UI and the data transferred to and from the middle tier components in XML for example transactions . The server application includes a collection of Java libraries see and an XML parser that constructs and parses the XML documents exchanged between the client application and the business objects of the database . It is recognised that structured definition languages other than XML can be used as desired in order to construct the data definitions in the document of the transaction passed between the client and server applications. The server application cooperates to move the data associated with the objects to and from the database in a manner controlled by the XML transactions configured via the formset used by the client application .

The presentation layer includes the Java applet as the client application that runs in for example the browser e.g. Internet Explorer that hosts the Virtual Machine e.g. Sun Java Virtual Machine on compatible workstation computers . The client application can cooperate in the dynamic rendering of the formset described in XML and stored centrally on the server and or database as the master formset . The dynamic nature of the formsets is described as data. This separated form generation environment can allow developers to be responsible for the content of the master formsets containing more generic definitions of content presentation and workflow and a business analyst to define the overlays to facilitate modification changing or hiding what an individual user of the client sees or what data elements the users can access via the user formsets . It is recognised that the overlays are used to modify the XML definitions in the master formset corresponding to application data extracted from the database storage and or database .

Once the user formsets have been rendered on the UI of the client the user can enter or modify data on the formset via the UI see and submit the modified data to the server as the XML transaction . The entire transaction constitutes a business function that is composed into an XML document and sent via Secure Socket Layer SSL to the host server running the server application . The server application processes the transaction and returns another XML document to the client application for presentation in the UI via the formset . Multiple client applications can be running in multiple browser windows of the UI with inter application communication that enables complex workflow and sharing of data between formsets . The client application is intelligent enough to interpret the response XML document and display it on the current formset switch to another formset to display the document contents and or perform various other operations. The client application is installed on the local client with the master copy stored on the central server . Each time a connection to the server is made by the client the client application can perform a version check and be updated automatically no user intervention required if required.

The server application is part of the Middle layer can be a Java servlet that accepts XML transactions . These transactions can include such as but not limited to a submitted transaction a request to a view and a business object or a request for a database style record set query . At a high level the server application can have three functions the server application maps the XML to an internal Java business object via the parser see Appendix C the server application processes the business object against a business rules processor and maps the business object to the database via the database manager . There can be many advantages to using Java servlets as the server application in the middle layer such as servets are scalable fast portable reliable and extremely powerful. Scalable means the application can be deployed on single centralized server or distributed amongst any number of servers . It is recognised that the formsets can be served up from a central server such that the installation distribution of changes to formset s content is centralised in one location rather than having multiple installations. Servlets are fast because the process is already running and initialized and each new transaction runs in a previously pooled thread. Portability means that the Java servlet can be deployed with any major web server of the back end tier running on almost any flavour of Unix or Windows or any Java Servlet Container for example. The servlets are considered reliable because of safety mechanisms inherent in the Java Virtual Machine running on the client . The servlets are powerful because all standard Java API s are available meaning that you can do virtually anything from connecting to the database to sending an email or opening a serial connection to another network connected to the network .

By default the middleware server application can take care of two out of the three functions automatically. The server application with the parser module can automatically parse the XML into the business object and save it to the database . Most applications can require business rules be applied to the data business object before it is saved to the database . For this step the server application can access to or include the extendable Rules Processing Engine . The rules processor engine can be a Java class that implements a hooks or callback interface. Once written the class is mapped to the transaction via a properties file. Further reading business objects and running database queries can be implemented using templates in connection with the appropriate properties file see Figure A and corresponding Transaction Examples section below. The incoming transaction need only request a specific template and supply it the appropriate information so that the parser module and associated rules processor can find the object s . These templates can be simply XML documents that represent either the business object and or the database query an example of which is given in Appendix A.

Further workflow of individual forms of the formset and or between formsets can be embedded in the transaction through the use of metadata e.g. defined transaction classes e.g. class 2 class 3 etc . . . such that the transaction class can be used to direct the application to display appropriate forms content and or format in response to the received transaction class identifier of the transaction from the server application . For example the transaction sent to the application would contain the metadata used to control the workflow as well as any data entered by the user whereby the transaction result sent back to the application by the application would contain the metadata in the form of the defined transaction class to instruct the application to switch to another form of the formset for display on the UI . A workflow manipulator can be used by the applications for preparing and processing the transaction in regard to the metadata insertion and interpretation for formset display.

An example of the formsets is as follows. The formsets can provide application screens on the UI for entering manual insurance claims. This manual claim entry is done by the user of the client . These entry screens can allow the entry of expected claim data for the claim transactions can generate the claim transaction as an XML or other structured definition language document and send it to the server can receive a response e.g. XML from the server and display the response and can adjust overrides if desired and repeat until the desired result is achieved. The screens and queues of the formsets can provide information about pending claim transaction processing to the user of the client . For example different claim types e.g. dental drug etc . . . are used to submit claim transactions through the formset for the different lines of business of the payers of the insured claimed services. For example the screens of the formset associated with the claim transaction can help provide information send and or receive a medical claim submitted by a doctor using the client for suturing John Doe s knee a dental claim submitted by a dentist using the client for performing a root canal on Bob Smith and or a drug claim submitted by a pharmacist using the client prescribed by a doctor for dispensing an antibiotic to Jane Doe. It is recognised that the claim transaction can contain claims associated with one or more lines of business.

Further the formsets can be used to supply maintenance screens for maintaining information such as company and department and other business object maintenance needed for an adjudication system not shown that processes the transactions . The adjudication system could be represented as the server application . Some of the maintenance screens such as recipient and subscriber enrolment may be accessible to a plurality of users having different authorisation clearances either configured on one or many clients . Other maintenance screen versions of the formset such as those maintaining workflow queues of the adjudication system may only be accessible to a payer s staff rather than the claim recipients filling out the claim data forms of the formset hence demonstrating the dynamic configurability of the formset based on degree of user authorisations. These versions of the formset are configured through the use of the overlays as further described below.

Referring to the database contains the master formset an example of which is found in Appendix B. The server application of the form server can be employed by the system see to apply the static overlay filter to the master formset such that the generic definitions are converted into role category specific definitions for presentation to the client as role category defined formsets . It is also recognised that the static overlays could be applied in pre production of the formsets such that the server has a plurality of role category specific versions i.e. role category defined formsets implicitly containing the static overlay content of the master formset resident in server memory. In this case the server does not have access to the master formset for application of the static overlays rather the server is provided with the multiple role category versions of the master formset which would be represented in as role category formset file versions i.e. the referenced file does not contain only the static overlay contents but as well contains the contents of the master formset after the static overlays have been applied . The role of the server for application or non application of the static overlays can be based on use and resource constraints of the server as desired. In any event it is recognised that the server and associated server application can in response to a formset request by the client application either in response provide the preprocessed static overlay formset version i.e. role category defined formset of the master formset to the client application or can first apply the static overlay to the master formset resident in the server and or database and then send the role category defined formset to the client application . Once received the role category defined formset is rendered to the UI by the client application . The static overlay feature provides for changes to the master formset such as but not limited to Remove Modify and or Add predefined elements content format and behaviour functionality to the role category defined formset that will be served up to the user. The static overlays can be either additive or restrictive in nature and can be used to add modify or delete objects and their related functionality available in the master formset .

The Server can also be used to apply a dynamic overlay filter and or profiles to the role category specific formsets in order to dynamically create the customized client formsets displayed on the client . In this case the server application is used to process the role category defined formsets to include the content of the dynamic overlays and or the profiles before sending the formsets with both role category definitions as well as individual customized definitions and default data e.g. profiles for rendering by the client application on the UI . Otherwise the server can be used to supply the dynamic overlay and or the profiles to the client application along with the role category defined formsets for subsequent processing by the client application to dynamically create the customized client formsets displayed on the client . The dynamic overlays provide for changes to the role category defined formsets in what the user sees and what the user can change based on an application specific way of grouping the users of the formset . The dynamic overlay feature provides for changes such as but not limited to Hide protect and Mask certain parts of the customized formset version that is. served up to the user of the client . The dynamic overlay feature is specifically restrictive in nature and preferably does not add objects and their related functionality to the formset . Further the server application can also apply profiles also related to the user characteristics or groups of users having the same characteristics to provide default saved values into the fields of the formset . It is recognised that the default values could be obtained from the database and or the local storage for any specified user data values.

Referring to the static overlay feature is designed to act on any components in the Formset so as to affect the degree of access e.g. full partial none to the associated objects of the database coupled to the formset as well as to control the presentation of the formset components data content and or presentation format on the UI and or their functionality. The mechanism to deliver the modified Formset to the user is based on a formset access criteria e.g. user Category type assigned to the Formset and or the Role with related individual authorisation the User is assigned as supplied by the client application when requesting the formset from the server . For example when the client application loads on the client a parameter e.g. role category is set indicating the Formset the client application should display as well as the current User of the formset . One of the first things the client application does once initialised e.g. through user login to the client is to request this user respective Formset from the server application by passing in the access criteria of the User type role performing the request. The user of the particular formset is validated via the access criteria against the server s knowledge and or database of which user is attached to the current session of the client application and the Formset is either converted to the role defined formset by application of the static overlay or the pre processed role defined formset i.e. implicitly containing the contents of the static overlay is accessed as resident on the server as further defined below. Once either accessed or generated by the server this role defined Formset file is then returned to the requesting client application which uses the Formset file to render the formset data content e.g. fields presentation format e.g. branding and functionality e.g. available actions on the UI .

Using the concept of the master Formset and the static overlay mechanism the master Formset can hold all the general Formset information and the overlay Formset fragments can contain the role specific additions modifications and removals in respect to the formset . The general Formset can be maintained manually by an administrator of the system while the role specific formsets are then rendered and used by the client application . A static overlay utility module of the server application can read in the master formset and generate all the role specific affected components as a step in the building of the formset for presentation on the UI of the client as given by example below. The client application goes through a number of steps when loading on the client mainly in communicating with the server in order to get the various pieces of static overlay information the client application requires for presentation and operation of the respective user formset . In general there are two main steps in namely the web browser first requests the role defined formset based on the role of the user e.g. administrator vs. a technician and then loads the role defined formset from the server application . For example the message from the client application to the server application is a mixture of HTTP Get requests with an HTTP response containing the XML Message. The user formatted formset is encoded in the XML and can use a txforms.dtd DTD file for interpretation of the contained definitions and associated file content.

Referring to the static overlay Java utility can be invoked to build the role defined formset file by having static overlay files applied thereto or the overlay utility of the server application can be used to retrieve the preprocessed role defined formset having the implicit contents of the respective static overlay applied during pre production selected from a plurality of available preprocessed role defined formsets . This utility can use the access generation criteria to select appropriate control files either stored in the database or the storage of the server which identifies either the master formset file and related static overlays or the preprocessed role defined formsets and identifies a resultant formset file for use in an expected XML format by the client application .

As an example an ebill.ca Alberta billing formset will be used to demonstrate the use of static overlays . The master billing formset is given in Appendix B as source abClaim.xml. There are two static overlays examples one for standard web billing abClaim.properties and abClaim.overlay.xml and another for billing from Microsoft Outlook abClaim outlook.properties and abClaim outlook.overlay.xml .

As can be seen the properties control file merely sets the source formset file the overlay file and where to put the resulting formset file. As well the properties control file tells the static overlay utility to ignore the Microsoft Outlook forms and not include those in the resulting formset file . The static overlay will add a field called hidden.use patient . The static overlay creates a formset component called SegUsePatientFlag that contains this new field. And finally the static overlay adds this new component to the already existing DataPatientLookup data set that will be sent when a button is pressed invoking actions tied to this data set by the formset operation on the client . Note that the way to determine that the components in the static overlay exist or not is to search the master XML formset .

As the control file shows the abClaim outlook.xml has no components deleted but does replace the top level formset so that it only contains the Microsoft Outlook form. The other components are still included in the resulting formset XML file but are not referenced and cannot be used by the user of the client . As the two screen captures clearly show in the master formset has been generated into two totally different role defined formsets one screen set for normal AB billing and the other screen set for billing from within Microsoft Outlook.

The purpose of Dynamic Overlays see is basically to provide changes to the formset in what the individual user or groups of users see s and what they can change based on an application specific way of grouping the users based on individual permissions and settings e.g. Bob as a technician as compared to Charles or as grouping the users based on grouped permissions and settings e.g. technicians in department A as compared to technicians in department B . In the first case the technicians are the role category while Bob and Charles are the individuals. In the second case the technicians are the category role while the departments are the individuals . Dynamic Overlays can be applicable in the case where all the formsets are served up from the centralized server . So many users under the same role will get the same formset definitions. Therefore application of the dynamic overlays can give a level of customization down to the clinic level for example. For example all billing clerks will get the same formset all billing clerks in Alberta all our customers. However Dr. Jims clinic may have a specific need that says that Billing Clerk Joanne can NOT perform a specific function for training purposes for example . Dynamic overlays applied to the formset provides ALL billing clerks in the province in multiple customers clinics to have the base Billing Clerk form but JoAnne in Dr. Jims Clinic to have an additional customization to restrict her as specified in the dynamic overlay for production of the customized formset for Joanne. It is noted that the Master formset contains all functionality available to all versions of the formsets such that the static overlays can apply Role based customizations to the master formset i.e. produce a set of role based formsets applicable in general to all users acting in that role. The Dynamic Overlays provide Customer and or User based customizations of the role based formsets .

This Dynamic Overlays provides for the server application to Hide protect and or Mask certain parts of the formset that is served up to the user of the client . Otherwise the overlays can be submitted to the client along with the role defined formset for generation of the customized user formset as rendered on the Ui . The Dynamic Overlays are specifically restrictive in nature and are not used to add or otherwise link new objects of the database to the formset rather the Dynamic Overlays act to tailor the category roles of the formset to certain individual content functionality. For example Dynamic Overlays can be designed to act only on certain components contained in the role defined formset . Those components can be such as but not limited to Form Action Field Status Page and Status Page Field. The properties that Dynamic Overlays can apply to these components are as follows such as but not limited to 

hiding a form object is a matter of not having it displayed for example we can restrict this attribute to be applied only to Forms and Status Pages 

protecting makes a field or group of fields Read Only where if applied to the Formset globally then all fields on the formset are read only and

masking is where we substitute each character in the data for a character much like most password fields such that the formset contains the data however the actual value is masked so that the user cannot read it via the UI used for privacy concerns for example .

The client application see goes through a number of steps when loading mainly it communicates the formset request including access generation criteria with the server in order to get the various pieces of information it requires for displaying the formset for use by the user to generating and interacting with the transaction . The client application requests the dynamic overlys based on the individual settings of the user e.g. Clayton vs. Rob and then loads the category and user specific formset after the dynamic overlay has been applied by the server application or collects only the overlay to apply to the already requested role defined formset steps and as described above . Referring to there are three main steps wherein the server application first accesses the dynamic overlay . A dynamic utility then constructs using an overlay generation algorithm the runtime dynamic Overlay files using database tables . The overlay can then applied to the role defined formset and the formset becomes altered until it is closed and then sent as the resultant file to the client for display on the UI as the customized formset . It is recognized that the message from the client application to the server application can be a mixture of HTTP Get requests with an HTTP response containing the XML Message. Both the role defined formset and the runtime overlay can be encoded in XML and use the same DTD file txforms.dtd similar to the static overlay as described above.

Referring to the dynamic overlay utility can be used by the server application to generate and apply the dynamic overlay to the role defined formset or the utility can be used to generate the overlay and send the role defined formset and the generated overlay to the client application for subsequent application and rendering to the UI . The runtime overlay information can be stored in database tables . The algorithm used by the utility module for runtime overlay can group users and apply the overlay based on application specific rules for effecting the formset content functionality as per the generation criteria. Appendix C provides for a code example of how the dynamic overlay can be generated from table data in the database prior to application to the formset . From the code in Appendix C one can infer the underlying SQL used to extract the information from the database . Use of the control files in combination with the tables can give added flexibility to application of the dynamic overlays as the administrator of the system has the option of modifying the content of the dynamic overlays through table content changes control file content changes or a combination thereof. Further the administrator could use different tables with varying content that would be compatible with the same control files to generate via the overlay generation algorithm of different dynamic overlays if desired.

Tranzform Overlay Disable Object Purpose of this table is to identify all objects of the database that the formset wants protected. By default these objects will be hidden protected masked at runtime of the formset on the UI .

Tranzform Overlay Disable Object Purpose of this table is to override ie. Enable the disabled objects from the previous table TranzformOverlay Disable Object.

The following Example Data Entries for TRANZFORM OVERLAY DISABLE OBJECT table in the database shows that object is a protected resource see whereby this resource is the last tab on the right called DUR .

The following Example Data Entries for TRANZFORM OVERLAY OVERRIDE OBJECT table in the database shows that the Pharmacist role has override access to this resource but the Technical role does not.

Referring again to the screen shot is that of someone logged in as a Pharmacist and the screen shot is of someone logged in as a Technician. As you can see the protected resource DUR tab is shown for the pharmacist and hidden for the Technician.

Accordingly the utility can generate the dynamic overlay from the above table data resident in the database . For example the following is the raw XML comprising the dynamic overlay file as generated by the utility using the tables for application to the role defined formset to result in the Pharmacist screen of the customized formset . It should be noted that there is no entry for StatusPatientDurResult meaning that this pharmacist user has access to this resource.

Similarly the following is the raw XML comprising the dynamic overlay file as generated by the utility for the role Technician. It should be noted that there is an entry for StatusPatientDurResult and the overlay property is to hide this resource from the display of the customized formset on the UI .

It is recognised in the above described example of overlays is limited to hide forms and status pages. However it is recognised that for example field masking and protection could also be implemented similarly.

Referring to the client application can request the formset based on the individual data settings of the user e.g. Clayton vs. Rob and then load the data pre populated user specific formset after the profiles has been applied by the server application . The pre populated data settings are inserted into the various fields of the formset for example data such as but not limited to user identification data e.g. name role etc . . . application data saved from an earlier session and status information of pending transactions processed by a transaction processing system not shown since the previous display of the formset e.g. new user login . For example the profiles can be stored in the database in the tables and collected via control files by the server application . It is recognised that the server application can apply the profiles stored at the server storage and or database the client application can apply the profiles located in local storage see or a combination thereof.

Referring to operation of the system is shown. The client application is initialized on the client such as via user login. At step the user requests the role defined formset from the server including the passing of the access generation criteria indicating category role and user identification individual group . It is recognised that the request can be done as one request for all overlays and profiles as a series of individual requests as shown in or some other request sequence as desired. The server application then selects the control files and associated table according to the access generation criteria. The server application then either generates or accesses the overlays according to the control files as well as the profiles and then applies the overlays and then applies the profiles to the master formset . The completed formset is then rendered to the UI of the client . It is recognised that the overlays can be applied to the master formset by the server application explicitly or the server can have resident preprocessed role defined formsets for selection based on the formset request of the client application . Further it is recognised that the server application can either generate and then apply the dynamic overlays to the role defined formset prior to sending to the client application or the server application can supply both the role defined formset and the overlay for subsequent processing by the client application to result in the customized formset for display on the UI .

read reads a single matching record based on a primary key hit from the database table or one to one joined tables 

change insert a single new record or update a single existing record based on the primary key and the data from the arriving transaction .

The read template example below as a raw template builds a query to find the single matching record or it returns an error based on the primary key of the table from the database .

It should be noted how the join fields can reference each other to perform a one to one join across tables like the eb claim id field in the ab cib1 ab cpd1 and ab cst1 segments . If any of the fields in the read template have a value specified like the action field in the ab ebill segment the specified value becomes part of the where criteria to form a filter. This template is invoked based on the transaction class name submitted from the client application matching the .template.xml.

The find template builds a query to find multiple matching records zero to many based on the criteria submitted as fields on the transaction the client application submitted.

Again the find template invoked is based on the transaction class name submitted matching the .find.properties file see Appendix A. The database query is broken out into a list of select fields the names to call those select fields in the XML response returned the tables to select from the order by clause and then a list of where criteria. Each where criteria has it s own two entries in the find properties file the first being dependancy which is the field in the arriving transaction that this criteria is dependent upon and the second being where which is the actual criteria to append to the where clause. If the dependency is blank then the criteria is always applied. If the dependency is non blank it will only be applied if the field named is supplied in the arriving transaction. Note that the various database query portions can have database type specific versions which will be invoked appropriately depending on the database communicating with such as the 1 where criteria which does date arithmetic in a database specific manner . Paging can be automatically supported ie break the response into pages of 100 records each .

As an aside an example XSLT based reporting of the system supports can do a find as described above and then processes the resulting XML response through a XSL transform named .find.xsl in a second step which converts the XML into HTML PDF excel or word mime types.

The change transaction does not use a server side description and may only affect a single record. It defaults to a NRP node rules processor base class that assumes the data segments in the arriving transaction map to table names and the data fields in the arriving transaction map to columns fields within that table. This default NRP can also perform optimistic concurrency checking when an update arrives check that the existing record if any has not been modified . Individual fields and or segments can be marked as non database values in which case they are not persisted to the relation database tables. An application specific extension of this base NRP class can be configured for different transaction classes to implement business logic based on hooks imbedded in the base NRP class.

The NRP is chosen is based on the transaction type and transaction class of the arriving transaction through a global mapping properties file such as but not limited to 

The above is a fragment from the .xml.parser.properties file see Appendix A. This shows all the Find transaction types being mapped to the generic java class ca.ebill.base.xml db.FindNRP. The Change and Read transaction types are then mapped to specialized NRPs that contain the business logic for the specific transaction classes with the demonstration above of the different change and read ab ebill claim transaction classes all being mapped to the same ca.ebill.ab.xml db.AbNRP java class that implements the NRP interface and extends the generic NRP base class. The generic NRP base class has hooks that call overrideable methods when certain events happen such as when a table node is read from the arriving XML transaction or the transaction root node is read from the arriving XML transaction . The extending application specific NRP class AbNRP in this case can then override that method and perform business logic such as edit checking fields ensuring if the location is hospital there has to be a hospital admit date set and other application specific business logic.

