---

title: Compressed program recording
abstract: Program execution can be monitored and recorded for later playback. Certain state changes that can be predicted via a virtual processor during playback need not be recorded, so a compressed recording can be stored. To facilitate random access with respect to time during playback, key frames can be stored within the compressed recording. An index mechanism can associate key frames with particular memory addresses. Additionally, a snapshot of values for memory addresses can be used to further facilitate determining the value of a memory address without having to simulate execution. Multiprocessor executions can be supported, and playback can be done on a machine type different from that on which recording took place.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07620938&OS=07620938&RS=07620938
owner: Microsoft Corporation
number: 07620938
owner_city: Redmond
owner_country: US
publication_date: 20051031
---
Debugging computer software can be a particularly challenging endeavor. Software defects bugs are notoriously difficult to locate and analyze. One common way to locate bugs is to generate a trace of program execution. In such an approach processor state and the values of memory locations are recorded after each single step of a program. A programmer can then consult the trace of the program s execution to see if the program is executing as expected.

However such a conventional approach breaks down if the program is particularly complex or if the program runs for any significant length of time. The pure volume of data generated by such a trace can quickly overwhelm the bandwidth and storage capacity of even advanced computer systems.

During execution a software program can be monitored to generate a recording of the program s execution. Compression techniques can be used to reduce the size of the recording of the program s execution. For example if a value for a memory address can be predicted via a virtual processor during playback the value need not be stored in the recording.

Various other features can be incorporated if desired. For example key frames can enable playback from an intermediate position e.g. in random access fashion within the recording. A summarization index can facilitate efficient location of relevant key frames and memory snapshots can be used to determine a value for a memory address without playing back the part of the recording that accesses the memory address. Multi processor support can include use of sequence numbers for synchronization.

The foregoing and other features and advantages will become more apparent from the following detailed description of disclosed embodiments which proceeds with reference to the accompanying drawings.

In the example a program recording tool processes state information within a software program under test during monitored execution of the program. Such execution can be simulated execution of the program e.g. by a software simulation engine that accepts an executable version of the program . The program recording tool can generate a recording of the execution of the program which as explained in the examples herein can be compressed. As explained herein the recording can include instructions e.g. code for the software program under test as well as a series of values that can be consulted to determine values for memory address read operations during playback.

Execution monitoring can monitor state information including read and write operations. For example the address and size of reads or writes can be monitored.

In practice the program recording can then be played back to determine the state of the program at various points in time during the monitored execution.

In any of the examples herein state information can include state changes or other information about the processor state changes to or values of memory addresses or any other changes in the state of the machine e.g. virtual machine caused during execution of the program e.g. by the program itself or services invoked by the program .

For example a register within a processor can change and values for memory locations can change information about the value of registers or memory locations can be monitored or both.

A recording of a program s execution or a program recording can include information about state during recorded monitored execution of the program. In practice the recording can also include executable instructions of the program which can be used during playback to simulate execution. In some cases playback of such instructions can be used to determine state changes without having to explicitly store the state e.g. without having to store a changed value of a register or memory address when the value changes .

For example if an instruction merely makes a change internal to the processor the change can be determined by simulating execution of the instruction without having to store the resulting value. In practice such instructions include those that increment registers add constants and the like. Compression can be achieved by not including state information in the program recording for such instructions.

The information can include the value of a memory address at a particular point in time during the recorded execution of the program e.g. what is the value of memory location x after execution of the nth instruction or after n processor cycles .

In practice the playback tool can be used as a debugger tool that a software developer can employ to determine the values of memory addresses and registers during execution of the program.

As described herein certain information about machine state can be predicted via the playback tool therefore the number of values stored in the recording can be significantly reduced. Because the compressed program recording can be of a smaller size than an uncompressed trace of the program s execution the system can be used to analyze and debug complex programs or programs that run for extended periods of time that could not be efficiently analyzed via an uncompressed trace.

In any of the examples described herein a variety of compression techniques can be used to reduce the size of a program recording. shows an example of a compression technique for use in program recordings.

In the example activity by a processor executing a program under test is shown in the uncompressed series of operations A G. The resulting compressed series of recorded states B D F and G are sufficient to reconstruct the uncompressed series . To conserve space a count can be stored instead of storing the values for certain memory addresses.

The techniques shown include discarding values for writes such as the write A. Such a write can be discarded from the compressed series because the value can be regenerated via the virtual processor and executable instructions of the program under test. So for example the value for the write A is not included in the series because it can be predicted during playback when the write operation is executed e.g. by a virtual processor . Instead a count is stored in B to indicate that the next two reads B and C can be correctly predicted based on the value from the write A.

Due to the count stored in B the series also does not need to store values for successive reads if the reads result in the same value. So for example the read for operation C need not be recorded because the read before it B had the same value. In particular successive identical reads or reads after writes e.g. when the value has not changed due to an external operation can be predicted via any of the predictability techniques described herein. The compressed data in can also indicate the size of read or write operations. However in practice the size need not be stored because it can be re created during playback.

The series can be stored as a stream. If desired different streams can be used for the different components of the data e.g. a separate stream for values and counts and the like . The information stored in the compressed program recording can also include data about instructions that break virtualization e.g. instructions that query the time or machine configuration for consideration during playback.

In practice the series can be stored with executable instructions for the program being recorded as a compressed program recording from which playback can determine the values of the memory addresses without having to store all the values involved in the read and write operations.

The technique of not storing values can also be described as not storing values if they can be predicted. Such predictions can rely on a virtual processor executing instructions of the software program under test and values already loaded e.g. at playback time from the compressed program recording.

When executing instructions of the software program under test it might be expected that the value e.g. for a memory address will be a certain value. For example it is expected that a value read from a memory address will be the value that was last written to it.

In some cases such an expectation will be wrong. For example the program may have switched into an unmonitored mode e.g. kernel mode which changed the value of the memory address. Further if other threads or processors are running they may change the value of the memory address. In such a case the subsequently monitored value will not have been correctly anticipated and it can be included in the program recording e.g. the compressed series . And further the value could change yet again so that the read from the value will be yet a different value.

So predictability can take advantage of the observation that a value is expected to be what was last written to the memory address but can also consider which values have already been loaded from the compressed program recording. A value that can be correctly predicted from a write or an entry in the compressed series that has already been loaded e.g. at playback time need not be stored again in the program recording. Instead for example a running count of the number of times in a row that values will be correctly predicted by the virtual processor and the entries already loaded e.g. at playback time from the series can be stored. For cases in which the prediction is correct a value need not be stored in the program recording e.g. the compressed series . When the prediction is not correct the value can be stored so that it can be loaded during playback.

Because the same virtual machine e.g. or an emulator of it consulting the stored program recording will predict the same values during playback storing the predictable values is unnecessary. Avoiding storage of the values can significantly reduce the size of the program recording.

In the example a playback tool accepts an initial state and recorded memory state changes for execution of a program along with a representation of the executable instructions for the program. Using a predictor e.g. which can include a virtual processor that can execute the instructions the playback tool can determine an ending memory state at a particular point during the execution which will reflect the memory state of the program when execution was monitored and recorded.

In any of the examples herein compressed memory state changed can be included in a program recording. shows an exemplary method of using a predictor and compressed memory state changes to determine memory state.

At a virtual processor can be used in conjunction with a representation of executable instructions to generate appropriate values for memory write operations. As a result values for the memory write operations by the processor need not be stored in the program recording. When determining the value of memory addresses values for unpredictable memory reads are retrieved from the program recording at .

Predictable memory reads can be predicted via a predictor and the compressed memory state changes can indicate whether the memory read is predictable or not e.g. by keeping a count of successive predictable reads . At the predictable memory reads as indicated in the compressed memory state changes are used to determine the value of memory addresses.

Because the values involved in memory writes and reads can be determined the value for a particular address in memory can be determined at a specified point in time for the program.

The resulting value of a memory read operation by a processor can often be predicted during playback e.g. it will remain the same or be written to by the processor unless it is changed by some mechanism external to that processor or some mechanism that is not monitored during program recording. shows an exemplary system employing a cache to determine predictability of memory read operations. In the example a representation of the executable instructions of the program are accepted by a recording tool that includes a predictor e.g. including a virtual processor operable to execute or simulate execution of the instructions in representation . The recording tool can generate an appropriate compressed program recording via monitoring execution of the instructions .

As shown in the example rather than storing successive predictable values for read operations the cache can include a hit count. If another read operation involves the value for the address already indicated in the cache the count can simply be incremented. If a different unpredictable value is detected the entry for the memory address can be stored and a new count started for the different value.

The example shows the cache after having recorded the read E of . The count in the cache is set to 1 because during playback there is one value that can be predicted i.e. 77 for memory address AE02 without having to load another value from the compressed series e.g. the value will already have been loaded from recorded entry D .

After recording the read F the count will be increased to 2 because during playback there will be one more value that can be predicted i.e. 90 for memory address without having to load another value from the compressed program recording e.g. the value will already be known based on the write E .

Thus for example a value can be correctly predicted during playback because it has already been loaded from the compressed program recording or because a virtual processor will perform a write operation for the memory address. Recording the execution can include determining which values will be correctly predicted. Values that can be correctly predicted at playback need not be written to the compressed program recording.

In any of the examples herein the cache can take the form of a buffer of fixed size. An index for the cache can be computed using a calculation scheme e.g. a modulus of the size of the cache on the address.

At an operation during monitored execution is analyzed to determine whether it is a read or a write. If the operation is a write the cache is updated at e.g. the value is placed in the cache . As noted elsewhere herein an indication that the write operation changed the value of memory need not be stored in the compressed program recording because it can be determined via execution of the executable instructions for the program.

If the operation is a read it is then determined at whether the value involved in the read is the same as that indicated in the cache e.g. is it predictable . If so the hit count for the cache is incremented at and the analysis continues.

If the value is not predictable at the count and value are stored as part of the compressed program recording e.g. as part of the memory state changes . The count is then reset and the cache is updated with the new value at . Analysis continues on subsequent reads and writes if any.

At the conclusion of the method the information in the cache can be flushed e.g. to the program recording so that the remaining information left over in the cache is available during playback.

Playback of a compressed program recording can similarly employ a caching technique to correctly determine the value of a memory address. shows an exemplary system that employs a cache to take advantage of predictability of memory read operations. Such a system can be included for example in a debugging tool. In the example a representation of the executable instructions of the program and a compressed program recording are accepted by a playback tool that includes a predictor e.g. including a virtual processor operable to execute or simulate execution of the instructions in representation . The playback tool can generate information e.g. a value of an address on the state of memory that reflects what was monitored during recording.

As shown in the example rather than storing successive predictable values for read operations the cache can include a hit count which is read from the compressed program recording . If a read operation involves an address and the hit count indicates the value is unchanged the count can simply be decremented. If the count goes down to zero a different unpredictable value is indicated the entry for the memory address can then be read from the recording together with a new hit count for the cache.

The cache is thus able to store at least one value of a memory address as a single stored value that can be used plural times e.g. reused as indicated in the hit counts during playback to indicate successive identical values for memory read operations for the memory address according to the compressed recording.

The cache can thus store a predictable value for a memory address and a hit count indicating how many successive times the cache will correctly predict values in succession.

At an operation during playback is analyzed to determine whether it is a read or a write. If the operation is a write the cache is updated at e.g. the value is placed in the cache . The value for the write can be determined via execution of the executable instructions for the program.

If the operation is a read it is then determined at whether the hit count in the cache is zero. If not the hit count is decremented at and the value for the read is taken from the cache.

If the hit count is zero then a new value and new hit count are loaded e.g. from the program recording at . The new value is used for the value of the read. At the cache is updated to reflect the new value and hit count.

At a query is received for the value of an address x at time t. The time may be expressed absolutely e.g. after this instruction after this many clock cycles etc. or relatively after the next n instructions etc. or implicitly e.g. at the current point during execution .

At a program recording is played back until the time t is reached using any of the techniques described herein. Then at the value at the address x is indicated. For example a debugging tool may show the value on a user interface.

Thus if playback begins at key frame A the instructions in the partial compressed program recording A need not be played back. In some cases such as when determining the value of a memory location that is modified subsequent to the key frame A the contents of the earlier compressed program recordings e.g. A may be immaterial to the result and can be ignored. In this way the amount of processing performed to determine state can be reduced.

In implementations involving a cache the cache can be flushed or stored before writing the key frame. As a result operations involving memory locations will update the cache.

The illustrated technique can involve generating key frames while the program is being monitored or at a later time. In some cases it may be desirable to generate the key frames in response to activity in a debugger e.g. by generating key frames for areas proximate the current time location being investigated in a debugger by a developer .

The frequency at which key frames are generated can be tuned e.g. increased or decreased to optimize performance and compression.

The key frame need to be stored e.g. if the cache is flushed . Alternatively the cache could be stored e.g. if storing results in better compression .

Although the example can take advantage of the key frames A N fulfilling the request may still involve considerable processing. If for example playback is initiated at key frame N and the value for the address x cannot be determined e.g. does not appear in the partial compressed program recording N processing can continue to start playback at each of the key frames e.g. in reverse order or some other order to see if the value can be determined.

To avoid the searching situation shown in an index can be used. A summarization index associating key frames with memory addresses is shown in . When a request for the value of a memory address is received the index can be consulted to determine at which key frames playback can be commenced to determine the value. Addresses for which memory values can be determined via playback of partial compressed program recordings immediately following a key frame are associated with the key frame in the index.

If desired more detailed information about the instructions or the instructions themselves can be stored in the index. For example a reference to where the instructions following the key frame involving a particular memory address can be found can be stored.

If desired basic information about key frames e.g. when the key frame occurred and where it can be found can also be stored in the summarization index.

Using the index the key frame s are found. At the one or more key frames starting playback sub sequences involving the address e.g. from which the value of the address can be determined such as those sub sequences involving reads or writes of the address are indicated.

In practice playback can then begin at the key frame closest to and earlier than the time location for which the value of the memory address was requested.

Responsive to receiving the request a considerable amount of processing may need to be done to determine the value of the address x. Even taking advantage of the key frames may involve executing several of the subsequences A N to determine within which the memory location appears. And even with the summarization index the partial compressed program recording is consulted. In a program involving a large number of instruction cycles it may not be efficient to load data for replay to determine activity so remote in time.

The snapshots A N can include a list of memory addresses and their associated values at the point in time during execution associated with the respective snapshot. Accordingly a request for the contents of a memory address x can be fulfilled without having to replay the compressed program recording at which the memory address can be found. Instead the closest snapshot before the request can be consulted e.g. snapshot N .

At a request for the contents of address x is received. At it is determined wither the address is in the code space. If it is the value for the code bytes are returned at .

At it is determined whether there is a summarization index for the current position e.g. of execution within the program recording . If not one is built that goes back from the current position to a point in execution e.g. a sequence where a snapshot exists. In some cases it may be desirable to go back more than one snapshot e.g. in anticipation of additional requests for other addresses . For example the summarization index can go back two three or more snapshots.

At it is determined whether the address is accessed in the summarization index. If it is at playback begins from the keyframe and finds the instruction that accesses the address to determine the value. At if the address was found the value is returned at .

If the address was not found at it is determined whether the address s value is in the snapshot that the summarization index borders. If so the value is returned at . Otherwise the address is not referenced in the compressed program recording and an address unknown result can be returned. In practice such a result can be indicated to a user as a series of question marks e.g. .

The number of summarizations can be tuned for performance. In practice snapshots tend to be larger than summarizations so having too many snapshots can degrade performance. But having fewer snapshots typically involves more simulation e.g. via a virtual processor and simulation is more efficient when a summarization can be consulted to determine where to simulate.

For example each of the sub recordings can be a stream or some other arrangement of data indicating a compressed program recording generated via monitoring state changes for a respective processor.

Thus execution of a program that runs on multiple processors can be recorded. A similar arrangement can be used for multiple threads or multiple processors executing multiple threads can supported.

At a separate compressed program recording is written for respective processors. Again a similar arrangement can be used for multiple threads or multiple processors executing multiple threads can be supported.

In some cases the sequences may not be dispositive. For example it may not be conclusively determined that segment B for the recording B executes after segment A for the recording A. In such a case when a request for the value of a memory address is received multiple values may be returned. Such multiple values can be communicated to the developer e.g. in a debugger and may be indicative of a program flaw e.g. a likely race condition .

At the atomically incremented sequence number is maintained and incremented atomically when needed e.g. an increment before write or increment after write scheme can be used . At the sequence is periodically written to the compressed program subsequence.

The sequence writes can be triggered by a variety of factors. For example whenever a lock or synchronization instruction e.g. inter thread atomic communication instructions such as compare and exchange and the like is encountered the sequence can be written. Also whenever the program goes into or out of kernel mode the sequence can be written. For further analysis the instructions between a pair lock instructions can be associated with the first instruction of the pair.

In any of the examples herein monitored execution can be accomplished by using a software simulation engine that accepts the program under test as input. In this way specialized hardware can be avoided when monitoring execution. Similarly playback can consult a software simulation engine as part of the playback mechanism e.g. as a predictor .

Any of the technologies herein can be provided as part of an application programming interface API by which client programs can access the functionality. For example a playback tool can expose an interface that allows a program to query values for memory locations single step execution and the like.

Further a client can indicate via function call that it is particularly interested in a range of instructions. In response key frames can be created during replay for the instructions within the range. Such an approach allows fast random access to positions close to the area of interest in the trace while still allowing for efficient storage of information outside the client s area of interest.

In practice during program recording the compressed program recording can be buffered in memory before writing to disk. A circular buffer technique can be used whereby writing to disk is not necessary.

For example as long as the buffer is large enough to hold a key frame and the information between the key frame and the next key frame then some of the program s state can be recreated. In practice with a large circular buffer typically many key frames are used to support random access.

When using the circular buffer a threshold size can be specified. When the amount of information for a compressed program recording exceeds the threshold information from the beginning of the recording is overwritten with later information.

Such an approach can be useful because it is often the end of a recording that is of interest e.g. shortly before a crash .

The threshold size can be any size accommodated by the system e.g. 50 megabytes 100 megabytes 150 megabytes and the like .

In any of the examples described herein the information in a compressed program recording can be further reduced in size by applying any compression algorithm. For example streams of information about read operations can be compressed indexes can be compressed summarization tables can be compressed or some combination thereof. Any number of compression techniques e.g. a compression technique available as part of the file system can be used.

The compressed program recording can be saved in a format that can be transferred to another machine type. For example execution monitoring can be done on one machine type and playback can be performed on another machine. Portable compressed program recordings are useful in that for example execution can be monitored on a machine under field conditions and playback can take place at another location by a developer on a different machine type.

To facilitate portability the executable instructions e.g. code bytes of the program under test can be included in the program recording. For example code e.g. binaries from linkable libraries e.g. dynamic link libraries can be included. Information useful for debugging e.g. symbol tables can also be included if desired.

If desired the compressed program recording can be sent e.g. piped to another machine during recording allowing near real time analysis as the information is gathered.

Additional information can be stored to facilitate portability such as machine configuration information architecture endianness e.g. byte order of the machine and the like.

A user interface can be presented to a developer by which the machine state as determined via the compressed program recording is indicated. Controls e.g. single stepping stepping backwards jumping ahead n instructions breakpointing and the like can be presented by which the developer can control the display of the machine state.

To the developer it appears that the program is being executed in debug mode but a compressed program recording can be used to avoid the full processing and storage associated with full debug mode.

Any number of formats can be used to store a compressed program recording. For example the information can be saved in a file e.g. on disk . In order to reduce contention between different threads of the program being monitored data can be recorded for each thread independently in different streams within the file. For each stream the data for simulating program execution during playback can be recorded.

The file format can include sequencing packets read packets executable instructions and the like. For example the sequencing packets can store the sequence information described herein. A global integer or timer can be used for the sequence. Sequencing events can be made uniquely identifiable so that ordering can be achieved.

On a single processor system perfect ordering can be achieved by tracking context swaps between threads. The sequencing events can also be used to track key frames e.g. when a thread transfers control from kernel mode and user mode .

The executable instructions can include the bytes of the instructions executed in the program. During replay a simulator can fetch such instructions for simulated execution.

In any of the examples herein the memory can be virtual memory. For example memory accesses by a monitored program can be to virtual memory. Playback of a compressed program recording can then be used to determine the value of an address in such virtual memory e.g. when a request for a value of an address in virtual memory is received .

With reference to the computing environment includes at least one processing unit and memory . In this most basic configuration is included within a dashed line. The processing unit executes computer executable instructions and may be a real or a virtual processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. The memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory etc. or some combination of the two. The memory can store software implementing any of the technologies described herein.

A computing environment may have additional features. For example the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The storage may be removable or non removable and includes magnetic disks magnetic tapes or cassettes CD ROMs CD RWs DVDs or any other computer readable media which can be used to store information and which can be accessed within the computing environment . The storage can store software containing instructions for any of the technologies described herein.

The input device s may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device or another device that provides input to the computing environment . For audio the input device s may be a sound card or similar device that accepts audio input in analog or digital form or a CD ROM reader that provides audio samples to the computing environment. The output device s may be a display printer speaker CD writer or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer executable instructions audio video or other media information or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired or wireless techniques implemented with an electrical optical RF infrared acoustic or other carrier.

Communication media can embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above can also be included within the scope of computer readable media.

The techniques herein can be described in the general context of computer executable instructions such as those included in program modules being executed in a computing environment on a target real or virtual processor. Generally program modules include routines programs libraries objects classes components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer executable instructions for program modules may be executed within a local or distributed computing environment.

Any of the methods described herein can be implemented by computer executable instructions in one or more computer readable media e.g. computer readable storage media .

The technologies from any example can be combined with the technologies described in any one or more of the other examples. In view of the many possible embodiments to which the principles of the disclosed technology may be applied it should be recognized that the illustrated embodiments are examples of the disclosed technology and should not be taken as a limitation on the scope of the disclosed technology. Rather the scope of the disclosed technology includes what is covered by the following claims. We therefore claim as our invention all that comes within the scope and spirit of these claims.

