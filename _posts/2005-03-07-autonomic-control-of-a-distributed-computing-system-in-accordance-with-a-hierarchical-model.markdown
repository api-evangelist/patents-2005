---

title: Autonomic control of a distributed computing system in accordance with a hierarchical model
abstract: A distributed computing system conforms to a multi-level, hierarchical organizational model. One or more control nodes provide for the efficient and automated allocation and management of computing functions and resources within the distributed computing system in accordance with the organization model. The model includes four distinct levels: fabric, domains, tiers and nodes that provide for the logical abstraction and containment of the physical components as well as system and service application software of the enterprise. A user, such as a system administrator, interacts with the control nodes to logically define the hierarchical organization of distributed computing system. The control node includes an automation subsystem having one or more rule engines that provide autonomic control of the application nodes in accordance with a set of one or more rules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07680799&OS=07680799&RS=07680799
owner: Computer Associates Think, Inc.
number: 07680799
owner_city: Islandia
owner_country: US
publication_date: 20050307
---
The application is a continuation in part of and claims priority to Ser. No. 11 047 468 filed Jan. 31 2005 the entire content of which is incorporated by reference.

The invention relates to computing environments and more specifically to distributed computing systems.

Distributed computing systems are increasingly being utilized to support business as well as technical applications. Typically distributed computing systems are constructed from a collection of computing nodes that combine to provide a set of processing services to implement the distributed computing applications. Each of the computing nodes in the distributed computing system is typically a separate independent computing device interconnected with each of the other computing nodes via a communications medium e.g. a network.

One challenge with distributed computing systems is the organization deployment and administration of such a system within an enterprise environment. For example it is often difficult to manage the allocation and deployment of enterprise computing functions within the distributed computing system. An enterprise for example often includes several business groups and each group may have competing and variable computing requirements.

In general the invention is directed to a distributed computing system that conforms to a multi level hierarchical organizational model. One or more control nodes provide for the efficient and automated allocation and management of computing functions and resources within the distributed computing system in accordance with the organization model.

As described herein the model includes four distinct levels fabric domains tiers and nodes that provide for the logical abstraction and containment of the physical components as well as system and service application software of the enterprise. A user such as a system administrator interacts with the control nodes to logically define the hierarchical organization of the distributed computing system. The control nodes are responsible for all levels of management in accordance with the model including fabric management domain creation tier creation and node allocation and deployment.

In one embodiment a method comprises receiving input that defines a model for a hierarchical organization of a distributed computing system having a plurality of computing nodes. The model specifies a fabric having one or more domains and wherein each domain has at least one tier that includes at least one node slot. The method further comprises automatically configuring the distributed computing system in accordance with the hierarchical organization defined by the model.

In one embodiment a distributed computing system comprises a plurality of application nodes interconnected via a communications network and a control node. The control node includes an automation subsystem having one or more rule engines that provide autonomic control of the application nodes in accordance with a set of one or more rules.

In another embodiment a method comprises receiving input that defines an expected state for a distributed computing system having a plurality of application nodes interconnected via a communications network and receiving status data that represents an actual state for the distributed computing system. The method further comprises processing rules with a set of rule engines to determine operations for reducing any difference between the actual state and the expected state and applying the operations to the distributed computing system to control the application nodes in accordance with the rules.

In another embodiment a computer readable medium comprises instructions that cause a processor to process rules with a set of forward chaining rule engines to determine operations for reducing differences between an actual state of a distributed computing system and an expected state. The instructions further cause the computer to apply the operations to the distributed computing system to provide autonomic control of the application nodes in accordance with the rules.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features objects and advantages of the invention will be apparent from the description and drawings and from the claims.

In the illustrated example the collection of computing nodes forming distributed computing system are logically grouped within a discovered pool a free pool an allocated tiers and a maintenance pool . In addition distributed computing system includes at least one control node .

Within distributed computing system a computing node refers to the physical computing device. The number of computing nodes needed within distributed computing system is dependent on the processing requirements. For example distributed computing system may include 8 to 512 computing nodes or more. Each computing node includes one or more programmable processors for executing software instructions stored on one or more computer readable media.

Discovered pool includes a set of discovered nodes that have been automatically discovered within distributed computing system by control node . For example control node may monitor dynamic host communication protocol DHCP leases to discover the connection of a node to network . Once detected control node automatically inventories the attributes for the discovered node and reassigns the discovered node to free pool . The node attributes identified during the inventory process may include a CPU count a CPU speed an amount of memory e.g. RAM local disk characteristics or other computing resources. Control node may also receive input identifying node attributes not detectable via the automatic inventory such as whether the node includes I O such as HBA. Further details with respect to the automated discovery and inventory processes are described in U.S. patent application Ser. No. 11 070 851 entitled AUTOMATED DISCOVERY AND INVENTORY OF NODES WITHIN AN AUTONOMIC DISTRIBUTED COMPUTING SYSTEM filed Mar. 2 2005 the entire content of which is hereby incorporated by reference.

Free pool includes a set of unallocated nodes that are available for use within distributed computing system . Control node may dynamically reallocate an unallocated node from free pool to allocated tiers as an application node . For example control node may use unallocated nodes from free pool to replace a failed application node or to add an application node to allocated tiers to increase processing capacity of distributed computing system .

In general allocated tiers include one or more tiers of application nodes that are currently providing a computing environment for execution of user software applications. In addition although not illustrated separately application nodes may include one or more input output I O nodes. Application nodes typically have more substantial I O capabilities than control node and are typically configured with more computing resources e.g. processors and memory . Maintenance pool includes a set of nodes that either could not be inventoried or that failed and have been taken out of service from allocated tiers .

Control node provides the system support functions for managing distributed computing system . More specifically control node manages the roles of each computing node within distributed computing system and the execution of software applications within the distributed computing system. In general distributed computing system includes at least one control node but may utilize additional control nodes to assist with the management functions.

Other control nodes not shown in are optional and may be associated with a different subset of the computing nodes within distributed computing system . Moreover control node may be replicated to provide primary and backup administration functions thereby allowing for graceful handling a failover in the event control node fails.

Network provides a communications interconnect for control node and application nodes as well as discovered nodes unallocated nodes and failed nodes. Communications network permits internode communications among the computing nodes as the nodes perform interrelated operations and functions. Communications network may comprise for example direct connections between one or more of the computing nodes one or more customer networks maintained by an enterprise local area networks LANs wide area networks WANs or a combination thereof. Communications network may include a number of switches routers firewalls load balancers and the like.

In one embodiment each of the computing nodes within distributed computing system executes a common general purpose operating system. One example of a general purpose operating system is the Windows operating system provided by Microsoft Corporation. In some embodiments the general purpose operating system such as the Linux kernel.

In the example of control node is responsible for software image management. The term software image refers to a complete set of software loaded on an individual computing node including the operating system and all boot code middleware and application files. System administrator may interact with control node and identify the particular types of software images to be associated with application nodes . Alternatively administration software executing on control node may automatically identify the appropriate software images to be deployed to application nodes based on the input received from system administrator . For example control node may determine the type of software image to load onto an application node based on the functions assigned to the node by system administrator . Application nodes may be divided into a number of groups based on their assigned functionality. As one example application nodes may be divided into a first group to provide web server functions a second group to provide business application functions and a third group to provide database functions. The application nodes of each group may be associated with different software images.

Control node provides for the efficient allocation and management of the various software images within distributed computing system . In some embodiments control node generates a golden image for each type of software image that may be deployed on one or more of application nodes . As described herein the term golden image refers to a reference copy of a complete software stack.

System administrator may create a golden image by installing an operating system middleware and software applications on a computing node and then making a complete copy of the installed software. In this manner a golden image may be viewed as a master copy of the software image for a particular computing function. Control node maintains a software image repository that stores the golden images associated with distributed computing system .

Control node may create a copy of a golden image referred to as an image instance for each possible image instance that may be deployed within distributed computing system for a similar computing function. In other words control node pre generates a set of K image instances for a golden image where K represents the maximum number of image instances for which distributed computing system is configured for the particular type of computing function. For a given computing function control node may create the complete set of image instance even if not all of the image instances will be initially deployed. Control node creates different sets of image instances for different computing functions and each set may have a different number of image instances depending on the maximum number of image instances that may be deployed for each set. Control node stores the image instances within software image repository . Each image instance represents a collection of bits that may be deployed on an application node.

Further details of software image management are described in co pending U.S. patent application Ser. No. 11 046 133 entitled MANAGEMENT OF SOFTWARE IMAGES FOR COMPUTING NODES OF A DISTRIBUTED COMPUTING SYSTEM filed Jan. 28 2005 and co pending U.S. patent application Ser. No. 11 046 152 entitled UPDATING SOFTWARE IMAGES ASSOCIATED WITH A DISTRIBUTED COMPUTING SYSTEM filed Jan. 28 2005 each of which is incorporated herein by reference in its entirety.

In general distributed computing system conforms to a multi level hierarchical organizational model that includes four distinct levels fabric domains tiers and nodes. Control node is responsible for all levels of management including fabric management domain creation tier creation and node allocation and deployment.

As used herein the fabric level generally refers to the logical constructs that allow for definition deployment partitioning and management of distinct enterprise applications. In other words fabric refers to the integrated set of hardware system software and application software that can be knitted together to form a complete enterprise system. In general the fabric level consists of two elements fabric components or fabric payload. Control node provides fabric management and fabric services as described herein.

In contrast a domain is a logical abstraction for containment and management within the fabric. The domain provides a logical unit of fabric allocation that enables the fabric to be partitioned amongst multiple uses e.g. different business services.

Domains are comprised of tiers such as a 4 tier application model web server application server business logic persistence layer or a single tier monolithic application. Fabric domains contain the free pool of devices available for assignment to tiers.

A tier is a logically associated group of fabric components within a domain that share a set of attributes usage availability model or business service mission. Tiers are used to define structure within a domain e.g. N tier application and each tier represents a different computing function. A user such as administrator typically defines the tier structure within a domain. The hierarchical architecture may provide a high degree of flexibility in mapping customer applications to logical models which run within the fabric environment. The tier is one construct in this modeling process and is the logical container of application resources.

The lowest level the node level includes the physical components of the fabric. This includes computing nodes that as described above provide operating environments for system applications and enterprise software applications. In addition the node level may include network devices e.g. Ethernet switches load balancers and firewalls used in creating the infrastructure of network . The node level may further include network storage nodes that are network connected to the fabric.

System administrator accesses administration software executing on control node to logically define the hierarchical organization of distributed computing system . For example system administrator may provide organizational data to develop a model for the enterprise and logically define the enterprise fabric. System administrator may for instance develop a model for the enterprise that includes a number of domains tiers and node slots hierarchically arranged within a single enterprise fabric.

More specifically system administrator defines one or more domains that each correspond to a single enterprise application or service such as a customer relation management CRM service. System administrator further defines one or more tiers within each domain that represent the functional subcomponents of applications and services provided by the domain. As an example system administrator may define a storefront domain within the enterprise fabric that includes a web tier an application tier and a database tier. In this manner distributed computing system may be configured to automatically provide web server functions business application functions and database functions.

For each of the tiers control node creates a number of node slots equal to the maximum number of application nodes that may be deployed. In general each node slot represents a data set that describes specific information for a corresponding node such as software resources for a physical node that is assigned to the node slot. The node slots may for instance identify a particular software image instance associated with an application node as well as a network address associated with that particular image instance.

In this manner each of the tiers include one or more node slots that reference particular software image instances to boot on the application nodes to which each software image instance is assigned. The application nodes to which control node A assigns the image instances temporarily inherit the network address assigned to the image instance for as long as the image instance is deployed on that particular application node. If for some reason the image instance is moved to a different application node control node A moves the network address to that new application node.

System administrator may further define specific node requirements for each tier of the fabric. For example the node requirements specified by system administrator may include a central processing unit CPU count a CPU speed an amount of memory e.g. RAM local disk characteristics and other hardware characteristics that may be detected on the individual computing nodes. System administrator may also specify user defined hardware attributes of the computing nodes such as whether I O like HBA is required. The user defined hardware attributes are typically not capable of detection during an automatic inventory. In this manner system administrator creates a list of attributes that the tier requires of its candidate computing nodes. In addition particular node requirements may be defined for software image instances.

In addition to the node requirements described above system administrator may further define policies that are used when re provisioning computing nodes within the fabric. System administrator may define policies regarding tier characteristics such as a minimum number of nodes a tier requires an indication of whether or not a failed node is dynamically replaced by a node from free pool a priority for each tier relative to other tiers an indication of whether or not a tier allows nodes to be re provisioned to other tiers to satisfy processing requirements by other tiers of a higher priority or other policies. Control node uses the policy information input by system administrator to re provision computing nodes to meet tier processing capacity demands.

After receiving input from system administrator defining the architecture and policy of the enterprise fabric control node identifies unallocated nodes within free pool that satisfy required node attributes. Control node automatically assigns unallocated nodes from free pool to respective tier node slots of a tier. As will be described in detail herein in one embodiment control node may assign computing nodes to the tiers in a best fit fashion. Particularly control node assigns computing nodes to the tier whose node attributes most closely match the node requirements of the tier as defined by administrator . The assignment of the computing nodes may occur on a tier by tier basis beginning with a tier with the highest priority and ending with a tier with the lowest priority. Alternatively or in addition assignment of computing nodes may be based on dependencies defined between tiers.

As will be described in detail below control node may automatically add unallocated nodes from free pool to a tier when more processing capacity is needed within the tier remove nodes from a tier to the free pool when the tier has excess capacity transfer nodes from tier to tier to meet processing demands or replace failed nodes with nodes from the free pool. Thus computing resources i.e. computing nodes may be automatically shared between tiers and domains within the fabric based on user defined policies to dynamically address high processing demands failures and other events.

In this example e commerce fabric includes a storefront domain A and a financial planning domain B. Storefront domain A corresponds to the enterprise storefront domain and allows customers to find and purchase products over a network such as the Internet. Financial planning domain B allows one or more employees to perform financial planning tasks for the enterprise.

Tier level C includes one or more tiers within each domain that represent the functional subcomponents of applications and services provided by the domain. For example storefront domain A includes a web server tier labeled web tier A a business application tier labeled app tier B and a database tier labeled DB tier C. Web server tier A business application tier B and database tier C interact with one another to present a customer with an online storefront application and services. For example the customer may interact with web server tier A via a web browser. When the customer searches for a product web server tier A may interacts with business application tier B which may in turn access a database tier C. Similarly financial planning domain B includes a financial planning tier D that provides subcomponents of applications and services of the financial planning domain B. Thus in this example a domain may include a single tier.

Tier level D includes one or more logical node slots A H node slots within each of the tiers. Each of node slots include node specific information such as software resources for an application node that is assigned to a respective one of the node slots . Node slots may for instance identify particular software image instances within image repository and map the identified software image instances to respective application nodes . As an example node slots A and B belonging to web server tier A may reference particular software image instances used to boot two application nodes to provide web server functions. Similarly the other node slots may reference software image instances to provide business application functions database functions or financial application functions depending upon the tier to which the node slots are logically associated.

Although in the example of there are two node slots corresponding to each tier the tiers may include any number of node slots depending on the processing capacity needed on the tier. Furthermore not all of node slots may be currently assigned to an application node . For example node slot B may be associated with an inactive software image instance and when needed may be assigned to an application node for deployment of the software image instance.

In this example organizational data associates free node pool with the highest level of the model i.e. e commerce fabric . As described above control node may automatically assign unallocated nodes from free node pool to at least a portion of tier node slots of tiers as needed using the best fit algorithm described above or another algorithm. Additionally control node may also add nodes from free pool to a tier when more processing capacity is needed within the tier remove nodes from a tier to free pool when a tier has excess capacity transfer nodes from tier to tier to meet processing demands and replace failed nodes with nodes from the free tier.

Although not illustrated the model for the enterprise fabric may include multiple free node pools. For example the model may associate free node pools with individual domains at the domain level or with individual tier levels. In this manner administrator may define policies for the model such that unallocated computing nodes of free node pools associated with domains or tiers may only be used within the domain or tier to which they are assigned. In this manner a portion of the computing nodes may be shared between domains of the entire fabric while other computing nodes may be restricted to particular domains or tiers.

During this process control node may receive input specifying node requirements of each of the tiers of the hierarchical model . As described above administrator may specify a list of attributes e.g. a central processing unit CPU count a CPU speed an amount of memory e.g. RAM or local disk characteristics that the tiers require of their candidate computing nodes. In addition control node may further receive user defined custom attributes such as requiring the node to have I O such as HBA connectivity. The node requirements or attributes defined by system administrator may each include a name used to identify the characteristic a data type e.g. integer long float or string and a weight to define the importance of the requirement.

Control node identifies the attributes for all candidate computing nodes within free pool or a lower priority tier . As described above control node may have already discovered the computing nodes and inventoried the candidate computing nodes to identify hardware characteristics of all candidate computing nodes. Additionally control node may receive input from system administrator identifying specialized capabilities of one or more computing nodes that are not detectable by the inventory process.

Control node dynamically assigns computing nodes to the node slots of each tier based on the node requirements specified for the tiers and the identified node attributes . Population of the node slots of the tier may be performed on a tier by tier basis beginning with the tier with the highest priority i.e. the tier with the highest weight assigned to it. As will be described in detail in one embodiment control node may populate the node slots of the tiers with the computing nodes that have attributes that most closely match the node requirements of the particular tiers. Thus the computing nodes may be assigned using a best fit algorithm.

Next control node retrieves the node requirements associated with the selected tier . Control node may for example maintain a database having entries for each node slot where the entries identify the node requirements for each of the tiers. Control node retrieves the node requirements for the selected tier from the database.

In addition control node accesses the database and retrieves the computing node attributes of one of the unallocated computing nodes of free pool . Control node compares the node requirements of the tier to the node attributes of the selected computing node .

Based on the comparison control node determines whether the node attributes of the computing node meets the minimum node requirements of the tier . If the node attributes of the selected computing node do not meet the minimum node requirements of the tier then the computing node is removed from the list of candidate nodes for this particular tier . Control node repeats the process by retrieving the node attributes of another of the computing nodes of the free pool and compares the node requirements of the tier to the node attributes of the computing node.

If the node attributes of the selected computing node meet the minimum node requirements of the tier YES of control node determines whether the node attributes are an exact match to the node requirements of the tier . If the node attributes of the selected computing node and the node requirements of the tier are a perfect match YES of the computing node is immediately assigned from the free pool to a node slot of the tier and the image instance for the slot is associated with the computing node for deployment .

Control node then determines whether the node count for the tier is met . Control node may for example determine whether the tier is assigned the minimum number of nodes necessary to provide adequate processing capabilities. In another example control node may determine whether the tier is assigned the ideal number of nodes defined by system administrator . When the node count for the tier is met control node selects the next tier to enable e.g. the tier with the next largest priority and repeats the process until all defined tiers are enabled i.e. populated with application nodes .

If the node attributes of the selected computing node and the node requirements of the tier are not a perfect match control node calculates and records a processing energy of the node . As used herein the term processing energy refers to a numerical representation of the difference between the node attributes of a selected node and the node requirements of the tier. A positive processing energy indicates the node attributes more than satisfy the node requirements of the tier. The magnitude of the processing energy represents the degree to which the node requirements exceed the tier requirements.

After computing and recording the processing energy of the nodes control node determines whether there are more candidate nodes in free pool . If there are additional candidate nodes control node repeats the process by retrieving the computing node attributes of another one of the computing nodes of the free pool of computing nodes and comparing the node requirements of the tier to the node attributes of the computing node .

When all of the candidate computing nodes in the free pool have been examined control node selects the candidate computing node having the minimum positive processing energy and assigns the selected computing node to a node slot of the tier . Control node determines whether the minimum node count for the tier is met . If the minimum node count for the tier has not been met control node assigns the computing node with the next lowest calculated processing energy to the tier . Control node repeats this process until the node count is met. At this point control node selects the next tier to enable e.g. the tier with the next largest priority .

In the event there are an insufficient number of computing nodes in free pool or an insufficient number of computing nodes that meet the tier requirements control node notifies system administrator . System administrator may add more nodes to free pool add more capable nodes to the free pool reduce the node requirements of the tier so more of the unallocated nodes meet the requirements or reduce the configured minimum node counts for the tiers.

Control node then determines whether there are any computing nodes in the free pool of nodes that meet the minimum node requirements of the tier . When there are one or more nodes that meet the minimum node requirements of the tier control node selects the node from the free pool based the node requirements of the tier as described above and assigns the node to the tier . As described in detail with respect to control node may determine whether there are any nodes that have node attributes that are an exact match to the node requirements of the tier. If an exact match is found the corresponding computing node is assigned to a node slot of the tier. If no exact match is found control node computes the processing energy for each node and assigns the computing node with the minimum processing energy to the tier. Control node remotely powers on the assigned node and remotely boots the node with the image instance associated with the node slot. Additionally the booted computing node inherits the network address associated with the node slot.

If there are no adequate computing nodes in the free pool i.e. no nodes at all or no nodes that match the minimal node requirements of the tier control node identifies the tiers with a lower priority than the tier needing more processing capacity .

Control node determines which of the nodes of the lower priority tiers meet the minimum requirements of the tier in need of processing capacity . Control node may for example compare the attributes of each of the nodes assigned to node slots of the lower priority tiers to the node requirements of the tier in need of processing capacity. Lower priority tiers that have the minimum number of computing nodes may be removed from possible tiers from which to harvest an application node. If however all the lower priority tiers have the minimum number of computing nodes defined for the respective tier the lowest priority tier is selected from which to harvest the one or more nodes.

Control node calculates the processing energy of each of the nodes of the lower priority tiers that meet the minimum requirements . The energies of the nodes are calculated using the differences between the node attributes and the node requirements of the tier needing additional capacity. Control node selects the computing node with the lowest processing energy that meets the minimum requirements and assigns the selected computing node to the tier in need of processing capacity .

When harvesting a node control node calculates the processing energy of all the nodes in the tier as described above with reference to . Control node identifies the node within the tier with the highest processing energy and returns the identified node to the free pool of nodes . As described above the node with the highest processing energy corresponds to the node whose node attributes are the most in excess of the node requirements of the tier.

Returning the node to the free pool may involve remotely powering off the computing node and updating the database to associate the harvested node with free pool . In addition control node updates the database to disassociate the returned node with the node slot to which it was assigned. At this point the node no longer uses the network address associated with the image instance mapped to the node slot. Control node may therefore assign a temporary network address to the node while the node is assigned to free pool .

When configuring a tier system administrator may elect to activate email alerts. For example system administrator may activate the email alerts feature in order to receive email alerts providing system administrator with critical and or non critical tier information such as a notification that a tier has been upgraded a node of the tier has failed or the like. Furthermore system administrator may input various policies such node failure rules. For example system administrator may identify whether control node should reboot a node in case of failure or whether the failed node should automatically be moved to maintenance pool . Similarly system administrator may identify whether nodes assigned to the tier may be harvested by other tiers.

User interface may also allow system administrator to input node requirements of a tier. In order to input node requirements of a tier system administrator may click on the Requirements tab causing user interface to present an input area to particular node requirements of the tier.

User interface also displays properties that control node has identified during the computing node inventory process. In this example user interface presents system administrator with the a CPU node count a CPU speed the amount of RAM the disk size and other characteristics that are identifiable during the automated node inventory. User interface additionally presents interface information to system administrator . Specifically user interface provides system administrator with a list of components and their associated IP and MAC addresses.

User interface also allows system administrator to define other custom requirements. For example system administrator may define one or more attributes and add those attributes to the list of node attributes presented to system administrator .

System administrator or another user may select an image by clicking on the box in front of the image identifier name and perform one or more actions on the image. Actions that system administrator may perform on an image include deleting the image updating the image and the like. System administrator may select one of the image actions via dropdown menu . In some embodiments user interface may further display other details about the images such as the node to which the images are assigned if the node status is active the network address associated with the images and the like.

For each node user interface presents a node ID a status of the node the tier to which the node belongs a hostname associated with the node a NIC IP address a rack location a slot location the number of CPU s of the node the amount of RAM on the node the number of disks on the node whether the node has I O HBA and the number of NICs of the node.

System administrator or other user may select a node by clicking on the box in front of the node identifier name and perform one or more actions on the node. Actions that system administrator may perform on the node include deleting the node updating the node attributes or other properties of the node and the like. System administrator may select one of the node actions via dropdown menu .

System administrator or other user may select an alert by clicking on the box in front of the logged alert and perform one or more actions on the logged alert. Actions that system administrator may perform include deleting the alert changing the status of the alert or the like. System administrator may specify the log actions via dropdown menu .

Monitoring subsystem provides real time monitoring of the distributed computing system . In particular monitoring subsystem dynamically collects status data from the hardware and software operating within distributed computing system and feeds the status data in the form of monitor inputs to SLAI . Monitoring inputs may be viewed as representing the actual state of the fabric defined for the organizational model implemented by distributed computing system . Monitoring subsystem may utilize well defined interfaces e.g. the Simple Network Management Protocol SNMP and the Java Management Extensions JMX to collect and export real time monitoring information to SLAI .

SLAI may be viewed as an automation subsystem that provides support for autonomic computing and acts as a central nervous system for the controlled fabric. In general SLAI receives monitoring inputs from monitoring subsystem analyzes the inputs and outputs appropriate action requests to BLT . In one embodiment SLAI is a cybernetic system that controls the defined fabric via feedback loops. More specifically administrator may interact with BLT to define an expected state for the fabric. BLT communicates expected state to SLAI . SLAI receives the monitoring inputs from monitoring subsystem and applies rules to determine the most effective way of reducing the differences between the expected and actual states for the fabric.

For example SLAI may apply a rule to determine that a node within a high priority tier has failed and that the node should be replaced by harvesting a node from a lower priority tier. In this example SLAI outputs an action request to invoke BLT to move a node from one tier to the other.

In general BLT implements high level business operations on fabrics domains and tiers. SLAI invokes BLT to bring the actual state of the fabric into accordance with the expected state. In particular BLT outputs fabric actions to perform the physical fabric changes. In addition BLT outputs an initial expected state to SLAI and initial monitoring information to SLAI and monitoring subsystem respectively. In addition BLT outputs notifications to SLAI and monitoring subsystem to indicate the state and monitoring changes to distributed computing system . As one example BLT may provide control operations that can be used to replace failed nodes. For example BLT may output an action request indicating that a node having address 10.10.10.10 has been removed from tier ABC and a node having address 10.10.10.11 has been added to tier XYZ. In response monitoring subsystem stops attempting to collect status data from node 10.10.10.10 and starts monitoring for status data from node 10.10.10.11. In addition SLAI updates an internal model to automatically associate monitoring inputs from node 10.10.10.11 with tier XYZ.

As described further below monitoring subsystem employs a modular architecture that allows new detection and monitoring collectors to be plugged in for existing and new protocols and for existing and new hardware and software. As illustrated in monitoring subsystem provides a plug in architecture that allows different information collectors to be installed. In general collectors are responsible for protocol specific collection of monitoring information. The plug in architecture allows for new protocols to be added by simply adhering to a collector plug in signature. In this example monitoring subsystem includes collectors A and B for collecting information from operating systems and applications executing on nodes within tier A and tier B respectively.

In one embodiment collectors are loaded at startup of control node and are configured with information retrieved from BLT . Monitoring engine receives collection requests from SLAI sorts and prioritizes the requests and invokes the appropriate one of collectors based on the protocol specified in the collection requests. The invoked collector is responsible for collecting the required status data and returning the status data to monitoring engine . If the collector is unable to collect the requested status data the collector returns an error code.

In one embodiment collectors are Java code compiled into ajar file and loaded with a class loader at run time. Each of collectors has an associated configuration file written in a data description language such as the extensible markup language XML . In addition a user may interact with BLT to add run time configuration to dynamically configure collectors for specific computing environments. Each of collectors expose an application programming interface API to monitoring engine for communication and data exchange.

A user such as a system administrator specifies the protocol or protocols to be used for monitoring a software image when the image is created. In addition the users may specify the protocols to be used for monitoring the nodes and each service executing on the nodes. Example protocols supported by the collectors include Secure Shell SSH Simple Network Management Protocol SNMP Internet Control Message Protocol ICMP ping Java Management Extensions JMX and the Hypertext Transfer Protocol HTTP .

Some protocols require special privileges e.g. root privileges to perform the required data collection. In this case the corresponding collectors communicate with a separate process that executes as the root. Moreover some protocols may require deployment and or configuration of data providers within the fabric. Software agents may for example be installed and configured on nodes and configured on other hardware. If needed custom in fabric components may be deployed.

In this example the modular architecture of monitoring subsystem also supports one or more plug in interfaces for data collection from a wide range of third party monitoring systems . Third party monitoring systems monitor portions of the fabric and may be vendor specific.

In general sensor subsystem receives actual state data from monitoring subsystem in the form of monitoring inputs and supplies ongoing dynamic input data to analysis subsystem . For example sensor subsystem is notified of physical changes to distributed computing system by monitoring subsystem . Sensor subsystem uses the state data received from monitoring subsystem to maintain ongoing calculated values that can be sent to analysis subsystem in accordance with scheduler .

In one embodiment sensor subsystem performs time based hierarchical data aggregation of the actual state data in accordance with the defined organization model. Sensor subsystem maintains organizational data in a tree like structure that reflects the current configuration of the hierarchical organization model. Sensor subsystem uses the organizational data to perform the real time data aggregation and map tiers and domains to specific nodes. Sensor subsystem maintains the organizational data based on notifications received from BLT .

Sensor subsystem sends inputs to analysis subsystem to communicate the aggregated data on a periodic or event driven basis. Analysis subsystem may register an interest in a particular aggregated data value with sensor subsystem and request updates at a specified frequency. In response sensor subsystem interacts with monitoring subsystem and scheduler to generate the aggregated data required by analysis subsystem .

Sensor subsystem performs arbitrary data aggregations via instances of plug in classes referred to as triggers that define the aggregations. Each trigger is registered under a compound name based on the entity being monitored and the type of data being gathered. For example a trigger may be defined to aggregate and compute an average computing load for a tier every five minutes. Analysis subsystem requests the aggregated data based on the registered names. In some embodiments analysis subsystem may define calculations directly and pass them to sensor subsystem dynamically.

Analysis subsystem is composed of a plurality of forward chaining rule engines A N. In general rule engines match patterns in a combination of configuration data and monitoring data which is presented by extraction agent in the form of events. Events contain the aggregated data values that are sent to rule engines in accordance with scheduler .

Sensor subsystem may interact with analysis subsystem via trigger listeners that receives updates from a trigger within sensor subsystem when specified events occur. An event may be based on system state e.g. a node transitioning to an up or down state or may be time based.

Analysis subsystem allows rule sets to be loaded in source form and compiled at load time into discrimination networks. Each rule set specifies trigger delivered attributes. Upon loading the rule sets analysis subsystem establishes trigger listeners to receive sensor notifications and update respective working memories of rule engines . As illustrated in each of rule engines may serve a different tier defined within the fabric. Alternatively multiple rule engines may serve a single tier or a single rule engine may serve multiple tiers.

Rule engines process the events and invoke action requests via calls to effector subsystem . In addition rule engines provide a call back interface so that effector subsystem can inform a rule engine when an action has completed. Rule engines prevent a particular rule from re firing as long as any action invoked by the rule has not finished. In general rules contain notification calls and service invocations though either may be disabled by configuration of effector subsystem . BLT supplies initial system configuration descriptions to seed each of rule engines .

In general rule engines analyze the events and discover discrepancies between an expected state of the fabric and an actual state. Each of rule engines may be viewed as software that performs logical reasoning using knowledge encoded in high level condition action rules. Each of rule engines applies automated reasoning that works forward from preconditions to goals defined by system administrator . For example rule engines may apply modus ponens inferences rules.

Rule engines output requests to effector subsystem which produce actions requests for BLT to resolve the discrepancies. Effector subsystem performs all operations on behalf of analysis subsystem . For example event generator task invocation module and logger of effector subsystem perform event generation BLT action invocation and rule logging respectively. More specifically task invocation module invokes asynchronous operations within BLT . In response BLT creates a new thread of control for each task which is tracked by a unique task identifier task id . Rules engine uses the task id to determine when a task completes and if needed to re fire any rules that were pended until completion of the task. These tasks may take arbitrary amounts of time and rules engine tracks the progress of individual task via change notifications produced by BLT .

Event generator creates persistent event records of the state of processing of SLAI and stores the event records within a database. Clients uses these event records to track progress and determine the current state of the SLAI .

Logger generates detailed trace information about system activities for use in rule development and debugging. The logging level can be raised or lowered as needed without changing operation of SLAI .

In addition working memory includes a second data region that is modifiable i.e. read write and may be updated by monitoring subsystem or used internally by rule engines . In general data region stores aggregated data representing the actual state of the fabric and can be updated by sensor subsystem or by rule engines . The actual state may consist of a set of property annotations that can be attached to objects received from BLT or to objects locally defined within a rule engine such as local object .

As described BLT provides the facilities necessary to create and administer the organizational model e.g. fabric domains tiers and nodes implemented by distributed computing system . In general BLT abstracts access to the persisted configuration state of the fabric and controls the interactions with interfaces to fabric hardware services. As such BLT provides fabric management capabilities such as the ability to create a tier and replace a failed node. WSDL interfaces provide web service interfaces to the functionality of BLT that may be invoked by web service clients . Many of WSDL interfaces offered by BLT allow administrator to define goals such as specifying a goal of the expected state of the fabric. As further described below rule engines within SLAI in turn invoke task manger to initiate one or more BLT tasks to achieve the specified goal. In general web service clients may be presentation layer applications command line applications or other clients.

BLT abstracts all interaction with physical hardware for web service clients . BLT is an enabling component for autonomic management behavior but does not respond to real time events that either prevent a goal from being achieved or produce a set of deviations between the expected state and the actual state of the system. In contrast BLT originates goals for autonomic reactions to changing configuration and state. SLAI analyzes and acts upon these goals along with real time state changes. BLT sets the goals to which SLAI strives to achieve and provides functionality used by the SLAI in order to achieve the goals.

In general BLT does not dictate the steps taken in pursuit of a goal since these are likely to change based on the current state of distributed computing system and changes to configurable policy. SLAI makes these decisions based on the configured rule sets for the fabric and by evaluating monitoring data received from monitoring subsystem .

Fabric administration service implements a set of methods for managing all aspects of the fabric. Example methods include methods for adding viewing updating and removing domains tiers nodes notifications assets applications software images connectors and monitors. Other example methods include controlling power at a node and cloning capturing importing exporting or upgrading software images. Rule engines of SLAI may for example invoke these methods by issuing action requests .

Task manager receives action requests via task interface . In general task interface provides an interface for receiving action requests from SLAI or other internal subsystem. In response task manager manages asynchronous and long running actions and are invoked by SLAI to satisfy a goal or perform an action requested by a client.

Task manager generates task data that represents identification and status for each task. Task manager returns a task identifier to the calling web service clients or the internal subsystem e.g. SLAI that initiated the task. Rule engines and web service clients use the task identifiers to track progress and retrieve output results and errors associated with achieving the goal.

In one embodiment there are no WSDL interfaces for initiating specific tasks. Rather administrator interacts with BLT though goal interfaces presented by WSDL interfaces to define the goals for the fabric. In contrast the term task is used to refer to internal system constructs that require no user interaction. Tasks are distinct low level units of work that affect the state of the fabric. SLAI may combine tasks to achieve or maintain a goal state.

For example administrator can request configuration changes by either adding new goals to an object or by modifying the attributes on existing goals. Scheduled goals apply a configuration at a designated time. For example the goals for a particular tier may specify the minimum maximum and target node counts for that tier. As a result the tier can increase or decrease current node capacity by scheduling goals with different configuration values.

This may be useful for example in scheduling a software image upgrade. As another example entire domains may transition online and offline per a defined grid schedule. Administrator may mix and match goals on a component to achieve configurations specific to the application and environment. For example a tier that does not support autonomic node replacement would not be configured with a harvesting goal.

In some embodiments goals are either in force or out of force. SLAI only works to achieve and maintain those goals that are currently in force. SLAI may applies a concept of gravity as the goals transition from in force to out of force. For example SLAI may transition a tier offline when an online goal is marked out of force. Some goal types may have prerequisite goals. For example an image upgrade goal may require as a prerequisite that a tier be transitioned to offline before the image upgrade can be performed. In other embodiments goals are always in force until modified.

SLAI may automatically formulate dependencies between goals or may allow a user to specify the dependencies. For example a user may request that a newly created tier come online. As a result of this goal SLAI may automatically direct task manager to generate a task of harvesting a target number of nodes to enable the tier. Generally all goals remain in force by SLAI until modified by BLT . In one embodiment each goal remains in force in one of three states Satisfied Warning or Critical depending on how successful SLAI was in achieving the goal at the time the event record was generated and stored.

In this manner SLAI controls the life cycle of a goal i.e. the creation scheduling update deletion of the goal and provides a common implementation of these and other services such as timeout event writing goal conflicts management of intra goal dependencies and tracking tasks to achieving the goals.

Progress toward a goal is tracked though event subsystem . In particular event subsystem tracks the progress of each in force goal based on the goal identifiers. Tasks executed to achieve a particular goal produce events to communicate result or errors. The events provide a convenient time based view of all actions and behaviors.

Examples of goal types that may be defined by administrator include software image management goals node allocation goals harvest goals tier capacity goals asset requirement goals tier online offline goals and data gathering goals.

In one embodiment BLT presents a task interface to SLAI for the creation and management of specific tasks in order to achieve the currently in force goals. In particular rule engines invoke the task interface based on evaluation of the defined rule sets in view of the expected state and actual state for the fabric. Example task interfaces include interfaces to reserve node resources query resources for a node slot associate or disassociate an image with a node in a tier node slot allocate de allocate startup or shutdown a node move a node to a tier apply remove or cycle power of a node create a golden image create or delete an image instance and delete an activity node or tier.

Report generator provides an extensible mechanism for generating reports . Typical reports include image utilization reports that contain information with respect to the number of nodes running each software image inventory reports detailing both the logical and physical aspects of the fabric and system event reports showing all events that have occurred within the fabric. Report generator gathers localizes formats and displays data into report form for presentation to the user. Report generator may include one or more data gathering modules not shown that gather events in accordance with a schedule and update an events table to record the events. The data gathering modules may write the events in XML format.

Rule compiler compiles each of rules and translates match conditions of the rules into a discrimination network that avoids redundant tests during rule execution. Execution engine handles rule administration object insertion and retrieval rule invocation and execution of rule actions. In general execution engine first matches a current set of rules against a current state of working memory and local objects . Execution engine then collects all rules that match as well as the matched objects and selects a particular rule instantiation to fire. Next execution engine fires executes the instantiated rule and propagates any changes to working memory . Execution engine repeats the process until no more matching rule instantiations can be found.

Firing of a rule typically produces a very small number of changes to working memory . This allows sophisticated rule engines to scale by retaining match state between cycles. Only the rules and rule instantiations affected by changes get updated thereby avoiding the bulk of the matching process. One exemplary algorithm that may be used by execution engine to handle the matching process includes the RETE algorithm that creates a decision tree that combines the patterns in all the rules and is intended to improve the speed of forward chained rule system by limiting the effort required to re compute a conflict set after a rule is fired. One example of a RETE algorithm is described in Forgy C. L. 1982 RETE a fast algorithm for the many pattern many object pattern match problem . Artificial Intelligence 19 1737 hereby incorporated by reference. Other alternatives include the TREAT algorithms and LEAPS algorithm as described by Miranker D. P. TREAT A New and Efficient Match Algorithm for AI Production Systems . ISBN 0934613710 Daniel P. Miranker David A. Brant Bernie Lofaso David Gadbois On the Performance of Lazy Matching in Production Systems. AAAI 1990 685692 each of which is hereby incorporated by reference.

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

