---

title: Serialization of file system item(s) and associated entity(ies)
abstract: A system and method for serialization and/or de-serialization of file system item(s) and associated entity(ies)is provided. A file system “item” comprises a core class which can include property(ies). Through serialization, a consistent copy of the item and associated entity(ies), such as fragment(s), link(s) with other item(s) and/or extension(s),if any, can be captured. The serialization system includes an identification component that identities entity(ies) associated with an item and a serialization component that serializes the item and associated entity(ies). The serialization component can further serialize a header that includes information associated with the item and associated entity(ies). The header can facilitate random access to the item and associated entity(ies). The serialization system can expose application program interface(s) (API's) that facilitate the copying, moving and/or transfer of an item and its associated entity(ies) from one location to another location.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07676481&OS=07676481&RS=07676481
owner: Microsoft Corporation
number: 07676481
owner_city: Redmond
owner_country: US
publication_date: 20050503
---
This application claims the benefit of U.S. Provisional Application Ser. No. 60 656 118 filed on Feb. 24 2005 and entitled SERIALIZATION OF FILE SYSTEM ITEM S AND ASSOCIATED ENTITY IES the entirety of which is incorporated herein by reference.

The subject invention relates generally to object storage system s and more particularly to serialization and or de serialization of item s and associated entity ies .

Traditionally in a computer file system a file is the basic unit of data storage. Typically a file in a file system has the following characteristics. It is a single sequence of bytes. It has a finite length and is stored typically in a non volatile storage medium. It is created in a directory and has a name that it can be referred to by in file operations possibly in combination with its path. Additionally a file system may associate other information with a file such as permission bits or other file attributes timestamps for file creation last revision and last access etc. Specific applications can also store domain specific properties in the byte stream of the file. For example files that are used by a word processing application and hence considered as documents may store properties like the Title and Author of the document. These properties are stored within the byte stream of the file in a format that is specific to the application creating the file. The properties are not structured as objects nor do they have standardized names. The byte streams are unstructured values.

Additionally conventional computer file systems have provided limited file organization techniques available to users. For example existing applications have largely adopted a tree structure folder format for organizing and displaying various types of files. Though some relationships between folders subfolders and files can be viewed such relationships are limited in scope and are primarily dependent upon explicit user input. For example files can be related according to their common folder or subfolder as denoted by the user.

The following presents a simplified summary of the subject invention in order to provide a basic understanding of some aspects of the subject invention. This summary is not an extensive overview of the subject invention. It is not intended to identify key critical elements of the subject invention or to delineate the scope of the subject invention. Its sole purpose is to present some concepts of the subject invention in a simplified form as a prelude to the more detailed description that is presented later.

The subject invention provides for serialization and or de serialization of file system item s and associated entity ies . A file system item comprises a core class for example a contact which can include property ies . An item can be simple or compound e.g. includes other item s embedded in it . Associated with an item can be entity ies such as fragment s link s with other item s and or extension s . Through serialization a consistent copy of the item and associated entity ies if any can be captured e.g. for transporting of the item and to reconstruct the item on a destination system .

In accordance with an aspect of the subject invention a serialization system is provided. The serialization system includes an identification component that identities entity ies associated with an item a serialization component that serializes the item and associated entity ies . The serialization component can further serialize a header that includes information associated with the item and associated entity ies . The header can facilitate random access to the item and associated entity ies e.g. allowing a reader to interpret parse only the parts in which it is interested . Optionally the serialization system can expose application program interface s API s that facilitate the copying moving and or transfer of an item and its associated entity ies from one location to another location e.g. separate computer system and or removable media .

Another aspect of the subject invention provides for an item de serialization system which can be employed to de serialize an item and it s associated entity ies . The de serialization system can employ a header to gain random access to the item and associated entity ies e.g. can interpret parse only the parts in which it is interested . The de serialization system can re create the item structure in a file system store.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the subject invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the subject invention may be employed and the subject invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the subject invention may become apparent from the following detailed description of the subject invention when considered in conjunction with the drawings.

The subject invention is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the subject invention. It may be evident however that the subject invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the subject invention.

As used in this application the terms component handler model system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal . Computer components can be stored for example on computer readable media including but not limited to an ASIC application specific integrated circuit CD compact disc DVD digital video disk ROM read only memory floppy disk hard disk EEPROM electrically erasable programmable read only memory and memory stick in accordance with the subject invention.

The subject invention provides for serialization and or de serialization of file system item s and associated entity ies . As used in this application a file system item comprises a core class for example a contact which can include property ies e.g. name address telephone number . An item can be simple or compound e.g. includes other item s embedded in it . Associated with an item can be entity ies such as item fragment s link s with other item s e.g. relationship s and or extension s e.g. additional property ies .

Referring to a serialization system in accordance with an aspect of the subject invention is illustrated. The system can be employed to serialize an item e.g. core item and entity ies associated with the item. The system can further generate and serialize a header that includes information associated with the item and associated entity ies .

The serialization system includes an identification component that identities entity ies associated with an item. The identification component can obtain information regarding the item from a file system store . As discussed below the information can include for example item fragment s extension s outgoing link s incoming link s and or embedded item s .

The serialization system further includes a serialization component that serializes the item and associated entity ies . The serialization component can further generate and serialize a header that includes information associated with the item and associated entity ies . The header can facilitate random access to the item and associated entity ies e.g. allowing a reader to interpret parse only the parts in which it is interested .

Referring briefly to an exemplary item structure diagram in accordance with an aspect of the subject invention is illustrated. In this example a core item can include property ies . For example a core item can be a contact with properties of name and home telephone number .

The core item can have extension s added by particular application s to extend the core item with extra property ies . Continuing with the contact core item example an e mail application can extend the property ies of the core item by adding extension properties e mail address and business telephone number .

Next the core item can be linked to zero one or more other item s . The link can be an outgoing link s and or an incoming link s . Outgoing link s refer to a coupling between the core item and the other item s with the core item as the source. Incoming link s refer to a coupling between the core item and the item s with other item s as the source. Outgoing link s and or incoming link s can be typed. Links thus provide relational power for coupling of items. For example a link can be of type friend which has associated properties of date of friendship and rating . Additionally links can uniquely identify e.g. using a globally unique identifier a coupling between items.

The core item can further include embedded item s sometimes referred to collectively herein as a compound item. For example a core item of type contact can include an embedded item comprising an image e.g. photograph . In accordance with an aspect of the subject invention a compound item can be viewed as a single unit of consistency by item level operations e.g. backup restore copy and or export .

The core item can have fragment s which are entity types that enable declaration of large collections in items types and item extensions. The elements of the collection are entities that have keys. This enables applications to access and modify elements in the collection independently of the owning item. The owning item does not have to be retrieved in order for the collection to be modified. Additionally the system can track changes of each element in the nested extent.

A core item can be backed up by a file or may have FileStream properties. A file backed item is an item where a part of the item is promoted out of a backing file .

The extension s outgoing link s information associated with incoming link s e.g. link identifier s embedded item s fragment s and or backing file can be collectively referred to as associated entity ies of the core item . When a request to serialize a core item is received the core item and associated entity ies if any are copied in order to preserve the structural integrity of the core item . By including the associated entity ies a system not shown receiving the serialization stream can re constitute the core item and associated entity ies in their appropriate context.

The diagram illustrates elements of an exemplary item structure which can be employed with the serialization system . Those skilled in the art will recognize that the subject invention is not limited to the item structure set forth in . Any suitable item structure for carrying out the subject invention can be employed and all such item structures are intended to fall within the scope of the hereto appended claims.

Referring to the system can be employed to serialize e.g. for transport to another computer system a core item and associated entity ies of the core item e.g. extension s outgoing link s information associated with incoming link s e.g. link identifier s embedded item s and or fragment s . The identification component identifies the core item within the file system store and provides identification information to the serialization component . The identification component further identifies entity ies associated with the core item and provides identification information related to the associated entity ies to the serialization component .

The serialization component can allocate space e.g. temporarily for a header which is populated during serialization. In this example the serialization component performs the following 

Turning to an exemplary serialization structure in accordance with an aspect of the subject invention is illustrated. The structure can be generated for example by the serialization component for example 

The class set forth in Table 2 is used to support the metadata that is employed to interpret the binary serialization of the user defined type UDT .

Finally the structure can include a header section . The header section can include information associated with the core item and associated entity ies . The header section can facilitate random access to the core item and associated entity ies e.g. allowing a reader to interpret parse only the parts in which it is interested .

Turning next to a serialization system in accordance with an aspect of the subject invention is illustrated. The serialization system includes an identification component and a serialization component as discussed above. The system further includes application program interface s APIs . The APIs facilitate communication between the system and application s . For example the APIs can facilitate copying moving and or transfer of an item and its associated entity ies from one location to another location e.g. separate computer system and or removable media . Thus the APIs can be employed for item level operations such as Export Backup Restore Copy etc. In one example the application can selectively include all or part s of an item by providing serialization information e.g. flag s to the API . The APIs can be exposed at the file system level and or at the store procedure level. Exemplary APIs are discussed below 

The serialize item API generates an item serialization that includes the following components if they exist 

In case an item is quite large it can be inefficient to serialize the item in memory and return the serialization to the client application. For such scenarios a serialize item to file API can be employed that writes the serialization directly to the file specified by the application. This can limit the memory consumed by the serialization at both the client application and the server side. Additionally the API can lead to better performance because much smaller number of bytes need to be sent from the server to the client application. For example a call to the serialize item to file can be of the form 

The options value allows the serialize function to satisfy the requirement of various customer scenarios. These options can be used to select the data metadata elements related to the item that should be included as a part of the serialization. These options can affect the content of the serialization.

In this example and combinations are not permitted. In order to achieve the above the options must be specified using explicit or combination of individual options as follows 

Turning to a serialization environment in accordance with an aspect of the subject invention is illustrated. Application s provide information associated with an item to be serialized for example an ItemID to the serialization system . Thereafter the serialization system obtains type information regarding the ItemID from a file store system metadata . Employing the ItemID and the type information the serialization component query ies e.g. recursively the file system views for information associated with the item e.g. the item and associated entity ies to be serialized as discussed previously.

In one example the serialization component does not support random access for item fragments. In this example the item fragment can be sequentially accessed e.g. in a linked list fashion using the starting offset from the header and the length field preceding each fragment.

When the INCLUDE EMBEDDED option is chosen the system recursively walks through the items in the compound item and serializes them. For example the system can perform multiple queries to walk the recursive structure and serialize each item. The resulting serialization has a recursive structure where embedded item serializations are included in their parent s serialization.

In one example each item in a compound item can have a different security descriptor. Thus it is possible that the caller of the serialize API does not have access to all the items in a compound item. In this example in the situation in which the user does not have access to all the items items to which the caller does not have access are not serialized.

In this example the backing file may either be inline into the serialization or copied separately by the caller e.g. based upon serialize option s .

When the application has requested file back item s to be included in the serialization the backing file can be read from the file storage system . In addition to the file attribute s creation last access and or modification times can also be included in the serialization header. For example this information can be employed when the item is being serialized for backup e.g. where it is required to restore time stamps to their original value upon de serialization .

In this situation the application has not requested file back item s to be included in the serialization for example by not setting the INLINE BACKING FILE option while calling the serialize API. In this example the serialize API can embed the file name in the header instead of including the contents of the file in the serialization. Accordingly the application can read this file name and can handle the contents of the backing file using the file storage system API directly. However in this case as well the file attributes and the creation last access and modification timestamps can be captured in the serialization header For example this information can be when the item is being serialized for backup e.g. where it is required to restore time stamps to their original value upon de serialization .

In this example the schema metadata is captured along with each entity serialization as it contains typeld s that can be unique to the file system store . The typeld to assembly name and version mapping is the schema metadata that is required to de serialize a user defined type serialization. For example there can be schema metadata associated with each entity e.g. item link extension and or fragment and it can be included with the respective entity serialization.

In order to obtain this information the serialization system can query the system metadata to obtain a fully qualified type name. For example GetNameFromTypeld returns the fully qualified type name given a Typeld as a table with exactly one row of two columns containing the SchemaName and TypeName respectively. The Typeld from the respective item link extensionlfragment table of the file system store can be employed as a input to the function to obtain the schemaname and the type name. This can further be joined with the sys.assemblies table to get the fully qualified type name. Generally the Typelds are not unique across file system store s e.g. databases however the fully qualified type names are unique. For in store copies e.g. where the type ids are the same at source and target the schema metadata can be excluded.

As discussed previously each item can have a security descriptor associated with it identifying user s can access the item and or user s that cannot access them. Continuing with the example discussed with respect to exemplary trust boundaries are identified. In this example the environment can rely upon file system authorization to ensure that the user has permission to connect to the file system store . The caller of the particular serialize or de serialize API generally has established a connection with the file system store before calling the API.

Turning next to a de serialization system in accordance with an aspect of the subject invention is illustrated. The system can be employed to de serialize an item and it s associated entity ies for example generated by the system and or system . The system can employ a header to gain random access to the item and associated entity ies e.g. can interpret parse only the parts in which it is interested .

The system can expose application program interface s API s that facilitate the de serialization of the item and it s associated entity ies . The APIs can provide the serialized item to a de serialization component for example received from application s . The de serialization component re creates the item structure and stores it in a file system store .

After receiving a request to de serialize an item from an application the API provides the serialized item to the de serialization component the de serialization component can use the header offset as described above to read the header e.g. into memory and employ the header through the de serialize process. In one example the de serialize component can then 

In one example during de serialization the system ensures that all the relationships of the items that existed in the serialization continue to exist once the items are de serialized. Furthermore since incoming link information is serialized serialization will also fix up the incoming links to the items that were de serialized. This is to ensure that what was serialized is the same e.g. exactly after it is de serialized.

For example the scope of the fix up work can be all the items in a given copy operation. As discussed below a user of the serialization API can create a batch scope by invoking two helper APIs BeginDeserializationBatch EndDeserializationBatch. Any items de serialized inside of this scope will have their links fixed up to other items in this scope. For example a temporary table can be employed to keep track of the IDs for the relationships of the items as they are de serialized. This temporary table then maps the old IDs to the new IDs and serialization then fixes target IDs and source IDs of links. In this example links within the batch and containment relationships can be fixed.

This can be implemented for example as an extra flag for DeserializeItem. However one example the consumer of the Serialization APIs is required to explicitly state the beginning and end of the batch.

The APIs facilitate communication between the system and application s . For example the APIs can facilitate de serialization of a serialized item. The APIs can be exposed at the file system level and or at the store procedure level. Exemplary APIs are discussed below 

The De serialize Item API de serializes an item and places it in a container with the id specified as the containerid. If both the namespace name and the container id are passed as null then their values are taken from the serialization. The stored procedure de serializes the item in the same container that the item was when it was serialized. For example this can be desired in scenarios such as copying an entire tree e.g. folders and sub folders from source to destination while retaining the item ids. In this example the container id cannot be passed as null if the serialization does not include the item ids e.g. doing so will result in an error . For example 

This API de serializes and overwrites an existing item in the store with the contents of the given serialization. In this example when overwriting a file backed item the backing file is truncated. If the serialization does not have the file inline then this operation results in a backing file of zero length.

Further in this example this API can only be used when restoring the same item to a state in the past. For example 

This API can be provided to allow de serializing of large items from a file e.g. produced by the system and or the system . For example the file can be produced by the SerializeItemToFile API discussed above and or by invocation of the SerializeItem API discussed above with subsequent writing of the item serialization to the file. In this example if both the namespace name and the container id are passed as null then their values are taken from the serialization. For example 

The Deserialize with Overwriting existing item from file API overwrites an existing item in the file system store with the contents of the given item serialization contained in the file specified e.g. created by SerializeltemToFile API discussed above and or by invocation of SerializeItem API with the item serialization subsequently written to the file . In this example when overwriting a file backed item the backing file is truncated. If the serialization does not have the file inline then this operation results in a backing file of zero length.

In this example DeserializeItemReplaceFromFile can only be used when restoring the same item to a state in the past. For example 

These helper functions can be used in conjunction with each other and the Link Fix Up deserialization option discussed below . Calling BeginDeserializationBatch starts a deserialization batch scope. In this example all items serialized in this scope will have all their links corrected so that they will continue to work. After all items have been deserialized EndDeserializationBatch is then called to end the scope and clean up the temporary table used by this operation.

For example ItemA links to ItemB that links to ItemC. Further these items are being deserialized to a new store. In this example the client application makes the following calls 

Even though the items have been recreated in this new store and have new ItemIDs they can be correctly linked together because of a fix up flag.

Reconstruction of user defined type s UDTs by the de serialization component can be performed 1 to verify whether the serialization is a valid serialization and 2 to verify that the types required for de serializing the item are present in the system and or 3 to trigger validation constraint s . In this example reconstruction of UDTs from the serialization is performed prior to de serialization of the core item.

Referring next to a de serialization environment in accordance with an aspect of the subject invention is illustrated. The environment includes a de serialization system which interfaces with a file system store via a base update API . An exemplary trust boundary is further identified. As discussed above the caller of the particular de serialize API generally has established a connection with the file system store before calling the API.

For example an application can provide an item serialization to the de serialization system . The de serialize system can obtain information regarding user defined types from the system metadata as discussed previously. Through the base update API the de serialization system can attempt to store the de serialized core item and associated entity ies . The base update API can include for example 

The de serialization system can use this base update API to create the de serialized item in the file system store . For example this base update API can be employed when creating an item without overwrite.

This base update API can be employed to set the security descriptor of the Item that was de serialized. For example the following policy can be employed while setting the security descriptor 

The de serialization system can call this base update API to overwrite an existing item with the de serialized item in the file system store . For example this base update API can be employed when creating an item with overwrite.

This base update API can be used to move the item to be replaced so that it has the same container and the same namespace name as it did when it was serialized.

The de serialization system can employ this base update API to de serialize out going link s of the item in the file system store .

The de serialization system can use this base update API to de serialize fragments of the item in the file system store .

This base update API can be employed by the de serialization system to update the target item id of links which are incoming links for the item that was created as discussed below.

Replacing an item during de serialize with its copy in the past can be a common occurrence during a restore. Significantly the item that has been restored could have moved between the time it was serialized e.g. backed up and de serialized e.g. restored . Move is a general operation that refers to one of the following 

In this example when the item is restored the replace operation cannot change the namespace name or the containerid. Therefore to restore the item to its original location MoveItem is used to have the same container and the same namespace name if either of them had changed and then perform the replace.

In this example when DeserializeltemReplace is called on a compound item e.g. replacing compound item with its copy in the past the following occurs 

In one example during a restore operation e.g. when item ids have been retained in the environment the following can be employed to fix the target item ids for the links incoming to the item 

When the file is inline in the serialization in one example the header can carry the following information the item id of the file backed item from which the path to which the file is to be written can be deduced and the portion of the serialization that contains the backing file. This can be employed to write the file files to the designated location using the base update API .

In this example when the file is not inline in the serialization it is the responsibility of the caller to use the base update API to copy the backing file to the target location.

It is to be appreciated that the system the file system store the system the APIs the application s the system the file storage system metadata the system metadata the file system views the environment the APIs the de serialization component the application s the file system store the environment the system metadata and or the base update API can be computer components as that term is defined herein.

Turning briefly to methodologies that may be implemented in accordance with the subject invention are illustrated. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the subject invention is not limited by the order of the blocks as some blocks may in accordance with the subject invention occur in different orders and or concurrently with other blocks from that shown and described herein. Moreover not all illustrated blocks may be required to implement the methodologies in accordance with the subject invention.

The subject invention may be described in the general context of computer executable instructions such as program modules executed by one or more components. Generally program modules include routines programs objects data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Referring to a method facilitating serialization of an item in accordance with an aspect of the subject invention is illustrated. At a request to serialize an item is received e.g. from an application . At memory is allocated for a header. At a core item is serialized.

At item fragment s if any are serialized. Next at outgoing link s if any are serialized. At incoming link s identifiers if any are populated in the header. At extension s if any are serialized. At embedded item s if any are serialized. At a backing file if any is serialized. At a serialization length header offset and header are written to the serialization. At information regarding the serialization is provided to the requester e.g. requesting application . For example the serialization itself can be provided to the requesting application. Alternatively a pointer to the serialization and or a file name of the serialization can be provided to the requesting application.

Next turning to a method facilitating de serialization of an item in accordance with an aspect of the subject invention is illustrated. At a request to de serialize an item is received. At a header offset is used to read a header into memory. At a core item is de serialized. At item fragment s if any are de serialized. At outgoing link s if any are de serialized.

At extension s if any are de serialized. At embedded item s if any are de serialized. At a backing file if any is de serialized. The de serialized item and associated entity can be stored in a file storage system.

In order to provide additional context for various aspects of the subject invention and the following discussion are intended to provide a brief general description of a suitable operating environment in which various aspects of the subject invention may be implemented. While the subject invention is described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices those skilled in the art will recognize that the subject invention can also be implemented in combination with other program modules and or as a combination of hardware and software. Generally however program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular data types. The operating environment is only one example of a suitable operating environment and is not intended to suggest any limitation as to the scope of use or functionality of the subject invention. Other well known computer systems environments and or configurations that may be suitable for use with the subject invention include but are not limited to personal computers hand held or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include the above systems or devices and the like.

With reference to an exemplary environment for implementing various aspects of the subject invention includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to an 8 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable nonremovable volatile nonvolatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the subject invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes examples of the subject invention. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the subject invention but one of ordinary skill in the art may recognize that many further combinations and permutations of the subject invention are possible. Accordingly the subject invention is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

