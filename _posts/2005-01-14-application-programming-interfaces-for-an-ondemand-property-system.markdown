---

title: Application programming interfaces for an on-demand property system
abstract: The application programming interfaces described herein are directed at property management mechanisms that operate within an on-demand property system. The property management mechanisms support the caching of property values on an as needed basis, allow a plurality of object instances to utilize the same property via attached properties, overriding default information associated with a property on a per type basis, obtaining values for a property from an external source, and the like. In addition, the on-demand property system provides validation and control for each property instance. The property management mechanisms minimize the storage requirements and provide flexibility without requiring additional code from the developers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07562095&OS=07562095&RS=07562095
owner: Microsoft Corporation
number: 07562095
owner_city: Redmond
owner_country: US
publication_date: 20050114
---
This application is a Continuation of prior application Ser. No. 10 939 296 filed Sep. 11 2004 which is a Continuation in Part of prior applications Ser. No. 10 187 012 filed Jun. 28 2002 and Ser. No. 10 186 985 filed Jun. 28 2002 which are both hereby expressly incorporated by reference for all purposes.

This document generally relates to mechanisms for handling properties of objects and more particularly to mechanisms for managing properties and their associated values in an on demand property system.

Today most applications are written using objects. These objects may be supplied by third parties or may be developed specifically for an application. By using objects code may be easily reused and incorporated into many different applications without modification. In addition if modifications are necessary a new object may be created that inherits the functionality of the object. Then new specific functionality may be added to the new object as needed. This ability to reuse and modify existing objects reduces the development time for new applications sometimes as much as from months to weeks.

However even though the use of objects has become very commonplace and is beneficial the current approach for handling properties in these objects has several drawbacks. For example if a first property in an object is dependent on a second property in another object a developer must write code that monitors i.e. listens to the second property and upon change change the first property. One simplified portion of code that performs these functions is as follows 

As shown this callback function returns a value for the second property i.e. BackgroundColor whenever the first property e.g. Button1 Pressed changes. Therefore each time the first property state changes a value e.g. Red or Grey is computed and stored in the second property during the callback. This technique requires storage in the object for the second property. The storage is used to keep a current state for the second property.

Because developers may develop these objects in isolation circularities between some of the properties within different objects may occur. For example continuing with the above example a callback function for the backgroundColor property may be added that changes the state of the Button1 Pressed property. While having a callback function that changes the state of a button pressed property due to a change in backgroundColor is not very realistic and would not typically occur in an application it helps illustrate the problem that occurs when two properties change each other s state. In actual applications typically two parameter would not change each other s state directly but other dependent properties would cause the circularity illustrated by this simplistic example. Therefore given the example above at runtime once one of these two properties changes state both will continue to change states indefinitely. This circularity problem must then be identified and corrected before proper operation can occur. Unfortunately it is very difficult to test every combination of property changes. Therefore some of these circularity problems may not surface until after a software product has been released.

The invention is directed at property management mechanisms described herein operate within an on demand property system. The property management mechanisms support the caching of property values on an as needed basis allow a plurality of object instances to utilize the same property via attached properties overriding default information associated with a property on a per type basis obtaining values for a property from an external source and the like. In addition the on demand property system provides validation and control for each property instance. The property management mechanisms minimize the storage requirements and provide flexibility without requiring additional code from the developers.

Briefly the present property management mechanisms operate within an on demand property system. The property management mechanisms support the caching of property values on an as needed basis allow a plurality of object instances to utilize the same property via attached properties overriding default information associated with a property on a per type basis obtaining values for a property from an external source and the like. In addition the on demand property system provides validation and control for each property instance. The property management mechanisms minimize the storage requirements and provide flexibility without requiring additional code from the developers. These and other advantages will become clear after a careful reading of the following detailed description.

The following detailed description is divided into several sections. A first section describes an illustrative computing system in which the present property management mechanisms may operate. A second section describes an exemplary implementation of the property management mechanism within an on demand property system. A third section describes the property management mechanisms within the on demand property system. A fourth section describes a generalized operation of the property management mechanisms.

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Thus computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well know in the art and need not be discussed at length here.

Computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. Communication connection s is one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Computer readable media can be any available media that can be accessed by a computer. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

Various modules and techniques may be described herein in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. for performing particular tasks or implement particular abstract data types. These program modules and the like may be executed as native code or may be downloaded and executed such as in a virtual machine or other just in time compilation execution environment. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media.

The on demand property system includes an on demand property engine metadata and a property value cache . Briefly metadata includes information about any state that is associated with an attached property also referred to as a dependency property. In overview an attached property refers to a property that may be shared with multiple instances of objects. At a conceptual level attached properties may be compared to global variables that are used with traditional programming techniques. However as will be described attached properties are much more flexible and provide much more control over the property than global variables can provide. The mechanisms for attaching a property will be described in greater detail below. As will be described attached properties are identified via a DependencyProperty and are read and written using GetValue and SetValue accessors. By attaching properties one class may access properties of another class and store data on the properties for its own reference.

One implementation for which attached properties is very desirable is in user interface design and layout design. The layout design objects may attach some of the user interface properties in order to better determine the layout and vice versa.

Metadata may include a DataBindable indicator an Inheritable indicator a default value and the like for each attached property. The property value cache represents a generic data structure in which identifiers e.g. identifier for the attached properties and their associated local values e.g. value are stored. In one embodiment the property value cache may be a hash table.

The on demand property system may optionally provide client storage for attached properties and their associated values. In certain situations a client may want to supply their own local storage for properties. As will be described below the property management mechanisms allow an external party to store and return local values from their own local storage.

The on demand property engine manages the metadata the property value cache i.e. dependency properties and their values and the optional client storage . In overview the goal of the on demand property engine is to perform work when necessary without performing work that is not necessary. This is in direct contrast with how traditional programming techniques maintained property values. For example using traditional techniques each property on every instance of every object is considered important. Therefore validation and updating of every property is performed even though some of the properties may never be retrieved. Thus there is a lot of unnecessary processing performed to manage the properties using traditional programming techniques. However using the current on demand property engine the important properties are those that are queried for a particular instance. Thus the on demand property engine performs work as needed i.e. on demand for those properties that are queried.

In order to provide this on demand work the on demand property engine provides a DependencyObject class functionality a DependencyProperty class functionality a PropertyMetadata class functionality an Expression class functionality and a DependencySource class functionality .

In overview the DependencyObject class functionality illustrated in and described later in conjunction therewith provides attached property support provides property invalidation notification services provides dependency based property value evaluations and the like. In overview the DependencyProperty class functionality illustrated in and described later in conjunction therewith provides a property management mechanism for associating a dependency property with one or more objects and for specifying metadata for the dependency properties. Thus the DependencyObject class is the base class for any class whose instances desire the ability for DependencyProperties to be applied on them. In one embodiment any object may register a DependencyProperty. The DependencyProperty may be any property even a native property. Further any DependencyProperty registered by any object may be applied to any subclass of DependencyObject. Therefore DependencyProperties are useful to attach a property on any DependencyObject to set value expressions like databinding to a property to receive notifications of property invalidations to determine inheritance and the like. Each of these will be described in more detail below.

In overview the PropertyMetadata class functionality illustrated in and described later in conjunction therewith defines an attached property s behavior and metadata. As will be shown a subclass of a DependencyObject may set the metadata for a particular DependencyProperty which determines the behavior of that DependencyProperty for that type. Therefore different types may define different metadata for a particular DependencyProperty. For example RepeatButtons may want to define their own default style which is different from the default style for a Button. Therefore if Button defines a metadata for its own type and RepeatButton overrides metadata RepeatButton still inherits metadata from the button but any new information provided will override the corresponding old information.

In overview the Expression class functionality illustrated in and described later in conjunction therewith allow an expression to be associated with a value of a property for an instance of a DependencyObject. Expressions define relationships between properties. For example the value of the property may be defined as an expression which has logic for computing the value for that property. However because the logic may utilize a target that is outside the knowledge of the on demand property system the DependencySource class functionality illustrated in and described later in conjunction therewith is utilized with the Expression class functionality to inform the on demand property system of the dependency of the DependencyProperty on the target DependencyProperty. The Expression class functionality minimizes the logic that different frameworks need to implement in order to provide invalidations and expressions.

In operation software developer s code may include several instances of objects e.g. objects . One or more of these objects may subclass functionality provided by the on demand property engine . The developer s code is parsed or compiled depending on the form of the developer s code. The parsing or compilation may be performed using a JIT compiler and the like. The result of parsing compilation is executable code that may be processed using the on demand property system in conjunction with other components of an operating system. As one skilled in the art will appreciate the steps for obtaining the executable code is well known to those skilled in the art and modifications to the steps do not necessarily affect the operation of the on demand property system as long as the functionality provided by the on demand property engine has been successfully specified within the developer s code prior to generation of the executable code . Each of the functionalities for performing property management is now described in detail.

The DependencyObject class includes a GetValue method that takes a DependencyProperty as a parameter and returns an object. The GetValue method is a public method that gets the value for the specified DependencyProperty. The GetValue method may call GetValueOverride explained later in conjunction with to obtain the value. Thus the value may be obtained in various ways which may or may not include obtaining the value from the local value.

The DependencyObject class also includes a ReadLocalValue method that takes a DependencyProperty as a parameter and returns an object. The ReadLocalValue method is a public method that reads the local value of the specified DependencyProperty. As will be described later a local value may not always be available. In these circumstances the property engine attempts to utilize a default value and if a default value is not specified the property engine may return null .

The DependencyObject class also includes a GetValueBase method that takes a DependencyProperty as a parameter and returns an object. The GetValueBase method is a protected method that may be used by other methods within the DependencyObject class. GetValueBase method may be called to compute a new value of an attached property. However in contrast with GetValue GetValueBase does not call the GetLocalValueOverride method.

The DependencyObject class also includes a GetValueCore virtual method that takes a DependencyProperty and a PropertyMetadata as parameters and returns an object. Again the GetValueCore method is a protected method. Subclasses of DependencyObject may override this method in order to provide their own process for getting a value. For example the subclass may override the method in order to reference a value of a property in a style instead of getting the value from the local store.

The DependencyObject class also includes a SetValue method that takes a DependencyProperty and an object as parameters and returns void. The SetValue method is a public method that sets the value of the specified DependencyProperty to the specified object. Typically a call to set simply calls SetValue.

The DependencyObject class also includes a ClearValue method that takes a DependencyProperty and returns void. The ClearValue method is a public method that clears the local value for the specified DependencyProperty.

The DependencyObject class also includes a InvalidateProperty method that takes a DependencyProperty and returns void. The InvalidateProperty method is a public method that is called to invalidate the specified DependencyProperty on a DependencyObject. This invalidation of the specified DependencyProperty is performed whenever there has been some indication that the DependencyProperty may have changed. Therefore in certain circumstances the invalidation may occur without a change occurring on the specified DependencyProperty.

The DependencyObject class also includes an OnPropertyInvalidated callback that takes a DependencyObject and returns void. The OnPropertyInvalidate callback is a protected method. A subclass of a DependencyObject may override the OnPropertyInvalidated callback in order to perform unique processing for when the DependencyProperty get invalidated. In addition a subclass may provide ValueChanged notifications that alert users of changes in the property value. In one embodiment an event within the OnPropertylnvalidated callback is provided to implement these ValueChanged notifications.

The DependencyObject class also includes a DependencyObjectType property . The value for the DependencyObjectType is specified during registration of the DependencyObject.

The DependencyObject class may also include a GetLocalValueEnumerator method . The GetLocalValueEnumerator method is a public method that returns a LocalValueEnumerator. The LocalValueEnumerator allows the enumeration over the local property values of the DependencyObject.

The DependencyProperty class includes a first Register method that takes a string name a property type and ownerType as parameters and returns a DependencyProperty. The name identifies the specified property. The property type allows SetValue method to be validated if available. The ownerType refers to the type of object which registered the specified property. The first Register method is a public method that obtains the information necessary for storing the information in the property value cache. The first Register method may be used by any type registering a property for the first time. It is important to note that the DependencyProperty may only be registered once with the same set of parameters. However the DependencyProperty that is registered with the Dependency System may be used on any DependencyObject or its derived types.

The DependencyProperty class also includes a second Register method that is similar to first Register method except that metadata is also provided as an argument. Upon registering the specified DependencyProperty the supplied metadata becomes associated with the specified DependencyProperty. It is not desirable to provide type specific metadata in the register call because the defaultMetadata in the register call is applicable when the property is used on any type. If a default value for an attached property is not defined in the default metadata or defined in the Type metadata the property engine will return the following 

The DependencyProperty class also includes an AddOwner method that takes a Type as a parameter and returns a DependencyProperty. The AddOwner method is a public method that attaches the DependencyProperty to the calling Type.

The DependencyProperty class also includes an OverrideMetadata method that takes a Type and a PropertyMetadata as parameters and returns void. The overrideMetadata method is a public method that allows metadata associated with DependencyProperty to be overwritten. For example the metadata of a base type may be modified as follows 

The DependencyProperty class also includes two GetMetadata methods and . One takes a Type as a parameter and the other takes a DependencyObect as the type. The GetMetadata methods are public.

The DependencyProperty class also includes several properties such as a string Name that identifies the DependencyProperty an OwnerType that uniquely identifies the framework a GlobalIndex property that provides a zero based globally unique index of the property and a PropertyType that identifies the type of object registering the DependencyProperty.

DependencyProperty class also includes an IsValidType property that is used to determine if a given value is appropriate for the type of the property.

The PropertyMetadata class includes a first constructor that takes an object as a defaultValue. The defaultValue then becomes associated with the designated DependencyProperty. The PropertyMetadata class also includes a second constructor that in addition to the defaultValue takes a Boolean ReadOnly parameter .

The Property Metadata class also includes a third constructor that takes a property invalidated call back. The property invalidated call back is called when the DependencyProperty is invalidated. The property Metadata class also includes a fourth constructor which in addition to the property invalidated call back takes a GetValueOverride callback as a parameter.

The Property Metadata class also includes a DefaultValue property a ReadOnly property and an IsSealed property . The DefaultValue property supplying a value for the DependencyProperty in the case where no other value is available. The ReadOnly property providing a means for disabling the operation of the SetValue method thereby making the DependencyProperty read only.

The Expression class includes an array of DependencySource properties . The dependency sources represent the source for the data. Therefore the expression provides the sources. A notification to the expression instance may then occur whenever a source is updated. In other words if an expression is placed on a DependencyObject DependencyProperty the sources of the expressions are given back pointers.

The Expression class also includes a GetValue method that takes a Dependency Object and a DependencyProperty as parameters and returns a object. The GetValue method defines how to evaluate the value of the expression for a given DependencyObject and DependencyProperty.

The Expression class also includes a SetValue method that takes a Dependency Object a DependencyProperty and an object as parameters and returns a bool. In general the expression class provides a means for defining relationships between properties. The SetValue method defines the manner in which the value specified in the object parameter is set for a given DependencyObject and DependencyProperty. In other words the SetValue method is used to apply the Expression to the property on the instance. With this SetValue method two way databinding is available. The bool return value is used to notify the DependencyObject that the Expression has handled the set i.e. storage of the value. If the bool return value is true then the Expression invalidates the property of interest.

The Expression class also includes an OnAttach method that takes a DependencyObject and a DependencyProperty as parameters and returns nothing. The OnAttach method is called when an expression is being associated with a DependencyProperty for a particular DependencyObject. This enables the Expression to invalidate a particular DependencyProperty on a particular DependencyObject if one of the DependencySources has been invalidated.

The Expression class also includes an OnDetach method that takes a DependencyObject and a DependencyProperty as parameters. The OnDetach method is called when an expression is b eing detached from a Dependencyproperty for a particular DependencyObject. This enables the Expression to release any resources associated with the DependencyObject and the DependencyProperty.

The Expression class also includes an OnPropertyInvalidation method that takes a DependencyProperty and DependencyObject as parameters. The OnPropertyInvalidation method is called when a property on which the expression is applied is invalidated. For expressions that propogate value updates to the dependency sourc this OnPropertyInvalidation method needs to be called so that changes may be notified.

The DependencySource class includes a constructor . The constructor takes a DependencyObject and a DependencyProperty as arguments. The values for the DependencyObject and DependencyProperty are stored in the DependencyObject property and the DependencyProperty .

Reference has been made throughout this specification to one embodiment an embodiment or an example embodiment meaning that a particular described feature structure or characteristic is included in at least one embodiment of the present invention. Thus usage of such phrases may refer to more than just one embodiment. Furthermore the described features structures or characteristics may be combined in any suitable manner in one or more embodiments.

One skilled in the relevant art may recognize however that the invention may be practiced without one or more of the specific details or with other methods resources materials etc. In other instances well known structures resources or operations have not been shown or described in detail merely to avoid obscuring aspects of the invention.

While example embodiments and applications have been illustrated and described it is to be understood that the invention is not limited to the precise configuration and resources described above. Various modifications changes and variations apparent to those skilled in the art may be made in the arrangement operation and details of the methods and systems of the present invention disclosed herein without departing from the scope of the claimed invention.

