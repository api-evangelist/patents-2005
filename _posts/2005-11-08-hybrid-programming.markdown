---

title: Hybrid programming
abstract: Hybrid programming combines certain aspects of the synchronous calling nature of a thread-oriented programming model with certain aspects of the asynchronous calling nature of an event-oriented programming model by creating parallelized calls. In a described implementation, multiple synchronous calls are transformed into multiple asynchronous calls and encapsulated within a barrier time period. A hybrid programming model or protocol may be employed, for example, in conjunction with communication exchanges in a multiple-phase and multiple-party distributed programming environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865911&OS=07865911&RS=07865911
owner: Microsoft Corporation
number: 07865911
owner_city: Redmond
owner_country: US
publication_date: 20051108
---
The creation of software often starts with an unfulfilled need that can be met by the operations of an electronic apparatus. The unfulfilled need provides direction for a software programmer to begin planning an outline of logic that can achieve the goal of meeting the unfulfilled need. The software programmer is responsible for providing finalized code that is both executable on an electronic apparatus and capable of achieving the goal.

Some software development systems facilitate the production of finalized executable code from higher level logical outlines. By way of example only a software development system may permit a programmer to input a logic outline using a graphical user interface GUI . The logical components that are input by way of the GUI can then be transformed by the software development system into skeleton code. The programmer is then empowered to expand the skeleton code into complete source code. The source code can be transformed into finalized executable code using a compiler or similar development tool.

Hybrid programming combines certain aspects of the synchronous calling nature of a thread oriented programming model with certain aspects of the asynchronous calling nature of an event oriented programming model by creating parallelized calls. In a described implementation multiple synchronous calls are transformed into multiple asynchronous calls and encapsulated within a barrier time period. A hybrid programming model or protocol may be employed for example in conjunction with communication exchanges in a multiple phase and multiple party distributed programming environment. In another described implementation multiple first synchronous message calls are parallelized. If affirmative acknowledgments are received for each of the multiple first synchronous message calls within a predetermined barrier time period then multiple second synchronous message calls are parallelized. If affirmative acknowledgments are received for each of the multiple second synchronous message calls within a predetermined barrier time period then the program can proceed. If on the other hand an affirmative acknowledgment fails to be received then the failure issue is handled.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Moreover other method system scheme apparatus device media procedure API arrangement etc. implementations are described herein.

Two programming models are the thread programming model and the event programming model. The thread model is a blocking model that relies on synchronous calls. In contrast the event model is a non blocking model that relies on asynchronous calls. Both models can be employed when programming in a distributed environment such as a peer to peer P2P network. Each model has benefits and drawbacks.

With synchronous calls being used with the thread model writing code in a thread programming model environment is relatively easier. There are generally fewer simultaneous processes occurring that need to be tracked and managed. Unfortunately it is difficult for one peer to communicate with multiple other peers in a timely manner because the blocking that is instituted in thread modeled programming frequently causes significant communication delays.

With asynchronous calls being used with the event programming model communications between one peer and multiple other peers is expedited inasmuch as they may be occurring simultaneously. Unfortunately writing code in an event programming model environment is relatively more difficult because many different processes may be occurring simultaneously. A program written in accordance with an event model may entail multiple phases with a number of callbacks to connect different parts of the program.

Thus both the thread programming model and the event programming model have benefits and drawbacks especially in a distributed system that involves many communications between and among different devices. In an implementation described herein a hybrid programming model combines some aspects of a thread oriented programming model and some aspects of an event oriented programming model.

In a described implementation thread oriented programming model is associated with synchronous calls and event oriented programming model is associated with asynchronous calls. Thread oriented programming model and event oriented programming model are selectively combined in a combination operation to produce hybrid programming model . Hybrid programming model is associated with parallelized calls.

Parallelized calls may involve simultaneously or asynchronously executing multiple synchronous calls of a set of synchronous calls that are encapsulated into a single overall synchronous like grouping. The nature of parallelized calls as well as a programming model aspects resulting from combination operation are described further herein below.

At block multiple synchronous calls are encapsulated. For example a set of synchronous calls may be grouped together. At block the encapsulated synchronous calls are transformed into asynchronous calls. For example each synchronous call from the grouping may be transformed into an asynchronous call with the asynchronous calls capable of being executed in parallel e.g. with one or more calls being started while one or more other calls are still incomplete .

At block the transformed calls are executed asynchronously. For example execution of some of the transformed calls of the grouping may at least partially overlap with execution of other ones of the transformed calls of the grouping e.g. be executed substantially in parallel . At block it is determined if all calls were successfully executed. For example it may be determined if all encapsulated calls of the grouping have been successfully executed. If so then at block the program proceeds to another phase algorithm or program portion.

If on the other hand all calls have not been successfully executed as determined at block then at block it is determined if a timeout period has expired. If not then execution of the encapsulated calls continues at block . If the timeout period has expired then at block the issue is handled. For example the non completion of the encapsulated synchronous calls may be addressed in some predetermined manner.

In a described implementation multiple devices or network nodes are capable of communicating across one or more networks . As illustrated two devices and n are capable of engaging in communication exchanges via network . Although two devices are specifically shown one or more than two devices may be employed depending on implementation.

In one example implementation one device e.g. device is being used to develop a program and or protocol. In another example implementation many devices are present on network . Each device is considered a peer in a peer to peer P2P network with one device e.g. device being a coordinator in a given communication exchange and other devices e.g. devices . . . n being subordinates in the given communication exchange.

Generally device may represent a server device a storage device a workstation or other general computer device a router switch or other transmission device a so called peer in a distributed P2P network some combination thereof and so forth. As illustrated device includes one or more input output I O interfaces at least one processor and one or more media . Media include processor executable instructions . Although not specifically illustrated device may also include other components.

In a described implementation of device I O interfaces may include i a network interface for communicating across network s ii a display device interface for displaying information on a display screen iii one or more man machine interfaces and so forth. Examples of i network interfaces include a network card a modem one or more ports and so forth. Examples of ii display device interfaces include a graphics driver a graphics card a hardware or software driver for a screen or monitor and so forth. Examples of iii man machine interfaces include those that communicate by wire or wirelessly to man machine interface devices e.g. a keyboard a mouse or other graphical pointing device etc. .

Generally processor is capable of executing performing and or otherwise effectuating processor executable instructions such as processor executable instructions . Media is comprised of one or more processor accessible media. In other words media may include processor executable instructions that are executable by processor to effectuate the performance of functions by device .

Thus realizations for hybrid programming may be described in the general context of processor executable instructions. Generally processor executable instructions include routines programs applications coding modules protocols objects interfaces components metadata and definitions thereof data structures application programming interfaces APIs etc. that perform and or enable particular tasks and or implement particular abstract data types. Processor executable instructions may be located in separate storage media executed by different processors and or propagated over or extant on various transmission media.

Processor s may be implemented using any applicable processing capable technology. Media may be any available media that is included as part of and or accessible by device . It includes volatile and non volatile media removable and non removable media and storage and transmission media e.g. wireless or wired communication channels . For example media may include an array of disks for longer term mass storage of processor executable instructions random access memory RAM for shorter term storage of instructions that are currently being executed link s on network for transmitting communications and so forth.

As specifically illustrated media comprises at least processor executable instructions . Generally processor executable instructions when executed by processor enable device to perform the various functions described herein including those actions that are illustrated in flow diagrams and of respectively and those protocols that are illustrated in block diagrams and of respectively .

By way of example only processor executable instructions may include all or part of a development system A a GUI based programming description B skeleton code C final code D protocol logic E and APIs F. Generally each may be considered a programming construct.

In a described implementation development system A facilitates the creation of software programs. A programmer may use development system A to display a logical outline as a GUI based description B. Development system A is capable of producing skeleton code C from GUI based description B. After the programmer expands e.g. fine tunes and adds details to skeleton code C final code D results. This final code D comprises final source code. After compiling final code D comprises final executable or object code.

Devices communicate with each other over network using some protocol. The processor executable instructions that implement enforce or otherwise comport with this protocol comprise protocol logic E. The interfaces that enable access to hybrid programming features objects etc. comprise APIs F. An example API F is the parallelize PAR API that is described herein below.

Any of these programming constructs may comprise a hybrid programming implementation. For example development system A may implement the actions of flow diagrams or by producing appropriate code in accordance with a hybrid programming model. For instance development system A may act as a parallelizer of synchronous calls possibly in a manner that is transparent to a programmer. GUI based description B may represent and skeleton final code C D may realize such actions. Protocol logic E and APIs F may implement the hybrid programming protocols illustrated in .

In a described implementation generally the first phase corresponds to first messages and first message acknowledgments . The second phase corresponds to second messages and second message acknowledgments . Each set of messages is encapsulated within a barrier . The received acknowledgments are collected at block and they are accounted for at decision block .

Specifically the first message is logged at coordinator . A first barrier is instituted to encapsulate the set of first messages corresponding to the first communication exchange. The barrier includes a timeout variable. First messages are sent from coordinator to subordinates . . . n 1 . Subordinates . . . n 1 also log the first message. Zero to n 1 of subordinates . . . n 1 send a first message ack back to coordinator .

Coordinator receives none to all of the first message acks that are sent from subordinates . . . n 1 within or during barrier . The length of the encapsulating barrier is set by the timeout variable. When the timeout period expires all acknowledgment messages i.e. all first message acks are collected at block .

At block coordinator determines if all first messages have been affirmatively acknowledged by all destination subordinates . . . n 1 . If coordinator fails to receive an acknowledgment from one or more subordinates . . . n 1 or if a received acknowledgment is a negative acknowledgement then coordinator attempts to handle the issue at block . The issue may be handled for example by investigating the status of non responding subordinates by resending first messages to non responding subordinates by attempting a different procedure by aborting the current procedure some combination thereof and so forth.

If on the other hand coordinator does receive an affirmative acknowledgment from all destination subordinates . . . n 1 as determined at block coordinator may proceed with the next phase. As illustrated in hybrid protocol includes a second phase. In the second phase the second message is logged at coordinator . A barrier is instituted to encapsulate the second messages. A total of n 1 second messages are sent to subordinates . . . n 1 which log the second messages upon receipt. From zero to all of subordinates . . . n 1 return a second message ack to coordinator .

Collection of received second message acks ceases at the conclusion of barrier as established by the timeout variable. All of the received second message acknowledgments are collected at block . At block coordinator determines if all of the second messages have been affirmatively acknowledged. If not the issue is handled at block . If all of the second messages have been affirmatively acknowledged coordinator may proceed with the next program portion at block . The next part of the program that is conducted may be another encapsulated message phase another operation including one prepped by the first two message phases and so forth.

In a described implementation first and second messages are synchronous messages. However the institution of barrier enables the encapsulated messages to be transformed into asynchronous messages within barrier . However the set of transformed messages remain synchronous with respect to the remainder of the program coding. In other words from a macro scale the set of messages remain synchronous to facilitate easier coding but each individual synchronous message within the set of messages is transformed into an asynchronous message to expedite communication exchanges.

The transformation may be accomplished in a fashion that is transparent to the programmer. The following sample code represents an example communication exchange that comports with a hybrid programming model. The set of synchronous messages are parallelized with a PAR command having a PAR BEGIN and a PAR END .

At block multiple first synchronous calls are parallelized. For example a first set of synchronous calls may be sent from an originating peer without waiting for acknowledgments to be received from destination peers for individual ones of the first synchronous calls thus transforming them into asynchronous calls relative to one another. At block it is determined if all first calls have been affirmatively acknowledged. For example the originating peer may determine if an affirmative acknowledgment has been received from all destination peers for each synchronous call of the first set of synchronous calls. If not then the issue is handled at block . For example a communication error handling routine may be called.

If on the other hand all of the first calls are determined to have been affirmatively acknowledged at block then at block multiple second synchronous calls are parallelized. For example a second set of synchronous calls may be sent from the originating peer without waiting for acknowledgments to be received from the destination peers for individual ones of the second synchronous calls which enables at least some of the second synchronous calls to be simultaneously under execution. At block it is determined if all second calls have been affirmatively acknowledged. For example the originating peer may determine if an affirmative acknowledgment has been received from all destination peers for each synchronous call of the second set of synchronous calls. If not then the issue is handled at block .

If on the other hand all of the second calls are determined to have been affirmatively acknowledged at block then at block the program may proceed. For example the program may proceed with a target operation with a third phase having multiple third synchronous calls and so forth. In accordance with the actions of flow diagram multiple synchronous calls are parallelized within a set of such synchronous calls. This effectively transforms them into multiple asynchronous calls from a micro perspective but they remain synchronized for the set of synchronous calls from a macro perspective.

Generally first message of hybrid protocol is implemented as a prepare message in hybrid protocol . Second message of hybrid protocol is implemented as a commit message in hybrid protocol . If all subordinates . . . n 1 are ready and committed as determined at blocks and respectively coordinator is empowered to proceed with an operation at block .

Specifically coordinator logs the Prepare communication exchange and prepares a barrier encapsulation . In this example the timeout variable is set to infinity so that coordinator does not progress with the operation unless until acknowledgments are received from all destination subordinates . . . n 1 .

Prepare messages are sent to destination subordinates . . . n 1 from coordinator . In response subordinates . . . n 1 log when they are Ready e.g. by changing or setting a state by locking operations or resources etc. . Prepare acknowledgment messages are sent back to coordinator . Coordinator collects the acknowledgments at . After they have been received from all subordinates . . . n 1 coordinator determines if all subordinates . . . n 1 are ready at block . If not then coordinator handles the issue at block .

If on the other hand no subordinate failed to indicate readiness in its prepare acknowledgment message then coordinator logs the Commit communication exchange and establishes barrier . Commit messages are sent to destination subordinates . . . n 1 and commit acknowledgment messages are received from them. Commit acknowledgment messages indicate that they are capable or are not capable of accepting commands to perform the operation. The acknowledgements are collected at block .

If all of the subordinates . . . n 1 are committed as determined at block then coordinator may proceed at block with the operation that is prepped by the 2PC procedure. If they are not all committed then coordinator handles the issue at block .

The transformation of the synchronous commands into an encapsulated set of asynchronous commands may be accomplished in a fashion that is transparent to the programmer. The following sample code represents an example communication exchange that comports with a hybrid programming model for a 2PC procedure. The set of synchronous messages are parallelized with the PAR command having a PAR BEGIN and a PAR END . In the example below the timeout variable is set to but a shorter barrier time may alternatively be used.

The devices actions aspects features functions procedures modules data structures protocols models components etc. of are illustrated in diagrams that are divided into multiple blocks. However the order interconnections interrelationships layout etc. in which are described and or shown are not intended to be construed as a limitation and any number of the blocks can be modified combined rearranged augmented omitted etc. in any manner to implement one or more systems methods devices procedures media apparatuses APIs arrangements etc. for hybrid programming.

Although systems media devices methods procedures apparatuses techniques schemes approaches procedures arrangements and other implementations have been described in language specific to structural logical algorithmic and functional features and or diagrams it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

