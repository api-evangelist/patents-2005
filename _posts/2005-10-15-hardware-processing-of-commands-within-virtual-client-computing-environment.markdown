---

title: Hardware processing of commands within virtual client computing environment
abstract: Commands are processed by hardware within a virtual client computing environment, such as graphics-related commands processed by graphics hardware. A server computing device includes graphics hardware, a virtual client computing environment, and a server computing environment. The graphics hardware processes graphics-related commands into responses. The virtual client computing environment includes an encoding application that issues the commands. The server computing environment includes a decoding application. The encoding application includes a first thread that receives the commands and places them onto a first queue. The encoding application includes a second thread that receives the responses from a second queue and communicates the responses to a remote display device. The decoding application includes a third thread that receives the commands from the first queue, communicates the commands to the graphics hardware, receives the responses from the graphics hardware, and places the responses onto the second queue.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266232&OS=08266232&RS=08266232
owner: International Business Machines Corporation
number: 08266232
owner_city: Armonk
owner_country: US
publication_date: 20051015
---
The present invention relates generally to virtual client computing environments such as Microsoft Windows Terminal Services environments and more particularly to the hardware processing of commands within such environments such as the processing of graphics related commands by graphics hardware within such environments.

Organizations typically have tens hundreds or thousands of computer users. Historically each computer user has had his or her own client computing device. The client computing devices of all the computer users are usually connected to one another via a network which eases administration of the devices to great extent. However some maintenance is still typically needed on the client computing devices themselves which means that administrators and other information technology IT personnel periodically have to visit each client computing device which is time consuming and costly. Furthermore providing a separate computing device to each computer user is itself a costly endeavor.

Therefore more recently many organizations have migrated their computing resources to a terminal services type environment which is also referred to herein as a virtual client computing environment. In these types of environments a central server computing device hosts a large number of computer users with each user assigned to a separate session running within the operating system on the server computing device. Each computer user still has a client computing device but such client computing devices act primarily as dumb terminals. Users provide input at the client computing devices and the client computing devices provide output to the users but otherwise all application program processing is performed at the server computing device. Examples of such virtual client computing environments include the Microsoft Windows Terminal Services environment and virtual client computing environments available from Citrix Systems of Fort Lauderdale Fla.

Virtual client computing environments are advantageous for at least two reasons. First the client computing devices of the computing users because they only perform input output functionality do not have to be very sophisticated. As a result the cost per user is decreased substantially. Instead of having the latest and expensive processor and other hardware components for instance a client computing device can have a cheaper and slower processor as well as other cheaper hardware components. Overall performance is not degraded because primary application program processing is performed at the server computing device not at the client computing device.

Second maintenance on such multiple user systems is substantially performed at the server computing device itself and not at the client computing devices. For instance upgrading memory processing power hard disk drive storage and so on is provided by increasing these resources at the server computing device not at the client computing devices. As a result maintenance costs incurred by IT personnel are reduced because the IT personnel do not have to visit each client computing device to perform many regular maintenance tasks.

One downside to employing a virtual client computing environment is in the area of graphics processing. Sophisticated graphics processing is typically performed at least in part by dedicated graphics hardware and not solely in software. Graphics related commands are standardized in accordance with standards such as OpenGL. An application program running on a computing device provides such graphics related commands to the operating system running on the computing device. The operating system in turn conveys these commands to the graphics hardware of the computing device which processes them for rendering on the display device of the computing device or for reporting back to the application program. Having dedicated graphics hardware process the graphics related commands provides for graphics processing that is usually many orders of magnitude faster than if such graphics related commands were processed in software that is by a processor of the computing device like any other software and not aided by specialized hardware.

Virtual client computing environments are not well situated to take advantage of dedicated graphics hardware to process graphics related commands however. If the graphics hardware is located at the client computing device itself it cannot be employed by the client application programs running within a virtual client computing environment on a server computing device. This is because the client application programs run within the confines of the operating system provided on the server computing device and thus do not have access to the graphics hardware on the client computing devices themselves for processing graphics related commands. Furthermore even if such access were possible adding expensive graphics hardware to client computing devices defeats the purpose of having virtual client computing environments in the first place which is to save costs by having the client computing devices acting primarily as dumb terminals.

In addition if the graphics hardware is located at the server computing device it typically cannot be employed by client application programs running within virtual client computing environments on the server computing device. For example in a Microsoft Windows environment the graphics hardware may be accessed directly only by server application programs running on the server computing device and not by client application programs running within virtual client computing environments on the server computing device.

A solution to this problem in Linux environments is found in the Deep Computing Visualization DCV product available from International Business Machines Inc. of Armonk N.Y. DCV generally allows the graphics hardware of a server computing device to be leveraged by client application programs running within virtual client computing environments on the server computing device even where the output of such programs is displayed at the client computing devices and not at the server computing device. DCV utilizes various inter process communication IPC mechanisms so that client application programs can pass graphics related commands to the graphics hardware of the server computing device the responses to which are then passed back to the programs themselves or displayed at the client computing devices.

However it has been found that DCV provides for less than optimal performance in graphics related command processing in Microsoft Windows environments. Insofar as the point of accessing the graphics hardware of the server computing device for the benefit of the client computing devices is to enhance graphics performance the less than optimal performance of DCV means that it is not an adequate solution to this problem. Therefore there is a need for allowing client application programs running within virtual client computing environments on Microsoft Windows based server computing devices to leverage the graphics hardware of such server computing devices for the benefit of client computing devices. Such leveraging should provide performance approaching that as if the graphics hardware were installed on the client computing devices themselves and accessible by the client application programs. For these and other reasons therefore there is a need for the present invention.

The present invention relates to the hardware processing of commands within a virtual client computing environment such as the processing of graphics related commands by graphics hardware. A server computing device of an embodiment of the invention includes graphics hardware first and second queues a virtual client computing environment and a server computing environment. The graphics hardware is for processing graphics related commands into graphics related command responses.

The virtual client computing environment is for interacting with a remote client computing device communicatively coupled to the server computing device. The virtual client computing environment includes an encoding application that issues the graphics related commands. The encoding application includes a first thread to receive the graphics related commands and to place the graphics related commands onto the first queue. The encoding application also includes a second thread to receive the graphics related command responses from the second queue and to communicate the graphics related command responses to a display device of the remote client computing device.

The server computing environment is for managing the virtual client computing environment and includes a decoding application. The decoding application includes a third thread to receive the graphics related commands from the first queue to communicate the graphics related commands to the graphics hardware for processing to receive the graphics related command responses from the graphics hardware and to place the graphics related command responses onto the second queue.

A server computing device of another embodiment of the invention includes hardware a virtual client computing environment and a server computing environment. The hardware is for processing specific commands into responses more quickly than is capable of being accomplished in software alone. The virtual client computing environment is for interacting with a remote client computing device communicatively coupled to the server computing device and for issuing the specific commands and includes a first thread and a second thread. The server computing environment is for managing the virtual client computing environment and includes a third thread.

The first thread is to receive the specific commands issued within the virtual client computing environment and to place them onto a first queue. The second thread is to receive the responses from a second queue and to communicate them to corresponding hardware of the remote client computing device. The third thread is to receive the specific commands from the first queue to communicate them to the hardware for processing to receive the responses from the hardware and to place them onto the second queue.

A method of an embodiment of the invention receives a graphics related command by a first thread of a virtual client computing environment of a server computing device as issued by an encoding application running within the virtual client computing environment of the server computing device. The virtual client computing environment is for interacting within a remote client computing device communicatively coupled to the server computing device. The server computing environment is for managing the virtual client computing environment.

The first thread places the graphics related command onto a first queue. A third thread of the server computing environment receives the graphics related command from the first queue. The third thread communicates the graphics related command to graphics hardware of the server computing device for processing into a graphics related command response. The third thread receives the graphics related command response from the graphics hardware and places it onto a second queue. A second thread of the virtual client computing environment receives the graphics related command response from the second queue and communicates it to a display device of the remote client computing device.

An article of manufacture of an embodiment of the invention includes a computer readable medium and first second and third means in the medium. The medium may be a recordable data storage medium a modulated carrier signal or another type of computer readable medium. The first means is for receiving commands issued within a virtual client computing environment and for placing the commands onto a first queue. The second means is for receiving responses from a second queue and for communicating them to corresponding hardware of a remote client computing device associated with the virtual client computing environment. The third means is for receiving the commands from the first queue for communicating them to hardware for processing into the responses for receiving the responses from the hardware and for placing them onto the second queue.

Embodiments of the invention provide for advantages over the prior art. Like the Deep Computing Visualization DCV prior art described above embodiments of the invention leverage graphics hardware at the server computing device for use by client application programs running on the server computing device for displaying information on the display devices of the remote client computing devices. However the architecture inherent to embodiments of the invention provides for significant performance gains over the DCV and other prior art. The specific utilization of threads and queues as described above for instance provides embodiments of the invention with significant performance enhancement over the DCV and other prior art.

Still other advantages aspects and embodiments of the invention will become apparent by reading the detailed description that follows and by referring to the accompanying drawings.

In the following detailed description of exemplary embodiments of the invention reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized and logical mechanical and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is therefore not to be taken in a limiting sense and the scope of the present invention is defined only by the appended claims.

The server computing device includes a virtual client computing environment and a server computing environment which are primarily software applications as well as processors graphics hardware and other types of hardware commonly found in a server computing device but which are not depicted in for illustrative convenience. The virtual client computing environment corresponds to the remote client computing device . All or substantially all input and output with the user of the remote client computing device is performed at the remote client computing device . However all or substantially all processing of such input to provide such output is accomplished within the virtual client computing environment . The virtual client computing environment thus is said to interact with the remote client computing device which is communicatively coupled to the server computing device via a network or other mechanism. Whereas only one virtual client computing environment and only one remote client computing device are depicted in in actuality there will typically be more than one such computing environment and more than one such client computing device.

The virtual client computing environment runs as a session within an operating system. Client application programs such as the client application thus run within the computing environment for the computer user of the remote client computing device . The virtual client computing environment may run in its own partition of the server computing device in one embodiment. The server computing environment is the managing environment for all the virtual client computing environments and therefore manages the virtual client computing environment . For instance the server computing environment may be responsible for managing the execution and administration of the virtual client computing environments such as the client application programs running therein as well as may be responsible for the instantiation and deletion of such virtual client computing environments. The server computing environment may run within its own partition of the server computing device in one embodiment.

Therefore the user interacts with the remote client computing device as if the client application were running on an operating system installed on the remote client computing device . However in actuality the operating system is installed on the server computing device . Input from the user is conveyed from the remote client computing device to the virtual client computing environment for processing by the client application and other applications within the environment using the hardware resources of the server computing device such as the processors and the graphics hardware . Output to the user is then conveyed from the client application or other applications within the environment to the remote client computing device where it may be displayed for example on the display device of the remote client computing device .

The remote client computing device thus acts as a dumb terminal. The client computing device receives input from and displays output to the user but the input and output themselves are processed at the server computing device within the virtual client computing environment . Therefore where upgrading of processing power is needed for example just the hardware of the server computing device needs to be upgraded and not the hardware of the remote client computing device . Other advantages usually attributable to terminal services and other types of virtual client computing environments are also realized by the computer architecture of . The virtual client computing environment is thus a virtual environment in that it is not located at the remote client computing device of the computer user itself but rather is located at the server computing device which is not typically physically accessible by the computer user.

The architecture of operates as follows. The thread receives a graphics related command from within the encoding application . The graphics related command may be a command that is more quickly processed into a graphics related command response by the graphics hardware as compared to substantially or completely within software such as executed by the processors . That is the graphics related command is processed by the graphics hardware to provide the greatest performance benefits. The graphics related command may be an OpenGL graphics related command or another type of graphics related command.

The first thread of the encoding application places the graphics related command onto the first queue as indicated by the arrow . If placing the graphics related command onto the first queue causes the queue to become non empty that is if the queue was empty before the thread placed the graphics related command onto the queue then the first thread also wakes the third thread of the decoding application . The thread then receives or consumes the graphics related command from the first queue as indicated by the arrow .

The thread communicates the graphics related command to the graphics hardware as indicated by the arrow and the graphics hardware processes the command into a graphics related command response. The graphics hardware processes the graphics related command into a graphics related command response more quickly than normal software processing of the command into the response such as by the processors can typically be accomplished. The thread receives the graphics related command response from the graphics hardware as is also indicated by the arrow .

The third thread of the decoding application places the graphics related command response onto the second queue as indicated by the arrow . If placing the graphics related command response onto the second queue causes the queue to become non empty that is if the queue was empty before the thread placed the graphics related command response onto the queue then the third thread also wakes the second thread of the encoding application . The thread then receives or consumes the graphics related command response from the second queue as indicated by the arrow . The thread communicates the graphics related command response to the display device of the remote client computing device as indicated by the arrow . For instance if the response is a bitmap to be displayed on the display device then the thread communicates the response to the display device .

In this way the embodiment of the invention depicted in provides for enhanced graphics related command processing by the graphics hardware for ultimate display by the display device of the remote client computing device even though the display device is not directly connected to the graphics hardware . As compared to the Deep Computing Visualization DCV prior art that has been described the embodiment of employs three threads and as well as two queues and as has been described. The utilization of these three threads and and these two queues and provides the embodiment of with performance advantages over the DCV prior art as well as over other prior art.

Several special situations and particular and more general aspects are now described in relation to the operation of the architecture of the server computing device of . First the first queue may be completely full such that the first thread is unable to place more graphics related commands onto the first queue . In such instance the first thread blocks or waits until the first queue is no longer completely full so that it can again place more graphics related commands onto the first queue . The first queue becomes non full as the third thread receives or consumes graphics related commands from the first queue . When the third thread receives or consumes a command from the queue that causes the queue to transition from full to non full in one embodiment it wakes the first thread to indicate to the first thread that it can again place commands onto the first queue . Waking threads as accomplished in one embodiment of the invention can be accomplished by sending a conventional inter thread Microsoft Windows event.

Second and similarly the second queue may be completely full such that the third thread is unable to place more graphics related command responses onto the second queue . In such instance the third thread blocks or waits until the second queue is no longer completely full so that it can again place more graphics related command response onto the second queue . The second queue becomes non full as the second thread receives or consumes graphics related command responses from the second queue . When the second thread receives or consumes a response from the queue that causes the queue to transition from full to non full in one embodiment it wakes the third thread to indicate to the third thread that it can again place responses onto the second queue .

Third it is noted that no provision is made in the embodiment of to associate the graphics related command responses provided in the second queue with the graphics related commands provided in the first queue . This is because graphics related commands such as OpenGL graphics related commands in particular may be divided into two categories asynchronous commands and synchronous commands. The former are commands for which the encoding application generating the graphics related commands requires no response. Such commands may include those that return void which are the majority of OpenGL graphics related commands in particular as well as the special case of the OpenGL SwapBuffers command which returns the contents of the graphics hardware frame buffer associated with the encoding application . This frame buffer is sent to the display device but the encoding application need not be notified that this has happened. Thus the second thread consumes the response to a SwapBuffers command from the second queue asynchronously.

Therefore because the majority of graphics related commands are usually asynchronous commands there is no need to associate the graphics related command responses provided in the second queue with the graphics related commands provided in the first queue . The graphics related command responses can be processed independently of the graphics related commands and the latter does not have to be synchronized with the former. In other words the first thread and the second thread of the encoding application operate at least substantially independently for the majority of graphics related commands. As the first thread receives graphics related commands it places them onto the first queue and as the second thread receives graphics related command responses from the second queue it conveys them to the display device . The former activity is thus disassociated with the latter activity.

However some graphics related commands are indeed synchronous. Synchronous commands are those for which the encoding application that generated the commands requires return values. Synchronous graphics related commands occur relatively infrequently. Therefore the following mechanism is employed when such commands are encountered. When the first thread places a synchronous graphics related command on the first queue it blocks and waits for the response to this command to arrive on the second queue . When the second thread receives or consumes a synchronous command response from the second queue it signals or otherwise notifies the first thread as indicated by the arrow such as by using a Microsoft Windows messaging event as can be appreciated by those of ordinary skill within the art. The first thread correspondingly wakes reads the result from the second queue as may be provided by the second thread and returns it to within the encoding application . This process or mechanism is referred to as a rendezvous between the threads and .

Fourth it is noted that the second thread is needed in addition to the first thread of the encoding application as follows. Even though the thread blocks until the results of a synchronous command are available it does not also process the responses provided in the second queue and rather the thread processes the responses provided in the queue because asynchronous commands such as the SwapBuffers command also can return responses. The thread returns processor control to the encoding application immediately after queuing an asynchronous command within the queue and there is no guarantee that the encoding application will cause processor control to again execute the thread to process the response to an asynchronous command. As a result the second thread is provided so that responses that are generated by asynchronous commands can be processed in a timely manner.

Fifth in general it is noted that for each encoding application within each virtual client computing environment there is a pair of threads and in one embodiment of the invention. The encoding application is an encoder in that it produces graphics related commands such as OpenGL graphics related commands. The decoding application is a decoder in that it renders these commands to produce responses such as bitmaps or graphics rendering states.

Because the majority of OpenGL graphics related commands in particular are asynchronous the encoding application need not wait for completion of a command to continue its processing once it has produced that command. The encoding application can simply queue the command within the first queue for later processing by the decoding application . Similarly as has been described the decoding application can process the graphics related commands into graphics related command responses asynchronously queuing the responses within the second queue for later processing by the encoding application .

The queue has a number of queue entries A B C . . . N collectively referred to as the queue entries . Each of the queue entries is capable of storing a graphics related command where the queue implements the queue or a graphics related command response where the queue implements the queue . There are two pointers associated with the queue a head pointer and a tail pointer . The head pointer typically points to the next queue entry that is empty in which a command or a command response can be placed whereas the tail pointer typically points to the queue entry containing the next command or command response that is to be consumed.

However the tail pointer will point to an empty queue entry where the queue is completely empty. In such instance the tail pointer points to the same empty queue entry as the head pointer does so that it is known that the queue is completely empty when the tail pointer points to an empty queue entry and the head pointer and the tail pointer both point to the same empty queue entry. Thus when first starting the queue is empty and the head pointer and the tail pointer both point to the first queue entry A. Furthermore it is noted that the head pointer will point to an occupied queue entry where the queue is completely full. In such instance the head pointer points to the same occupied queue entry as the tail pointer does so that it is known that the queue is completely full when the head pointer points to an occupied queue entry and the head pointer and the tail pointer both point to the same occupied queue entry.

When the producing thread is to place a command or a response in a queue entry it places the command or response into the queue entry pointed to by the head pointer and advances the head pointer one queue entry to the right in one embodiment of the invention or to the left in another embodiment . Where the head pointer already points to the last queue entry N then the head pointer rolls over to point to the first queue entry A. It is noted that the producing thread only places a command or response into the queue entry pointed to by the head pointer if that queue entry is empty.

However the producing thread always advances the head pointer to the next queue entry to the right or to the left in another embodiment after placing a command or a response in the queue even if that next queue entry is full. This is because commands and responses are placed and consumed in a first in first out FIFO manner. Advancing the head pointer to the next queue entry to the right or to the left in another embodiment even if this entry is full is accomplished because this next queue entry if full or occupied will be the next queue entry consumed by the consuming thread such that this queue entry is the entry that will become empty next. That is this next queue entry is guaranteed to be pointed to by the tail pointer in such an instance.

When the consuming thread is to receive or consume a command or a response in a queue entry it receives or consumes the command or response pointed to by the tail pointer and advances the tail pointer one queue entry to the right in one embodiment of the invention or to the left in another embodiment . Where the tail pointer already points to the last queue entry N then the tail pointer rolls over to point to the first queue entry A. It is noted that the consuming thread only receives or consumes a command or response from the queue entry pointed to by the tail pointer if that queue entry is occupied.

However the consuming thread always advance the tail pointer to the next queue entry to the right or to the left in another embodiment after receiving or consuming a command or a response from the queue even if the next queue entry is empty. As before this is because commands and responses are placed and consumed in a FIFO manner. Advancing the tail pointer to the next queue entry to the right or to the left in another embodiment even if this entry is empty is accomplished because this next queue entry if empty will be the next queue entry into which another command or response is placed by the producing thread such that the queue entry becomes occupied or full. That is this next queue entry is guaranteed to be pointed to by the head pointer in such an instance.

In another embodiment of the invention the queue is considered to be empty when the head and tail pointers and point to the same queue entry and the queue is considered to be full when incrementing the head pointer would make it equal to or greater than the tail pointer . Thus a thread would not increment the head pointer in this embodiment of the invention if doing so would make it equal to the tail pointer . Either the embodiment described in the preceding paragraphs may be employed the embodiment described in this paragraph may be employed or another embodiment of the invention may be employed in relation to implementing the invention.

It is noted that advancement of the head pointer and the tail pointer for the queue are desirably synchronized which can be accomplished by using the Microsoft Window API InterlockedCompareExchangePointer as can be appreciated by those of ordinary skill within the art. The producing thread is not allowed to add an entry to a full queue and the consuming thread is not allowed to consume an entry from an empty queue. For this reason synchronization of the advancement or movement of the pointers and is desirable.

In one embodiment the queue entry has a fixed size regardless of the type of graphics related command or command response that it holds such that not all the bytes may be used by the queue entry for a given command or response. Stated another way some graphics related commands and command responses may be longer than other commands and command responses. Therefore the queue entry in this embodiment is sized to hold the largest graphics related command or command response so that it is guaranteed that the queue entry can hold any graphics related command or command response as needed.

Referring first to the method is performed when a graphics related command is received by the first thread as may be issued within the virtual client computing environment such as by the encoding application running therein. The first thread attempts to place the graphics related command onto the first queue . If the queue entry pointed to by the head pointer for the first queue is full then the first thread blocks until it is waken by the third thread . At some point this queue entry is or becomes empty such that the first thread places the command at the queue entry pointed to by the head pointer . The first thread then advances the head pointer to the next queue entry within the first queue .

If placement of the command at the queue entry pointed to by the head pointer in part caused the queue to become non empty i.e. the queue was previously empty and now is not empty then the first thread also may wake the third thread for the third thread to consume this command. The method is then finished but is repeated each time a graphics related command is received by the first thread for placement onto the first queue . That is the method is repeated each time the first thread is entered by the encoding application to issue a graphics related command.

Referring next to the method is performed when a graphics related command is to be received from the first queue by the third thread . The method is described as starting in relation to being performed when the third thread attempts to receive a graphics related command from the first queue . Thus if the queue entry pointed to by the tail pointer for the queue is empty then the third thread blocks until it is waken by the first thread to indicate that there is a command on the first queue now that is to be consumed. In actuality then the method starts at part since initially it is not waken until there is a command on the first queue . However the method is depicted in as starting by attempting to receive a graphics related command from the queue in part for illustrative consistency and correspondence with the method of .

Therefore ultimately the third thread receives a command at the queue entry pointed to by the tail pointer . Receipt of the command consumes the command from the queue entry such that this queue entry then becomes empty. The third thread advances the tail pointer to the next queue entry within the first queue . Furthermore if receipt of the command at the queue entry pointed to by the tail pointer caused the queue to become non full i.e. it was previously full and now is no longer full then the third thread wakes the first thread which may have been blocking in part of the method of . The third thread ultimately communicates the graphics related command to the graphics hardware for processing . The third thread then repeats the method beginning at . That is the third thread may at some point receive all the commands within the queue such that it blocks at part .

Referring next to the method is performed when a graphics related command response is received by the third thread from the graphics hardware . The method is performed by the third thread concurrently with the method of . Thus that the third thread blocks in part of the method means that it blocks in relation to the method and not in relation to the method of . Similarly that the third thread blocks in part of the method means that it blocks in relation to the method and not in relation to the method of .

The third thread attempts to place the graphics related command response onto the second queue . If the queue entry pointed to by the head pointer for the second queue is full then the third thread blocks until it is waken by the second thread . At some point this queue entry is or becomes empty such that the third thread places the response at the queue entry pointed to by the head pointer . The third thread then advances the head pointer to the next queue entry within the second queue .

If placement of the response at the queue entry pointed to by the head pointer in part caused the queue to become non empty i.e. the queue was previously empty and now is no longer empty then the third thread also may wake the second thread for the second thread to consume this response. The method is then finished but is repeated each time a graphics related command response is received by the third thread for placement onto the second queue . That is the method is repeated each time the third thread receives a response from the graphics hardware .

Referring finally to the method is performed when a graphics related command response is to be received from the second queue by the second thread . The method is described as starting in relation to being performed when the second thread attempts to receive a graphics related command response from the second queue . Thus if the queue entry pointed to by the tail pointer for the queue is empty then the second thread blocks until it is waken by the third thread to indicate that there is a response on the second queue now that is to be consumed. In actuality then the method starts at part since initially it is not waken until there is a command on the second queue . However the method is depicted in as starting by attempting to receive a graphics related command response from the queue in part for illustrative consistency and correspondence with the method of .

Therefore ultimately the second thread receives a response at the queue entry pointed to by the tail pointer . Receipt of the response consumes the response from the queue entry such that this queue entry then becomes empty. The second thread advances the tail pointer to the next queue entry within the second queue . Furthermore if receipt of the response at the queue entry pointed to by the tail pointer caused the queue to become non full i.e. it was previously full and now is no longer full then the second thread wakes the third thread which may have been blocking in part of the method of . The second thread ultimately communicates the graphics related command response to the display device of the remote client computing device . The second thread then repeats the method beginning at . That is the second thread may at some point receive all the responses within the queue such that it blocks at part .

It is noted that although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This application is thus intended to cover any adaptations or variations of embodiments of the present invention. For instance embodiments of the invention have been substantially described herein in relation to graphics related hardware for processing graphics related commands into graphics related command responses. However other embodiments of the invention are applicable to other types of hardware for processing other types of commands into other types of command responses. Therefore it is manifestly intended that this invention be limited only by the claims and equivalents thereof.

