---

title: Systems and methods for providing distributed, decentralized data storage and retrieval
abstract: Systems and methods for distributed, decentralized storage and retrieval of data in an extensible SOAP environment are disclosed. Such systems and methods decentralize not only the bandwidth required for data storage and retrieval, but also the computational requirements. Accordingly, such systems and methods alleviate the need for one node to do all the storage and retrieval processing, and no single node is required to send or receive all the data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08266237&OS=08266237&RS=08266237
owner: Microsoft Corporation
number: 08266237
owner_city: Redmond
owner_country: US
publication_date: 20050420
---
The invention relates generally to systems and methods for providing distributed decentralized data storage and retrieval. More particularly the invention relates to distributed storage and retrieval models that provide cost effective mechanisms to enable peer based services such as for example rich media advertising photo and video sharing and storage and video email.

A number of scenarios may be enabled via a peer based distributed storage system. Examples of such scenarios include peer based textual and rich media advertising storage caching replication peer based digital photo and video storage and sharing and peer based video email. These scenarios tend to be cost prohibitive as centralized services however because storage costs can become unbounded in a data center.

Many websites are moving to purely advertising based models with highly targeted advertisements that appear based upon knowledge previously learned from the user. For example it is well known that a great deal of demographic data can be collected about people and quite a bit of information can be inferred based solely upon data collected in the clickstream of a website. Highly targeted ads may be based upon search keywords for example. Such a scenario typically requires lots of storage.

Storage of such advertisements in a centralized manner has been done before. A difficulty however exists in certain markets such as emerging markets because a different cost structure may be needed to be able to efficiently store forward and cache the advertisements to the local machine. In many cases it is cost prohibitive to centralize these ads and pay storage costs in a datacenter because the ads are generally localized into the various world wide markets. Paying bandwidth costs to ship ads around the world is usually not an efficient or inexpensive model.

Existing solutions for photo sharing fall into two major camps centralized storage e.g. photos.msn.com or point to point P2P photo sharing e.g. Google s current version of Picasa . Centralized storage has clear limitations if it is provided for free the total space available for photo storage may be severely limited. On the other hand typical user fees tend to be far in excess of what it would cost a user to simply buy their own disk. If they buy their own disk however then they are responsible for backing up the photos and may be severely limited in the number of people who could view the photos because most broadband connections throttle the upload speeds.

P2P photo sharing solutions such as Groove or Google s current version of Picasa make entire copies of the photos across all of the machines participating in a peer group. Though this sidesteps the storage cost and bandwidth issues described above it introduces different problems. For example if not many people are participating in the group then there is a fair chance depending upon the uptime of the various peers that a participant s photos may not be available if their local copies were lost. In addition this brute force solution requires 100 of all peers to store 100 of all photos. This tends to result in a great deal of redundant storage used across the entire peer group and does not scale well.

Video messages delivered via email suffer from many of the same problems described above in connection with photo sharing but they are even more massive in size making storage costly . Delivery also tends to be unreliable unless serviced from a central datacenter. Though live P2P video teleconferencing does not have the storage problems because the video is consumed at the same time it is sent it has further limitations around quality limited by bandwidth as well as synchronicity of the speaking parties.

Thus there is a need in the art for distributed storage models that provide cost effective mechanisms to enable peer based services such as rich media advertising photo video sharing storage and video email for example.

The invention provides systems and methods for decentralized distributed data storage and retrieval. Such a system may include an interconnected network of nodes. Each node may have running thereon a collection of one or more processes that form a local cache and transport layer a stream store layer a chunk store layer and a fragment store layer. A collection of processes may also be provided for block storage.

The local cache and transport layer may include a storage service and a routing service. The storage service may receive a storage request to store a certain bit stream of arbitrary length. The routing service may communicate the bit stream to any of the stream store services. The stream store service may store the bit stream in local persistent storage for later retrieval and also divide the bit stream into one or more chunks. The stream store service may then communicate the chunks to respective chunk store services. The chunk store service may store the chunk in local persistent storage for later retrieval and also divide the chunk into one or more fragments. The chunk store service may then encode the fragments into check blocks and communicate them to respective fragment store services. The fragment store service may store the fragment in local persistent storage for later retrieval. Thus the bit stream may be divided into a plurality of check blocks and each check block stored in general on a different network node distributed over a vast network of such nodes.

Such a decentralized peer to peer distributed storage system may be used to store and cache digital advertisements locally such as for example in client PCs that reside in the actual country or city where the ads are to be viewed. With regard to digital photo and video storage and sharing the underlying distributed storage mechanisms may be leveraged to achieve very high reliability and availability of the photos without requiring massive amounts of redundancy. With regard to video email the distributed storage model may be leveraged to build a reliable mail delivery system tuned for large sized video messages.

Although not required the invention can be implemented via an application programming interface API for use by a developer or tester and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers e.g. client workstations servers or other devices . Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. An embodiment of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an example system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology compact disc read only memory CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as ROM and RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data . RAM may contain other data and or program modules.

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the example operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client devices can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

Each node A H may be assigned a unique address. The length of the address may be chosen in order to ensure that each node has a unique address. In an example Interned based system where the network is expected to include tens of millions of nodes 160 bit addresses may be used. Such an addressing scheme may form a routing overlay on top of the TCP.

Processes distributed among the several nodes A H may communicate with each other over the network via simple object access protocol SOAP messages. SOAP is a well known lightweight XML based distributed computing protocol. A SOAP message is an XML document that includes a SOAP envelope. The envelope includes an optional SOAP header and a mandatory SOAP body. The SOAP message header represents the metadata of the message and provides a way to extend SOAP. The SOAP message body is the actual message payload. The distributed processes may communicate with one another by putting SOAP packets onto the network.

A process may be a message originator e.g. on node A as shown an intended message receiver e.g. on node G as shown or an intermediary e.g. on node C as shown . The message originator is the process that originally puts the SOAP message onto the network. The intended message receiver is the process to which the message is ultimately destined. Accordingly a SOAP message originating from the message originator may include an address associated with the intended message receiver.

It is possible however especially in large networks that the message originator does not know the address of the intended message receiver. In fact the message originator might not even know that the intended message receiver exists. Accordingly to get the message to the intended receiver on G a process on an intermediary node C may receive the message C modify and or copy the message and put one or more copies D F of the message back onto the network. Thus the message may hop around the network until the message G eventually hops to the intended message receiver on G . It has been found that for a network having about 10 million nodes the average hop count is about three and the maximum hop count is about 5.8.

In order to optimize the number of hops it takes to get a message from the originator to the intended message receiver the nodes may gossip. That is from time to time nodes may communicate information about themselves onto the network. For example a node may gossip about its up time or bandwidth and the status of its neighbors. Nodes also listen for such information being communicated by their neighbors. Consequently each node learns and retains information about certain of its peers.

Such gossiping enables a message originator to get a message to an intended message receiver without specific knowledge of the intended message receiver s address. For example if the message originator wants to get a message to a certain device then the message originator need only get the message as close to that device as possible e.g. address it to another node that is likely to know something about the intended message receiver or something about another node that is likely to know something about the intended message receiver etc. . Because the neighbors of the intended message receiver will have knowledge of the intended message receiver the message will eventually hop to the intended message receiver. Thus a resilient network may be built that enables message delivery even where for example the message originator does not know how to get to the intended message recipient directly or cannot get to the intended message recipient directly because of a firewall for example or the like.

A service on each node A H may also maintain a local routing table A H on behalf of one or more neighboring nodes. Local routing tables are described in greater detail below.

The local cache and transport layer may include a storage service and a routing service . The storage service and the routing service may reside on the same node or on different nodes. The storage service may receive a storage request Bit Stream from the same node or from a different node via the network. The storage request may include a request to store a certain bit stream. Such a bit stream may in general have any arbitrary length M. The routing service may communicate the bit stream to any of the one or more stream storage services A N. The stream storage service that receives the bit stream may reside on the same node as the routing service or on a different node.

The stream store service at the recipient node A as shown may receive one or more packets containing the bit stream i.e. the bit stream may be so long that more than one packet is required to communicate it to the stream store service . The stream store service A may store the bit stream in local persistent storage for later retrieval. The stream store service A may also divide the bit stream into one or more chunks. Each chunk may be of length m M bits. In an example embodiment each chunk may have a length of about 64K bits. The stream store service A may then communicate each of the one or more chunks to respective chunk store services A N. A chunk store service that receives a chunk may reside on the same node as the stream store service A or on a different node.

The chunk store service at the recipient node A as shown may receive one or more packets containing the chunk and may store the chunk in local persistent storage for later retrieval. The chunk store service A may also divide the chunk into one or more fragments. Each fragment may be of length 1 m bits. In an example embodiment each fragment may have a length of about 2K bits. The chunk store service A may then encode the fragments into check blocks and communicate each of the one or more check blocks to respective fragment store services A N. A fragment store service that receives a fragment may reside on the same node as the chunk store service A or on a different node.

The fragment store service at the recipient node A as shown may receive one or more packets containing the fragment and may store the fragment in local persistent storage for later retrieval. The fragment store services A N at the recipient nodes may receive one or more packets containing the respective check blocks and each may store a respective check block in local persistent storage for later retrieval. Thus the M bit bit stream may be divided into a plurality of k bit check blocks and each check block stored in general on a different network node distributed over a vast network of such nodes.

Preferably the number of check blocks into which each chunk is divided is more than enough to ensure reliable retrieval with a great degree of confidence. Any of a number of known algorithms may be employed for determining the number of check blocks that should be stored to ensure with a certain confidence level that the original bit stream may be reconstructed from the check blocks. Such algorithms are known to those skilled in the art and therefore need not be described in detail here.

In order to ensure that the data retrieval system described below will be able to find the stored data later an addressing scheme may be used to determine where i.e. on which nodes to store the data. The routing service for example may compute based on the bit stream itself an address of a node to which to route the bit stream. For example in a scenario such as described above where each node may be identified by a unique address a hash may be computed based on the bit stream and a hash table may be consulted to determine a node address that corresponds to the hash value.

The bit stream may have a bit stream identifier. For example the bit stream may be a file the file may have a file name. Accordingly the file name may be considered a bit stream identifier. The user i.e. the person seeking to store the bit stream may have a user identifier. For example there may be a public key associated with the user. In an example embodiment the bit stream identifier and the user identifier may be concatenated and a hash of the concatenated string computed. The computed hash value may be used to determine the address of the node to which the bit stream is to be sent for storage and subsequent storage processing as described above. Similarly a respective hash value may be computed for each chunk fragment and check block into which the bit stream is decomposed. The chunks fragments and check blocks may then be sent to the nodes having addresses that correspond to the computed hash values.

In a network environment having millions of nodes it may be impractical and undesirable for each node to store and maintain a hash table that includes a respective address associated with every node. Accordingly in an example embodiment a service on each node A H may maintain a local routing table A H on behalf of one or more neighboring nodes see . Preferably every node knows about the address space i.e. the addressing scheme used to uniquely identify the several nodes but each node maintains a routing table only for a few of its neighbors. Thus the hash table may be distributed among the several nodes.

By using a distributed hash table each node has insight into only a small portion of the entire address space. As described above however it is the nature of the underlying fabric that a message originator need not know the address of the intended receiver. The message originator can compute a hash base on the bit stream or chunk or fragment or block to be stored and consult its local hash table. If the address is found then the message originator can send the message directly to the intended receiver. Otherwise the message originator puts the message onto the fabric and the message hops through one or more intermediaries until it finds its way to the intended receiver.

Eventually as described above the data e.g. check block fragment chunk or bit stream is persisted i.e. stored permanently in storage at a destination node. When the data is persisted the destination node may put a message onto the fabric to inform the originating node that the data has been persisted. When the originating node receives the information message it accepts that the data has been persisted.

For example when a check block is persisted on a destination node the fragment store service may notify the chunk store service that requested storage of the check block that the check block has been persisted. Similarly when all the check blocks associated with a given chunk are persisted the chunk store service may notify the stream store service that requested storage of the chunk that the chunk has been persisted etc. Eventually the routing service at the local cache and transport layer is notified that the bit stream has been stored.

In order to confirm that storage has occurred properly the service requesting storage may start a timer when the data is sent out for storage. For example when a chunk store service sends out its fragments for storage the chunk store service may start a fragment storage confirmation timer. If the chunk store service does not receive confirmation that a particular fragment has been stored before the timer expires then the chunk store service concludes that the fragment has not been stored and attempts to store the fragment elsewhere.

It should be understood however that a distributed system as described above may have the capability to alter time. That is each node may have a time manager that keeps time for that node relative to absolute system time. Thus time may be slowed stopped or even reversed on a particular node relative to absolute system time and to the time frame of other nodes. Accordingly because time at the node requesting storage may be running faster than time at the node s on which the data is to be stored or intermediary nodes the timer at the node requesting storage may expire before the data is persisted even though there is nothing wrong with the storage process time is merely running slower. To accommodate for this the storing node can periodically send a message to the node requesting storage to inform the node requesting storage that even though storage is not yet completed the node requesting storage should not time out.

In order to retrieve the bit stream or as described below a portion of the bit stream the routing service in the local cache and transport layer may put a message onto the network requesting that the data be retrieved from the node s on which it is stored. To retrieve the data the routing service may compute the key associated with the data. For example as described above the routing service may compute a hash of the bit stream identifier and user identifier. The computed hash value may be used to determine the address of the node to which the bit stream was sent for storage and subsequent storage processing.

The routing service may then consult the local routing table to determine the address or nearest neighbor address associated with the hash and request the bit stream from that address. If the bit stream is still stored in the local cache associated with that stream store service then the stream store service returns the bit stream in one or more packets to the node that requested it. If the bit stream is not still stored in the local cache associated with that stream store service then the stream store service computes the hashes associated with the chunks into which the bit stream was decomposed and requests those chunks from the chunk store services to which those chunks were sent during the storage process.

If a chunk remains in local cache associated with that chunk store service then that chunk is returned to the node that requested it. If not then the chunk store service computes the hash associated with the fragments associated with that chunk and requests those fragments from the nodes on which those fragments were stored.

This process continues retrieving check blocks to reconstitute the fragments retrieving fragments to reconstitute the chunks retrieving chunks to reconstitute the bit stream until the bit stream is reconstituted and returned to the node that requested it. As described above the nature of the underlying fabric is that routing to the key will lead the message to the nodes on which the data is stored.

As described above the bit stream may be divided into a plurality of contiguous check blocks fragments chunks . Accordingly the retrieval process need not retrieve the entire bit stream and may retrieve only a subset of the check blocks fragments chunks . In general the retrieval process may begin with any check block fragment chunk in the bit stream and end with any other check block fragment chunk . To retrieve only a portion of the bit stream the retrieval service need only determine the addresses associated with the check blocks fragments chunks that make up that portion of the bit stream and request reconstitution of that portion of the bit stream from those check blocks fragments chunks . Because the hashing process works by hashing the identifier of the previous layer and the ordinal number i.e. offset of the chunk that is the check block in the lower layers it is possible to find the hash value of any of the pieces.

It is anticipated that a node on which a check block is persisted may no longer be on the network when the data is retrieved e.g. the data may have been overwritten deleted or corrupted the node may be unavailable at the time the data is requested the node may have been removed from the network permanently etc. . Preferably as described above the number of check blocks into which each chunk is divided is more than enough to ensure reliable retrieval with a great degree of confidence even when a number of check blocks are irretrievable. It is also anticipated that one or more nodes may be added to the network between the time the data is stored and the time it is retrieved. If a new node that is closer to the key has been introduced then due to the nature of the underlying fabric a previously existing node one that existed at the time the data was stored will realize that the new node has been introduced and that the new node is closer to the data sought to be retrieved. Accordingly the new node may push the appropriate message s to the new node in order to continue the process of hopping the message to the node on which the data is stored.

According to an aspect of the invention a decentralized peer to peer distributed storage mechanism may be used to store and cache ads for example locally such as in client PCs that reside in the actual country or city where the ads are to be viewed. In this manner not only may textual or banner ads be stored but so may rich media e.g. full motion video plus stereo audio television style advertisements localized to a specific region neighborhood or individual.

With regard to digital photo and video storage and sharing the underlying distributed storage mechanisms may be leveraged to achieve very high reliability and availability of the photos without requiring such massive amounts of redundancy such as in Google s current version of Picasa. This scenario may be particularly important given the increased number of phone based cameras appearing in the market. Even with a phone based camera having its own local mass storage the user may still have problems backing up photos and sharing them electronically. This may be especially interesting in emerging markets where mobile phone usage is exploding due to more ready build out of a wireless infrastructure.

With regard to video email the distributed storage model may be leveraged to build a reliable mail delivery system tuned for large sized video messages. In such a system the quality problem may be solved because the system is no longer bound by the bandwidth limitations of either the sender or the receiver. It also allows the receipts to be freed from being in the same place at the same time. This scenario may be important in emerging markets where complex scripts make it difficult to type textual messages on a keyboard and high rates of illiteracy make it difficult to send any type of text message.

Thus there have been described systems and methods for distributed decentralized storage and retrieval of data in an extensible SOAP environment. It should be understood that such systems and methods decentralize not only the bandwidth required for data storage and retrieval but also the computational requirements. That is such systems and methods alleviate the need for one node to do all the storage and retrieval processing and no single node is required to send or receive all the data.

It should further be understood that although the invention has been described in connection with certain preferred embodiments depicted in the various figures other similar embodiments may be used and modifications or additions may be made to the described embodiments for practicing the invention without deviating therefrom. For example when it is being stored the data may be encrypted signed etc. so that the retrieving process can verify that the retrieved data is in fact the expected data. The invention therefore should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the following claims.

