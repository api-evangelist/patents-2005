---

title: Sheaf data model
abstract: A data model including a first table to represent an entity type with a column in the table for a respective attribute of the entity type, and having rows entered with attribute data. The data model also includes a row graph which represents an ordering relationship between the rows of the first table, and a column graph which represents an ordering relationship between columns of the first table. Further, the column graph is a row graph from a second table.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865526&OS=07865526&RS=07865526
owner: Limit Point Systems, Inc.
number: 07865526
owner_city: Livermore
owner_country: US
publication_date: 20050422
---
This application is a continuation of application Ser. No. 09 852 781 filed May 11 2001 the entire contents incorporated herein by reference.

The present invention relates to a data model and associated operators. More particularly the present invention relates to a sheaf data model including a base set and a corresponding graph representing the inclusions of the base set and associated operators which operate on the sheaf data model.

A data model is a theory for describing computer data. The term was introduced by C. F. Codd in the early 1970 s to describe the relationship between previous approaches to data management and a relational data model which he had just introduced. Formally a data model specifies three things 1 a class of mathematical objects which are used to model data 2 the operations on those objects and 3 the constraints between the objects that must be satisfied in a valid database.

The purpose of a data model is to serve as a basis for analysis design and implementation of database management systems DBMS . That is a DBMS will implement in software or sometimes in hardware the operations of the model which allow clients of the system to store and manipulate their data as instances of the objects of the model.

Currently all major DBMS such as the ones sold under the trademarks ORACLE INFORMIX and SYBASE are based on some form of the relational model. To the commercial data management industry data management is essentially indistinguishable from relational database management system RDBMS technology.

In the relational data model the mathematical objects are relations on domains and the operations are given by relational algebra. The terms relation domain and relational algebra have detailed rigorous definitions in mathematics. However it is possible to understand these terms via a widely used table analogy and which will be described with reference to the tables shown in and 

A mathematical set is any collection of objects entities etc. A domain is a set of values that can be directly represented on the computer in other words a computer data type. Three very common domains are integer numbers real numbers and character strings. Referring to a domain is a table with a single column listing all possible values in the domain . A name of the domain is a column heading. The number of values in the domain has been selected to be very small to make the table easy to draw however in practice the number of values is much larger.

In addition the Cartesian product can be extended to more than just two factors. The n ary Cartesian product A B C . . . n factor sets is a table with n columns one for each factor. Each row contains n values one from each one of the factors. In addition there is a row in the table for each possible combination of values. Each row is called an n tuple and the n ary Cartesian product is the set of all such n tuples.

A relation schema or relation type is a list of column headings for the table or equivalently a list of factors in the Cartesian product which the relation is a subset of. There are many different possible subsets of the rows of a given Cartesian product set and hence there are many possible relations for a given relation type. The term relation instance is used to refer to a specific subset of the rows of a given relation type.

Applications are often analyzed for data base purposes using the dual notions of entity and relationship. An entity is any thing or object in the real world which is distinguishable from all other objects. Entities have attributes. An attribute is a named property that takes its value from some domain. An entity is represented by its set of attribute values and the attribute values identify the entity and describe its state. A relationship is an association between entities.

When the relational model is used to store application data the application data is typically organized so that a relation represents either an entity in the application or a relationship between entities. illustrate an example of a relational model directed to a personnel application including an EMPLOYEE table and a MANAGED BY table see and . The EMPLOYEE table shown in is an entity table. Each row in table represents an entity i.e. an employee and the columns in table represent attributes of the entity i.e. an employee id name job title and salary .

The MANAGED BY table shown in is a relation corresponding to a relationship between workers and managers. That is each row in table represents a relationship between two employees one a manager of the other. The columns in table include the ids of the relevant employees and a manager id .

In addition because an entity is any thing or object an attribute value can also be considered as an entity. For example a name serving as an attribute value of an entity EMPLOYEE may also be considered an entity. Thus an entity attribute association can be considered as a relationship between two entities a primary entity and the attribute entity. This fundamental relationship is referred to as a HAS A relationship which is built into the relational data model. That is the HAS A relationship is directly represented by the relationship between a table and its columns. Other relationships such as the MANAGED BY relationship shown in must be represented by additional tables.

Further a large number of operations may be performed on relations. The operations receive one or more relations i.e. tables as an input and produce a relation as an output. The operations are not all independent of each other. That is some operations can be implemented using other operations. Six fundamental operators in the relational algebra include 1 Cartesian product 2 selection 3 projection 4 union 5 intersection and 6 rename. The Cartesian product operator has been discussed with reference to . A description of the other five operators will now be given with reference to 

The selection operator receives a table i.e. a relation and a row selection condition as an input and outputs a table containing only the rows that match the selection condition. For example the command SELECT rows with SALARY 100 000 in relation EMPLOYEE returns a table shown in . Note the table in does not have a name. The rename operator discussed below allows a table to be named. However in some instances the table produced by an operator is a temporary result to be used only as input to another operator. In these instances there is no need for the table to have a name.

Another result of a selection operation is shown in in which the command SELECT rows with TITLE Programmer in relation EMPLOYEE is executed. As shown the resulting table includes only the rows with the title Programmer. 

The projection operator is similar to the selection operator except it works on columns. That is the projection operator receives a table and a column selection condition typically a list of column names as an input and outputs a table including only the selected columns. In addition because two rows may have a different attribute only in a column not selected by the projection operation the resulting table may include duplicate rows. In this instance only one of the duplicate rows is retained and the others are discarded. illustrates a result of the projection operation in which the command PROJECT columns named NAME in relation EMPLOYEE is executed. As shown the projection operation produces a table including all of the employees names.

The union operator receives two tables as an input and outputs a table including all the rows in either of the input tables. In addition the union operator can only be used on tables which both have the same relation type column headings . For example illustrates a resultant table from a union operator of the tables shown in and . The table is produced by executing the command UNION relation Table with relation Table . The references to Tables and respectively refer to the tables shown in and

The intersection operator receives two tables as an input and outputs a table containing all rows that were the same in both tables. Similar to the union operator the intersection operator can be only used on tables which both have the same relation type. For example illustrates a resultant table from an intersection operation of the tables shown in and in which the command INTERSECT relation Table with relation to Table is executed.

The above noted operators all produce nameless tables. However a table must have a name if it is to be later referred to. The rename operator may be executed to perform this function.

The set of operators described above is a primitive set of operators. That is the set is a minimal set of operations from which other more convenient operations can be built. Practical relational database systems implement a number of other operators which for simplicity purposes are not described herein.

A database for a particular application is designed by choosing a set of relation types that represent the entities and relationships in the application. This collection of relation types is called the database schema. The details of the mathematics of the relation model place a number of constraints on the relation types in the database schema. A database schema that satisfies these constraints is said to be in normal form and the process of reshaping a candidate database schema design to meet the requirements of the normal form is called normalization. The net effect of normalization is typically to scatter the attributes of an entity across many different tables.

The constraints of the normal form are organized into various stages such as first normal form second normal form etc. The first normal form requires each column in a table to contain atomic data. That is the domain associated with the column must be some predefined preferably fixed size type value such as an integer. The reason for this is because the relational operations deal only with the table structure and can not deal with any internal structure associated with the data within a given cell in the table.

The most infamous type of non atomic data is the array. Frequently the most natural interpretation of the application entity is it has an attribute which is a variable length collection. For instance an attribute for an employee might be skills a variable length array of skill keywords. However this attribute would constitute a non atomic attribute and hence is forbidden. Typically the atomic attribute requirement forces the creation of additional tables such as an EMPLOYEE SKILLS table which would cross reference other employee entities to skill entities. In many applications this is an entirely acceptable approach. However in several instances discussed below this type of processing is unacceptable.

The relational data model was a radical departure from previous data management approaches because it is a mathematical model. Previous ad hoc approaches had mostly focused on how data was to be stored and described how to access the data in terms of how it was stored. This limited the types of queries that could be made and generated massive software maintenance problems whenever the data storage was reorganized.

The relational data model instead described data in terms of abstract mathematical objects and operations. The mathematical abstraction separated how data was accessed from how it was actually stored. Furthermore the mathematics ensured that the relational algebra was a complete set of query operators. That is any query within the universe of possible queries defined by the model could be generated by a suitable combination of the fundamental relational algebra operators.

The mathematical abstraction and completeness of the relational algebra meant that sophisticated query processors could be implemented as independent subsystems without knowledge of the application. This arguably created the database management system as a commercial product and unquestionably revolutionized the database industry.

In spite of the overwhelming success of the relational data model not all application areas are well served by the model. A first application which is not well suited for the relational model is an application which deals with spatial data. There are a wide variety of applications using data that is spatial or geometric in nature. For example computer aided design and manufacturing CAD CAM and geographic information systems GIS are two well known commercially important examples.

A main focus of systems that deal with spatial data is the need to represent spatial decomposition. For example in design data the decomposition into systems subsystems and parts is a spatial decomposition. Similarly in geographical data the decomposition into states counties and cities is a spatial decomposition. Furthermore these applications frequently exhibit multiple concurrent decompositions. For instance geographic systems must represent both physical boundaries and political boundaries.

At the finest level of decomposition spatial data includes collections of geometric primitives and the topological relationships between the primitives. Geometric primitives include simple geometric shapes like points lines and polygons as well as a wide and constantly growing number of mathematically more sophisticated primitives such as non uniform rational B splines NURBS . The topological relationships describe how these geometric patches are connected to form complex structures.

It has long been understood that the relational model is a poor choice for representing spatial data. There are at least two fundamental issues. First it is difficult to represent the decomposition relationships especially the topological relationships in a natural and efficient way. For instance a polygon has a collection of edges i.e. a HAS A relationship which is naturally represented as an attribute of the polygon entity. However the first normal form prohibits such variable length collections as attributes. On the other hand representing the topological relationships in separate relationship tables requires complex possibly recursive and frequently inefficient queries to retrieve all the parts of a geometric primitive. Second the operations of the relational algebra are not well suited to natural spatial queries such as nearness queries and region queries.

A second application which is not well suited for the relational model is object oriented programming systems. Object oriented languages such as Smalltalk C and Java facilitate the definition of programmer defined entity types called classes. Individual entities of these entity types are called objects. Complex entities and entity types are composed primarily using two relationships. First the HAS A relationship is used to compose simpler objects into more complex objects. That is objects have parts which are other objects. An IS A relationship is used to combine entity types into more complex types.

The IS A relationship or inheritance as it is called in the object oriented paradigm is a powerful new technique introduced by the object oriented paradigm. The IS A relationship is a relationship between entity types rather than just individual entities. If an entity type MANAGER is specified to inherit type EMPLOYEE then the MANAGER type is a special type of EMPLOYEE i.e. a IS A relationship . Every MANAGER entity has all the attributes every EMPLOYEE entity has plus any attributes that are specified in type MANAGER. This programming mechanism greatly facilitates the construction of complex software applications by making it much less labor intensive and less error prone to model the natural inheritance relationships found in applications.

In execution an object oriented application is a complex network of objects related by the HAS A and IS A relationships. The natural notion of data storage for such a system is the notion of object persistence. That is it should be easy to store an object and all the objects it refers to in a database thus making the object persist after the program that created it has finished execution. Similarly it should be easy to retrieve the object when execution resumes.

Attempts to use the relational model to store object oriented data suffer one of the same difficulties as described above for spatial data which is complex recursive HAS A relationships are difficult to implement in the relational model. A more severe problem is the IS A relationship can not at all be implemented directly in the relational model. In the context of a relational data base the IS A relationship is a relationship between relation types. As discussed above a relation type is not a relation but is a set of attributes. Thus the relation types as such can not be represented or operated on within the model.

A third application area for which the relational model is not well suited and an increasingly commercially important one is numerical simulation or scientific computing. Simulation software is aimed at predicting the outcome of complex physical biological financial or other processes by building mathematical models and numerically solving the resulting equations. Defense petroleum exploration and medical imaging have been the classical applications for scientific computing. However as the price of numerical computation has dropped it is increasingly cost effective to use simulation in a wide range of applications. For example the manufacturing industry is replacing the conventional design build test redesign product development cycle with a design simulate redesign cycle. Similarly financial trading is directed by market simulations and major metropolitan TV stations produce their own weather simulations complete with computer generated animations.

Simulations combine features of spatial data and object oriented data. The results of the simulation usually represent the dependence of some property on space or time. For example the result may represent the dependence of mechanical stress on position within the product or a stock price on time or a temperature on location. Thus simulation data usually contains embedded spatial data representing the shape of the product the interesting intervals of time or the geography of the region of interest. In addition the space and time dependent properties computed are usually complex mathematical types with important IS A relationships between them.

In addition to sharing these features with spatial data and object oriented data simulation data has another essential feature which is the data sets tend to be very large. The amount of data that must be processed in a simulation is directly proportional to the desired accuracy. The quest for accuracy always requires that the simulations be run at or over the limits of the computational resource.

Another object of the present invention is to provide a novel data model which efficiently deals with spatial data object oriented programming applications and simulation applications.

Another object of the present invention is to provide novel algebraic operators which operate on the data model according to the present invention.

To achieve these and other objects the present invention provides a novel method of representing data on a computer including the steps of constructing a first table to represent an entity type with a column in the table for a respective attribute of the entity type and entering attribute data into rows of the first table. The method also includes the steps of constructing a row graph which represents an ordering relationship between the rows of the first table and assigning a column graph which represents an ordering relationship between columns of the first table. The column graph is a row graph from a second table.

The present invention also provides a novel data model including a first table to represent an entity type having a column in the table for a respective attribute of the entity type and having rows entered with attribute data and a row graph which represents an ordering relationship between the rows of the first table. Further the data model includes a column graph which represents an ordering relationship between columns of the first table in which the column graph is a row graph from a second table.

The above noted problems associated with the relational model i.e. using the relational model to represent spatial object oriented and scientific data all originate because the relational model provides no explicit mechanism for representing inclusion. Two Distinct Types of Inclusion are 

The theory of partially ordered sets may be used to address inclusion. A partially ordered set or poset as it is frequently abbreviated includes two components 1 a set of objects called the base set and 2 a reflexive antisymmetric transitive relation on the base set called the ordering relation. The ordering relation explicitly defines which members of the base set are included in each other.

The table analogy discussed above with reference to the relational mode can also be used to describe a partially ordered set. In this instance a poset includes a table and a directed acyclic graph. The table represents the base set and the graph represents the ordering relation.

For example illustrates a very simple spatial object comprising a single triangle including three vertices three edges and the interior space of the triangle .

If an entity A is next most inclusive to entity B there is no entity between A and B i.e. there is no entity C between A and B . Thus for any given entity there may be more than one next most inclusive entity. For example both edges e ID 3 and edge e ID 5 are next most inclusive to vertex v. Thus the meaning of the term partial order is that the members of the base set are ordered with respect to each other but not totally ordered so that every member has exactly one next larger member. In a partial order a member can have one next larger member many next larger members or no next larger members. The definition of a partially ordered set also includes the case in which every member of the base set has no next larger members. This corresponds to the ordinary unordered set.

In addition the ordering relation of a partially ordered set is often referred to by the phrase less than or equal to. For example in one can say v e which means v is included in e. The next most inclusive relation is often referred to as the covers relation and the graph is often called a Hasse diagram. 

All the operators of the relational algebra may be configured to work on posets. The effect of any of the operators on the table part of a poset is the same as in the relational case but each operator must be configured to also operate on the graph part discussed in more detail later .

In addition to the relational algebra operators there are a number of other poset operators that are derived from the order relation. Two poset operators will now be described in which it is assumed a a etc. are rows in a poset table A 

The name down set originates in the standard mathematical practice of drawing links so they point up. Thus if a1 a2 then a1 is below a2 in the graph smaller members are always below larger members. In such a vertical graph the down operator literally goes down the graph hence the name. To be visually consistent with the rows in the table the links in the graphs shown in the figures according to the present invention point from right to left and not in a downward manner .

The operators thus defined operate on entities specifically appearing in the table. In applications in which inclusion plays an important role it is often important to treat a collection of entities as if it was an entity itself a sort of virtual row in the table. For instance in spatial applications it is often important to deal with the boundary of an object. The boundary of the simple spatial object i.e. triangle shown in is a collection of three edges but it is often desirable to treat it as a single entity the boundary.

Lattice theory may be used to accomplish this. In more detail associated with every finite poset is another poset a special type of poset called a finite distributive lattice henceforth FDL or just lattice . shows the FDL for the simple spatial object shown in . The number of members of an FDL is typically much greater than the number of members of the poset that generates it. For simplicity and readability the graph is drawn in the traditional mathematical orientation i.e. in a downward fashion . Icons also show the geometrical meaning of each member of the lattice instead of ID attributes as used in previous figures.

For example icon illustrates the complete triangle including all members of the poset. Icon includes member IDs and which correspond to edges e and e respectively. Icon includes member IDs and which correspond to edge e and vertex V. Any icon below and connected to icon is included in icon .

Intuitively the lattice contains all the members of the original poset plus all distinct combinations of them. Two different combinations of members are distinct if they do not represent the same inclusion. For instance the combination of just edges e and e is distinct from the combination of edges e e and e since the former combination does not include all the points in edge e. Conversely the combination of the three edges is not distinct from the combination of the three edges and the three vertices. These two combinations edges and edges vertices are equivalent because the vertices are already included in the edges adding them to the combination doesn t include any additional points. Consequently the lattice in contains a single member for the boundary i.e. icon it does not contain separate members for the collection of three edges and for the collection containing three edges and three vertices. The lattice is not the set of all subsets of rows of the table. Thus the lattice generated by a poset is a poset itself and can be thought of using the table analogy similar to that shown in for example. The lattices table contains all distinct combinations of rows of the original poset and its graph contains all the inclusion relations. In addition in a lattice there are two additional operations defined. In the following operators l l . . . lare members of a lattice L. A first operator according to the present invention is the Join operator. In more detail the operator Join l l . . . l returns the smallest member of L which is greater than or equal to all of its inputs. For example referring to the Join of ID s and respectively shown in icons and results in the boundary of the triangle shown in icon . A second operator Meet l l . . . l returns the largest member of L which is less than or equal to all of its inputs. For example the Meet of ID s respectively shown in icons and results in the vertex v shown in icon .

Now to incorporate column inclusion into the model. To do this the table analogy is expanded so that there are two graphs associated with the table. That is a first graph as shown in hereinafter referred to as the row graph and a new graph hereinafter referred to as the column graph . The column graph describes the inclusion structure of the columns.

In the sheaf data model every lattice has an associated lattice which is referred to as a schema. The column graph of a lattice is defined by the row graph of its schema. The schema relationship is recursive a schema lattice has to have a schema lattice. This recursion is terminated in a special lattice the primitive schema lattice which is its own schema.

The lattice of the triangle shown in and its corresponding schema lattice are shown in respectively. illustrates the lattice including a row graph column graph and table . The table includes columns and respectively corresponding to an ID NAME AND GEOMETRY of the entity type. illustrates the corresponding schema lattice . The schema lattice includes a row graph column graph and table . The table includes rows and respectively corresponding to the columns and of the lattice shown in .

Thus using the schema lattice it is possible to determine the variable type of the primary entities in the rows of the table . For example referring to table ID number corresponds to edge e of the triangle shown in . Referring to the schema lattice it is possible to determine the ID number is an integer type with a size of 4 bytes. Similarly the name e is a string type with a size of 4 bytes and the geometry edge is also a string type with a size of 4 bytes.

The association between a lattice and its schema introduces three more operators. An exponentiation operator EXP L returns a lattice with schema L. The table and row graph of the result are empty. A logarithm operator LOG L returns the schema lattice associated with lattice L. A restriction operator RESTRICT L TO s where s is a member of the schema of L returns the projection of L onto the columns in the down set of s.

Turning now to sheaves. The table of a lattice L is the Cartesian product of the rows of the schema lattice where each row is interpreted as a domain. By using RESTRICT L TO s successively for each member s of the schema lattice we can define a family of tables one for each member of the schema. Each member of this family is itself a Cartesian product over a subset of the rows of the schema lattice.

An association or map generated in this manner between a lattice and a family of Cartesian product sets is called a sheaf. The schema lattice is referred to as the source of the sheaf and the family of product sets is referred to as the target of the sheaf. The largest member of the target the table which is restricted to produce all the other members of the target is called the top table.

The row graph of the top table is not defined by the schema. It can be arbitrarily chosen by the user. Once the row graph is defined the top table defines an FDL and can itself be used as the schema for another lattice.

Hence every lattice defines a sheaf of Cartesian product sets tables and this sheaf can be viewed as the primary object of the data model. The table row graph and column graph as well as the relational poset lattice and sheaf operators can all be considered different aspects of the sheaf object. This is the origin of the name sheaf data model.

The sheaf structure and operators introduce column inclusion into the data model but they also add an additional critical feature which is a data dependent schema. The schema of a table is defined by the contents of another table not predefined to some fixed set of columns. This feature is essential for representing simulation data.

As discussed above all the operators of the relational algebra can be generalized to work on either an FDL or a sheaf. The typical effect of any of the operators on the table part of an FDL or sheaf is the same as in the relational case but for an FDL each operator must be configured to also operate on the row graph while for a sheaf each operator must be configured to also operate on both the row graph and the column graph. The appropriate configuration for each of the six basic relational operators is discussed below.

1 The Cartesian product operator. For the FDL configuration the table of the result of the Cartesian product A B where A and B are both FDLs is the same as for the relational configuration.

The row graph is arbitrary and may be chosen to be any order relation the user desires. However there are two common and important choices. Let a b and a b be two rows in the product table 

For the sheaf configuration the table and the row graph of the result of A B where A and B are sheaves is the same as the FDL configuration. The column graph schema of the result is the disjoint union of the column graphs of A and B.

2 The selection operator. For the FDL configuration the table of the result is the same as for the relational operator. The row graph is a graph which satisfies the row selection condition specified as follows let g0 be the reflexive transitive closure of the row graph of the input and let the g1 be the subgraph of g0 containing the nodes corresponding to the set of rows which satisfy the selection condition and all the links which reference only nodes corresponding to the selected set. The graph which satisfies the row selection condition is the reflexive transitive reduction of g1.

For the sheaf configuration the table and the row graph of the result is the same as the FDL configuration. The column graph of the result is the same as the column graph of the input.

3 The projection operator. For the FDL configuration the table of the result is the same as for the relational operator except duplicate rows are not discarded. The row graph of the result is the same as the row graph of the input.

For the sheaf configuration the table and the row graph of the result is the same as the FDL configuration. The column graph of the result is a graph which satisfies the column selection condition specified as follows a graph satisfies the column selection condition if and only if it is the graph formed as the result of the selection operator with a row selection condition corresponding to the column selection condition operating on the row graph of the schema sheaf of the input.

4 The union operator. For the FDL configuration the table of the result is the same as for the relational operator. The row graph is the reflexive transitive reduction of the union of the row graphs of the input posets where the union of two graphs is the graph formed by the union of the node sets of the two graphs and the union of the link sets of the two graphs.

For the sheaf configuration the table and the row graph of the result is the same as the FDL configuration. The column graph of the result is the same as either of the column graphs of the two inputs which must both have the same column graph.

5 The intersection operator. For the FDL configuration the table of the result is the same as for the relational operator. The row graph is the reflexive transitive reduction of the intersection of the row graphs of the inputs where the intersection of two graphs is the graph formed by the intersection of the node sets of the two graphs and the intersection of the link sets of the two graphs.

For the sheaf configuration the table and the row graph of the result is the same as the FDL configuration. The column graph of the result is the same as the column graph of either of the inputs which must both have the same column graph.

6 The rename operator. For both the FDL configuration and the sheaf configuration the rename operator is the same as in the relational model.

In summary the sheaf data model provides a formal mathematical data model and explicitly incorporates inclusion. The algebra associated with the model contains relational poset lattice and sheaf operators which provide the basis for a complete data definition and manipulation language.

The sheaf structure and its operators form an extremely useful abstraction. However the sheaf structure suffers from a severe practical problem. In more detail the source of a sheaf is the finite distributive lattice FDL containing all possible distinct combinations of members of a client defined poset. The problem is even for very small posets the number of all possible distinct combinations of rows is astronomical. It is completely infeasible to generate and store the entire source lattice. For the same reason it is infeasible to store the target of the sheaf i.e. the family of product sets .

The present invention solves this problem by combining data structures and algorithms to utilize the sheaf concepts without actually generating the entire source and target. This combination is referred to as the finite sheaf data type. In order to understand this data type a few facts about FDLs will now be introduced.

As discussed above an FDL contains the members of the original poset and all distinct combinations thereof. The members of the original poset are referred to as the join irreducible members or jims of the lattice while the distinct combinations are join reducible members or jrms pronounced germs .

Based on a Birkhoff representation theorem a jrm is equal to the join of the collection of jims contained in its down set this collection of jims is the distinct combination associated with the jrm. 

From the usual mathematical point of view an FDL is a given pre existing base set and ordering relation i.e. a fully instantiated table and graph . Every member of the lattice is represented by a row and a node in the graph every inclusion relationship is represented by a path in the graph. From this point of view the Birkhoff representation theorem is a statement about a relationship that must exist between the nodes and links of the graph. The Join and Meet operators are queries that find the proper member using the fully instantiated graph.

The fundamental mechanism making it practical to use the sheaf formalism is a form of deferred computation or lazy evaluation. Instead of mimicking the mathematics and instantiating the entire lattice the present invention instantiates the jims and only the jrms the user specifically requests. This approach reduces the storage requirements to feasible levels but forces extension and reinterpretation of the mathematics.

Turning now to a finite sheaf data type the finite sheaf data type henceforth finite sheaf or just sheaf includes a data structure and a collection of operators on the data structure that implement the lazy evaluation strategy described above.

The interpretation of this data structure is that the table represents the top table of the sheaf defined by the schema. Each row in the table represents a jim in the row lattice of the top table. The row graph represents the order relation for the row lattice. Nodes in the graph which correspond to rows in the table represent jims in the lattice while the remaining nodes represent jrms. The links in the graph represent the next most inclusive relation also known as the cover relation in mathematical lattice theory . The collection of jims associated with each jrm by the Birkhoff theorem is generated by traversing the graph below the jrm.

In the usual mathematical formulation of an FDL each member is unique. But in practical computing applications a user may want to have multiple copies of a lattice member. The data structure supports this by having the graph represent a lexicographic ordering relation. A lexicographic ordering relation is a generalization of the order words appear in a dictionary. Words are first ordered by their first letter. All words with the same first letter are then ordered by their second letter etc. The first letter in the finite sheaf order is derived from the Birkhoff theorem. Member lis less than the member lif the set of jims in the down set of lis a subset of the set of jims in the down set of l. The second letter is the order the members were created in. Lattice members which are copies have the same set of jims in their down set the same first letter and are ordered relative to each other by the second letter in the order they were created in.

The table and graph combination stores all the jims of the row lattice but only those jrms that the user specifically creates.

The finite sheaf data type supports all the relational poset lattice and sheaf operators of the sheaf data model as described above. In addition the finite sheaf data type extends and reinterprets the mathematics as follows 

First the set of operators must be extended to include operations for creating the jims and the order relation 

CREATE LINK LESSER ID GREATER ID creates a link in the graph between the jims identified by lesser id and greater id.

DELETE LINK LESSER ID GREATER ID deletes the link between the jims identified by lesser id and greater id.

Second the join and meet operators must be reinterpreted. Mathematically the result of these operations is guaranteed to exist and hence these are query operations. They find the proper member using the order relation i.e. row graph. But if only previously requested jrms have been instantiated then the result of a meet or join may not exist. The result has to be created and linked into the graph. In other words instead of deriving the result from the order relation the order relation must be derived from the result. Efficient algorithms for computing the join and meet are described in appendix A which is incorporated in its entirety.

Problems of practical interest require the table and graphs associated with the finite sheaf type to be stored on disk outside of the main memory of the computer. Efficient access to such externally stored data must take into account the properties and performance characteristics of disk storage. This problem has been extensively studied in the context of relational data base management technology.

The standard solution relies on constructing hierarchical index structures which allow retrieval of any record with a minimum number of disk accesses. The best known index structures are the B tree and its variants. Nodes in the B tree correspond to hierarchical groupings of records in the table.

The key to efficient indexing of the finite sheaf is the following observation the hierarchical groupings of the B tree are jrms in the row lattice. They are jrms chosen specifically to optimize disk access. Hence the row graph itself can be used as an index. In addition to the jrms explicitly constructed by the user internal routines of the finite sheaf type can construct jrms intended purely for use in achieving efficient disk access.

Turning now to applications which may use the sheaf data model. The mathematical study of spatial structure is organized into two broad disciplines. Topology is the study of continuity nearness and connectivity without regard to explicit shape and size. Geometry adds shape size and measure to topology. The theory of topology can be formulated entirely in terms of lattice theory. Furthermore recent research in computational geometry has established that all existing methods of geometry representation can be described using finite distributive lattices. The sheaf data model provides a direct realization of this mathematical structure and hence is ideal for storing and manipulating spatial data.

There is however an additional operator not described above that is particularly convenient for creating instances of the finite sheaf type representing spatial data. Spatial data often appears in the form of a mesh a large number of interconnected geometric primitives all the same type or of related types. As a simple example the shape of a product may be specified in a CAD CAM system by a triangle mesh a large number of triangles connected together at their edges so as to cover the surface of the product. Such meshes are even more common when spatial data is used in the context of a simulation.

Mesh data is usually presented by specifying the number and type of the geometric primitive and by specifying the so called connectivity data. The connectivity data describes how the primitives are to be connected typically by listing the vertices that appear in each primitive. So a triangle mesh could be specified by stating the number of triangles then specifying 3 vertex identifiers for each triangle. Two triangles are implicitly connected at a point if they both contain the same vertex and connected at an edge if they share two vertices.

The additional operator is the cellular lattice constructor that makes it convenient and efficient to build the table and graph of the lattice corresponding to a mesh given the usual input data. An algorithm for an efficient cellular lattice constructor is given in Appendix B which is incorporated in its entirety.

Recent research in computer science has demonstrated the inheritance relationships between classes in an object oriented application generate a mathematical lattice. The sheaf data model is thus able to directly and precisely represent inheritance relationships.

Object containment relationships can be divided into two categories cyclic and acyclic relationships. In a cyclic relationship A contains B contains C contains . . . contains A. In other words the chain of relationships eventually forms a circle. In an acyclic relationship the chain is linear. The sheaf data model as stated represents only acyclic containment relationships.

As discussed above simulation results typically represent the dependence of some property on space and time. In mathematical physics such space and time dependent properties are called fields. The abstract fields of mathematical physics can be represented by sheaves. An important part of the present invention described here is the method by which the concrete field data of numerical simulation can be interpreted as a sheaf.

A field is a map that associates a value of some property called the fiber space with every point in some object called the base space. Both the fiber space and the base space can be represented as finite sheaves. The representation of an abstract field as a finite sheaf requires the following information be provided 

The schema for the sheaf of fields with a given base space and fiber space is the tensor product lattice of the discretization and the fiber space schema. The jims of the tensor product lattice are all pairs of the form d f where d is a jim of the discretization and f is a jim of the fiber space schema. As with any finite sheaf there is a column in the table of the sheaf for each jim in its schema. The domain of the column associated with schema jim d f is defined to be the domain of f the domain of d is ignored. A field is represented by a row in the table and the data in the cells of the row is referred to as the degrees of freedom of the field. The degrees of freedom associated with any pair b f where b is a member of the base space lattice and f is a member of the fiber schema is the restriction of the row to the schema member d b f where d b is the discretization of b.

Any numerical representation of a field can be interpreted as a sheaf using the above method. The ability of the sheaf data model to directly represent arbitrary fields in addition to traditional relational data spatial data and object oriented data makes it an ideal model for scientific data.

This invention may be conveniently implemented using a conventional general purpose digital computer or microprocessor programmed according to the teachings of the present specification as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

The present invention includes a computer program product which is a storage medium including instructions which can be used to program a computer to perform a process of the invention. The storage medium can include but is not limited to an type of disk including floppy disks optical disks CD ROMs and magneto optical disks ROMs RAMs EPROMs EEPROMs magnetic or optical cards or any type of pure software inventions e.g. word processing accounting Internet related etc. media suitable for storing electronic instructions.

Obviously numerous modifications and variations of the present invention are possible in light of the above teachings. It is therefore to be understood that within the scope of the appended claims the invention may be practiced otherwise than as specifically described herein.

By definition the result of the join operation is a jrm. A jrm is defined by the intersection of its down set with the set of jims J. In our case a jrm g is presented as the join of the members of a client specified subposet S. The jrm g is then defined by intersection of the down set of S with the set of jims J.

Since the construction intersection of the down set of x with J occurs frequently in the following it is useful to define a notation for this set down where x is either a member p of the lattice or a subset S of the lattice

In order to place g in the existing cover relation graph we need to find the maximal lower bound and minimal upper bound for g in the existing graph. The maximal lower bound is the set of maximal members that are less than or equal to g while the minimal upper bound is the set of minimal members that are greater than or equal to g. If g is already in the graph the maximal lower bound will contain a single member the greatest lower bound which must be equal to g. Similarly the minimal upper bound will contain a single member the least upper bound which also must be equal to g. If g is not in the graph the maximal lower bound is the lower cover for g and the minimal upper bound is the upper cover for g.

J S is computed by a straight forward traversal of the down set of S. A bottom up algorithm for computing the maximal lower bound and an algorithm for computing the minimal upper bound follow.

The maximal lower bound is the set of maximal members of the down set of g. Thus to place g in the cover relation we must compute the maximal members of the down set of g. This is the inverse of the usual definition of the down set where we are given g and the cover relation and can find down g by transitivity of the cover relation. Here we are given only down g J and must find all other members g such that down g J is included in down g J.

The client defines the jrm g by specifying a join expansion i.e. some subposet s. Then J g is defined to be the set of jims contained in a depth first traversal of the stored cover relation starting at s. That is J g is derived from the existing cover relation.

We maintain two subposets gdown for the down set of g and gdown max for the maximal members of the down set. Both are initialized to contain J g . We then repeatedly reduce gdown max as follows 

Let gdown max up be the upper cover of gdown max i.e. the union of the upper covers of the members of gdown max. Let g be a member of gdown max up. If g is a jrm and the lower cover of g is included in gdown then J g is included in J g Lemma 1 and hence g 

At each step of the above process we have that gdown contains only members of the down set of g and at each step the set of maximal members is reduced by replacing some members in it with larger members. The process does not complete until all the members of gdown max are maximal. Further more all members of down g are reachable by this process Lemma 2 . So when the reduction completes it contains the all maximal members of down g that are present in the graph. If gdown max contains a single member it is g itself otherwise gdown max is the lower cover of g.

Let s1 s2 . . . sn denote the members of S. Define two cover sets C0 and C1. Initialize C0 to up s0. Then 

Now the condition J p J g will be satisfied if and only if the condition J p J g for all p p.lower cover. In other words the condition is recursive.

As above if g is not already in the graph insert it between the minimal upper bound and the maximal lower bound.

Birkhoff representation theorem states that any jrm is equal to the join of the jims contained in it. Let S l l . . . l be a subset of a lattice L. Then the jims of c meet S are given by so we have meet join . . . 

The meet operation thus reduces to a combination of set intersection operations and a join operation. The set intersection operation is standard the join algorithms are given above.

A cellular lattice is constructed by making copies of a template and gluing the copies together. The copies are glued together by specifying which members in one copy are the same as members in another copy. The members which are thus glued together are the atoms of the template the members of the template which form the upper cover of the bottom member.

