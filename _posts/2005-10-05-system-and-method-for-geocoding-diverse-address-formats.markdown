---

title: System and method for geocoding diverse address formats
abstract: A method and system for providing geocodes in response to complete or partial address information is disclosed. The disclosure teaches embodiments that are naturally upgraded to integrate changing spatial information due to addition of countries, better data, political changes, and other similar changes in geographical data. A single geocoding engine is capable of handling the various address formats in use in different countries and jurisdictions. The disclosed embodiments are error tolerant and capable of overcoming many errors due to spelling, variety of languages and formats used to provide and address. The diversity in addresses due to, for instance country-specific formats such as postal-codes are naturally integrated into existing database of geocoding information. Preferably, the embodiments are based on JAVA to allow platform independence and use XML based communication to use networks without requiring excessive resources while providing fast services.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07685108&OS=07685108&RS=07685108
owner: Pitney Bowes Software Inc.
number: 07685108
owner_city: Troy
owner_country: US
publication_date: 20051005
---
This application is a divisional of U.S. patent application Ser. No. 10 159 195 filed May 31 2002 now U.S. Pat. No. 7 039 640 which claims priority to U.S. provisional Application No. 60 295 103 filed on May 31 2001 by Julia Miller and Chuck Schwerin and entitled SYSTEM AND METHOD FOR GEOCODING DIVERSE ADDRESS FORMATS which are incorporated herein by reference in their entireties.

Although the development of the Internet suggests that the world is becoming more connected hence smaller and less dependent on geographical data in fact the new possibilities enabled by the new technologies make geographic information more valuable. It is increasingly important to develop databases that are compatible with the various diverse formats for street level addressing to zip codes in use in the world. Geographical information is now playing a major role in providing mission critical information about clients products physical assets and other information that enhances the corporate bottom line. Even consumers who find products on the Internet often want to avoid paying unnecessary tariffs or to locate the closest outlet or service point for a product.

Thus low cost geographical information also termed spatial information is significant for the expansion of commerce and free trade by allowing seamless integration of the various local address formats into an evolving and widely accessible database suitable for integration with other product and service details. Once relegated to the back office and proprietary systems due to complexity and cost new technologies have enabled integration of spatial information into mainstream Relational Database Management Systems RDBMSs where it can serve an enterprise business need cost effectively. Spatial data related RDBMSs support storing managing accessing and updating spatial data. The Internet has provoked a steep increase in demand for data analysis presentation and representation with maps spatial data being but one component. As a result we have seen the introduction of a variety of technology solutions for example HTML XML ASP JAVA and COM that help meet the demand.

Some of the applications of spatial data include routing geocoding the process of generating latitude and longitude information corresponding to a geographical location reverse geocoding generating a geographical location such as an address from corresponding latitude and longitude information mapping finding a geographically nearest location of interest acquiring position and the yellow pages. Typically a geocode represents a particular geographic area. Preferably a grid defined by longitude and latitude coordinates defines a geocode corresponding to a location of interest on the surface of the earth. Alternative examples of geocodes include zip codes as used by the United States Postal Service.

Such spatial data has additional significance. Ready knowledge of the location of its assets markets clients distance and time required for shipping goods geographic relationships between clients assets products and the like is valuable to a company. The company might be further interested in finding all customers contained within a particular service area for target marketing a new product or service available in that area. For instance if the service area boundary changes then the customers remaining in a particular service area and the ones moved to a new service area are of interest. Instead of visiting each customer record to determine the new service area the spatially enabled system allows one to simply change the service area boundaries perform a new query with the contain or overlap function and let the system do the work for you.

An example of software for associating geocodes with other business data is provided by SpatialWare from the Mapinfo Corporation which provides spatial data processing within an RDBMS environment. This system creates a tightly integrated solution with the database allowing the user access to spatial extensions within the normal database environment and its tools. Thus users and administrators can perform the majority of database tasks such as determining driving directions to a desired destination from within the normal tools provided by the database vendor.

Another example of spatial data applications is provided by mobile location services for locating and servicing customers on the move. With the aid of such capability one may offer a discount to customers who happen to be within a defined distance of a store via a wireless device or survey people for their responses or recollections of a significant event within a defined distance and time of the event taking place. In such applications it is important to rapidly locate a customer and estimate the layout of a particular geographic area. In an example of applying spatial technology an insurance company could rapidly determine the addresses and identities of its customers affected by an event of interest and respond rapidly to provide customer satisfaction with lower transaction costs. Other applications include preparing dynamic and interactive maps representing prevalence of cancers and other diseases provided online or designating areas for a franchise to best cover a targeted market making maps for a new area and the like. In these and other applications the use of sufficiently well resolved geocodes in general is superior to relying on mere addresses even with zip codes since rapid and effective search techniques available at a desired spatial resolution e.g. using a suitable R tree described below .

Locating an address or any other object of interest or a customer can be accomplished by generating a geocode e.g. a latitude and longitude specifying a position on the surface of the earth or a postal code such as the United States Postal Service Zip code and other variants. Creating a displayable map corresponding to a collection of geocodes involves associating a graphical display object such as point objects line objects and area objects with a geocode. Displaying an ordered set of graphical objects corresponding to selected geocodes renders a corresponding map to a user. Examples of such maps include the familiar driving directions for going from one location to another that are now available for most regions in the United States. These are not surprisingly often found in conjunction with Internet sites providing advertising or location information.

All of the above applications require not just cataloging but also looking up spatial data repositories. Spatial data can be advantageously indexed or otherwise organized to enable efficient searches. For instance the R Tree index organizes records by the geographic extent of each object. Objects can be grouped together and described as being contained within a larger rectangular space. The size of each space is dependent upon the number of objects in that space. As the number of objects increases the space can be further split into two or more sub spaces thus reducing the number of objects in each new area. The process continues until the entire geographic extent of the data is covered and the number of objects related to each area is approximately equal.

Underlying all of these applications is the need to collect and organize geographical information. Preferably addresses and maps corresponding to the entire world need to be entered into a suitable database in view of the increasingly integrated world economy and the global reach of the Internet. Typically a geocoding engine is implemented in a client server architecture to respond to a request for one or more geocodes corresponding to a particular address. In the alternative such an engine may be provided geocodes and a corresponding address requested. Not surprisingly such a system has to be scalable to maintain responsiveness under the load of multiple concurrent requests.

The extraordinary diversity of the formats for addresses in the world with multiple geocode formats within even a single nation along with the various languages in use presents a formidable problem in constructing and deploying a common geocoding engine. Since a request to obtain a geocode corresponding to an address in one nation may be received in another nation with a different addressing system or even language integration of all of the geographical information of interest is difficult with many nations being too small for a dedicated geocoding engine while others are too diverse to be served by just one conventional geocoding engine.

Cost effectiveness requires efficient geocoding engine s that can handle diverse types of geocoding requests. This goal introduces performance penalties since the different address formats increase the computational overhead both while retrieving addresses or geocodes from a database and in building or updating the database itself. Alternative addresses present yet another challenge since it is possible even within the same system to specify an address in more than one way based on little more than personal style. In addition partial addresses and degenerate addresses e.g. multiple cities and streets with the same name or similar names require an efficient look up strategy to identify a best match. Examples include the many ancient cities referred to by their various names such as Varanasi INDIA is also termed as Kashi INDIA or Benaras INDIA. This diversity is compounded by the deliberate changes in names of cities or streets in response to political pressures.

The present invention provides a system and method for handling and communicating geocoding requests seeking or updating spatial information. The disclosed method provides geographical information to a plurality of users employing a plurality of formats by encoding geographical data to generate default data in a parent class that may be customized via an overriding sub class. The class implementing parser matcher interpolator or data access is preferably determined based on a country code in the request. This country code may be explicitly or constructively specified with appropriate defaults allowed.

A geocoding engine constructed in accordance with the invention reduces the overhead while providing for coordination in handling requests containing multiple address formats and updates in spatial information. A single geocoding engine is capable of handling requests comprising a variety of address formats and constraints. The engine preferably includes modules for detecting a country code designation invoking a parser corresponding to a country code detecting a postal code detecting a world city name in the received request obtaining a candidate list invoking a matcher module for evaluating the candidate list and invoking an interpolator for generating a geocode corresponding to a selected candidate.

A system in accordance with the invention provides spatial information to a plurality of users with the aid of a generic Matcher module a customized local Matcher module a generic interpolator module a customized interpolator module one or more servlets for managing local requests by preprocessing and forwarding input received from and output sent to a client. The geocode engine coordinates Interpolator Matcher and databases by determining whether customized data is available in preference to default data.

Advantageously a multithreaded design is employed to provide a stable implementation that can process and allocate resources for batch as well as individual requests. Moreover communication of geocoding requests data and results is facilitated by the use of XML code words disclosed herein i.e. elements and attributes for communications across networks.

The invention provides a system and method for geocoding on a wide variety of platforms and processing international address data in a variety of formats. A preferred embodiment of the invention executes on any platform providing support for the widely available JAVA virtual machine JVM .

The invention provides a JAVA based geocoding solution that is portable and suitable for international geocoding. Use of a flexible binary data format allows any type of address data to be stored. In addition a data creation utility provides international users with a method to put country specific data in the binary format available for use in geocoding with a minimum of additional effort.

An embodiment of the invention creates a multi threaded platform independent geocoding engine written entirely in Java incorporating worldwide generic components for address matching parsing and interpolating a data access component that enables it to read addresses from a database in a binary format as well as country specific Java classes whose address rules supercede those of the worldwide classes. An example organization of a database is to store data in data structures such as folders objects corresponding to the country code to ensure consistent retrieval of the data. Moreover the data structures may in some embodiments be organized to allow overriding subclasses to update the data or organized in databases with the country codes as keys for searching and accessing the data.

It is desirable that modifications of or extensions to a geocoding engine allow continued use of existing Geocoding API Application Programming Interface specifications. At the same time these are necessarily modified to handle additional requirements imposed by the increased diversity in the address types handled both by supporting partial or alternative addresses and International addresses. The disclosed invention allows construction of embodiments that are suitable for continuous modifications in a constantly changing world. The efficiency gained by the use of fewer geocoding engines to handle diverse address types in queries enables better service.

In another aspect it is desirable that a geocoding engine be capable of being implemented on machines supporting single or multi threaded computations. A thread safe design not only makes the engine stable but also allows multiple requests to be dispatched concurrently thus requiring fewer engines to service a large volume of geocoding requests. Moreover the engine may be implemented on machines having more than one processor.

In another aspect a geocoding engine in an embodiment of the invention is capable of further efficiency by geocoding a single address or accepting and geocoding a batch of addresses. This reduces the volume of independent requests and makes the task of obtaining geocodes or updating databases easier for remote users of the geocoding engine. Moreover batch geocoding requests can be better processed with improved allocation of resources in a multi threaded design.

Although in the example embodiment spatial information is as limited as the geocode point passed as a response to a geocoding request additional spatial information may be included in alternative implementations. It should be noted that spatial information is readily transmitted after encoding in XML since there are available definitions for simple geometric objects suitable for geographical information in the form of the Geography Markup Language presently in version 2 and available from http www.opengis.net gml 01 029 GML2.html at the time of filing of the application that is incorporated herein by reference in its entirety. Thus coordinates shapes such as streets blocks and the like are readily communicated via XML i.e. GML across networks without requiring extensive resources associated with images in general. In addition elements have been defined to better manage communications over the network for more particular operations and parameters than general geographical information.

Some particularly suitable XML elements the names and parameters and their special values presented as attribute list ATT LIST introduced for handling such information are described in Appendix A. An example non exhaustive set of such XML elements one or more of which may be employed to transmit geocoding information consists of XML comprising at least one of the members of the set of elements consisting of RequestEnvelope ResponseEnvelope USA GeocodeRequest USA ParsedAddress USA StreetAddressData AddressNumber PreDirectional PostDirectional StreetBase PreThoroughfareType PostThoroughfareType USA GeocodeConstraints AddressConstraints AddressCloseMatchConstraints MustMatchHouseNumber MustMatchStreet MustMatchZipCode MustMatchCity MustMatchInput SearchRadiusExtension DistanceFromCorner DistanceFromStreet ZipConstraints GeographicAreaConstraints GeographicAreaCloseMatchConstraints MustMatchUrbanization MustMatchCounty MustMatchState PointOfinterestConstraints CASSConstraints USA ResponseConstraints MaxCandidates SuccessResponse FaultResponse USA GeocodeResponse USA GeocodeLocationList USA GeocodeLocation USA GeocodeFaultResponse FaultMessage and FaultCode.

XML elements may also be viewed in the context of their function and or implementation. In accordance with such an example classification scheme XML elements may be described as belonging to one or more of the following categories 

Package information which includes elements such as RequestEnvelope ResponseEnvelope GeocodeRequest SuccessResponse FaultResponse ResponseCode Message GeocodeSummary RequestResult and GeocodeRequestType.

Generic address components which includes elements such as InputAddress Address AddressConstraints AdditionalFields AddressNumber AreaName1 AreaName2 AreaName3 AreaName4 Country GenericField1 GenericField2 GenericField3 GenericField4 MainAddress placeName postAddress postCode1 postCode2 postDirectional postThoroughfareType preAddress preDirectional preThoroughfareType unitType unitValue and Candidate unitsOfMeasure. These elements assist in communicating information about various administrative designations in an address of interest.

Response Constraints which includes elements to help tune the scope and nature of the geocoding process. Some example elements include as ReturnCloseMatchesOnly IncludeRequest IncludeParsedAddress IncludeActualConstraints MaxRanges maxCandidates offsetFromCorner offsetFromStreet and CoordinateReferenceSystem.

Matching constraints dictate the restrictions placed on the generation of the requested geocodes typically to avoid waste of resources and or ensure a best match. Examples include elements such as FallbackToPostalCentroid closeMatchesOnly fallbackToGeographicCentroid GeocodeConstraints BaseConstraints and AdditionalConstraints.

Matching quality information which includes elements such as addressNumberMatched areaName2Matched areaName1Matched areaName3Matched areaName4Matched countryMatched genericField1Matched genericField2Matched genericField3Matched genericField4Matched postCode1Matched postCode2Matched streetNameFieldsMatched placeNameMatched matchprecision TotalLocationsFound TotalLocationsReturned and TotalCloseMatchesFound.

DEU Country specific address components which includes elements related to specifying German addresses. Similar country specific address components are possible for other countries with each potentially meriting such individualized attention within the dame geocoding engine setup by the methods and system of the described invention as DEU AddressData Hnr Postfach Pirma Str PIzOrt DEU AddressGeographyData PLZ Ort Country MustMatchPlz MustMatchHnr MustMatchOrt MustMatchStr MustMatchInput DEU GeocodeFaultResponse DEU GeocodeLocationList DEU GeocodeLocation DEU GeocodeResponse DEU GeocodeLocationList DEU ParsedAddress and DEU GeocodeConstraints.

It should be noted that the listed elements along with their attributes are illustrative and not exhaustive. Moreover variations without departing from the spirit of the invention are intended to be included within the scope of the invention.

Notably response to a successful geocode request includes a response without any candidates since a correctly formed request that generates no candidates is not considered a fault. In a preferred embodiment response to a geocode request containing a fault is handled differently by throwing an exception. In this context a fault means that there was a condition that prevented the geocode engine from running.

The proposed XML elements have the advantage of communicating geocoding requests the form of envelope desired for sending or receiving a request the data relevant for making particular requests and constraints on both the requests and results that a user may desire to impose. Appendix B to this disclosure includes a description of JAVA based classes for a possible implementation of an embodiment of the invention.

User may also specify parameters associated with the address specification. Not all data retrieved from Data Access for instance Local.Data that preferably reflects local country specific features will satisfy the specified geocode constraints. Consequently the retrieved data is subject to processing by Matcher that is preferably also specific to the country code although a generic matcher is available for customization. This specificity allows for inclusion of local address peculiarities into the matching process by allowing scoring of meaningful matches with lower computational and maintenance overhead while ensuring easy upgrades. The output of Matcher is further processed by Interpolator that is also built by further customization of a generic version to obtain local version.

The system also includes one or more facilities for inputting data for continued upgrading and expansion of the range and types of geocodes and addresses. Accordingly for instance Local Data Creator collects address data and geocode data that is input for instance optionally as an XML message to Data Constructor . It should be noted that a geocoding engine does not require data encoded in any version of XML. Indeed data creators may choose any data encoding format. XML provides an increasingly popular means for communicating data to the geocoding engine and receiving data from the geocoding engine. Data Constructor can also retrieve existing data in TAB format from Original Local Data . Data Constructor then provides data to build Local Data that is particularly useful in contexts of interest. The country code specified in a user input allows navigation of data to locate data corresponding to the country code. In the absence of a country code generic data access is still possible with the aid of a default country code assignment.

The format of the data is flexible and may be changed in different implementations of the invention without departing from the invention. The use of a preferred binary format to represent data provides security by making the data less transparent while reducing the need for separate encryption of data during transmission or storage. This format also satisfies international encryption requirements as well as maximizes geocoding speed. The design of customizable parser matcher interpolator and data storage with the aid of JAVA classes allows use of small footprint implementations that are further customized by merely overriding a parent class to introduce new data or functionality hence customization reflecting a country or political changes.

This flexibility allows capability for geocoding at postcode city street point of interest level or any other geographic centroid level. Advantageously the Geocoder assumes that a country code is one field being passed in unless a default code exists in metadata. Moreover a country code need not be provided if all addresses exist in the same country or satisfy the same addressing pattern or if geocoding is based on recognizing names of cities particularly well known cities.

As described above a geocoder consists of several modules including a parser a matcher an interpolator a data access piece and the geocoding engine. Although a Graphical User Interface GUI is not required it is advantageous to include a GUI for a more user friendly product design. A Java GUI is preferred to the continued use of Windows GUI to ensure portability of the product across various platforms. Moreover users of a Java GUI may optionally connect via JServer Client and JServer Servlet or directly to Engine via an API.

Different versions of the geocoders may be limited to one or a few countries including for the purpose of testing without departing from the spirit of the invention. Moreover the geocoding ability may be restricted such as in only providing address and postal geocoding.

Preferably the GUI for the Local Data Creator is separate and need not be available to the typical user e.g. User . The data creation routine is among other things useful for creating data for a particular country. Subsequently such data may be packaged in an integrated product. Of course some users may also want the data creation portion in order to create their own data files. The data creation utility is independently useful for setting up localized data for instance a customized dictionary functionality.

For country data in TAB format the data creation utility has an interface that enables data creators to describe the structure of the data. Accordingly a data creator e.g. Local Data Creator of indicates columns for street segment range and unit portions of the street data as well as centroid information mapping of geographic areas to search area codes and so forth.

Typically the parser accepts an UnrefinedAddress object and return a ParsedAddress object. In view of the diversity of address formats in the world there is no generic address parser. Therefore a suitable parser has to be created or instantiated for each country or jurisdiction s sharing a common addressing format. In the absence of a specified country a default country specification may be employed to invoke a default parser.

To add a new country data is preferably created from TAB files using the data creation utility. An address parser is also provided along with the creation of a country specific version of GeocodableAddress that indicates the parser to be used. Moreover the existing Data Manager Matcher Interpolator and CandidateAddress are usable for the new country or further customization is possible by subclassing them to enhance or change the default functionality.

The data constructor e.g. Data Constructor of also creates a country specific GeocodableAddress object such as a USAGeocodableAddress object corresponding to USA. This object can use all the methods of the base class and provides a constructor as well as sets the parser class name. Of course GeocodableAddress functionality can be further extended or changed with no loss of generality.

In another aspect J Server servlets e.g. JServer Servlet of may pass requests off to specialized servlets depending on type e.g. the street address geocode requests may be handled by a servlet different from that handling a postal centroid request . These specialized servlets each have their own process space and each servlet has its own DataManager. The number of such specialized servlets is small. Moreover they may be on different machines providing a natural network compatible implementation. In this regard it should be noted that functionality of Servlet of includes the functionality of the specialized servlets described above.

The first request from a servlet to the engine classes causes the DataManager for the local data to be started with concomitant reduction of waiting time for users due to intitialization of the DataManager. Once created the DataManager is available for subsequent calls without further initialization.

Advantageously user preferences are communicated by use of a GeocoderConstraints object that itself may be customized for each country. As the engine receives a request from a user it first invokes the parser then the DataManager to get candidates the Matcher to rank the candidates and finally the Interpolator to position the points for providing a result to the user.

As previously described for extending the default functionality of the geocoder or changing default behavior a localizer has the option of extending the provided classes. CandidateAddress can be extended to hold specific data or just to access the generic data differently for instance getStreetName instead of getString 3 .

The matcher can be extended to customize how matching is done instead of just checking exact match on fields. For example if the street type does not match but everything else does some users may want to consider this a better match than one where the house number is incorrect but everything else matches.

If there are special rules for house positioning on a street the localizer may wish to derive a specific Interpolator to customize the placement of points.

Similar customization is possible for the DataManager as well. By default the GenericDataManager class assumes that data for country XYZ may be found in the XYZ subdirectory off the main data path. But in some cases there are further refinements. In the US for instance one DataManager may handle addresses in Puerto Rico while a second DataManager stores data for addresses in the rest of the country. The two DataManagers would have separate data directories and the data may contain different columns metadata and versions.

Alternatively a DataManager may check a special file to obtain additional information for an address such as the US unique ZIP Code category.

An example of a JAVA based functionality is the Mapinfo corporations s MapXtreme Java functionality for reading TAB files modifying tables databases and so forth. This MapXtreme Java functionality is also suitable for use by the data creation module to read the TAB data files.

Accordingly during step if there is not administrative designator e.g. no city is specified then the control goes to step for testing for the presence of a postcode. Since a postcode typically may also function as an alternative administrative designator if there a postcode detected control passes to step . However if there is not postcode specified then the method terminates possibly with a fault being communicated to a user. In alternative embodiments a well known lower level administrative designator may be sufficient to allow further processing not shown but typically in the absence of an administrative designator and a postcode the method ends.

If a postcode or an administrative designator is available then control passes to step for identification of at least one lower level administrative designator. If there is no lower level administrative designator then control passes to step . During step if a postcode is available then a centroid corresponding to the postcode is provided as the corresponding geocode during step . If only the administrative designator is available then the administrative centroid is provided as the corresponding geocode during step .

If a lower level administrative designator is available then control flows to step to identify any unique identifiers. Examples of unique identifiers include house numbers identifiers names of buildings landmarks and the like. In the absence of any unique identifier control flows to step for providing a lower level administrative centroid as the corresponding geocode to the user. On the other hand if one or more unique identifiers are available then the need and possibility of performing an interpolation operation is evaluated during step . If interpolation is feasible then the geocode incorporating interpolation if desirable is provided as a response during step . However if a precise geocode is not available and no interpolation is possible then control flows to step to provide a lower level administrative centroid as a geocode.

Next during step this parsed address object is then processed to standardize it to ensure use of standard abbreviations names and the like. During step candidate addresses are identified e.g. by searching Local Data of . During step Soundex is used to identify addresses that sound like the main part of the address and to correct errors. In an embodiment of the invention the capability to sound out addresses is provided by abstract class Soundex that extends java.lang.Object. This abstract class defines what a Soundex object can do. Each locality i.e. country either has a new corresponding Soundex object or is associated with an existing object. These locality Soundex objects should be in the country package with the language mentioned in the name such as USAEnglishSoundex USASpanishSoundex CANFrenchSoundex CANEnglishSoundex and the like.

Address matching preferably further includes restricting candidate addresses by user specified or other geocoding constraints during step . For instance only candidates within a specified postal code may be acceptable. The identified candidate addresses are ranked during step by scoring the extent of match between various fields of a candidate address and the input address. Next during step geocode coordinates corresponding to the candidate addresses are determined by looking up a database and or using an interpolator e.g. Interpolator of to estimate geocodes from known geocodes if a precise geocode for the address is not readily available. Finally during step the results are provided to the client application after encoding in XML.

If a country specific matcher is available then control passes to step for ranking of postal code candidates and correcting accounting for possible typographical errors in the specified postal code followed by control passing to step . Otherwise during step only exact matches are processed and during step results are provided to the client application.

In the absence of a country specific parser for identifying relevant parts of a postal code control passes from step to step for parsing with a generic parser followed by a retrieval of postal code candidates during step and sending results to the client application during step .

The handling of postal codes a type of geocode themselves to generate corrected postal codes and geocodes in the form of specified geographic coordinates such as longitudes and latitudes e.g. of the centroid of the area covered by the postal code allows translation between different types of geocodes.

During step the XML request is translated into an abstract address structure based on the country and request type and control flows to step . During step if a postal code is detected in the address then control flows to step for postal centroid geocoding. Otherwise control passes from step to step . During step if a major city name is detected in the address then control flows to step for geocoding city based addresses. On the other hand if during step a major city name is not detected then control flows to step . During step a determination is made if the address corresponds to a country specific parser. In response to a failure to detect a suitable country specific parser the procedure terminates during step . Otherwise street level geocoding is performed during step . The geocoding result is provided to the client application during step preferably after encoding them in XML as well. In this preferred embodiment described in geocoding is enabled in the alternative at the postal code city or street level. In other embodiments the order of the steps may be modified or concurrent processing allowed to enable use of one or more of postal code city name and street level geocoding.

It will be appreciated that the various features described herein may be used singly or in any combination thereof. Thus the present invention is not limited to only the embodiments specifically described herein. While the foregoing description and drawings represent an embodiment of the present invention it will be understood that various additions modifications and substitutions may be made therein without departing from the spirit and scope of the present invention as defined in the accompanying claims. In particular it will be clear to those skilled in the art that the present invention may be embodied in other specific forms structures and arrangements and with other elements and components without departing from the spirit or essential characteristics thereof. One skilled in the art will appreciate that the invention may be used with many modifications of structure arrangement and components and otherwise used in the practice of the invention which are particularly adapted to specific environments and operative requirements without departing from the principles of the present invention. The presently disclosed embodiment is therefore to be considered in all respects as illustrative and not restrictive the scope of the invention being indicated by the appended claims and not limited to the foregoing description.

Listed next are several XML elements for communicating constraints typically as part of a request but also possibly as part of a response to a request 

In the case of Geocode response constraints as usual all unspecified values assume the server default settings. Some additional XML elements descriptions are 

Notably response to a successful geocode request includes a response without any candidates since a correctly formed request that generates no candidates is not considered a fault.

Response to a geocode request containing a fault is handled differently. In this context a fault means that there was a condition that prevented the geocode engine from running. Some fault messages are 

