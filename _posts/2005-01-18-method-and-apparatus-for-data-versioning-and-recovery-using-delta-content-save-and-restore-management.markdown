---

title: Method and apparatus for data versioning and recovery using delta content save and restore management
abstract: A method, apparatus, and computer instructions for managing versioning data for memory segments. Responsive to a request from a requester to allocate a memory segment, the memory segment is allocated. A versioning data structure is created for the memory segment. The versioning data structure is used to store changes in data for the memory segment, and the memory segment includes a pointer to the versioning data structure. When a change in the data is detected for the memory segment, wherein the change in the data forms the delta data. Responsive to detecting the change in the data for the memory segment, the delta data is stored in the versioning data structure, wherein the versioning data structure is used to return the data in the memory segment to a prior state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07395386&OS=07395386&RS=07395386
owner: Lenovo (Singapore) Pte. Ltd.
number: 07395386
owner_city: Singapore
owner_country: SG
publication_date: 20050118
---
The present invention is related to the following patent applications entitled Method and Apparatus for Dimensional Data Versioning and Recovery Management Ser. No. 11 037 127 entitled Platform Infrastructure to Provide an Operating System Based Application Programming Interface Undo Service Ser. No. 11 037 127 entitled Virtual Memory Management Infrastructure for Monitoring Deltas and Supporting Undo Versioning in a Paged Memory System Ser. No. 11 037 000 entitled Infrastructure for Device Driver to Monitor and Trigger Versioning for Resources Ser. No. 11 037 268 entitled Method and Apparatus for Managing Versioning Data in a Network Data Processing System Ser. No. 11 037 001 entitled Heap Manager and Application Programming Interface Support for Managing Versions of Objects Ser. No. 11 037 024 entitled Method and Apparatus for Marking Code for Data Versioning Ser. No. 11 037 322 and entitled Object Based Access Application Programming Interface for Data Versioning Ser. No. 11 037 145 filed even date hereof assigned to the same assignee and incorporated herein by reference.

The present invention relates to an improved data processing system and in particular to a method and apparatus for processing data. Still more particularly the present invention relates to a method apparatus and computer instructions for an automated incremental versioning backup and restore mechanism for data elements within a computer system.

Data storage components variables collections and multi dimensional collections are used throughout all computer applications. During the execution of an application the contents of these types of data storage elements will change or evolve. These changes occur due to modifications or updates to the data. These changes may be made by user input or through programmatic means. As the program logic of an application progresses situations often arise in which the program state and the content of the data storage elements need to be reset to a prior state. This state may be an arbitrary state selected by the user or programmatically by an application. Mechanisms for incrementally saving and resetting data to a prior known state are present in many applications.

Currently available mechanisms are found in applications such as word processors for resetting or rolling back to a previous state. A word processor may allow a user to undo changes to a document such as deletions insertions or formatting changes.

A significant problem with existing mechanisms is that they are prone to inefficiencies and require explicit management by the application programmer or end user. Therefore it would be advantageous to have an improved method apparatus and computer instructions for data versioning and recovery management.

The present invention provides a method apparatus and computer instructions for managing versioning data for memory segments. Responsive to a request from a requestor to allocate a memory segment the memory segment is allocated. A versioning data structure is created for the memory segment. The versioning data structure is used to store changes in data for the memory segment and the memory segment includes a pointer to the versioning data structure. When a change in the data is detected for the memory segment wherein the change in the data forms the delta data. Responsive to detecting the change in the data for the memory segment the delta data is stored in the versioning data structure wherein the versioning data structure is used to return the data in the memory segment to a prior state.

With reference now to the figures and in particular with reference to a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. Computer is depicted which includes system unit video display terminal keyboard storage device which may include floppy drives and other types of permanent and removable storage media and mouse . Additional input devices may be included with personal computer such as for example a joystick touch pad touch screen trackball microphone and the like. Computer can be implemented using any suitable computer such as an IBM eServer computer or IntelliStation computer which are products of International Business Machines Corporation located in Armonk N.Y. Although the depicted representation shows a computer other embodiments of the present invention may be implemented in other types of data processing systems such as a network computer. Computer also preferably includes a graphical user interface GUI that may be implemented by means of systems software residing in computer readable media in operation within computer .

Referring to a block diagram of a data processing system in which the present invention may be implemented. Data processing system may be a symmetric multiprocessor SMP system including a plurality of processors and connected to system bus . Alternatively a single processor system may be employed. Also connected to system bus is memory controller cache which provides an interface to local memory . I O bridge is connected to system bus and provides an interface to I O bus . Memory controller cache and I O bridge may be integrated as depicted.

Peripheral component interconnect PCI bus bridge connected to I O bus provides an interface to PCI local bus . A number of modems may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add in connectors. Communications links to other data processing systems may be provided through modem and network adapter connected to PCI local bus through add in connectors.

Additional PCI bus bridges and provide interfaces for additional PCI local buses and from which additional modems or network adapters may be supported. In this manner data processing system allows connections to multiple network computers. A memory mapped graphics adapter and hard disk may also be connected to I O bus as depicted either directly or indirectly.

Those of ordinary skill in the art will appreciate that the hardware in may vary. For example other peripheral devices such as optical disk drives and the like also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.

With reference now to a block diagram of a Java virtual machine is depicted in accordance with a preferred embodiment of the present invention. Java virtual machine includes class loader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. Java virtual machine also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine may be for example Java interpreter or just in time compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example the Java Native Interface JNI .

Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by Java virtual machine to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the Java virtual machine creates a new Java stack for the thread. The Java virtual machine performs only two operations directly on Java stacks it pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the Java virtual machine pushes a new frame onto the Java stack of the thread. When the method completes the Java virtual machine pops the frame for that method and discards it. The Java virtual machine does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a Java virtual machine method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined.

Native method stacks stores the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some Java virtual machine implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. The constant pool is located in method area in these examples. The Java virtual machine specification strictly defines data types and operations. Most Java virtual machines choose to have one method area and one heap each of which is shared by all threads running inside the Java virtual machine such as Java virtual machine . When Java virtual machine loads a class file it parses information about a type from the binary data contained in the class file. Java virtual machine places this type of information into the method area. Each time a class instance or array is created the memory for the new object is allocated from heap . Java virtual machine includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

The present invention provides a memory management subsystem to provide for data versioning and recovery management. The mechanism of the present invention saves modifications or deltas in data when memory segments in memory are changed. Memory segment is an allocatable unit of memory available from the heap. A memory segment may contain one or more objects. Additionally a memory segment may contain only part of an object with the other part of the object being located in one or more other memory segments. A delta in data is the difference between the data in its prior version and its current version. The different deltas may be used to restore memory segments to a prior state. In these illustrative examples the memory management subsystem may be for example memory management and heap in . The mechanism of the present invention modifies this heap to include data structure for restoring delta data for memory segments. In these examples delta data represents changed values or data for a particular memory segment. This delta data is associated with an index. This index may take various forms such as a number or a timestamp.

In particular these changes between the prior data and the current data in its changed form are stored in a data structure such as for example a linked list in a heap. The data structure is associated with a memory segment. In the illustrative examples a memory segment is associated with the versioning data structure using at least one of a pointer and an offset. The mechanism of the present invention modifies the memory management system to automatically generate this linked list in the heap of a Java virtual machine without requiring any special requests from applications or the user.

Turning now to a diagram illustrating components used in data versioning and recovery is depicted in accordance with a preferred embodiment of the present invention. Memory management process receives requests from applications such as application and application to allocate objects. These objects are allocated from the available memory segments. Memory management process may be implemented in a memory management component such as memory management in .

In response to receiving these requests data objects such as data object and data object are allocated by memory management process . These data objects are located in memory segments and in a heap such as heap in these examples. Additionally delta linked list is located within heap . This particular data structure contains a linked list of entries that identify delta data for various memory segments such as memory segment and memory segment .

In this example object includes memory segment header and memory segment data . Object includes memory segment header and memory segment data . Memory segment data and memory segment data contain the data for the memory segment in its current state. Memory segment header includes a pointer or offset to delta linked list . In a similar fashion memory segment header also includes an offset or header in the delta linked list .

If a request is received by memory management process to restore one of the memory segments in the heap to a prior state the process identifies the memory segment and an index to identify the state that is desired. This index may be for example a numerical value or a timestamp. If for example memory segment is identified in the request the object header is used to find delta linked list . The link list is managed by the memory management subsystem which also calculates the delta data in these illustrative examples. The index in the request is used to identify the desired state for memory segment . Based on the particular entry identified in linked list the linked list may be traversed to make the appropriate changes to memory segment to return that memory segment to its original state. In turn object also is returned to its original state because this object is located within memory segment .

In these depicted examples all of the delta data for all memory segments is stored within delta linked list . The entries that apply to a particular memory segment may be identified through an object identifier that is found within each entry of delta linked list .

In other illustrative examples a separate linked list data structure may be used for each memory segment. In this case the object header provides an offset to the particular linked list data structure for that memory segment.

When application changes a memory segment such as memory segment memory management process creates an entry within delta linked list to store the delta data. The memory management process can detect changes in a memory segment using a number of different mechanisms. For example the application making a call to assign a value to an object being managed by the memory management process the memory management process detects this call and generates delta data. For example the delta data may be the difference between the old value and the new value. In another example all of the memory segments are examined periodically to see whether a change has occurred since the last time data for the memory segments was stored in delta linked list . This comparison is made by comparing the data in the memory segment with a previous copy of the date for the memory segments. In another example an explicit API call may be made to generate a change in the memory segment. This receipt of this call is used to detect the change in data. Specifically any changed values in memory segment are stored within delta linked list in association with the identification of memory segment and an index such as a numerical value or a timestamp. In this manner all changes to memory segment are stored within delta linked list . Thus memory segment may be returned to any prior state desired using this data structure.

Turning next to a diagram illustrating components used in providing data versioning and recovery management is depicted in accordance with a preferred embodiment of the present invention. In this illustrative example memory management process receives requests from application and application to create objects for use by the applications. In this example memory segment is created for use by application and memory segment is created for use by application .

Memory management process may be implemented within memory management in . Memory segments and may be located in a heap such as heap in . These memory segments may be allocated for objects used by the applications. Memory segments are similar to chunks of memory. Memory segment includes memory segment header memory segment data and delta linked list . Memory segment header includes an offset to point to the beginning of delta linked list in this illustrative example. Memory segment data contains the current data for memory segment . Delta linked list contains entries that identify all of the delta data for memory segment .

In a similar fashion memory segment header provides an offset to the beginning of delta linked list . Memory segment data contains the current data for memory segment . Delta linked list contains all the delta data for changes made to memory segment data . In this illustrative example memory management process automatically increases the size of memory segment in response to a request to allocate memory segment . This increased size includes space needed to store delta data. This type of allocation for memory segments and is performed automatically without requiring an application or a user to request the additional memory to store delta data. Additionally memory management process may allocate more space for memory segment and memory segment as the memory segment data and the delta data increase for these objects.

Turning now to a diagram illustrating objects and a delta linked list is depicted in accordance with a preferred embodiment of the present invention. In this example memory segment and memory segment are examples of data elements requested by an application such as applications and in . Space for memory segment and memory segment is allocated in a heap by a memory management subsystem. References to these data elements are returned to the applications for use. Additionally the memory management subsystem also initializes delta linked list .

In these illustrative examples memory segment and memory segment are examples of spreadsheets. Of course these memory segments may contain data from numerous applications or objects. Further all of the data for an application or object may not be located in a single memory segment.

Array is the initial state of memory segment . Array indicates that a change has been made to the value in cell 1 1 . Array indicates that changes have been made to the memory segment in cells 1 2 and 2 1 . Array indicates that changes have been made to memory segment in cell 1 1 . The initial change made in array is stored as entry . Each of these entries includes a timestamp which is used as the index. The entries also include a memory segment MS reference to identify the object with which the entry is associated. The array index identifies the cell in which the change has been made. The value in the entry identifies the change value. In other words when the value a is changed to value a the value a is stored in entry to identify the delta between array and array . The changes to array are stored in entry and . These two entries have the same timestamp because the changes were made at the same time by the application. Entry identifies the change made to array for memory segment .

In a similar fashion the data in memory segment is an example of a spreadsheet and shows the different states of the memory segment. Array shows the initial state of memory segment . Array shows that a change has been made in cell 1 3 . Array shows that a change has been made in cells 1 3 and 2 1 for memory segment . The change made to array is recorded in delta linked list as entry . The changes made to array are shown in entries and in delta linked list .

As can be seen these examples illustrate that the index or state for the deltas is associated with timestamps. An entry is made each time a change is made to one of the memory segments in these examples.

The current state of memory segment is shown in array . The current state of memory segment is shown in array . As a result if a user an application or some other process wishes to return memory segment to a prior state delta linked list may be used to perform this restoration.

In this illustrative example the prior state is identified through a timestamp. If the memory management subsystem receives a request identifying a particular timestamp and memory segment the memory segment may be returned to that state. In this example if the timestamp is Ts for memory segment the memory management subsystem may identify the most recent delta for memory segment and return it to the prior state. For example a in cell 1 1 may be returned to a using entry . The mechanism of the present invention traverses the linked list from the most current entry to the entry identified by the timestamp. Entries for memory segments other than the selected memory segment are ignored.

Next the process identifies entries and as those corresponding to timestamp Ts. The values for b in cell 2 1 are returned to b and for c in cell 2 1 are returned to c.

This type of traversal and restoration of data is provided as one manner in which the memory segment may be restored to a prior state. Of course any process used to return a memory segment to a prior state using delta data may be employed in these illustrative examples.

The delta in data may be identified or calculated in a number of different ways. In these examples the delta may be calculated using an exclusive OR XOR . In other words the value of prior data may be XOR d with the value of the current data to identify the change in the current data as compared to the prior data. The result of this function is considered the delta in the data in this example. With this delta the current data may be restored to the value of the current data. The data may be for example the values for data in all of the heaps managed by a memory management system. The delta in the data also may be calculated using Moving Picture Experts Group MPEG processes such as MPEG 2. With these processes every delta is similar to a video frame with respect to normal use in processing video data. Instead the deltas are for one or more memory segments. As with a video in which not every pixel necessarily changes from frame to frame not all of the data elements within a memory segment may change from one delta to another delta. Compression algorithms similar to MPEG2 can be employed which minimize the amount of memory required to store the necessary information or delta to restore the memory segments to prior values.

Turning now to a flowchart of a process for allocating memory segments is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a memory management process such as memory management process in .

The process begins by receiving a request to allocate a memory segment step . In these examples the request is received from an application such as application in . In response the size of the memory segment is identified step . Several options exist as to where in memory to place the delta linked list. The consideration of which option to choose is based upon tradeoffs in performance and or memory usage. In a preferred performance optimized embodiment the delta linked list is co resident in memory with the data element for which it contains delta information. In this case at memory segment allocation memory is allocated sufficient to contain both the data element and an estimated size for the delta linked list step . The estimated size may be calculated in this example primarily by the number of deltas desired to be retained.

Next an offset is calculated and stored in the object header step . This offset is used by the memory management subsystem to point to the delta linked list. The memory segment is then allocated step . A memory segment reference is then returned to the requester step .

At this point the requestor may access the allocated memory segment. In these illustrative examples step may be an optional step depending on the particular implementation. In the instance in which the delta linked list is allocated as a separate memory segment from the memory segment this step may be skipped.

Turning now to a flowchart of a process for storing delta data is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a memory management process such as memory management process in .

The process begins by detecting an alteration of the data in the memory segment step . This step may occur in different ways for example when the memory management process receives a request to change data in a memory segment. When that change is processed an entry is created in the delta linked list step with the process terminating thereafter. This linked list could be a combined linked list for all memory segments being managed. Alternatively the linked list could be one that was created within the memory segment when the memory segment was allocated or as a separate linked list associated with the memory segment.

Turning now to a flowchart of a process for returning a memory segment to an earlier state is depicted in accordance with a preferred embodiment of the present invention. In this illustrative example the process in may be implemented in a memory management process such as memory management process in .

The process begins by receiving a request to restore a memory segment to an earlier state step . This request may be received from an application or a user input. Additionally the request may be received from another process such as an operating system or Java virtual machine process requiring the memory segment to be returned to some other state. An index and a memory segment identifier are identified from the request step . The location of the delta linked list is identified from the memory segment step . In step the location of the delta linked list is identified using the offset from the memory segment header. Thereafter the memory segment is restored to the earlier state using the delta data in the delta linked list using the index step with the process terminating thereafter.

Turning now to a flowchart of a process for restoring a memory segment to an earlier state is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in is a more detailed description of step in .

The process begins by selecting a most recent unprocessed entry in the delta linked list step . The memory segment is then altered to include the value from the entry step . Next a determination is made as to whether an entry identified by the index has been processed step . This step determines whether the particular index such as a timestamp for the memory segment has been processed. If this entry has been processed the memory segment has been returned to the desired state with the process terminating thereafter. Otherwise the process returns to step to select the next most recent unprocessed entry in the delta linked list. In the instance in which the linked list includes entries for other memory segments a determination may be included to determine whether the memory segment identifier is for the memory segment that is being restored.

With reference now to a flowchart of a process for presenting different versions of data is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a memory management process such as memory management process in . This process may be used to restore data in memory segments and cause a selected application to present the restored data in a fashion similar to synchronizing a video for presentation. In this case the data is synchronized with the application to allow the user to view the different versions of the data in one or more memory segments.

The process begins by receiving a request to play versions of data for one or more memory segment step . Next a version of the data is selected step . The data for the memory segments is restored step and the restored data is then synchronized with the application step .

Next the process waits for a period of time step . After the period of time has passed a determination is made as to whether a user input has been received selecting the presented version of the restored data step . If a user input is received selecting a presented version of the restored data the process terminates. Otherwise the process returns to step to select the next version of data for restoration and presentation.

In this manner different versions of data may be replayed to a user in a fashion similar to a video or a movie. This process allows the user to pause or select the data desired. Thus the present invention provides an improved method apparatus and computer instructions for saving delta data and restoring a memory segment to a prior state using the delta data. In these examples a data structure containing entries is used to store changes in the data and memory segments. This data structure takes the form of a linked list in these illustrative examples. Of course other types of data structures may be used such as for example a table. In the depicted examples the linked list may be a single linked list for all memory segments being managed by a memory management subsystem. Alternatively this data structure may be located as part of the memory segment or in a separate data structure in which each data structure is associated with a particular memory segment that is being managed by the memory management subsystem.

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such as a floppy disk a hard disk drive a RAM CD ROMs DVD ROMs and transmission type media such as digital and analog communications links wired or wireless communications links using transmission forms such as for example radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

