---

title: Custom API modeling for source code static analysis simulator
abstract: In processing an external function for which source code is not available, such as an application program interface (API), a model is used to evaluate whether the external function is properly invoked. An error potentially resulting from improper invocation of the external function and at least one condition that will result in the potential error are identified. The model is created to test for the condition that will result in the potential error. When the condition is found, generation of an error message is triggered. The model is associated with a source code analyzer such that when the source code is analyzed by the source code analyzer, the model is applied to evaluate invocation of the external function. The potential error and conditions that result in the error, such as input/output parameter errors and dependency errors, may be derived from documentation describing the operation of the external function or API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07549144&OS=07549144&RS=07549144
owner: Microsoft Corporation
number: 07549144
owner_city: Redmond
owner_country: US
publication_date: 20050222
---
The present invention generally pertains to computer software development and more specifically to a method and system for improving evaluation of computer source code to detect programming errors.

The ever improving price performance of microprocessors random access memory RAM and storage systems over the past decade has affected how computer software is developed. In the past when hardware resources were more expensive source code often was written in assembly language. Writing code in a low level language was more time consuming for developers but resulted in somewhat more efficient and compact code. However as a result of the improving price performance of processors memory and storage increasingly more programming is performed in high level languages such as C C Visual Basic and others to minimize the cost of software development.

Better tools for software developers have been created that make software creation more efficient and productive and take further advantage of the improved computing systems that are available. For example static source code analysis tools help software developers to identify errors by deducing possible behavior of the source code. Some static source code analysis tools compile the code to identify syntax defects that the conventional compiler may not have detected that result in violation of programming language rules. Some static source code analysis tools do not include a compiler but instead intercept the output of an external compiler parse the compiled code and analyze it. Once the static source code analysis tools have evaluated the source code for possible syntax errors the representation of the source code generated by the code analyzer further allows the code to be evaluated for semantic problems by the simulator. Thus static source code analysis tools help to detect syntax errors that may not have been detected by a compiler as well as semantic errors that would not be detected by a compiler.

Static source code analyzers are tremendously helpful to software developers both in that they assist software developers in identifying problems that might interfere with compiling of the source code or even if the source code compiles without incident might cause the software to fail in operation. Static source code analyzers do not replace testing to determine if the resulting software functions as intended. However by presenting developers with error messages including correlations to specific lines in source code static source code analyzers allow developers to quickly address potential syntactic and semantic problems in their source code.

The accuracy of static source code analyzers depends on their ability to interpret the source code presented. As a result some errors in the source code might be missed. In addition if the static source code analyzer incorrectly interprets the source code being analyzed false positives may be generated when the source code being evaluated is correct. Unfortunately the occurrence of false positives amounts to noise that obscures error messages indicating actual errors in the source code. As a result an actual error in the software code being analyzed may be overlooked by the software developer.

Other tools that are very helpful to software developers are software developer kits. Software developer kits are typically created for specific operating systems such as Microsoft WINDOWS or computing or game platforms such as the Microsoft XBOX to make software development easier by enabling access to previously created software tools. These software development kits may include source code for prewritten routines that perform common functions likely to be included by developers in their code. By providing convenient access to such software routines developers need not waste time rewriting common routines that already have been created.

Software development kits also may include application program interfaces or application programming interfaces APIs that can be accessed in the operating environment for which the developer is creating software. APIs can be used to invoke services to generate graphics generate sounds and any number of other functions. In addition APIs that invoke differently implemented but functionally comparable services can be used to provide source code software portability between different platforms for which the source code can be compiled. Perhaps most significantly APIs are useful for providing an interface between high level language source code and lower level utilities that operate more directly with the hardware devices of the operating environment.

APIs are often distributed separately or as part of a software development kit in a collection of binary libraries. Typically the source code used to create the APIs are not distributed or otherwise made available to developers. The source code is not made available to protect various proprietary concerns of the developers of the operating environment. However even though the source code implementation of the API is not made available documentation or other information may be made available with the software development kit that explains the operation of the API the proper syntax for invoking the API arguments to be passed to the API and characteristics of values returned by the API.

Unfortunately submitting source code that invokes one or more APIs to a static source code analyzer may result in the generation of a number of errors. As described above a source code analyzer is only accurate to the extent that it is configured to understand the source code. Thus a static source code analyzer may be unable to analyze an API signature because the static source code analyzer is only presented with the API signature and cannot access the source code implementation of the API.

As shown in the prior art example of when analyzing source code input processor of static source code analyzer will recognize API signature s as distinct from standard programming instructions . API signature s may be regarded as a syntax error in error report because the API signature represents a non standard expression. Alternatively for example in C an extern designation can be appended to API signature s which will prevent simulator from attempting to evaluate the semantics of API signature s . Without the source code implementation of the API a static source code analyzer may be able to evaluate the syntax of an API call by determining whether appropriate arguments are passed to the API in accordance with the API signature. However without the source code a static source code analyzer cannot semantically evaluate API signature s their behavior of their effect on source code that invokes API signature s . Upon encountering the extern designation the static source code analyzer makes no attempt to semantically evaluate the expression that follows.

Without access to the source code implementation of the API the static source code analyzer cannot determine what effect the API might have for example on arguments passed to the API. As a result static source code analyzer may generate an error message with regard to a problem with a variable when in fact that problem is actually related to the API. As a result inclusion of API signatures in source code may result in a great deal of false positive error messages or noise being generated by the source code analyzer that may unfortunately divert attention away from actual true error messages. In addition because the source code analyzer may not be able to evaluate an API call or it effects the source code analyzer will not be able to detect errors resulting from such an API call. The API may perform an operation on an argument that was passed to it that will result in an illegal operation at some subsequent point in the source code. Thus if the source code analyzer is incapable of evaluating the operation of the API the source code analyzer may fail to detect related errors in the source code.

It would therefore be desirable to provide a method and system that is able to evaluate API calls even without having access to the source code implementation of the API.

Accordingly one advantage of the present invention is that it provides a method and a system for evaluating external function calls such as API calls even when the source code implementation of the external function call is not available. Typical known source code analyzers ignore external function calls and as a result may miss errors in the invocation of the external function or flag false positives when in fact the error detected was resolved by the external function call. Because the source code for the external function is not available the function source code itself cannot be incorporated into source code and analyzed. However because the function source code is not made available the provider of the external function may provide documentation or other information describing operation of the external function. This documentation enables a software developer to understand what parameters are passed to the external function what parameters are output by the external function what are prerequisite functions on which the API depends as well as other important information. From this descriptive information a model can be developed to insure that the API is properly invoked. A set of primitives included with the static source code analyzer according to an embodiment of the present invention provides a user with a way to model the function of the API so that the static source code analyzer can evaluate the behavior and effect of API calls.

One aspect of the present invention is thus directed to a method for analyzing invocation of an external function for which function source code implementation is not available. At least one potential error resulting from an improper invocation of the external function by source code is identified and at least one condition that will result in the potential error is identified. A model of the external function is employed that is useful to test for the at least one condition resulting in the potential error and which is able to initiate generation of an error message when the condition is found. The model is associated with a source code analyzer such that when the source code is analyzed by the source code analyzer the model is applied to evaluate invocation or operation of the external function.

The external function may include an API. Identifying the at least one condition that will result in the potential error is made based on information describing operation of the external function. The condition may include an incorrect input type of an input parameter acceptable to the application program interface or an incorrect input content range of the input parameter acceptable to the API. Similarly the condition may include an incorrect output for an output parameter generatable by the API or an incorrect output content range of the output parameter generatable by the API. The condition also may include a failure to invoke a prerequisite function that must be invoked prior to the invocation of the external function or a failure to invoke a post requisite function that must be invoked after the invocation of the external function.

The model may be created using a plurality of primitives usable to test for the at least one condition that results in the potential error. The source code analyzer includes a model repository configured to store the model created such that the source code analyzer can access the model upon evaluating source code and identifying a reference to the external function.

With reference to an exemplary conventional computing system suitable for use with an embodiment of the present invention is shown. The system includes a general purpose computing device in the form of a PC provided with a processing unit a system memory and a system bus . The system bus couples various system components including the system memory to processing unit and may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the PC such as during start up is stored in ROM . PC further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a compact disk read only memory CD ROM or other optical media. Hard disk drive magnetic disk drive and optical disk drive are connected to system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable machine instructions data structures program modules and other data for PC . Although the exemplary environment described herein employs a hard disk removable magnetic disk and removable optical disk it will be appreciated by those skilled in the art that other types of computer readable media which can store data and machine instructions that are accessible by a computer such as magnetic cassettes flash memory cards digital video disks DVDs Bernoulli cartridges RAMs ROMs and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information in PC and provide control input through input devices such as a keyboard and a pointing device that communicate with system bus via I O device interface . Pointing device may include a mouse stylus wireless remote control or other pointer but in connection with the present invention such conventional pointing devices may be omitted since the user can employ the interactive display for input and control. As used hereinafter the term mouse is intended to encompass virtually any pointing device that is useful for controlling the position of a cursor on the screen. One or more audio input output devices including headsets speakers and microphones also engage personal computer via I O device interface . Still further input devices not shown may include a joystick haptic joystick yoke foot pedals game pad satellite dish scanner or the like. These and other input output I O devices are often connected to processing unit through an I O interface that is coupled to the system bus . The term I O interface is intended to encompass each interface specifically used for a serial port a parallel port a game port a keyboard port and or a universal serial bus USB . A monitor is connected to system bus via an appropriate interface such as a video adapter . It will be appreciated that PCs are often coupled to other peripheral output devices not shown such as speakers through a sound card or other audio interface not shown and printers.

PC can also operate in a networked environment using logical connections to one or more remote computers such as a remote computer . Remote computer may be another PC a server which is typically generally configured much like PC a router a network PC a peer device or a satellite or other common network node and typically includes many or all of the elements described above in connection with PC although only an external memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are common in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment PC is connected to LAN through a network interface or adapter . When used in a WAN networking environment PC typically includes a modem or other means such as a cable modem Digital Subscriber Line DSL interface or an Integrated Service Digital Network ISDN interface for establishing communications over WAN such as the Internet. Modem which may be internal or external is connected to the system bus or coupled to the bus via I O device interface i.e. through a serial port. In a networked environment program modules or portions thereof used by PC may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used such as wireless communication and wide band network links.

As described above conventionally appending the designation extern or a similar identifier to a declaration of an API signature indicates that the expression representing the API invokes an external routine for which the source code implementation is not available. As is understood in the art the extern designation communicates to the compiler not to attempt to resolve any subsequent invocation of the external routine. The linker will be responsible for locating the object code of the invoked function and resolving the code implementation of the external function at a binary level after compiling. In addition the extern designation communicates to a conventional static source code analyzer not to attempt to semantically analyze the designated external function. Nonetheless the static source code analyzer may evaluate the syntax of subsequent external function calls to ensure that invocations of the external function comport with the syntax of the function as specified.

According to embodiments of the present invention potential API signatures identified are submitted to API simulator . API simulator evaluates potential API signatures to determine if the syntax is correct if proper arguments are passed to the API if the arguments passed are of the appropriate type and to otherwise evaluate API signatures for the presence of coding errors. A determination of whether API signatures are of the correct form is communicated by API simulator to simulator . Using the information provided by API simulator simulator generates error messages in error report for API signatures that include errors. Conversely false positives that may have been flagged as errors by simulator due to its lack of familiarity with API signatures are not reported as errors in error report .

It will be appreciated that if the source code implementation of an API is available to the software developer the software developer can incorporate the API source code implementation in software developer s source code for simulator to evaluate along with the rest of source code . However as described above generally APIs are provided only in their object code form in binary libraries that enable the APIs to be linked with other object code modules compiled from source code . Beneficially embodiments of the present invention do not require the provider of the API to supply the API s source code implementation.

Instead for each API signature that is contemplated expected or desired to be used with source code API simulator includes a model for the evaluation of each API signature. For example models may be developed for a group of APIs identified as the most likely to be called. As a result most noise that would otherwise be included in error report due to false positives can be eliminated without having to include models of every API that might be called.

API simulator includes models derived from information preferably provided by the API developer in SDK and or API documentation that is made available to software developers. Generally SDK API documentation describes the functioning of the API indicates the arguments to be provided to the API what form of values are required or usable by the API and other functional characteristics of the API. SDK API documentation is used to model APIs using API primitives . API primitives include a set of routines packaged in a modeling library associated with the simulator that can be employed by a user to model the function of an API so that API simulator can evaluate the effect of an API invoked by the source code. Use of API primitives is described further below.

Thus using API primitives and reviewing SDK API documentation even without access to the API source code some rules can be derived to evaluate invocation and or operation of API signature s that may be included in source code submitted to static source code analyzer . These rules are included in API simulator and can be applied to potential API signatures that are identified. The identified API signatures are then evaluated to determine if they use the appropriate syntax pass appropriate arguments to the API and otherwise adhere to the rules of the API to evaluate whether the API signatures in source code are valid. If API simulator is applied to determine if API signature s identified in the source code are implemented correctly no error messages will be reported in error report . On the other hand if the mistake is made in invoking the API in source code API simulator conveys this error message to simulator . Thus simulator can include appropriate error messages regarding API signatures that were identified in source code in error report .

Preferably API simulator not only evaluates the standalone syntax and signature structure of the indication of the API but also is configured to communicate to simulator whether API signatures included in source code resolve other potential errors in source code detected by simulator . As a simple example the API may evaluate an argument passed to the API and truncate or round its value beyond certain limits to acceptable values. Accordingly if simulator detects that a particular value is out of bounds based on source code simulator can query API simulator to determine if an API resolves the potential error. If so no error message will be reported in error report further reducing the incidence of false positive error messages.

In addition API models included in the API simulator may include dependency rules. For example it is possible that before an API is called an argument passed to the API must be initialized or another API or some other function on which an API depends must be invoked. API simulator can include that dependency rule so that an error will be generated by static source code analyzer if the dependent function is not invoked before the API is invoked. Similarly if it is necessary that an API invoke another function or API after it is called API simulator also can include that rule to generate an error if the function or API is not called as required.

As described above many APIs are provided in binary libraries and the source code used to implement the APIs is not made available to software developers that will use them. Embodiments of the present invention model identify expected APIs based on documentation provided with APIs or SDKs to enable static source code analyzer to substantively evaluate API calls as further described below.

It will be appreciated that although static source code analyzer depicts input processor as causing standard programming instructions and API signature s to be processed independently simulator and API simulator preferably work cooperatively to evaluate whether APIs have been invoked properly and whether the APIs function properly with the source code.

For purposes of illustration an exemplary API is presented that receives two arguments and returns a success failure value. Before the API is called the memory block pointed to by the second parameter is not initialized. The API performs some operations on the memory block pointed to by the second parameter. However if the first parameter fails to meet a certain condition the functions will not be performed on the memory block pointed to by the second parameter and in fact the memory will not even be initialized. Accordingly if failure to initialize the memory block is a problem that problem will not be detected by a conventional static source code analyzer operable to evaluate the effect of the API.

Further assume that the API is referenced by source code that a user desires to submit for static source code analysis 

A potential problem arises in the line of source code following the API call y 1 x. A conventional static source code analyzer without access to the source code implementation of the API is not able to determine what value of x may be returned by the API. In examining the source code implementation of the API x will be initialized if z is greater than zero but x will not be initialized if z has a value less than or equal to zero. Variable x is not otherwise initialized by the source code invoking the API. Thus if x is not initialized the expression y 1 x will result in division by an uninitialized variable. On the other hand if z is greater than or equal to zero x is initialized and set to a nonzero value thus expression y 1 x will yield a defined acceptable result. Furthermore even if z were not initialized it is not possible to predict the result of the API on the value of x even with access to the source code implementation.

Some conventional simulators may make assumptions about x. Hypothetically for example a static source code analyzer may assume that x is initialized. On the other hand the static source code analyzer may also be configured to assume that if x is not initialized by the source code invoking the API x will not be initialized by the API. Similarly hypothetically the static source code analyzer may assume that the value of x returned by the API is zero or is not equal to zero. In any case the static source code analyzer can only guess at the value of x because a conventional static source code analyzer is not able to determine what value of x may be returned by the API.

As a result because the value of x cannot be determined by a conventional static source code analyzer the y 1 x expression presents a problem. Depending on what assumptions are made by the conventional static source code analyzer the static source code analyzer may fail to detect errors generate false error messages or yield an appropriate response purely by happenstance as further described below.

Even without the API developer disclosing the source code implementation of the API according to embodiments of the present invention the static source code analyzer is adapted to correctly identify potential errors in source code.

Static source code analyzers typically use state objects to track the state of program elements and variables. Thus for example in the preceding example of the routine invoking the API if a function for which the source code implementation is known is invoked that affects the value of x a state object could be used to track the value of x to determine whether division by x in the statement y 1 x yields a valid result. Recognizing the known syntax and rules of the source code state machines may be used for example to determine whether a primitive such as an unsigned integer is used in a manner consistent with the primitive being an unsigned integer.

According to embodiments of the present invention a user can study the documentation describing the API and using API primitives create a model that the static source code analyzer can access and employ to evaluate the function of the API. API primitives include signatures that can specify a plurality of arguments that can be used to evaluate the arguments to determine if they meet certain conditions to determine whether an API is invoked properly whether the API yields a valid result and similar determinations.

As previously described in connection with in one embodiment of the present invention API primitives are provided with static source code simulator in a modeling library that allow the static source code simulator to model the behavior of APIs. The API primitives relate to functions that deal with memory initialization buffers pointers memory allocation and other functions that may be performed by an API. The API primitives can be used to specify that certain conditions must hold when an API is called and certain results are expected or hold true when the call to the API returns.

Using the preceding API documentation the API SomeFunctionAPI may be modeled using a number of exemplary API primitives having specified primitive signatures and functions. For example syntax and functional descriptions are provided for four API primitives that can be used to model the function of an API based on what is known about the API from the API or SDK documentation even without access to the source code implementation 

Using the some of the API primitives based on information about the API derivable from the API documentation the API SomeFunctionAPI may be modeled to facilitate a more accurate evaluation of the source code by the static source code analyzer 

State object includes a state to evaluate the syntax of the API call. Because the API is designated as an external function by declaring it using extern syntax a conventional static source code analyzer will recognize that the extern syntax invokes a module for which source code is not available and will ignore the remaining syntax of the expression. Accordingly state augments the static source code analyzer to enable it to determine if the defined syntax of the API call is used. State may include a plurality of states sequentially tested to determine if a series of required arguments are supplied. If not at a state a syntax error is generated that will be included in the error report produced by the static source code analyzer. On the other hand if the syntax is correct or once a syntax error is generated at state state object advances to a state .

At state it is determined if the dependency conditions of the API are met. If not at a state a dependency error is generated that is included in the error report produced by the static source code analyzer. A dependency error may exist for example if the API is to be invoked only after another API has been called or some other function must be performed as specified in the API documentation. A plurality of dependency checking states may be included each of which evaluates a particular dependency. If the dependencies have been met or once a dependency error is generated at state state object advances to a state .

At state it is determined if the first variable is greater than zero. If not at a state the second variable is not flagged as having been initialized or processed. On the other hand if it is determined at state that the first variable is greater than zero at a state the second variable is flagged as having been initialized and processed.

State object operates in concert with other state objects employed by the static source code analyzer. Thus for example when x is defined a state object is created for it by the static source code analyzer. Because x has not been initialized its state object indicates that it has not been initialized. Without some understanding of the functioning of the API the static source code analyzer may assume that the API either never initializes the out variables thus resulting in a false positive or always initializes the out variables thereby overlooking a potential problem. Thus modeling the API in the present invention ensures that better and more accurate information is provided to a user.

On one hand a static source code analyzer that does not model the API as shown in may assume that unless x is initialized by source code as presented which does not include the API source code x is not initialized. Thus regardless of the possibility that API call might initialize x when z is greater than zero expression y 1 x at line will result in an error message because it may result in dividing by an undefined value if x is not initialized. Error message of turns out to be an accurate statement because x will not be initialized by the API because variable z is set to zero in expression and because z is not greater than zero x will not be initialized. However error message being accurate is purely fortuitous because a conventional static source code analyzer is not adapted to evaluate the function of the API and thus cannot determine whether the API initializes x.

However without the benefit of an API model static source code analyzer will generate a similar same error message even when x is initialized as shown in . In static source code analyzer analyzes source code that is identical to source code except for the change of statement where z was initialized and set equal to zero to statement preceding an API call that initializes z and sets z equal to one. Accordingly because z is initialized and greater than zero as described above the API will perform a function on x and return x as some non zero number. Accordingly expression does not result in division by an uninitialized variable. Nonetheless error message indicating the division by uninitialized variable problem is generated because source code analyzer has no way of determining that statement causes API call to return a value for x that is valid and not zero. Error message constitutes an unequivocally incorrect false positive because expression will not result in division by an undefined uninitialized value.

Neither the result of nor the result of is acceptable. Error message presents a statement that may not be true and a software developer may have a difficult task in attempting to debug the code to identify and possibly correct the issue that caused static source code analyzer to generate this message. Error message generated by static source code analyzer also is unacceptable because it indicates an error where there is none the software developer cannot possibly revise the code so as to prevent the message and consequently the software developer has to ignore error message

Alternatively as shown in a static source code analyzer is configured to operate on the assumption that in source code arguments passed to an external function such as those invoked in API call are initialized. In making this assumption static source code analyzer does not regard expression y 1 x in line as potentially causing an error. Thus static source code analyzer generates message indicating that no errors have been detected. Fortuitously message is correct because z was initialized by expression and set equal to one resulting in the API initializing and returning a nonzero value of x.

However without static source code analyzer being configured to analyze the API this assumption could be wrong. As shown in where static source code analyzer analyzes source code in which variable z is initialized and set equal to in statement the assumption made is wrong. Because z is initialized to zero in source code API call does not initialize x. Thus expression results in division by an undefined value. However message indicates no error has been found. Thus not being configured to model the API static source code analyzer again generates message which is inaccurate. Once again static source code analyzer generates messages that may be inaccurate false positives or may fail to include actual errors.

In contrast using embodiments of the present invention in which a static source code analyzer models the API the problems described above are avoided. As shown in static source code analyzer analyzes source code in which variable z is initialized and set equal to zero by statement As a result API call results in variable x not being initialized resulting in division by an undefined value in expression . Because static source code analyzer includes a model of the API using API primitives static source code analyzer correctly models the function of the API the static source code analyzer recognizes the illegal function and generates an accurate error message

Furthermore as shown in when static source code analyzer analyzes source code which includes expression initializing z to 1 before API call the API will return a non zero value of x and expression does not represent an illegal operation. Because static source code analyzer models the function of the API using API primitives as previously described the static source code analyzer correctly determines that initialization of z in expression initializes x and returns a nonzero value so that it returns a message indicating that no errors were found. Thus in both the case of source code and static source code analyzer generates an accurate report which identifies true errors but does not include false positives.

On the other hand if it is determined at decision step that an API model is available or if it had previously been determined at decision step that the source code element was a standard source code element at a decision step it is determined if an error is detected in the source code element. If so an appropriate error message is generated at a step . On the other hand if no error is detected at decision step or once appropriate messages have been generated at steps team or flow diagram proceeds to a decision step . At decision step it is determined if all of the source code elements have been simulated. If not at a step the next source code element to be evaluated is identified and the next source code element is evaluated at step . Alternatively once it is determined at decision step that all the source code elements have been simulated at a step a report is generated including all error messages generated in the preceding steps. Static source code analysis ends at a step .

Although the present invention has been described in connection with the preferred form of practicing it and modifications thereto those of ordinary skill in the art will understand that many other modifications can be made to the present invention within the scope of the claims that follow. Accordingly it is not intended that the scope of the invention in any way be limited by the above description but instead be determined entirely by reference to the claims that follow.

