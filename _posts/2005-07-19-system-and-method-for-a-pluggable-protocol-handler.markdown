---

title: System and method for a pluggable protocol handler
abstract: Embodiments of the invention are generally directed to a system and method for pluggable protocol handlers to route message traffic between communication partners. In an embodiment, a protocol independent connection manager receives a message from a communication partner over a network connection. The connection manager calls a dynamically loadable protocol handler to process and route the received message to a subsequent communication partner. In one embodiment, the network connection is a multiplexed network connection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07966412&OS=07966412&RS=07966412
owner: SAP AG
number: 07966412
owner_city: Walldorf
owner_country: DE
publication_date: 20050719
---
The field of invention pertains generally to the software arts and more specifically to a system and method for a pluggable protocol handler.

Even though standards based application software e.g. Java based application software has the potential to offer true competition at the software supplier level legacy proprietary software has proven reliability functionality and integration into customer information systems IS infrastructures. Customers are therefore placing operational dependency on standards based software technologies with caution. Not surprisingly present day application software servers tend to include instances of both standard and proprietary software suites and often problems emerge in the operation of the newer standards based software or interoperation and integration of the same with legacy software applications.

The prior art application server depicted in provides a good example. shows a prior art application server having both an Advanced Business Application Programming ABAP legacy proprietary software suite and a Java 2 Enterprise Edition J2EE standards based software suite . A connection manager routes requests e.g. HyperText Transfer Protocol HTTP requests and HTTP with secure socket layer HTTPS requests associated with sessions between server and numerous clients not shown in conducted over a network . A session can be viewed as the back and forth communication over a network between computing systems e.g. a particular client and the server .

The back and forth communication typically involves a client client sending a server server a request that the server interprets into some action to be performed by the server . The server then performs the action and if appropriate returns a response to the client e.g. a result of the action . Often a session will involve multiple perhaps many requests and responses. A single session through its multiple requests may invoke different application software programs.

For each client request that is received by the application server s connection manager the connection manager decides to which software suite the request is to be forwarded. If the request is to be forwarded to the proprietary software suite notification of the request is sent to a proprietary dispatcher and the request itself is forwarded into a request response shared memory . The proprietary dispatcher acts as a load balancer that decides which one of multiple proprietary worker nodes through are to actually handle the request.

A worker node is a focal point for the performance of work. In the context of an application server that responds to client server session requests a worker node is a focal point for executing application software and or issuing application software code for downloading to the client. The term working process generally means an operating system OS process that is used for the performance of work and is also understood to be a type of worker node. For convenience the term worker node is used throughout the present discussion.

When the dispatcher identifies a particular proprietary worker node for handling the aforementioned request the request is transferred from the request response shared memory to the identified worker node. The identified worker node processes the request and writes the response to the request into the request response shared memory . The response is then transferred from the request response shared memory to the connection manager . The connection manager sends the response to the client via network .

Note that the request response shared memory is a memory resource that each of worker nodes through has access to as such it is a shared memory resource . For any request written into the request response shared memory by the connection manager the same request can be retrieved by any of worker nodes through . Likewise any of worker nodes through can write a response into the request response shared memory that can later be retrieved by the connection manager . Thus the request response shared memory provides for the efficient transfer of request response data between the connection manager and the multiple proprietary worker nodes through .

If the request is to be forwarded to the standards based software suite notification of the request is sent to the dispatcher that is associated with the standards based software suite . As observed in the standards based software suite is a Java based software suite in particular a J2EE suite that includes multiple worker nodes through .

A Java Virtual Machine is associated with each worker node for executing the worker node s abstract application software code. For each request dispatcher decides which one of the N worker nodes is best able to handle the request e.g. through a load balancing algorithm . Because no shared memory structure exists within the standards based software suite for transferring client session information between the connection manager and the worker nodes through separate internal connections have to be established to send both notification of the request and the request itself to the dispatcher from connection manager for each worker node. The dispatcher then forwards each request to its proper worker node.

Various problems exist with respect to the prior art application server of . For example the establishment of connections between the connection manager and the J2EE dispatcher to process a client session adds overhead inefficiency within the standards based software suite . For example establishing connections between the connection manager and the J2EE dispatcher typically include copying data to and from the network stack. In addition the J2EE dispatcher opens a separate select thread for each connection. Opening a number of separate threads can add overhead to the system because each thread uses resources such as memory. This increased overhead reduces the efficiency and scalability of application server .

Embodiments of the invention are generally directed to a system and method for pluggable protocol handlers to route message traffic between communication partners. In an embodiment a protocol independent connection manager receives a message from a communication partner over a network connection. In another embodiment messages are received from a communication partner via a connection oriented shared memory region. The connection manager calls a dynamically loadable protocol handler to process and route the received message to a subsequent communication partner. In one embodiment the network connection is a multiplexed network connection.

Comparing first note that the role of the connection manager has been enhanced to at least perform dispatching for the standards based software suite so as to remove the additional connection overhead associated with the prior art system s standards based software suite dispatching procedures .

Also the connection manager is protocol independent. A protocol handler can be plugged into the connection manager to support any one of a number of protocols by which a request can be conveyed to the connection manager. For example handlers for protocols such as the hypertext transfer protocol HTTP secure HTTP HTTPS the simple mail transfer protocol SMTP the network news transfer protocol NNTP the TELNET protocol the P4 protocol of SAP AG and the Internet Inter Object Request Broker Protocol IIOP may be provided at the connection manager so that it can receive a request conveyed from a client in accordance with any of these protocols. The advantages of pluggable protocol handlers include easy extendibility of connection managers with additional protocols and small and independent software components that can be developed tested maintained and replaced independently e.g. in the case of an error in one protocol handler only this part needs to be replaced not the complete program.

In addition in one embodiment the role of a shared memory has been expanded to at least include a a first shared memory region that supports request response data transfers not only for the proprietary suite but also the standards based software suite b a second shared memory region that stores session objects having low level session state information e.g. information that pertains to a request s substantive response such as the identity of a specific servlet invoked through a particular web page and c a third shared memory region that stores high level session state information e.g. information that pertains to the flow management of a request response pair within the application server e.g. the number of outstanding active requests for a session .

Regarding request notification queues Q through QM one queue for each of the worker nodes through has been implemented within the standards based software suite . In an embodiment the shared memory structures and request notification queues help implement a fast session fail over protection mechanism in which a session that is assigned to a first worker node can be readily transferred to a second worker node upon the failure of the first worker node.

Shared memory is memory whose stored content can be reached by multiple worker nodes. Here the contents of the shared memory region can be reached by each of worker nodes in and . Additionally the contents of shared memory regions and can be reached by each of worker nodes through . In one embodiment shared memory region supports shared cache that can be reached by each of worker nodes through .

Different types of shared memory technologies may be utilized within the application server and yet still be deemed as being a shared memory structure. For example shared memory region may be implemented within a connection oriented shared memory technology while shared memory region may be implemented with a shared closure oriented shared memory technology.

The connection oriented request response shared memory region effectively implements a transport mechanism for request response data between the connection manager and the worker nodes. That is because the connection manager is communicatively coupled to the shared memory and because the shared memory is accessible to each worker node the request response shared memory at perhaps its broadest level of abstraction is a mechanism for transporting request response data between the connection manager and the applicable worker node s for normal operation of sessions e.g. no worker node failure as well as those sessions affected by a worker node crash.

Although the enhancements of the application server of have been directed to improving the reliability of a combined ABAP J2EE application server it is believed that architectural features and methodologies described in more detail further below can be more generally applied to various forms of computing systems that manage communicative sessions whether or not such computing systems contain different types of application software suites and whether any such application software suites are standards based or proprietary. Moreover it is believed that such architectural features and methodologies are generally applicable regardless of any particular type of shared memory technology employed.

In operation the connection manager forwards actual request data to the first shared memory region request response shared memory regardless of whether the request is to be processed by one of the proprietary worker nodes or one of the standards based worker nodes . Likewise the connection manager receives response data for a request from the request response shared memory whether a proprietary worker node or a standards based worker node generates the response.

With the exception of having to share the request response shared memory with the worker nodes of the standards based software suite the operation of the proprietary software suite is essentially the same as that described in the background in one embodiment of the invention. That is the connection manager forwards request notifications to the proprietary dispatcher and forwards the actual requests to the request response shared memory . The proprietary dispatcher then identifies which one of the proprietary worker nodes is to handle the request. The identified worker node subsequently retrieves the request from the request response shared memory processes the request and writes the response into the request response shared memory . The response is then forwarded from the request response shared memory to the connection manager who forwards the response to the client via network .

In an alternative embodiment the ABAP dispatcher is integrated into the connection manager just as the J2EE dispatcher . Indeed it is contemplated that a single dispatcher may encompass the functionality of both dispatchers and . In the case where the dispatcher is integrated into the connection manager the connection manager identifies which one of the proprietary worker nodes is to handle a request and via its integrated dispatcher capabilities forwards the request to the request response shared memory . The identified worker node subsequently retrieves the request from the request response shared memory processes the request and writes the response into the request response shared memory . The response is then forwarded from the request response shared memory to the connection manager who forwards the response to the client via network .

In one embodiment network connections and are multiplexed network connections. A multiplexed network connection refers to a network connection in which the messages from more than one client are multiplexed over the same network connection. Since the connections are multiplexed there is no need to set up separate network connections for each client in an embodiment of the invention. This reduces the network connection overhead for connection manager .

Connection manager receives messages e.g. and from one or more clients clients and on a network connection endpoint e.g. network connection endpoints and . Network connection endpoints and also are identifiable endpoints for a network connection such as the combination of a network layer address e.g. an Internet Protocol address and port number.

In one embodiment connection manager is protocol independent. In such an embodiment connection manager accesses one or more dynamically pluggable protocol handlers through for example an Application Programming Interface API e.g. APIs to process the received messages. The term dynamically refers to pluggable protocol handlers that can be loaded and removed at runtime.

Pluggable protocol handlers process the received messages and in accordance with the appropriate protocol to determine an appropriate communication partner. Determining an appropriate communication partner for a received message typically includes selecting one of worker nodes through to process the message. Selecting the appropriate worker node can be based on a number of factors including session management information and or load distribution schemes. The pluggable protocol handler forwards the received message e.g. message to the selected worker node via for example network connections or connection oriented shared memory.

After processing the message the worker node may provide a response message . Connection manager receives message on network connection endpoint . If a session communication protocol is being used within the server then connection manager first processes the session information and then calls an appropriate pluggable communication protocol handler . The pluggable communication protocol handler selects the appropriate client e.g. standards based protocol client or propriety protocol client and forwards the message to the selected client.

As shown in connection manager calls pluggable protocol handlers to process messages from communication partners that are both external to application server e.g. clients and internal to application server e.g. worker nodes . For ease of reference the term internal communication partners refers to entities that are within the same application server or cluster as connection manager . Similarly the term external communication partners refers to entities that are external to the application server in which connection manger resides.

The messages sent by and to external communication partners e.g. clients are formatted according to either a standards based protocol or a proprietary protocol. These messages typically have a protocol header and message data. For example message includes protocol header and data . In an embodiment pluggable communication protocol handlers determine an appropriate communication partner for a message based at least in part on the protocol header e.g. protocol header .

An example of a standards based protocol used in an embodiment of the invention is IIOP. shows selected portions of one example of an IIOP protocol header . IIOP protocol header includes protocol magic Global Inter ORB Protocol GIOP version flag message type and message size . Protocol magic is a four byte portion of the message header whose value is the four upper case characters GIOP. GIOP version is a two byte element of the message header that specifies the version number of the GIOP protocol being used in the message. Flag is an eight bit octet to provide various flags for the message. Message type specifies a message type for the message e.g. request reply cancel request locate request locate reply close connection message error fragment etc. . Message size specifies the size of the message that follows the message header.

An example of a proprietary protocol used in an embodiment of the invention is P4. shows selected portions of one example of a P4 protocol header . P4 protocol header includes version size server identifier and broker identifier . Version is a two byte element of the message header species the version of P4 protocol for the message. Size is a four byte element that specifies the size of the message. Service identifier is a four byte element that specifies an identifier to uniquely identify a server for example within a cluster of servers. Broker identifier is a four byte field that can be used to identify a cluster in which the server resides.

Referring again to in an embodiment the communication between connection manager and the internal communication partners is session based. In such an embodiment session communication data is prepended to messages between connection manager and the internal communication partners. Session logic associated with the internal communication partners and connection manager not shown processes session communication data .

Shared memory is a memory resource that each of worker nodes through can access to exchange messages and other information with connection manager . In the illustrated embodiment shared memory includes request response shared memory and request notification queues . Connection manager writes request data into and reads response data from request response shared memory . Any of worker nodes can retrieve the request data from request response shared memory . Likewise any of worker nodes can write a response into request response shared memory that can later be retrieved by connection manager .

Connection manager uses request notification queues to notify worker nodes that request data is available in request response shared memory . In an embodiment each of worker nodes has a separate request notification queue within request notification queues . In such an embodiment connection manager may store a handle in the appropriate queue of a worker node to notify the worker node that request data is available. The worker node can then retrieve the handle and use it to access request response shared memory and obtain the request data.

Over time connection manager calls pluggable protocol handler to process messages implemented according to either a standards based protocol e.g. IIOP or a proprietary protocol e.g. P4 . In an embodiment pluggable protocol handler or for ease of reference handler handles a connection oriented protocol on a multiplexed connection e.g. multiplexed connections and shown in . Handler registers a number of callback functions at connection manager to respond to various events including new client connection available connection to communication partner established data available write to connection possible and connection closed. The registered function is called if the associated event is occurring on a connection. Table 1 illustrates selected functions for handler according to an embodiment of the invention.

In an embodiment PlugInInit function is called after handler is loaded into connection manager . PlugInInit function provides handler specific initialization for handler . Initialization may include providing version information of connection manager supported protocol information hostname port number and the like.

Handler registers one or more input output functions with multiplex select thread . Multiplex select thread calls these functions if an associated event occurs on a network connection. In one embodiment the functions registered for handler include read accept write and connect .

In an embodiment read allows handler to read from a multiplexed connection. Reading from the multiplexed connection may include reading an entire message or only reading a fragment of the message. If only a fragment of the message is read then read may be repeatedly called until the entire message has been read. Pseudo code listing illustrates read data processing according to an embodiment of the invention. Pseudo code listing is directed to read data processing for data implemented according to the P4 protocol implementing a state machine . It is to be appreciated that similar read data processing may be used for other protocols either standards based protocols or proprietary protocols .

In an embodiment write allows handler to write data to a multiplexed connection. Writing to the multiplexed connection may include writing an entire message or only writing a fragment of the message. If only a fragment of the message is written then write may be repeatedly called until the entire message has been written.

Connect allows handler to connect to a communication partner on a multiplexed connection. The communication partner may be either an internal communication partner e.g. worker nodes shown in or an external communication partner e.g. clients and shown in . Accept allows the connection manager to accept new incoming connections from an external or internal client. Multiplex select thread can either accept or reject the request to connect to a communication partner based at least in part on whether sufficient resources exist to form the connection.

Reference number illustrates handler requesting a connection with connect function . Similarly reference number illustrates handler reading data from a multiplexed connection. Other handlers for other protocols not shown can access multiplex select thread to perform similar input output functions as shown by reference number .

Turning now to the particular methods associated with embodiments of the invention are described in terms of computer software and hardware with reference to a flowchart. The methods to be performed by a computing device e.g. an application server may constitute state machines or computer programs made up of computer executable instructions. The computer executable instructions may be written in a computer programming language or may be embodied in firmware logic. If written in a programming language conforming to a recognized standard such instructions can be executed on a variety of hardware platforms and for interface to a variety of operating systems. In addition embodiments of the invention are not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement embodiments of the invention as described herein. Furthermore it is common in the art to speak of software in one form or another e.g. program procedure process application etc. as taking an action or causing a result. Such expressions are merely a shorthand way of saying that execution of the software by a computing device causes the device to perform an action or produce a result.

Referring to process block the dynamically loadable protocol handler receives an indication that a network connection endpoint is available for an input output function. The received indication may be for example a return from a select thread e.g. multiplex select thread shown in indicating that a network connection is ready for an input output function or may be an indication on the connection oriented shared memory indicating that data is ready for processing.

Referring to process block an input output function of the dynamically loadable protocol handler is performed. Examples of input output functions include read functions write functions and connect functions. In an embodiment the fragmentation of network messages is supported. In such an embodiment read write functions may read write either an entire message or only a portion of the message e.g. a message fragment . The read write function may be repeatedly called until the entire message is read from the connection or written to the connection. The process can be repeated as shown by .

The architectures and methodologies discussed above may be implemented with various types of computing systems such as an application server that includes a Java 2 Enterprise Edition J2EE server that supports Enterprise Java Bean EJB components and EJB containers at the business layer and or Servlets and Java Server Pages JSP at the presentation layer . Of course other embodiments may be implemented in the context of various different software platforms including by way of example Microsoft .NET Windows NT Microsoft Transaction Server MTS the Advanced Business Application Programming ABAP platforms developed by SAP AG and comparable platforms.

Processes taught by the discussion above may be performed with program code such as machine executable instructions which cause a machine such as a virtual machine a general purpose processor disposed on a semiconductor chip or special purpose processor disposed on a semiconductor chip to perform certain functions. Alternatively these functions may be performed by specific hardware components that contain hardwired logic for performing the functions or by any combination of programmed computer components and custom hardware components.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks compact disks read only memory CD ROMs digital versatile video disks DVD ROMs erasable programmable read only memory EPROMs electrically erasable programmable read only memory EEPROMs magnetic or optical cards or other type of computer readable media suitable for storing electronic instructions.

It is believed that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a Java 2 Enterprise Edition J2EE environment or environments defined by other releases of the Java standard or other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation .

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will however be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

