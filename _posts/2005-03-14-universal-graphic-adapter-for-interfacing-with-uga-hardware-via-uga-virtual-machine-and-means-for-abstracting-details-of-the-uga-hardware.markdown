---

title: Universal graphic adapter for interfacing with UGA hardware via UGA virtual machine and means for abstracting details of the UGA hardware
abstract: The subject invention relates to a Universal Graphics Adapter (UGA) that is a hardware-independent design that encapsulates and abstracts low-level graphics hardware in a standard manner through firmware. UGA is a firmware standard, intended to wrap existing or planned hardware, including VGA. UGA does not require the use of real-mode assembly language, direct hardware register, or frame buffer access to program, thus providing advantages over conventional systems. UGA supports basic drawing operations, continuous display modes, and power management. As a firmware-based standard, UGA facilitates updating a system to support both evolving and new hardware features.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07562161&OS=07562161&RS=07562161
owner: Microsoft Corporation
number: 07562161
owner_city: Redmond
owner_country: US
publication_date: 20050314
---
This application is a Continuation of U.S. patent application Ser. No. 10 157 067 entitled UNIVERSAL GRAPHIC ADAPTER FOR INTERFACING WITH HARDWARE AND MEANS FOR ENCAPSULATING AND ABSTRACTING DETAILS OF THE HARDWARE filed May 29 2002 and is related to U.S. Divisional patent application Ser. No. 10 885 955 entitled UNIVERSAL GRAPHICS ADAPTER filed Jul. 7 2004. This application claims the benefit of U.S. Provisional Patent application Ser. No. 60 341 140 entitled UNIVERSAL GRAPHICS ADAPTER filed Dec. 13 2001. The entireties of the above noted applications are incorporated by reference herein.

The present invention relates generally to video graphics display and more particularly to hardware independent video display facilitated through firmware services that abstract video hardware and expose an interface to an operating system.

Video graphics array VGA is a graphics display system for personal computers PCs . VGA has become one of the de facto standards for PCs providing a resolution of 720 by 400 pixels in text mode and a choice of resolutions in graphics mode e.g. 640 by 480 by 16 colors 320 by 200 by 256 colors . VGA is a hardware specific standard that employs analog signals not digital signals. Other standards have appeared since the 1987 VGA debut but VGA remains the lowest common denominator standard and thus substantially all PCs support VGA. However VGA has drawbacks.

For example VGA is hardware specific and thus to program to VGA requires knowledge of hardware software and assembly and or machine language which makes such programming difficult. Furthermore some of the original requirements of VGA are becoming harder to support as the PC continues to evolve requiring extensive rework of assembler and or machine coded BIOS Basic Input Output System code to support enhancements. The VGA standard from the 1980s makes demands on hardware and software that are outdated today such as the use of Int 10 services a non linear frame buffer a limited range of display modes and direct register addressing using real mode assembly language. Further limitations include that BIOS code executes in a real mode 86 environment and that the video BIOS image is restricted to an absolute maximum of 64K. Additionally VGA is tied to legacy I O Input Output and memory usage that has a non relocateable memory and a non intuitive non linear frame buffer layout. Also VGA has limited mode support e.g. 80 25 70 Hz characters and 640 480 16 color graphics . VGA also does not support power management which has become increasingly important in mobile computing environments. Also there is no firmware support of VGA adapters in a multiple monitor configuration under existing operating systems.

Substantially all display devices support VGA in addition to the high performance device capabilities they expose. Many PCs require a VGA device to be in the machine before the system can boot and BIOS Power On Self Test POST messages require a VGA device for display. In addition to being a de facto universal standard VGA is also now a dated standard with capabilities that have not changed significantly as the PC platform has evolved.

The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key or critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

Universal Graphics Adapter UGA is a hardware independent design that encapsulates and abstracts low level graphics hardware in a standard manner through firmware. UGA is a firmware standard intended to wrap existing or planned hardware including VGA. UGA does not require the use of real mode assembly language direct hardware register or frame buffer access to program thus providing advantages over conventional systems. UGA supports basic drawing operations continuous display modes and power management. As a firmware based standard UGA facilitates updating a system to support both evolving and new hardware features.

UGA mitigates shortcomings of VGA without making basic graphical operations more difficult to perform. For example use of firmware to wrap hardware implementations facilitates a variety of display adapters complying with a UGA specification without requiring hardware changes. An example UGA firmware interface specification is attached hereto as Appendix A and which is considered part of this patent application specification. UGA facilitates devices supporting multiple BIOS including both UGA and VGA BIOS in for example an Option ROM Read Only Memory . The VGA register set will not be changed so hybrid display adapters will continue to work in existing machines as well as working with a UGA enable operating system. From one point of view UGA extends the concepts of Plug and Play PnP and ACPI behind the PCI bus by providing standardized enumerating and manipulating of child devices of display adapters.

UGA features include but are not limited to hardware details being wrapped by firmware exposed device capabilities being implemented in firmware native mode support being exposed by firmware not requiring access to legacy I O ports or memory employing Base Address Registers BARs in PCI Peripheral Component Interconnect a local bus standard space only not requiring real mode execution environment not limiting size of BIOS to 64K facilitating adding new functionality to the BIOS cross platform support e.g. 86 Itanium improved overall graphics hardware and driver quality and being able to code a BIOS in a higher level language e.g. C vs. assembler machine .

UGA benefits different classes of user in different ways. For example substantially all users benefit from an improved pre and post boot experience. When users first switch on computers they will be presented with a high resolution graphical display on which an OEM Other Equipment Manufacturer can place graphics during and or before a power on self test POST . This can include for example tools for repairing or configuring the system that follow the same paradigm as the operating system. An experienced user who wants to take advantage of multi monitor support will not be required to understand how to disable the VGA BIOS on one of the display adapters. Users upgrading from earlier releases of operating systems on mobile PCs that lack high performance display drivers can benefit from power managed driver support unlike the conventional VGA driver.

UGA has other benefits. For example a BIOS can be developed in a high level language e.g. C C rather than in assembler. Thus a BIOS will be easier to maintain because high level language programming skills are more widely available than assembler skills. Furthermore the BIOS size will not be restricted to 64K so support for new features can be added as they become available and required. Display adapters will be platform independent freed from the hardware restrictions for Int 10 support or 86 assembler thus facilitating adapting and evolving new display hardware. New display adapters will not be required to support the VGA register set in new display adapters thus facilitating innovation in adapter design. Display hardware can be made to support UGA through firmware which can reduce die size. Furthermore independent hardware vendors will not be required to supply a UGA device driver since a UGA driver can be provided as part of an operating system. Thus adapters should be more timely brought to market.

Operating systems can provide a UGA driver. A UGA Hardware Abstraction Layer HAL wraps both native UGA driver support and the VGA driver which facilitates a system supporting the transition between VGA and UGA devices. In one example of the present invention if both supported types are available a system can be configured to default to UGA.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.

Appendix A is an example UGA firmware interface and this Appendix is considered part of this patent application specification.

Appendix B is an example Extensible Firmware Interface Universal Graphics Adaptor EFI UGA Binding Protocol and this Appendix is considered part of this patent application specification.

The present invention is now described with reference to the drawings where like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident however to one skilled in the art that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate description of the present invention.

As used in this application the term computer component is intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a computer component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and a computer. By way of illustration both an application running on a server and the server can be computer components. One or more computer components may reside within a process and or thread of execution and a computer component may be localized on one computer and or distributed between two or more computers.

UGA is a next generation graphics adapter technology that succeeds VGA. UGA abstracts graphics hardware and exposes a UGA firmware interface that facilitates platform independent interaction between entities on the different sides of the firmware interface e.g. an operating system and a graphics display device . The UGA firmware interface is exposed from UGA firmware. In one example of the present invention the system firmware and UGA HAL driver employ the interface to perform basic operations with the UGA hardware. This layer replaces legacy video BIOS. In the example UGA firmware exports a single entry point to the external world e.g. system firmware operating system runtime . One example exported entry point is UgaFwDispatchService which is responsible for dispatching a UGA I O request to an appropriate handler within the UGA firmware based on a UGA device type and I O request type. One example UGA specification therefore defines five UGA device types UgaDtParentBus UgaDtGraphicsController UgaDtOutputController UgaDtOutputPort UgaDtOther to facilitate interacting with an operating system through the entry point.

UGA supplies high resolution high color multiple monitor support GDI Graphics Device Interface acceleration and LFB Linear Frame Buffer layout independence. UGA defines an interface that IHVs Independent Hardware Vendors can implement on UGA hardware to facilitate interacting with an operating system via a UGA firmware. Thus as an operating system firmware and or hardware evolve so long as the interfaces between such entities are maintained such changes can be independent of the other entities which minimizes the impact of such changes on related entities providing advantages over conventional systems where the impact can be greater. For example a graphics display hardware component can be updated to provide a higher resolution. So long as the hardware component maintains the interface to the UGA firmware neither the UGA firmware nor the operating system are required to change due to the graphics display hardware change. This provides an advantage over conventional systems where a hardware component upgrade can require patching the operating system with which it operates.

UGA facilitates dispatching I O service requests for display controller firmware facilitates reporting negotiating and configuring display capability ranges for output controllers and devices facilitates enumerating display controller devices and their children and facilitates power management of display controller devices and their children. Such services facilitate producing a platform independent graphics display environment providing advantages over conventional systems.

UGA defines a firmware interface specification for firmware that can be written in a high level language e.g. C C that can be compiled to be interpreted by a system BIOS and or operating system virtual machine p code and or byte code. The UGA firmware can be located in a display device and or in a system for an integrated environment.

Turning now to by employing the present invention an operating system can interact with abstracted UGA hardware via a UGA firmware stored in a BIOS. Such firmware can be interpreted byte code that was compiled from a higher level language e.g. C C that executes in an on board execution environment. The firmware can implement an interface that facilitates non hardware specific interactions between the operating system and the hardware . Such an interface can include abstractions like device on device off device accept data device provide data and device report children. One example interface is described in Appendix A. Such an interface facilitates a flexible approach for operating system to hardware interaction wherein the details of how the hardware will perform certain tasks are restricted to the hardware. This is contrasted with the conventional situation where an operating system interacts with a VGA hardware through a VGA specific hardware specific BIOS that implements the standard VGA register interface. The BIOS is conventionally coded in a lower level language e.g. assembler machine language .

Turning now to a system that includes a UGA virtual machine that facilitates access via a UGA interface to UGA hardware is illustrated. The UGA virtual machine can be implemented in firmware and stored in a BIOS on a chip associated with the UGA hardware . The system illustrates one configuration of computer components wherein legacy compatibility with VGA hardware is maintained. Conventionally access to VGA hardware has been via an Int 10 VGA I O register interface .

In the system a boot time application and or a run time application can consider the system to have only UGA hardware through the interaction of a hardware abstraction layer HAL and a UGA kernel services . The HAL abstracts the details of video display hardware into an interface. The boot time application calls a boot time display API Application Programming Interface to perform actions like displaying messages during POST and or to display a power on banner e.g. trademark screen . The run time application calls a run time display API to perform display functions e.g. display text display graphics . Although the boot time application and or run time application may desire to interact with UGA hardware the system may only have VGA hardware . Thus the HAL can implement abstracted methods to work with VGA hardware through the conventional register interface . However when UGA hardware is present the HAL can implement the abstracted methods to work through the UGA virtual machine to interact with the UGA hardware .

Turning now to a hierarchy of computer components associated with UGA are illustrated. The hierarchy includes five sample devices defined in the example UGA firmware specification attached as appendix A that facilitate communicating through devices to attached devices. At the top of the hierarchy is a parent device e.g. UgaDtParentBus . An operating system can interact with the parent device which may be a physical and or logical device through the UGA firmware interface. Two pieces of information are employed to communicate with a device a device identifier e.g. with which device do you wish to communicate and a request type e.g. what would you like the device to do . In one example of the present invention what the user would like the device to do is referred to as a service. A UGA firmware interface can define a set of services for devices to perform. Such services can include but are not limited to power management e.g. turn on turn off go to lower power state go to higher power state device description e.g. provide EDID extended display identification data standard data and data communications e.g. accept data provide data .

The hierarchy also includes a graphic controller e.g. UgaDtGraphicsController . Such a controller can perform functions e.g. services for the operating system and can also interact with other child computer components e.g. devices . For example one or more other devices e.g. UgaDtOther can be logically and or physically connected to the controller device . An operating system can communicate through the parent device to the graphics controller and thus to the other device s . Similarly an operating system can communicate through the parent device to the graphics controller and thus to an output controller or e.g. UgaDtOutputController . While one other device and two output controllers and are illustrated it is to be appreciated that a variety of combinations of such devices can be employed with the present invention. The output controller could be connected with an actual output device e.g. an output port associated with a monitor and the output controller could be connected with another actual output device e.g. an output port associated with a television .

The hierarchy an example of which is defined in the UGA firmware specification attached in Appendix A thus facilitates operating system communications with actual output devices and physical and or logical devices residing between the operating system and the actual device. In one example of the present invention one or more of the computer components identified in the hierarchy can be located on a video graphics adapter card. By way of illustration a video graphics card could have two output ports one for a television output and one for a computer monitor output. Such outputs could be operatively connected to output controllers that facilitate performing actions like identifying the capabilities of the output devices and performing power management for the devices. Similarly the output controllers could be operatively connected to a graphics controller which is in turn operatively connected to a bus that facilitates connecting the video graphics adapter card to a host system. Conventionally individually accessing more than one physical and or logical entity on a video graphics card via the VGA register interface was impractical if possible at all. Thus the UGA firmware interface provides advantages over conventional systems with respect to accessing multiple physical and or logical devices located on one physical device.

In view of the exemplary systems shown and described above methodologies that are implemented in accordance with the present invention will be better appreciated with reference to the flow diagrams of . While for purposes of simplicity of explanation the illustrated methodologies are shown and described as a series of blocks it is to be understood and appreciated that the present invention is not limited by the order of the blocks as some blocks can in accordance with the present invention occur in different orders and or concurrently with other blocks from that shown and described herein. Moreover not all illustrated blocks may be required to implement a methodology in accordance with the present invention. Furthermore additional and or alternative methodologies can employ additional blocks not illustrated herein. In one example of the present invention such methodologies can be implemented as computer executable instructions and or operations which instructions and or operations can be stored on computer readable media including but not limited to an ASIC a CD a DVD a RAM a ROM a PROM an EEPROM a disk a carrier wave and a memory stick.

Turning now to a method for I O service request dispatching is flow charted. At a UGA client establishes a context that includes establishing information like a device identity a location and size of an input buffer a location and size of an output buffer and a request type. At a method e.g. UgaHalDispatchService Context IoRequest is called to begin dispatching the abstracted service through the layers of the UGA firmware interface. At a determination is made concerning whether the context established at is valid and at a determination is made concerning whether the requested I O action is valid. If the determination at either or is NO then processing proceeds to where a status code is generated. But if the determinations and are YES then processing proceeds to .

At a determination is made concerning whether there is UGA hardware available for the abstracted UGA service that has been requested. If the determination at is NO then there is no UGA hardware and the abstracted UGA calls can be processed by emulation to interact with the VGA hardware that is available. But if the determination at is YES then at the service is dispatched to the next lowest level in the UGA firmware interface. Similarly at the service is dispatched to the next lowest level until at through the actual service routine is invoked. The service routines and through represent a set of services for a first UGA device. The service routines and through represent a set of services for a second UGA device. UGA devices implement a set of abstracted UGA services. Thus UGA devices can appear like an abstracted hardware that implements an interface to a UGA client which simplifies operating system to hardware communications and control. This abstraction contrasts directly with the conventional VGA register interface where the operating system has to be aware of and implement the register interface for communications with VGA hardware.

Thus to invoke a UGA firmware method a UGA client can call an entry point e.g. UgaFwDispatchService that is exported from UGA firmware supplying UGA device specific context and UGA I O request blocks. The UGA device context is employed by the UGA firmware to identify a UGA device for which the I O request is intended. The UGA client provides a memory storage for a UGA device context a UGA I O request block and input and output buffers associated with the UGA I O request block. The UGA client populates a UGA I O request block request code and the location s and size s of input and or output buffers. Upon successful completion of an I O request UGA firmware places the number of returned bytes into an I O request block and can based on UGA I O request code and device context fill the output buffer with the requested data. UGA firmware can return a status code indicating the status e.g. success failure of the I O request for each UGA I O request.

A UGA firmware runtime environment e.g. system firmware operating system can implement a UGA Hardware Abstraction Layer UGA HAL to facilitate a common interface to UGA and non UGA e.g. VGA display devices. Thus a firmware client can assume that UGA firmware is available and for non UGA devices the UGA HAL facilitates translating UGA I O requests from the UGA client and non UGA e.g. VGA firewire network output device. Furthermore firmware that is UGA specification compliant can be implemented for display controller devices that are not local. Remote display devices appear as a local display device to the UGA client including the UGA HAL.

Turning now to a method for negotiating output ranges is flow charted. Output ranges are associated with what a display device can do. For example a first display device may be able to display 640 by 480 60 Hz while a second display device may be able to display 1280 by 1024 80 Hz. If both display devices are associated with the same graphics controller then the present invention can be employed to ascertain the intersection between the performance capabilities of the devices.

At initial values are established. Such initial values can include but are not limited to establishing an index to the set of available devices and establishing a context for the output controller. At information concerning the capabilities of a device are read. For example a UgaFwGetEdidSegment context call can be made to retrieve EDID data e.g. 128 byte 256 byte descriptions of the capabilities of a device. Such EDID data can contain discrete values e.g. for a device with one capability and or a range of values e.g. for multi capability devices . A determination at is made concerning whether this is the first device read. If so then a determination is made at concerning whether the data read succeeded. If not then a fatal error has occurred and processing proceeds to . But if the read succeeded then at the currently determined output ranges are established as the initial ranges read at . If this was not the first read then a determination is made at concerning whether the read succeeded. If the read did not succeed then processing continues at where the next potential device is identified and a context is established to facilitate reading description data from that next device. If the read did succeed then processing continues at where an intersection between previously determined ranges and the currently read range is performed. At a determination is made concerning whether the intersection computation has determined a new range. If so then at the determined intersection ranges are updated and processing proceeds to .

At a determination is made concerning whether there is another device from which descriptive data is to be read. If the determination is YES then processing proceeds to where such descriptive data is read. If the determination is NO then processing concludes and video modes that lie within the determined output ranges can safely be employed.

Thus system firmware and or an operating system intersect display capabilities data returned for output controllers and output ports attached to the controllers. The intersections define video mode ranges that are supported by connected devices. Thus a mode identified in the intersection can be set on an output controller and can be displayed on the output device attached to the output port attached to the output controller.

Based at least in part on the EDID data returned for output ports and or controllers supported intersected video mode ranges may contain discreet or contiguous sets of available modes. Thus system firmware and or an operating system can request a mode from the intersected ranges. Then the system firmware and or operating system can invoke a UGA firmware video setting method e.g. UgaFwSetVideoMode on an output controller specifying device context I O request type and requested mode data e.g. horizontal resolution vertical resolution color depth refresh rate and based on such information the UGA firmware can dispatch an I O handler method for the I O request and the UGA child device. The UGA firmware can employ for example a table driven algorithm that analyzes discrete mode ranges and or a timing formula e.g. VESA GTF for contiguous and or discreet mode ranges to program UGA hardware to set a requested mode.

At a determination is made concerning whether there was a valid parent context. If not then the depth first traversal has completed. If so then processing proceeds to where the next iteration of the recursive enumeration is begun.

Such a recursive enumeration method facilitates UGA firmware supporting a variety of devices. A UGA firmware specification can define a set of I O services that are implemented in UGA firmware for enumerated UGA devices. Service types are associated with UGA I O request codes and such I O request codes can be added to a UGA firmware specification. The UGA firmware I O model is designed to facilitate new I O request codes and or new device types being added to a UGA firmware specification while preserving compatibility between UGA clients UGA runtime environments and UGA firmware.

By employing a recursive enumeration method UGA firmware supports one or more video child devices that include but are not limited to a parent bus a graphics controller an output controller an output port and other device types. For enumerated UGA devices the UGA firmware can provide an additional device descriptor data that can be interpreted by a system BIOS and IHV video driver a standardized PnP identifier to support generic child device driver support and a device description string. UGA devices can be associated with a unique context or a shared context can be shared by UGA devices associated with a single UGA adapter.

To enumerate UGA devices system firmware and or an operating system traverse a UGA device tree using for example a depth first traversal algorithm. UGA firmware method calls e.g. UgaFwStartDevice UgaFwGetChildDevice can be invoked for the devices. In one example of the present invention a device context creation method and a start method for a parent device are executed before child devices are enumerated and or started.

The system BIOS and or operating system pass device context and I O request types to UGA firmware which based on the information can dispatch an I O handler method for the I O request and UGA child device. By employing a recursive enumeration method UGA firmware can support one or more output controllers and or output ports. Such enumerated ports can be attached to a physical output device e.g. CRTC monitor flat panel television . For enumerated output ports the system firmware and or operating system invokes a data acquisition method e.g. UgaFwGetEdidSegment specifying a device context and I O request type. Based on such information the UGA firmware dispatches an I O handler method for the I O request and the UGA child device. The UGA firmware then returns display identification and configuration data for the output device attached to the output port. Such information can be returned for example in the EDID format defined in the VESA Video Electronics Standards Association standard. The UGA firmware reads the EDID information from the output device by for example DDC display data channel standard and or an implementation specific communication channel. The UGA firmware can if the EDID data cannot be obtained from the output device create an EDID.

If the UGA firmware does not implement or fails while employing a data acquisition method e.g. UgaFwGetEdidSegment for an output port device then the UGA firmware implements a set of device channel I O routines e.g. UgaFwDeviceChannelOpen UgaFwDeviceChannelRead UgaFwDeviceChannelWrite UgaFwDeviceChannelClose which enable system firmware and or an operating system to communicate directly with output devices over DDC or other implementation specific communication channels.

Similar to processing for output ports for enumerated output controllers the system firmware and or operating system invokes a data acquisition method e.g. UgaFwGetEdidSegment specifying a device context and I O request type. Based on such information the UGA firmware dispatches an I O handler method for the I O request and the UGA child device. The UGA firmware then returns display identification and configuration data for the output controller. Such information can be returned for example in the VESA EDID format. EDID data for output controller devices is provided by UGA firmware based on the hardware capabilities of the UGA display adapter. In one example of the present invention the data acquisition method must be implemented in the UGA firmware for output controller devices.

Concerning power management facilitated by the present invention a top down tree traversal can be employed for power up and a bottom up tree traversal can be employed for power down. For devices UGA firmware methods e.g. UgaFwSetPowerState can be invoked to probe a power state and cause power changes. Such methods can be vetoed in which case power state setting methods previously invoked can be cancelled. The system firmware and or operating system can pass device context I O request types power request types requested device states and requested power states to UGA firmware. Thus UGA devices can support multiple power states and UGA firmware can dispatch I O handler methods for I O requests and child devices related to such power state management.

One example of the present invention implements UGA as an EFI Extensible Firmware Interface driver. Thus an EFI UGA Binding Protocol is attached hereto as Appendix B which is considered part of this patent application specification.

In order to provide additional context for various aspects of the present invention and the following discussion are intended to provide a brief general description of a suitable computing environment in which the various aspects of the present invention may be implemented. While the invention has been described above in the general context of computer executable components instructions and or operations that may run on one or more computers those skilled in the art will recognize that the invention also may be implemented in combination with other program modules and or as a combination of hardware and software. Generally program modules include routines programs components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with computer system configurations including single processor or multiprocessor computer systems minicomputers mainframe computers personal computers hand held computing devices microprocessor based or programmable consumer electronics and the like each of which may be operatively coupled to one or more associated devices. The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects of the invention includes a computer the computer including a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit may be any of various processors. Dual microprocessors and other multi processor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer such as during start up is stored in ROM . The BIOS can include for example the UGA firmware.

The computer further includes a hard disk drive a magnetic disk drive e.g. to read from or write to a removable disk and an optical disk drive e.g. for reading a CD ROM disk or to read from or write to other optical media . The hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of data data structures computer components computer executable instructions etc. for the computer . Although the description of computer readable media above refers to a hard disk a removable magnetic disk and a CD it should be appreciated that other types of media that are readable by a computer such as zip drives magnetic cassettes flash memory cards digital video disks cartridges ASICs and the like may also be used in the exemplary operating environment and further that any such media may contain computer executable instructions for performing the methods of the present invention.

A number of program modules can be stored in the drives and RAM including an operating system one or more application programs other program modules and program data . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.

A user can enter commands and information into the computer through a keyboard and a pointing device such as a mouse . Other input devices not shown may include a microphone an IR remote control a joystick a game pad a satellite dish a scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port a game port a universal serial bus USB an IR infrared interface etc. A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor a computer typically includes other peripheral output devices not shown such as speakers printers etc.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer s . The remote computer s may be a workstation a server computer a router a personal computer microprocessor based entertainment appliance a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated. The logical connections depicted include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN environment the computer is connected to the local network through a network interface or adapter . When used in a WAN environment the computer typically includes a modem or is connected to a communications server on the LAN or has other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

What has been described above includes examples of the present invention. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly the present invention is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted as a transitional word in a claim.

UgaFwXxxx methods exported by UGA firmware to system firmware and operating system and UGA IO request handlers.

VmlXxxx methods exported by Virtual Machine VM to UGA firmware via UGAVMXXX.LIB I O library. Note l in the prefix is a lower case L.

UGA firmware interface is exposed from UGA firmware. The system firmware and UGA HAL driver use this interface to perform basic operations with UGA hardware. This layer replaces legacy video BIOS.

UGA CHANNEL TRANSFER contains information required by the UGA firmware to perform data transfers between open device channel and memory buffer.

UGA DEVICE specifies a device object associated with a device enumerated by UgaFwGetChildDevice. System firmware operating system allocates UGA DEVICE for each enumerated device. A pointer to this object is passed to UGA firmware methods. This is an opaque object UGA firmware cannot dereference any of its fields directly its layout may change without notice.

UGA MEMORY TRANSFER contains information required by the UGA firmware to perform memory data transfers.

UGA firmware exports a single entry point to the external world system firmware operating system runtime . The exported entry point is called UgaFwDispatchService. UgaFwDispatchService is responsible for dispatching the UGA IO request to the proper handler within the UGA firmware based on UGA device type and IO request type.

UgaFwDispatchService is called with two arguments PUGA DEVICE pDevice and PUGA IO REQUEST pIoRequest. UgaFwDispatchService can determine the device type the request is intended for calling VM Library method VmlGetDeviceType pDevice . UGA firmware cannot dereference directly any fields within UGA DEVICE data structure this is an opaque object and its internal layout may change in the future without notice.

UGA IO REQUEST contains pointers to input and output buffers lengths of both buffers field to store a number of bytes returned by UGA firmware in the output buffer and the IO request code in the UGA IO REQUEST.ioRequestCode field.

TBD Should we declare UGA IO REQUEST an opaque object as well and define methods to manipulate its fields 

For each UGA device UGA firmware will initially receive UgaIoStartDevice followed by UgaIoGetChildDevice IO requests moving from the top to the bottom of the UGA device tree. Other IO requests will be received after devices have been enumerated and started. UgaDtParentBus is a special case it is intended to seed UGA device enumeration process and it will not be used for anything else than UgaIoGetVersion and UgaIoGetChildDevice.

UgaFwDispatchService is the only entry point exported from UGA firmware and it is used as the main UGA service dispatch routine.

UgaFwBtPrivateInterface provides a way to send OEM IHV specific requests to the UGA firmware and to exchange free formatted data between the system and UGA firmware.

UgaFwCopyRectangle copies data from video to video memory from system to video memory or from video to system memory.

Bitmap translations between source and destination regions are not supported both regions must use the same format. UGA 1.0 supports only 16 bpp as RGB 565 and 32 bpp as xRGB.

This is a required method with the exception of OEM systems with built in non PnP displays e.g. laptops which do not support external PnP display devices. For such OEM systems UgaFwGetEdidSegment method must be implemented.

UgaFwDeviceChannelClose is mainly intended for retrieving EDID data from display devices flexible support for new EDID formats . Additionally IHV driver writers can use this method to communicate with other video child devices.

UgaFwGetChildDevice UgaFwDeviceChannelOpen UgaFwDeviceChannelRead UgaFwDeviceChannelWrite UgaFwGetEdidSegment.

This is a required method with the exception of OEM systems with built in non PnP displays e.g. laptops which do not support external PnP display devices. For such OEM systems UgaFwGetEdidSegment method must be implemented.

UgaFwDeviceChannelOpen is mainly intended for retrieving EDID data from display devices flexible support for new EDID formats . Additionally IHV driver writers can use this method to communicate with other video child devices.

UgaFwGetChildDevice UgaFwDeviceChannelRead UgaFwDeviceChannelWrite UgaFwDeviceChannelClose UgaFwGetEdidSegment.

This is a required method with the exception of OEM systems with built in non PnP displays e.g. laptops which do not support external PnP display devices. For such OEM systems UgaFwGetEdidSegment method must be implemented.

UgaFwDeviceChannelRead is mainly intended for retrieving EDID data from display devices flexible support for new EDID formats . Additionally IHV driver writers can use this method to communicate with other video child devices.

UgaFwGetChildDevice UgaFwDeviceChannelOpen UgaFwDeviceChannelClose UgaFwDeviceChannelWrite UgaFwGetEdidSegment.

This is a required method with the exception of OEM systems with built in non PnP displays e.g. laptops which do not support external PnP display devices. For such OEM systems UgaFwGetEdidSegment method must be implemented.

UgaFwDeviceChannelWrite is mainly intended for retrieving EDID data from display devices flexible support for new EDID formats . Additionally IHV driver writers can use this method to communicate with other video child devices.

UgaFwGetChildDevice UgaFwDeviceChannelOpen UgaFwDeviceChannelClose UgaFwDeviceChannelRead UgaFwGetEdidSegment.

UgaFwFlushDevice is responsible for flushing any pending writes to hardware making sure all DMA operations are completed etc.

UGA hardware must remain fully idle upon return from this routine until some other UGA method is called system firmware OS may be touching PCI configuration space of this device.

UgaFwGetChildDevice must report all devices which are supported by UGA adapter regardless if they are available or not at the time of enumeration. UgaFwGetDeviceState method will be used to determine a current state of devices on per needed bases.

Setting UGA DEVICE DATA.ui32SharedContextSize property to non zero value tells the run time environment to allocate shared context buffer of given size associate it with currently enumerated device and point all subsequently enumerated devices to the same buffer as long as enumeration returns zero as shared context size for those devices. In general shared context size should be set to non zero value only for the root device and to zero for all subsequently enumerated devices.

Additional information about UGA devices can be obtained using UgaFwGetDevicePropertySize and UgaFwGetDeviceProperty methods.

For UgaDtOutputController devices UgaFwGetEdidSegment returns capabilities of individual output controllers i.e. capabilities of the video adapter itself.

This method can fail if UGA firmware provides I2C methods for given UgaDtOutputPort device and EDID for that device is accessible via I2C protocol. This method must always succeed for UgaDtOutputController devices and for UgaDtOutputPort devices not supporting I2C protocol by default e.g. TV some laptop flat panel displays .

Video memory configuration data varies based on currently selected video mode. UgaFwGetMemoryConfiguration will be typically called after UgaFwSetVideoMode call.

UgaFwGetPersistentData returns a free formatted IHV defined device configuration data. This data is stored by a system firmware on a non volatile media and it is persistent over a reboot.

UgaFwGetPersistentDataSize returns a size in bytes of a persistent storage area available for UGA device. A persistent storage area for a device is provided by a system firmware and hardware.

This method cannot fail for UgaDtGraphicsController and UgaDtOutputController devices it must reset those devices to the initial state where any other UGA method can be used especially UgaFwSetVideoMode. UgaFwResetDevice will be used by the operating system in the case of emergency.

To determine an actual state of a device at any time a call to UgaFwGetDeviceState must be issued. Caller should not make any assumptions about current device state based on device state value passed to UgaFwSetDeviceState.

If UgaFwSetDeviceState is called for UgaDtOutputController and UgaDtOutputPort devices then UGA firmware should expect UgaFwSetVideoMode call to follow i.e. UGA firmware should not set video mode on its own even if this is required to complete a set state request.

UgaFwSetPersistentData writes a free formatted IHV defined device configuration data. This data is stored by a system firmware on a non volatile media and it is persistent over a reboot.

The device must remain idle between UgaPrProbe and UgaPrCommit or UgaPrCancel requests. This method cannot fail UgaPrCommit request.

Specifies a device object associated with a device enumerated by UgaFwGetChildDevice. Each device enumerated by UgaFwGetChildDevice has a unique device object associated with it.

For add in UGA adapters 800 600 32 bpp at 60 Hz must be supported. This mode is optional for integrated video implementations.

UgaFwStartDevice powers on and initializes device associated with device object to the state when other UGA firmware methods can be used with that device.

UgaFwStartDevice code in not discardable It is used by the firmware during the POST INIT faze of boot process but it may be used by the OS at any other time as well e.g. during multi monitor initialization or during the power management cycles.

UgaFwStopDevice stops UGA device. It is responsible for cleaning up all resources associated with pDevice pDevice will be gone 

Virtual machine interface is exposed by the system firmware boot time and by the operating system run time . UGA firmware uses this interface to request basic services from its run environment. The UGA VM stub is included as a part of UGA VMXXX.LIB static library that UGA firmware code is linked with.

VmlBtPrivateInterface provides a way to send OEM IHV specific requests to the system firmware and to exchange free formatted data between the UGA and system firmware. This method is available only at the boot time and is not exported from the VM at the OS run time.

VmlCopySystemMemory copies data from the source location in the system memory to the destination location in the system memory.

pvDestination and pvSource must point to the addresses in the system memory. This function cannot be used to access device physical memory. Source Length cannot overlap Destination.

UgaFwGetChildDevice VmlPciAllocateCommonBuffer VmlPciMapSystemMemory VmlPciReadDeviceMemory VmlPciWriteDeviceMemory.

UGA firmware specifies the size of the device context for each enumerated UGA device in the UgaFwGetChildDevice handler of the parent device. The device context size of the child device is returned in the UGA DEVICE DATA.ui32DeviceContextSize field.

VmlGetDeviceId returns IHV defined device specific device ID associated with a device object pointed by pDevice.

UGA firmware specifies device ID for each enumerated UGA device in the UgaFwGetChildDevice handler of the parent device. The device ID value for the child device is returned in the UGA DEVICE DATA.deviceId field.

UGA firmware specifies device type for each enumerated UGA device in the UgaFwGetChildDevice handler of the parent device. The device type value for the child device is returned in the UGA DEVICE DATA.deviceType field.

VmlGetParentDevice returns a pointer to the parent device object of the device associated with a device object pointed by pDevice.

UGA runtime environment maintains a link to the parent device only. UGA firmware itself can maintain links to child devices in device context if needed using VmlGetParentDevice and VmlGetDeviceContext for parent device in UgaFwStartDevice handler for example .

VmlGetPersistentData returns a free formatted IHV OEM defined device configuration data. This data is stored by a system firmware on a non volatile media and it is persistent over a reboot.

VmlGetPersistentDataSize returns a size in bytes of a persistent storage area available for a device. A persistent storage area for a device is provided by a system firmware and hardware.

VmlGetSharedContext returns a pointer to IHV defined context shared between all devices enumerated by UGA firmware for given display adapter.

UGA firmware must specify the same size of the shared context for each enumerated UGA device in the UgaFwGetChildDevice handlers. The shared context size is returned in the UGA DEVICE DATA.ui32SharedContextSize field.

VmlPciAllocateCommonBuffer allocates contiguous non pageable system memory and maps it so that it is simultaneously accessible from both the processor and a device for DMA operations.

VmlPciAllocateCommonBuffer allocates system memory that can be reached from both the processor and the device. This memory appears contiguous to the device. This method sets up a translation for the device including loading map registers if necessary.

VmlPciAllocateCommonBuffer allocates at least a page of memory regardless of the requested ui64Length. After a successful allocation requesting fewer than PAGE SIZE bytes the caller can access only the requested ui64Length. After a successful allocation requesting more than an integral multiple of PAGE SIZE bytes any remaining bytes on the last allocated page are inaccessible to the caller.

If UGA firmware needs several pages of common buffer space but the pages need not be contiguous the driver should make several one page requests to VmlPciAllocateCommonBuffer instead of one large request. This approach conserves contiguous memory.

VmlPciFreeCommonBuffer frees a common buffer allocated by VmlPciAllocateCommonBuffer along with all resources the buffer uses.

The parameters passed to VmlPciFreeCommonBuffer must match exactly those passed to and returned from VmlPciAllocateCommonBuffer. UGA firmware cannot free part of an allocated common buffer.

VmlPciLockSystemMemory makes physical pages mapped by the virtual address range resident and locked in the memory.

VmlPciLockSystemMemory may have to allocate temporary transfer buffer visible to PCI device. In this case VmlPciLockSystemMemory will copy the content of the buffer pointed by pvHostAddress to that temporary transfer buffer for UgaMtSystemToVideo transfer operation and VmlPciUnlockSystemMemory will copy the content of temporary transfer buffer to UgaMtVideoToSystem operation. Because of possibility of this dual buffering it is illegal for the CPU to access directly buffer pointed by pvHostAddress between matching VmlPciLockSystemMemory and VmlPciUnlockSystemMemory for given transfer operation.

If the length returned in pui64Length is smaller than the initial value then the pvAddress can be advanced by returned length and VmlPciLockSystemMemory can be called again for the remaining length. This operation can be repeated till the whole memory region is successfully locked. If multiple calls to VmlPciLockSystemMemory must be used to lock whole memory region then it means that virtual contiguous memory region is mapped into multiple detached contiguous physical memory blocks. In this case multiple mapping values will be returned as well via ppvMapping argument. Caller must store all retuned mapping values in order to use them with matching calls to VmlPciUnlockSystemMemory.

VmlPciPollDeviceIoPort returns UGA STATUS TIMEOUT when there is no match before timeout is reached. Otherwise VmlPciPollDeviceIoPort returns UGA STATUS SUCCESS immediately after matching pattern is read.

VmlPciPollDeviceMemory returns UGA STATUS TIMEOUT when there is no match before timeout is reached. Otherwise VmlPciPollDeviceMemory returns UGA STATUS SUCCESS immediately after matching pattern is read.

VmlPciLockSystemMemory may have to allocate temporary transfer buffer visible to PCI device. In this case VmlPciLockSystemMemory will copy the content of the buffer pointed by pvHostAddress to that temporary transfer buffer for UgaMtSystemToVideo transfer operation and VmlPciUnlockSystemMemory will copy the content of temporary transfer buffer to UgaMtVideoToSystem operation. Because of possibility of this dual buffering it is illegal for the CPU to access directly buffer pointed by pvHostAddress between matching VmlPciLockSystemMemory and VmlPciUnlockSystemMemory for given transfer operation.

UGA firmware cannot unlock a part of locked contiguous physical memory block. If the multiple calls had to be used to lock a contiguous virtual memory block mapped into multiple disconnected contiguous physical memory blocks then the caller must use multiple matching calls to VmlPciUnlockSystemMemory to unlock multiple blocks of physical memory passing pvHostAddress ui64Length and pvMapping corresponding to each physical memory block.

VmlPciUnmapDeviceIoSpace unmaps device specific physical IO address range mapped by VmlPciMapDeviceIoSpace.

The parameters passed to VmlPciUnmapDeviceIoSpace must match exactly those passed to and returned from VmlPciMapDeviceIoSpace. UGA firmware cannot unmap a part of mapped device physical IO range.

VmlPciUnmapDeviceMemory unmaps a device specific physical memory address range mapped by VmlPciMapDeviceMemory.

The parameters passed to VmlPciUnmapDeviceMemory must match exactly those passed to and returned from VmlPciMapDeviceMemory. UGA firmware cannot unmap a part of mapped device physical memory range.

VmlSetPersistentData writes a free formatted IHV OEM defined device configuration data. This data is stored by a system firmware on a non volatile media and it is persistent over a reboot.

EFI UGA IO PROTOCOL provides an EFI interface to display adapter firmware one that is compliant with the UGA Firmware Interface Specification. In order to simplify EFI client code implementation EFI UGA IO PROTOCOL exports CreateDevice and DeleteDevice methods in addition to a single UGA firmware dispatch entry point.

The EFI UGA IO PROTOCOL implementation and EFI UGA driver binding code samples shown in this document are completely generic and are independent of the display hardware architecture. They can be provided as a part of an EFI driver library.

This section lists the EFI UGA IO PROTOCOL methods. These methods are used to create and initialize a UGA device object delete a UGA device object and send an I O request packet to a UGA device object.

Video IHVs do not need to implement this method. It is included in the EFI VML static library. For implementation details see Section 2.1 EFI UGA Binding and EFI UGA IO PROTOCOL Implementation Sample.

The EFI UGA IO DELETE DEVICE method deletes a UGA device object that was created in a previous call to the EFI UGA IO CREATE DEVICE method.

Video IHVs do not need to implement this method. It is included in the EFI VML static library. For implementation details see the sample code in Section 2.1 EFI UGA Binding and EFI UGA IO PROTOCOL Implementation Sample.

Video IHVs must implement this method. For a sample implementation see Section 2.2 UGA Firmware Interface Implementation Sample.

This method is the main UGA firmware service dispatch routine. In addition to implementing this method video IHVs must implement any of the functions that are specified in IORequest.ioRequestCode. See the UGA IO REQUEST CODE enumeration for a list of names of the functions that this method can call. 

The structures listed in this section are used by the EFI UGA IO PROTOCOL methods to hold information about a particular UGA device object.

The EFI UGA IO PROTOCOL structure contains the addresses of functions used to create a UGA device delete a UGA device and send messages to a UGA device.

The EFI UGA IO PROTOCOL CONTEXT structure contains the information of an EFI UGA IO PROTOCOL structure together with the handle associated with a PCI video adapter.

This section provides sample code that illustrates how to implement EFI UGA Binding and EFI UGA IO PROTOCOL. The section also provides sample code for a UGA Firmware Interface implementation.

This code and information is provided as is without warranty of any kind either expressed or implied including but not limited to the implied warranties of merchantability and or fitness for a particular purpose.

This code and information is provided as is without warranty of any kind either expressed or implied including but not limited to the implied warranties of merchantability and or fitness for a particular purpose.

This code and information is provided as is without warranty of any kind either expressed or implied including but not limited to the implied warranties of merchantability and or fitness for a particular purpose.

