---

title: Lightweight highly available infrastructure to trace program execution
abstract: A portable tracing utility provides trace configuration, trace instrumentation and trace management functionality for single or multithreaded programs. Through various application programming interfaces (“APIs”) of the tracing utility, a client may control tracing behavior to setup in-memory data structures for storing trace records that record the program's history of execution or to alter the granularity of execution history being traced. The trace behavior can be modified during the life of a program by using the APIs, either dynamically when the program assumes certain states, or through remote procedure calls issued by, for example, an external interface. Programs are instrumented with these APIs to record the history of execution, which during execution of the program is stored in circular in-memory buffers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07770154&OS=07770154&RS=07770154
owner: Oracle International Corporation
number: 07770154
owner_city: Redwood Shores
owner_country: US
publication_date: 20050701
---
The present invention relates to tracing execution history of a program and in particular implementing portable utilities that facilitate and standardize the implementation of tracing.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

It is often useful to know the execution history of a program to analyze the underlying software and resolve defects and performance issues. Programs analyzed can be single threaded programs or be complex multithreaded execution entities.

Tools for analyzing programs include debuggers that attach to a program to perform step by step or breakpoint by breakpoint execution to examine the current contents of program data structures at a particular step or breakpoint. Although this approach gives a peek into the state of the program at an instant of the program s execution the approach provides no history of execution. Despite the lack of execution history these type of debuggers may be useful for analyzing simple programs. However for analyzing complex programs on live production systems the lack of execution history impairs the usefulness of these types of debuggers as a tool for analyzing programs.

Programs sometimes store trace records in persistent storage such as files on disks that capture the execution history. However this approach involves significant runtime overhead. The overhead causes programmers to restrict tracing to such a degree that the ability to effectively perform first pass diagnosis when a problem occurs is substantially impaired.

Based on the foregoing there is clearly a need to provide a mechanism that allows tracing to be implemented in a way that reduces overhead.

A method and apparatus for tracing is described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

A portable tracing utility provides trace configuration trace instrumentation and trace management functionality for single or multithreaded programs. Through various application programming interfaces APIs of the tracing utility a client may control tracing behavior to setup in memory data structures for storing trace records that record the program s history of execution or to alter the granularity of execution history being traced. The trace behavior can be modified during the life of a program by using the APIs either dynamically when the program assumes certain states or through remote procedure calls issued by for example an external interface. Programs are instrumented with these APIs to record the history of execution which during execution of the program is stored in circular in memory buffers.

A utility such as tracing utility is a set of interrelated routines functions procedures subroutines that provide a particular specialized functionality to another set of routines referred to herein as clients. Clients interact with a utility through an API which is a set of routines of a utility that are exposed to clients that is routines that may be referenced by code in the client and called during execution of the client. An example of such a routine is a function with one or more arguments that is invoked by a client.

A utility handles details of a particular functionality many data structures that a utility generates are internal to its routines and may not be accessed by clients of the utility. The behavior of a utility can be controlled by a client through APIs. Data and or information a utility provides to a client is provided through the API or through output stored in storage structures accessible to the client.

For purposes of exposition software modules such as client and tracing utility are described herein as performing particular actions when in fact execution of the software by a process causes the process to perform those actions. For example when client is described as calling an API function or accessing data a process executing the application software is calling the API function or accessing the data.

Utilities are typically developed by vendors and development teams different from those that develop clients. Developers and or vendors that develop client software are referred to herein as client implementers.

Tracing utility provides tracing functionality to clients such as client . A client controls the behavior of tracing utility by invoking API . To record a particular point of execution within client client calls at that particular point a routine of API referred to herein as a trace function.

Client may register with tracing utility one or more components by which to trace execution. This allows tracing to be tracked and managed according to components that a client implementer may define for the client. Also a client may specify the granularity of tracing by specifying one or more tracing levels. The higher the tracing level the greater the granularity.

To record the execution history of client trace records are stored in an in memory e.g. volatile memory virtual memory data structure referred to as a tracing store. The trace records are retained in the in memory tracing store that is the trace records are not necessarily written to persistent storage after being stored in the tracing store. According to an embodiment a tracing store such as tracing store is a circular buffer within the data segment of a process executing a client. A data segment is memory allocated to a process to store interim data created by the process s execution of a client. Other processes cannot access the memory while it is allocated to the process. For this reason the data segment can be accessed very efficiently because for example contention with other processes for access to the memory of the data segment does not have to be coordinated with other processes as in the case of accessing shared memory shared by processes. A circular buffer is a buffer in which data is written at the beginning of the buffer. Afterwards when the buffer has been filled with data data is written at the beginning of buffer again overwriting data previously stored there.

At times it is useful to persistently store the contents of a tracing store. To this end tracing utility may dump all the records stored in tracing store to persistent trace store which may be for example a file.

Alternatively trace records are archived. Specifically trace records are written to persistent storage automatically. Archiving prevents trace records from being overwritten.

According to an embodiment a separate tracing store is used to track the history of each client component being traced. A client may specify different sizes for the tracing store of each component.

Because each component has a dedicated tracing store tracing of one component does not affect the tracing store of another component. Thus trace records generated for one component do not overwrite trace records of another component. This reduces the likelihood that trace records of a component with light tracing activity are overwritten by the trace records of a component with relatively heavy tracing activity.

Control attributes are attributes e.g. variables whose state governs the behavior of tracing utility . Control attributes specify for example whether tracing is enabled and for what tracing level what client components to trace the size of a component s tracing store whether trace records for a particular component are archived and the resource management facilities to manage resources used by tracing e.g. memory management routines file access routines .

Control attributes include two types of control attributes which are dynamic attributes and static attributes . Static attributes are control attributes that can only be set when tracing is initialized. Dynamic attributes can be set any time tracing is occurring for a client.

Client may specify a configuration plug in that is called by tracing utility to initialize some or all of the control attributes. When configuration plug in is called it sets the control attributes by invoking one or more functions of API . The configuration plug in allows client implementers to implement their own logic for controlling the behavior of tracing utility . Client may specify its preferred resource management facilities such as memory management and IO routines in configuration plug in so that these resource management facilities will replace the original defaults used by tracing utility after initialization.

According to an embodiment configuration plug in accesses a client attribute store which stores information about how to configure control attributes. The client attribute store may be configured or maintained by the client or other external software according to any format desired by a developer. This allows client implementers or other developers to develop and use their own customized configuration interfaces tracing configuration interface for configuring tracing utility . The tracing configuration interfaces store information about configuring tracing utility in client attribute store . To configure tracing utility according to information stored in client attribute store tracing utility invokes configuration plug in which in turns configures tracing utility in the way defined by client attribute store and according to logic implemented within configuration plug in .

The configuration plug in is useful for defining and establishing default and or initial tracing behavior for client . When other types of behavior are desired the behavior may be changed dynamically as described below. Also the tracing configuration interface may be used to change the default tracing behavior temporarily or permanently.

Remote procedure call RPC handler is a routine being executed by a thread of a process that executes client . RPC handler listens for RPC messages. A remote procedure call is a call of a routine made by a process in which another process on the same or different node and or computer executes the called routine. The other process is referred to as the remote process. The call is made by transmitting an RPC message that requests execution of a routine to another process over a communication connection such as a network connection. Also input parameters and output parameters are transmitted over the connection and may be included in the message.

RPC messages received by RPC handler may specify some desired behavior and or action by tracing utility to which RPC handler may respond by invoking API to effect the behavior and or action. For example an RPC message may request that contents of tracing store be dumped to persistent trace store or that tracing for a particular component be commenced. When RPC handler receives an RPC message RPC handler responds according to the logic with which it is implemented by calling API to cause tracing utility to dump tracing store to persistent trace store or to cause tracing utility to commence tracing for a particular component.

In general the RPC handler is implemented as one or more routines of client . This entails and allows development of an RPC handler by client implementers.

The RPC messages can be generated by an interface being executed by a process external to any client process. The RPC messages can be directed to a client process on a computer system. The interface can be customized to the tracing needs of the client and its client implementers

Trace records are generated in response to execution of an invocation of a trace function of API within client . To record a particular execution at a point within client client includes an invocation of a trace function at that point.

According to an embodiment of the present invention a client invocation of a trace function specifies a component tracing level and operation. For a particular execution of a call of a trace function tracing utility generates a trace record so long as tracing is active for that component and active for that tracing level.

The trace records in persistent trace store may be viewed through any external process executing a trace viewing tool . An external process is a process different than that being traced. The trace viewing tool may be used to examine the execution history of a client by a process after the process has terminated. In addition the execution history may be viewed on demand while the process is still executing the client by causing tracing utility to dump its contents to persistent trace store and examining the execution history recorded therein.

Furthermore when an execution failure and program dump occurs the trace records might be available in program dumps. If so the trace records can be examined using trace viewing tools. This provides information about a first failure instance that can be used to analyze and debug client code.

Client software often makes use of many utilities. As mentioned before such utilities are separate components typically developed and maintained by development teams separate from the team that develops the client. It is important that these developers be able to develop their software independently with as little coordination as possible.

Using the tracing approaches described herein developers of utilities may independently add tracing functionality to utilities without having to coordinate with developers of client software that make use of those utilities. Because the performance impact of in memory tracing is minimal the tracing of a utility is performed in a way that minimizes impact upon the performance of end user computer systems running the client software. In this way execution of utilities is traced in a way that is transparent to client software and users that use it.

According to an embodiment the states of various combinations of control attributes are defined as a diagnostic state. Through API tracing utility may be set to these diagnostic states. For example to cease all archiving of trace records for all components tracing utility may by default define a diagnostic state of NO ARCHIVE. By invoking API tracing utility may be set to the NO ARCHIVE diagnostic state causing tracing utility to cease all archiving of trace records by setting for each component the state of the control attribute that is needed to cease archiving for that component.

Diagnostic states may be user defined allowing users to establish states of various combinations of control attributes as a diagnostic state. A client may define a diagnostic state by registering a diagnostic state with tracing utility through API . When the client calls API to register a diagnostic state the client supplies a diagnostic state identifier e.g. a string and diagnostic state plug in . The diagnostic state is reached by calling a function of API and identifying the desired diagnostic state in the call. This causes the diagnostic state plug in for the diagnostic state to be invoked. The diagnostic state plug in is used to set control attributes to the state that is associated with the diagnostic state and or to otherwise perform what ever logic needed to reach the state.

For example to increase the amount of information traced for a component of client that opens files OPEN FILE client registers a diagnostic state identified as TRACK OPEN FILE and a diagnostic state plug in. To set tracing utility to the diagnostic state TRACK OPEN FILE client invokes API . Alternatively an RPC message may be sent to RPC message handler . Setting the tracing utility to the diagnostic state TRACK OPEN FILE causes tracing utility to call the diagnostic plug in registered for this diagnostic state. The diagnostic state plug in sets control attributes as needed to cause tracing utility to trace client component OPEN FILE at a particular tracing level. The diagnostic state plug in sets the attributes via a call to API .

According to an embodiment client registers a DEFAULT diagnostic state and diagnostic state plug in for the DEFAULT diagnostic state. When tracing utility receives a request to turn off a diagnostic state it sets itself to the DEFAULT diagnostic state by calling the diagnostic state plug in registered by the client.

Diagnostic state plug ins may be used to not only set control attributes associated with a diagnostic state but also to perform operations unrelated to tracing utility .

According to an embodiment of the present invention client is a database server such as a database server available from Oracle corporation Oracle 9i 10i 11g . The database server is configured to use tracing utility to trace various components defined by the database server. The tracing utility may be controlled through commands issued in a database session.

A database session is established for a client process in order for the client process to interact with a database server. A database session is a particular connection established for a client to a database server through which the client issues a series of requests for execution of command statements. The statements substantially conform to a database language supported by the database server such as SQL and include data definition language DDL statements data manipulation language DML statements and statements used to configure a database server. One or more processes executing within the session execute the statements.

According to an embodiment the database language includes commands for altering the behavior of the tracing utility. This allows the behavior of a tracing utility to be modified by issuing commands within a database session to a database server.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another computer readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term computer readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Common forms of computer readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

