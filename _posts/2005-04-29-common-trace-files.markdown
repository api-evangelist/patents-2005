---

title: Common trace files
abstract: A method and system for generating common trace files for multiple components. In one embodiment, separate trace information is received from multiple components. The separate trace information received from multiple components is integrated into a single common trace file to provide common trace information for multiple components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07810075&OS=07810075&RS=07810075
owner: SAP AG
number: 07810075
owner_city: Walldorf
owner_country: DE
publication_date: 20050429
---
Embodiments of the invention generally relate to the field of data processing systems and more particularly to a system and method for employing common tracing for multiple components.

Even though standards based application software e.g. JAVA based application software has the potential to offer true competition at the software supplier level legacy proprietary software has proven reliability functionality and integration into customer information systems IS infrastructures. Customers are therefore placing operational dependency on standards based software technologies with caution. Not surprisingly present day application software servers tend to include instances of both standard and proprietary software suites and often problems emerge in the operation of the newer standards based software or interoperation and integration of the same with legacy software applications.

The prior art application server depicted in provides a good example. shows a prior art application server having both an ABAP legacy proprietary software suite and a JAVA J2EE standards based software suite . A connection manager routes requests e.g. HTTP requests HTTPS requests associated with sessions between server and numerous clients not shown conducted over a network . A session can be viewed as the back and forth communication over a network between computing systems e.g. a particular client and the server .

The back and forth communication typically involves a client client sending a server server a request that the server interprets into some action to be performed by the server . The server then performs the action and if appropriate returns a response to the client e.g. a result of the action . Often a session will involve multiple perhaps many requests and responses. A single session through its multiple requests may invoke different application software programs.

For each client request that is received by the application server s connection manager the connection manager decides to which software suite the request is to be forwarded. If the request is to be forwarded to the proprietary software suite notification of the request is sent to a proprietary dispatcher and the request itself is forwarded into a request response shared memory . The proprietary dispatcher acts as a load balancer that decides which one of multiple proprietary worker nodes through are to actually handle the request.

A worker node is a focal point for the performance of work. In the context of an application server that responds to client server session requests a worker node is a focal point for executing application software and or issuing application software code for downloading to the client. The term working process generally means an operating system OS process that is used for the performance of work and is also understood to be a type of worker node. For convenience the term worker node is used throughout the present discussion.

When the dispatcher identifies a particular proprietary worker node for handling the aforementioned request the request is transferred from the request response shared memory to the identified worker node. The identified worker node processes the request and writes the response to the request into the request response shared memory . The response is then transferred from the request response shared memory to the connection manager . The connection manager sends the response to the client via network .

Note that the request response shared memory is a memory resource that each of worker nodes through has access to as such it is a shared memory resource . For any request written into the request response shared memory by the connection manager the same request can be retrieved by any of worker nodes through . Likewise any of worker nodes through can write a response into the request response shared memory that can later be retrieved by the connection manager . Thus the request response shared memory provides for the efficient transfer of request response data between the connection manager and the multiple proprietary worker nodes through .

If the request is to be forwarded to the standards based software suite notification of the request is sent to the dispatcher that is associated with the standards based software suite . As observed in the standards based software suite is a JAVA based software suite in particular a JAVA 2 Enterprise Edition J2EE suite that includes multiple worker nodes through .

A JAVA Virtual Machine is associated with each worker node for executing the worker node s abstract application software code. For each request dispatcher decides which one of the N worker nodes is best able to handle the request e.g. through a load balancing algorithm . Because no shared memory structure exists within the standards based software suite for transferring client session information between the connection manager and the worker nodes through separate internal connections have to be established to send both notification of the request and the request itself to the dispatcher from connection manager for each worker node. The dispatcher then forwards each request to its proper worker node.

A virtual machine VM as is well understood in the art is an abstract machine that converts or interprets abstract code into code that is understandable to a particular type of a hardware platform e.g. a particular type of processor . Because virtual machines operate at the instruction level they tend to have processor like characteristics and therefore can be viewed as having their own associated memory. The memory used by a functioning virtual machine is typically modeled as being local or private to the virtual machine.

Various problems exist with respect to the prior art application server of . For example as application development projects grow larger tracing becomes both increasingly important and cumbersome. Tracing is a technique used primarily by software developers to track the execution of program code. For example when developing an application developers trace the execution of methods or functions within certain modules to identify problems and or to determine if the program code may be improved. If a particular method takes an inordinate amount of time to complete the developer may determine the reasons why and or change the program code to operate more efficiently.

Typically developers use trace tools to trace the execution of program code. Trace tools are proprietary application programs which use different techniques to trace the execution flows for an executing program. One technique referred to as event based profiling tracks particular sequences of instructions by recording application generated events as they occur. By way of example a trace tool may record each entry into and each exit from a module subroutine function method or system component within a trace file e.g. a time stamped entry may be recorded within the trace file for each such event . Trace events may also be sent to a console or other output destination.

The conventional trace tools do not provide for integration of various trace files relating to various corresponding components. This often leads to misreading of errors as accurate comparison between the trace files is required for an accurate reading of the errors. The problem is exasperated when a development project involves a great number of applications components modules or developers. The problem is further complicated when different interfaces and or services are used across the development project.

A method and system for generating common trace files for multiple components. In one embodiment separate trace information is received from multiple components. The separate trace information received from multiple components is integrated into a single common trace file to provide common trace information for multiple components. In one embodiment the common trace information contained in the common trace file is filtered and or sorted in accordance with a predetermined criteria.

Described below is a system and method for employing common tracing for multiple components. Throughout the description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.

In the following description numerous specific details such as logic implementations opcodes resource partitioning resource sharing and resource duplication implementations types and interrelationships of system components and logic partitioning integration choices may be set forth in order to provide a more thorough understanding of various embodiments of the present invention. It will be appreciated however to one skilled in the art that the embodiments of the present invention may be practiced without such specific details based on the disclosure provided. In other instances control structures gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate functionality without undue experimentation.

Various embodiments of the present invention will be described below. The various embodiments may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor or a machine or logic circuits programmed with the instructions to perform the various embodiments. Alternatively the various embodiments may be performed by a combination of hardware and software.

Various embodiments of the present invention may be provided as a computer program product which may include a machine readable medium having stored thereon instructions which may be used to program a computer or other electronic devices to perform a process according to various embodiments of the present invention. The machine readable medium may include but is not limited to floppy diskette optical disk compact disk read only memory CD ROM Digital Video Disk ROM DVD ROM magneto optical disk read only memory ROM random access memory RAM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM magnetic or optical card flash memory or another type of media machine readable medium suitable for storing electronic instructions. Moreover various embodiments of the present invention may also be downloaded as a computer program product wherein the program may be transferred from a remote computer to a requesting computer by way of data signals embodied in a carrier wave or other propagation medium via a communication link e.g. a modem or network connection .

Second the connection manager is protocol independent. A protocol handler can be plugged into the connection manager to support any one of a number of protocols by which a request can be conveyed to the connection manager . For example handlers for protocols such as the hypertext transfer protocol HTTP secure HTTP HTTPS simple mail transfer protocol SMTP network news transfer protocol NNTP Telnet File Transfer Protocol FTP Remote Method Invocation RMI P4 a proprietary protocol used by the assignee of this application and T3 available from BEA Systems Inc. may be provided at the connection manager so that it can receive a request conveyed from a client in accordance with any of these protocols.

Third the role of a shared memory has been expanded to at least include a a first shared memory region that supports request response data transfers not only for the proprietary suite but also the standards based software suite b a second shared memory region that stores session objects having low level session state information i.e. information that pertains to a request s substantive response such as the identity of a specific servlet invoked through a particular web page and c a third shared memory region that stores high level session state information i.e. information that pertains to the flow management of a request response pair within the application server e.g. the number of outstanding active requests for a session .

Fourth request notification queues Q through QM one queue for each of the worker nodes through has been implemented within the standards based software suite . As will be described in more detail below the shared memory structures and request notification queues help implement a fast session fail over protection mechanism in which a session that is assigned to a first worker node can be readily transferred to a second worker node upon the failure of the first worker node.

Shared memory is memory whose stored content can be reached by multiple worker nodes. Here the contents of the shared memory region can be reached by each of worker nodes in and . Additionally the contents of shared memory regions and can be reached by each of worker nodes through . Different types of shared memory technologies may be utilized within the application server and yet still be deemed as being a shared memory structure. For example shared memory region may be implemented within a connection oriented shared memory technology while shared memory region may be implemented with a shared closure oriented shared memory technology. A more thorough discussion of these two different types of shared memory implementations is provided in more detail below in section 5.0 entitled Implementation Embodiment of Request Response Shared Memory and section 6.0 entitled Implementation Embodiment of Shared Closure Based Shared Memory .

The connection oriented request response shared memory region effectively implements a transport mechanism for request response data between the connection manager and the worker nodes. That is because the connection manager is communicatively coupled to the shared memory and because the shared memory is accessible to each worker node the request response shared memory at perhaps its broadest level of abstraction is a mechanism for transporting request response data between the connection manager and the applicable worker node s for normal operation of sessions i.e. no worker node failure as well as those sessions affected by a worker node crash.

Although the enhancements of the application server of have been directed to improving the reliability of a combined ABAP J2EE application server it is believed that improved architectural features and methodologies can be more generally applied to various forms of computing systems that manage data processing and communicative sessions whether or not such computing systems contain different types of application software suites and whether any such application software suites are standards based or proprietary. Moreover it is believed that such architectural features and methodologies are generally applicable to data processing and communicative sessions regardless of for example any particular type of shared memory technology employed.

For example in operation the connection manager forwards actual request data to the first shared memory region request response shared memory regardless of whether the request is to be processed by one of the proprietary worker nodes or one of the standards based worker nodes . Likewise the connection manager receives response data for a request from the request response shared memory whether a proprietary worker node or a standards based worker node generates the response.

With the exception of having to share the request response shared memory with the worker nodes of the standards based software suite the operation of the proprietary software suite is essentially the same as that described in the background in one embodiment of the invention. That is the connection manager forwards request notifications to the proprietary dispatcher and forwards the actual requests to the request response shared memory . The proprietary dispatcher then identifies which one of the proprietary worker nodes is to handle the request. The identified worker node subsequently retrieves the request from the request response shared memory processes the request and writes the response into the request response shared memory . The response is then forwarded from the request response shared memory to the connection manager who forwards the response to the client via network .

In an alternative embodiment the ABAP dispatcher is integrated into the connection manager just as the J2EE dispatcher . Indeed it is contemplated that a single dispatcher may encompass the functionality of both dispatchers and . In the case where the dispatcher is integrated into the connection manager the connection manager identifies which one of the proprietary worker nodes is to handle a request and via its integrated dispatcher capabilities forwards the request to the request response shared memory . The identified worker node subsequently retrieves the request from the request response shared memory processes the request and writes the response into the request response shared memory . The response is then forwarded from the request response shared memory to the connection manager who forwards the response to the client via network .

The classes and or objects of this embodiment comprise an Application Programming Interface API usable to configure tracing operations within a JAVA environment. It should be noted however that the underlying principles are not limited to any particular programming environment.

In one embodiment each controller is an instance of a defined controller class e.g. a JAVA class which includes a tracing sub class to provide features specific to tracing operations. It is contemplated that the controller may also include a logging sub class to provide features specific to logging operations. In one embodiment using an object oriented environment such as JAVA the common trace module may represent an instance of the tracing sub class. In one embodiment the common trace module may include one or more trace modules associated with program code locations e.g. locations within packages classes . . . etc. such that the common trace module is used to provide a common trace file having trace messages from various components in one trace file as opposed to providing a separate trace file associated with each of the components.

For example component tracing may include component tracing of virtual machines work processors worker nodes garbage collection and the like. Such tracing of components provides trace messages in various trace files that are not gathered at the same time. For example a trace message may be recorded at 2 00 PM in a VM trace file while a trace message is recorded at 2 01 PM in a work processor trace file regarding the same error. This makes it difficult for a developer to compare the two files to accurately analyze the nature of the error its function level its severity and such. In one embodiment the common trace module is used to work with the common trace manager and with various controllers associated with various components to facilitate a resulting common trace file to provide trace messages from various components. In one embodiment the common trace module may provide methods for integrating various trace output destinations associated with various controllers into one trace output destination . Further the common trace module may be used for controlling the actual writing of trace messages.

In one embodiment in addition to providing a common trace file for various components the common trace module may be used to trace messages based on other factors such as severity based trace levels trace patterns and trace errors. For example a trace pattern may be adopted based upon the occurrence of a new condition. For example the occurrence of a particular error may be qualified as a new condition which in turn may lead to creating a particular tracing pattern for the common trace module . It is contemplated that trace pattern may be adopted changed or removed by the developer or automatically by the application server upon meeting or not meeting of certain thresholds. Similarly a particular error or set of errors may be regarded as very important which may lead to adding a higher trace level that particular error. Using this technique the common trace module may regard a particular error or situation or a particular set of errors or situations in high regard and sort the common trace file in accordance with the error trace level. Similarly errors may be traced based on the already defined severity levels for high to low or vice versa.

For example when a method is called the writing of the trace message to the common trace file may be performed using the severity level associated with the message the severity settings of the relevant controller s and the filtering configuration of one or more optional filters . For example in one embodiment trace messages having a severity level greater than or equal to the effective severity of the relevant controller are candidates for output and are forwarded to the common trace file associated with the controller e.g. assuming the trace messages are not filtered by one of the filters .

A variety of different severity levels may be defined. In one embodiment of the invention the following severity levels are defined from lowest to highest severity level MINIMUM DEBUG PATH INFO WARNING ERROR FATAL and MAXIMUM. In addition tracing may be totally enabled or disabled using the severity settings of ALL or NONE respectively. Further each of the descriptive threshold levels may have an associated numeric value e.g. DEBUG 100 PATH 200 . . . etc. . Similarly trace patterns and trace errors may be tracked however not the same severity levels may be associated with trace patterns and trace errors as they may be assigned a separately defined set of severity levels.

In one embodiment each of the components may be assigned an identification value or name for tacking purposes. For example each of the VMs may be assigned a unique identification e.g. to that the VMs can be identified. Such identification information may be used to facilitate the filtering of trace messages based on which VM is to be traced. For example there are three VMs that are identified as VM VM and VM of which VM is regarded the one with highest importance VM is regarded as moderately important and VM is regarded as least important for tracing purposes. In this case one of the filters such as filter may be set such that it would provide any trace messages from VM with higher priority over trace messages from VM and VM. Similarly if trace messages are being received from VM and VM trace messages from VM are assigned a higher priority over trace messages from VM and are provided in the common trace file . This filtering mechanism uses component identification to first identify the component and then assign a predefined priority level to those components and trace messages from such components. Stated differently not only the filtering mechanism provides filtering of trace information based on a predefined filtering criteria but also sorting of trace information based on a predefined sorting criteria. It is contemplated that such identifications are assigned to any number of components not limited to VMs such as work processors worker nodes and the like. In one embodiment filters associated with the controller may also use other predefined filtering criteria to filter trace messages before and or after evaluating the trace messages based on the criteria e.g. such component identification severity level etc. described above.

In one embodiment a common trace console not shown may be provided as another common trace output destination in addition to or in substitution to the common trace file . If a particular controller is capable of writing to both a file and a console a filter may be assigned to filter messages directed to the file thereby limiting output to the console only. Thus using filters a finer granularity of output may be defined using a wide variety of variables. As illustrated filters may be associated with particular controller and or with specific output destinations e.g. common trace file . As mentioned above filters may be associated with both controllers and or output destinations to further restrict or alter the output tracing behavior. In one embodiment multiple filters having different filtering criteria may be allocated to each controller and or destination .

In one embodiment instances of the tracing sub class e.g. tracing modules are associated with specified program code regions of applications. The tracing modules receive method calls from the applications and process the method calls based on defined severity levels trace errors trace patterns component identification and the like. A viewer may be provide access to trace information generated by the tracing system architecture in the common trace file . Further in one embodiment tracing operations performed by the trace controllers having a common trace module are associated with particular program code locations identified by particular package class function names and the like. For example in a JAVA environment locations may be named according to the hierarchical structure known from JAVA packages.

A worker node in the context of the application server is regarded as the focal point for executing application software and or issuing application software code for downloading to the client. As described earlier worker nodes also include work processes which generally refer to operating system processes that are used for performance of work and are understood to be a type of worker node. Throughout this application the terms worker node and work process are used interchangeably. Each of the worker nodes is associated with a virtual machine . A VM is an abstract machine that can include an instruction set a set of registers a stack a heap and a method area like a real machine or processor. A VM essentially acts as an interface between program code and the actual processor or hardware platform on which the program code is to be executed. The program code includes instructions from the VM instruction set that manipulates the resources of the VM .

In the illustrated embodiment a trace common module not shown works with the trace manager and controllers to provide a common trace file for providing and storing trace information for exceptions generated both at the virtual machines and worker nodes . For example a VM can directly throw an exception in response to detecting an error for example due to an arithmetic exception such as dividing by zero or indexing exception which may be caused by trying to access an array element with an index outside of the array bounds. Exceptions can also be thrown by JAVA code using the throw statement. These program exceptions can include additional information provided by the programmer from data that is accessible at the point where the exception is thrown that can be used to identify the source of the problem that caused the exception. Further a developer can throw exceptions that trigger the technique at certain points in a program to provide trace information providing information as to the state virtual machine at different times during execution of the program.

In one embodiment the common trace file includes a common trace file for maintaining trace information and messages by not only providing a single trace file for each of the virtual machines and each of the worker nodes but it provide a single trace file for both the virtual machines and the worker nodes . Such common trace file helps the developer access a single trace file for accessing the VM and worker node related trace information.

Furthermore in one embodiment a filter not shown is employed to filter the trace information according to a component e.g. virtual machine gets the highest priority a type of error a pattern of error the severity level of the error and the like. This can be achieved by having the filter work the common trace module at the controller to filter out the unwanted and or unnecessary trace information as well as sort the remaining trace information in accordance with one or more categories described above.

In one embodiment a common trace file is provided for each type of the illustrated component. For example a common trace file is generated to provide and store trace information relating to the worker nodes . The worker node common trace file serves as the common trace file for the developer to access to find worker node related trace information. Similarly a common trace file is generated to provide and store trace information relating to the virtual machines . The virtual machine common trace file serves as the common trace file for the developer to access to find virtual machine related trace information. It is contemplated that the filtering mechanism as described above may be employed to distribute filtered and or sorted information via each of the common trace files .

Then the dispatcher for the standards based software suite is invoked by executing a particular dispatching algorithm. For purposes of this discussion it is sufficient to realize that the dispatcher 1 accesses and updates at high level state information for the request s session in a shared memory session table not shown 2 determines which one of the worker nodes ought to handle the newly arrived request and 3 submits at the request into the request response shared memory and submits at a request notification for the request into a request notification queue that is associated with the worker node selected by the dispatching algorithm.

In one embodiment using the trace manager trace controller and common trace module of the common trace mechanism a common trace file is created for tracking the trace information relating to the worker nodes . Such common trace file is created by the common trace module by integrating various worker node related trace files each of which corresponding to each of the worker nodes . For example worker nodes N are associated with the same number of trace files N providing separate information for each of the worker nodes . By using the common trace module along with the trace controller such trace files are integrated into a single common trace file to track trace information relating to the worker nodes .

Similarly in one embodiment a common trace file is also generated for all of the virtual machines . A with the common trace file the virtual machine common trace file serves as an integrated common trace file for tracking trace information relating to the virtual machines .

In one embodiment a master common trace file may be provided to have one common trace file for various components such as the one described with reference to . Stated differently various common trace files are further integrated into a single common trace file that serves for tracking trace information for each of the relevant components including worker nodes and virtual machines . In another embodiment the common trace file is used for other purposes such as tracking trace information relating to yet another set of components or for other tasks such as garbage collection.

In the illustrated embodiment the common trace file is used for tracking garbage collection relating to virtual machines . Garbage collection refers to a process designed to identify and reclaim blocks of memory that have been dispensed by a memory allocator but that are no longer live e.g. no longer being used as determined for example by not being reachable from any currently referenced objects or entities . Entities that are garbage collected are typically referred to as being dead as opposed to being live. Garbage collection is usually handled as a background task by runtime systems rather than as an explicit task by user programs. There are some costs associated with garbage collection as access to memory is typically restricted and runtime systems sometimes are halted during some portions of garbage collection process.

In one embodiment a common trace file is provided for tacking trace information relating to multiple garbage collections . In the illustrated embodiment three common trace files are employed for tracking trace information relating to worker nodes virtual machines and garbage collection as opposed to employing a separate trace file associated with each of the worker nodes virtual machines and garbage collection processes . In another embodiment a common trace file or a different combination of trace files may be provided for various components. For example a single trace file is provided for worker nodes and virtual machines while a separate trace file is maintained for garbage collection .

In one embodiment as described earlier a filter may be employed along with the common trace module to facilitate filtering and or sorting of the trace information being tracked at various common trace files . The filtering and sorting of the trace information is performed using any one or more of component priorities using component identification trace patterns trace errors severity levels and the like as described elsewhere in this description.

As with the first trace messages second trace messages relating to a second component are tracked at processing block . The second trace messages relating to the second component are received at a second trace controller at processing block . At decision block a determination is made as to whether filtering of the trace message is needed. If yes the filtering of the trace messages is performed at processing block . Once the filtering is done a common trace file is created using the filtered trace messages at processing block . If the filtering is not needed the common trace file is created using trace messages at processing block . The common trace file is provided at processing block .

In one embodiment the trace file can be created with just one message and other messages would append to this trace file. Further if a trace file already exists the trace message can be written to an existing trace file and there may not be a need to open a new trace file as the messages can be appended to the existing file.

In one embodiment first trace messages relating to a first component of a second type are received at a first trace controller at processing block . Second trace messages relating to a second component of a second type are received at a first trace controller at processing block . For example the first and second components of the second type include worker nodes. At decision block a determination is made as to whether the trace information is to be filtered. If yes the trace information is filtered at processing block . Once the filtering is performed or if filtering is not needed a second trace file is created at processing block . As with the first trace file the second trace file may be created with a single message while the rest of the messages may be appended to the second trace file. Also an existing second trace file may be used by writing the trace messages to it as opposed to opening a new file. The first and second trace files are then provided at processing block .

The architectures and methodologies discussed above may be implemented with various types of computing systems such as an application server that includes a JAVA 2 Enterprise Edition J2EE server that supports Enterprise JAVA Bean

 EJB components and EJB containers at the business layer and or Servlets and JAVA Server Pages JSP at the presentation layer . Of course other embodiments may be implemented in the context of various different software platforms including by way of example Microsoft .NET Windows NT Microsoft Transaction Server MTS the Advanced Business Application Programming ABAP platforms developed by SAP AG and comparable platforms.

A hard drive or other storage device may be used by the system for storing information and instructions. The storage device may include a magnetic disk or optical disc and its corresponding drive flash memory or other nonvolatile memory or other memory device. Such elements may be combined together or may be separate components. The system may include a read only memory ROM or other static storage device for storing static information and instructions for the processors through .

A keyboard or other input device may be coupled to the bus for communicating information or command selections to the processors through . The input device may include a keyboard a keypad a touch screen and stylus a voice activated system or other input device or combinations of such devices. The computer may further include a mouse or other cursor control device which may be a mouse a trackball or cursor direction keys to communicate direction information and command selections to the processors and to control cursor movement on a display device. The system may include a computer display device such as a cathode ray tube CRT liquid crystal display LCD or other display technology to display information to a user. In some environments the display device may be a touch screen that is also utilized as at least a part of an input device. In some environments the computer display device may be or may include an auditory device such as a speaker for providing auditory information.

A communication device may also be coupled to the bus . The communication device may include a modem a transceiver a wireless modem or other interface device. The system may be linked to a network or to other device using via an interface which may include links to the Internet a local area network or another environment. The system may comprise a server that connects to multiple devices. In one embodiment the system comprises a JAVA compatible server that is connected to user devices and to external resources.

While the machine readable medium is illustrated in an exemplary embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine of the system and that causes the machine to perform any one or more of the methodologies of the present invention. The term machine readable medium shall accordingly be taken to include but not be limited to one or more machine readable storage medium such as solid state memories optical and magnetic media and one or more propagation medium such as carrier wave signals.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more machine readable storage medium such as memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs Digital Video Disk ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

Furthermore it is appreciated that a lesser or more equipped computer system than the example described above may be desirable for certain implementations. Therefore the configuration of system may vary from implementation to implementation depending upon numerous factors such as price constraints performance requirements technological improvements and or other circumstances.

It is noted that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments JAVA based environments such as a JAVA 2 Enterprise Edition J2EE environment or environments defined by other releases of the JAVA standard or other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation .

It should be noted that while the embodiments described herein may be performed under the control of a programmed processor such as processors through in alternative embodiments the embodiments may be fully or partially implemented by any programmable or hardcoded logic such as field programmable gate arrays FPGAs TTL logic or application specific integrated circuits ASICs . Additionally the embodiments of the present invention may be performed by any combination of programmed general purpose computer components and or custom hardware components. Therefore nothing disclosed herein should be construed as limiting the various embodiments of the present invention to a particular embodiment wherein the recited embodiments may be performed by a specific combination of hardware components.

It should be appreciated that reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore it is emphasized and should be appreciated that two or more references to an embodiment or one embodiment or an alternative embodiment in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined as suitable in one or more embodiments of the invention.

Similarly it should be appreciated that in the foregoing description of exemplary embodiments of the invention various features of the invention are sometimes grouped together in a single embodiment figure or description thereof for the purpose of streamlining the disclosure aiding in the understanding of one or more of the various inventive aspects. This method of disclosure however is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather as the following claims reflect inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus the claims following the detailed description are hereby expressly incorporated into this detailed description with each claim standing on its own as a separate embodiment of this invention.

While certain exemplary embodiments have been described and shown in the accompanying drawings it is to be understood that such embodiments are merely illustrative of and not restrictive and that the embodiments of the present invention are not to be limited to specific constructions and arrangements shown and described since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure.

