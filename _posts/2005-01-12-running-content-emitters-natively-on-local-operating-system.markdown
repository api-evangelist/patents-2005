---

title: Running content emitters natively on local operating system
abstract: Techniques for running content emitters natively on a local operating system, by executing a local executive as a native application on the target operating system. In some embodiments, a content emitter such as a portlet preferably invokes, by its normal inclusion mechanism, a markup emitter directed toward the native user interface environment. The markup streams created by locally-executing portlets are collected by the local executive, but instead of being combined into a browser-based markup stream as in the prior art, one or more windows represented by the markup streams is/are created for rendering with the native operating system. An association is maintained between the created window and the portlet(s) emitting content for that window, and controls can be created and valued for the window using this association. In other embodiments, the content emitters execute remotely and deliver content that is adapted for native rendering.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08631324&OS=08631324&RS=08631324
owner: International Business Machines Corporation
number: 08631324
owner_city: Armonk
owner_country: US
publication_date: 20050112
---
The present invention is related to commonly assigned U.S. patent application Ser. No. 11 034 521 titled Rendering Content Natively on Local Operating System which was filed concurrently herewith.

The present invention relates to computer programming and deals more particularly with client side content collection and rendering.

In recent years a content aggregation framework based on a portal server model has become the defacto standard for development of web applications worldwide. In this approach portal applications called portlets are used with the portal server.

Portlets are applications that emit markup into an aggregation stream and have become a popular programming model. In the predominant approach portlets are run on a portal server. A portal server may aggregate content from a number of these content emitting applications when creating the aggregation stream. This aggregation stream represents a complete portal page and this portal page is returned from the portal server to a client for display in the client s web browser. This portal portlet model is well known in the art.

In an alternative approach the portal model becomes even more ubiquitous by allowing a portal to run locally on a client machine and transferring portlets to the client for execution on the local machine. The locally executing portal continues to aggregate content from each portlet and sends the resulting aggregated stream to the client s web browser for rendering.

While this alternative local execution approach is functionally workable in most cases it has some limitations. These include 

1. The local browser which is the expected renderer of the aggregated stream is still required. If the browser software is changed or updated the portal page may cease to function properly.

2. The browser based approach acts as a barrier to the local operating system such that the locally executing portlets typically will only support local operating system functions to the extent the browser will allow. For example a locally executing portlet in this alternative approach cannot leverage dynamic data exchange DDE a messaging mechanism in the Windows operating system for the transfer of specific data between applications. Windows is a registered trademark of Microsoft Corporation in the United States other countries or both. 

3. Each time the portal delivers a page to the browser the browser will re create the portal screen. This may cause excessive resource consumption and computing overhead and may result in a screen flashing scenario that is disruptive to the end user.

The present invention provides local content collection techniques whereby a local i.e. client side executive runs as a native application on the target operating system. In preferred embodiments a portal portlet model is used and a client side portlet invokes by its normal inclusion mechanism a markup emitter such as a JavaServer Page JSP that emits markup directed toward the native user interface environment. JSP is a trademark of Sun Microsystems Inc. The portlet may be loaded on the client in various ways including from a remote portal server from the local file system or other local media etc. A portlet with a content emitter directed to a native environment may continue to run remotely as well. 

In alternative embodiments portlets may continue to execute remotely under control of a remote portal server. Or content may be generated remotely using other types of content generators such as a remote Web service or other type of network accessible service . In these alternative embodiments a client side executive is preferably responsible for requesting and receiving the remotely generated content and for directing that content to an appropriate window for native rendering on the client.

The present invention will now be described with reference to the following drawings in which like reference numbers denote the same element throughout.

The present invention provides techniques for executing a local portal executive as a native application on the target operating system. The code used to implement the portal executive is not limited to a particular programming language and in preferred embodiments is capable of accessing operating system windowing messages events user input and so forth. The executive preferably implements a standard portlet application programming interface API and runtime environment. This will allow the executive to load standard portlets locally for example from the local file system or retrieve them from a remote location such as a remote portal server . The executive hosts the portlets and calls the portlets through the portlet API. Preferred embodiments are described herein with reference to the portlet API provided by the IBM WebSphere Portal product although this is by way of illustration and not of limitation. WebSphere is a registered trademark of International Business Machines Corporation in the United States other countries or both. 

When a portlet is called and asked to render its content it returns a markup stream. Existing portlets typically emit content in the Hypertext Markup Language HTML Compact HTML CHTML or Wireless Markup Language WML . The content is then aggregated by a portal. It is expected that some portals will be supporting content in Extensible HTML XHTML soon. Generally a portal aggregator can be enhanced to support any appropriate language.

The local portal executive disclosed herein may support one or more of these markup languages and or other languages including languages yet to be developed . According to preferred embodiments portlets are requested to render their output in a language or notation that maps the user interface for the portlet to standard controls rather than using a browser oriented markup language as in the prior art . This notation is preferably based on the Extensible Markup Language XML and is referred to herein as User Interface Markup Language or UIML . Content emitted in this notation by a particular portlet may be device and machine independent while other portlets may emit content that tends to be domain specific. References herein to UIML are not intended to limit the invention to use with a particular markup language and various UI oriented markup languages such as the Extensible Application Markup Language XAML may be used with embodiments of the present invention without deviating from the scope of the present invention. 

As depicted in fragment of the tag name for this sample element is UI and an ID identifier and OPERATION attribute are present on tag in the example. Sample fragment also includes two child elements TEXT and INPUT . This example fragment may be rendered on the user interface as a wizard page and illustrates a device and machine independent syntax.

The sample fragment in depicts a domain specific syntax example and is designed to illustrate rendering of content for a device in a 3270 type data stream approach. As depicted in this sample fragment the tag name for this sample element is I3270 and a ScreenID attribute is present on tag . Sample fragment also includes two FIELD child elements which provide data for rendering on the user interface.

According to preferred embodiments the markup streams created by locally executing portlets are collected but instead of being combined into a browser based markup stream as in the prior art windows represented by the markup streams are created for rendering in the native operating system. As will be discussed in more detail below an association is maintained between the created window and the portlet s emitting content for that window. By maintaining this association between window and portlet an optimization is realized. Referring again to note that the sample markup fragment uses the value Wizard Page 1 for its ID attribute on element . A locally executing portlet can emit the content shown in where a UI element has this same Wizard Page 1 value for its ID attribute and now specifies a value of Refresh for its OPERATION attribute thereby signalling that the previously created window having the identifier Wizard Page 1 should now be refreshed. In contrast to prior art portal environments where the portal screen is re created in the browser for every display by the portal this approach enables selective and explicit control over when a window will be redisplayed. By refreshing an existing window rather than building a new window embodiments of the present invention may provide better performance over prior art approaches.

Window refreshes may be triggered by various events or actions for which the portlet s logic is adapted. For example user input such as activating a Clear button on a user interface may be defined as triggering a window refresh in some portlets. In another example timers may be used to trigger window refreshes at predetermined intervals. Optionally window content may be cached and the cached content may be used when refreshing windows if the cached content continues to be valid. Embodiments of the present invention may also allow refreshes of a portion or subset of a window s content.

The markup depicted in can be produced with standard JavaServer Pages technology. According to preferred embodiments an additional JSP is provided for each portlet that will execute natively where this additional JSP is adapted for producing content for native execution. See the discussion of where support for multiple JSPs by a portlet is described in more detail. JavaServer Pages is a trademark of Sun Microsystems Inc. To the portlet writer it is just another markup choice that the portlet provides for its emitted content and all other logic in the portlet may remain the same.

It should be noted that while discussions herein refer primarily to JSPs as content emitters this is by way of illustration and not of limitation. Alternatives include style sheets such as those created using the Extensible Stylesheet Language XSL combinations of JSPs with XML markup and XSL style sheets inclusion of static files and so forth.

The portal executive of preferred embodiments also maps input semantics clipboard semantics and DDE semantics from the operating system into messages delivered to the portlet through standard portlet API messages as described in more detail below . This enables the portlet to accept data from and provide data to the user and the clipboard as well as other native applications.

The portal executive may choose to render all portlet windows into a single frame window using for example the multiple document interface or MDI approach where multiple documents are rendered in separate child windows of a parent or it may allow each portlet to render its content in a separate window. Rendering multiple child windows within a single parent window is also referred to herein as a multipane window system . This approach is not limited to an MDI interface and embodiments of the present invention may support any window style that is deemed desirable without deviating from the inventive concepts disclosed herein. Optionally embodiments of the present invention may also allow rendering multiple portlet views in a separate child window of a parent window or as separate and independent windows. In addition user interface markup emitted by a locally executing portlet could allow invocation of special controls that are provided by the operating system such as tree controls ActiveX controls of the Windows operating system and so forth ActiveX is a registered trademark of Microsoft Corporation in the United States other countries or both . This is in contrast to portlets of the prior art which render their content targeted to a browser environment and do not generate content directed toward operating system features.

While embodiments of the present invention allow portlets to execute as native applications these portlets can continue to execute in a remote environment and on other machines and their content can continue to be served from a central portal server by using the portlet s browser based JSPs. With this enhanced flexibility the portlet application model may become even more ubiquitous across a variety of computing platforms.

Turning now to an illustration is provided of components and flows in a prior art portal server environment. As shown in a client browser establishes a connection with a portal server typically via a series of Hypertext Transfer Protocol HTTP requests and responses. Connections may be made using other protocols such as Wireless Application Protocol WAP . However for ease of reference discussions herein are in terms of using HTTP. For each HTTP request sent to the portal server a markup page is returned to the browser on an HTTP response . The client browser decodes the returned markup syntax and displays the page to the user.

When the user has accessed the portal and logged in if a log in is required the portal creates the delivered markup page as a markup stream that represents an aggregation of content from one or more server side portlets . The portal content aggregator calls appropriate one s of these portlets and each portlet returns a content fragment as a stream of markup to the aggregator the aggregator then assembles the fragments into a composite stream for the markup page. When the page has been built in this manner the content stream is returned to the client browser via the HTTP response . As noted above the browser then decodes this content stream and displays the portal page for the user. 

To summarize in this prior art environment the server side portlets run remotely and when called by the portal content aggregator render their content as a stream of markup to be aggregated for rendering in a client side browser.

Reference is now made to . When the portal executive function see also of receives a rendering request from a client via an HTTP request the portal executive in turn creates a portlet request for each portlet for which content will be displayed on the portal page. By way of illustration issuance of a portlet request to a single portlet is shown in at . In order to allow portals and portlets to support multiple output markup languages and multiple target devices the portlet request typically contains a field referred to herein as a content type field that denotes the markup type for the portlet to render. For standard client browsers this field is typically set to indicate HTML output. For newer mobile devices this field is typically set to indicate XHTML output while for older mobile devices it might indicate that WML or CHTML output is requested.

Upon receiving a portlet request the portlet checks the content type field and through an inclusion mechanism selects the proper JSP to call to render the markup specific content stream. Each JSP associated with a portlet renders one unique markup syntax for a given set of content. For example if the content type field in portlet request is set to HTML the portlet includes the JSP that produces its output using HTML syntax whereas if the type field is set to WML the portlet uses JSP instead.

The JSP renders its content into a stream provided by the portlet to the portal executive as a portlet response . When all applicable portlets have been called and each portlet stream is returned to the portal aggregator as shown at reference numbers and of the portal aggregator assembles the composite stream and returns it to the client browser .

Turning now to an environment in which a local portal executive operates on a client is depicted and is illustrative of embodiments of the present invention. Here the locally executing portal executive sends an HTTP request to the portal server asking the portal server to transfer a portlet to the client for local execution. For example any of Portlet through Portlet N might be requested. In preferred embodiments the server side portal responds by returning an archive such as a Java Archive JAR file that comprises the execution artifacts of the requested portlet. Java is a trademark of Sun Microsystems Inc. 

The local portal executive then installs the portlet JAR file locally and begins execution of the portlet. As depicted in according to preferred embodiments the portlet is executed locally in the same way it is executed on the server side that is the portlet is called via a portlet request and the portlet in turn selectively includes a JSP for execution based on the selected content markup as indicated by the content type field of the portlet request. As noted earlier locally executing portlets are preferably requested to render their output in a user interface notation referred to herein by way of illustration as UIML and thus the portlet request preferably specifies a value such as UIML for the markup to be rendered. Note that portlet is depicted as supporting inclusion of JSPs that render several different markup languages as in and now also supports a JSP that renders content in UIML. The content emitted by portlet may then be rendered into a window on the client as shown generally at of .

It should be noted that a portlet that supports UIML type content will be able to run locally on the client under control of the local portal executive and such portlets will also continue to be able to run on a server side portal server. When running on the server side the UIML emitting JSP will not be called to render content responsive to a server side portal rendering request because the server side executive will not request that output type. 

The processing of begins when a user selects a portlet Block and that portlet will be executed locally. In Block an HTTP request is sent by the local portal executive to retrieve the portlet s JAR file. It should be noted that the present invention is not limited to retrieval of portlets from a server. As one skilled in the art will understand the portlets could alternatively be installed in other ways for example by manually retrieving the JAR file from the Internet or by loading it from local media such as a disk drive of the local file system or a CD ROM. 

The JAR file is received Block and the Java classes for the portlet are loaded. A portlet request is created e.g. as a PortletRequest invocation Block and its content type field is set to request UIML markup. A call is then made to the portlet s service method Block to request content rendering. See where this processing is depicted in more detail. After the portlet returns its content a method is called at Block to create the portlet s window. See where this is depicted in more detail. The processing of then exits.

Input to the processing of is a UIML content stream created by a portlet. In Block the tag value of the opening element of the portlet s emitted content which for purposes of illustration is referred to herein as a UI tag is parsed and the value of this tag s ID attribute is retrieved. This ID attribute is used to find the window into which the portlet s content stream should be rendered. In Block a test is made to see if this ID attribute value matches the ID attribute associated with an earlier created window. If so control transfers to Block for processing of that existing window. Otherwise a method is called at Block to create a new window which will then be associated with this ID attribute value and processing then continues at Block . Note that once a new window is created it can communicate with the portlet executive but can also operate independently and can be accessed by other applications. This is distinct from portal pages of the prior art. 

At Block a method is called passing the ID attribute value and the stream emitted by the portlet where this method will then parse the content values from the stream as depicted in more detail in . Upon returning from the processing of the window associated with the ID is activated and rendered Block . The processing of then returns.

The flowchart in depicts creation of the child controls of the newly created window to be used for rendering a portlet s content. In preferred embodiments each control is created by reading the UIML input stream provided from the UIML emitting JSP and creating a child control that matches the tag type in that stream as will now be described in more detail.

Block parses the next tag of the passed UIML stream. Block tests to see if that tag has the value INPUT . If so then Block creates a text input control connection ID CID as a child of the parent window where this parent window is the window associated with the ID value passed as input . Similarly Blocks and test the tag to see if it is a LABEL or BUTTON tag respectively and if so Blocks and create a text display control as a child of the parent window. If the tag does not match any of these values it is tested in Block to see if the value is COMBO and if so Block creates a combo box control CID as a child of the parent window. Blocks and test the tag to see if it is RADIO or CHECKBOX respectively and if so Blocks and create a radio button control CID or checkbox control as a child of the parent window.

After any of the child control CIDs has been created control reaches Block which calls a method to load the control with a value passing the CID and current tag as input . This method is depicted in more detail in . Upon returning from the processing in control then transfers to Block to continue parsing the UIML stream.

If the tag value does not match any of the previously tested values control reaches Block which tests to see if the closing tag syntax in this example for the UIML element has been reached. If so then the input stream has been completely parsed and its child controls have been processed so the processing of returns. Otherwise when the test in Block has a negative result the current tag has an unexpected value. Block therefore preferably writes a message to a portal executive log file where the message contains the value of this tag after which processing continues at Block to continue parsing the UIML stream. Alternatively control may exit immediately from the processing of when Block has processed an unexpected tag which may indicate an error situation. 

If the CTYPE value tested in Block indicates that this control corresponds to a RADIO or COMBO control then Block retrieves an array of control values from the tags which are child tags of the current tag. Block then sets the control CID s values from these retrieved values and control then returns from .

If the test in Block determines that the CTYPE value is unexpected Block preferably logs an unknown control type error message into the local portal executive s log file and control then returns from .

The sample document in uses a UI element see reference number as has been discussed and this element has an ID attribute whose value is used to identify the window into which this content will be rendered. The UI element may contain various child elements and several are illustrated in . In preferred embodiments each child element has an ID attribute and this attribute is used to identify the control associated with the child element. The uniqueness requirements among values of the ID attributes for controls within a window depend on the underlying operating system. As a general rule if all controls within a given window have a unique ID uniqueness requirements should be met for all operating systems. Optionally unique ID attribute values may be generated automatically using techniques which are outside the scope of the present invention for those controls that do not have explicit IDs provided by the content emitting software. While use of ID attributes is preferred these attributes may alternatively be omitted from child elements without deviating from the scope of the present invention. 

As an example of a child element within a UI element for a window a LABEL element includes an ID attribute and a VALUE child element. The LABEL element may be created by the content emitting JSP to specify text that should be placed in the window being created or refreshed. An INPUT element includes an ID attribute and a maxlength attribute and may be created by the content emitting JSP to specify that user input should be provided in the window. A RADIO element includes an ID attribute and some number of child VALUE elements. In this example 3 child VALUE elements are specified thus indicating that a set of 3 radio buttons should be rendered in the window the text associated with each button is to be taken from the text specified in the child VALUE elements. A CHECKBOX element includes an ID attribute and a VALUE child element. This element may be created by the content emitting JSP to specify that the window should include a checkbox control where the text specified in the VALUE child element is to be rendered with that control. A COMBO element includes an ID attribute and some number of child VALUE elements. In this example 3 child VALUE elements are specified thus indicating that a combo box control should be rendered in the window using the text taken from these 3 child VALUE elements. Elements and illustrate two examples of BUTTON elements each having an ID attribute. The content emitting JSP may create this syntax to specify graphical buttons to be rendered on the window. Reference number refers to the closing tag for the UI element .

When the user interacts with the UI of a given portlet the portal executive preferably retrieves a copy of the portlet s window data Block . If the user interaction comprises pressing a button on the UI Block the portal executive of preferred embodiments creates an action event and passes the action event along with the window data retrieved at Block to the portlet by calling the portlet s actionPerformed method Block . The portlet then acts on the action associated with the pressed button Block as appropriate and the portal executive then calls the portlet with a PortletRequest invocation to the portlet s service method Block thereby requesting the portlet to invoke the UIML emitting JSP and render content reflecting its new state. Block then invokes the processing of to create or activate the portlet window. The processing of then exits.

If the user invokes a clipboard copy operation Block the portal executive of preferred embodiments calls the portlet s service method Block with a copy request thus invoking a clipboard related call on the portlet and the window data retrieved at Block and responsive to this request the portlet returns a copy of its window data Block . The portal executive then sends this data to the clipboard Block after which it calls the portlet s service method Block to request portlet rendering and invokes the processing of Block to create or activate the portlet window.

If the user invokes a clipboard cut operation Block the portal executive of preferred embodiments calls the portlet s service method Block with a cut request and the window data retrieved at Block and responsive to this request the portlet returns a copy of its window data Block . The portlet then clears the internal data values Block corresponding to the data being cut and the portal executive then sends the data it received from the portlet at Block to the clipboard Block after which it calls the portlet s service method Block to request portlet rendering and invokes the processing of Block to create or activate the portlet window.

If the user invokes a clipboard paste operation Block the portal executive of preferred embodiments calls the portlet s service method Block with a paste request and the window data retrieved at Block and responsive to this request the portlet processes the new window values Block that is values currently on the clipboard are used to set corresponding state data of the portlet. The portal executive then calls the portlet s service method Block to request portlet rendering and invokes the processing of Block to create or activate the portlet window.

When the user signals for the window to exit or close Block the local portal executive of preferred embodiments terminates the running portlet instance closes its window and purges the portlet application from memory Block . Following completion of Block the processing of exits.

Preferred embodiments have been described herein with reference to using a web portal portlet model for content aggregation. It should be noted however that references herein to using portals or portlets are by way of illustration and not of limitation. Alternatively techniques disclosed herein may be adapted for use with other content aggregation models.

As has been demonstrated the present invention provides advantageous techniques that enable portlets to execute locally as a native application invoking markup emitters such as JSPs to instantiate native user interfaces. Using the disclosed techniques the portlets can also continue to execute as markup producers running in a remote environment to create content directed toward a browser. Natively executing portlets may leverage a number of operating system facilities that are unavailable to a browser based environment including data transfer through DDE direct user input support and operating system input support and windowing or clipboard operations including cut copy and paste semantics .

Preferred embodiments have been described thus far with reference to a client side portal executive and content emitters executing at the client where these content emitters are loaded onto the client by the client side portal executive for local execution. As discussed with reference to a server side portal server may transmit the content emitters to the client on request of the client side portal executive as archive files. Alternative approaches based on the teachings disclosed herein may be implemented without deviating from the scope of the present invention. Several such alternatives will now be discussed with reference to .

In a first alternative the content emitters may remain on the server side and execute remotely at the server side to create output for use with embodiments of the present invention. This alternative is illustrated in . As shown therein a client side portal executive in this embodiment communicates with a server side portal server . Requests in this embodiment generally comprise requests for content to be generated by a particular portlet X where that portlet is requested for example in a content type parameter to generate its content in UIML or another UI markup language that is adapted for native client side rendering.

When the local portal executive wishes to request content from a server side portlet it preferably sends a request to the server side portal server identifying the target portlet and content type. The portal server preferably sends a portlet request to the target portlet. In one approach the portlet returns its content to the portal server using an interface . Alternatively the existing content aggregator interface may be used for returning the portlet s generated content to content aggregator . In either case portal server then returns the UIML stream in response to the local portal executive and executive renders that stream in an appropriate portlet window . As has been discussed above an ID attribute in the opening tag of the UIML stream is preferably used to determine the window into which the content should be rendered. 

Expanding on this alternative in more detail suppose the local portal executive requests content from portlet to be emitted using UIML markup. Request therefore identifies portlet and the UIML content type. Components and flows that may be used in the server side processing of this request are depicted in . As shown therein upon receiving request portal server preferably sends a portlet request to invoke processing of portlet and portlet then dynamically includes its UIML markup emitter . A dashed line is used at in to illustrate the availability of markup emitters and a solid line is used at to illustrate that in this scenario markup emitter is in use. Markup emitted by portlet in the UIML markup language is preferably returned directly to the portal server as shown in the UIML portlet response whereas markup emitted using other JSPs is preferably returned to the content aggregator as shown in the other portlet response .

In yet another alternative a remote content emitter is not required to adhere to the portal portlets model. Content adapted for native rendering in a windowing environment may be generated remotely by a Web service for example and delivered to a client side executive for rendering. This alternative is illustrated in . As shown therein a client side portal executive in this embodiment is responsible for rendering content in various windows . The portal executive is shown at as communicating by way of example to request and receive content from a remote Web service . In one approach Web service may be adapted only for generating content in UIML. In another approach Web service may be adapted for receiving a content type indicator on content requests such that it can dynamically include a markup emitter as has been discussed herein with reference to portlets. In this approach content request identifies a UIML emitter or another emitter of markup adapted for native rendering which is then included in the Web service processing. Content response thus delivers UI markup to the local portal executive for rendering in an appropriate window.

As will be appreciated by one of skill in the art embodiments of the present invention may be provided as methods systems or computer program products comprising computer readable program code. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment combining software and hardware aspects. The computer program products maybe embodied on one or more computer usable storage media including but not limited to disk storage CD ROM optical storage and so forth having computer readable program code embodied therein.

When implemented by computer readable program code the instructions contained therein may be provided to a processor of a general purpose computer special purpose computer embedded processor or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing embodiments of the present invention.

These computer readable program code instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including instruction means which implement embodiments of the present invention.

The computer readable program code instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented method such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing embodiments of the present invention.

While preferred embodiments of the present invention have been described additional variations and modifications in those embodiments may occur to those skilled in the art once they learn of the basic inventive concepts. Therefore it is intended that the appended claims shall be construed to include preferred embodiments and all such variations and modifications as fall within the spirit and scope of the invention.

