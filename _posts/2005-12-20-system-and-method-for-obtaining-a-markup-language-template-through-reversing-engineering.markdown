---

title: System and method for obtaining a markup language template through reversing engineering
abstract: Process for reverse engineering a program application written in a legacy programming language (e.g., COBOL), where the program application was specifically designed using a markup language template so as to process documents in the markup language. The process involves extracting from the program application, line by line, content fragments of the original markup language template and reassembling them to obtain the original template.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747942&OS=07747942&RS=07747942
owner: American Express Travel Related Services Company, Inc.
number: 07747942
owner_city: New York
owner_country: US
publication_date: 20051220
---
The present invention generally relates to a system method and computer program for reverse engineering a program application to obtain a markup language template that was used in generating the program application. More particularly the present invention relates to reverse engineering a program application in a legacy programming language where the program application was specifically designed using a markup language template to process documents in the markup language in order to obtain a markup language template substantially identical to the one originally used to create that program application.

Markup languages are commonly used in programming particularly with newer programming formats and web based programming. There are several types of markup languages including but not limited to HTML Hypertext Markup Language XML Extensible Markup Language XHTML Extensible Hypertext Markup Language etc. Generally markup languages are programming languages in which the content of a document is marked with tags that provide information indicative of formatting structure font content type etc. More specifically the markups tags are provided to the content of a document to indicate relevance or purpose of that content or of portions thereof. Thus when the document is read by a computing system designed to handle i.e. process the markup language a program known as a parser can identify and extract the relevant content for which the type and or purpose has been indicated by the tags. Thus markup languages provide a simple and convenient way to represent data to be read and processed by a computer.

The examples provided herein will be discussed with respect to Extensible Markup Language XML . One of ordinary skill in the relevant art will understand that the description of the invention also pertains to other markup languages.

While markup languages are gaining in popularity many legacy program languages e.g. COBOL FORTRAN BASIC etc. still used by programmers and institutions are not designed with built in functionality for understanding markup language documents. These older programming systems could be replaced with object oriented program applications and or web based applications to solve the incompatibility between older legacy programs and modern markup language documents. However older legacy programs still form a vital part of many programming systems and the replacement of the same could be expensive and complicated. Consequently these legacy program systems are likely to last into the foreseeable future.

These facts have led to the generation of program applications that run in legacy program environments and are specifically tailored to read markup language documents and convert the data contained therein to a form suitable for the legacy program language. Similar programs are available for generating markup language documents in legacy programming environments.

Programs for providing such functionality to legacy systems are described in for example U.S. patent application Ser. Nos. 10 906 020 and 10 906 018 both of which were filed on Jan. 31 2005. Both of these applications are incorporated by reference herein.

Those applications describe systems for generating program applications in a legacy program environment such as COBOL in order to process a markup language document such as an XML document. The methods for generating such program applications start with a markup language template which preferably includes all or most of the relevant markup language indicators i.e. the tags which are used to identify content in a markup language document . Typically the markup language template provides a description of all of the tags that the subsequently generated program application running on the legacy system can expect to encounter in processing documents in the markup language. The template operates as an example document which provides the necessary information to build a program application for processing future documents.

Preferably using the template a generation tool is used to create a copy book in the legacy language. A copy book is a file structure outside of the program which is copied into the program. Such copy books are understood by one of ordinary skill in the relevant art. The copy book is used to create an intermediate application programming interface API . This interface is the program application which acts as a bridge between the markup language and the legacy program and at run time converts the tags of the markup events into a format which the legacy environment understands.

Ultimately the program application written in the legacy language includes fragments of the original markup language template which have been parsed out in order to create the necessary data structure of the program application. In essence the parsing involves breaking down the hierarchy of the tags of the template into simple events with the events being used to write the program application in the legacy environment.

With the necessary program application developed the application can be implemented in the legacy system in order to allow the legacy system to read process and or generate documents in the defined markup language. This gives the legacy system the ability to converse with more modern data formats and process documents it would otherwise not understand.

Once implemented the program application can continue to provide the newfound functionality to the legacy system. There are however instances in which upgrades are necessary. In upgrading a system it may be necessary to provide additional or alternative markup tags which the original template did not address or otherwise alter the data structure in the program application pertaining to the markup language. Such upgrades can be handled easily if the original template is available for modification. Problems arise however in that the original template is manually managed and it is up to the developer to ensure that it is properly retained for later use. If the original template is not properly retained the upgrading of the system can become complicated and time consuming.

Thus what is needed is a system and method for reverse engineering a program application in the legacy environment to parse out and reconstruct the original template in the markup language when the original template is not otherwise available.

The present invention meets the above identified needs by providing a system method and computer program product for obtaining an original markup template used to develop a program application by reversing engineering the program application.

The present invention is generally directed to reverse engineering a program application used to read process and or generate documents in a markup language operating in a program environment in which the markup language could not otherwise be interpreted in order to obtain a markup language template which was originally used to create the program application.

More specifically the present invention is directed to a method system and computer program for searching a program application operating in a program environment that could not otherwise interpret a mark up language document for a markup language data structure and reading the lines of the program application corresponding to the markup language data structure. In reading the lines of the program application the invention extracts fragments of the original markup language template existing in the lines of the program application and reconstructs those fragments in accordance with associated code in the program application indicative of the relationship of those fragments to the template.

The process of the invention generally includes locating the beginning of the markup language data structure in a program application which was designed using a markup language template and processing program lines of the program application containing the markup language data structure. The processing preferably includes i extracting level information for each program line ii extracting content fragments of a markup line of the markup language template to be obtained iii detecting an end of the markup language line for which the content fragments have been extracted iv writing out for instance to a file document or memory in which the mark up language template is to be reconstructed or into an intermediate area for creating the template each markup language line once the end of the line has been detected v extracting repetition information from the program line indicative of any markup language lines that are to be repeated and if applicable vi repeating written out markup language lines in accordance with extracted repetition information and extracted level information. Furthermore the process involves reconstructing the markup language template by providing the written out markup lines and repeated markup language lines in a template.

An advantage of the present invention is that it provides an alternative method to obtaining an original markup language template used to generate a program application in a legacy programming environment when the original template is not otherwise available. Another advantage of the present invention is that it allows for easier generation of updated program applications by providing the original markup language template used to create such a program application rather than having to recreate all of the programs in achieving the upgrade.

Further features and advantages of the present invention as well as the structure and operation of various embodiments of the present invention are described in detail below with reference to the accompanying drawings.

The present invention is directed to a system method and computer program product for reverse engineering a data structure in a program application to obtain a markup language template originally used to generate the program application. The present invention is now described in more detail in terms of the above exemplary reverse engineering process. This is for convenience only and is not intended to limit the application of the present invention. In fact after reading the following description it will be apparent to one skilled in the relevant art s how to implement the following invention in alternative embodiments.

Referring to a system diagram of an exemplary computer system in which the present invention in an embodiment would be implemented is shown.

System includes computers database server and communication system . Computers database and server are interconnected to communicate in a local area network. Communication system is connected to server so as to provide communication with a larger network such as the Internet.

A program application written in a legacy computer language which is defined herein to include any programming language such as COBOL FORTRAN BASIC or any other which does not have built in functionality for reading processing a markup language such as XML HTML XHTML or the like may be stored on one or more of server database computers or other mediums as will be discussed in more detail below in Section IV.

As discussed above and set forth in detail in co pending applications Nos. 10 906 020 and 10 906 018 the program application may be a program for reading processing and or generating markup language documents. Thus the program application is written in the legacy language in order to provided the functionality for understanding a markup language which otherwise does not exist in the legacy language. is an example of such a program.

In the example in program in COBOL consists of 57 lines of program code which are numbered in column . Program is actually an example of part of a program application which includes the structure of a test XML mark up language template. As discussed in the above mentioned co pending applications the program application is generated from the markup language template which is used in providing markup language tags which the program must be able to process during operation. An example of such a template is provided in as will be discussed in more detail below.

The present invention is directed to reverse engineering the program application to obtain the original markup language template used to create the program application. Preferably the process is achieved by a program product operating in one of the components of the computer system such as computer or server the details of which are provide below in Section IV. Of course any one of a number of systems may be used to implement the reverse engineering process of the present as will be appreciated by one of ordinary skill in the relevant art s .

The process of the present invention is generally related to reverse engineering a program application. The program application is reverse engineered to obtain a markup language template used to generate the program application. Specifically the program application is reverse engineered to extract fragments of the original language template used to create the program application and reconstruct the fragments in the structure of the original template. The process generally includes a step of locating the start of a markup language data structure in the code of the program application such as the XML data structure in .

Once the data structure is located the code of the program application is read line by line to extract the necessary data. This may include extracting level information for each program line of the program application. The level information is used in tracking groups of data in the program application particularly for groups of data to be repeated. Specifically the markup language template may have repeated different lines of the language therein or groups of lines. However the program application rather than repeating code will simply indicate which information is being repeated without specifically repeating the data. When constructing the markup language template from the program application it is necessary to identify which lines or groups of lines of the markup language template are to be repeated. Tracking of the level information can be useful in this regard as will be discussed in more detail later. In reference numerals indicate level information in the lines of code of a program application.

Initially various parameters variables are defined and storage areas for those variables are set to be blanks. The parameters are filled as the process proceeds. Those variables may include among others the markup template line this defines the storage area in which extracted fragments of content are stored and concatenated to build the markup line until the line is completed and written out level information repeating information etc. as will be discussed in more detail below.

The process extracts any content fragments in the successive lines of code. Content fragments also referred to as fragments content etc. are portions of the original markup language template that have been parsed in generating the program application. The content fragments of the original template are located in the order of their appearance in the template throughout the data structure of the program application. They exist as portions of the code of the program application used to give the functionality of processing other markup language documents.

Also in preferred embodiments the process may extract information indicative of the length of a content fragment. For instance when a content fragment is extracted from the program application there may be associated therewith information indicative of the length of that content for example the number of bytes. This length information refers to the length of bytes that the content fragment occupied in the original markup language template. This information is useful in that the length information can be compared with the actual length of the content fragment associated therewith. If the length of the actual content is longer than the information indicative of the original length it indicates that the generation of the program application included adding to that content fragment bytes not originally included in the original markup language template.

For instance in a markup language an area for providing data can be represented by a single byte when in fact the content may be expanded to include any number of characters. In various legacy program languages such expandability does not exist and the actual bytes provided represent the maximum number of bytes of content available for that variable parameter etc. Thus in constructing the program application an expandable unit from the markup language template may be given a length greater than that in the markup language template to account for the expandability. By processing the length information and comparing it to the actual content fragment extracted such instances can be detected and noted to a user when providing the reconstructed markup language template.

Another piece of information extracted from the lines of the program application is information indicative of the end of a markup language line i.e. a line of code of the markup language template . Once the process has detected information indicative of the end of a markup line the content fragments previously extracted and concatenated in one of the parameter areas is recognized as being a complete line and is written out so that the next line can be stored in the parameter area. These steps are repeated to output consecutive lines of the markup language template.

In addition the process extracts repetition information indicative of lines of markup language written out from the program application which are to be repeated in the markup language template. As discussed above this is preferably done in connection with the level information written out for each program line of the program application. For instance the program application may include data which indicates the start of a grouping of repeated information i.e. data corresponding to lines of the template which were repeated where the grouping ends the number of times the grouping is to be repeated and the position at which the repetition is to occur. As will be appreciated by one of ordinary skill in the relevant art there are a number of ways of accomplishing this depending on the particular legacy program language involved. Relevant examples of this process will be discussed below with respect to COBOL.

Finally the process includes providing the written out markup language lines in a markup language template and repeating particular lines or groups of lines as indicated. This markup language document represents a copy of the original markup language template used in generating the program application.

One of ordinary skill in the relevant art will appreciate that the process may be modified depending on the preferences of the programmer and in accordance with the different legacy program languages in which the program application is written. Provided below are examples of the implementation of a process according to one embodiment of the present invention where XML is the markup language and COBOL is the legacy language.

In step the process locates an XML data structure which in this embodiment is entitled LS XML document . In step the process sets variables parameters to blank settings. The variables are parameters for which information is extracted from the COBOL program application and stored for use in the process. These parameters take the form of storage area memory. Examples of the variables are provided in step . The variable New xmlline refers to the content fragments to be extracted from the COBOL program application. Specifically the variable is set to dictate a storage area into which content fragments may be read assembled with other fragments and stored until the line of XML data is completed and written into a document to construct the template.

An occurs clause is relevant in COBOL language for indicating data to be repeated. The term level refers to the level information from the line of COBOL program application containing an occurs clause. The term size indicates the number of times the set of data is to be provided i.e. repeated . As can be seen in step there are variable areas for occurs occurs and occurs . These three different sets of occurs clauses are provided inasmuch as there may be multiple sets of data to be repeated. Thus the different and potentially nested groups of data to be repeated can be separately identified. As would be appreciated by one of ordinary skill in the relevant art more sets of occurs variables may be included as needed.

Once all of the defined variables are set to blanks the process proceeds to step . In step a line of the COBOL program application is read and the level number thereof is extracted. In step it is determined whether there are more lines in the COBOL program application. If there are no more lines the process is exited in step . If there are more lines the process proceeds to step .

In step the extracted level number is compared to the values in the occursx level variables. This will only happen if the occurs variables have already been populated. How those variables are populated will be discussed in detail below. Specifically in step it is determined whether extracted level number N is less than or equal to a value stored in connection with the occurs level variable.

When the extracted level number is a level number or less than the number that is already populated in one of the variable areas which will be discussed in detail below the process understands that the line indicates the end of a set of data to be repeated. Thus if level number N is less than or equal to occurs level i.e. the occurs level variable is already populated with a number less than or equal to the level number of the current line the process proceeds to step . In step the process replicates the output records from the written out line beginning after a label .A discussed below to the present line in accordance with the number of times indicated in the occurs size variable the population of which is also discussed below . Also the occurs level and occurs size variables are reset.

If the extracted level number N is not populated in the occurs level variable or the extracted level N is not less than the value populated for that variable the process proceeds to step . Similarly to steps and steps and make determinations for the extracted level N with respect to the occurs level variable. Furthermore steps and provide similar functionality with respect to the occurs level variable. Once it is determined for each of the occurs variables whether the process should repeat a previous group of data i.e. whether the current level number indicates the end of data to be repeated the process proceeds to step .

In step it is determined if the line of COBOL program application code has a picture clause. If the line of code has a picture clause the process proceeds to step in which information regarding the length L is extracted. If there is no picture clause in the line the process proceeds directly to step .

In step it is determined whether the source line has a value clause. In the COBOL language the value clause refers to content fragment. Reference numbers in indicates examples of content fragments. Consequently at step a content fragment V is extracted from the COBOL program application. If there is not a value clause the process proceeds to step . If a value clause is extracted the process proceeds to step in which it is determined if L length V . In other words it is determined if the extracted length information L is greater than the actual number of bytes of the extracted content fragment V. If the proposition holds true the process proceeds to step in which a comment warning of the discrepancy is written into the header of the output file. If the proposition does not hold true the process proceeds to step . In step the extracted content fragment V is added to the XML line being written such that the variable new xmlline is updated to be new xmlline V. In other words the extracted content is added to the XML line and concatenated with other fragments as necessary.

In step it is determined if the end of an xmlline being concatenated in accordance with variable new xmlline has been reached. Specifically if the first two bytes of a content fragment extracted in step contains 

In step it is determined if the content of the line has an occurs clause. If there is not an occurs clause the process proceeds to the next step. If there is an occurs clause in the line a repetition size A and a level number N are extracted from the line. In step if the occurs level is still blank the process proceeds to step in which the occurs level variable is set to N and the occur size is set to A. In addition the last output line is tagged with the label .A . If the occurs level is not blank the process proceeds to step in which it is determined whether the occurs level is blank. If it is blank the process proceeds to step which is similar to step but that the occurs variables are set with level N and size A and the last output line is labeled as .A . If the occurs level is not blank the process proceeds to step . Steps and are similar to steps and except for that the occurs level is used and the last output line is labeled as .A . Thus the start of data to be repeated is indicated the repetition of which takes place once the end of data is located as discussed above in steps .

The process then starts again at step and repeats itself until it is determined at step that there are no more lines of the COBOL program application corresponding to the XML data structure in which case the process exits in step with the complete XML template having been written out.

For instance chart is provided in . The line numbers for chart provided in column correspond to the line numbers of program provided in column of . As shown in line of chart the source line of the corresponding COBOL program application shown in is a picture clause. Consequently the level number N see column is extracted along with length L see column . Line number see column of the COBOL program application includes a value clause. Consequently the value clause in this case . Consequently the process detects the end of an XML template line and the entire concatenated line is written out into the output record see column . The line constructed from lines through of the COBOL program application can be seen in . Specifically the first line of the output xml reads .

In line number of the COBOL program language the process encounters its first occurs clause. Specifically that lines states GRP RESULTS OCCURS. Because this is the first occurs clause of the application the occurs variables have not previously been populated. Consequently as shown in column occurs level is set to 10 and occurs size is set to 2. As can be seen 10 is the level number N for that line and the size 2 is determined from the occurs size recited in the COBOL code OCCURS . In addition the process labels the last output record line with the label .A .

In line number level number is again recited. Because the variable occurs level has already been populated with a number that is equal to or less than 10 in this case as shown in line of chart the process determines that repetition is to take place. Consequently as indicated in column all of the lines written out from the label A to line are provided in the template two times. Note however that this does not mean to repeat that information two additional times but that the information is to be recited two times total or in this case one additional time . The repetition can be seen in the output XML template in . Specifically the lines from when the label A line was added to an output line in line of chart to the occurrence of level number in line are indicated by reference numeral . In accordance with the information in line section is repeated as shown by section .

After line the process determines that there are no lines of the COBOL program application left which correspond to the data structure in which case the process ends. Consequently the XML template used to create the COBOL program application in is completely written out as shown in .

The present invention may be implemented using hardware software or a combination thereof and may be implemented in one or more computer systems or other processing systems as discussed in general above with respect to .

As a more specific example a computer system for use in the present invention such as computer or server includes one or more processors such as processor . Various software embodiments are described in terms of this exemplary computer system. After reading this description it will become apparent to a person skilled in the relevant art s how to implement the invention using other computer systems and or architectures.

Computer system can include a display interface that forwards graphics text and other data for display.

Computer system also includes a main memory preferably random access memory RAM and may also include a secondary memory . The secondary memory may include for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive an optical disk drive etc. The removable storage drive reads from and or writes to a removable storage unit in a well known manner. Removable storage unit represents a floppy disk magnetic tape optical disk etc. which is read by and written to by removable storage drive . As will be appreciated the removable storage unit includes a computer usable storage medium having stored therein computer software and or data.

In alternative embodiments secondary memory may include other similar devices for allowing computer programs or other instructions to be loaded into computer . Such devices may include for example a removable storage unit and an interface . Examples of such may include a program cartridge and cartridge interface such as that found in video game devices a removable memory chip such as an erasable programmable read only memory EPROM or programmable read only memory PROM and associated socket and other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to computer .

Computer system may also include a communications interface . Communications interface allows software and data to be transferred between computer system and external devices. Examples of communications interface may include a modern a network interface such as an Ethernet card a communications port a Personal Computer Memory Card International Association PCMCIA slot and card etc. Software and data transferred via communications interface are in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communications interface . These signals are provided to communications interface via a communications path e.g. channel . This channel carries signals and may be implemented using wire or cable fiber optics a telephone line a cellular link a radio frequency RF link and other communications channels.

In this document the terms computer program medium and computer usable medium are used to generally refer to media such as removable storage drive a hard disk installed in hard disk drive and signals . These computer program products provide software to computer system . The invention is directed to such computer program products.

Computer programs also referred to as computer control logic are stored in main memory and or secondary memory . Computer programs may also be received via communications interface . Such computer programs when executed enable the computer system to perform the features of the present invention as discussed herein. In particular the computer programs when executed enable the processor to perform the features of the present invention. Accordingly such computer programs represent controllers of the computer system .

In an embodiment where the invention is implemented using software the software may be stored in a computer program product and loaded into computer system using removable storage drive hard drive or communications interface . The control logic software when executed by the processor causes the processor to perform the functions of the invention as described herein.

In another embodiment the invention is implemented primarily in hardware using for example hardware components such as application specific integrated circuits ASICs . Implementation of the hardware state machine so as to perform the functions described herein will be apparent to persons skilled in the relevant art s .

In yet another embodiment the invention is implemented using a combination of both hardware and software.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example and not limitation. It will be apparent to persons skilled in the relevant art s that various changes in form and detail can be made therein without departing from the spirit and scope of the present invention. Thus the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

In addition it should be understood that the figures and screen shots illustrated in the attachments which highlight the functionality and advantages of the present invention are presented for example purposes only. The architecture of the present invention is sufficiently flexible and configurable such that it may be utilized and navigated in ways other than that shown in the accompanying figures.

Further the purpose of the foregoing Abstract is to enable the U.S. Patent and Trademark Office and the public generally and especially the scientists engineers and practitioners in the art who are not familiar with patent or legal terms or phraseology to determine quickly from a cursory inspection the nature and essence of the technical disclosure of the application. The Abstract is not intended to be limiting as to the scope of the present invention in any way. It is also to be understood that the steps and processes recited in the claims need not be performed in the order presented.

