---

title: Method and apparatus for enforcing safety properties of computer programs by generating and solving constraints
abstract: A method and apparatus is disclosed herein for generating and solving constraints. In one embodiment, the method comprises modifying program code by inserting one or more dynamic annotations having unsolved variables, generating one or more constraints based on the one or more dynamic annotations using a verifier, solving the one or more generated constraints; and modifying the program code by inserting a dynamic annotation in place of an annotation containing an unsolved variable.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07730455&OS=07730455&RS=07730455
owner: NTT Docomo, Inc.
number: 07730455
owner_city: Tokyo
owner_country: JP
publication_date: 20051107
---
The present patent application claims priority to the corresponding provisional patent application Ser. No. 60 626 166 titled Method and Apparatus for Analyzing and Limiting Resource Use of Sequential Computer Programs filed on Nov. 8 2004.

This application is related to the co pending application entitled Flexible and Efficient Method for Limiting the Resource Usage of Computer Programs filed on Dec. 23 2003 U.S. patent application Ser. No. 60 532 359 assigned to the corporate assignee of the present invention.

The present invention is related to the field of checking of computer programs more particularly the present invention is related to performing both static and dynamic checking of computer programs.

Programs are created by individuals referred to herein as code producers and run by individuals referred to herein as code consumers. The code consumer does not want to run an untrusted program created by the code producer because the program communicates with the code consumer s computer via a runtime library which provides functions to access resources such as files and the network. The code consumer wants to be sure that the program is safe meaning that it does not corrupt user data it does not export private data to outside sources and it does not abuse system resources.

There are several existing methods for ensuring safety of a computer program. These include dynamic checking and static checking. Dynamic checking refers to the process by which each potentially unsafe operation is checked just before it occurs. For example if a safety policy forbids access to a particular directory then the runtime RT library or RT monitor must check each file access. Dynamic checking has advantages. First it is precise. That is it only detects safety violations that the program is actually going to commit. If the checker detects a violation then the program would actually commit the violation had the user turned off the checker. Second it is simple. The entire checker consists of simple checks that are placed in the runtime library alongside the appropriate routines. However dynamic checking has disadvantages. First it is late because it detects errors at the last possible moment. Lateness is a problem because terminating the program without warning may surprise or confuse the user or cause her to lose valuable data. Also when terminating the program it may be difficult to recover operating system OS resources that the program has allocated which may adversely affect the performance of other running programs. Second dynamic checking is inefficient. Since every operation performs a check before executing these checks occupy a considerable portion of CPU time.

In static checking the entire program is analyzed before execution to see whether it is safe. Static checking has advantages. First static checking is early in that it detects all faults before execution begins. Thus if the checker verifies the program no runtime errors can occur so the user cannot lose data and the OS never has to terminate the program. Second static checking is efficient. All checking is done based on the program text so there are no runtime checks whatsoever and the program can run at the same speed as a fully trusted program. Static checking also has disadvantages. First static checking is complex because it tries to reason about program behavior which is complex. Second static checking is incomplete meaning that it rejects some safe programs. This imprecision comes from two sources. First programs are complex. Although the checker may be able to handle many simple programs because many program properties of practical interest are undecidable there are some safe programs that it cannot verify. Second the static checker runs with incomplete information in that it knows the program but it does not know its input. The best result state checking can produce is to determine whether some input causes an unsafe action. It cannot determine whether this input actually occurs.

In the context of resource usage dynamic checking refers to the process by which a resource manager performs checks while the program runs while static checking refers to the process by which the resource manager performs checks before the program runs. Dynamic checking is flexible but inefficient while static checking is efficient but inflexible.

Resource use estimation in programs may be considered a problem for estimating execution times of sequential computer programs. Execution time itself can be considered a resource where the basic consumption of each instruction is 1. In contrast the resource usage of a computer program is often parameterized by the variables of the program. For example consider the following code fragment 

The execution time problem for this code looks only at the top level for construct and has to analyze the sum 1. In contrast in order to evaluate the resource usage of this program the sum i is analyzed. Thus the execution time problem is a special case of the resource usage problem.

For more information on static resource accounting see A. Ermedahl and J. Gustafsson Deriving Annotations for Tight Calculation of Execution Time In Proceedings of Euro Par 97 Vol. 1300 of Lecture Notes in Computer Science pp. 1298 1307 August 1999.

With respect to dynamic approaches a dynamic resource monitor is used to keep track of all resource usage and can be very inefficient. For more information on dynamic resource accounting see C. Park and A. Shaw Experiments with a Program Timing Tool Based on Source level Timing Schema IEEE Transactions on Computers 24 48 57 May 1991.

A method and apparatus is disclosed herein for generating and solving constraints. In one embodiment the method comprises modifying program code by inserting one or more dynamic annotations having unsolved variables generating one or more constraints based on the one or more dynamic annotations using a verifier solving the one or more generated constraints and modifying the program code by inserting a dynamic annotation in place of an annotation containing an unsolved variable.

A method and apparatus for creating a safe computer program from an unsafe computer program are described. For purposes herein a safe program is one whose behavior is constrained by a safety policy. A safety policy is any policy that can be realized using dynamic checks for example one that constrains how a program uses a runtime library. Embodiments of the present invention have several primary advantages. First one or more embodiments produce safe programs that are more efficient than with other approaches. Second one or more embodiments handle many different safety policies. Third it is easy to prove that it is correct. This methodology can be applied to ensure resource use safety of a computer program as well as for estimating resource usage of a computer program.

In one embodiment programs are modified into safe programs by adding annotations to the program. The annotations are added as a result of analysis having both static and dynamic components.

In one embodiment the techniques described herein are implemented using four components a check inserter a constraint generator a constraint solver and a check instantiator. The check inserter receives an unsafe program and adds dynamic checks to the program. These checks include variables which are not yet determined. The constraint generator receives the program with checks added and produces a set of safety constraints on the variables added by the check inserter. These constraints are necessary and sufficient for program safety. That is in one embodiment the program is safe if and only if the constraints are solvable. The constraint solver accepts the set of safety constraints and determines values for the variables created by the check inserter. The check instantiator accepts the solutions produced by the constraint solver and substitutes them into the program s dynamic checks to produce a final safe program without variables. The new program is similar to the input program except that it halts before violating the security policy. Thus in one embodiment constraints for different parts of a program are statically generated using the computation structure of the program and the constraints are then solved to determine where to place dynamic annotations.

The analysis framework described herein has many applications. For example as is described below the analysis framework may determine annotations for a computer program that have direct applications to estimating resource usage and ensuring resource use safety. To that end one embodiment of the present invention includes two application programming interfaces APIs one for resource use estimation and one for resource use safety. In one embodiment the resources of interest on a platform are captured by a resource accounting policy which is a map between program instructions and actual usage.

A technique for simplifying static analysis by modifying the program in a way that preserves the semantics of the analysis is also disclosed. This technique adds dynamic annotations e.g. dynamic checks to the program. In one embodiment dynamic checks are added to the program based on constraints that are solved while evaluation the program. The solved constraints enable insertion of the annotations to make the program safe. Those constraints that are unsolvable statically are simplified by dynamic calls.

In the following description numerous details are set forth to provide a more thorough explanation of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

The techniques described herein for annotating programs for the purpose of for example ensuring safety are below in terms of an application to resource usage particularly resource use estimation. It should be apparent that these teachings are applicable to other applications.

In one embodiment in order to apply the annotation framework to resource estimation constraints for the resources consumed by different parts of the program are statically generated using an inductive computation on the structure of the program. This process includes annotating computer program code to add one or more operations that apply to resource usage for a portion of the computer program code and determining resource usage of the computer program based on the one or more operation indicating resource consumption of the computer program code. In one embodiment the resource usage of the computer program code is determined as a set of constraints that relate resource consumption of the portion of the computer program code to resource consumption of components of the portion of the computer program code. The process also includes generating constraints for resources consumed by portions of the computer program code and solving the constraints to determine resource usage by the computer program code as part of determining resource usage of the computer program code. In one embodiment solving the constraints involves converting the constraints to canonical form and matching the constraints against one or more entries in a knowledge base.

In one embodiment an analysis method determines the resource usage of an arbitrary sequential computer program using a consumption condition generator. In one embodiment the consumption condition generator performs an inter procedural full program computation as a constraint generation process to generate constraints that are then solved for determining resource usage. More specifically the consumption condition generator operates on a set of static annotations in the program and automatically computes static annotations. The static annotations may be provided by a programmer.

In one embodiment two kinds of annotations are used basic consumption and compound consumption. Basic consumption annotations map program commands to the resources they use. Compound consumption annotations may be associated with blocks loops method calls and other composite program constructs and are resource use expressions for the corresponding program constructs. In one embodiment compound consumption annotations express the resource usage of each command in terms of the local and global variables that occur in the command. The consumption condition generator captures the property that the compound consumption for a program construct bounds the sum of the basic consumptions of its components. The constraints generated by the consumption condition generator are used to solve for the compound consumption expression for the entire program or block method loop or composite command in question. In addition in one embodiment any resource usage expression satisfying the constraints generated by the consumption condition generator is guaranteed to satisfy the resource needs of the program.

The constraint generation process can be applied for any desired granularity of placement for the dynamic annotations. In one embodiment these constraints are solved using simplification to canonical form and matching against a knowledge base of constraint solution template pairs.

The techniques for resource use estimation may be applied to many types of resources and can be instantiated to explicit resources such as for example memory disk threads etc. and implicit resources such as for example execution time and energy based for example on CPU instruction counts .

The resource accounting process disclosed herein has applications in all areas where it is useful to estimate the resource usage of a program. Examples include but are not limited to real time program scheduling and estimation liveness and resource use safety of arbitrary code.

Static analysis may be simplified by adding dynamic checks in place of unsolvable constraints. In one embodiment the simplified static analysis includes receiving program code having one or more annotations and modifying the program code by inserting a dynamic annotation in place of an annotation corresponding to an unsolved constraint. The dynamic annotation may comprise a dynamic call into the program code. The modification occurs while preserving semantics of the checks. In one embodiment the annotations are inserted into the program code to increase program resource use safety based on results from solving constraints when evaluating resource usage of the program code. This process may be performed iteratively.

More specifically after attempting to solve a constraint while evaluating a program one or more unsolvable constraints may be identified. For example when evaluating the resource usage of a program an unsolvable constraint may be identified. In such a case these constraints are replaced with dynamic checks. In this way static and dynamic components are combined together. Thus in one embodiment difficult static problems may be eliminated by deferring them to a dynamic evaluator.

In an example embodiment this methodology is used to verify that a given program is bounded by a stated resource usage expression. In one embodiment a feedback channel is used in the analysis to indicate constraints that are unsolvable statically. These constraints are simplified using dynamic resulting in simpler constraints that may then be solved.

In one embodiment a program may be automatically annotated for resource use safety. This may occur by adding dynamic annotations using an API that allows for static verification of resource use safety in an arbitrary sequential computer program. In such a case the analysis methods for resource estimation and static analysis simplification discussed above may be used to automatically annotate a program with a resource use API that ensures adequacy of the resource estimate in which safety is directly implied. Thus the automatic annotator is sound i.e. any automatically annotated program will pass a static verifier for resource use safety. In one embodiment this automatic annotation process includes evaluating resource usage of computer program code and annotating the computer program by inserting one or more operations into the computer program code for resource use safety based on a result of evaluating the resource usage of the computer program code. In one embodiment inserting one or more operations into the computer program code includes removing one or more resource consumption constraints for resource use safety based on a result of evaluating the resource usage of the computer program code. The operations may be consume operations to set one or more resource consumption constraints corresponding to the unsolved constraints terms to a predetermined value e.g. zero in order to achieve resource use safety.

The following description describes an embodiment of the architecture applied to resource usage. It should be noted that other applications of the techniques described herein exist.

The system of enables creation of a safe program from an unsafe one. Referring to the system comprises two subsystems a constraint generator and a constraint solver . An unsafe program is input into constraint generator . Constraint generator generates constraints for unsafe program . Constraint solver solves the constraints and creates safe program .

Referring to the process begins by annotating the computer program with one or more operations related to resource usage of portions of the computer program processing block . After annotating the program processing logic generates resource usage constraints for the computer program processing block . After evaluating resource usage processing identifies one or more constraints having one or more unsolved terms processing block . Next processing logic insert one or more acquire operations to the computer program in response to results of evaluation resource usage by the computer program to set one or more resource consumption constraints corresponding to the unsolved terms to achieve resource use safety processing block .

The program with its safety constraints may be generated by an annotator. In one embodiment the annotator operates in two phases. In the first phase the annotator creates an integer variable ffor the resource consumption of each function f a boolean variable fpre for the condition under which f is called and a boolean variable fpost for the condition under which f returns. Since all of these variables can depend on the arguments to f and on the program state they are written as f right arrow over x s f pre right arrow over x s and f post right arrow over x s for purposes herein. In the second phase the annotator creates pre and post conditions for each function that state the f pre is true when f is called f post is true when f returns and fuses no more than fresources and adds these as abstract resource usage annotations. Then a verification condition generator VCG generates constraints on the variables f pre f post and f. Thus the VCG discovers constraints whose solution contains safe values.

Constraints solver solves constraints in the program. Check instantiator replaces abstract resource annotations with concrete annotations that do not involve variables. The output of check instantiator is safe program .

Referring to processing logic of the constraint solver determines when the constraints of program and safety constraints are solvable processing block . Next processing logic of the constraint solver modifies both the program and the set of constraints processing block . In one embodiment processing logic modifies the program in order to simplify the constraints and make them easier to solve. More specifically processing logic determines how to modify the program by inspecting the constraints and if the constraints are solvable processing logic in the constraint solver solves the constraint processing block and instantiates variables in the program processing block . This results in safe program .

Some constraints may be extremely difficult to solve because program behavior can be arbitrarily complex. In one embodiment constraint solver simplifies the constraints by ruling out complex behaviors.

In one embodiment a program is unsafe if and only if it violates the calling convention of some library function. That is the program either violates the pre condition of the function or it calls the library function with insufficient resources. In one embodiment the constraint solver places a dynamic check immediately before each call to a library function. Such a constraint solver allows the maximum set of safe executions because it stops precisely the unsafe executions.

In one embodiment this constraint solver introduces a dynamic check before each call to a library function or at least before each call to a library function that is constrained by the security policy. In another embodiment the constraint solver introduces fewer dynamic checks if it can use more intelligence in solving the equations. For example the constraint solver may realize that some pre condition is satisfied in all executions so that no check is actually necessary.

Referring to the process begins by processing annotating a computer program to add one or more operations associated with resource usage for a portion of the computer program processing block . After annotating processing logic generates a set of constraints as one or more inequalities relate resource consumption by that program to the consumption of its associated portion of the computer program processing block . With the constraints processing logic solves the set of constraints to determine resource usage by the computer program by converting the constraints to canonical form and matching the constraints against one or more entries in a knowledge base processing block . Next processing eliminates one or more annotations in the computer program corresponding to one or more unsolved constraints in the canonical form of the set of constraints processing block .

Referring to annotation inserter receives program e.g. source binary and resource accounting policy and in response thereto generates annotated program . The resource consumption of the same program may depend on the platform it is being run on and this dependency is captured using a resource accounting policy . In one embodiment resource accounting policy is used to initially annotate program using an accounting API so that the consumption of commands is made explicit. Thus in such a case annotation inserter performs a policy based annotation.

Constraint generator receives annotation program and captures the resource consumption of the program as a set of constraints that relate the consumption of a block or a method in annotated program to the consumption of its components which may include other functions or blocks. This approach may be used to handle loops as well since the consumption of loop may be expressed as the consumption of one unrolling of the loop added to the consumption of the loop from there on resulting in a recurrence. In one embodiment the form of these constraints can either be equations or inequations. Equations can capture the resource consumption exactly for different ranges in the domains of the variables of the resource consumption function. Inequations provide a tight upper bound on the resource consumption and help approximate consumption over multiple paths with a single expression such as is the case in conditionals.

Constraint canonicalizer receives the set of equations generated by constraint generator that contain terms corresponding to method block and loop consumption that must be solved for. In one embodiment in order to solve for a particular term all the equations are organized by constraint canonicalizer so that the minimal set of equations relevant to that particular term is obtained. This process is called canonicalization and in one embodiment involves a standard fix point style computation. Constraint canonicalizer outputs a set of canonicalizal constraints .

In one embodiment constraint solver receives a set of canonicalizal constraints output from canonicalizer along with an input from solution knowledge base and in response thereto identifies any recurrences in the set of canonical equations and matches them against a set of heuristics. In one embodiment the heuristics are specified in the most general form possible for a particular class of recurrences and thus unification is required to instantiate the heuristic with the particular instance for the target program. The result of the matching operation is a closed form solution for the term being solved for which could be the resource consumption of a function block loop or the entire program. The outputs of constraint solver are solved partially solved constraints and unsolved constraints .

Annotation eliminator performs annotation elimination or annotated program based on the solved partially solved constraints . More specifically the solution of constraints facilitates static estimation completely or partially of the resource usage of different commands corresponding to different regions of the program. Annotation eliminator identifies the core unsolved constraints and the regions of the program they correspond to and eliminates consumption annotations from these portions of the program. As a result annotation eliminator outputs partially evaluated program . In one embodiment partially evaluated program includes a minimal number of dynamic consumption annotations.

Partially evaluated program is received by dynamic resource counter which determines resource usage of partially evaluated program by counting resources.

In one embodiment constraint simplifier reuses unsolved constraints and uses dynamic cost to simplify the results of static analysis. In one embodiment the static analysis is limited by the constraint solutions available in the knowledge base. The generated constraints relate the arguments of the dynamic annotations placed in the program. If the constraints generated for a specific dynamic annotation are unsolvable it may be possible to weaken the constraint by inserting an actual dynamic call in the corresponding body of the code. This weakened constraint may then match against a constraint solution pair in static knowledge base to obtain a dynamic call annotation to insert into the program in place of the constraint resulting in a simplified overall set of constraints. In one embodiment this feedback process is then iterated until no more constraints are left. Notice that this process terminates because all unsolved constraints are eliminated by inserting dynamic annotations.

In one embodiment in order to describe the resource accounting procedure a simple imperative programming language is used to perform computation with integer values. Assuming there is one resource of interest whose amount is measured in some arbitrary unit a command consume E is used to model any operation that dynamically uses E units of the resource where E is an expression in the language. In one embodiment resource accounting is performed at the level of function calls and the command run cons E f x is used to model the static evaluation of the resource use within f x where E will in general depend on x.

Notice that in this language the static accounting API run cons is used only to annotate functions. While a hand annotated program may use run cons in an unrestricted fashion the automatic accounting procedure of one embodiment only introduces it at function definition points. The constraints generated by the accounting procedure depend on where the run cons annotations are present in the program. Since one goal is to solve for the consumption of the entire program these annotations are only at function boundaries in one embodiment.

The usage of a resource for the same program may be platform dependent and this dependence may be specified in a uniform way. In one embodiment the Resource Accounting Policy RAP for the agent running the given program specifies a map between basic commands and units of the resource in question. In general the RAP specifies a resource expression for the command which may refer to the free variables in the command. Basic commands for our language include skip assignment and function call. shows an example of a resource accounting policy for the read disk resource.

The first step in the resource accounting procedure is to take an unannotated program and transforms it using a resource accounting policy. The transformed program contains known basic consumption annotations for each command as well as the as yet unknown static compound consumption for each function definition. In one embodiment the transformation is performed according to the following rules and is performed inductively on the structure of the commands. Note also that the annotation is performed for the bodies of all functions including the main program.

First for the base case simple commands skip assignment function call are preceded by a consume e statement as specified by the resource accounting policy. Second each compound command sequencing conditional while and function definition is recursively treated by applying the transformation in sequence to the component commands of the compound command. For the commands c cand if b then celse c the component commands are cand c and for the commands while b do c and run cons ef x begin c end the component command is c.

One embodiment of the annotation inserter is described in the flow diagram of . Note that the resource accounting policy is represented as a map p between commands and resource expressions.

Note that both the resource accounting policy and the initial annotation process can be extended to include consumption annotations for function that are also defined within the program. In this case in one embodiment the definitions of those functions would be omitted from the annotation process and their use would be annotated with a basic consumption annotation using the information provided in the RAP.

After performing annotation constraints are generated from the annotated program. illustrate one embodiment of the consumption condition generator ccg . In several cases a function is presented in both code and flowchart forms. In all cases the two forms are equivalent.

The consumption condition generator ccg is defined by recursion on the syntax of commands. Given a command c a program state s and a set of constraints T ccg c s T produces new constraints regarding the resources consumed by the command c when started in state s. In order to determine the usage of the entire program starting in initial state s the original program is wrapped within a top level main function and statically solved the constraints generated by ccg main s .

The amount of resources consumed by command c when started in state s is denoted by C c s . The ccg generates constraints on values of the map C for the different commands in the program. Since the C command can be completely defined statically the constraints are solved for as many instances of C c s as possible and include them in the static run cons annotation for the methods.

The goal of one embodiment of the constraint generation process is to statically evaluate the run cons for the entire program. The first step in this process is to simplify the set of constraints so that only C c s are solved for the commands c that actually lie on the control flow path for the program given the initial state. In one embodiment there are two parts to this process static elimination and substitution.

With static elimination for example it may be possible to statically determine the value of boolean tests and eliminate constraints generated by the branch that isn t taken.

With substitution the constraints generated by the ccg are organized as a directed rewrite system. Each constraint generated by the ccg is directed from left to right expressing the consumption of a command in terms of its basic commands. The top level constraint describes the consumption of the entire program. Given a constraint for x in terms of y if the constraint for y only refers to a variable z then x is expressed in terms of z directly. This process is repeated until there are no more substitutions to be made for the top level constraint.

Referring to the process begins by processing logic by performing static analysis on a computer program prior to running the computer program by solving resource constraints in canonical form that represent resource usage by the computer program processing block . Next processing logic identifies one or more constraints having one or more unsolved terms processing block . Using the one or more constraints having one or more unsolved terms processing logic identifies one term the unsolved terms whose elimination simplifies the one or more constraints to a highest degree processing block . After the identification process processing logic eliminates the one term by replacing a static measure of a dynamic operation in the computer program with a dynamic operation corresponding to resource use processing block .

The process continues with processing logic determining whether there are any unsolved constraints processing block . If not processing logic outputs solved constraints processing block . If there are unsolved constraints processing logic tests whether any nodes are with outdegree processing block . For these nodes the child node can be folded back into the parent node by a simple substitution. If there are such nodes processing logic eliminates such nodes by substitution into parents processing block . If not processing logic outputs the canonicalized constraints processing block .

The constraints generated by substitution and elimination result either in solved constraints or in systems of recurrences between different variables in the constraints. The complexity of the generated recurrences depends on the control flow in the original program and cannot be assumed to be of a specific form. Thus these recurrences are solved by matching against a library of general solution forms for recurrence equations. A client may choose a solution library of any size. A library that captures many different programmatic templates will allow for a better static estimate of resource consumption in the program. As an example consider the while command below. i 0 while i

The simplified constraints generated from the above command describes the consumption of this entire command say c in terms of the consumption of the while loop cw recall that C i i 1 0 cond 10 0 0 1 

Notice that the consumption expression for the while loop is a recurrence and assuming that the library contains a general expression for it. Assume that this expression corresponds to the consumption of the following loop 

The solution to this constraint would be specified in the most general form as C c0 w i S i c a b c d . In order to match the two constraints we use a standard algorithm for set unification and then add the solution as a constraint to the original set.

This process is repeated for all the recurrences in the set of constraints. Recurrences that can t be matched against any pattern are left untouched. At the end of this process there might be a few unsolved C c s left and these will correspond to dynamic resource counting.

The next step in this process eliminates all the dynamic consumes that were introduced in the initial annotation and have been covered by the static calculation. An unsolved C c s in the constraints renders the commands that it is a part of and ultimately the entire program statically unsolvable for resource consumption. However in order to collect the parts of the syntax tree for which resource consumption was determined into the run cons static annotation on each method. Thus the following is performed 

Next one embodiment of a constraint simplification is performed. In one embodiment the process employed is as follows. First each unsolved constraint has an expression on the right hand side that involves terms related to dynamic annotations. An elimination order is chosen for eliminating sets of subterm. For example one elimination order can look at single subterms first then subterms sets of size and so on. Second for each eliminated subterm set the resultant constraint is matched against the knowledge base. If there is no match the process continues on using elimination order to the next candidate elimination. If there is a match the eliminated subterm set is recorded as well as the generated solution. Third amongst the successful matches the solution of the most poly nomial complexity is selected. This corresponds to the most difficult subterms that could have been eliminated. Fourth the eliminated subterms are sent to the annotation eliminator and the simplified constraints are sent back to the constraint solver. The feedback loop then iterates over the same procedure.

This general static analysis simplification technique is applicable to APIs where a dynamic operation can cache the results of static analysis. In addition the dynamic operation admits a way of self combination i.e. it is possible to statically ensure that a particular dynamic operation is equivalent to the combination of two or more dynamic operations.

Thus techniques for annotating programs for resource use safety are disclosed. One or more of the following advantages are associated with embodiments of the present invention. The resource bounds shown for a program can be efficiently verified. The technique works both with annotated and unannotated code providing the programmer with flexibility in specifying the resource usage of their programs. In one embodiment the constraints generated by the consumption constant generator are in the form of inequalities which facilitates to combining usage in different parts of the program such as in the different branches of the conditional. Moreover the annotations introduced herein allow combining of static analysis and dynamic resource monitoring to provide precision in resource usage estimation without significant lack of performance. In addition the static analysis described herein infers tight upper bounds for resource usage in loops. Furthermore in one embodiment the techniques are defined in terms of control structures in sequential computer programs and thus are applicable across the spectrum of such languages from bytecode to source. Also the analysis performed as part of is inter procedural and the generated resource expressions are in a most general form in terms of relevant globals locals and function parameters.

The system further comprises a random access memory RAM or other dynamic storage device referred to as main memory coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions by processor .

The computer system also comprises a read only memory ROM and or other static storage device coupled to bus for storing static information and instructions for processor and a data storage device such as a magnetic disk or optical disk and its corresponding disk drive. Data storage device is coupled to bus for storing information and instructions.

The computer system may further be coupled to a display device such as a cathode ray tube CRT or liquid crystal display LCD coupled to bus for displaying information to a computer user. An alphanumeric input device including alphanumeric and other keys may also be coupled to bus for communicating information and command selections to processor . An additional user input device is cursor control such as a mouse trackball trackpad stylus or cursor direction keys coupled to bus for communicating direction information and command selections to processor and for controlling cursor movement on display .

Another device that may be coupled to bus is hard copy device which may be used for printing instructions data or other information on a medium such as paper film or similar types of media. Furthermore a sound recording and playback device such as a speaker and or microphone may optionally be coupled to bus for audio interfacing with the computer system. Another device that may be coupled to bus is a wired wireless communication capability to communication to a phone or handheld palm device.

Note that any or all of the components of the system and associated hardware may be used in the present invention. However it can be appreciated that other configurations of the computer system may include some or all of the devices.

Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description it is to be understood that any particular embodiment shown and described by way of illustration is in no way intended to be considered limiting. Therefore references to details of various embodiments are not intended to limit the scope of the claims which in themselves recite only those features regarded as essential to the invention.

