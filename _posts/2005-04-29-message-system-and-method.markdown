---

title: Message system and method
abstract: A method and system for bridging services is provided. The method and system includes retrieving at last one message from a first messaging tool using at least one processing thread to retrieve message objects from a messaging queue of the first messaging tool. This aspect of the invention further includes executing a preprocessing on the retrieved message object using a predefined application programming interface (API) and placing the preprocessed message on an API of a second messaging tool. A computer program product comprising a computer useable medium including a computer readable program which, when executed causes the computer to implement the steps of the method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07853956&OS=07853956&RS=07853956
owner: International Business Machines Corporation
number: 07853956
owner_city: Armonk
owner_country: US
publication_date: 20050429
---
The invention generally relates to a message system and more particularly to bridge services in a networked environment.

In the past it was possible to deploy many different types of servers which only needed to communicate with each other occasionally however in current implementations many a business applications require systems to communicate in real or near real time automatically. Without a solution to communicate universally between such platforms in real or near real time there would be a need to design and implement a protocol on separate platforms which is not a trivial form of programming. This would also lead to the requirement of extensive time and resources for developing and testing such low level communications code.

MQ Series Messaging System is a message oriented middleware for providing exchange of messages and data on an enterprise wide basis. Currently MQ Series is used extensively in many locations and is gaining the acceptance as the defacto cross platform messaging tool. MQ Series Messaging System is offered by many providers including Microsoft and IBM MQ Series Message Queuing Series .

Microsoft BizTalk is gaining ground as an EDI electronic data interchange processing and work flow service BizTalk is a set of tools enabling business to business B2B exchange. In effect BizTalk enables B2B eCommerce and process integration the latter of which enables disparate business applications to exchange documents with each other over a network or enterprise system. The BizTalk Framework is an open framework for B2B exchange which is implemented across major platforms and most major B2B products from other companies. BizTalk is built on the Microsoft Windows 2000 operating system.

Microsoft has released an MQ Adapter for BizTalk but it turns out not to be very practical solution. First it requires a piece of code to run on the MQ Server itself. This limits the MQ Server to run on Windows based machines. This in of itself is a very limiting feature especially in view of the advent of new systems such as for example Linux based system. Second the MQ Adapter for BizTalk uses a preprocessor extension API application program interface that is very difficult to understand and is actually not compatible with their flagship development environment e.g. Microsoft.Net. This would appear to be contrary to the underlying advantages of an API i.e. a set of routines protocols and tools for building software applications which makes it easier to develop a program by providing all the building blocks. The MQ configuration for the MS adapter is also overly complex as it acts as a remote queue manager.

In a first aspect of the invention a method includes retrieving at least one message from a first messaging tool using at least one processing thread to retrieve message objects from a messaging queue of the first messaging tool. This aspect of the invention further includes executing a preprocessing on the retrieved message object using a predefined application programming interface API and placing the preprocessed message on an API of a second messaging tool.

In another aspect of the invention a method includes preprocessing messages as a set of loadable objects having access to a first messaging tool and accessing a second messaging tool interface. The method further includes creating a thread for loading a preprocessor object to process a message body incoming from the first messaging tool before passing the thread to the second messaging tool interface.

In yet another aspect of the invention computer program product comprising a computer useable medium including a computer readable program has computer readable program that when executed on a computer causes the computer to preprocess messages as a set of loadable object having access to a first messaging tool and access a second messaging tool interface. The computer readable program when executed also causes the computer to create a listener thread for loading a preprocessor object to process a message body incoming from the first messaging tool before passing the listener thread to the second messaging tool interface.

In another aspect of the invention a system includes an application programming interface for preprocessing messages as a set of loadable objects having access to a first messaging tool. The system further includes a module for accessing a second messaging tool interface and a service for creating at least one listener thread for loading a preprocessor object to process a message body incoming from the first messaging tool before passing the at least one listener thread to the second messaging tool interface.

The invention is directed to a system and method of message queuing and more particularly to providing a bridge service in a network environment The bridge service of the invention addresses the issues with for example. MQ to BizTalk bridge service which utilizes the .Net MQ Client and BizTalk API directly. The invention is further applicable to any message queuing system such as for example java message service JMS or XIPC. As should be understood JMS and XIPC are middleware products that manage interprocess communications across programs in a network.

The configuration of the invention can be implemented in the environment of . For example the invention can reside on the server although it is contemplated that the invention can reside on any of the components or run with any of the components of . The configuration of the invention allows the ability to preprocess messages with the .Net API as a set of loadable objects. These loadable objects have full access to MQ data including key fields such as Message ID and Correlation ID in their native format.

A module MQ AIC may be resident on the server e.g. BizTalk server for example provided to submit message from BizTalk back to MQ or across other platform. This module exposes the AIC interface and also has the ability to look up destination MQ Queue manager and destination Queue information based on document type sender id or by a predefined destination. The AIC interface is an application interface component that allows BizTalk to communicate with other systems for example. In one non limiting embodiment the MQ AIC application integration component transmits documents to an MQ Series Queue or Distribution List.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution stem apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current example of optical disks include compact disk read only memory CDROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

Referring to the invention can be implemented by a .Net Windows service which creates a listener thread for each configured queue block . The service is thus capable of creating a listener thread for loading a preprocessor object to process a message body in coming from a first messaging tool e.g. MQ manager before passing the listener thread to the second messaging tool interface e.g. BizTalk . The .Net Windows service is implemented using the .Net Framework utilizing any .Net framework compatible programming language by deriving the service object from System.ServiceProcess.ServiceBase. This allows the process to run in the background without any user interaction allowing this process to run automatically.

By utilizing background threads multiple queues can be monitored and used simultaneously and by utilizing multiple listeners on one queue the performance can be fined tuned to match the needs of the system. Additionally an independent application domain is created for each background thread to allow dynamic loading and unloading of individual preprocessor components without the need to restart the entire service block . Thus each listener thread executes under an independent application domain and exposes the application programming interface to allow the dynamic loading and unloading of individual components without the need to restart the service.

Each background thread which acts as a single flow of execution which is attached to a MQ queue can load a PreProcessor module independently of other threads. This allows for custom processing of the MQ Message received from the queue prior to submitting it to BizTalk. The utilization of the application domain concept in the .Net framework allows the PreProcessors to be updated and a new version loaded while the service is running. This allows in flight or real time or near real time bug fixes and feature enhancements to be deployed with out affecting the processing of other messages.

A control thread will monitor the status of the listener threads and restart them if necessary block . This eliminates any user intervention if a problem exist. For example by monitoring the status of the listener threads it is possible to restart a listener thread if connectivity to the message server or BizTalk server is lost. The control thread maintains a copy of the configuration file which specifies each queue to listen to and the appropriate configuration setting for each queue. The configuration settings within the configuration file dictate the queues to listen to and what preprocessors apply to each queue.

Upon system startup the controller e.g. control thread steps through the configuration settings and creates a ListenerThread object which represents an MQ Listener for each configured listener thread and then applies the individual thread configurations settings. Once this set of listener thread objects is created a timer is treated to wake up the control thread at a preselected interval e.g. 5 seconds at which time the control thread steps through the list of listener threads and checks a status property.

If the listener thread s status property is not running then the control thread starts the listener thread by creating a new thread object which executes the Listener Thread s Process Message method. The control process records the thread id from the listener thread with the ListenerThread object for future reference. The control process can then find an independent thread and allow the control objects to stop a specific thread if required for example to stop the service. Thus by having a separate control thread monitoring the status of the Listener Threads MQ Listener any errors or problems that exist on an individual listener thread e.g. MQ Server connection lost Bad Message . . . are alleviated because the processing can be automatically restarted at any predetermined time period interval e.g. every 5 seconds.

The controller e.g. control thread will also maintain performance counters which can be used by a monitoring program to determine the state of the service block . These performance counters are maintained as standard Windows performance counters to allow for any commercial monitoring tools that can access the Performance monitor API from MS Windows to watch for errors. The performance counters that are maintained may include for example.

By monitoring these values support personnel can readily detect a problem with the system as it occurs. An example would be to poll the Listener Threads Created counter every 5 minutes or other predetermined time and if it changes then a problem occurred. Alteratively the system of an embodiment of the invention can compare the Actual Thread Count to the Configured Thread Count . If these counts do not match the system of an embodiment of the invention will recognize that something is incorrect. Alternatively the system can monitor the Errors Per Second for a non 0 value. Each listener thread can load an optional preprocessor object to process the informing message body before it is passed to BizTalk block .

In one embodiment the optional preprocessor may be an application programming interface for preprocessing messages as a set of readable objects having access to a first messaging tool. In one embodiment the application programming interface accesses the preprocessor which allows custom processing of the MQ message received from a queue.

The preprocessor is capable of being updated and a new version loaded while the service is running. The listener configuration includes an optional .Net Assembly file to load and a corresponding .Net object derived from a predefined class library 

This interface abstract is an abstract class versus an interface so that the object can be forced to be derived from System.MarshallByRefObject which allows calling the interface across the applications domains. In this manner multiple versions of the code can be loaded into different domains allowing phased roll out approaches if necessary.

By implementing a preprocessor information from the MQ Message Envelope can be added to the message the message could be logged to a database decrypted or any other processing the application needs to do is performed before the message is in BizTalk. If there is an error putting the message into BizTalk e.g. BizTalk server down then the error message is passed to an LogErrorMessage method and any processing that the preprocessor did during the execute method can be undone.

The message is read from the MQ queue using the Check Point option in MQ. This allows the listener thread to issue a rollback command to MQ which will place the message back on the queue for resubmission. This allows for robustness and recovery block .

The preprocessor of an embodiment of the invention has the option to consume the message without it going to BizTalk block . This is accomplished by returning a null document to the listener thread indicating that the message is consumed and that it should not be rolled back block . This function allows for the removal of invalid documents prior to the submission. Although BizTalk can also perform document validation if the application needs to handle bad documents in a different manner than BizTalk or needs to have the documents reformatted prior to the submission the preprocessor of an embodiment of the invention can handle this task as described herein.

A default envelope preprocessor can be provided which wraps the original massage in an XML envelope utilizing MQ data to determine the source and destination of the document block . The application programming interface has the ability to access the default envelope preprocessor to wrap an original message in the envelope. Once the message has been preprocessed it is submitted to BizTalk or other type of application program via its exposed application programming interface block .

The message is then removed from the message queue block . This would be implemented by adding a XML wrapper around the is message body with a header section which includes the details from the MQ Message envelope. Example envelope properties may include message id correlation id put date time put queue manager queue name reply to queue manager reply to queue put application userid received time server name listener thread name to name a few.

As further shown in the application programming interface has the ability to access preprocessor modules which allow custom processing of an MQ message received from a queue. The preprocessor modules can be updated and a new version loaded while the service is running. In this manner the preprocessor modules allow for the service to perform any necessary preprocessing for the messages. The number of preprocessors modules is also unlimited however there is preferably one per configured listener. The service also may access the default envelope preprocessor .

While the invention has been described in terms of embodiments those skilled in the art will recognize that the invention can be practiced with modifications and in the spirit and scope of the appended claims.

