---

title: Application behavior based malware detection
abstract: An executable file is loaded into a virtual machine arranged to emulate the instructions of said executable file. The virtual machine keeps track of application programming interfaces (APIs) used by the executable file during emulation. The executable file is scanned to determine names of (APIs) used. Behavior flags are set if certain conditions occur within the executable file. The APIs determined during emulation and during scanning are compared with a set of known behaviors. A match of the APIs and the known behaviors indicates a high risk of malware. A determination of malware being present is based upon any matches and any behavior flags that are set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07779472&OS=07779472&RS=07779472
owner: Trend Micro, Inc.
number: 07779472
owner_city: Tokyo
owner_country: JP
publication_date: 20051011
---
The present invention relates generally to addressing malicious software in computer systems. More specifically the present invention relates to the detection of malicious software based upon an application s behavior.

Currently it is common for malicious software such as computer viruses worms spyware etc. to affect a computer such that it will not behave as expected. Malicious software can delete files slow computer performance clog e mail accounts steal confidential information cause computer crashes allow unauthorized access and generally perform other actions that are undesirable or not expected by the user of the computer.

Current technology allows computer users to create backups of their computer systems and of their files and to restore their computer systems and files in the event of a catastrophic failure such as a loss of power a hard drive crash or a system operation failure. Assuming that the user had performed a backup prior to the failure it can be straightforward to restore their computer system and files to a state prior to the computer failure. Unfortunately these prior art techniques are not effective when dealing with infection of a computer by malicious software. It is important to be able to detect such malware when it first becomes present in a computer system or better yet before it can be transferred to a user s computer.

One prior art technique for detecting a virus is known as the signature matching technique. This technique is able to detect known malware using a predefined pattern database that compares a known pattern the virus signature with a suspected virus in order to perform detection. This technique though is unable to handle new unknown malware. Further although this technique works well with traditional types of computer viruses for example it does not work well with more recent popular malicious software such as Mass Mailer and self compressed viruses. Other prior art techniques use predefined rules or heuristics to detect unknown malware. These rules take into account some characteristics of the malware but these rules need to be written down manually and are hard to maintain. Further it can be very time consuming and difficult to attempt to record all of the rules necessary to detect many different kinds of malware. Because the number of rules is often limited this technique cannot achieve both a high detection rate and a low false positive rate.

The detection of computer worms can be especially problematic. Prior art techniques rely upon creating a pattern file for a newly detected worms and for updating that file as a new worms are found. But a worm is inherently different from other types of computer viruses in that a worm can generate many variants very quickly. It can be extremely difficult to generate the signature files needed to detect all of the new variants of a computer worm.

Given the difficulties in the prior art with detecting malware in general and computer worms in particular a new technique is desired.

To achieve the foregoing and in accordance with the purpose of the present invention a heuristic technique is disclosed that allows for the detection of malware in general and computer worms in particular.

A method of detecting malware begins by first receiving a suspect executable computer file. Next the executable file is loaded into a virtual machine arranged to emulate the instructions of the executable file. The instructions of the executable file are emulated using the virtual machine. A behavior flag if any suspect conditions occur during emulation. The virtual machine keeps track of application programming interfaces APIs used by the executable file during emulation. The APIs used are compared with a set of known behaviors each known behavior includes a list of APIs used by malware. Finally a determination is made that the executable file is malware based upon the results of the comparison.

In an alternative embodiment an executable file is loaded into a virtual machine arranged to emulate the instructions of said executable file. The virtual machine keeps track of application programming interfaces APIs used by the executable file during emulation. The executable file is scanned to determine names of APIs used. Behavior flags are set if certain conditions occur within the executable file. The APIs determined during emulation and during scanning are compared with a set of known behaviors. A match of the APIs and the known behaviors indicates a high risk of malware. A determination of malware being present is based upon any matches and any behavior flags that are set.

The present invention is applicable to all malicious software or malware that generally causes harm to a computer system provides an effect that is not expected by the user is undesirable illegal or otherwise causes the user to want to restore their computer system from a time prior to when it was infected by the malware. Malware can be classified based upon how is executed how it spreads or what it does. The below descriptions are provided as guidelines for the types of malware currently existing these classifications are not perfect in that many groups overlap. For example commercially available anti virus software is designed to scan a computer for viruses and worms as well as other malicious software. Of course later developed software not currently known may also fall within the definition of malware.

When computer viruses first originated common targets were executable files and the boot sectors of floppy disks later targets were documents that contain macro scripts and more recently many computer viruses have embedded themselves in e mail as attachments. With executable files the virus arranges that when the host code is executed the virus code is executed as well. Normally the host program continues to function after it is infected by the virus. Some viruses overwrite other programs with copies of themselves thus destroying the program. Viruses often spread across computers when the software or document to which they are attached is transferred from one computer to another. Computer worms are similar to viruses but are stand alone software and thus do not require host files or other types of host code to spread themselves they can move over the Internet using e mail or socket connections. They do modify the host operating system however at least to the extent that they are started as part of the boot process. In order to execute worms either exploit some vulnerability of the target host or use some kind of social engineering to trick users into executing them. Once executed a computer worm might drop a backdoor program or a computer virus.

A Trojan horse program is a harmful piece of software that is often disguised as legitimate software. Trojan horses cannot replicate themselves unlike viruses or worms. A Trojan horse can be deliberately attached to otherwise useful software by a programmer or can be spread by tricking users into believing that it is useful. Some Trojan horses can spread or activate other malware such as viruses a dropper . An example of a Trojan horse is a program called Gpcoder that encrypts documents spreadsheets and database files on a user s computer. The program then leaves the user a message about how to obtain a program for 200 that would remove the encryption. A wabbit is a third uncommon type of self replicating malware. Unlike viruses wabbits do not infect host programs or documents. And unlike worms rabbits do not use network functionality to spread to other computers. A simple example of a wabbit is a fork bomb.

Spyware is a piece of software that collects and sends information such as browsing patterns or credit card numbers about users and the results of their computer activity without explicit notification. Spyware usually works and spreads like Trojan horses. The category of spyware may also include adware that a user deems undesirable. Sometimes the term spyware is used to refer to more traditional malicious software such as viruses and worms. A backdoor is a piece of software that allows access to the computer system by bypassing the normal authentication procedures. There are two groups of backdoors depending upon how they work and spread. The first group work much like a Trojan horse i.e. they are manually inserted into another piece of software executed via their host software and spread by the host software being installed. The second group work more like a worm in that they get executed as part of the boot process and are usually spread by worms carrying them as their payload. The term ratware has arisen to describe backdoor malware that turns computers into zombies for sending spam.

An exploit is a piece of software that attacks a particular security vulnerability. Exploits are not necessarily malicious in intent they are often devised by security researchers as a way of demonstrating that vulnerability exists. They are however a common component of malicious programs such as network worms. A root kit is software inserted onto a computer system after an attacker has gained control of the system. Root kits often include functions to hide the traces of the attack as by deleting logged entries or by cloaking the attacker s processes. Root kits might include backdoors allowing the attacker to easily regain access later or to exploit software to attack other systems. Because they often hook into the operating system at the kernel level to hide their presence root kits can be very hard to detect.

Key logger software is software that copies a computer user s keystrokes to a file which it may send to a hacker at a later time. Often the key logger software will only awaken when a computer user connects to a secure web site such as a bank. It then logs the keystrokes which may include account numbers PINs and passwords before they are encrypted by the secure web site. A dialer is a program that replaces the telephone number in a modem s dial up connection with a long distance number often out of the country in order to run up telephone charges on pay per dial numbers or dials out at night to send key logger or other information to a hacker. Software known as URL injection software modifies a browser s behavior with respect to some or all domains. It modifies the URL submitted to the server to profit from a given scheme by the content provider of the given domain. This activity is often transparent to the user.

Another type of malicious software performs extortion on a vast scale such as threatening to take down an Internet web site such as a gambling web site during time sensitive events. An attacker would attempt to shut down an Internet site by using thousands of so called zombie or robot personal computers that have been secretly taken over by malicious software. These computers could be used to simultaneously deluge a web site with incoming messages that would paralyze the web site.

The present invention is suitable for use with a wide variety of types and formats of malware. The below description provides an example of the use of the invention with malware written in the portable executable PE format. As is known in the art the portable executable format is an executable file format used in 32 bit and 64 bit versions of Microsoft operating systems. The portable executable format is a modified version of the UNIX COFF file format. Of course the present invention applies to computer files in other formats as well.

It is realized that certain types of malicious software embed specific kinds of application behavior or strategy within the software itself. For example a Mass Mailer virus will implant itself in an SMTP engine in order to propagate itself. Behavior analysis of the suspect software is based on the software s use of various application programming interfaces API s . The present invention collects information about the API s used as well as using a variety of virus behavior sensors. The present invention implements heuristic rules for detection of malware it can correctly parse and identify unknown new viruses without the need for manual analysis.

As is known in the art an application programming interface API is generally a set of software routines and protocols used by an application program as a means for gaining access to another specific application or to an operating system. An API allows an application program to request and carry out lower level services implemented by a computer s operating system.

In this example the suspect computer file is in the PE format and is an executable file or .exe file. The suspect computer file may originate from a wide variety of locations. By way of example the suspect computer file may arrive as an e mail attachment as a file on a medium such as a computer disk or by being downloaded using a protocol such as FTP or HTTP.

Also available to the scan engine are numerous flags data structures tables and rules that assist with determining whether a suspect computer file contains malware or not. In one embodiment this information is stored in a single file called a Rule file although the information may be stored in separate locations as well. described below shows various malware behavior flags that might be set. shows the Rule file header that contains information and flags used by the scan engine to process a suspect computer file. Fields and are not used in the present invention.

Field is set to disable malware detection by pattern when the present invention is in use so that no false positives are generated. Fields are used to turn on or off use of the malware behavior flags . When the scan engine reads a pattern the scan engine will also receive header . Through use of these flags a service engineer can turn on or off their functionalities if any serious false positives develop related to those flags.

In step the suspect computer file is loaded into the scan engine using a PE Loader function the PE header of the suspect file is analyzed in order to obtain the relevant data from the header. For example the results of this step include obtaining the section information the program entry point the import table data entry and the image base.

Due to backwards compatible issues DOS .exe file headers can be found in front of the PE header. The DOS .exe header starts from the signature MZ that contains four bytes. Following this value is the PE header starting from the signature PE . The PE loader uses this information to determine the entry point of the PE header. Following the PE signature are fields describing the entry point number of sections and other resources. For example the PE loader retrieves the fields such as PE header signature number of sections entry point image base import table RVA and import table size. These fields will be used later during execution of the scan engine.

In step the scan engine begins execution and analysis of the suspect computer file. As mentioned earlier the scan engine is a virtual machine that emulates a CPU. The virtual machine begins parsing binary code of the suspect computer file from its entry point the entry point being calculated using the PE Loader function. Upon execution the virtual machine analyzes the binary code of the computer file translates this binary code into instructions fetches instructions from the code one by one and executes these instructions. The virtual machine also uses data previously obtained from the header in step to implement these instructions. In one particular embodiment the virtual machine follows a standard Intel format for the instructions e.g. and Intel x86 specification.

In one optional embodiment of the present invention an optimization is implemented whereby the virtual machine implements and analyzes a first subset of all the instructions encountered in order to determine if that subset of instructions shows a recognizable virus signature. For example the virtual machine may look at the first 120 instructions.

 Excluding API if the suspect file contains the API it is set then the algorithm will ignore the scan result. Mail represents the APIs related to e mail operations. Profile I O represents APIs that write or read profiles from the operating system. System Information represents the APIs that access system information. Resource represents the APIs that read from the system or write to resources in the system. Console Mode represents the APIs related to the console mode program. Mutex represents the APIs related to mutex object operations. Memory Allocate represents the APIs related to allocating memory from the system. Environment Strings I O represents the APIs that read write the environment string from the operating system. Critical Section I O represents the APIs related to critical section object operations. Timer I O represents the APIs that can be access timer object I Os. Shall Execute represents the APIs related to the shall operation. Net I O represents the APIs related to accessing the Internet or sockets. Net Search represents the APIs that can be search objects in the network. Service I O represents the APIs related to read write service from the operating system. Service Search represents the APIs that can enumerate a service from the operating system. Registry I O represents the APIs related to registry key read write in the operating system. Registry searching represents the APIs that can query registry keys from the operating system. Process I O represents the APIs that can read write processes from the operating system. Process Search represents the APIs that can enumerate processes from the operating system. API Searching represents the APIs that can query an API. Load Library represents the APIs that can load specified libraries. Set Get File Attribute represents the APIs can be set get file attributes. File directory I O represents the APIs related to the file system I O. Directory File searching represents the APIs that can search files folders from the file system. Get Version represents the APIs that can get versions of the operating system.

Thus each hexadecimal value for a rule in the rule set defines the possible behavior of a particular malicious software program by setting bits in the hexadecimal word that correspond to API types that the software typically uses. Creation of the rules in the rule set may be performed in any suitable manner. By way of example a service engineer or other expert in computer virus or worm analysis is able to analyze malicious software and to determine which API types the malicious software uses.

When the variable Dynamic Behavior is compared to each rule in the rule set an exact match indicates that the suspect computer file is exhibiting exactly the behavior that known malicious software exhibits.

A first phase of the virtual machine performs a dynamic analysis of the suspect computer file. Step is a dynamic scan in that the API behavior for the suspect computer file is monitored dynamically as each instruction is executed in the virtual machine. For example instructions such as CALL and JMP are monitored to determine which memory address is being accessed. As each instruction makes a call to a software routine using an API the present invention operates to analyze the memory address utilized to determine if the address is a pointer to a dynamic link library DLL . For example the virtual machine checks to see if the memory address is located in the import table or not. Once it is determined that a software routine is being called the routine name or API name is determined using the DLL.

Next the API name is checked to see if it is present in the API List of the Rule file. If so a count corresponding to that particular API type is noted. Determination of an API type based upon the API name string is further described in .

More specifically the import table is used to determine an API name. The import table is a table that contains all of the API names and addresses of the corresponding DLL and is generated by the compiler. From the import table the import directory entry can be determined. Many import directories may be present each including 20 bytes. Each directory corresponds to a single import DLL. The virtual machine keeps track of these import directories while emulating the 32 bit instructions. The virtual machine uses the memory address following each instruction to determine a corresponding API name stored in the suspect file.

The scan engine keeps track of which API types are utilized by the suspect computer file in the course of emulating each instruction in the virtual machine. For example the scan engine keeps track of which API type is used at least once by the suspect computer file. Keeping track of or counting these API types may be performed in any suitable manner. In one particular embodiment a 32 bit dynamic API behavior count variable named Dynamic Behavior is used to keep track of the API types used. The initial value of this variable is zero. Once an API name is determined by the virtual machine as being utilized by the suspect computer file it is compared to the API names in the API list. If there is a match then a bit wise OR is performed with the API type and the Dynamic Behavior variable. In this fashion the Dynamic Behavior variable keeps track of which API types are being utilized by the suspect file.

For example if the virtual machine determines that an API having the name FindFirstFileA is used by the suspect file it is determined that its API type is 0x0001. Performing a bit wise OR with the variable Dynamic Behavior initially having a value zero results in Dynamic Behavior 1. This variable now indicates that the suspect computer file exhibits the specific behavior of seeking files. Each time that the virtual machine detects usage of a particular API name the virtual machine determines the corresponding API type and performs the OR operation with the current value of the variable Dynamic Behavior. In this fashion the variable keeps a running tally of all the different types of suspect APIs that the suspect computer file is utilizing.

Once the dynamic behavior variable has been determined it is stored for later comparison to the rule set in step . The format of a rule set is described above with reference to .

Determining whether particular conditions occur during execution of the suspect computer file also occurs during the dynamic scan. As mentioned above the malware behavior flags of are set or reset according to the following analysis.

Flag is set during instruction emulation if the virtual machine determines that a combination of instructions in the suspect computer file has exhibited Ring calling behavior.

The virtual machine first notes if the instructions PM or MSW are executed and keeps a notation if so. Next if either the instruction INT n or ESC is executed this behavior constitutes a Ring calling behavior and the flag is set.

Flag is set if upon loading of the suspect computer file it is determined that the entry point is found within the last section. In other words while the virtual machine is emulating the first instruction it is determined whether the entry point is located in the latest section or not. If so then flag is set.

Flag is set if during execution of the instructions in the virtual machine it is determined that the suspect computer file is reading data from kernel32.dll in memory. Flag is similar to the previous flag in that it is dependent upon an instruction reading from kernel32.dll in memory. But this function more precisely determines whether or not the address is within the export table. If so then flag is set. Flag is set if the virtual machine generates a dump buffer but no virus signature was found in the first subset of instructions. In other words this flag signals whether the suspect computer file has attempted to decode data from memory. Flag is another mechanism used to determine whether the suspect computer file has attempted to decode data from the stack. If the virtual machine has dumped this data then flag is set. Flag is set or reset during operation of the PE Loader. When the PE Loader is processing the import directory from the suspect file flag will be set if the PE Loader cannot find the end of the import directory. If the suspect computer file has a relocation table the next function will check the relationship between the data in the relocation table and the instructions. If any inconsistencies are found then flag is set.

Once step has finished step operates to perform a static scan of API behavior. As is known in the art an executable file and in particular an executable file in PE format stores API names within its code. A file in PE format stores API names in an import table. Step scans this import table and retrieves all of the API names present. Similar to step these API name strings are then mapped to API types and a corresponding static API Static Behavior variable is created. shows a variable Static Behavior word and its corresponding hexadecimal value . In this simple example the import table contains the API name strings FindFirstFileA FindNextFileA and Write File. The first two strings correspond to the Directory File Searching type and the third string corresponds to the File Directory I O type. The respective bits bit and bit are then set in the variable Static Behavior. Thus Static Behavior for this static scan of API behavior represents API types used by the suspect computer file that might be an indication that the file is malware.

The advantage of static API analysis is that it is fairly simple to get all of the APIs used. Because some malicious software might attempt to hide the API information from an import table analysis it is useful to also perform a dynamic analysis as described above. The advantage of a dynamic analysis is that it can determine the exact API behavior during a run time emulation.

Step is a decision step that determines whether the suspect computer file is malware depending upon various inputs. Input is the Dynamic Behavior variable the Static Behavior variable and the various malware behavior sensor flags shown in . If step determines that malware is present than it is able to send out a malware alert message.

First both the Dynamic Behavior and the Static Behavior variables are compared against each rule in the rule set to determine if there is a match. Existence of a match is evidence of high risk behavior and the suspect computer file is treated as possible malware. The result from the dynamic analysis has higher priority than the result from static analysis therefore even if there is no match for the Static Behavior variable a match for the Dynamic Behavior variable will still indicate the presence of malware.

Other high risk behaviors that indicate the presence of malware include flag is set flag is set flag is set and flag is set flag flag or flag is set and flag is set. Of course other permutations of malware behavior flags being set and rules being matched by either of the behavior variables can also indicate that the suspect computer file is likely to be malware.

If step determines that the suspect computer file is likely to be malware then in step an alert message is sent by the scan engine. The scan engine will then send an appropriate alert to the corresponding software product that can then alert the user. If step determines that there is no risky behavior present and thus the suspect computer file is not likely to be malware then in step the scanning will end.

CPU is also coupled to a variety of input output devices such as display keyboard mouse and speakers . In general an input output device may be any of video displays track balls mice keyboards microphones touch sensitive displays transducer card readers magnetic or paper tape readers tablets styluses voice or handwriting recognizers biometrics readers or other computers. CPU optionally may be coupled to another computer or telecommunications network using network interface . With such a network interface it is contemplated that the CPU might receive information from the network or might output information to the network in the course of performing the above described method steps. Furthermore method embodiments of the present invention may execute solely upon CPU or may execute over a network such as the Internet in conjunction with a remote CPU that shares a portion of the processing.

In addition embodiments of the present invention further relate to computer storage products with a computer readable medium that have computer code thereon for performing various computer implemented operations. The media and computer code may be those specially designed and constructed for the purposes of the present invention or they may be of the kind well known and available to those having skill in the computer software arts. Examples of computer readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs and holographic devices magneto optical media such as floptical disks and hardware devices that are specially configured to store and execute program code such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer code include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Therefore the described embodiments should be taken as illustrative and not restrictive and the invention should not be limited to the details given herein but should be defined by the following claims and their full scope of equivalents.

