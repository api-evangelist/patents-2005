---

title: Uniform resource discovery with multiple computers
abstract: Data associated with a function instance corresponding to a resource on one computer system is published for use on another computer system. A function instance is created on the other computer system using the published data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07467384&OS=07467384&RS=07467384
owner: Microsoft Corporation
number: 07467384
owner_city: Redmond
owner_country: US
publication_date: 20050502
---
This application is a continuation in part of U.S. patent application Ser. No. 11 060 912 filed on Feb. 18 2005 U.S. patent application Ser. No. 11 061 268 filed on Feb. 18 2005 U.S. patent application Ser. No. 11 060 913 filed on Feb. 18 2005 and U.S. patent application Ser. No. 11 061 291 filed on Feb. 18 2005 each of which claims the benefit of U.S. Provisional Application 60 546 671 filed Feb. 20 2004 this application also claims the benefit of U.S. Provisional Application 60 567 558 filed May 3 2004 all of the aforementioned applications are hereby incorporated herein by reference.

Modern computer systems use a wide array of resources implemented in both hardware and software such as printers files software components and the like. Each type of resource generally has its own interface for programmatic enumeration as well as its own interface for general programmatic access. For example enumerating the devices capable of producing audio output often requires using different interfaces depending on how the audio output devices are connected to the computer system. Furthermore accessing the same type of resource on another computer system connected via a network often requires the use of yet other interfaces for programmatic enumeration and access. This is troublesome for a wide variety of applications including those that want to provide a unified view of and access to disparate types of resources independent of resource type or manner of connection.

Described herein are various technologies and techniques directed to the discovery and use of computer resources on a single computer system and on multiple computer systems connected by a network. More particularly described herein are among other things systems methods and data structures that facilitate the discovery of and access to computer resources on a single or multiple computers in a manner that is uniform across disparate types of resources using a publication and subscription model.

Described herein are various technologies and techniques directed to the discovery and use of computer resources on a single computer system and on multiple computer systems connected by a communications medium. More particularly described herein are among other things systems methods and data structures that facilitate the discovery of and access to computer resources on a single or multiple computers in manner that is uniform across disparate types of resources.

Included in the various technologies and techniques described herein is a unique discovery module that enables applications to retrieve information about various resources and access these resources in a uniform manner. In these implementations the application uses the discovery module to request information about or access to one or more resources. In response to the request the application receives one or more function instances each of which is associated with a single resource that satisfies the request. In some implementations the application may also receive notifications when the resources associated with function instances change.

In some implementations function instances are created and used on a single computer system. In other implementations the data associated with function instances created on one computer system is used on another computer system. In such an implementation a computer system that publishes resources for use by publication clients can be called a publication server. A publication server may contain a publication service that uses a discovery module to obtain function instances that the publication service then makes available to one or more publication clients using a communications medium.

Function instances may have various forms and formats. For example in some implementations a function instance is an object that includes or references metadata about its associated resources. In some implementations a function instance also includes or references some information or mechanism that may be used to activate its associated resource. As used herein activation refers to creating or making available a programmatic mechanism such as an API or the like by which an application may access or use a resource.

Regardless of the particular form or format of function instances in accordance with the various implementations described herein function instances will in general have uniform fields which may contain references to resource metadata and activation data and a uniform API enabling users of function instances to interact with function instances in the same manner regardless of the resources represented by the function instances.

In some implementations function instances are created using function instance providers. In these implementations each function instance provider is associated with a given set or type of resources. In these implementations function instance providers also include appropriate mechanisms to enumerate and create function instances for the set or type of resources associated therewith. For example and without limitation one function instance provider may enumerate and create function instances for Universal Plug and Play resources another function instance provider may enumerate and create function instances for Web Service Discovery resources yet another function instance provider may enumerate and create function instances for Simple Service Discovery Protocol resources etc. Furthermore in some implementations a particular function instance provider referred to herein as a subscription provider may enumerate and create function instances using information about resources received using a communications medium.

In some implementations the determination as to which function instance provider is appropriate for which kinds of requested resources is made by a provider management module. In general the provider management module keeps track of the available function instance providers. When a request for function instances is received by the provider management module for example from the discovery module the provider management module then selects an appropriate function instance provider to satisfy the request and sends a request for function instances to the selected function instance provider. The function instance provider then enumerates its associated resources or otherwise queries its resources for information creates one or more function instances to represent resources that satisfy the request and returns the function instances to the provider management module.

In accordance with some implementations a particular type of function instance provider referred to herein as a mapped function instance provider presents function instances from multiple other function providers in a uniform manner using configurable categories. Function instances provided by a mapped function instance provider may be referred to more specifically as mapped function instances.

As noted above in some implementations each function instance includes or references metadata for its associated resource. In some implementations applications may access this metadata to obtain an API with which they can interact and control the resource associated with the function instance.

In some implementations a function instance enables an application to obtain an API for the associated resource in a manner independent of the resource and function instance. In one such implementation an application may request that a function instance activate a specific API. As a result of such a request data associated with the function instance may be used to create the requested API.

In some implementations in the case where a particular mapped function instance represents another mapped function instance a function instance provider may present function instances that support activating multiple APIs. In this implementation a mapped function instance that represents other mapped function instances may support activating APIs for the function instance it represents and also support activating APIs for the underlying function instances.

Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Tasks performed by the program modules are described below with the aid of block diagrams and operational flowcharts.

Those skilled in the art can implement the description block diagrams and flowcharts in the form of computer executable instructions which may be embodied in one or more forms of computer readable media. As used herein computer readable media may be any media that can store or embody information that is encoded in a form that can be accessed and understood by a computer. Typical forms of computer readable media include without limitation both volatile and nonvolatile memory data storage devices including removable and or non removable media and communications media.

Communication media embodies computer readable information in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communications media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

Turning now to in its most basic configuration the computing device includes at least one processing unit and memory . Depending on the exact configuration and type of computing device the memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line . Additionally the computing device may also have additional features functionality. For example the computing device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by the removable storage and the non removable storage .

The computing device may also contain communications connection s that allow the device to communicate with other devices. The computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included in the computing device .

Those skilled in the art will appreciate that the technologies described herein may be practiced with computing devices other than the computing device illustrated in . For example and without limitation the technologies described herein may likewise be practiced in hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like.

The technologies described herein may also be implemented in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

While described herein as being implemented in software it will be appreciated that the technologies described herein may alternatively be implemented all or in part as hardware firmware or various combinations of software hardware and or firmware.

Turning now to illustrated therein is a system in which uniform resource discovery may be carried out. Included in the system are an application a function discovery module and a number of resources . Generally the application may be any program process or the like that is operable to interact with or control the function discovery module and or one or more resources. In general a resource may be any hardware software or combination of hardware and software that provides functionality to the application.

In accordance with one implementation the application is a program that displays a graphical representation of available resources. However those skilled in the art will appreciate that the application can be any process that is operable to communicate with or make use of any resources for any purpose.

Included in the function discovery module is a discovery interface module a provider management module a number of providers and a mapped function instance provider . Also included in the function discovery module are mapped function instance provider data and provider management data .

In general the discovery interface module is a programmatic entity that provides functionality to receive requests from an application and also includes various routines operable to handle the requests. In some implementations the discovery interface module is operable to communicate with the provider management module to retrieve function instances in response to application requests.

For example and without limitation in accordance with one implementation the discovery interface module comprises an API that includes methods that enable an application to request function instances for specified resources. In response to such a request the discovery interface module communicates with the provider management module to retrieve function instances that represent the requested resources.

In general the provider management module is a programmatic entity that accepts requests for function instances from the discovery interface module . In some implementations as described below the provider management module uses the provider management data and the one or more providers and to retrieve function instances which the provider management module then returns to the discovery interface module .

For example and without limitation in accordance with one implementation the provider management module comprises executable code that responds to requests from the discovery interface module by identifying a provider using information such as the provider management data and the information included with the request. If a provider that can service the request is found the provider management module requests that the identified provider supply a set of function instances according to the request from the discovery interface module .

In general in one implementation the providers are programmatic entities that receive requests for function instances from the provider management module . In response to a request from the provider management module a provider enumerates or queries the resources with which it is associated and creates and returns corresponding function instances to the provider management module. In some implementations providers might also support activation of application programming interfaces.

In accordance with various implementations described herein each provider is associated with a predefined set or type of resource. For example and without limitation one function instance provider may be associated with Universal Plug and Play resources another function instance provider may be associated with Web Service Discovery resources yet another function instance provider may be associated with Simple Service Discovery Protocol resources etc. Providers may also be associated with multiple resources of varying types.

The particular manner in which a provider enumerates and creates function instances may be dependent on the type of resources with which it is associated. For example in the case where a provider is associated with Plug and Play resources upon receipt of a request for a function instance or function instances the provider module may use a Plug and Play specific API to enumerate its associated Plug and Play resources. The provider module may then create and return function instances that represent the Plug and Play resources.

In some implementations the providers and can be supplied by parties other than the party or parties providing the function discovery module .

In general the mapped function instance provider is a particular implementation of a provider that supports the creation of mapped function instances. As used herein a mapped function instance is a function instance that is associated with at least one other function instance.

The mapped function instance provider receives requests for function instances from the provider management module . In response it creates and returns mapped function instances and in some implementations does so using data from the mapped function instance provider data . In some of these implementations the mapped function instance provider data defines mapped function instances and specifies categorization and activation information for such mapped function instances.

For example and without limitation in accordance with one implementation the mapped function instance provider provides a category that supplies a single set of function instances for resources that output audio but are of different underlying types. For example and without limitation this category could include Plug and Play audio hardware and Universal Plug and Play media renderer devices. In some implementations this category information is associated with the mapped function instance provider data .

In general the mapped function instance provider data contains data associated with the mapped function instance provider . For example and without limitation in accordance with one implementation the mapped function instance provider data may include a hierarchical set of nodes in a configuration data store e.g. the registry in various versions of the Windows operating system from Microsoft Corporation of Redmond Wash. . In addition the mapped function instance provider data may include one or more Extensible Markup Language XML fragments in particular nodes where the nodes represent mapped function instance categories and the XML fragments contain information associated with mapped function instances.

In general the provider management data contains data associated with the provider management module . For example and without limitation in accordance with one implementation the provider management data is a set of XML fragments that contain information associated with function instance requests and providers .

It will be appreciated by those skilled in the art that the discovery interface module the provider management module and the various providers and may be implemented using various object oriented or non object oriented technology. The selection of one or another type of object oriented or non object oriented technology is a matter of choice and is often determined by such things as the underlying operating system etc.

However in accordance with some implementations one or more of the discovery interface module the provider management module and the various providers and are implemented as objects that conform to the Microsoft Component Object Model COM specification. The COM specification defines binary standards for objects and their interfaces which facilitate the integration of software components into applications.

Turning now to shown therein is a generalized representation of a function instance . The following description of is made with reference to the system of . However it should be understood that the function instance described with respect to is not intended to be limited to being used by or interacting with elements of the system .

In general a function instance represents a resource either directly e.g. by referencing the resource directly or indirectly e.g. by referencing another function instance . Function instances may be used throughout the system to represent and transfer resource and other function discovery information. For example the provider management module may retrieve function instances from providers and provide function instances to the discovery interface module which provides function instances to the application .

A function instance may be implemented as an object in an object oriented environment and embodied in a computer readable medium or media. However it should be understood that the functionality described herein with respect to a function instance object can also be implemented in a non object oriented fashion and can be implemented on many types of systems both object oriented and non object oriented.

As shown the function instance includes a unique identification field a resource metadata field and an activation data field . Additionally in some implementations the function instance implements a function instance interface . The interface defines a set of methods that any function instance object may implement.

In the implementation of the function instance shown in these methods implemented include a get unique identifier method that retrieves data referenced by the unique identification field a get resource metadata method that retrieves data referenced by the resource metadata field and a function instance activate method that activates the function instance.

It should be understood that in some implementations the information returned by the methods may be made available directly by means such as and without limitation public object properties. In such implementations the corresponding method may not be necessary. For example if the unique identification field can be retrieved by accessing the field directly then the get unique identifier method would not be necessary. Additionally the methods may be made available directly and without the use of an interface.

The unique identification field contains data that in some implementations uniquely identifies the function instance in a system on which the function discovery module is executing. Furthermore the unique identification field remains constant even when the function discovery module or system is stopped and restarted. Therefore once an application retrieves the unique identification value for a particular function instance the value can be stored and later used to locate that function instance and thereby a particular resource.

The resource metadata field contains data specific to the particular resource represented by the function instance. In one implementation the metadata may comprise a key value table . In this table the keys contain identifiers that identify the information in a particular key value pair. For example and without limitation there may be a Friendly Name key or a Manufacturer key . The value associated with a particular key contains the information described by the key. For example and without limitation the value associated with the Friendly Name key could be Primary sound card while the value associated with the Manufacturer key could be Company Name Inc. 

Regardless of the way in which the resource refers to a particular piece of metadata in some implementations the resource metadata field identifies the metadata in a consistent manner through the use of standard keys . For example a particular resource may make its friendly name accessible using a resource specific property called Name while another resource may make its friendly name accessible using a method called GetMyCommonName. In both cases the resulting metadata could be represented in the function instance resource metadata using the same key for example and without limitation using a Friendly Name key .

It should be noted that the metadata represented by the key value table is not limited in any way to particular data. Furthermore the key value table can be implemented using many data structures. Finally the key value table does not necessarily comprise the entirety of the resource metadata accessible using the function instance.

When called the get resource metadata method returns the data represented by the resource metadata field . As discussed previously this method may not be necessary or required if the resource metadata is available through other means such as through the use of a public property.

The activation data field includes or references information that may in some implementations be used by the function instance when an application requests activation of the function instance. In one implementation the activation data field may include or reference function instance provider data that identifies the provider of the function instance. In the same or other implementations the activation data field may include or reference an activation data table that contains references to application programming interfaces or interfaces that can be requested by an application and references to corresponding factories that can create entities that implement the requested interface. In one implementation references to the interfaces are stored in an interface column and references to the factories are stored in a factory column . When an application requests activation from a function instance it submits with the request an interface that the entity returned by the function instance may support.

In one implementation including an implementation that does or does not include an activation data table the function instance provider data may be used to identify the provider of the function instance. In some implementations the provider may be queried to determine if it supports activating the interface requested by the application and may be relied upon to create an instance of an entity that supports the requested interface.

In the same or another implementation the activation data table included in or referenced by the activation data field may be examined for an entry that contains the requested interface. If the interface exists the corresponding factory may be used to create an entity that supports the requested interface. This entity is then returned to the application that requested the activation. For example an application may request an activation and specify the Foo interface . If the Foo interface exists in the activation data table the corresponding Foo factory is used to create an entity that implements the Foo interface.

In the same or another implementation the requesting application may supply or reference with the request a factory that may be able to activate the requested interface. In such an implementation the function instance provider data and activation data table may or may not be necessary for the purposes of activating the function instance.

It should be understood that while the terms interface and factory are often associated with object oriented environments the functionality enabled by the activation data field is not limited to any particular environment or system and can also be implemented in non object oriented systems. Furthermore the activation data table can be implemented using many data structures. Finally the function instance provider data and activation data table do not necessarily comprise the entirety of the activation data used or maintained by the function instance .

In some implementations the function instance activate method uses activation data associated with the function instance or provided in the activate request to activate the function instance ultimately returning an entity that supports the requested interface. As was explained previously an implementation of the activate method may use function instance provider data to identify a provider which may then activate the function instance it may use interface and factory data in an activation data table to identify a factory which may then activate the function instance it may use a factory included or referenced in the activate call or it may activate the function instance through other means. Also as discussed previously this method may not be necessary or required if the activation data included in or referenced by the activation data field is available through other means such as through the use of a public property.

Turning now to shown therein is a generalized representation of an API layer . In some implementations an API layer may be a data structure embodied in a computer readable media or medium. The following description of is made with reference to the system of the function instance and the activation data table of and the tree structure of . However it should be understood that the API layer described with respect to is not intended to be limited to being used by or interacting with elements of the system the function instance and the activation data table or the tree structure .

In accordance with some implementations the mapped function instance provider uses some number of API layers and a tree structure such as the tree structure to enable enhanced categorization and activation of function instances. An API layer represents the information that may be used by the mapped function instance provider to retrieve function instances in a particular category and also to enable activation of the retrieved function instances. Some implementations may not support all functionality or include all data identified by the exemplary API layer . For example and without limitation one implementation may include only information necessary for enhanced categorization of function instances and may not include information necessary for activation of function instances. In such an implementation activation may be supported through other data and means outside of the API layer . Finally in one implementation the API layers and tree structure are stored in the mapped function instance provider data .

The API layer illustrated in includes a category of underlying function instance s field a subcategory of underlying function instance s field a filter criteria field a supported interface field and a factory field .

If present in the API layer the category and subcategory of underlying function instance s fields and may represent the category from which the function instances returned by this API layer originate. The mapped function instance provider might not create any function instances that directly reference a resource . Instead the mapped function instance provider may create function instances that map to other function instances including function instances created by a provider or function instances created by the mapped function instance provider .

The category and subcategory of underlying function instance s fields and specify the base set of function instances returned using the API layer before any filtering performed using the filter criteria field . For example and without limitation an API layer called Audio Endpoints Local might contain the necessary category and subcategory to specify a set of function instances that directly map to sound hardware on the local computer system.

If present in the API layer the filter criteria field may contain or reference data by which the set of function instances returned using the API layer is filtered. For a function instance to be specified by an API layer it may be identified by the category and subcategory of underlying function instance s fields and and may also meet the filter criteria specified in this field if any filter criteria information is provided.

Filter criteria can include for example and without limitation particular values of resource metadata properties as well as supported application programming interfaces. For example filter criteria for audio hardware might indicate that a resource metadata property named Device Type has the value Audio Hardware and that the function instance supports the Audio application programming interface.

If present in the API layer the supported interface field may contain the application programming interface supported by the function instances returned using this API layer . Alternatively the supported interface field may contain no supported application programming interface in which case the API layer does not in and of itself support activation although activation may still be supported through other data or means.

In some implementations the data in or referenced by the supported interface field populates a portion of the interface column of the activation data table referenced by a function instance . In these cases because the data exists in or is referenced by the interface column during activation in some implementations the data originating in the supported interface field is used as part of the process that determines if the function instance supports a requested interface.

If present in the API layer the factory field may identify a factory entity that creates entities that support the interface specified in the supported interface field . Alternatively if no such factory exists the factory field may not identify a factory. As with the data in or referenced by the supported interface field in some implementations the data in or referenced by the factory field populates a portion of the activation data table referenced by a function instance .

In some implementations the data in or referenced by the factory field populates a portion of the factory column of the activation data table . Because the data exists in or is referenced by the factory column during activation the data originating in the factory field is used as part of the process that determines the factory entity that can create an entity that supports the requested interface.

Turning now to shown therein is a generalized representation of a tree structure which specifies categories and subcategories used by the mapped function instance provider . The following description of is made with reference to the system of the function instance and the activation data table of and the API layer of . However it should be understood that the tree structure described with respect to is not intended to be limited to being used by or interacting with the system the function instance and the activation data table or the API layer .

The tree structure represents a conceptual model of the category and subcategory relationships that can be used by the mapped function instance provider . The tree structure includes a root category associated with the mapped function instance provider and some number of subcategories .

The subcategories may be organized in a hierarchical manner as is shown in the diagram but are not limited to this structure and may be organized in any other structure including but not limited to a flat list. If the subcategories are organized in a hierarchical manner a single subcategory may commonly be referred to using a notation such as but not limited to the following Subcategory A Subcategory B Subcategory C. This notation would locate subcategory C as a descendant of subcategory B which is in turn is a descendant of subcategory A.

When an application requests function instances from the discovery interface module and specifies the mapped function instance provider the mapped function instance provider uses any provided subcategory information to locate the specified node in the tree structure . Once the specified node has been located the function instance provider uses any API layers associated with that node to generate function instances .

A node may have zero or more API layers . If no API layers exist for a given node then in some implementations no function instances are returned when that node is specified in a request for function instances. A node may have multiple API layers . If multiple API layers are specified then in some implementations the set of function instances returned consists of function instances from all specified API layers.

An application may request that function instances should be returned from the node specified by the subcategory information as well as all nodes descended from the specified node. In this case the API layers in the specified node and all descendant nodes are used to create function instances.

Turning now to illustrated therein is a system in which publication of and subscription to function instances can be carried out. Included in the system are a number of publication servers and a number of publication clients and and a communications medium . The following description of is made with reference to the system of and the function instance of . However it should be understood that the system described with respect to is not intended to be limited to being used by or interacting with elements of the system or the function instance .

Generally a publication server may be any system that is operable to publish the data associated with function instances said data to be used by one or more publication clients . In general a publication client may be any system that is operable to use data published by one or more publication servers . As defined herein the term publish refers to making some or all of the data associated with a function instance available. Similarly the phrase publishing a function instance refers to making some or all of the data associated with the function instance available.

In accordance with one implementation the publication servers and are linked to each other and to the publication clients and by a communications medium that functions to enable the publication servers and publication clients to communicate. For example and without limitation the communications medium may be a wired network or a wireless network or a combination of wired and wireless networks. Furthermore one or more publication servers and one or more publication clients can reside on the same physical computer in which case the communications medium may also include one or more forms of intra computer communication channels such as inter process calls or messages.

Included in the publication server are a function discovery module a publication service a number of resources and a number of publication applications .

In general the publication service is a program process or the like that publishes some or all of the information associated with certain resources to publication clients . In some implementations the publication service uses the function discovery module to obtain function instances that represent resources from which it obtains data to publish to publication clients. The publication service may also provide notifications to publication clients when the function instances it has published change. It may also notify clients when new function instances are available or when published function are no longer usable or accessible or should no longer be published. Also in some implementations the publication service responds to requests from publication clients for information about the function instances it has published.

For example and without limitation in accordance with one implementation when the publication service starts perhaps and without limitation because the computer on which it is installed has started it queries the function discovery module and obtains the set of function instances that should be published. The publication service may then send a publish message for each function instance using a network or other communication protocol or service like for example and without limitation the Web Service Discovery protocol. In another implementation the publication service may send a single publish message with information about all of the function instances. In another implementation the publication service may send more than one publish message but fewer publish messages than the number of function instances. The publication service may then monitor or receive notifications about the set of function instances it has published and notify publication clients when a function instance changes possibly by sending a new publish message with updated data associated with the changed function instances. The publication service may also send new publish messages when new function instances are available and may send unpublish messages when function instances should no longer be published. When the publication service stops executing perhaps and without limitation because the computer on which it is installed is shutting down it may send an unpublish messages for each function instance it is currently publishing to notify publication clients that the associated resource is no longer available through that particular publication service. In another implementation the publication service may send a single or some other number of unpublish messages for the function instances that are currently published.

In general the function discovery module is similar or identical to the function discovery module of . In other implementations it may not be similar or identical. The mapped function instance provider and mapped function instance provider data may be in accordance with one implementation used by a publication server to assist in identifying the function instances to be published.

The mapped function instance provider and mapped function instance provider data may be similar or identical to the mapped function instance provider and mapped function instance provider data of . In other implementations they may not be similar or identical. In accordance with one implementation the mapped function instance provider data may store information about the function instances to publish. The mapped function instance provider when queried for the set of function instances to publish obtains information from the mapped function instance provider data . As is the case with other mapped function instances which reference other function instances the function discovery module then queries for additional function instances that ultimately represent actual resources.

In general the resources are similar or identical to the resources of . In other implementations they may not be similar or identical.

In general a publication application is any program process or the like that wants to publish resources using the publication service . In some implementations the publication application may indicate that resources should be published by interacting with the function discovery module . Any given publication server may have one or more publication applications.

For example and without limitation in accordance with one implementation the publication application may use an API provided by the function discovery module to specify the function instances to be published. The function discovery module then uses these function instances when it is queried by the publication service to determine the function instances to publish. In accordance with one implementation the publication server may use the mapped function instance provider and mapped function instance provider data to maintain the set of function instances to publish. In this implementation the publication application may add or remove from the set of function instances to publish by creating or deleting mapped function instances by interacting with the function discovery module using a function discovery module API or by modifying the mapped function instance provider data directly.

In general the application is a program process or the like that is operable to interact with or control the function discovery module and or one or more of the resources made accessible through the function discovery module using function instances including resources published by a publication server .

In accordance with one implementation the application may be a program that displays a graphical representation of available resources. However those skilled in the art will appreciate that the application can be any process that is operable to communicate with or make use of any resources for any purpose.

In general the function discovery module is similar or identical to the function discovery module of . In other implementations it may not be similar or identical. As defined herein the function discovery module is operable to obtain information from one or more publication services which it then uses to create function instances . The function discovery module is also described in additional detail below with reference to .

Turning now to illustrated therein is one implementation of a system that receives function instances published by publication servers. Included in the system are a publication client and a number of publication servers and . The following description of is made with reference to the system of the function instance of and the system of . However it should be understood that the system described with respect to is not intended to be limited to being used by or interacting with elements of the system the function instance or the system .

As explained previously with reference to the publication client is linked to one or more publication servers and by a communications medium .

Also as explained previously with reference to the publication servers and publish data associated with selected function instances that are accessible from the publication server.

Included in the publication client are a function discovery module an application and other resources .

As explained previously with reference to the application is any program process or the like that is operable to interact with or control the function discovery module and or one or more of the resources made accessible through the function discovery module using function instances including resources published by a publication server and other resources on the same computer system.

Included in the function discovery module are a discovery interface module a provider management module one or more subscription providers and other providers . Also included in the function discovery module is mapped function instance provider data .

In general the discovery interface module is a programmatic entity that provides functionality to receive requests from an application and also includes various routines operable to handle the requests. In some implementations the discovery interface module may be similar or identical to the discovery interface module of . In other implementations it may not be similar or identical.

In general the provider management module is a programmatic entity that accepts requests for function instances from the discovery interface module and in some implementations uses providers and to retrieve function instances which it then returns to the discovery interface module . In some implementations the provider management module may be similar or identical to the provider management module of . In other implementations it may not be similar or identical.

In general the mapped function instance provider is a particular implementation of a provider that supports the creation of mapped function instances using in accordance with one implementation the mapped function instance provider data . In some implementations the mapped function instance provider and mapped function instance provider data may be similar or identical to the mapped function instance provider and mapped function instance provider data of . In other implementations they may not be similar or identical.

In general the one or more subscription providers are programmatic entities that receive requests for function instances from the provider management module . In response to a request from the provider management module a subscription provider uses data obtained from one or more publication servers to create and return function instances that satisfy the provider management module s request.

The particular manner in which a subscription provider obtains data about resources and creates function instances may be dependent on the type of resources with which it is associated as well as the nature of the communication with the publication servers from which it obtains resource information. In accordance with one implementation a subscription provider may obtain data about resources by querying publication servers for function instances by unicasting multicasting or broadcasting requests for resources by resource name resource type or any other criteria that serves to categorize resources. In another or the same implementation a subscription provider may obtain resource information by receiving and storing communications that contain resource information initiated by publication servers. In accordance with one implementation the subscription provider may notify the function discovery module when the data associated with function instances it has provided changes. It may obtain knowledge of changes to this data by querying publication servers by receiving notifications of changes from publication servers or by some other means. A subscription provider that receives data about resources published by a publication server may also receive data about resources made available by computers or software processes that are not publication servers.

For example in one implementation and without limitation a subscription provider uses the Devices Profile for Web Services specification or the Web Service Discovery protocol to interact with publication servers and in some implementations with computers or software processes that are not publication servers. Such a subscription provider may obtain data with which it creates function instances by sending a PROBE message with a particular resource type or name and receiving responses from publication servers or other computers or software processes that understand the Devices Profile for Web Services specification or the Web Service Discovery protocol. It may also obtain resource data with which it creates function instances by receiving HELLO messages sent by publication servers or other computers or software processes announcing new resources. The subscription provider of this example may receive information about changes to resources by querying the publication server or other computers or software processes using PROBE messages. It may also receive information about changes to resources by receiving notifications initiated by the publication servers or other computers or software processes using HELLO messages.

In general the other providers are programmatic entities that receive requests for function instances from the provider management module and in response to these requests provide function instances associated with other resources . In some implementations the other providers and other resources may be similar or identical to the providers and resources of . In other implementations they may not be similar or identical.

Turning now to shown therein is generalized operational flow including various operations that may be performed in publishing function instances . The following description of is made with reference to the function instance of and the system of . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the function instance or the system . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

As shown in one implementation of operation the publication service of the publication server queries the function discovery module for a set of function instances to publish. In accordance with the same or another implementation it may also register with the function discovery module to receive notifications when the function instances for which it queries change.

In accordance with one implementation and without limitation the publication service may query for function instances to publish by providing category subcategory and other criteria information that results in the function discovery module using the mapped function instance provider to obtain function instances. In such an implementation the publication application may indicate which function instances are to be published by creating function instances in a category monitored by the publication service.

After receiving the set of function instances to be published in one implementation of operation the publication service sends a publish message for each function instance. This publish message may include but is not limited to the network location of the resource and other information about the resource represented by the function instance. For example and without limitation when the publication service uses the Devices Profile for Web Services specification and the Web Service Discovery protocol the publish message may correspond to a Web Service Discovery HELLO message. In another implementation of operation the publication service may send a single publish message for all function instances. In yet another implementation of operation the publication service may send more than one publish message associated with the function instances.

In one implementation of operation the publication service determines if it should stop execution. In accordance with one implementation and without limitation when the publication service runs as an operating system service the publication service may start execution when the computer starts or stop execution when the computer stops. In other implementations the publication service may start and stop based on user requests or on other criteria or configuration data. In yet other implementations the publication service may exist as part of or be hosted by an application whose lifetime may be controlled by the user or by other criteria or configuration data.

If it is determined in operation that publication service should stop execution the operational flow continues to operation . If it is determined that the publication service should not stop execution the operational flow continues to operation described below.

When it has been determined that the publication service should stop execution the operational flow proceeds to operation . In one implementation of operation the publication service sends an unpublish message for each function instance it has previously published and for which it has not previously sent an unpublish message. For example and without limitation when the publication service uses the Devices Profile for Web Services specification or the Web Service Discovery protocol the unpublish message may correspond to a Web Service Discovery BYE message. In another implementation of operation the publication service sends a single unpublish message for all function instances. In yet another implementation of operation the publication service sends more than one unpublish messages associated with the function instances.

When it has been determined that the publication service should not stop execution the operational flow proceeds to operation . In one implementation of operation the publication service determines if it has received a notification from the function discovery module of a change to one of the function instances it has previously received from the function discovery module. It also determines if it has received notifications from the function discovery module of new function instances to publish possibly because there are new function instances that satisfy the criteria specified in operation or that function instances previously supplied by the function discovery module should no longer be published possibly because they are no longer usable or accessible.

If it is determined in operation that there are new removed or changed function instances the operational flow continues to operation . If it is determined that there are no new removed or changed function instances the operational flow continues to operation described below.

When it has been determined that there are new removed or changed function instances the operational flow proceeds to operation . In one implementation of operation the publication service sends a publish unpublish or change message depending on whether there are new removed or changed function instances. The nature of operation is described in more detail below with reference to and operational flow .

If it is determined in operation that there are no new removed or changed function instances the operational flow proceeds to operation . In one implementation of operation the publication service determines if it has received a request from a publication client for a published resource or resources.

If it is determined in operation that the publication service has received a request for a published resource from a publication client the operational flow continues to operation where a response is sent to the publication client. If it is determined that the publication service has not received a request for a published resource the operational flow proceeds to operation described previously. In accordance with one implementation if the publication service receives a request for a resource that it cannot satisfy using any of the resources it has previously published no response is sent to the publication client. However it will be appreciated by those skilled in the art that in some implementations the publication service may send a response that indicates explicitly that no resources satisfy the request from the publication client.

When it has been determined that the publication service has received a request for a resource it has previously published the operational flow proceeds to operation . In one implementation of operation the publication service responds to the request with information about the previously published resource or resources that satisfy the request from the publication client . This information may include but is not limited to the network location of the resource s that satisfy the publication client s request. For example and without limitation in one implementation the request from the publication client may consist of a Web Service Discovery PROBE message. In this example the response from the publication service may consist of a Web Service Discovery PROBE MATCH message.

It will be appreciated by those skilled in the art that the publication service may only determine if it publishes resources that satisfy a publication client s request in response to an actual request from a publication client instead of determining which resources it publishes before a request. In this case the publication service may respond to a request from a publication client before or instead of sending a notification of published resource. It will also be appreciated that one implementation of this operational flow may use separate operating system or process threads to check for notifications or events. For example and without limitation a thread may exist to receive notifications of changes to function instances another thread may exist to receive requests for published resources and another thread may exist to determine if the operational flow should stop execution.

Turning now to shown therein is a generalized operational flow including various operations that may be performed in responding to a change in published function instances . In particular the operational flow illustrates operations that might be performed by a publication service to carry out the sending operation of operational flow . In one implementation the sending operation is performed when the publication service determines that it has received a notification from the function discovery module of a change to one of the function instances it has previously received from the function discovery module. Operation may also be performed when the publication service determines it has received notifications from the function discovery module either of new function instances to be published or that function instances previously supplied by the function instance should no longer be published possibly because they are no longer usable or accessible.

The following description of is made with reference to the function instance of and the system of . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the function instance or the system . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

As shown in one implementation of operation the publication service determines if the function discovery module has provided notification of new function instances that should be published possibly for example and without limitation because the function discovery module knows of new function instances that satisfy the criteria specified in operation of .

If it is determined in operation that the change is due to new function instances to be published the operational flow proceeds to operation . If the change is not due to new function instances the operational flow continues to operation described below.

When it has been determined that the change is due to new function instances to be published the operational flow proceeds to operation . In one implementation of operation the publication service sends a publish message that may be received by one or more publication clients . In accordance with one implementation and without limitation when the publication service uses the Devices Profile for Web Services specification or the Web Service Discovery protocol the publish message may correspond to a Web Service Discovery HELLO message. In some implementations a new HELLO message may be sent for each new function instance. In other implementations when a new function instance is to be published and other function instances have already been published a HELLO message may be sent with an updated metadata version.

When it has been determined that the change is not due to new function instances to be published the operational flow proceeds to operation where the publication service determines if the function discovery module has provided notification that previously supplied function instances are no longer usable or accessible or for any reason should no longer be used.

If it is determined in operation that the change is due to function instances that should no longer be published the operational flow proceeds to operation . If the change is not due to function instances that should no longer be published the operational flow continues to operation described below.

When it has been determined that the change is due to function instances that should no longer be published the operational flow proceeds to operation . In one implementation of operation the publication service sends an unpublish message that may be received by one or more publication clients . In accordance with one implementation and without limitation when the publication service uses the Devices Profile for Web Services specification or the Web Service Discovery protocol the unpublish message may correspond to a Web Service Discovery BYE message. In another implementation the unpublish message may correspond to a HELLO message with an updated metadata version that reflects the change in published function instances.

When it has been determined that the change is not due to function instances that should no longer published the operational flow proceeds to operation where the publication service determines if the function discovery module has provided notification that previously supplied function instances have changed. For example and without limitation a notification may be raised when a property value associated with a previously supplied function instance has a new value.

If it is determined in operation that the change is due to a change in a previously supplied function instances the operational flow proceeds to operation . If the change is not due to a change in a previously supplied function instance the operational flow ends. In the specific implementation described in operational flow operation should always proceed to operation because all other criteria that caused operational flow to execute have been checked and exhausted.

When it has been determined that the change is due to a change in a previously supplied function instances the operational flow proceeds to operation . In one implementation of operation the publication service sends a change message that may be received by one or more publication clients . In accordance with one implementation and without limitation when the publication service uses the Devices Profile for Web Services specification or the Web Service Discovery protocol the update message may correspond to a Web Service Discovery HELLO message with new data for example and without limitation an updated metadata version that reflects for example and without limitation a changed function instance a change in a function instance or a change in published function instances. In other implementations the change message may correspond to a message type dedicated to communicating changes rather than to a message type like the HELLO message that also communicates the existence of new resources.

Turning now to shown therein is a generalized operational flow including various operations that may be performed in a process that retrieves function instances . The following description of is made with reference to the system of the function instance of the API layer of and the tree structure of . In particular the description of is made with reference to the function discovery module the provider management module a provider and the function instance . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the function discovery module the provider management module a provider or the function instance or to be limited to being associated with the system of the function instance of the API layer of or the tree structure of . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

As shown in one implementation of operation the discovery interface module of function discovery module receives a request for a set of function instances . This request may include but is not limited to a category a subcategory a tree enumeration flag that defines if only the subcategory identified by the category and subcategory information should be searched or if all descendant subcategories should also be searched filter criteria that specifies how the returned function instances should be filtered and whether the requestor should be notified of changes to the function instances after the function instances are returned.

In some implementations the function discovery module dispatches the request to the provider management module . In one implementation of operation the provider management module uses the specified category to identify a provider to service the request for function instances .

The provider management data may contain information that maps categories to providers . A provider generally corresponds to a particular type of resource. For example and without limitation a single provider may correspond to any of the following types of resources Plug and Play resources Universal Plug and Play resources Web Service Discovery resources Simple Service Discovery Protocol resources and software components. Providers may also correspond to any other type of resource. A provider may correspond to resources on the same computer system on which the provider is executing or to resources on other computer systems.

In one implementation of operation the provider selected in operation creates and returns function instances identified in the request. The steps taken by the provider to obtain the information necessary for it to create function instances vary by provider. For example a provider for Plug and Play resources may use an application programming interface specific to interaction with Plug and Play resources to enumerate the resources and retrieve resource metadata information about the resources.

In the case of Plug and Play resources this application programming interface may be the SetupDi application programming interface. SetupDi is an API included with certain versions of the Windows operating system from Microsoft Corporation of Redmond Wash. The SetupDi API enables accessing Plug and Play hardware. In some implementations the mapped function instance provider may use tree structure and API layer data stored in the mapped function instance provider data to create function instances.

In operation in some implementations the function instances created by the provider are returned to the provider management module then to the function discovery module then to the discovery interface module and finally to the application .

It should be noted that the provider may create the function instances and return them to the provider management module or it may return the data necessary to create the function instances and leave the actual creation of the function instances to the provider management module or to the function discovery module .

It should be further noted that the provider may return function instances or data asynchronously from the request for function instances. Also the function instances created by the provider may not be complete that is they might not contain all of the information required to be contained by a function instance. In such cases the function discovery module the provider management module the discovery interface module or another module may supplement the data in the created function instances before the function instances are returned to the requesting application .

In one implementation of operation the function discovery module determines if the processing necessary for this request is complete. In one implementation the processing may be deemed complete if the requesting application did not request to be notified of changes to the function instances after the function instances are returned. In some implementations in contrast if the application did request notification of changes to the requested function instances the function discovery module may need to respond when one of the requested function instances changes and so processing may not be considered complete.

If it is determined in operation that processing is complete the operational flow is finished. If it is determined in operation that processing is not complete operational flow proceeds to operation .

In one implementation of operation the function discovery module determines if a change to the resources represented by the previously created function instance has occurred. The manner in which it determines if a change has occurred may vary depending on both the nature of the resource and the implementation of the function discovery module. For example some resource types may support providing asynchronous notification of changes. Knowledge of changes for other resource types may require that the function discovery module or some other module poll the resource and compare the current state of the resource with the state that existed when the original function instance was created.

If it is determined in operation that a change has occurred the operational flow proceeds to operation . If it is determined that a change has not occurred the operational flow proceeds to operation .

In general in one implementation of operation the function discovery module sends notification of the change identified in operation to the application . The mechanism by which the function discovery module notifies the application may vary. In one implementation the function discovery module may notify the application of the change by using an API implemented by a programmatic entity provided to the function discovery module by the application. In another implementation the function discovery module may send operating system messages to the application. In yet another implementation the application may call an API provided by the function discovery module to determine if changes have occurred.

In addition those skilled in the art will realize that the data provided to the application can be determined in many ways. For example the data may have been provided in an asynchronous callback to the function discovery module it may have been the result of a call from the function discovery module to an API supported by the resource or it may have been obtained through some other means.

Turning now to shown therein is a generalized operational flow including various operations that may be performed to service a request for published function instances. The following description of is made with reference to the system of the function instance of the system of and the system of . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the system the function instance the system or the system . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

As shown in one implementation of operation the discovery interface module receives a request for function instances from an application . In some implementations the application and discovery interface module are similar or identical to the application and discovery interface module of and the nature of the request is correspondingly similar or identical. For example and without limitation the request may include a category a subcategory filter criteria and so on. In some implementations the application and discovery interface module are not similar or identical to the application and discovery interface module .

In accordance with one implementation the request received in operation may directly or indirectly result in use of a subscription provider . In such cases operational flow continues to operation where in one implementation the provider management module queries the subscription provider for function instances that satisfy the request passing any required criteria information to the subscription provider.

In general in operation the subscription provider sends requests to publication servers for resources that satisfy the provided criteria. In accordance with one implementation and without limitation the request may correspond to a Web Service Discovery PROBE message.

It will be appreciated by those skilled in the art that the subscription provider does not necessarily need to send requests for further resource information if it already stores information sufficient to satisfy the request from the provider management module . For example and without limitation the subscription provider may cache the results of previous queries and use the cached data to service requests it receives. In the same or another implementation and again without limitation the subscription provider may cache information that was broadcast unsolicited by publication servers and may use this information likewise to service requests it receives.

In general in operation the subscription provider creates new function instances based on information discussed in operation . While the function instances created in this operation exist on the same machine as the subscription provider and requesting application they represent resources identified through the publication and subscription mechanism described herein. Such resources may exist on other computers.

It will be appreciated by those skilled in the art that any response to the query of operation that conforms to the protocol or communication method in use can be employed by the subscription provider to obtain information from which function instances may be generated regardless of whether the response comes from a system that conforms to the definition of a publication server as defined herein. For example where the Web Service Discovery protocol is used any valid Web Service Discovery response may provide information suitable for use by the subscription provider the response does not need to come from a publication server and may come from another system the generates messages that conform to the Web Service Discovery protocol.

Finally in operation in some implementations the function instances created by the subscription provider in operation are returned to the provider management module then to function discovery module then to the discovery interface module and finally to the requesting application .

Those skilled in the art will realize that the subscription provider may create the function instances and return them to the provider management module or it may return the data necessary to create the function instances and leave the actual creation of function instances to the provider management module or to the function discovery module .

It will also be realized that the subscription provider may return function instances or data asynchronously from the request for function instances. Also the function instances created by the subscription provider may not be complete that is they may not contain all of the information required to be contained by a function instance. In such cases the function discovery module the provider management module the discovery interface module or another module may supplement the data in the created function instances before the function instances are returned to the requesting application .

Turning now to shown therein is a generalized operational flow including various operations that may be performed by a provider to service a request for function instances. In particular the operational flow illustrates operations that may be performed by a provider to carry out the determination operation of operational flow .

The following description of is made with reference to the system of the API layer of and the tree structure of . In particular the description of is made with reference to the provider management module the providers and the resources . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the provider management module the providers or the resources and is also not intended to be limited to being associated with the system of the API layer of or the tree structure of . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

In one implementation of operation a provider receives a request for function instances. The request may include but is not limited to a subcategory that identifies a particular set of resources on which the returned function instances should be based a tree enumeration flag that defines if only the specified subcategory should be searched or if all descendant subcategories should also be searched and filter criteria that specifies how returned function instances should be filtered.

In one implementation of operation the provider enumerates the resources with which it is associated and retrieves any information required to create function instances for such resources. The enumeration can in some cases be limited by the specified subcategory information and in the same or other cases can be limited by the specified filter criteria information.

The manner in which the provider enumerates resources varies depending on the nature of the resources with which the provider interacts. In some cases the provider may enumerate the resources and obtain information necessary to create function instances by using an application programming interface that is operable to manage the resources. For example and without limitation a provider for Plug and Play resources may use the application programming interface known as SetupDi. Similarly a provider for Simple Service Discovery Protocol resources may use a Universal Plug and Play application programming interface to find information about the available Universal Plug and Play or Simple Service Discovery Protocol resources etc.

The mapped function instance provider may use the tree structure and API layer data stored in the mapped function instance provider data to create function instances. For example if the mapped function instance provider is given a subcategory of Subcategory A Subcategory B it may traverse the tree structure to the node associated with subcategory B and then return function instances defined by the API layer s associated with the node associated with subcategory AB.

Using the information retrieved in operation one implementation of operation maps the information to the organization and naming required by the function instance. This operation ensures that an application using function instances can retrieve the same information with a single name even if the underlying resources name that information differently. For example and without limitation information about the manufacturer of the resource could be represented by the resource specific application programming interface using a data field called ManufacturerName. This same information the manufacturer may be referred to in function instance resource metadata as Manufacturer. In this example operation transforms resource data retrieved from the resource so that it has the organization and name expected in function instance resource metadata.

In one implementation of operation the provider creates function instances for each resource identified by the request. The provider may create function instances using among other things the resource metadata containing mapped information generated in operation any activation information known or retrieved about the resource and any other information required to create function instances.

Finally in one implementation of operation the function instance s the provider has created are returned to the provider management module . It should be noted that the provider might create the function instances and return them to the provider management module or it might return the data necessary to create the function instances and leave the actual creation of the function instances to the provider management module to the function discovery module or to some other module. Also the provider might return function instances or data asynchronously from the request for function instances. In addition not all of the information necessary to create a full and valid function instance may be provided by the provider . In such cases the function instances created by the provider might not be immediately usable by a requesting application . For example the provider might not specify the value of the unique identification field this information might instead be provided by the provider management module by the function discovery module or by some other module.

Turning now to shown therein is a generalized operational flow including various operations that may be performed by a mapped function instance provider to service a request for function instances . In particular the operational flow illustrates operations that might be performed by a provider to carry out the determination operation of operational flow . The following description of is made with reference to the system of the function instance of the API layer of and the tree structure of . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the system the function instance the API layer or the tree structure . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

In one implementation of operation a mapped function instance provider receives a request for function instances. The request may include but is not limited to a subcategory that identifies a particular set of resources on which the returned function instances should be based a tree enumeration flag that defines if only the specified subcategory should be searched or if all descendant subcategories should also be searched and filter criteria that specifies how returned function instances should be filtered.

In one implementation of operation the mapped function instance provider first locates the appropriate node in the tree structure maintained in the mapped function instance provider data . For example a request with subcategory information Subcategory A Subcategory B may define a node that is located at the end of the tree path starting with the root node continuing through the node for subcategory A and terminating with the node for subcategory B. Once this node is located the mapped function instance provider retrieves all of the API layer data associated with the node.

Then for each API layer retrieved in operation the mapped function instance provider executes operation which retrieves the function instances specified in the API layer . The mapped function instance provider locates the function instances using the category of underlying function instance s field and subcategory of underlying function instance s field .

Additionally the function instance provider may filter the returned function instances by specified function instance resource metadata property values or by supported activation interfaces or by some other data. For example a subcategory named Audio Hardware Local might have an API layer with the category field Plug and Play the subcategory field DevNode and a filter on a particular Plug and Play property so that only function instances that reference audio resources are returned.

In some implementations operation may be executed multiple times when there are multiple API layers associated with the node . In this case the set of retrieved function instances may consist of all of the function instances returned as a result of the data in each API layer. This enables a single category to contain function instances that represent similar resources even if the underlying function instances come from different providers different categories or different subcategories.

Next one implementation of operation creates a new function instance for each function instance retrieved in operation . This new function instance may contain a new value for the unique identification field that is different from the value of the underlying function instance on which it is based. While the new function instance is based on the underlying function instance it is not the same function instance and so in some implementations warrants its own unique identifier.

The new function instance also contains function instance resource metadata that comprises both the resource metadata of the underlying function instance and the resource metadata from the API layer and mapped function instance provider. For example and without limitation the resource metadata of the new function instance may contain a Manufacturer entry with information from the underlying function instance as well as a Subcategory entry that contains the subcategory where the API layer is located. The underlying function instance contains no information about the subcategory information associated with an API layer but the mapped function instance provider can add this information when it creates the new function instance.

Finally the new function instances created in operation may also contain activation data included in or referenced by the activation data field and retrieved from the API layer . For example and without limitation suppose an API layer with a supported interface field that contains Foo Interface and a corresponding factory field that defines an entity that can in turn create another entity that supports the Foo interface based on the information in the function instance. Function instances created based on this API layer may contain activation data table entries that denote that the function instance supports the Foo interface and define how to create an entity that implements the Foo interface.

The activation data created in operation may also contain activation information in the form of specific interface and factory entries from underlying function instances. This enables API layering where an API is defined in terms of another API. For example and without limitation suppose that an API layer contains category of underlying function instance s field subcategory of underlying function instance s field and filter criteria field information that specifies that the underlying function instances also provided by the mapped function instance provider support the Complex Interface. 

The API layer that uses these underlying function instances could then contain a supported interface field that denotes that the resulting function instances support the Simple Interface. In this case function instances returned as a result of data in this API layer contain activation data that indicates that they support both the Simple Interface and the Complex Interface.

Turning now to shown therein is a generalized operational flow including various operations that may be performed by a function instance in response to an activation request. The following description of is made with reference to the system of the function instance of and the API layer of . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the system the function instance and the API layer . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

In one implementation of operation a function instance receives an activation request for an object that supports a specified application programming interface. Depending on the implementation of activation functionality this request may include but is not limited to an interface that specifies the application programming interface the returned object supports a factory identifier that identifies a factory object that can create an entity that supports the requested interface and a set of additional data that if provided can be used by function instance to control or modify the activation. In some implementations the request may contain a subset of this information. For example an implementation that uses function instances where the activation data field includes or references an activation data table may in some cases not include the factory identifier. In such an implementation factory information may be retrieved from the function instance itself.

In operation the function instance determines if it supports activation for the requested interface. In one implementation this test may be performed by examining the activation data table for the presence of the requested interface which if supported will exist in the interface column . In this implementation if the interface does not exist in interface column the function instance does not support activation for the specified application programming interface. In an alternate implementation for example and without limitation in one that does not use function instances that include or reference activation data table information and instead uses factory information provided with the activation request this test may not be performed and in some implementations operational flow may proceed from operation to operation as indicated by dotted line .

If it is determined in operation that the function instance supports activation for the requested application programming interface the operational flow continues to operation described below. If it is determined in operation that the function instance does not support activation for the requested application programming interface operational flow proceeds to operation .

In operation the provider associated with the function instance is queried to determine if the provider supports activating the requested application programming interface. In some implementations the provider may be determined using function instance provider data. If it is determined in operation that the provider supports activating the requested application programming interface the provider creates an entity that implements the requested application programming interface. The operational flow then continues to operation described below. If it is determined that the provider does not support activation for the requested application programming interface operational flow proceeds to operation . In an alternate implementation for example and without limitation in one that does not use function instances that include or reference activation data table information and instead uses factory information provided with the activation request operational flow may proceed to operation as indicated by dotted line .

In operation the activation request indicates that the specified application programming interface is not supported by the function instance or provider .

If the function instance supports activation for the requested application programming interface or in some implementations if the factory to be used is identified in the activation request operational flow continues to operation where in one implementation the function instance creates an instance of a factory associated with the specified application programming interface. In an implementation using the activation data table the factory column contains an identifier for a factory that creates entities that implement the requested interface. For example and without limitation the factory column in a COM based system could contain a CLSID that uniquely identifies a COM object that can create instances of another COM object that actually implements the requested interface. Alternatively and again without limitation in a NET or Java based system the factory column could contain a fully qualified object or path hierarchy that identifies a NET or Java object that can create another object that implements the specified interface. In a non object oriented system the factory column could contain an identifier that specifies how to create some entity that can in turn create another entity that implements the requested application programming interface. In an implementation that uses factory information provided with the activation request the factory information provided with the activation request may be used to create the factory that can create entities that implement the requested interface.

In one implementation of operation the factory created in operation is used to create an entity that implements the requested interface. The factory has access to the data associated with the function instance like the resource metadata as well as possibly to other data like additional parameters included in the activation request. Using this data the factory can create an entity that implements the requested interface.

For example and without limitation suppose a function instance represents Plug and Play audio hardware such as a sound card and suppose that the activation data denotes that the function instance supports an Audio COM interface. In one implementation a factory object that supports creating COM objects that implement the Audio interface might use the Plug and Play SetupDi API to create an object that implements the Audio interface. Such a factory object could use the resource specific information in the function instance like an identifier that specifies which audio hardware the function instance represents to assist in creating the object that implements the Audio interface.

It should be noted that while this description refers to a factory and to factories creating entities which in turn create other entities that implement the requested application programming interface that the function instance could refer directly to the entity that implements the application programming interface. In addition the same entity that implements the factory may also implement the application programming interface.

Finally in operation the entity implementing the requested application programming interface is returned to the requester. Continuing with the example introduced in the previous paragraph and without limitation the COM object that implements the Audio interface would be returned to the application which could then use it to control and interact with the audio hardware to for example play audio or control volume.

Although some particular implementations of systems and methods have been illustrated in the accompanying drawings and described in the foregoing Detailed Description it will be understood that the systems and methods shown and described are not limited to the particular implementations described but are capable of numerous rearrangements modifications and substitutions without departing from the spirit set forth and defined by the following claims.

