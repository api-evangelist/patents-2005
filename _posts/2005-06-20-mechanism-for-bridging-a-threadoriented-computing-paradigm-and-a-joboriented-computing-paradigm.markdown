---

title: Mechanism for bridging a thread-oriented computing paradigm and a job-oriented computing paradigm
abstract: A mechanism is provided for fostering the adoption of grid computing by bridging the thread-oriented paradigm (used in single and multi-processor computers) and the job-oriented paradigm (used in grid computing). This mechanism allows an application developer to write an application in the same manner as if he were writing a thread-oriented program (in terms of creating and joining threads). However, when the application is executed on a client computer and the mechanism is invoked, the mechanism interacts with a resource management interface to cause a distributed resource manager to create, distribute, and manage the execution of jobs on the resource computers of a grid. Thus, rather than actually spawning threads on the client computer, the mechanism causes jobs to be spawned and executed on the grid. By doing this, the mechanism allows the application to take advantage of grid computing without requiring the application to be grid-aware.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07802257&OS=07802257&RS=07802257
owner: Oracle America, Inc.
number: 07802257
owner_city: Redwood Shores
owner_country: US
publication_date: 20050620
---
Many of today s operating systems provide multi threaded capability. With this capability an operating system is able to support concurrent execution of multiple sets of code multiple concurrent executions of the same set of code or both.

In a computer having a single processor the practical effect of multi threading is that the multiple threads share the processor. Since the processor can execute only one thread at a time the processor will execute one thread to a certain execution point or for a certain period of time. The processor then performs a context switch and begins executing another thread. The processor will execute that thread until a certain execution point is reached or until a time limit has been reached. The processor then performs another context switch and begins executing another thread. This other thread may be the previous thread or it may be another thread. By switching from thread to thread in this manner the processor services each thread and provides the impression that the multiple threads are being executed concurrently.

In a computer having multiple processors the execution of the various threads can be truly concurrent. For example if a computer has five processors and there are currently five threads executing in the computer then each processor can be executing one of the threads. Since each processor has the processing resources to execute its own thread the multiple threads can be truly executed concurrently and in parallel. Many of today s high power computers are multi processor computers. These multi processor computers provide the processing power needed to execute some of today s more resource intensive programs.

One of the drawbacks of multi processor computers is that they are not as scalable as would be desired. Multi processor computers can accommodate only a finite number of processors typically in the 16 32 processor range which may not be enough for heavy computation. For this and other reasons there has been a movement in recent times away from large multi processor computers towards a grid based computing model.

In a computing grid a plurality of individual resource computers are coupled together via one or more networks. Each of these resource computers may be a single processor computer or a multi processor computer. Access to the processing resources of the resource computers is controlled by a distributed resource manager DRM . When a client computer has a job to be run it submits the job to the DRM. In response the DRM selects one or more of the resource computers and assigns the job to that resource computer to be run thereon. After the job is completed the DRM receives the results of the job from the resource computer and passes the results back to the client computer. In this manner the DRM acts as the access point to the grid and utilizes the resources in the computing grid to execute jobs. During a busy time a client computer may submit multiple jobs to the DRM which in turn may assign those jobs to various resource computers for execution thereon. During a slow time a client computer may submit very few or even no jobs to the DRM. As shown by this discussion a computing grid provides a client computer with great computing flexibility and scalability. No longer does the client computer have to provide all of its own computing resources. Rather it can call upon the computing resources of the grid as needed.

While grid computing provides many advantageous its adoption by large enterprises has been relatively slow. There have been several reasons for this slow adoption. One reason has been the lack of a standard interface for invoking the functionalities of the DRM. Different DRM makers have implemented different proprietary interfaces. Because of this application developers have not been able to develop applications that are compatible with all DRM s. Instead they have been forced to tailor their applications for specific DRM s. This has slowed the development of applications that are grid aware grid compatible. To rectify this situation an organization known as the Global Grid Forum has created a standard interface known as DRMAA distributed resource management application API for invoking the functionalities of a DRM. If all DRM makers start conforming to this standard then it will be possible for application developers to write applications that are compatible with all DRM s.

Another reason for the slow adoption of grid computing has been the fact that grid computing represents a significant change in computing paradigm. The current prevailing computing paradigm the one used in single and multi processor computers is thread oriented. Under this paradigm when an application wishes to have a set of code executed concurrently with itself it makes a call to the operating system to create another thread and to use that thread to concurrently execute the set of code. Because all threads created by an operating system are assumed to run in the same computer in the same process space the application can make liberal use of logical constructs such as pointers that are valid only within a process space of a particular computer. The same cannot be done in a grid computing environment. In a grid it is not known beforehand which resource computer will be selected by the DRM to execute a job. Thus computer and or process space specific assumptions cannot be made. As a result the thread oriented paradigm cannot be used across a grid.

Instead in grid based computing a job oriented paradigm is used. With the job oriented paradigm each request to execute a set of code is packaged as a job in such a way that it is more self contained. By doing so it is possible for the DRM to assign the job to any resource computer for execution thereon. The packaging of a request is just one of the differences between the thread oriented paradigm and the job oriented paradigm. There are many other significant differences. Because of these differences it is not possible for an application written in accordance with the thread oriented paradigm to operate in a job oriented paradigm unless significant changes are made to the application. Because such extensive changes would require a significant investment in resources very few existing applications have been altered to make them job oriented and hence grid aware grid compatible.

Yet another reason for the slow adoption of grid computing has been that most application developers are accustomed to programming in the thread oriented paradigm. To write grid aware applications developers would have to change from their current paradigm to the job oriented paradigm. This requires significant investment on the part of the developers and is difficult to do. Because of this relatively few grid aware grid compatible applications have been developed.

In accordance with one embodiment of the present invention to foster the adoption of grid computing a mechanism is provided for bridging the thread oriented paradigm and the job oriented paradigm. In one embodiment this mechanism takes the form of a distributed thread dthread library comprising a plurality of methods or functions that can be invoked by applications. This library which acts as an application programming interface API allows an application developer to write an application in the same manner as if he were writing a thread oriented program. More specifically the application can be written in terms of creating and joining threads. However when the application is executed on a client computer and the dthread library is invoked by the application the methods of the dthread library do not spawn threads of execution as is usually done in the thread oriented paradigm. Instead the methods of the dthread library interact with a resource management interface to cause a DRM to create distribute and manage execution of jobs on the resource computers of a grid. Thus rather than actually spawning threads and executing those threads on the client computer the dthread library causes jobs to be spawned and executed on the resource computers of the grid. By doing this the dthread library allows the application to take advantage of grid computing without requiring the application to be written in such a way that it is grid aware note the application does not know it is interacting with a grid at all . By providing this capability the dthread library will ease the transition into the grid oriented paradigm and will foster the proliferation of grid computing.

Before describing an embodiment of the present invention in detail some additional background information will first be provided to facilitate a complete understanding of the invention.

As noted previously many current operating systems support multi threaded operation. In many of these operating systems a pthread library which conforms to a well know POSIX standard is provided to support multi threaded operation in a multi processor computer. This library provides a plurality of methods functions routines that can be invoked by applications. In effect the pthread library acts as an API for enabling applications to call upon the multi threaded capability of the operating system. Some of the methods of the pthread library are shown in . These methods include 1 a pthread attr init method 2 a series of methods whose names start with pthread attr set 3 a pthread create method 4 a pthread join method and 5 a pthread attr destroy method. The following discussion illustrates how these methods may be used by an application executing in a multi processor computer.

When an application invokes the pthread attr init method the operating system creates an attribute data structure that can be used to store one or more attributes associated with a thread. Once this attribute data structure is created the application may invoke one or more of the pthread attr set . . . methods one or more times each time specifying an attribute value pair to be stored within the attribute data structure. After the attributes of a thread are specified the application may invoke the pthread create method to cause the operating system to create a new thread associate the attribute data structure with the new thread and use the new thread to execute another set of code such as a function a subroutine a method etc. the other set of code to be executed is specified in the pthread create method invocation . The new thread may be and often is executed by a different processor than the processor currently executing the application.

At some point the application may wish to obtain the results of the execution of the other set of code. To do so the application invokes the pthread join method to cause the operating system to join the thread executing the other set of code with the main thread executing the application. After the threads are joined the application may wish to do some cleanup to release memory that is no longer needed. To do so the application may invoke the pthread attr destroy method. When this method is invoked the operating system destroys the attribute data structure that was created as a result of the pthread attr init method invocation. The memory associated with the attribute data structure is thus freed and made reusable. In this manner an application may use the pthread library to take advantage of the multi threaded capability of the operating system in a multi processor computer.

The pthread library is used by an application to implement multi threading inside a multi processor computer. To implement job execution in a computing grid an application would use a completely different library referred to herein as a resource management interface. Like the pthread library this resource management interface is an API which comprises a plurality of methods functions routines that can be invoked by applications. Unlike the pthread library however the resource management interface does not implement multi threading within a multi processor computer. Rather it interacts with a DRM to submit monitor and receive results from jobs executed on a computing grid. Thus instead of operating under a thread oriented paradigm the resource management interface operates under a job oriented paradigm. Because these two libraries operate under very different paradigms applications written to invoke one library cannot invoke the other library without significant changes being made to the applications. To invoke the resource management interface directly an application needs to be grid aware.

An example of a resource management interface is the DRMAA interface developed by the Global Grid Forum mentioned previously . DRMAA provides a standard interface to which application developers can program. If a DRM conforms to the DRMAA standard then an application written to invoke the DRMAA interface will be able to interact with that DRM. shows some of the methods in the DRMAA interface. These methods are invoked by an application miming on a client computer to interact with a DRM to submit monitor and receive results from jobs executed on a computing grid. The operation of these methods will be described in greater detail in a later section.

As noted above applications written in accordance with a thread oriented paradigm to invoke the pthread library cannot be easily changed to invoke a resource management interface e.g. DRMAA in accordance with a job oriented paradigm. To bridge these two paradigms one embodiment of the present invention provides a dthread library. Like the pthread library and the resource management interface the dthread library is an API comprising a plurality of methods functions routines that can be invoked by applications.

While the names of the methods of the dthread library are similar to the names of the methods of the pthread library their functionalities are quite different. Rather than implementing multi threaded functionality within a multi processor computer as is done by the pthread library the methods of the dthread library invoke the methods of the resource management interface e.g. DRMAA to interact with a DRM to submit monitor and receive results from jobs executed on a computing grid. Thus even though the methods look like they are thread oriented methods in actuality they interact with the resource management interface to implement a job oriented paradigm. Effectively the dthread library shields an application developer from the specifics and complexities of the resource management interface. The dthread library allows the application developer to continue to think and program in terms of the thread oriented paradigm yet when the application is executed and the methods of the dthread library are invoked a job oriented paradigm is actually implemented. In effect the dthread library converts thread oriented method calls into job oriented method calls to enable the application developer to write applications that are thread oriented and grid unaware but still enjoy the benefits of grid computing.

The similarity between the pthread and the dthread methods gives rise to at least two significant benefits. First it makes it easy to convert a current application that invokes the pthread library into a new application that invokes the dthread library. The main thing that has to be done is to change each occurrence of pthread to dthread some minor changes may also have to be made to the parameters that are provided with the method calls . Thus existing thread oriented applications can be relatively easily transformed into job oriented grid enabled applications note applications that invoke the dthread library are grid enabled but they are not grid aware . Second the similarity makes it simple for a developer accustomed to writing applications that invoke the pthread library to switch to writing applications that invoke the dthread library. With no major syntax differences and the outward appearance of a thread oriented paradigm the dthread library does not impose much of a burden on the developer to learn anything new. Thus application developers face very few barriers to developing grid enabled applications. The two benefits mentioned above will likely cause more existing applications to be converted to grid enabled applications and cause more new grid enabled applications to be developed. Both of these results will foster greater adoption of grid computing.

At this point it should be noted that while the similarity between the pthread and dthread libraries gives rise to significant benefits such similarity is not required. If so desired the methods of the dthread library may be significantly different from the methods of the pthread library. This and other modifications are within the scope of the present invention.

As noted above when a method of the dthread library is invoked it invokes one or more methods of the resource management interface. shows a sample mapping between the methods of the dthread library and the methods of a resource management interface in accordance with one embodiment of the present invention. In the sample shown in the resource management interface is assumed for the sake of illustration to be the DRMAA interface. It should be noted though that if so desired the methods of the dthread library may be mapped to other methods of other resource management interfaces.

As shown in when the dthread attr init method is invoked it invokes the drmaa allocate job template method of the DRMAA interface once and the drmaa set attribute method twice. When the dthread attr set method is invoked it invokes the drmaa set attribute method. When the dthread create method is invoked it invokes the drmaa set attribute method the drmaa set vector attribute method and the drmaa run job method. When the dthread join method is invoked it invokes the drmaa wait method the drmaa wifexited method and the drmaa wexitstatus method. When the dthread attr destroy method is invoked it invokes the drmaa delete job template method. The significance of these mappings and the manner in which the dthread library interacts with the DRMAA interface will be elaborated upon in a later section.

In one embodiment in addition to the methods shown in the dthread library further comprises an  init method and a  fini method and the DRMAA library further comprises a drmaa init method and a drmaa exit method. When an application interacts with the dthread library for the first time thereby causing the dthread library to be loaded the  init method of the dthread library is executed which in turn invokes the drmaa init method of the DRMAA library . Invocation of the drmaa init method causes a session to be opened and initialized with the DRM . When the application terminates thereby causing the dthread library to be unloaded the  fini method of the dthread library is executed which in turn invokes the drmaa exit method of the DRMAA library . Invocation of the drmaa exit method causes some cleanup operations to be performed and causes the session with the DRM to be closed. Through the use of the  init and  fini methods it is possible to shield the application from the management of the underlying connection with the DRM .

With reference to there is shown a functional block diagram of a sample system in which one embodiment of the present invention may be implemented. As shown the system comprises a client computer a computing grid and a network for communicatively coupling the client computer to the grid . The grid comprises a plurality of resource computers . Each of the resource computers is an individual computer which may have a single processor or multiple processors. Each resource computer may also comprise other resources such as storage memory I O devices etc. Access to the resource computers is controlled by a DRM . In one embodiment it is the DRM that interacts with the client computer to manage the creation of jobs the distribution of jobs to the resource computers and the return of job results to the client computer . Overall the DRM acts as the access point to the grid . For the sake of illustration the DRM is shown as an individual component in the grid . However if so desired the DRM may be incorporated into one of the resource computers or even into the client computer . These and other modifications are within the scope of the present invention.

The client computer comprises an operating system and one or more applications only one application is shown for the sake of simplicity . Plugged into the operating system are a pthread library a dthread library and a DRMAA library . In one embodiment these libraries provide the methods that were previously discussed with reference to . To invoke the methods provided by these libraries the application makes calls to the operating system . In turn the operating system invokes the proper methods in the proper libraries.

To facilitate a complete understanding of the present invention a sample operation of the dthread library will now be described with reference to the sample system shown in .

Suppose that application is currently executing on the client computer using a particular thread. Suppose further that the application arrives at a point in its execution where it wishes to spawn a new thread to execute another set of code e.g. a function concurrently with itself. Before it spawns this new thread however the application wishes to specify some attributes for the new thread. To do so the application first invokes the dthread attr init method of the dthread library to create a data structure in which the attributes of the new thread may be stored. This invocation is shown in . In response to this invocation the dthread attr init method does not actually create a data structure. Instead it invokes the drmaa allocate job template method of the DRMAA library . In response the drmaa allocate job template method creates a data structure referred to herein as a bucket within the client computer for storing the attributes of a new job and assigns it a bucket ID. This bucket ID is returned to the dthread attr init method.

After receiving the bucket ID the dthread attr init method in one embodiment proceeds to set two attributes more attributes could be set if so desired of the job to default values. To do so the dthread attr init method invokes the drmaa set attribute method of the DRMAA library twice. In the first invocation the dthread attr init method provides the bucket ID the name of an attribute in this case DRMAA output path and a value for the attribute in this case null . This causes the drmaa set attribute method to store the attribute value pair DRMAA output path and null inside the bucket thereby setting the path to an output file to null . In the second invocation the dthread attr init method provides the bucket ID the name of an attribute in this case DRMAA error path and a value for the attribute in this case null . This causes the drmaa set attribute method to store the attribute value pair DRMAA error path and null inside the bucket thereby setting the path to an error file to null . After this is done the bucket i.e. the new job template is initialized and the dthread attr init method returns the bucket ID to the application . The application believes this ID to be a pointer to a data structure created by the dthread attr init method that stores the attributes for a new thread.

After calling the dthread attr init method the application may wish to specify values for one or more attributes of the new thread. To do so the application calls the dthread attr set method of the dthread library see . Each time the application calls the dthread attr set method it provides the bucket ID the name of an attribute and a value for the attribute. In response the dthread attr set method invokes the drmaa set attribute method of the DRMAA library and provides thereto the bucket ID the name of an attribute and a value. In some instances the name of an attribute provided by the application may not be the name of an attribute recognized by the DRMAA standard. In such a case the dthread attr set method has sufficient logic to convert the attribute name into one that is recognized by DRMAA. The same conversion may be done for the attribute value if necessary. In response to being invoked the drmaa set attribute method stores the attribute value pair provided by the dthread attr set method into the previously created bucket.

The application may call the dthread attr set method zero or more times to specify zero or more attribute values for the new thread. After it has specified all of the desired attribute values the application calls the dthread create method of the dthread library to create a new thread to execute another set of code concurrently with itself see . In making the dthread create call the application provides the bucket ID the name of a set of code e.g. the name of a function to be executed and a reference to an array of zero or more arguments to be used in executing the set of code. In one embodiment the name of the set of code is recognized as a string and not as a pointer.

In response to being invoked the dthread create method in one embodiment invokes several methods of the DRMAA library . First it invokes the drmaa set attribute method. In this invocation the dthread create method provides the bucket ID the attribute name DRMAA remote command and the function name foo for example provided by the application as part of the dthread create method call. Basically this invocation causes the drmaa set attribute method to store information within the bucket indicating that the program or command that is to be executed by the job is named foo .

In addition the dthread create method invokes the drmaa set vector attribute method. As part of this invocation the dthread create method provides the bucket ID the attribute name DRMAA v argv and the reference to the array of arguments provided by the application as part of the dthread create method call. This invocation causes the drmaa set vector attribute method to store information within the bucket indicating where the arguments for the program to be executed can be obtained.

After that is done the dthread create method invokes the drmaa run job method and provides the bucket ID. In response to this invocation the drmaa run job method accesses the bucket referenced by the bucket ID and extracts all of the information stored therein. From the information contained in the bucket the drmaa run job method determines from the DRMAA remote command attribute which set of code e.g. the function foo is to be executed by the job and locates and obtains that set of code in one embodiment the set of code is resident on the client computer . In addition the drmaa run job method locates and obtains the array that contains the arguments to be used in executing the set of code. The drmaa run job method packages the set of code the arguments some or all of the attributes and values in the bucket and possibly other information in the bucket and sends the package to the DRM . In response the DRM creates a new job assigns it a job ID and assigns the job to one or more of the resource computers in the grid to be executed thereon. The set of code is thus caused to be executed on the grid . Thereafter the DRM returns the job ID to the drmaa run job method which in turn returns the job ID to the dthread create method which in turn returns the job ID to the application . The application believes this ID to be an ID of a thread that is executing the set of code on the client computer . Unbeknownst to the application however the set of code is not being executed by a thread on the client computer but rather by one or more of the resource computers on the grid .

At some point the application may wish to obtain the results of the execution of the set of code. To do so the application calls the dthread join method of the dthread library and provides the job ID see . In response the dthread join method in one embodiment invokes several methods of the DRMAA library . First it invokes the drmaa wait method and provides the job ID. In response to this invocation the drmaa wait method submits a request which includes the job ID to the DRM to monitor the status of the job. The drmaa wait method will wait until the job completes execution. When the job is completed the DRM sends a job complete notification and a set of execution results to the drmaa wait method. In turn the drmaa wait method creates a results data structure in the client computer and stores the execution results therein. In addition the drmaa wait method returns a job complete notification and a pointer to the results data structure to the dthread join method.

Upon receiving the job complete notification and the pointer to the results data structure the dthread join method invokes the drmaa wifexited method to obtain the exit status of the job e.g. whether the job completed successfully or encountered an error . As part of this invocation the dthread join method provides the pointer to the results data structure. Using the pointer the drmaa wifexited method accesses the results data structure obtains the exit status of the job therefrom and returns the exit status to the dthread join method.

At this point the dthread join method performs a check on the exit status. If the exit status indicates that the job encountered an error and hence did not complete successfully then it returns an error message to the application . On the other hand if the exit status indicates that the job completed successfully then the dthread join method invokes the drmaa wexitstatus method to obtain a set of one or more execution result values. Included in this invocation is the pointer to the results data structure. Using the pointer the drmaa wexitstatus method accesses the results data structure obtains the one or more execution result values therefrom and returns it them to the dthread join method. Thereafter the dthread join method returns to the application with the execution status and the set of one or more result values. In this manner the application is able to obtain the results of the execution of the set of code without ever knowing that the set of code was executed on a grid.

After obtaining the results of the execution of the set of code the application may wish to perform some cleanup. To do so the application calls the dthread attr destroy method of the dthread library and provides the bucket ID see . In response the dthread attr destroy method invokes the drmaa delete job template method of the DRMAA library . As part of this invocation the dthread attr destroy method provides the bucket ID. In response the drmaa delete job template method destroys the bucket that was used to store the attribute and other information for the job and frees the memory for reuse by other entities.

In the manner described the dthread library enables the application to take advantage of the computing grid without ever being aware of the existence of the grid .

In the embodiment of the dthread library described thus far the methods of the dthread library invoke the methods of the DRMAA library . As an alternative the methods of the dthread library may be programmed with sufficient logic that they implement all of the functionalities that are performed by the methods of the DRMAA library . If this is done then there will be no need to invoke the methods of the DRMAA library . This and other embodiments are within the scope of the present invention.

In one embodiment the dthread library is implemented as one or more sets of instructions that are executed by one or more processors. is a block diagram of a computer system upon which an embodiment of the dthread library may be executed. Computer system may be used to implement the client computer the resource computers or any other computer in the system of .

Computer system includes a bus for facilitating information exchange and one or more processors coupled with bus for processing information. Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions by processor . Computer system may further include a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

In computer system bus may be any mechanism and or medium that enables information signals data etc. to be exchanged between the various components. For example bus may be a set of conductors that carries electrical signals. Bus may also be a wireless medium e.g. air that carries wireless signals between one or more of the components. Bus may further be a network connection that connects one or more of the components. Any mechanism and or medium that enables information signals data etc. to be exchanged between the various components may be used as bus .

Bus may also be a combination of these mechanisms media. For example processor may communicate with storage device wirelessly. In such a case the bus from the standpoint of processor and storage device would be a wireless medium such as air. Further processor may communicate with ROM capacitively. Further processor may communicate with main memory via a network connection. In this case the bus would be the network connection. Further processor may communicate with display via a set of conductors. In this instance the bus would be the set of conductors. Thus depending upon how the various components communicate with each other bus may take on different forms. Bus as shown in functionally represents all of the mechanisms and or media that enable information signals data etc. to be exchanged between the various components.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any non transitory medium that participates in providing data that causes a machine to operation in a specific fashion. In an embodiment implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms such as nonvolatile media and volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory .

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CDROM DVD or any other optical storage medium a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge or any other non transitory medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its memory. The instructions may optionally be stored on storage device .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

At this point it should be noted that although the invention has been described with reference to a specific embodiment it should not be construed to be so limited. Various modifications may be made by those of ordinary skill in the art with the benefit of this disclosure without departing from the spirit of the invention. Thus the invention should not be limited by the specific embodiments used to illustrate it but only by the scope of the issued claims and the equivalents thereof.

