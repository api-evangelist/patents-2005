---

title: Providing instrumentation data to an instrumentation data source from within a managed code
abstract: A computer-implemented method for exposing instrumentation data available from within a managed code environment to an instrumentation data source executing outside of said managed code environment is presented. The method comprises each of the following. An indication is received that said instrumentation data should be exposed to said instrumentation data source. In response to receiving said indication, a decoupled provider is loaded. The decoupled provider facilitates communication between said managed code environment and said instrumentation data source. A determination is made as to whether schema describing said instrumentation data has been previously registered with said instrumentation data source. In response to determining that said schema has not been previously registered with said instrumentation data source, said schema is registered with said instrumentation data source through said decoupled provider.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07631300&OS=07631300&RS=07631300
owner: Microsoft Corporation
number: 07631300
owner_city: Redmond
owner_country: US
publication_date: 20050831
---
This application is a continuation of U.S. patent application Ser. No. 09 899 959 filed on Jul. 6 2001 now U.S. Pat. No. 6 996 809 which claims the benefit of U.S. Provisional Application No. 60 217 123 filed Jul. 10 2000 the entire disclosures of which are hereby incorporated by reference herein.

A wide array of products and services are accessible through the Internet and the World Wide Web Web or WWW . For example a Web user can shop get traffic conditions read product reviews and compare products on line. However there are many types of services that are still not available through the Web. While a Web user may be able to find a restaurant in their particular area for instance they may be unable to determine whether that restaurant has seating available at a particular time on a particular night. Likewise if a user owns a business they may be interested in knowing if a vendor has a particular item in stock. If more than one vendor has the item in stock the business owner may be interested in knowing which vendor has the item for the lowest price and which one can deliver the item fastest. Users are unable to perform such tasks using services currently available on the Web.

Services like those described above do not yet exist because there are no standards in place for integrating proprietary information like available restaurant seating vendor inventory prices and delivery times and other such information. After all each vendor most likely has a unique way of describing the items or products they sell. Moreover it is very difficult to develop computer program code necessary for integrating such disparate data and services. However emerging technologies such as the extensible markup language XML make the task of describing disparate types of data in a consistent way much easier. Moreover new application development and execution platforms can help developers create and deploy distributed applications quicker and easier than ever before.

One development and execution platform that helps software developers to create and deploy distributed applications is the Microsoft .NET platform from Microsoft Corporation of Redmond Washington. The Microsoft .NET platform is an application programming and execution platform that provides write once compile once run anywhere application development. Microsoft .NET platform applications may be created in any language as long as they are compiled by a compiler that targets the Microsoft .NET universal runtime URT also known as the common language runtime engine. Such a compiler compiles .NET applications into intermediate language IL rather than directly into executable code. IL is a platform independent and central processing unit CPU independent intermediate language. IL is a much higher level language than most CPU machine languages.

To execute a .NET platform application the compiled IL is interpreted or just in time compiled by the URT into native machine instructions. The native machine instructions can then be directly executed by the CPU. Because IL is CPU independent IL can execute on any CPU platform as long as the operating system running on that CPU platform hosts the Microsoft .NET URT. Applications compiled into IL need the URT to execute and are called managed code applications. By contrast code that does not need the common language runtime to execute such as today s Win32 applications are called native code applications.

The Microsoft .NET platform also includes a base library that comprises a large set of class libraries and services. These libraries and services provide access to the features of the URT and other high level services so that software developers do not have to code the same services repeatedly. For instance classes may be offered to expose hypertext transfer protocol HTTP clients and servers generic containers like arrays and dictionaries and other types of classes previously available only through language specific extensions.

The Microsoft .NET platform also provides technologies to support rapid software development. For instance in the Microsoft .NET platform all application services are offered via a common object oriented programming model. This is unlike previous development and execution environments where some operating system facilities are accessed via dynamically linked library DLL functions and other facilities are accessed via component object model COM objects. Moreover the Microsoft .NET platform provides consistency in error handling. When programming Microsoft Windows in a traditional fashion some functions report Win32 error codes some return HRESULTS and some raise exceptions. In the Microsoft .NET platform all errors are reported via exceptions. This greatly simplifies reading writing and maintaining code.

In order to access management information about other applications and devices Microsoft .NET applications need access to instrumentation data such as the data provided by Microsoft Windows Management Instrumentation WMI . WMI is the Microsoft Corporation s implementation of the Distributed Management Task Force s DMTF Web Based Enterprise Management WBEM initiative. WMI is a set of system services and programming interfaces that allow applications to expose instrumentation data in a consistent way. By exposing instrumentation data in a consistent fashion management applications can be written to a single application programming interface API . WMI also provides a set of services such as remoting asynchronous access and scripting that allow applications and management tools to better access and serve management data without requiring information providers to explicitly support those features. Additionally WMI services also include a standard query language for management objects event publication and subscription and standard event filtering and aggregation.

WMI currently runs in native code outside the .NET platform. Therefore WMI does not have access to instrumentation data offered by applications executing in managed code. Because WMI is a management platform in order to be effective it must be able to access data regarding all instrumented objects and applications including those executing in managed code within the .NET platform. Additionally WMI should be able to easily obtain instance information on object classes exposed from within the .NET platform and to write properties and execute methods on instances of these classes. In order to be truly effective provision of instrumentation data from the .NET platform to WMI should be easily implemented during or after code development and deployment.

Therefore in light of the above there is a need for a method and system for easily providing instrumentation data including class instance and method information from applications executing within a managed code environment such as the .NET platform to an instrumentation data source such as WMI. Moreover provision of instrumentation data should be accomplished through an easy to use interface that allows code to be instrumented during or after development.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

A computer implemented method for exposing instrumentation data available from within a managed code environment to an instrumentation data source executing outside of said managed code environment is presented. The method comprises each of the following. An indication is received that said instrumentation data should be exposed to said instrumentation data source. In response to receiving said indication a decoupled provider is loaded. The decoupled provider facilitates communication between said managed code environment and said instrumentation data source. A determination is made as to whether schema describing said instrumentation data has been previously registered with said instrumentation data source. In response to determining that said schema has not been previously registered with said instrumentation data source said schema is registered with said instrumentation data source through said decoupled provider.

Another computer implemented method for exposing instrumentation data available within a managed code environment to an instrumentation data source executing outside said managed code environment is provided. The method comprises each of the following. An indication that said instrumentation data should be exposed to said instrumentation data source is received. In response to receiving said indication a decoupled provider is loaded. The decoupled provider facilitates communication between said managed code environment and said instrumentation data source. A determination is made as to whether schema describing said instrumentation data has been previously registered with said instrumentation data source. In response to determining that schema has not been previously registered with said instrumentation data source said schema is registered with said instrumentation data source through said decoupled provider. A request for said instrumentation data is also received from said instrumentation data source at said decoupled provider. In response to said request said instrumentation data is converted from a format compatible with said managed code environment to a format compatible with said instrumentation data source and said converted instrumentation data is transmitted to said instrumentation data source.

Yet another computer implemented method for exposing instrumentation data available within a managed code environment to an instrumentation data source executing outside said managed code environment is presented. The computer implemented method comprises each of the following. A request for said instrumentation data is received at a decoupled provider. A determination is made as to whether said request comprises a request for one or more instances of said instrumentation data. In response to determining that said request comprises a request for instances of said instrumentation data said decoupled provider is queried to determine if instances of said instrumentation data are available. In response to determining that said instances of said instrumentation data are available that satisfying said request said instances of said instrumentation data satisfying said request are converted from a format compatible with said managed code environment to a format compatible with said instrumentation data source and said converted instances of said instrumentation data satisfying said request are transmitted to said instrumentation data source.

The present invention is directed to a method computer readable media and apparatus for providing instrumentation data from a managed code environment to an instrumentation data provider. Aspects of the present invention may be embodied in a managed code development and runtime environment or through and API exposed within the managed code environment. Additionally aspects of the present invention may be embodied in an operating system program such as Windows 2000 provided by Microsoft Corporation of Redmond Wash.

Referring now to the figures in which like numerals represent like elements an actual embodiment of the present invention will be described. Although aspects of the invention will be described in the general context of a managed code environment that includes program modules that execute on an operating system in conjunction with a computer those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. Although the invention is also described as being practiced in a distributed computing environment where tasks are performed by remote processing devices that are linked through a communications network other possible implementations should be apparent to those skilled in the art.

Referring now to an illustrative operating environment for an embodiment of the present invention will be described. Aspects of the present invention are implemented as an executable software component executing on a computer such as the computer accessible via a distributed computing network such as the Internet . As is well known to those skilled in the art the Internet comprises a collection of networks and routers that use the Transmission Control Protocol Internet Protocol TCP IP to communicate with one another. The Internet typically includes a plurality of local area networks LANs and wide area networks WANs that are interconnected by routers. Routers are special purpose computers used to interface one LAN or WAN to another. Communication links within the LANs may be twisted wire pair or coaxial cable while communication links between networks may utilize 56 Kbps analog telephone lines Mbps digital T 1 lines 45 Mbps T 3 lines or other communications links known to those skilled in the art. Furthermore computers such as the computer and other related electronic devices can be remotely connected to either the LANs or the WANs via a permanent network connection or via a modem and temporary telephone link. It should be appreciated that the Internet comprises a vast number of such interconnected networks computers and routers.

The computer comprises a general purpose computer as known to those skilled in the art including a processing unit a system memory and a system bus not shown that couples the system memory to the processing unit . The computer also typically includes at least some form of computer readable media. Computer readable media can be any available media that can be accessed by the computer . By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile media and nonvolatile media removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other solid state memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer .

As known to those skilled in the art the system memory may include a ROM and a RAM not shown . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computer such as during start up may also be provided. A number of program modules may be stored in the computer storage media including an operating system suitable for controlling the operation of the computer such as Windows NT or Windows 2000 from Microsoft . As will be described in more detail below the system memory may also store a managed code environment including a common language runtime and instrumentation provider code for exposing instrumentation data available within the managed code environment to an instrumentation data source executing outside the managed code environment.

A user may control the operation of the computer through input devices such as a keyboard or a mouse not shown . These and other input devices are often connected to the processing unit through a serial port interface not shown that is coupled to the system bus but may be connected by other interfaces such as a universal serial bus USB . Output devices such as a monitor not shown are also connected to the system bus via an interface such as a video adapter not shown . In addition to the monitor the computer may include other output devices such as a printer not shown .

As described briefly above the computer operates in a networked environment in the actual embodiment of the invention described herein. The computer communicates with other computers over the Internet and connects to the Internet through a network interface. Alternatively the computer may include a modem not shown and use an Internet Service Provider ISP to establish a connection to the Internet . It will be appreciated that the network connections described herein are illustrative and other means of establishing a communications link between the computer and the Internet may be used.

Referring now to an illustrative managed code environment will be described. As mentioned briefly above the managed code environment comprises an application development and execution environment that provides facilities to make the development and execution of distributed applications and services much easier. In the actual embodiment of the present invention described herein the managed code environment comprises the Microsoft .NET platform which will be described in detail below. Those skilled in the art should appreciate that while the present invention is described herein as executing on the Microsoft .NET framework the present invention may also be utilized in connection with other types of managed code environments that utilize an interpreter or just in time compiler to execute applications. For instance the present invention may be utilized in connection with a Java virtual machine from Sun Microsystems.

According to the actual embodiment of the present invention described herein the managed code environment comprises operating system services a common language runtime a services framework and one or more application models such as the active server pages plus ASP.NET application model and the Win forms application model . Each of the components of the managed code environment is described in detail below.

At the lowest level of the managed code environment resides operating system services . As known to those skilled in the art an operating system may provide a number of services such as memory management and hardware support through device drivers and other types of services. These operating system services are exposed to the managed code environment through APIs DLLs or through other means known to those skilled in the art.

Built on top of the operating system services is a common language runtime runtime that loads and executes code written in any runtime aware programming language. Code that targets the runtime is called managed code. Managed code means that there is a defined contract of operation between executing code and the runtime . Responsibility for tasks like creating objects making method calls and so on is delegated to the runtime which enables the runtime to provide additional services to the executing code.

The runtime makes use of a common type system capable of expressing the semantics of most modern programming languages. The common type system defines a standard set of types and rules for creating new types. The runtime understands how to create and execute these types. Compilers and interpreters use runtime services to define types manage objects and make method calls instead of using tool or language specific methods.

A primary design goal for the type system of the runtime is to enable deep multi language integration. Using the runtime code written in one language can inherit implementation from classes written in another language exceptions can be thrown from code written in one language and caught by code written in another and operations such as debugging and profiling work seamlessly regardless of the language used to write the code. The means that developers of reusable class libraries no longer need to create versions for each programming language or compiler and developers using class libraries are no longer limited to libraries for the programming language they are using.

The runtime also supplies integrated pervasive security services to ensure that unauthorized users cannot access resources on a machine and that code cannot perform unauthorized actions. This improves overall system safety and reliability. Since the runtime is used to load code create objects and make method calls the runtime can perform security checks and enforce security policy as managed code is loaded and executed. In this regard the runtime supports code access security and role access security.

With code access security developers can specify the required permissions their code requires. For example code may need permission to write a file or access environment variables. At load time and on method calls the runtime verifies that the code can be granted the permissions it has asked for. If not a security violation is reported.

Role based security builds on the same permissions model as code access security except that the permissions are based on user identity rather than code identity. Roles represent categories of users and can be defined at development or deployment time. Policies for granting permissions are assigned to each defined role. At run time the identity of the user on whose behalf the code is running is determined. The runtime determines what roles the user is a member of and then grants permissions based on those roles.

A services framework resides on top of the runtime . The services framework provides classes that can be called from any modem programming language. In particular the services framework includes a base class library a data access class library and a debugging class library . The base class library includes a set of class libraries that developers would expect in a standard language library such as collections input output string and numerical classes. In addition the base class library provides classes to access operating system services such as graphics networking threading globalization and cryptography. The data access class library provides classes for connecting to issuing commands against and retrieving results from data stores. Other class libraries may also be provided. It should also be appreciated that each of these class libraries complies with a set of naming and design guidelines to further reduce the learning curve for developers.

Conceptually on top of the services framework sit two application models the ASP.NET application model and the Win forms application model . Developers writing client applications for the Microsoft Windows operating system can use the Win forms application model to take advantage of the rich user interface features of the Windows operating system including existing ActiveX controls and features of the Windows 2000 operating system such as transparent layered and floating windows.

The ASP.NET application model takes advantage of the common language runtime and the services framework to provide a reliable robust scalable hosting environment for distributed applications. To provide such functionality the ASP.NET application model includes forms that are responsible for generating a user interface typically in the form of hyper text markup language HTML . The ASP.NET application model comes with a set of Web forms that mirror typical HTML user interface widgets including list boxes text boxes and buttons and an additional set of Web controls that are more complex such as calendars and advertising rotators . The ASP.NET application model also includes Web services that provide a high level programming model for building Web services with ASP.NET.

Referring now to an illustrative management instrumentation data source will be described. As mentioned briefly above aspects of the present invention provide access to instrumentation data contained within a managed code runtime environment such as the Microsoft .NET platform to a management instrumentation data source. In the actual embodiment of the present invention described herein the management instrumentation data source is Microsoft Windows Management Instrumentation.

As mentioned briefly above WMI is the Microsoft Corporation s implementation of the Desktop Management Task Force s Web Based Enterprise Management initiative. As known to those skilled in the art WMI is a set of system services and programming interfaces that allow applications to expose instrumentation data in a consistent way. By exposing instrumentation data in a consistent fashion management applications can be written to a single API.

WMI also provides a set of services such as remoting asynchronous access and scripting that allow applications and management tools to better access and serve management data without requiring information providers to explicitly support those features. It should be appreciated by those skilled in the art that while the actual embodiment of the present invention described herein provides access to instrumentation data contained within a managed code environment to WMI the present invention may also be practiced with other types of instrumentation data sources including other implementations of WBEM.

In WMI a service WINMGMT provides all of the WMI functionality. According to an actual embodiment of the present invention the WINMGMT service is implemented as a single executable process in concert with several in process DLLs that assist the executable process in areas such as delivering or filtering events. In accordance with another actual embodiment of the present invention the WINMGMT service is hosted in process to another executable. This WINMGMT service supports a Common Information Model CIM object repository that provides a central storage area for management data a CIM object manager CIMOM that provides applications with uniform access to management data and the APIs that together deliver WMI. Applications depend on the CIMOM to handle the interface between a management application and data providers A N. WMI facilitates these communications by supporting a common programming interface the Component Object Model COM interface. The WMI COM API supplies event notification and query processing services and can be used in several programming language environments such as C and C .

The CIM repository holds the CIM and associated schema along with data information or data source details. The CIMOM uses the schema data contained in the CIM repository when servicing requests from a management application for data regarding managed objects A N. A management application is an application or operating system service that uses or processes information originating from managed objects A N. Through the use of the present invention the management application may obtain instance information write properties and execute methods on managed objects within a managed code environment. A management application can access managed object information by making a requests to the CIMOM through one of the methods provided in the WMI API. As known to those skilled in the art the CIMOM may also use the schema data in the CIM repository when servicing requests from a management console received through snap ins A N.

The managed objects A N are either physical or logical enterprise components that are modeled using CIM. For example a managed object can be hardware such as a cable or software such as a database application. Managed objects A N may include a Windows Driver Model WDM kernel object A a Simple Network Management Protocol SNMP object B a Desktop Management Interface DMI object C a WIN32 object D or other type of object N. As will be described in detail below managed objects may also include objects resident in a managed code environment.

The CIMOM communicates with the managed objects A N through the data providers A N. The data providers A N are standard COM and distributed COM DCOM servers that function as mediators between the managed objects A N and the CIMOM . The data providers A N supply instrumentation data for parts of the CIM schema. If the CIMOM receives a request from a management application for data that is not available from the CIM object repository or for event notifications that are not supported by the CIMOM the CIMOM forwards the request to the appropriate one of the data providers A N. The data providers A N can then supply data and event notifications for the specific managed object A N to the CIMOM . In turn this data can be returned by the CIMOM to the management application . As will be described below a decoupled provider and decoupled proxy communicate to the CIMOM through a COM or DCOM interface and allow the provision of instrumentation data from a managed code environment.

Referring now to an illustrative interface between a managed code environment and an instrumentation data source such as WMI executing within a native code environment will be described. As described above an instrumentation data source such as WMI executes within a native code environment such as WIN32. In WMI the CIMOM receives requests from management applications regarding managed objects such as objects exposed by the managed code application . In order to respond to such requests the CIMOM may query the CIM object repository or may query a data provider associated with the particular managed object for which data is needed. For instance the CIMOM may query the WIN32 data provider F for instrumentation data regarding the managed object F. If the requested data relates to an object existing in the managed code environment the CIMOM may query a decoupled provider executing in managed code. Once the requested instrumentation data is received the CIMOM can respond to the request from the management application .

In order to provide access to instrumented objects that exist within the managed code environment the present invention provides a decoupled provider a managed provider and a decoupled proxy . As will be described in greater detail below the decoupled provider and the decoupled proxy facilitate communication with the CIMOM . In particular these objects assist the managed provider in dynamically registering objects to be instrumented with the CIMOM respond to requests from the CIMOM for instance data and also respond to requests to write properties or execute methods on instrumented objects.

Turning now to an illustrative Routine will be described for exposing objects to an instrumentation data source according to an actual embodiment of the present invention. According to the actual embodiment of the invention described herein the Routine is executed at run time and provides functionality for dynamically registering instrumented objects with the instrumentation data source. In this manner these objects can be made available to interested management applications or clients. Those skilled in the art should appreciate that while Routine provides functionality for dynamically registering objects to be instrumented at run time such objects may also be registered with the instrumentation data source when an application utilizing such objects is deployed or at another time.

The Routine begins at block where an indication is received that an object should be made available to an instrumentation data source. According to one embodiment of the present invention an attribute is provided in the code at development time that indicates that a particular object should be made available to an instrumentation data source. For instance the attribute instrumented may be provided in or before a class definition to indicate that the class should be instrumented and made available to an instrumentation data source. Instrumenting objects through attribution provides a very easy way for programmers to expose object data. Previously a programmer would have to create a complex COM provider to expose instrumentation data. By using attribution however a programmer can expose instrumentation data by simply adding the appropriate attribute on the objects to be exposed. In a similar way instrumentation data may be exposed through a call to a routine exposed by an API for exposing instrumentation data.

According to another embodiment of the present invention an attribute may be added to shipped code to instrument objects within the code even where the source code is unavailable. In the Microsoft .NET platform metadata is emitted when source code is compiled. The metadata is used by the runtime to locate and load class types lay out object instances in memory resolve method invocations and field references translate IL to native code enforce security and perform other features. By adding an instrumentation attribute to the metadata for each object to be exposed to the instrumentation data source these objects may be instrumented without having access to the application source code.

From block the Routine continues to block where a determination is made as to whether a decoupled provider is present. As described briefly above the decoupled provider facilitates communication between the managed provider executing within the managed code application and the instrumentation data source. If the decoupled provider has not been loaded the Routine branches to block where the decoupled provider is loaded. The Routine then continues from block to block .

If at block it is determined that the decoupled provider has been loaded the Routine continues to block . At block a determination is made as to whether schema describing the object class to be instrumented has been previously registered with the instrumentation data source. As known to those skilled in the art such schema describes the properties and methods exposed by and object much like a class definition. If such schema has been previously registered the Routine branches to block where a determination is made as to whether the previously registered schema correctly describes the object class. If the previously registered schema correctly describes the object class to be instrumented the Routine branches to block . If the previously registered schema does not correctly describe the object class to be instrumented the Routine continues from block to block where the previously registered schema is overwritten with schema correctly describing the object class. The Routine then continues from block to block .

If at block it is determined that schema describing the object class to be instrumented has not been registered with the instrumentation data source the Routine continues to block . At block schema describing the object class to be instrumented is registered with the instrumentation data source. According to the actual embodiment of the present invention described herein this process may comprise creating the schema in the managed object format MOF used by WMI based upon the class definition or based upon schema describing the class in the XML format used by the Microsoft .NET platform.

From block the Routine continues to block where the application program associated with the instrumentation data is registered with the instrumentation data source as a provider of instances of such instrumentation data. From block the Routine continues to block where the decoupled provider is also notified that instances of instrumentation data of the object class type are available to be instrumented. The Routine then continues from block to block where it ends.

Referring now to an illustrative Routine will be described for processing requests for object instance data for writing properties and for executing methods on instrumented objects. As described briefly above once loaded the decoupled provider communicates with the instrumentation data source and responds to requests from the instrumentation data source. For instance the instrumentation data source may request all instances of an instrumented object may request to write a property on an instrumented object or may request to execute a method on an instrumented object. The decoupled provider receives these requests and processes them according to the Routine .

The Routine begins at block where a request is received from the instrumentation data source at the decoupled provider. The Routine then continues to block where the decoupled provider determines whether the request received from the instrumentation data source was a request for an instance of an instrumented object. If a request for an instance was received the Routine branches to block where the decoupled provider queries the managed providers executing within managed code applications for instances that meet the criteria provided with the request. According to one embodiment of the present invention the decoupled provider queries the available managed providers in a round robin fashion for matching instances.

From block the Routine continues to block where the instances satisfying the request are identified to the decoupled provider. The Routine then continues to block where the identified instances are converted to a format compatible with the instrumentation data source by the decoupled provider. This process may involve converting instance properties compatible with the managed code environment to properties compatible with the instrumentation data source. The Routine then continues to block where the converted instances are transmitted to the instrumentation data source as a reply to the request. The Routine then returns to block where another request may be processed as described above.

If at block the decoupled provider determines that the request was not a request for instance data the Routine continues to block . At block the decoupled provider determines whether the request was a request to execute a method on an instance of an instrumented object or to write a property on an instance of an instrumented object. If such a request was not received the Routine branches from block to block where another request may be processed. If such a request was received the Routine continues to block .

At block the decoupled provider identifies the object upon which the requested action is to be taken. The Routine then continues to block where the decoupled provider executes the requested method or writes the requested property on the identified object. The Routine then continues to block where the decoupled provider provides a confirmation to the instrumentation data source that the requested action has been taken. The Routine then returns to block where another request may be processed in a similar manner.

Referring now to an illustrative Routine for processing requests to fire events regarding instrumented objects from within a managed code environment to an instrumentation data source will be described. As mentioned briefly above a fire method is exposed within the managed code environment through an API. In order to fire an event into the instrumentation data source the event object to be fired is first instrumented with an attribute indicating that the object is an event object. The fire method is then called on the object. The object is then fired into the instrumentation data source as described below with regard to the Routine .

The Routine begins at block where the object to be fired is identified. The Routine then continues to block where the namespace within the instrumentation data source corresponding to the object to be fired is identified. From block the Routine continues to block where a determination is made as to whether schema describing the object class has previously been registered with the instrumentation data source. If schema has not previously been registered the Routine continues to block where the object properties are identified and schema is registered with the instrumentation data source for the object. From block the Routine continues to block where the application associated with the event object to be fired is also registered with the instrumentation data source as a provider of such objects. The Routine then continues from block to block .

If at block it is determined that the schema has been previously registered the Routine branches to block . At block a determination is made as to whether the registered schema is correct. If the previously registered schema is correct the Routine branches to block . If the previously registered schema is incorrect the previously registered schema is overwritten with the new schema at block . The Routine then continues from block to block . In this manner schema corresponding to the event class may be dynamically registered with the instrumentation data source.

At block a determination is made as to whether the decoupled provider has previously been loaded. If the decoupled provider has not been previously loaded the Routine branches from block to block where the decoupled provider is loaded. From block the Routine continues to block .

If at block it is determined that the decoupled provider has been previously loaded the Routine continues to block where the decoupled provider is instructed to fire an event for the identified object class. The Routine then continues to block where the decoupled provider communicates to the instrumentation data source to determine whether the event should be fired. This may include querying the instrumentation data source to determine if any client applications are listening for events of the type to be fired.

The Routine then continues to block shown in where a determination is made as to whether the event should be fired. If the event should not be fired the Routine branches to block where it ends. In this manner the event will not be fired if no client is listening for the event thereby saving message bandwidth. If at block it is determined that the event should be fired the Routine continues to block to block where the object is converted from a format compatible with the managed code environment to a format compatible with the instrumentation data source. The Routine then continues to block where the converted event object is fired into the instrumentation data source. The Routine then continues to block where it ends.

In light of the above it should be appreciated by those skilled in the art that the present invention provides a method and apparatus for providing instrumentation data available within a managed code environment to an external instrumentation data source. While an actual embodiment of the invention has been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

While illustrative embodiments have been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

