---

title: Using messages to extend CRM functionality
abstract: A method of extending the functionality of an API in a CRM program and system to implement the method is disclosed. The method may allow a user to use request and response messages to be communicated with a single interface that may be exposed as a CRM web service module to create new business logic and operations by extending previously defined classes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07669205&OS=07669205&RS=07669205
owner: Microsoft Corporation
number: 07669205
owner_city: Redmond
owner_country: US
publication_date: 20051130
---
This is a non provisional of U.S. Provisional Application Ser. No. 60 695 958 filed Jul. 1 2005 the entire disclosure of which is incorporated herein by reference.

Typical business applications may have a number of business entities and may be capable of performing various operations on those entities based on business logic. Such applications provide an Application Programming Interface API that allows access to and execution of business logic related to those entities. As interoperability is a critical requirement in business applications Web Service technology may be used to design the APIs. Consumers of the API are dependent on the signature of the API and are impacted when changes are made to the APIs during its life cycle. Also proportionate to the number of business entities that exist in such applications a similar number of static operations methods are defined and made available through the API.

A method of extending the functionality of an API in a CRM program and system to implement the method is disclosed. The method may allow a user to use request and response messages to be communicated with a CRM web service module to create new business logic and operations by extending previously defined classes and through a single API interface. Target base classes are created by separating the business entities into categories based on the business operations supported by the category and wherein the target class hierarchy can be reviewed to determine what business entities support which operations.

Although the following text sets forth a detailed description of numerous different embodiments it should be understood that the legal scope of the description is defined by the words of the claims set forth at the end of this patent. The detailed description is to be construed as exemplary only and does not describe every possible embodiment since describing every possible embodiment would be impractical if not impossible. Numerous alternative embodiments could be implemented using either current technology or technology developed after the filing date of this patent which would still fall within the scope of the claims.

It should also be understood that unless a term is expressly defined in this patent using the sentence As used herein the term        is hereby defined to mean . . . or a similar sentence there is no intent to limit the meaning of that term either expressly or by implication beyond its plain or ordinary meaning and such term should not be interpreted to be limited in scope based on any statement made in any section of this patent other than the language of the claims . To the extent that any term recited in the claims at the end of this patent is referred to in this patent in a manner consistent with a single meaning that is done for sake of clarity only so as to not confuse the reader and it is not intended that such claim term by limited by implication or otherwise to that single meaning. Finally unless a claim element is defined by reciting the word means and a function without the recital of any structure it is not intended that the scope of any claim element be interpreted based on the application of 35 U.S.C. 112 sixth paragraph.

The steps of the claimed method and apparatus are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the methods or apparatus of the claims include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The steps of the claimed method and apparatus may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The methods and apparatus may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the steps of the claimed method and apparatus includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Typical business applications may have a number of business entities and may be capable of performing various operations on those entities based on business logic. Such applications provide an Application Programming Interface API that allows access to and execution of business logic related to those entities. An API may be a set of programs code libraries or interfaces used by developers to interact with a hardware device network operating system software library or application. As interoperability is a critical requirement in business applications Web Service technology may be used to design the APIs. Consumers of the API are dependent on the signature of the API and are impacted when changes are made to the APIs during its life cycle. Also proportionate to the number of business entities that exist in such applications a similar number of static operations methods are defined and made available through the API. This model is difficult to extend for several reasons 

1. Any change to the API requires a change to all its consumers. Method based extensibility not very versatile and cost effective. In order to extend such APIs new methods need to be added to the API set 

2. Any change to the type system supported by the API requires a change to the API implementation and all consumers 

4. Ongoing cost and complexity of managing the consistency of operations and data across different types of business entities 

6. The programming model and development experience could be complex due to the large number of messages and or types in the API 

7. Often the customizations and the new types e.g. new Business Entities that are introduced by the end users require a different programming model compared to the system Business Entities 

A Message Oriented approach creates an extensibility point that addresses all the problems mentioned and provides a framework that allows new business logic to be implemented through new messages. This method accepts arbitrary messages even messages defined after the implementation without modification of the API signature or type system. The Message Oriented approach has the following advantages 

1. Any change to the API may be implemented by addition of a new message without changing the signature of the method or impacting the existing consumers of the method 

3. A relatively large number of business entities and business logic can be consolidated in a well organized browse able list of messages in the development environment as a way to improve the usability and development experience 

4. Ongoing cost and complexity of managing the consistency of operations and data across different types of business entities can be significantly reduced via a simple message class hierarchy 

6. The customization and the new types e.g. new Business Entities that are introduced by the end users may fit into the message class hierarchy and be consumed with the same programming model compared to the system Business Entities 

8. Work flow and business processes can be easily integrated with the API through a set of newly defined messages that include the workflow recipes and process descriptions.

A message oriented API may allow the users of the business application to execute business logic and access the business operation and data via messages. may be an illustration of the design of such a system for example in a customer relationship management CRM system. CRM may be a way to maintain having the ability to organize and maintain a connection with clients customers and service agents with regards to business relationships and customer satisfaction and a CRM application may be an acronym for customer relation management application which are programs by which a customer can be profiled and tracked to assist a sales staff in providing better service for that customer resulting in improved customer relations overall.

The CRM web service may be the interface that users of the business application use. The interface exposes the new messages extension that have been added to the CRM system after customization as well as the original messages that initially were included in the system through the same interface. The same interface and programming model that is used for the system original business Entities is used for custom Business Entities providing a seamless programming experience. This web service has a well defined web service description provided for in Web Service Definition Language WSDL and may be defined in any other desired definition language. WSDL may be an XML based contract language for describing the network services offered by a Web service provider via UDDI. UDDI stands for Universal Description Discovery and Integration and may be an XML and SOAP based lookup service for Web service consumers to locate Web Services and programmable resources available on a network. WSDL may describe a Web service to Web service consumers by its public methods data types of all parameters return value and bindings. SOAP stands for Simple Object Access Protocol which may be a lightweight XML based messaging protocol used to encode the information in Web service request and response messages before sending them over a network. SOAP messages may be independent of any operating system or protocol and may be transported using a variety of Internet protocols including SMTP MIME and HTTP. The WSDL is dynamically generated for the users of the system and enables them to access the web service and program against it.

The same method and interface may be used to work with various business entities and business operations and data in the system. The Execute method may take Request messages and return Response messages . Request messages may be instantiated and built by a client of the CRM web service . The caller may send the message to the CRM platform by calling the Execute method on the Web service . The message may be serialized into a SOAP packet by the client before being sent to the CRM web service and then deserialized back to the message object on the CRM Web platform. The message may then be sent to the server and processed there. The result of message processing may be returned to the caller of the Execute web method via a response message . Both request and response message content may be strongly typed allowing the caller to use a better development environment support when working with types. It also should be noted that SOAP is one of the available protocols for exchanging structured information in a decentralized distributed environment but that any appropriate protocol may be used.

At block the method may communicate a request message based on the selected operation. The communication may occur over any wired or wireless channel using a communication protocol appropriate for the channel chosen. As explained previously the method may take Request messages and return Response messages. Request messages may be instantiated and built by a client of the CRM web service. The caller may send the message to the CRM platform by calling the Execute method on the web service. The message may be sent via any transport protocol such as SOAP for example to the CRM server and gets processed there.

At block if the request message has a business entity type name as part of the request messages this will indicate to the user that the message is only valid for that specific Business Entity then the user may instantiate the request message filling the request message parameters at block and then sending the request message to the CRM server for processing at block .

At block if the request message is a common request message without any business type name in the request message name then a user may instantiate the request message. At block the user may discover supported target business entities by looking at the target class type and instantiate the target base class. At block the user may fill in the target class parameters to the request message. This approach ensures that the user can only execute supported operation on a given Business Entity at design time.

At block the method may add the target class to the request message and at block the method may execute the request message. The result of the execution may be returned to the caller of the Execute web method via a response message. Both request and response message content may be strongly typed allowing the caller to use a better development environment support when working with types. Of course this is just one way of executing the method and other ways are possible.

At block a user may instantiate a request message that has no references to any business entity neither in the request message name nor in the request message class. This type of message is business entity agnostic and may be used to execute generic operations that do not necessarily require any reference to a business entity. At block the method may fill in the request message parameters and then the request message may be sent to the CRM server for processing at block .

The API may be extended via new messages. As all the new messages are derived from the base Request and Response messages adding new messages does not require changing of the method signature. For example one version of CRM can have the ability to send an email by exposing the SendEmailRequest message and the later on add a new functionality to send a fax via a telephone line by simply adding a new message called SendFaxRequest. Both messages are derived from the base Request class and therefore do not require a change in the Execute method. Also the existence of class hierarchy may allow the serialization and deserialization of the messages to happen properly on both the client and server.

Polymorphism on the request message hierarchy may mean that the same interface can be used for multiple business entity types without the need of creating a new and separate interface for each business entity. For example a CreateRequest can be used to create new instances of different types of business entities via the same message and the same Execute method. This is one of advantages of message oriented approach.

Different types of messages may be defined in the system to satisfy different types of business operations that are provided in a business application. Some messages represent common operations and apply to most of the business entities in the system while some other messages are more targeted towards a specific set of business entities. A developer that uses a business application API may need to discover what business entities are supported on what business operation in the design environment and without making reference to documentation. The disclosed system may be addressed via Target classes and business entity Categories. Target classes may enable a developer to identify what messages are supported for which business entities. The business entities may be grouped under different categories based on the business operation that are supported by the category and for each group a Target base class is created.

 are named as TargetMerge. Create an instance of a class derived from TargetMerge that corresponds to a selected Business Entity.

The customization integration with the programming model may be seamless and consistent with the rest of the programming model. The CRM system may allow the users to add new business entities to the system. The addition of business entities to the system may automatically trigger generation of new types and messages in the service definition of the CRM web service and extends the hierarchy of messages. This may allow the developers to work with both original and customized strongly typed business entity classes and messages that accept these classes and enable execution of business logic and operation on them.

Another example of code to create and instance of a new business entity that already added as part of customization follows 

 User company FAB has created a custom business Entity in the system named fab Vendor. The user gets the same experience as working with system entities

The DynamicEntity class may extend the API beyond the strongly typed classes and may provide a generic and extensible way to work with business entities and execute their business logic. A user may decide to use the strongly typed business entities classes DynamicEntity format. A user also may decide to receive the results of the business operations execution in strongly typed BusinessEntities objects or DynamicEntity format. The benefit of DynamicEntity is that at the design time the user does not need to have fully described web service definition of the specific business entity type and can develop code that dynamically and at runtime discovers various defined business entities in a targeted CRM implementation and work with those entities execute operations without having their definitions at design compile time.

Although the forgoing text sets forth a detailed description of numerous different embodiments it should be understood that the scope of the patent is defined by the words of the claims set forth at the end of this patent. The detailed description is to be construed as exemplary only and does not describe every possible embodiment because describing every possible embodiment would be impractical if not impossible. Numerous alternative embodiments could be implemented using either current technology or technology developed after the filing date of this patent which would still fall within the scope of the claims.

Thus many modifications and variations may be made in the techniques and structures described and illustrated herein without departing from the spirit and scope of the present claims. Accordingly it should be understood that the methods and apparatus described herein are illustrative only and are not limiting upon the scope of the claims.

