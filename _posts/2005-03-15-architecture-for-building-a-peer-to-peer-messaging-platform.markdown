---

title: Architecture for building a peer to peer messaging platform
abstract: The claimed system is a multicast programming model for implementation on top of a service oriented framework, specifically a service oriented messaging system. It provides application-layer multicast capability without requiring an IP multicast infrastructure. The claimed system enables service oriented applications to implement multicasting communications easily and efficiently.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07912959&OS=07912959&RS=07912959
owner: Microsoft Corporation
number: 07912959
owner_city: Redmond
owner_country: US
publication_date: 20050315
---
The present invention generally relates to methods of enabling application level multicast functionality on a service oriented messaging system.

Unicasting is communication of a single message between one sender and one receiver over a network while multicasting involves sending a single message from one sender to a group of receivers where members of the group may assist in propagating the message to other members. TCP IP has been a dominant de facto unicast protocol standard. However multicasting technologies over TCP IP are being developed. Currently IP multicasting is supported at the data link layer and physical layer by hardware such as routers and network cards and by the network layer with rudimentary protocols such as IP. However the network and data link layer alone do not provide high level applications the means for implementing complete multicast functionality without having to design from scratch specific IP interfaces. Thus an upper layer application level multicasting framework may be extremely useful in developing multicast applications especially application level frameworks that do not rely solely on lower layer protocols for functionality.

Currently some applications provide multicast like functionality such as chatting and gaming applications however these applications are not true multicast as they remain broadcast based i.e. they rely on a server to broadcast a message to all receivers. Any message propagation using this process involves a client sending a message to the server and then the server application in turn broadcasting a separate message to each and every client connected to the server. If there are thousands of clients even low bandwidth applications may overload a network. Moreover multicasting applications that do utilize multicast functionality over TCP IP are written using unmanaged code.

Furthermore with the advent of service oriented application frameworks that rely on messaging capabilities a multicast framework may provide improvements to these service oriented models. For example service oriented frameworks are based on the provision and consumption of services through a negotiated messaging process which deviates from the object modeling application systems which relies heavily on passing hard coded objects and classes. While existing service oriented frameworks provide for basic unicast messaging between services they do not provide multicast functionality. Because such service oriented frameworks such as Microsoft Indigo critically rely on a messaging system for consumption of services multicast functionality on top of this framework and in conjunction with this framework could assist application developers in developing multicast applications such as peer to peer applications.

The claimed system is a multicast programming model for implementation on top of a service oriented framework specifically a service oriented messaging system. It provides application layer multicast capability without requiring an IP multicast infrastructure. The claimed system enables service oriented applications to implement multicasting communications easily and efficiently. Moreover the claimed multicast method and system of the claims provides management processes for creating and maintaining mesh topologies for peer to peer applications that may enhance multicast processes. Some of these processes may include a channel monitoring and delivery service a flooding and filtering service an advertising service a connection maintenance service a cross domain Internet wide mesh capability and a serverless peer resolution service.

Although the following text sets forth a detailed description of numerous different embodiments it should be understood that the legal scope of the description is defined by the words of the claims set forth at the end of this patent. The detailed description is to be construed as exemplary only and does not describe every possible embodiment since describing every possible embodiment would be impractical if not impossible. Numerous alternative embodiments could be implemented using either current technology or technology developed after the filing date of this patent which would still fall within the scope of the claims.

It should also be understood that unless a term is expressly defined in this patent using the sentence As used herein the term is hereby defined to mean . . . or a similar sentence there is no intent to limit the meaning of that term either expressly or by implication beyond its plain or ordinary meaning and such term should not be interpreted to be limited in scope based on any statement made in any section of this patent other than the language of the claims . To the extent that any term recited in the claims at the end of this patent is referred to in this patent in a manner consistent with a single meaning that is done for sake of clarity only so as to not confuse the reader and it is not intended that such claim term be limited by implication or otherwise to that single meaning. Finally unless a claim element is defined by reciting the word means and a function without the recital of any structure it is not intended that the scope of any claim element be interpreted based on the application of 35 U.S.C. 112 sixth paragraph.

The blocks of the claimed method and apparatus are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the methods or apparatus of the claims include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The blocks of the claimed method and apparatus may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The methods and apparatus may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the blocks of the claimed method and apparatus includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

According to the OSI model the process of communication between two end points in a telecommunication network may be divided into layers with each layer adding its own set of special related functions. A communicating computer may be equipped with these seven layers of function. In communicating a given message between users there may be a flow of data through each layer at one end down through the layers in that computer and at the other end when the message arrives another flow of data up through the layers in the receiving computer and ultimately to the end user or program. The actual programming and hardware that furnishes these seven layers of function is usually a combination of the computer operating system applications Transmission Control Protocol TCP Internet Protocol IP or alternative transport and network protocols and the software and hardware that enables a signal to be placed on one of the lines attached to the computer.

OSI divides communication into seven layers. The layers are in two groups. The upper layers are used whenever a message passes from or to a user and the lower layers are used when any message passes through the host computer. Messages intended for this computer pass to the upper layers . Messages destined for some other host are not passed up to the upper layers but are forwarded to another host. The seven layers are briefly described as follows.

The physical layer defines the physical characteristics of the interface such as mechanical components and connectors electrical aspects such as voltage levels representing binary values and functional aspects such as setting up maintaining and taking down the physical link. Well known physical layer interfaces for data communication include serial interfaces parallel interfaces and the physical specifications for LAN systems such as Ethernet and token ring.

The data link layer defines the rules for sending and receiving information across a physical connection between two systems. Data links are typically network segments not inter networks and point to point links. Data is packaged into frames for transport across the underlying physical network. Some reliability functions may be used such as acknowledgment of received data.

The Network Layer provides inter networking services that deliver data across multiple networks. An internetwork addressing scheme assigns each network and each node a unique address. The network layer supports multiple data link connections. In the Internet Protocol suite IP is the network layer internetworking protocol.

The Transport Layer provides end to end communication services and ensures that data is reliably delivered between those end systems. Both end systems establish a connection and engage in a dialog to track the delivery of packets across a network. The protocol also regulates the flow of packets to accommodate slow receivers and ensures that the transmission is not completely halted if a disruption in the link occurs. Transmission Control Protocol TCP may be a transport layer protocol.

The Session Layer coordinates the exchange of information between systems by using conversational techniques or dialogs. Dialogs are not always required but some applications may require a way of knowing where to restart the transmission of data if a connection is temporarily lost or may require a periodic dialog to indicate the end of one data set and the start of a new one.

The Presentation Layer contains protocols that are part of the operating system and application the user runs on a workstation. Information is formatted for display or printing in this layer. Codes within the data are interpreted and data encryption and translation are also handled in this layer.

The Application Layer provides defined procedures for accessing the underlying network services. The application layer is used to define a range of user applications.

While multicasting technologies are being developed for the lower levels of the OSI model i.e. the transport networking layers the claimed system focuses in on providing an application level programming model for implementing multicasting at the upper levels of the OSI model. Thus using the method and system of the claims a developer may implement multicasting functionality without requiring an IP multicast infrastructure. Moreover the claimed system may improve a services oriented programming model which is described below.

Service orientation may differ from object orientation primarily in how service oriented frameworks define application. Object oriented development may focus on applications that are built from interdependent class libraries whereas service oriented development may focus on systems that are built from a set of autonomous services. A service may simply be a program that one interacts with via message exchanges. However unlike existing distributed object technologies services may interact with their clients only through a well defined XML interface. Behaviors such as passing complete classes methods and calls across service boundaries may not be allowed. Thus application developers and system integrators may not require specific knowledge of the underlying object models type systems and protocols of the software being integrated.

Instead of integrating disparate applications via direct object activations as in distributed object systems applications may expose a set of services that other applications can utilize. Applications utilizing the services framework may expose their services using standards based protocols and policy definitions that can be dynamically acquired. This uncoupling of the applications that make up connected systems may enable simpler integration more flexibility in adapting systems to changes over time and also may enable more reliable operations.

Existing service oriented programming models may implement an existing upper OSI level messaging service such as Simple Object Access Protocol SOAP . SOAP may operate as an upper level OSI service that provides a schema for messages. One possible embodiment of a messaging system that utilizes the SOAP protocol is illustrated in . The illustrated messaging architecture hereinafter Message Bus may be viewed as an application programming interface API for simplifying the development and maintenance of a SOAP node. The claimed system and method may be implemented on any service oriented model providing basic upper level message handling but for the purposes of demonstration the claimed method and system will be described using the Message Bus illustrated in .

As illustrated in the Message Bus networking layer and transport may consist of any of the typical transport layer networking layer protocols in existence. TCP IP is a popular transport layer networking layer protocol and may not need to be IP multicast enabled which is an advantage of using the application level multicast system of the claims. The transport layer may encapsulate a networking mechanism such as an IP socket or named pipe or any mechanism by which data may be communicated. Message Bus transports may translate messages into actual bytes to be communicated on the wire via the data link and physical layers.

Moving up to the Presentation Session Layer a port object may represent a configurable logical conduit for messages. Each port object has a collection of transports that the port uses to translate logical messages into actual network communication. Ports are internally implemented as a pair of pipeline objects a send pipeline and a receive pipeline . Each pipeline may support pluggable message handlers not shown constituting port extensions which can inspect and manipulate messages traveling along the pipeline. A typical node in an application using the Message Bus may instantiate only a single Port object although it is possible to create more than one. The remainder of this description will refer to ports in effort to assist the user conceptualize the description but the use of ports may not be necessary in a modern message bus architecture.

At the application layer application code may send messages to a port object via a channel object . Channel objects come in a variety of embodiments which may be narrowed down to two sets send channels and receive channels. A single channel class may also implement both a send and a receive channel.

The Message Bus may support a variety of channel implementations to allow for a variety of message exchange patterns. For example a simple channel for one way datagram style messages may just represent an ultimate receiver. On the other hand a more complex channel may support correlated two way messaging reliable messaging or message durability across executions of the application. The channel is the first point at which a Message object created by application code may be handed to infrastructure code e.g. IP and from the perspective of the application code the channel is the first point of extensibility in the Message Bus architecture.

The general process of sending and receiving a message using the Message Bus Framework may be as follows.

At this point the message has left the SOAP node and has entered a network cloud. Until the message reaches the next SOAP node in its journey the message is no longer subject to the Message Bus or SOAP. Instead the message may be a stream of bytes passing through a networking protocol such as TCP IP or HTTP.

At some point the bytes of the message reach a listening node on the network that is a SOAP node. The following may take place at the listening node.

While the Message Bus framework provides a basic mechanism for implementing services using a service oriented framework there is no provision for enabling multicast functionality. The claimed method and system builds upon such a service oriented Message Bus architecture to provide developers the capability of building on top of the service oriented model to add multicasting functionality to their applications.

The claimed system and method may implement a particular multicast topology known as a mesh. illustrates a possible mesh topology. Generally a member of a multicast group may be referred to as a node and the group may be considered a mesh and is represented by a set of nodes that are interconnected to each other using communication channels e.g. . Each node in the mesh may be able to communicate a message to each and every other node in the mesh through a propagation process in which each message sent by one node e.g. node is passed on to neighboring nodes which continue passing them on to their neighbor nodes until each node receives the message. When a node has multiple connections it may receive a message and make copies of the message for sending along each channel connected to it. Because the direction of propagation generally flows away from the message sender and resembles physical flooding the propagation of messages using multicasting is generally called flooding. Each node in a multicast mesh may receive and be knowledgeable of any messages flooded on the network i.e. what one node knows via a flooded message every node in the mesh knows. Accordingly it may be beneficial to have a mesh of a reasonable size or rules regarding when messages should continue to be flooded.

A peer node may be associated with an instance of an application coupled to a mesh . A peer channel may be considered a specific channel to a peer node for communication between an application or service in service oriented language and a mesh via a peer node of the mesh. An application may create a node but a node cannot create an application. The application may create multiple nodes and each node may host multiple services. For example consider a Chat application. The Chat application may create a node in a mesh called ChatMesh. It may create two different services VideoService and TextService. Any text messages sent may be delivered to TextService and any video messages sent may be delivered to VideoService.

When initially connecting to a mesh a peer node may connect to another peer node e.g. that is already connected to the mesh. The connecting peer node may determine the address of the neighbor node connected to the mesh and send the neighbor node a solicitation to join the mesh. After connecting to the mesh the new peer node may create connections to additional neighbors e.g. within the mesh.

The purpose of a mesh may be to create a logical topology for the flooding of messages to all mesh nodes. To automatically achieve the optimal topology for flooding the mesh may maintain a signature a set of contact nodes and evaluates duplicate flooded messages to determine which neighbors are more efficient. Over time connections may be created and removed so that the mesh converges to a topology that is optimal for flooding.

When a node disconnects from a mesh it may potentially create a break in the mesh known as a mesh partition. Peer nodes use a mesh signature to be described below and mesh contact information to detect and repair a graph partition.

The peer channels may be communication channels that send and receive between the application and a peer node . They may appear to the application as multicast channels without requiring an IP enabled multicasting infrastructure. Each peer channel may be associated with a peer node . The peer node may be responsible for implementing the mesh algorithms e.g. optimization partition detection and repair and flooding messages throughout the mesh. Each peer node may provide its own service called a node service which interacts with a set of neighboring node services using reliable Message Bus channels. This node service may be implemented on top of the service framework and uses reliable channels over TCP and HTTP transport for example.

Messages sent on a peer channel may be destined to a particular service offered by another node in the mesh. Every node in the mesh may receive a copy of each message sent on the mesh. When a node receives a message it may deliver it to any associated peer channels which implement the message s intended service. In order to propagate the message to each node in the mesh the originating node may send the message to each of its neighbors. Those neighbors may pass it on to their neighbors and so forth. The actual flooding algorithm is described below.

An application message may be tunneled from one neighbor peer node to another for example by encapsulating the application message or inner message in another outer message addressed to the node s neighbor. A new outer message may be created per neighbor. In this way the original message including its destination service address may remain unchanged from node to node. All nodes may be reachable from all other nodes. To the extent to which this is not true e.g. nodes being behind untraversable firewalls the resilience of the mesh degrades.

A PeerChannelFactory may be responsible for spawning PeerChannels . The PeerChannelFactory may also maintain a collection of active channels that it creates. The PeerChannelFactory may not be directly associated with a PeerNode but looks them up or creates them as required.

A PeerListenerFactory object may be responsible for spawning PeerListeners . The PeerListenerFactory manages the active listeners and maintains a collection of active channels that the listeners have spawned. A PeerListenerFactory may be associated with exactly one PeerNode .

A PeerNode may represent a node in a mesh and contains its associated configuration. The PeerNode may be the owner of all the internal components which implement the node. This class may also contain static methods for looking up existing nodes.

A Neighbor may contain an underlying neighbor channel and tracks the state of the channel. The Neighbor may expose methods for communicating with the neighbor node.

A NeighborManager may contain a collection of Neighbors . The NeighborManager may expose events which are aggregates of all Neighbors e.g. MessageAvailable . This object may provide the implementation of a peer node service.

A Connector object may handle sending and receiving connection messages CONNECT WELCOME REFUSE DISCONNECT .

A Maintainer object may implement the mesh maintenance algorithms. The Maintainer may contain the mesh signature collection of known mesh nodes and collection of current mesh contacts.

A Synchronizer may coordinate a light weight contact signature synchronization protocol over a neighbor channel.

A mesh may be identified by a name or a mesh ID. A mesh ID is a valid hostname e.g. soccerpals that may be resolved to an IP address e.g. 123.12.123.12 . An address of a service on the mesh may be designated by a uniform resource identifier URI and is specified using the peer channel schema prefix net.p2p a mesh ID a path and a service name e.g. net.p2p soccerpals path service . An EndpointAddress structure may be used to reference services in a mesh and may consist in part of at least one URI.

Generally anytime a service or client desires to communicate with a mesh that service or client may be required to communicate through a PeerNode of the mesh. Specifically services may be associated with a PeerListenerFactory and clients may be associated with a PeerChannelFactory. This process may involve an application first creating and opening a PeerChannelFactory. The PeerChannelFactory may be instantiated as an object within the application and therefore may be associated with the application. Next a PeerChannel may be created by calling a method on the PeerChannelFactory which may be called CreateChannel. The PeerChannel may then check to see if there is an associated PeerNode . If there is an associated PeerNode the PeerChannel may connect to that PeerNode and open the PeerChannel and begin receiving and sending messages . Otherwise if there is no existing PeerNode the PeerChannel may create a new PeerNode open the PeerChannel e.g. by calling an OPEN function on the PeerChannel and passing in an EndpointAddress and open the new PeerNode .

In opening a new PeerNode the PeerNode may call a Resolver object which is responsible for providing a name resolution service. There may be numerous Resolver methods including RegisterMeshID UnregisterMeshID etc. The Resolver method may implement a custom name resolution service or may use a Message Bus provided resolution service such as Peer Name Resolution Protocol PNRP . The newly created PeerNode may call the Resolver to register a node service which is a service that is uniquely provided by each PeerNode for internal implementation purposes. This node service may be different from the application service that initiated the creation of the new PeerNode or that initiated the connection to an existing PeerNode. By registering with the Resolver other nodes may obtain a reference to the newly created PeerNode via its node service reference.

In addition to registering its node service a PeerNode may query the Resolver for other nodes in the mesh . Without calling the resolver s ResolveMeshId method a node may not know if there are other nodes in the mesh unless one of the other nodes initiates a connection to this node . If there are no other nodes the PeerNode may raise an indication to the PeerChannel which raises an alert to the Application. If there are other nodes the PeerNode may calls its Maintainer object to resolve the mesh ID into a EndpointAddress of a remote node service. Once the EndpointAddress is obtained the NeighborManager may be used to create a NeighborChannel to the NeighborNode . Once the NeighborChannel is created a connection may be attempted by sending a CONNECT message . If a WELCOME message is received the PeerNode may be opened and online and a synchronization process begins. If the REFUSE message is received the PeerNode may attempt additional connections. If the PeerNode does not find or connect to any other nodes the PeerNode may set itself to an offline state otherwise the PeerNode may be online and may receive and send messages .

Generally the process above may be similar for a PeerListener process except for the initial channel creation block. When dealing with a service that is only interested in communicating with the mesh after being solicited by a message targeted to that service the service may create and open a PeerListenerFactory instead of a PeerChannelFactory. The PeerChannel may then be used to create a PeerListenerFactory. When the first message is received by a PeerNode matching the filter criteria the PeerListener may spawn a PeerChannel. Once the PeerChannel is created two way communications may be made similar the process described above. A PeerListener however may also be configured With a message filter such that it only notifies the application for messages matching the filter criteria.

When the application wants to flood a message it may communicate with a PeerNode through its PeerChannel. The peer channel may notify the application whenever a message is available for it. Alternatively if the implementation uses a PeerListener the PeerListener may generate a PeerChannel and notify the application that a message has been received for it. Once a PeerChannel is created the application may receive and process it.

Each PeerNode may have a single associated NeighborManager. The NeighborManager may be limited to a delivery and reception role and may be tasked with maintaining a list of all its immediate neighbors i.e. PeerNodes directly connected to it and for collecting messages directed to it and sending messages from the PeerChannels that belong to a PeerNode.

If the current number of neighbors is greater than or equal to a maximum value described further in Mesh Maintenance section below a REFUSE message may be sent back to the neighbor with a short list of neighbors and or other known nodes and the channel is closed . Otherwise a WELCOME message may be sent with a short list of neighbors and or known nodes .

If the channel has not been closed by the above process the nodes may exchange ADVERTISE messages that may contain the services advertised on each node .

When a neighbor connects to another node on the mesh the current state of the mesh may be required to be synchronized to ensure that all nodes share the same view of the mesh. This state includes a list of mesh contact nodes along with a mesh signature which is used for internal mesh maintenance functions to be described below .

Peer Synchronizer may be a component of a PeerNode that is responsible for running the synchronization protocol between a pair of neighboring nodes. The synchronization process may involve the following steps which are illustrated in . At block when a neighbor transitions to Connected state the initiating Synchronizer may start the sync process by sending a SyncRequest message. The SyncRequest message may contain a list of abstracts of the contacts in the Maintainer s contact cache and the signature. Each contact abstract may contain the node ID of the contact node and the version number of the contact. For a new node this list may be empty.

At block upon receiving the SyncRequest message the responding Synchronizer may hand over the list of abstracts to a Maintainer. The Maintainer may implement the mesh maintenance algorithms and may contain the mesh signature collection of known mesh nodes and collection of current mesh contacts. At block the Maintainer in turn may compare the abstract list with the contents of its contact cache. At block the Maintainer may build a list of contacts that are present in its cache but missing from the abstract list i.e. the initiating node does not have them and adds the contacts that are newer than the ones in the abstract list. At block an updated abstract is created. Any contacts that are missing from the responder s cache are added or if the responder has an older version the Maintainer may add them into a new updated abstract list. At block the contact list the signature and the new abstract list may be returned to the Synchronizer.

At block if the abstract list returned by the Maintainer is non empty control may pass to block where the responding Synchronizer sends its own SyncRequest message with this abstract list and the Signature. At block the Synchronizer may send a series of SyncData messages with the contacts. The final contact chunk and the signature may be are sent in the SyncEnd message. If at block the abstract list returned by the Maintainer is empty the Sychronizer may not send its own SyncRequest and control may pass to block .

At block on the initiating side a determination may be made whether the initiating side sent a SyncRequest of its own. If the initiator did not send a SyncRequest the end of synchronization process may be signaled at block when all the SyncData and the SyncEnd messages are sent. If the initiator did send its own SyncRequest the synchronization process may end when and when the SyncEnd message is received at block .

At block on the responding side a determination may be made whether the responding side sent a SyncRequest of its own. If the responder did not send a SyncRequest the end of synchronization process may be signaled at block when all the SyncData and the SyncEnd messages are sent. If the responder did send its own SyncRequest the synchronization process may end when and when the SyncEnd message is received at block .

For all flooded messages the inner message may be extracted from the outer tunneling message . The PeerNode may call the Flooder to determine if the inner message has been seen before . If it has the message may be closed and processing is complete . If the inner message has not completed propagating through the mesh i.e. the message should be flood further further processing may occur.

If the inner message is an internal message for processing mesh functions a PeerNode may forward the message to its correct internal node object e.g. Maintainer . These components process the message as described further below. For signature messages the Maintainer may determine that the message should stop flooding further at which point the message is closed and processing may be complete . Otherwise the inner message s ID may be added to the Flooder s message table and the inner message may be re encapsulated by the Flooder into another outer tunneling message and sent to all neighbors except the neighbor from which the original message was received .

If the inner message is an application message the PeerNode may search for a channel object e.g. a PeerChannel or a PeerListener associated with the message s destination service. If a matching PeerChannel is found the message may be sent to the application service associated with the PeerChannel. Otherwise if a matching PeerListener is found a new PeerChannel may be created to the application service by calling AcceptChannel or BeginAcceptChannel and the message may be sent to the corresponding application.

If the inner message is not an application message the inner message s ID may be added to the Flooder s message table and the inner message may be re encapsulated by the Flooder into another outer tunneling message and sent to all neighbors except the neighbor from which the original message was received . Additional flood pruning logic may be implemented in this process as well . For example some applications may implement a propagation filter interface object which may be called a IPeerMessagePropagationFilter interface associated with the Flooder to determine if a message should be flooded further. If the Flooding filter interface determines that there should be no further flooding processing is complete .

The following are events that may occur in which a portion of the mesh may be disassembled or closed.

Neighbor Initiated Disconnect If a neighbor disconnects cleanly the neighbor may send a DISCONNECT message. This message may be handled by the Connector which closes the neighbor channel. When the neighbor channel closes either abruptly or via a formal disconnect process the NeighborManager may notify the other internal node components. The Maintainer may handle this event by performing a mesh maintenance algorithm described below . The PeerNode may handle this event by notifying the application that the services advertised by the remote node are no longer available. If this was the only neighbor connection the node may now be offline.

PeerNode Initiated Disconnect A neighbor may be disconnected locally e.g. by the PeerNode either because the peer node is closing or because the Maintainer chooses to prune the connection. When a neighbor is closing the local components may be notified. The Connector may handle this event by sending a DISCONNECT message to the neighbor. Once the Neighbor is closed the application may be notified that the remote node s advertised services are no longer available.

Closing a PeerChannel When a channel is closed it may be removed from the owning factory s channel collection and the reference to the associated PeerNode is released.

One advantage of the claimed mesh system is that it may allow an application to use the mesh to locate services which the application can then consume. In order to enable access to the services offered by various nodes on the mesh applications may need to first retrieve information about its neighbors. In particular an application may need to be able to enumerate services advertised on its neighbors.

To advertise a local service to neighbor nodes the application may call an AddAdvertisedAddresses function of the PeerNode specifying the local application service s EndpointAddress. This may cause the Maintainer to add this service to its currently advertised list and send an ADVERTISE message to neighbors containing the updated advertised service list. Similarly an application may un advertise a service by calling a RemoveAdvertisedAddresses function of the PeerNode.

When the application advertises its service addresses this information is cached by the node and sent to neighbors. On receiving this information an event may be raised. This event may provide the application with the neighbor s node ID and all the EndpointAddresss advertised on that node.

By advertising the addresses of an application s services an application can open a channel directly to the neighbor s application service thereby enabling a private communication channel. To send a message to a neighbor rather than sending a message to the entire mesh the application may be required to retrieve the list of advertised services on the neighboring node and decide which service to send to. To find this list of services the application may call a function of the PeerNode to retrieve the advertised services which may be called GetNeighborAdvertisedAddresses which collects the cached service information. The method returns a collection of EndpointAddresss to services advertised on the neighboring nodes along with the neighbors node IDs.

The application may select one of these EndpointAddresss and may use a channel of the underlying Message Bus e.g. http tcp etc. not a PeerChannel to create a channel to the service. The application may use this channel to directly communicate off mesh with the neighbor s service.

The values for cIdealNeighbors cMaxNeighbors and cMinNeighbors may depend on a variety of factors including mesh size and mesh traffic. Because a cMinNeighbors value of one may cause a complete separation if the one and only connection is lost a cMinNeighbors value of at least two may be appropriate for any mesh. A high value of cMaxNeighbors may mean that a particular node is doing a very disproportionate amount of flooding on behalf of other nodes. A cIdealNeighbors value between cMinNeighbors and cMaxNeigbors may be based on good redundancy with minimum overhead.

Each node in the mesh may attempt to maintain the most useful set of connections as possible where a connection s usefulness may be determined by the amount of unseen messages sent on it in either direction . Periodically when a node has more than the cIdealNeighbors it may disconnect the least useful connection .

Each node may have a node ID which is a random 64 bit number. The mesh has a signature which may be computed as the lowest node ID present in the mesh. The computation may be done by having the node with the lowest node ID publish its ID as the signature. However a node may not directly know that it has the lowest ID so all nodes may attempt to publish their ID. A node may not publish if the mesh signature is already lower than their ID. Also each node may have a backoff period before publishing which may be exponentially proportional to its node ID thereby helping to reduce the number of incorrect signature publications.

The mesh may have a set of contact nodes which may be responsible for periodically publishing the signature of the mesh as they see it. Whenever a node s view of the mesh signature becomes out of sync with the view that the contacts publish the node may know that the mesh has been partitioned and may attempt to reconnect after a random backoff period to one of the contacts that is out of sync. There is a small chance that this procedure may not detect a partition. To mitigate this contact nodes may periodically attempt to resolve the mesh ID to a new random node and form a connection.

From the above description the method and system of the claims may enable an application developer using a service oriented application framework to integrate multicast functionality with ease and convenience using the peer node objects. Using this framework services having multicast functionality may be created without concern for TCP IP or other underlying lower level communication protocols because the peer node objects manage messaging using whatever protocol is available. An advantage of this system may be that meshes may be created that span the entire Internet whereas multicast IP requires certain multicast IP enabled segments of the Internet e.g. the Mbone in order to operate. The claimed system also provides an application based filtering mechanism in which the flow of messages may be intelligently controlled using filter interfaces e.g. message suppression may be useful in making the mesh more efficient and secure which an IP multicast solution does not provide.

Further because the claimed system is built on top of a services oriented framework application developers may not need to concern themselves with programming from scratch a multicast solution they may only need to worry about what multicast functionality they would like to implement as part of their services. The peer node object model provides a base infrastructure so that developers can concentrate on developing multicast enabled services.

Although the forgoing text sets forth a detailed description of numerous different embodiments it should be understood that the scope of the patent is defined by the words of the claims set forth at the end of this patent. The detailed description is to be construed as exemplary only and does not describe every possible embodiment because describing every possible embodiment would be impractical if not impossible. Numerous alternative embodiments may be implemented using either current technology or technology developed after the filing date of this patent which would still fall within the scope of the claims.

Thus many modifications and variations may be made in the techniques and structures described and illustrated herein without departing from the spirit and scope of the present claims. Accordingly it should be understood that the methods and apparatus described herein are illustrative only and are not limiting upon the scope of the claims.

