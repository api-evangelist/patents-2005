---

title: Systems and methods for an enterprise services framework using a state model
abstract: Embodiments consistent with the principles of the invention check, before the data underlying a changed primary object is persistently save, for related objects whose data is also affected by the change. The related objects may be two or more degrees removed from the primary object. The changed primary object and all its changed related objects are then persistently saved together, so that the saved data is consistent across the related objects. Embodiments consistent with the principles of the invention also provide a state model for controlling access to services by clients and for making services available by servers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07844615&OS=07844615&RS=07844615
owner: SAP AG
number: 07844615
owner_city: Walldorf
owner_country: DE
publication_date: 20051219
---
The present invention relates to maintaining databases and more particularly to maintaining database consistency in a multi object client server service oriented architecture system.

The front ends of most business applications presents and accepts information in a user friendly fashion. A business application is typically designed with a graphical user interface GUI that displays information by mimicking something a user is accustomed to seeing and working with such as a business form a shipping label or a questionnaire. Beneath the GUI level however the information may be organized far differently than its manner of display might suggest. For example displayed information may be organized into several object oriented programming OOP objects which may in turn have several OOP objects dependent on related to or connected to them for example via method calls. Further and at a more basic level each of the OOP objects may store its data in several different database rows contained in several different database tables and this data may be interdependent interrelated or interconnected in some manner for example through shared data shared tables foreign keys etc.

These layers of objects and their associated database entries are difficult to correctly update and maintain because any relevant interrelated and interdependent objects and thus their underlying database data should be changed as needed for consistency whenever an object is changed. Similarly changes to an object and its data should be prevented if relevant interrelated and interdependent objects and data cannot be changed as needed to maintain synchronization between related objects and data. This is difficult to do in systems where the user and to a lesser extent the front end application typically has no awareness of the layers of objects and database entries connected to the information displayed entered and manipulated on the GUI. For example in service oriented architectures the front end application typically interacts through service requests with a backend that maintains the objects and databases. The services are typically self contained and do not depend on the context or state of the other services and thus may access the same underlying objects and databases used by other services at the same time as other services destroying the synchronization among objects and among data.

Database transaction processing systems face a somewhat similar problem where a single transaction can update many different databases. Such systems often use a two phase commit to help address the problem which enables the databases to be returned to the pre transaction state if some error condition occurs. The two phase commit strategy is designed to ensure that either all the databases are updated or none of them so that the databases remain synchronized. In a two phase commit database changes required by a transaction are initially stored temporarily by each affected database. The transaction monitor then issues a pre commit command to each database which requires an acknowledgment. If the monitor receives the appropriate response from each database the monitor issues the commit command which causes all databases to simultaneously make the transaction changes permanent. Otherwise all the temporarily stored changes are rolled back and discarded. The two phase commit strategy however only applies to the database operations that are part of a transaction which are not based on relationships between OOP objects. Thus a two phase commit does not solve all the problems associated with multidatabase transactions. For example it does not address finding and changing additional objects and database entries that are related to or dependent from another object.

Accordingly it is desirable to provide systems and methods for finding and changing objects and their underlying data that are related to or dependent on an object that is changed by a user application maintaining consistency among all the related objects and their associated data. It is also desirable to provide a clear framework defining the times at which object modifying services can be requested and the times at which object modifying services must be provided.

In accordance with the invention embodiments provide methods systems and computer programs for saving business objects comprising components and operations for receiving a modified business object determining a set of related business objects traceable from the modified business object modifying the set of related business objects based on a modification of the modified business object determining whether both the modified business object and the modified set of related business objects can be saved and saving both the modified business object and the modified set of related business objects upon a determination that both can be saved.

Other embodiments consistent with the invention provide servers systems and computer programs for saving business objects comprising components and operations for receiving a save request specifying a business object to be saved entering a software controlled state in which receiving a service request will cause failure processing to occur identifying a set of related business objects affected by data in the business object to be saved modifying data in the set of related business objects to be consistent with the data in the business object to be saved sending a plurality of pre save checks to at least one database manager for the data in the business object to be saved and the data in the set of related business objects committing the data in the business object to be saved and the data in the set of related business objects to at least one database controlled by the at least one database manager and exiting the software controlled state in which receiving a service request will cause failure processing to occur.

Additional embodiments and advantages of the invention will be set forth in part in the description which follows and in part will be obvious from the description or may be learned by practice of the invention. The advantages of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the appended claims.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention as claimed.

Reference will now be made in detail to exemplary embodiments of the invention examples of which are illustrated in the accompanying drawings. Wherever convenient the same reference numbers will be used throughout the drawings to refer to the same or like parts.

In one embodiment consistent with the invention communication between the client and server is broken down into core services which are organized based not on the business objects they affect but on the service they provide. Information about the affected object s is part of the signature of a core service method. For example the business object name the node name and a list of associated entities may be part of such a signature.

In a broad sense business objects are objects used in business applications. More precisely the data often called business data because it relates to business transactions and parties such as customers orders and the like of a business system such as is illustrated in may be organized into business objects. For example the SAP OLTP R 3 business system uses such data to form business objects Bdocs that are used as data containers for further processing. Considering a product order by way of example a business object may contain for a particular product order all the data associated with the order irrespective of what form the logical structure of the data takes in storage such as in the tables of a relational database s such as an SAP OLTP DB database. The logical structure is known to a back office business system such as OLTP R 3 which can access the data underlying the business objects.

Different business objects may interact with the same database as shown by the connections to database B in and may interact with each other by sharing the same data from an underlying database. Business objects may also interact more directly with each other for example via a method call from one business object that causes a change or reaction in another business object.

There are often connections and chains of connections between two three or more business objects. As they are used business objects interact with each other and changes or modifications to one business object often necessitates changes or creates side effects to other business objects. For example when a new customer calls a company to order a product the company may create a new purchase order business object such as purchase order business object to encapsulate and represent the order data. During the same order taking process the company may also create a new customer business object such as customer business object to encapsulate data about and represent the new customer including customer data referenced and used by the purchase order object such as the customer s address telephone number and billing terms e.g. payment in full due in 90 days or one half payment due at time of order and the balance due on delivery . Because of the interconnections between the two objects changes to the purchase order object may necessitate changes to the customer object and vice versa.

These interconnections and interdependencies between business objects can create difficulties maintaining the objects including difficulties at runtime at the database implementation level. For example if business object data is stored in multiple databases as shown in and or if more than one front end client application only one is shown in are trying to simultaneously access the same business objects and or databases and or related business objects and their underlying data then it is difficult for a back end application to ensure that the data in the business objects and databases are accurately and consistently maintained during accesses from various sources and that access occurs at the proper time among various applications.

Systems methods and computer software consistent with principles of the invention may synchronously update related business objects when a subject business object is updated including related business objects that may be several degrees removed from the subject business object helping to solve such difficulties. Further such systems methods and computer software may prevent conflicting access to business objects and their underlying data. In one embodiment a state model implementation may be used to control access to business objects and determine when a requesting application or related object may read or write an object s data without conflicting or interfering with the access of other applications or objects to the same data.

For example if front end client application tries to modify purchase order business object in a manner that would also result in a modification to data in database C associated with customer business object the modification may be prevented at runtime if another client application not shown is already in the process of modifying the same data in database C . Front end client application s access to the data in database C may be permitted after the other client application s not shown access is completed and the data is stable.

Next the process identifies a business object affected by the new data step . For example the process may determine that a purchase order business object must be created to process the new order data that was received.

Next the process updates a local copy of the business object in a local transaction buffer based on the new data step . For example the process may use the new data to populate a new purchase order business object or to update a local copy of an existing purchase order business object whose data was just fetched from a database. In one implementation the transaction buffer is not a persistent database it is a local holding area.

The process then determines whether another business object s is affected by the new data or the processing of the business object step . In one embodiment an application uses change notifications to assist with this determination creating a notification with the key of the data that is also affected and the determination is done at the business object level. If another object is affected step Yes the process retrieves for an existing object or creates if a new business object is needed a local copy of the affected business object and loops up to update the copy of the additional affected object based on the new data. This updating may include changing the value of some of the data in the additional affected object to be consistent with the data in the other updated business objects. For example if the new data received is for a new customer then a customer business object may have to be created in addition to the purchase order or if the new data received includes a product order then a manufacturing order business object for the factory may have to be created in addition to the purchase order. This loop may continue until all business objects connected to the new data are processed and data is consistent among them including processing business objects more than once to account for subsequent changes to related business objects during the loop.

After all affected business objects are processed step No then the process determines whether all the updated business objects can be permanently saved step . For example if the updated business objects store data in three different databases the three databases may be checked to determine whether the data associated with the local copies of the objects can be written into each of the databases at the current time. This may be the first phase of a two phase commit.

If one of the updated business object s cannot be saved step No then the process aborts in a defined way for example by performing cleanup processing. For example a business object may not be savable because of a technical reason such as the database being unavailable or a program crash or because of a process reason such as a customer object having no credit limit information or a purchasing specialist not entering an order limit for a specific purchase order.

If on the other hand all the updated business object s can be saved in databases or other permanent repositories for the business object data step Yes then the process proceeds to permanently store the data from all the local copies of the updated business object s in the appropriate repositories step such as committing the data to a database and ends.

The system begins operation in an idle state . In idle state the system is waiting for inputs such as service requests. From idle state the system may transition to another state or phase based on input s received while in idle state . As shown if the system receives an operation type input it will transition from idle state to operation state . Similarly if the system receives an retrieval op type input it will transition from idle state to retrieve state . Also similarly the system will transition from idle state to cleanup state if it receives a cleanup input and the system will transition from idle state to check save state if it receives a check or save input. In one embodiment if the system receives an input other than those defined to cause a transition to retrieve state operation state cleanup state check save state the system will transition not shown from idle state to failed state .

In one embodiment the inputs to the system that cause state transitions are client service requests. Refer for a moment to . is a table showing exemplary service requests sorted by category type for state or phase management of an embodiment of a system consistent with the invention. As shown the Retrieve RetrieveByAssociation Query and GetValueSet service requests are retrieval op type requests such as may cause a transition from idle state to retrieve state as shown in . In one embodiment Retrieve returns the data for a specified list of keys of a business object node. Retrieve may get a number of data sets for a number of keys. The operation may be designed to return exactly the requested data and the data may be specified by an exact key. A key is a positive identifier of a data set e.g. MaterialNumber is a key . A business object node collects datasets of the same type such as customer address. A business object may represent a form such as a purchase order with all its sub items and may be referred to as a business object nodes. RetrieveByAssociation returns the data for a specified list of keys of a business object node associated with another business object node. RetrieveByAssociation returns a various number of data sets or keys related to a data set e.g. all order items of an order where an order has several items related to it. RetrieveByAssociation processes a relation i.e. an association between different types. For example a parent child association also called composition in an object oriented environment an association between nodes within a business object or an association to other business objects which are typically the interconnections in a service environment e.g. a Purchase Order relates to Supplier Address . Query provides the result of a search request in a specific business object on a specific business object node which result may consist of a collection of keys only or a collection of data including the keys and GetValueSet returns a requested value set. For example an implementation for value help may return all possible values of an input field on the user interface which may be represented for example by a drop down list box. GetValueSet may return a set of keys of an attribute. For example a value help in a purchase order on the field Material may return a list of all materials which may be displayed in a drop down list box and clicking on an item of the drop down list box may select the item and copy it to the Material field.

An EndRetrieveOp service request is an explicit phase control request that causes a transition from retrieve state to idle state as shown in . As noted in comments column the EndRetrieveOp service returns different kinds of processes and other parameters such as messages and properties of the retrieved database data. In one embodiment EndRetrieveOp closes the data retrieval phase and returns various processes and parameters that have been accumulated since the last call of this service such as accumulated messages and dynamic properties. In other embodiments EndRetrieveOp may return other types of processes messages etc.

The Update Delete Create and Action service requests are operation type requests such as may cause a transition from idle state to operation state as shown in . In one embodiment Update updates the data of a list of specified keys in a transactional buffer Delete deletes the data and keys of a list of specified keys in the transactional buffer Create creates new business object node elements containing keys and data in the transactional buffer and Action executes an action on a specified list of keys of a business object node. In one embodiment the client has to ensure that all accumulated data changes have been sent before sending the Action service request.

An EndOperationOp service request is an explicit phase control request that causes a transition from operation state to idle state as shown in . In one embodiment EndOperationOp closes the data modification phase and returns various kinds of processes and parameters such as the messages and the change notifications based on keys that have been accumulated since the last call of this service.

The Check Save and Cleanup service requests are transaction type requests such as may cause a transition from idle state to cleanup state or Check Save state as shown in . As noted in comments column the save and check services various kinds of processes and parameters such as messages e.g. change notifications and properties. Check validates the accumulated data changes in the transactional buffer Save saves all accumulated data changes from the transactional buffer into the appropriate database s and Cleanup resets the transactional state by rolling back all the accumulated data changes. In one implementation consistent with the invention the save state includes a multi phase process for checking and changing related business objects before permanently saving changes.

In one embodiment consistent with the invention the services are implemented as interface methods. For example the transaction type services D may provide transaction control to client applications. Thus in one implementation of a remote client system the client application programming interface may contain a method called save which functions to persist all accumulated data changes. Or the client may trigger a complete reset of the transactional state in the back end by calling a cleanup method. Similarly a check method may trigger a validation of the complete transactional buffer. Such methods may also be called by processes within the back end. For example a cleanup method may be executed by a service manager if a commit or rollback has been processed in the backend within save request processing.

Referring again to in retrieve state the system executes the service requests Query Retrieve RetrieveByAssociation GetValueSet and EndRetrieveOp. As shown multiple retrieval op type requests such as Query Retrieve RetrieveByAssociation and GetValueSet may be executed during retrieve state without causing a transition to another state. A client application should use the EndRetrieveOp request to exit retrieve state and cause a return to idle state otherwise any following operation type or transaction type service requests may fail. If a client application submits an operation type service request an EndOperationOp service request a check service request or a save service request during retrieve state the system will transition to failed state as shown.

In operation state the system executes the service requests Create Update Delete Action and EndOperationOp. As shown multiple Operation type requests such as Create Update Delete and Action may be executed during operation state without causing a transition to another state. A client application should use the EndOperationOp request to exit operation state and return to idle state otherwise any following retrieval op type or transaction type service requests may fail. If a client application submits a retrieval op type service request an EndRetrieveOp service request a check service request or a save service request during operation state the system will transition to failed state as shown.

In failed state the system executes failure processing such as aborting any ongoing transactions. In the embodiment shown the system will not automatically perform further processing or transition to another state after any failure processing completes and the roll area cannot be reused. In one embodiment every user of the system has their own memory on a server that is protected against other users and this memory is called a roll area.

In cleanup state the system executes rollback processing as is known in the database arts. That is in response to a cleanup service request the system cancels the proposed changes in any pending database transactions such as those initiated by an operation type service request. The system automatically returns to idle state after the rollback processing completes.

In check save state the system checks and saves pending database transactions. That is the system permanently writes or persists database changes from a transactional buffer to the database s . In one embodiments front end clients should ensure that all pending updates have been sent to the back end server application before initiating the save operation with a save service request. The system automatically returns to idle state after the save processing completes.

Next the process receives the customer s information step . For example an operator may speak with a customer and type or otherwise enter information into a front end client application or a customer may speak or otherwise enter information into an interactive voice response client application or an interactive client application that recognizes touchtone telephone button entries. The information may include a wide array of data such as the customer s name address products or services the customer wishes to order method of payment information about existing orders billing information shipment tracking information delivery date information document numbers cancellation information etc. In an embodiment that uses a front end client application to implement the process of such as might be the case for the embodiment shown in the back end server application remains in idle state during this step of the front end client application process.

Using the information from the customer the process checks one or more databases using the customer supplied information step . For example a call center operator may enter a customer s name into a form on a graphical user interface GUI and activate a control to retrieve additional information associated with the customer s name from the organization s database s such as information regarding the customer s customer number address order history payment history credit line size shipping preference etc. In an embodiment that uses a front end client application to implement the process of such as might be the case for the embodiment shown in the back end server application transitions from idle state to retrieve state in conjunction with this step of the front end client application process because the front end client sends a retrieval op type client request D to the back end server application to fetch data about the customer from the database s .

Next the process receives any relevant business objects from the database s step . For example the process may receive a customer business object containing basic data about the customer such as name address telephone number customer number etc. The process may also receive related business objects such as business objects containing data about the customer s order history and payment history. In one embodiment the information from the business objects is displayed in a user friendly way on a GUI.

In an embodiment that uses a front end client application to implement the process of such as might be the case for the embodiment shown in the back end server application transitions from retrieve state to idle state in conjunction with this step of the front end client application process after retrieving the customer related data and objects or an indication that there is none from the appropriate database s . In idle state the back end server application transmits a server response to the front end client with the retrieved business objects if any . For example if the customer is new there will not be any relevant business objects in the organization s database. In one embodiment the front end client operation may sends a retrieval operation when a screen refreshes and sends an EndRetrieveOp after a retrieval operation is done which causes the transition back to idle.

The process then determines whether the customer is a new customer step based on the business objects received from the database s . For example if no business objects associated with the customer are received then the process determines that the customer is a new customer step Yes and proceeds to perform operations to create business object s for the customer step . In one embodiment the client application creates and works with business objects and the interface on the client side is object based. In this embodiment operations are done on these object instances. For example the process may create a customer object to contain basic information about the customer such as name address telephone number customer number etc. and it may create a purchase order object to contain information about products or services the customer called to purchase such as price quantity model number tax etc.

If on the other hand business object s associated with the customer are received then the process determines that the customer is an existing customer step No and proceeds to perform update operations on the customer s business objects that it received from the database step as appropriate. For example the process may update an existing customer object to change basic information about the customer if needed such as address telephone number fax number etc. Or the process may change an existing purchase order object to contain new information about products or services the customer had previously ordered such as a different order quantity a different model number tax etc. Or the process may create a may create a new purchase order object to contain information about products or services the customer called to purchase such as price quantity model number tax etc.

In an embodiment that uses a front end client application to implement the process of such as might be the case for the embodiment shown in the back end server application transitions from idle state to operation state in conjunction with steps or of the front end client application process because the front end client sends an Operation type client request to the back end server application to create delete update or perform some other action on a business object s and its associated data. Some embodiments consistent with the invention may automatically update business objects that are affected by a change initiated by a client application as well as the requested business object itself as explained previously. Other embodiments consistent with the invention may update business objects during the save state. Consistent with the invention an implementation may update any data in other business objects in the update state of a business object or before saving in a so called finalize state in the same way.

Next the process checks the success of the operation s on the business objects step . If any of the operations were unsuccessful then failure processing not shown may be required. In an embodiment that uses a front end client application to implement the process of such as might be the case for the embodiment shown in the back end server application transitions from operation state to idle state in conjunction with this step of the front end client application process after manipulating the customer related data and objects. In idle state the back end server application transmits a server response to the front end client containing messages and information about the changed customer business objects such as a set of effective changes and data for rendering the changes on a GUI. If an operation was unsuccessful that information is transmitted to the front end client application for failure processing. In one embodiment the front end client operation sends a retrieval operation when a screen refreshes and sends EndRetrieveOp after a retrieval operation is done causing the transition back to idle.

If the operations were successful then the process persistently saves the customer business objects to the database s step and ends. In an embodiment that uses a front end client application to implement the process of such as might be the case for the embodiment shown in the back end server application transitions from idle state to check save state in conjunction with this step of the front end client application process because the front end client sends a check save type client request to the back end server application to save the changes.

As shown in system includes an idle state and a retrieve state . Transition from idle state to retrieve state is triggered by a retrieval op type request as explained above with respect to . Transition from retrieve state to idle state is triggered by an EndRetrieveOp request as explained with respect to .

Similarly system may remain in retrieve state to process multiple retrieval op type requests and may transition to failed state when a client application submits an operation type service request an EndOperationOp service request a check service request or a save service request during retrieve state as explained above with respect to .

As shown if the system receives an operation type input it may transition from idle state to operation state as explained with respect to . In operation state the system executes the service requests Create Update Delete Action and EndOperationOp. As shown multiple operation type requests such as Create Update Delete and Action may be executed during operation state without causing a transition to another state. If a client application submits a retrieval op type service request an EndRetrieveOp service request a check service request or a save service request during operation state the system will transition to failed state as shown.

A client application should use the EndOperationOp request to exit operation state and eventually return to idle state otherwise any following RetrievalOp or Transaction service requests may fail. As shown in this example the system will transition to do modify state after receiving an EndOperationOp request. In Do Modify state the system builds a to do list of service providers with pending operations in an appropriate order based on a local transaction buffer. In one embodiment the system framework buffers all modifications like a printer queue buffers documents to print. The buffers are related to business objects and every different business objects gets an internal buffer in the framework. The Do Modify operation flushes these buffers and the application implementation gets its collected data at this point.

Retrieve and Operation states may be stacked within the do modify state . In one embodiment operations are stacked similar to a call stack and an implementation of a business object may call another business object by using this stack framework. If so the state of the calling business object is stored in a stack. The state handler of the called business object should guarantee that only allowed states are chosen. For example it should not be possible to update a called business object if the calling business object is in retrieve state. Various embodiments consistent with the invention may impose other restrictions regarding allowed and forbidden combinations.

From Do Modify state the system may transition to idle state . From Do Modify state the system may alternatively transition to failed state if it receives a check request save request cleanup request EndRetrieveOp request or RetrieveOp request in do modify state .

As shown in system includes an idle state and a retrieve state . Transition from idle state to retrieve state may be triggered by a retrieval op type request as explained above with respect to . Transition from retrieve state to idle state is triggered by an EndRetrieveOp request as explained above with respect to .

Similarly system may remain in retrieve state to process multiple retrieval op type requests and transition to failed state when a client application submits an operation type service request an EndOperationOp service request a check service request or a save service request during retrieve state as explained above with respect to .

As shown if system receives an operation type input in idle state it may transition to operation state as explained with respect to . In operation state the system may execute multiple operation type requests such as Create Update Delete and Action. If a client application submits a retrieval op type service request an EndRetrieveOp service request a check service request or a save service request during operation state the system will transition to failed state as shown. An EndOperationOp request will cause system to exit operation state and return to idle state via in one embodiment a Do Modify state not shown as explained with respect to .

From idle state a cleanup service request will cause system to transition to cleanup state which cancels proposed changes in any pending database transactions. From cleanup state system automatically transitions to cleanup end state wherein system sends cleanup status notifications to the service providers and then transitions back to idle state . Service providers are the implementation of business objects i.e. the business application.

From idle state a Save service request will cause system to transition to a save state . This state is a preparation for the save cycle. In one embodiment it is an internal system state that a service provider does not see. Before initiating a save transaction and causing system to enter save state a client should ensure that all pending updates have been sent to the service manager backend. In one embodiment this is done implicitly. When the state machine is in idle mode then all data is sent from framework to provider. From save state system automatically transitions to save check state .

In save check state system COO sends before save checks to the service providers such as coding that checks valid quantities of a purchase order before saving it such that if the check fails then the save is not done to verify that all the pending database changes can be made in the various affected databases. If any one before save check is rejected by a service provider then the save process will be cancelled and system will transition to idle state . As shown system may execute multiple retrieval ops and operations while in save check state .

In one embodiment there is no direct transition to retrieve state but it is possible to retrieve data of other business objects in the service provider implementation of save check . In this embodiment the system checks whether the implementation of save check calls only retrieve operations. If so then a new level of operation is opened like a stack level in subroutine calls and also named Stacking . In this new stack level a new instance of the state machine is started with idle state. A retrieval operation called in the service provider implementation is then checked against the new stack level.

From save check state system may transition not shown to retrieve state upon receipt of a retrieval op type service request. In one embodiment the back end application e.g. the stack handler initiates the retrieval op type service request as part of stacking. Also from save check state system may also transition to failed state upon receipt of an EndRetrieveOp service request an EndOperationOp service request a check service request a cleanup service request or a save service request.

Failing receipt of a service request that causes a different transition and upon successful completion of all before save checks of pending database changes system will automatically transition to save do state . In save do state system sends do save notifications to the service providers asking them to implement the pending database changes i.e. to write the new data into the database s .

Next system automatically transitions to save after state . In this state system sends after save notifications to the agents. In one embodiment consistent with the invention an agent is a program that runs after a successful save. It may trigger any kind of operation. For example an agent may start a printout after saving a leave request. In one embodiment a program of any kind may register for an after save event and the state Save After starts all the registered programs. The registered programs may also receive a list with all changes from the save cycle which they may operate on or not . From save after state system may transition not shown to retrieve state upon receipt of a retrieval op type service request . In one embodiment the state is stacked as described with respect to the save check state. If a client sends any other type of service request during save after state system will transition to failed state .

Absent receipt of a service request that causes a different transition and upon successful completion of sending after save notifications to the agents system will automatically transition to save done state . In save done state system performs commit work processing. In one embodiment the system framework calls a commit work routine that flushes all database buffers not the system framework buffers to the data base starts all background processes e.g. update tasks and releases all locks not used in update tasks.

Following save done state system automatically transitions to cleanup end state and sends cleanup status notifications to the service providers before returning to idle state .

System includes a number of components such as a central processing unit CPU a memory an input output I O device s and a database that can be implemented in various ways. For example an integrated platform such as a workstation personal computer laptop etc. may comprise CPU memory and I O devices . In such a configuration components and may connect through a local bus interface and access to database implemented as a separate database system may be facilitated through a direct communication link a local area network LAN a wide area network WAN and or other suitable connections. For another example system may be part of a larger client server system.

CPU may be one or more known processing devices such as a microprocessor from the Pentium family manufactured by Intel . Memory may be one or more storage devices configured to store information used by CPU to perform certain functions related to embodiments of the present invention including front end client application functions and or back end server application functions. Memory may be a magnetic semiconductor tape optical or other type of storage device. In one embodiment memory includes one or more programs that when executed by CPU perform various processes consistent with the present invention. For example memory may include a front end client application that interacts with a state machine back end or a back end server application that implements a state machine to control access to databases and uniformly and correctly update all related business objects when a business object changes. Memory may also include other programs that perform other functions such as a database manager program.

Methods systems and articles of manufacture consistent with the present invention are not limited to programs configured to perform dedicated tasks. For example memory may be configured with a program that performs several functions when executed by CPU . For example memory may include an application program that incorporates the functions of client application and a server application. Alternatively CPU may execute one or more programs located remotely from system . For example system may access one or more remote programs that when executed perform functions related to embodiments of the present invention.

Memory may be also be configured with an operating system not shown that performs several functions well known in the art when executed by CPU . By way of example the operating system may be Microsoft Windows Unix Linux an Apple Computers operating system Personal Digital Assistant operating system such as Microsoft CE or other operating system. The choice of operating system and even to the use of an operating system is not critical to the invention.

I O device s may comprise one or more input output devices that allow data to be received and or transmitted by system . For example I O device may include one or more input devices such as a modem network connection keyboard touch screen mouse and the like that enable data to be input including data from a user. Further I O device may include one or more output devices such as a modem network connection display screen CRT monitor LCD monitor plasma display printer speaker devices and the like that enable data to be output or presented including presentation to a user. The configuration and number of input and or output devices incorporated in I O device are not critical to the invention.

Database may comprise one or more databases that store information and are accessed and or managed through system . By way of example database may be an Oracle database a Sybase database or other relational database or database may be part of a central product validation system. Systems and methods of the present invention however are not limited to separate databases or even to the use of a database and can include systems that use data from practically any source such as the internet and other organized collections of data or memory systems.

One of ordinary skill in the art will recognize that the embodiments described and suggested above can be implemented using conventional equipment and programming techniques.

Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only with a true scope and spirit of the invention being indicated by the following claims.

