---

title: Virtualized file system
abstract: File system views are created for each application executed by a user, where this user-specific view comprises operating system files needed to run the application and file system changes made with this application for this user. Changes made to the file system during execution are allowed (in accordance with the user's permissions), but by default, those changes are not visible to other applications or to other users. Optionally, a user or administrator may specify that one or more file system views are to be accessible from other views. The view-specific isolation of file system changes applies also to system files and meta-data alterations that might be made to the operating system. In one alternative approach, file system views may be created for an application without regard to individual users, where that application's view is then used for all users who execute the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732220&OS=08732220&RS=08732220
owner: International Business Machines Corporation
number: 08732220
owner_city: Armonk
owner_country: US
publication_date: 20050615
---
The present invention relates generally to computing devices and more particularly to managing file system usage for applications executing on computing devices.

Current file systems offer protection on a per user basis. That is user permissions are established for files such that a program run by a particular user can read write delete and or execute any file for which that user has the corresponding permissions. This leads to a plethora of security reliability and maintenance issues that plague today s computer users.

As examples of security problems the user s computer is vulnerable to easy infestation by a virus unwittingly executed by the user. Trojan programs may also be unleashed that can read any of a given user s files and report information from those files without the user s knowledge. So called spy ware might be accidentally installed.

Other file system problems may be caused in less malicious ways such as through programming errors made by the program developers. For example a program might overwrite another program s critical files with its own possibly incompatible version which may lead to unpredictable results. Uninstaller programs might be used that fail to completely uninstall a program leaving behind parts of the application that are no longer usable. And faulty uninstallers are provided in some cases making programs difficult to uninstall. When applications that are no longer needed are not uninstalled system resources may be wasted.

File system views are created for each application executed by a user where this user specific view comprises operating system files needed to run the application and file system changes made with this application for this user. Changes made to the file system during execution are allowed in accordance with the user s permissions but by default those changes are not visible to other applications or to other users. Optionally a user or systems administrator may explicitly specify that particular applications have access to other views where this access may comprise read only access copy on write access and so forth. The access to other views may be allowed among applications executed by the same user and or may comprise allowing one or more of this user s file system views to be accessed by applications executed by one or more other users.

In one alternative approach file system views may be created for an application without regard to individual users where that application s view is then used for all users who execute the application.

The foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail consequently those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects inventive features and advantages of the present invention will become apparent in the non limiting detailed description set forth below.

The present invention will be described with reference to the following drawings in which like reference numbers denote the same element throughout.

Embodiments of the present invention bring the advantages of virtual memory into the realm of file systems. By way of review virtual memory allows multiple applications to execute without the knowledge of other executing applications while the collection of executing applications shares the same physical memory in a well controlled manner. Virtual memory usage provides security and reliability that was impossible when using prior shared memory space techniques. The term virtualized file system is used herein to refer to multiple applications sharing a file system each application having its own view of one or more files from the file system.

In one or more embodiments of the present invention each application is treated as a separate entity per user for every user that executes the application. When an application is initially executed by a particular user the application is given a fresh view of the base file system where this view of the base file system preferably includes the operating system files required for executing the application . As the application is executed on behalf of the user any changes made to the file system are allowed in accordance with the user s permissions but by default those changes are not visible to other applications or to other users. Upon subsequent execution of this application by the same user this user specific view shows only those file system changes that were made with this application for this user by default changes made by other users and by this user when executing other applications are not visible. Notably this isolation of the user s changes applies also to system files and meta data alterations that might be made to the operating system such as changes made to the registry when using a Microsoft Windows operating system. Windows is a registered trademark of Microsoft Corporation in the United States other countries or both. 

Preferably one or more embodiments of the present invention enable a user to allow access to the user s view of the file system created with regard to a particular application by other applications. Each such other application accessing the file system view can be given different permissions to use the files in the view if desired. The user may also grant permissions to other users to access a file system view. In any case per user security is still maintained. For example the user may allow access to a particular one of his or her views granting read only access to another user or perhaps by granting copy on write permission. However the integrity of the user s files will be maintained there is no risk of the other user altering the files within the original user s view. 

Because applications in these embodiments cannot access data of other applications unless explicitly allowed by a user techniques disclosed herein prevent Trojan programs from accessing the user s files without explicit permission of the user even if the Trojan program is unwittingly executed by the user. Instead the Trojan program s file system changes will be isolated within a view created for the Trojan program. The changes can be removed from the system by removing this view. Similarly a virus cannot infect the user s base operating system nor can it affect or infect other applications since any changes made by the virus to the file system as the virus executes will be limited to its own unique view and will therefore be confined to copies of files that are used by the run time environment in which the virus executed .

Techniques disclosed herein enable an installed application to be portable among systems that use the same operating system by transferring the application s file system view for example by transferring a package comprising a collection of the system files and data files used created by the application from a first system to a second system the second system is able to execute the application as if it was still executing on the first system and equally as if the previous executions of the application had taken place on the second system. In the prior art transferring an installed application from a first system to a second system would normally require knowledge of each individual file used by the application on the first system such that the proper set of files could then be located and transferred to the second system. 

An application can be completely uninstalled using techniques disclosed herein by removing its file system view and if multiple users have views of the application an administrator may delete all the views. That is all changes made by an application can be deleted by removing the view s containing the record of those changes. In addition a user can determine which files have been changed by an application by examining the application s file system view.

Applications that use different versions of a library e.g. a dll or so file can each install their respective library versions without conflicting with the other using techniques disclosed herein. This may increase application reliability and ease of development. An errant program cannot corrupt a user s files except those that it creates or modifies thereby limiting the scope of the corruption. Critical operating system files will always be intact for instant recovery that is such files cannot in general be altered. If one application deletes the operating system kernel for example the deletion applies only to that particular application s file system view the kernel remains available to other applications. 

In this first scenario reference numbers and of indicate that each of the 3 applications uses some set of files. According to one or more embodiments each application executed by a user will create a separate view for its files as noted above. Thus individual file system views are preferably created for each of and where each view also preferably includes the operating system files patches used by the respective application . For this scenario assume that the sets of files are non overlapping i.e. the applications have no files in common other than their usage of the core OS files and patches . Suppose by way of illustration that Application is a human resources application used for a corporation s employees Application is an accounts payable application used for paying the corporation s suppliers and Application is an online shopping application. Presumably the operating system is given full access to the files used by each application including any files newly created by the applications . Thus the graphic at reference number indicates that OS has full access to the files in Application s file system view and similarly the graphics at reference numbers and indicate that OS has full access to the files in the file system views for Application and Application respectively.

The file access permissions of Application are shown in column . For this scenario Application has copy on write permission to the operating system s core files and patches . See the graphic at . Application has full access to its own files see the graphic at . Copy on write access or COW as that term is used herein refers to using a base version of a file until determining that an update is required and then making a copy of the file and applying the update to the copy. The copy will be reflected in the application s file system view as updated. By default such changes are not then viewable outside the view.

The file access permissions of Applications and are shown in columns and respectively. For the scenario of Applications and both have copy on write permission to the operating system s core files and patches. See the graphics at and . Both Application and Application have full access to their own files see the graphics at and . However in this scenario none of the applications access files from the other applications file system views.

Referring now to a second file system usage scenario is illustrated. As in the operating system has full access to the core OS files and patches as shown at of . The operating system also has full access to the files of the applications i.e. to the file system views created for the applications which in this case are represented by reference numbers and see the graphics at reference numbers and of .

Suppose that Application and Application in this second scenario are the same applications discussed above namely a human resources application used for a corporation s employees and an online shopping application. However suppose that an application named Application replaces Application where Application is an e mail application usable by the corporation s employees. Further suppose that Application is responsible for maintaining a current list of the corporation s employees and that this list is consulted by Application e.g. to ensure that only authorized employees can access the corporation s e mail resources . In this second scenario therefore the files used by Applications and have an overlap. For this scenario shows that Application has copy on write access to the file system view s for core operating system files and patches see reference number while having full access to a file system view comprising its own files see reference number as well as copy on write access to at least some of the files of Application see reference number . Preferably Application will make a copy of applicable ones of the files from the file system view created for Application s files store that copy in the local file system view for Application and make any updates to that local copy. Notably any changes that Application makes to its local copy are not viewable to Application unless the user or administrator explicitly allows such access .

Applications executing under control of an operating system that uses the virtualized file system disclosed herein may be considered as having their own separate run time environments. An application s file system view may be considered a stacked view that generally comprises the file system view the application was installed on top of plus any file system alterations made by the application. From this perspective file system views for other applications may be stacked underneath a particular application s file system view. This stacking is illustrated using as will now be described.

In the example of a base operating system is installed and creates a view V . See reference number of . A word processor is also installed and is executing under control of that operating system. The word processor may therefore be considered as installed on top of the operating system and therefore the word processor s file system view is on top of the operating system s file system view. In the word processor s file system view is referred to as V shown at . An e mail program is also installed on top of the operating system and therefore its file system view is stacked on top of the operating system s file system view. The e mail program s file system view is shown as V see reference number . Suppose a spreadsheet program is to be executed and is installed on top of the word processor. shows the spreadsheet program s file system view V as being stacked on top of the file system view V of the word processor. See reference number . This stacking may be done for example by a user or administrator after installation of one or more applications. 

In this example the spreadsheet program can access using appropriate permissions all files installed or created by the word processor but not vice versa because the word processor s file system view V is part of the underlying stack of the spreadsheet program s file system view V . And all of the applications can access files installed by the operating system in its underlying file system view V . If files of the operating system need to be patched for example to address security vulnerabilities the patches can be made to file system view V assuming appropriate authentication is established for updating those files and assuming explicit user administrator permission for accessing the view all applications installed on top of view V will then benefit from the security patches. Similarly if the word processor makes changes in its file system view V such as by creating a new document the spreadsheet program can then see those changes through its stacked file system view V . While this example illustrates file access among several of the views it should not be construed as limiting. Permissions between views may be established in ways other than those discussed with reference to the stacked views in . For example a user or administrator might specify that a word processor and e mail application both be given full access permissions to files in the other s view. 

Files in the present invention s virtualized file system can be created overwritten altered etc. However according to one or more embodiments all changes are captured by a file system processing layer this layer then associates the changes with the user and the application making the change. The association is recorded in a persistent store such as a relational database. The collection of data to be stored is referred to herein as metadata . For subsequent executions of a particular application by the user the changes made to the file system during previous executions will be visible but in general e.g. without explicit access permission to the file system view other applications will not see those changes. Instead the other applications will see their own view of the files in the file system.

If two applications executed by a user need to interoperate and thereby access the other s files their file system views can be merged such that all changes made by one application are seen by the other application. Or permissions can be granted to allow one application to access files of another application s file system view. For example the e mail program in may be given read only permission to the word processor s file system view V . This enables documents generated by the word processor to be e mailed using the e mail application for example.

Referring again to the per user per application file system views the view for user pierceju is expanded in this illustration. See generally reference number . As shown therein this user has application file system views named Operating System Patches Notepad and E mail Client and in this example each of these views can be further expanded to show logical components of the views that are available. The E mail Client view at for example has been expanded to show components Core Files and Created Files . This illustrates an optional enhancement whereby one or more embodiments may use separate file system permissions for the files they originally install e.g. Core Files component and for the files they create after installation e.g. Created Files component .

Graphical highlighting is provided around the text E mail Client at to indicate that this application s file system view has been selected e.g. using a mouse pointer . See also where the selected application s name is presented in the descriptive information for window . The panes and show the file system access permissions within the views created for user s execution of the E mail Client application. As shown in pane in this example direct control full access is provided over files in the Created Files and Core Files components of the E mail Client application view. Thus the E mail Client application can perform operations including read write delete and so forth on those files. Pane shows that copy on write access has been specified for files in the Patches Operating System and Core System views. Pane shows that read only access has been specified for files in the Created Files component of the Notepad application view.

The user or perhaps an administrator may specify file access permissions through a GUI such as that shown in for example by dragging and dropping graphic representations of file system components from pane to panes or by dragging and dropping graphic representations among the panes .

Other information may be provided in metadata without deviating from the scope of the present invention although this has not been illustrated. In addition an alternative organization may be used for the metadata. For example instead of organizing the metadata by file as shown in one alternative approach that may be used is to organize the metadata by application within user such that all file copies that have been created for a particular user are stored together grouped according to the application for which the copies were created.

According to one or more embodiments an operating system application programming interface API is provided through which file access requests are made and calls to routines of this API invoke operations of a file system layer that provides the virtualized file system disclosed herein. In response to the API calls metadata for the calling application and user is consulted and the invocation is processed accordingly as will be discussed in more detail with reference to . Preferably use of the virtualized file system is transparent to the application developer who simply codes the application to invoke the API without regard to how the underlying file system is implemented. Alternatively however it may be desirable in some scenarios to write applications that are aware of the virtualized file system. Such an application might for example include a code to ask the user whether the user wishes this application s file system view to be accessible to other selected applications such as a set of applications created by a common vendor .

Referring now to flowcharts are provided that depict logic which may be used when implementing embodiments of the present invention. Each of these figures will now be discussed.

Referring first to when a write request is received for a particular file the requesting user and application are determined Block . The metadata for this file is consulted Block to determine whether a copy has been created in a view corresponding to the requesting user and application. As discussed above rather than organizing the metadata by file as shown in alternative organizations may be used. It will be obvious that Block as well as corresponding logic of the remaining flowcharts may be adapted to other approaches for the metadata organization. For example rather than accessing a relational database using the file name as a key according to the structure illustrated in a key might alternatively be comprised of an identifier of the requesting user and application. 

The test at Block checks to see if a copy of this file already exists for the requesting user and application according to the metadata. If not then processing continues at Block where a copy of the file is made and added to the file system view that corresponds to this user executing this application. The copy may be made from the base version of the file the location of which may be determined for example from the metadata. Alternatively when file system views are stacked as discussed with reference to the copy may be made from the top most view that both underlies the current view and contains a view of this particular file. Block then updates the metadata to include an entry for this newly created copy.

Control reaches Block when the test in Block has a positive result i.e. a copy of the file already exists in the view for this user executing this application and following execution of Block . At Block the write request is performed using the copy in the view for the requesting user and application. Processing then exits from .

The test at Block checks to see if a copy of this file already exists for the requesting user and application according to the metadata. If not then processing continues at Block where the read request is carried out using the base version of the file. When views are stacked as discussed with reference to a precedence approach may be used where the read request reads a file copy from the top most view that both underlies the current view and contains a view of this particular file rather than using the base version. Otherwise when the test at Block has a positive result then the read is carried out at Block using the copy of the file from the current file system view that is the file system view for the requesting user and application . Processing then exits from .

The test at Block checks to see if a copy of this file exists in the current view for the requesting user and application according to the metadata. If not then the delete file operation will not be performed and processing exits from . A message may be generated if desired indicating that the request will not be carried out. Otherwise Block removes the copy of the file from the current file system view. Processing then exits from .

Processing requests to delete an individual data item from a file may be implemented in a manner similar to the write operation illustrated in . That is if a copy of the file does not yet exist in the file system view for the requesting user and application then a copy is made for that view and the deletion of data is then carried out using that file copy. Otherwise the deletion is made to the copy that already exists in the file system view. If the current view does not have a copy of the file but a copy exists in an underlying stacked view then the stacked copy is preferably used when creating the copy for the current view. 

Requests to open and close files may be handled using logic similar to that of substituting open or close for read respectively and separate flowcharts illustrating these details are not deemed necessary to a full understanding of the present invention . In particular the metadata is preferably checked to determine whether a copy exists in the current file system view. If not then the base version or an underlying stacked copy as applicable is preferably opened or closed depending upon the requested action otherwise the copy in the current file system view is opened or closed.

When using an approach that establishes file system views per application without regard to which user executes the application the logic shown in can be adapted accordingly. For example Block can be adapted to obtain the identifier of the requesting application and Block can be adapted to check the metadata associated with this application. Preferably separate API calls are provided for this approach and logic adapted from the examples shown in is used for supporting these separate API calls.

Using techniques disclosed herein users are given significant control over the applications they employ. All changes made to a file system by a particular user can be removed by removing the file system views created by that user. Similarly all changes made by any user of a particular application can be removed by removing each of the file system views created for the application. Or all changes made by a single user executing a particular application can be removed by removing the file system view created for that user and that application. To control application access among users preferred embodiments grant or deny access to particular file system views. Similarly to control interaction among applications permissions are preferably specified with regard to file system views used by the applications. In the prior art users may be unable to determine which applications are using which files and thus how the applications are interacting. And when file content in one or more views has been damaged other portions of the computer system can continue to function without infection by the damaged view s thus providing a type of guaranteed system availability.

One or more embodiments of the present invention may be provided that support installation of more than one operating system on a particular computing system including installation of heterogeneous operating systems on a single computing system. Each operating system is preferably provided with its own file system view using techniques disclosed herein. See for example reference numbers and of where views for Operating System and Operating System respectively are represented in the GUI . A user may then be allowed to select execution under a particular one of the installed operating systems. Because each operating system s files are stored in separate file system views collisions and incompatibilities among them are avoided. Permission to access files in other views may be enabled among the file system views of the operating systems if desired e.g. by specifying permissions using GUI .

As will be appreciated by one of skill in the art selected components of the present invention may be provided as methods systems and or computer program products comprising computer readable program code. Accordingly the present invention may take the form of an entirely hardware firmware embodiment. An embodiment combining software and hardware firmware aspects might be used alternatively. Or components of the present invention may be provided in a software embodiment.

Furthermore components of the invention may take the form of a computer program product accessible from computer usable or computer readable media providing program code for use by or in connection with a computer or any instruction execution system. For purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport a program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape removable computer diskette random access memory RAM read only memory ROM rigid magnetic disk and optical disk. Current example of optical disks include compact disk with read only memory CD ROM compact disk with read write CD R W and DVD.

Referring now to a data processing system suitable for storing and or executing program code includes at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories not shown which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output I O devices including but not limited to keyboards displays pointing devices other interface devices etc. can be coupled to the system either directly or through intervening I O controllers or adapters .

Optionally network adapters not shown in may be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem attachments wireless adapters and Ethernet cards are just a few of the currently available types of network adapters.

While preferred embodiments of the present invention have been described additional variations and modifications in those embodiments may occur to those skilled in the art once they learn of the basic inventive concepts. Therefore it is intended that the appended claims shall be construed to include preferred embodiments and all such variations and modifications as fall within the spirit and scope of the invention. Furthermore it should be understood that use of a or an in the claims is not intended to limit embodiments of the present invention to a singular one of any element thus introduced.

