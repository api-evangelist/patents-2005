---

title: Service clean-up
abstract: Versions of a service not reachable by a set of service requestors that use the service are removed. Multiple, different versions of a service are stored, along with metadata associated with the multiple, different versions of the service. The metadata is examined to determine one or more of the multiple, different versions of the service that are not reachable by the set of service requestors that use the service. Those versions are deleted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09274830&OS=09274830&RS=09274830
owner: AOL Inc.
number: 09274830
owner_city: Dulles
owner_country: US
publication_date: 20051118
---
This application claims priority under 35 USC 119 e to U.S. Provisional Patent Application Ser. No. 60 628 555 filed on Nov. 18 2004 the entire contents of which is hereby incorporated by reference.

Software development platforms generally provide a framework to assist developers in developing applications. Software development platforms may include a runtime environment that supports the execution programs designed for the environment and provides common capabilities to those programs and a static library that provides the functions and application programming interfaces APIs for designing programs for the environment.

In one aspect versions of a service not reachable by a set of service requesters that use the service are removed. Multiple different versions of a service are stored along with metadata associated with the multiple different versions of the service. The metadata is examined to determine one or more of the multiple different versions of the service that are not reachable by the set of service requestors that use the service. Those versions are deleted.

Implementations may include one or more of the following features. For example the metadata may include multiple metadata files. Each metadata file may be associated with one of the multiple different versions of the service and contain metadata for the associated version of the service that indicates which ones of the set of service requesters are compatible with the associated version of the service.

To examine the metadata to determine one or more of the multiple different versions of the service that are not reachable by the set of service requestors that use the service the metadata may be examined to determine a version of the service that is compatible with all of the service requestors in the set of service requesters. The versions of the service that are set of service requestors may be designated as the one or more versions of the service that are not reachable by the set of service requestors that use the service. The designated versions then may be deleted.

The metadata files may be XML documents. In this case the metadata may include one or more tags that indicate a default condition in which none of the service requestors in the set of service requestors are compatible with the associated version of the service and one or more tags that override the default condition by indicating specific ones of the services requesters in the set of service requestors that are compatible with the associated version of the service. Alternatively or additionally the metadata may include one or more tags that indicate a default condition in which all of the service requesters in the set of service requestors are compatible with the associated version of the service and one or more tags that override the default condition by indicating specific ones of the service requestors in the set of service requestors that are not compatible with the associated version of the service.

The set of service requestors that use the service may include different versions of a service requestor that uses the service and the metadata that indicates which ones of the set of service requestors are compatible with the associated version of the service may include metadata indicating which ones of the different versions of the service requestor are compatible with the associated version of the service.

The service may be any one of an instant messaging IM service a mail service a common local storage service a notification manager a preferences service or a sequencer service.

Implementations of the described techniques may include hardware a method or process or computer software on a computer accessible medium.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features will be apparent from the description and drawings and from the claims.

Storage stores data and various programs such as an operating system OS . The OS is a program that controls the functioning and interaction of the hardware components of system and facilitates the operation of other programs executing on system . Windows Me Windows XP Linux and MacOS are examples of common operating systems for personal computers. Windows CE or Windows Embedded are examples of common embedded operating systems used in cellular telephones or personal digital assistants.

Storage also stores a runtime environment and one or more applications and or services . The runtime environment is a collection of code that controls the execution of programs specifically designed for it such as applications or services and provides common functions or capabilities to those programs.

In general the runtime environment software resides between the programs designed for it and the OS . In other words programs designed for the runtime environment call routines of the runtime environment to perform input output graphical interface and other functions and the runtime environment calls routines of the OS to implement those functions. In contrast programs that are not designed for the runtime environment call directly upon routines of the OS to perform input output graphical interface and other functions.

Referring to a software model includes an operating system OS and a runtime environment layered on top of the OS . The runtime environment includes a basic runtime and an execution environment runtime . The basic runtime provides basic utilities that are used by the execution environment runtime and are not otherwise provided for by OS . For example the basic runtime may provide a compression utility an extensible markup language XML parsing utility and a language runtime.

The execution environment runtime is layered on top of the basic runtime . The execution environment runtime controls the execution of programs and services designed for the runtime environment and provides common functionalities and capabilities for the execution of those programs and services. For example runtime components of the execution environment may provide for service versioning service discovery service clean up and service grouping as described further below.

In general services and applications run on top of the execution environment runtime . A service is a collection of logically related code and functions to perform a particular task or set of related tasks. A service is generally used by an application or other service to accomplish the task or tasks and usually does not interact with the end user. When a service is used by an application or other service at least a portion of the service s code and functions becomes part of the code of the application or other service either by being loaded directly into the process containing the application or service or by being loaded into another process and using an interprocess communications mechanism provided by the execution environment runtime to handle the passing of calls to the service s code and functions and the results of those calls between the processes. In other words the service s code is linked to the service requestor s code at runtime and is executable by the requestor s code.

A service implements one or more classes of objects that provide the functionality of the service. An object is a piece of compiled code that provides functionality to other compiled code e.g. an application or other service on the system as opposed to a source code object . Thus to access particular functionality of a service another service or application makes a request to the execution environment runtime for the appropriate object from the service. The execution environment runtime then controls instantiating the service object and connecting the requestor of the object to the object so that the requestor can access the service object s functionality. The functionality of an object is accessed by one or more methods of the object. For example a mail service may have a mail object class that provides a SendMail method and a ReadMail method. The SendMail and ReadMail methods are used to send an e mail and retrieve an e mail respectively.

Applications are the programs that provide a set of features to the end user. For example an e mail program allows a user to view the e mails in his or her mailbox compose new e mails and send e mails. An IM application allows a user to exchange instant messages with other users.

Applications are generally divided into an application interface portion and an application logic portion . In general the interface allows the user to interact with the application provides a view of data e.g. e mails or instant messages to the user and allow the user to provide input to the application. The application logic implements particular functionality based on user inputs by implementing certain logic and accessing services and updates the interface based on changes to the data. For example if a user selects a send button on a mail application the application logic translates that input into a send operation by calling the appropriate functions of a mail service and updates the user interface to reflect a sent e mail once the e mail is sent.

A mail application allows a user to view the e mails in his or her mailbox compose new e mails and send e mails. To this end mail application uses the functionality provided by mail service to send and receive e mails check for new e mails obtain a list of new e mails and or obtain a list of read e mails. An IM application provides instant messaging capabilities to a user. To do so the IM application uses an IM service not shown . In addition the IM application alerts a user when the user receives a new e mail. To provide the user with such alerts the IM application uses the mail service to check for new e mail and if there is new e mail alerts the user.

Referring again to the execution environment runtime provides for the interoperability of the applications and services and reuse of services. To provide for interoperability and reuse the execution environment runtime controls the instantiating of service objects and their connection them to service requestors. As part of this the execution environment runtime provides service versioning. In general when an application or service wants to use a particular service object the execution environment discovers the correct version and implementation of the service for the requesting application or service instantiates the service object and facilitates a connection between the application or service and the service object. This may allow for side by side versioning or services.

In addition as part of instantiating service objects the execution environment provides for service grouping. When the execution environment runtime instantiates a service object it instantiates the object in a particular process based on the metadata for the service. Thus where the service is activated can be controlled by changing the metadata associated with the service. This may allow a developer to change between the service being loaded in process and out of process and may allow certain services or classes of objects to be grouped in a particular process by designating the process in the metadata.

Also the execution environment runtime may provide for other functionality such as service clean up in which the execution environment runtime discovers and removes versions of services that are no longer used by applications or other services. The execution environment runtime also may provide for service discovery in which the execution environment runtime at the request of an application or service discovers services meeting particular criteria.

To develop applications and services for execution environment runtime a developer uses a library that provides an API for developing applications or services that run on top of the execution environment runtime . The library is statically linked into applications and services and provides a model object for objects running in the execution environment runtime . The library APIs allow the developer to develop objects according to the object model so that those objects are exposed to other applications and services running on the execution environment runtime . The API also allows the developer to develop applications and services running on the execution environment runtime that access the objects developed according to the object model. Also as described further below in addition to being accessed by the API objects developed using the API can be accessed as native objects i.e. objects natively supported by the OS . Thus the runtime environment and the statically linked library provide for a software development platform that defines an object model and provides for service versioning service grouping service clean up and service discovery. In addition objects developed for the software development platform are accessible as native objects and through the API of the platform.

The runtime components of the execution environment runtime control the execution of applications and services. In general one of the runtime components is a service manager subsystem that manages available services and applications and facilitates the connection between services and consumers of the services such as applications or other services. The service manager also may facilitate service versioning service grouping service discovery and service clean up.

With respect to service versioning a service requester may request a service object from the service manager. The service manager then locates the service determines the appropriate version of the service for the requestor instantiates the service object from the located service and returns a reference to the object to the requestor which can then access the service object s functionality using the reference. To provide service grouping the service manager reviews the metadata associated with the service when the service manager instantiates the service object to determine the process in which to instantiate the object.

In addition with respect to service discovery a service requestor may request that the service manager identify services that meet particular criteria. As described further below services have meta data associated with them that describes their properties and capabilities in the form of a service manifest file and other information about the service. The service manager may search the meta data of the services to determine which ones meet the criteria requested by the requestor. The service manager then returns an identification of the service and also may return the meta data describing the criteria.

Also to provide service clean up the service manager may review the meta data to determine which versions of services are no longer used by other services or applications. The service manager then removes those versions of services that are no longer used.

Also in the implementation shown the service manager subsystem is implemented as a dynamic link library DLL shown as SvcMgr.dll. The service manager DLL contains the code that implements a service manager object. Copies of the service manager DLL are loaded into the client the host manager process and the service host processes . These processes can then instantiate service manager objects which enable locating services instantiating service objects and connecting service requestors to those objects along with providing service versioning service grouping service clean up and service discovery functions.

The service host processes host out of process service objects. In the implementation shown services also are implemented as dynamic link libraries. Thus in general requested service objects need a host process in which to run. A requested service object may be loaded in process with the client such that it is hosted by the client process or the service object may be loaded out of process. When a service object is loaded out of process it is hosted by a service host process. For example the service object from service is loaded in process with the client while service objects from services and are loaded out of process in the service host process . When a service object is an out of process object the execution environment runtime provides an interprocess communications mechanism to pass calls to the object and results from the object between the client process and the service host process hosting the object such as for example service host

The host manager process controls the start up and shutdown behavior of the service host processes and when a service object is loaded out of process determines the appropriate service host process that will host the service object. The host manager then instructs the service host to load the service s DLL into the service host and instantiate the object which the service host does using a service manager object instantiated from the service manager DLL loaded into the service host e.g. service manager DLL . A reference to the object is then passed from the service host back to the client through the host manager .

Also through its service manager object the host manager process performs service versioning service grouping service discovery and service clean up. To perform such functions the host manager process reads and caches the service manifest files described below associated with each installed service.

Application launcher starts the execution of client when client is an application that is designed like a service. Applications may be standalone executables that are designed to be executed in the execution environment runtime or applications may be designed like a service. To be designed like a service for runtime architecture the application is implemented as a DLL packaged in the manner described below and includes a service manifest file as described below. Such applications are referred to as application services. Implementing an application like a service allows the application to be discovered and updated using the same execution environment mechanisms as are used to discover and update services. In general the term service and refers to both a service and an application service.

The application launcher is an executable application that receives an identifier e.g. a moniker as described below for the application as a command line parameter. To start the execution of the application service the application launcher executes a shim executable loads the application service DLL into the shim executable instantiates the application object from the DLL and hands over the run loop to the application object.

Services and application services designed for the execution environment runtime have a particular on disk structure e.g. a particular directory structure referred to as a package. This package contains the code and resources used to implement the service or application service and includes meta data describing the service or application service. Packages may be stored in specific locations of the directory structure that contains the code for the execution environment runtime

Package includes a top level service folder and various sub folders containing the code and resources of the service. The name of the top level service folder is the name of the service. In the top level service folder is a version folder which is named after the version number of the service and contains the code and resources for that version of the service. Generally the code and resources of a service or application service is the unit that is versioned not just the code. While not shown multiple different versions of the service may be installed. In this case each version is stored in its own version folder.

In the version folder is a service manifest file that is named servicemanifest.xml. In general a service manifest contains meta data that richly describes the service. Service manifest files are discussed in more detail below.

Also in the version folder is at least one service code module that contains the code for the service. In the example shown the code module is mailservice.dll. The code modules generally may be implemented as dynamic link libraries as shown.

The version folder also contains a resources folder . Resources folder contains resources which are generally non code items used by the service. For example resources folder contains a region folder which contains resources used by the service for a particular locale. In this case region folder is for a United States locale and contains a strings.xml file which contains strings in English that are returned by the service for display to the user.

In execution environment runtime services including application services clients and service objects may be identified by monikers. Thus there generally may be three types of monikers 1 a service moniker 2 a client moniker and 3 a class moniker.

A service moniker identifies a service or application service and does not specify a specific version number of the service. A service moniker may have a form such as ee where the is the name of the service and matches the name of the services folder for the service e.g. folder and the name in the service attribute of the tag in the service manifest for the service described further below . The following is an example of a moniker for a mail service with a service name of mail ee mail.

A client moniker is used to identify a client to the service manager subsystem so that the service manager subsystem can make decisions based on that identity. A client moniker may have a form such as ee where is the name of the client and is the version of the client. The following is an example of a moniker for version 1.0.1 of a mail application with a client name of mailapp ee mailapp 1.0.1.

A class moniker identifies a specific class of object exported by the specified service. A class moniker may have a form such as ee where the is the name of the service and matches the name of the services folder for the service and the name in the service attribute of the tag in the service manifest for the service described further below and the is the specific class of object that can be exported from the service. For example for an inbox class in a mail service the class monitor may look like ee mail inbox.

Services and application services designed for the execution environment runtime have a service manifest file associated with them. As described above the service manifest file contains meta data that richly describes the service or application service. A portion of the service manifest file is used to describe the code modules that comprise the service as well as the classes that those modules export. The service manifest file also can describe the properties and capabilities of the service and provide any other static information that describes the service to potential consumers e.g. other services or applications of the service.

In one implementation service manifest files are expressed in XML and may have a number of XML tags that describe the code modules and exportable classes as well as the capabilities of the service and other static information of use to potential consumers of the service or application service. In general the host manager process reads the service manifest files of the installed services and application services and caches the document object model DOM of the service manifest files. The host manager process through the service manager object uses the cached DOMs to control the start up and shutdown of services and to provide service versioning service grouping service discovery and service clean up.

The following are the basic tags that are used in service manifest files in the implementation shown 1 a tag 2 an tag 3 a tag 4 a tag 5 a tag and 6 a tag.

The tag labeled in in is the root element of the manifest file. The tag contains two attributes a version attribute and a service attribute. The value of the service attribute is set to the service s or application service s name and matches the portion of the service moniker as well as the service folder in which the service is stored. The value of the version attribute is set to the version number of the particular instance of the service or application service with which the service manifest file is associated by virtue of being stored in the package and matches the name of the version folder.

Referring to for example the tag in manifest file has a version attribute with a value of 1.4.6.1 and a service attribute with a value of boxelyRenderer. 

The tag labeled in is used in the manifest file of application services. A file attribute of the tag has a value set to the file name of the code module that contains the code for the application service. The app tag also has a name attribute. The value of the name attribute represents the class of the application object. A customHost attribute designates the name of the executable shim that is launched and into which the code module is loaded. A singleInstance attribute may be specified with a value of true to indicate that the application service can only have one instance running at a time.

Referring to as an example the tag contains a file attribute with a value of mailAppService.dll a name attribute with a value of amail a customhost attribute with a value of amail and a singleInstance attribute with a value of true. Thus to execute the application service associated with manifest file the application launcher reviews manifest file to determine that the customHost attribuite has a value of amail and locates the executable shim with the name amail.exe. The application launcher executes the shim causes the mailAppService.dll code to be loaded into the shim process and causes an object of the class amail to be instantiated to control the application.

The tag labeled in and in has no attributes. It is used as a container for one or more tags labeled in and in that define the code modules and corresponding classes for the service or application service. Each tag corresponds to a code module and there may be multiple tags within a tag. The code module associated with a tag is designated by the file attribute of the tag.

The tag also contains a context attribute that defines whether the service object is loaded in process or out of process. The value of the context attribute specifies where the code from the corresponding module is to be loaded 1 in process or 2 out of process in a service host. If the value of the context attribute is assigned inProc then the code is loaded into the process that is asking for it. If the context attribute is not specified or has a value other than inProc then the code is loaded out of process.

If the context attribute is not specified or is set to defaultGrp then the service is loaded out of process into a service host process with the default name e.g. servicehost.exe . If the value of the attribute is set to another string besides inProc or defaultGrp then the code is loaded out of process into a service host process having a process group name equal to the string e.g. mystuffexe .

Referring to as an example the tag has a context attribute with a value of inProc and a file attribute with a value of boxelyRenderer.dll. Thus the code from the boxelyRenderer.dll file will be loaded in process with any requestors that request the rendering service.

One or more tags labeled as in and in are contained in a tag and are used to designate the classes of objects that are exportable from the code module corresponding to the tag. The tag contains a clsName attribute. The value assigned to the clsName designates the name of an exportable object class. As an example the first tag in manifest file has a clsName attribute with a value of utilities. 

The tag labeled as in in the manifest file offers a way of controlling which clients and specific versions of clients can access the modules contained in the package. Inside of the tag is one or more tags labeled in that specify clients to block or allow.

The tag has an optional default attribute that specifies a default type of filter. The default atttibute may take one of two values either allowAll or revokeAll. If the default attribute is not present its value is assumed to be allowAll. If the default attribute has a value of allowAll then the override tags specify clients and versions of clients to be blocked. If the default attribute is revokeAll then the override tags specify the only clients and versions of clients that have permission to use this package.

Each tag contains a moniker attribute that has a value set to a client moniker but excludes the version e.g. ee clientName . The override tag may contain a from attribute and a to attribute which specify a range of versions or a version attribute that designates a single version to be affected by the override tag. If the version string in the to or from attribute is preceded by the character e.g. 1.7 then the to or from attributed is non inclusive. If the version string is not preceded by the character then the from attribute and to attribute are considered to be inclusive. If the to attribute is present but not a from attribute all versions through the to attribute will be affected. Similarly if a from attribute is present but not a to attribute all versions after the from attribute will be governed by the override tag.

Referring to as an example the tag in manifest file has a default attribute with a value of allowAll. The tag in manifest file has a moniker attribute with a value of ee mailApp and a to attribute with a value of 1.1.4.18. Thus all versions of the client corresponding to mailApp up to and including version 1.1.4.18 are blocked from using the rendering service corresponding to manifest file .

Service manifests also may have other tags that describe properties or capabilities of the service. For example referring to a tag indicates that the mail application has a navigation bar element that can be loaded by a navigation bar application to provide a button on the navigation bar application that can be selected by a user to launch the mail application. Also tags indicate default preferences for the mail application.

The execution environment runtime through the service manager subsystem may provide for service versioning. In general a client requests a service object using the class moniker for the corresponding class. By examining the service manifest files the service manager subsystem determines the correct version of the service for the client i.e. the newest version that the client is permitted to use and the code module of the correct version that contains the class. The service manager subsystem then instantiates the service object and returns a reference to the service object to the client. This may allow different versions of the same service to exist side by side with the most recent version that is compatible with a client being used by the client.

In addition the execution environment may provide for service grouping. In general when the service manager subsystem instantiates a service object the service manager subsystem examines the service manifest file for the corresponding service to determine whether the code module is to be loaded in process or out of process and if out of process which service host the code should be loaded into. The service manager subsystem then loads the code into the appropriate service host and instantiates the service object in the service host. Thus services can be grouped in specific service hosts depending on the information in the service manifest. This may allow a developer to quickly and easily change whether a service runs in process or out of process by simply changing the context attribute in the service manifest as opposed to changing it in the source code and recompiling . This also may allow a developer to easily run certain services together as a group in the same service host process.

Referring to to identify the correct version of the service for use with the client after the host manager has located the service manifests for the different versions of the service the host manager accesses the service manifest of the most recent version of the service . The host manager then inspects the service manifest to determine whether the manifest indicates that the service is incompatible with the client version . If a tag and or an tag indicates that the client identified by its client moniker is not permitted to use that version of the service and there are more versions of the service then the host manager accesses the service manifest of the next most recent version of the service to determine if the client is permitted to use that version of the service . If not then the host manager continues to progressively inspect the service manifests of earlier versions until the host manager discovers a version that the client is permitted to use or until there are no more versions left to review . If there are no more versions of the service and the host manager has not identified one that is compatible with the client then the host manager returns an error to the client .

Referring to once the host manager has identified the correct version of the service the host manager reviews the corresponding service manifest to determine the context in which to load the code module . To do so the host manager reviews the service manifest to locate the requested class in the manifest. The host manager then inspects the context attribute of the tag enclosing the tag that contains the name of the corresponding class. If the context attribute indicates that code module is to be loaded in process the host manager returns the filename of the appropriate service manifest to the service manager object created by client . The service manager object created by the client is then responsible for accessing the manifest file determining the appropriate code module from the file attribute of the tag loading the code module into the client s address space instantiating a service object of the requested class and returning a reference to the object to the client .

On the other hand if the context attribute indicates that the code module is to be loaded out of process the host manager forms a package moniker from the service attributes and the version attribute of the tag in the service manifest . The host manager then uses the context attribute to determine the service host into which the code module is to be loaded . If the context attribute is set to a string value other than defaultGrp the host manager looks for a service host with a name equal to the string value. If one is not executing the host manager creates a service host with a name equal to the string value to start executing. Similarly if the context attribute is set to defaultGrp or there is no context attribute at all the host manager looks for a service host with the default name and if one is not executing the host manager creates one with the default name.

If an executing service host with the appropriate name is found or after the host manager causes one to start executing the host manager sends a request to the service host e.g. service host to load the code module for the service and create a service object of the requested class . The request to the service host includes the file name of the code module that must be loaded the package name and the class to be instantiated. The service host then uses a service manager object created e.g. from the service manager DLL loaded into service host to load the code module into its address space and instantiate a service object of the requested class . The service manager object then returns a reference to the service object to the host manager which returns the reference to the client through the service manager object created by client .

The execution environment runtime through the service manager subsystem may provide for service clean up. In general the service manager subsystem determines and removes versions of services or application services that are no longer reachable by other services or applications. To perform service clean up the service manager subsystem inspects the service manifests for a service to determine the newest version of the service that does not block any clients from using it.

In general to perform service clean up the host manager through the service manager object accesses the service manifests for installed services and application services . For example if the service manifests are implemented in XML then host manager may load and parse the service manifests and then cache the DOMs of the service manifests. The host manager then selects a service and proceeds to review the service manifests of the different versions of the service from the newest to the oldest to determine the newest version of the service that does not block any clients . The host manager then deletes all versions of the service that are older than the newest version that does not block any clients . Once the host manager determines the newest version of the service that doesn t block any clients or reviews all of the version of the service host manager selects another service to review if there are any left . If so then host manager repeats the process on the new service. If there are no services left to review process ends .

Specifically the host manager identifies the newest version of the service and inspects the service manifest of that version to determine if the service manifest blocks any clients from using the service. The host manager may for instance inspect any and tags located in the service manifest to determine if any clients are blocked. If there are no blocked clients the service manager deletes the earlier versions of the service.

If any clients are blocked the host manager then determines if there are any earlier versions of the service or application service. If there are not any earlier versions of the service then the host manager selects another service or the host manager ends the review if there are no more services to review.

If there are earlier versions of the service the host manager then identifies the next newest version of the service and inspects the service manifest of that version to determine if the service manifest blocks any clients from using the service. If there are no blocked clients the service manager deletes earlier versions of the service. If there are blocked clients then this process continues until there are no more versions to review in which case no versions are deleted.

Once the host manager completes the review of a service the host manager selects another service if there are any left that have not been previously reviewed by the host manager for clean up. The process then reviews the versions of the newly selected service. Otherwise the host manager ends the review of the services.

The execution environment runtime through the service manager subsystem may provide for service discovery in which a client can request identification of services meeting particular criteria. As described above service manifest files describe the properties and capabilities and other information about the services or application services. A client may send a search query to the service manager subsystem. The search query specifies particular criteria. The service manager subsystem then searches the service manifests of the installed services or application services to determine which service manifest files contain meta data meeting the specified criteria. The service manager subsystem then returns an identification of the services or application services that have manifest files that contain the specified metadata and may return the specified meta data. The client can then use one of the returned services or use the returned meta data. The service manager subsystem also may limit the service manifests searched to those corresponding to the newest versions of the services that are compatible with the client.

In implementations in which the service manifests are implemented in XML the clients may be able to submit queries for particular tags or particular tags with particular attribute values. The service manager then searches for those tags in the service manifests and returns an identifier of the matching services and the matching tags.

When the client wants to search for services matching particular criteria client through a service manager object sends a query message to the host manager . The query message contains a query a best version parameter and a client moniker.

The query designates the matching criteria for nodes and attributes. The query may be expressed in a query language that is a subset of the XML Path Language XPATH which may allow for arbitrary queries of the tags nodes in the service manifests. XPATH is a language for addressing parts of an XML document. An example of a subset of XPATH that may be used is as follows expressed in Backus Naur Form BNF 

The best version parameter designates whether version logic should be applied. If the best version parameter indicates version logic should be applied then only the best version of a given service the newest version that is compatible with the client will be considered for the query. The client moniker is used to determine the best version of a given service. If the best version parameter indicates that version logic should not be applied then all versions of a given service will be queried for a match.

Accordingly when the host manager receives the query request the host manager through a service manager object determines whether the best version parameter indicates that version logic should be applied and if so determines the best versions of the installed services for the client using for example process . Based on the criteria specified in the query the host manager then searches the DOMs of the service manifests of the best versions of the installed services or application services for the nodes that match the query criteria . The host manager then returns the matching nodes and the identifications of the corresponding services e.g. a package moniker to the client through the service manager object of the client .

If the best version parameter indicates that version logic should not be applied the host manager searches the service manifests of all installed services or application services for the nodes that match the query criteria . The host manager then returns the matching nodes and an identification of the corresponding service e.g. a package moniker to the client through the service manager object of the client .

Using the service discovery mechanism clients can determine whether services having certain properties or capabilities are installed and then use those services or the meta data describing the properties or capabilities. For example clients can determine whether a particular version of a service is installed and then use that version of the service.

As another example service discovery may allow a preferences manager application to discover which application services have default preferences and what those default preferences are. The preferences manager may manage preferences for multiple applications. To do so the preferences manager may query which application services have default preferences e.g. by submitting a query for service manifests that contain an tag and tags . When the default preferences tags are returned along with an identification of the services the preferences manager may then display the default preferences for the multiple applications to the user and allow the user to change the default preferences.

As another example a navigation bar application may display a navigation bar that contains different buttons for launching different applications. To determine the application services that can be launched from the navigation bar and the resource that defines their buttons the navigation bar application may search for service manifests that contain a tag. The tag may have an attribute that indicates where the resource defining the application service s button is located. The navigation bar application uses the location to review the resource and implement a button on the navigation bar according to the resource. The navigation bar application also associates the application service identifier with the button so that the application service can be launched if the button is selected.

In general implementing the service manifests in XML and using a query language such as XPATH allows for arbitrary queries to be performed on the meta data in the service manifest files. This provides extensibility to the service discovery mechanism by allowing developers to add new tags to describe additional information regarding a service while having a mechanism for searching for the new tags.

As described above the execution environment library provides the APIs for developing objects exposed by the execution environment runtime and applications and services that call those objects. The APIs are an abstraction of the platform specific APIs for developing and calling objects native to the platform. In general many operating system platforms have a native object model i.e. a model for objects that are natively supported by the operating system . In other words many operating systems include code that directly supports a particular object model. For example a Windows operating system natively supports Component Object Model COM objects while a Macintosh operating system natively supports Distributed Objects. Normally a set of APIs is available for accessing the native objects of a particular operating system platform.

However the APIs of the execution environment library provide an abstraction layer above the platform specific APIs which allows a developer to develop objects without regard to the platform on which the objects will run. Accordingly the APIs of the execution environment library are operating system neutral APIs. The underlying implementation for a given operating system platform however uses the platform specific APIs and code. Thus when objects developed using the execution environment library are compiled for a specific operating system platform they are compiled as native objects. For instance when compiled for a Windows operating system the objects are COM objects but are Distributed Objects when compiled for a Macintosh operating system. Therefore these objects are accessible using the APIs for the natively supported objects.

However even though the objects are compiled to native objects they are still accessible by the operating system neutral APIs. To accomplish this the execution environment library includes a platform neutral interop in compiled objects.

Thus referring to a compiled object developed using the execution environment library includes the object s logic code . On top of the object s logic code is a native object interop that allows the object s logic code to be accessed using the APIs for accessing native objects of the operating system. On top of the native object interop is a platform neutral interop that allows the object s logic code to be accessed by the platform neutral APIs. To allow the object s logic to be accessed the platform neutral interop translates between the API calls from the platform neutral APIs to the APIs used for accessing the native objects.

Referring to a process for creating an object such as object includes developing the object using the operating system neutral API of the execution environment library and designating an operating system for which the object is to be compiled . The operating system includes native objects and APIs for accessing the native objects of the operating system. The process also includes compiling the object for the designated operating system to generate a compiled object . The compiled object includes logic code a native object interop for accessing the logic code using the APIs for accessing native objects of the operating system and a platform neutral interop for accessing the logic code using the operating system neutral API.

The techniques described above are not limited to any particular hardware or software configuration. Rather they may be implemented using hardware software or a combination of both. The methods and processes described may be implemented as computer programs that are executed on programmable computers comprising at least one processor and at least one data storage system. The programs may be implemented in a high level programming language and may also be implemented in assembly or other lower level languages if desired.

Any such program will typically be stored on a computer usable storage medium or device e.g. CD Rom RAM or magnetic disk . When read into the processor of the computer and executed the instructions of the program cause the programmable computer to carry out the various operations described above.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be. Accordingly other implementations are within the scope of the following claims.

