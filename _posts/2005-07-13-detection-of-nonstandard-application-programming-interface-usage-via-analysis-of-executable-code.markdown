---

title: Detection of non-standard application programming interface usage via analysis of executable code
abstract: A method for detection of non-portable application programming interface usage via executable code analysis includes identifying one or more conditions for inclusion of an object class within a set of acceptable object classes, wherein a reference to any object class of the set of acceptable object classes by an application is in compliance with a specified portability criterion. The method further includes analyzing an executable version of the application to identify object classes referenced by the application, and generating a portability verification report for the application, wherein the report indicates that the application violates the specified portability criterion if an object class referenced by the application does not meet at least one of the conditions for inclusion in the set of acceptable classes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07945902&OS=07945902&RS=07945902
owner: Oracle America, Inc.
number: 07945902
owner_city: Redwood City
owner_country: US
publication_date: 20050713
---
The present invention is directed to computer systems. More particularly it is directed to verification of portability of computer system applications.

The complexity and expense of developing and deploying enterprise level computer systems applications has been increasing over time. In addition to supporting a rich set of functional features a modern enterprise application may also have to be scalable enough to support large numbers of concurrent users and provide a high level of availability maintainability and interoperability with other applications. The development cycle for a single major release of an application may take months or even years and may require hundreds of person years of development resources. As a result enterprise application vendors are understandably eager to reduce the total cost of application development.

In the past application vendors often developed a first version of an enterprise application for a particular execution platform e.g. a combination of a computer hardware architecture and an operating system designed for the hardware architecture and then ported the application to other execution platforms as needed. Each ported version of the application typically went through a quality assurance test cycle on the corresponding platform. Quality assurance testing during which the functionality performance and other features of the enterprise application are tested often represents a substantial portion of the total expense of application development. In order to reduce porting and testing costs and also in response to growing customer demand for applications that can be deployed across a variety of hardware architectures and operating systems in recent years many application vendors have begun to target their applications to application server environments such as the Java 2 Enterprise Edition J2EE environment that are intended to be platform agnostic. Typically a standards organization or a collaborative body such as the participants in the Java Community Process in the case of J2EE is responsible for defining standards for the application server technology in the form of formal specification documents. The specification documents define the functionality and interfaces that must minimally be supported for compliance with a particular version of the application server technology. As application server is typically designed and advertised as being compliant with a particular version of an application server technology and potential users and developers may consult the specifications associated with that version to determine the set of features supported by the application server. Applications developed in accordance with a particular version of a specification are expected in principle to be deployable without source code modification at any application server that conforms to that version of the specification e.g. simply by modifying runtime deployment descriptors regardless of the specific operating system or hardware architecture of the platform on which the application server is executed. Thus once an application vendor has developed and tested such a portable application on an application server on one platform no further source code changes should be required to deploy the application on other platforms and the application vendor should also be able to reduce or eliminate additional testing required for the other platforms.

Unfortunately application servers provided by different application server vendors may differ slightly in the set of functions and features provided even where the different application server vendors claim compatibility with the same set of specifications. For example the specifications may allow optional features or extensions to be implemented and different application server vendors may implement different sets of optional functions. As a result an application developed on a particular application server may sometimes use features such as application programming interfaces APIs that are vendor specific. Also some development environments may support the use of so called wrapper APIs that may allow developers to utilize standard APIs through non standard intermediary interfaces that may be easier to use than the standard APIs. Both vendor specific and wrapper APIs may make applications non portable that is applications using such non standard features may work as designed at one vendor s application server but may fail at another vendor s application server even when both vendors claim to support the same standard specifications. Some applications using non standard extensions may even work at application servers from more than one vendor e.g. if two or more vendors implement some of the same non standard extensions and hence may be considered at least somewhat portable in general however applications that use non standard extensions may not be guaranteed to work at all application servers that support the same standard specification and thus may raise portability concerns. Application customers that do not wish to be dependent upon specific vendors and application developers tasked with developing portable applications may therefore wish to determine whether a given application is truly portable.

Some traditional tools for identifying non portable features of applications may require access to application source code which may not be easily accessible to customers. Other conventional tools may attempt to build a repository of non standard features or APIs for various application server components and check whether any of the non standard features are used in an application. However it may be difficult to accurately track the set application server extensions being supported by all the different application server vendors. As a result an approach that relies on maintaining an exhaustive list of non standard features may not be accurate or complete in its identification of the non portable features of an application. In addition portability criteria may change over time e.g. as standards or specifications change and traditional portability verification tools may themselves require source code modifications to adapt to changes in portability criteria.

Various embodiments of a method and system for detection of non portable application programming interface usage via executable code analysis are disclosed. According to one embodiment a method includes identifying one or more conditions for inclusion of an object class within a set of acceptable object classes wherein a reference to any object class of the set of acceptable object classes by an application is in compliance with a specified portability criterion. The method further includes analyzing an executable version of the application to identify object classes referenced by the application and generating a portability verification report for the application wherein the report indicates that the application violates the specified portability criterion if an object class referenced by the application does not meet at least one of the conditions for inclusion in the set of acceptable classes. In one embodiment the application may reference one or more external classes e.g. classes that are not defined within the application itself or in optional libraries deployed with the application and a condition of the one or more conditions may include a requirement that each of the external classes is defined in a standard application programming interface specification such as a J2EE specification. Other conditions may include a requirement that the class be defined within the application or a shared library bundled within a deployed version of the application.

In one embodiment the method may include identifying root object classes e.g. classes that represent entry points that are called by an application server when an application request arrives in order to pass the execution context to the application referenced by a deployable version of the application and recursively parsing executable code corresponding to the root object classes to identify a transitive closure of the set of non root object classes referenced directly or indirectly by the root object classes. In parsing the executable code the method may include loading a byte stream representing the executable code of the object class into memory where the byte stream is formatted in accordance with an object class file format specification identifying a section of the byte stream that includes names of one or more classes referenced from the current class and obtaining the names of the referenced classes from that section. In some embodiments the class file containing the byte stream may be located and loaded into memory by a class file loader based on a class name and a search path. The root object classes may be identified from deployment descriptors included in a deployable version of the application in one embodiment e.g. from EJB module deployment descriptors and or web module deployment descriptors of a J2EE application. In one embodiment a method may include providing an interface to specify the portability criterion and in response to input via the interface identifying a new portability criterion without modifying source code.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

In one implementation the set of acceptable object classes may include object classes that are defined either within the application itself in object code packages or shared libraries bundled with the application or in the versions of the API standard specification identified by the portability criteria. In the following description the terms object class and class may be used synonymously. The executable version of the application may be analyzed for portability violations without requiring access to the source code of the application and or without actually executing the application thus allowing application customers and other interested parties to easily verify application portability without going to the trouble of analyzing source code and without incurring the expense of testing the application in an execution environment such as an application server.

In some embodiments application may be intended for deployment at an application server . An application server may be any type of execution environment designed to allow applications to be developed and deployed e.g. independently of the details of hardware architectures and operating systems and may be implemented using any of a variety of technologies in various embodiments. Application server may be configured to provide a variety of application server services e.g. services that implement commonly used functionality that may be useful to a variety of deployed applications such as transaction services security services connection pooling services messaging services etc. Various applications may utilize the specific sets of application server services that they require and application developers may simply employ the services provided by the application server without re implementing them for each individual application. In one embodiment application and application server may be configured to utilize J2EE technology in other embodiments other technologies such as .NET may be employed. In one embodiment application may be a standalone application that may be executable without being deployed to an application server .

Any type of application or a portion of a multi tiered application may be checked for portability according to specified portability criteria in various embodiments. Application may reference both internal classes and functions e.g. classes and methods defined and implemented within the application or in shared libraries bundled within a deployed version of the application as well as external classes and functions that may not be implemented within the application e.g. the classes and methods implementing common functions or services that may be provided by the application server and utilized by a variety of applications as described above such as transaction management functions security related functions connection pooling functions messaging functions etc. Portability criteria may be derived for example from one or more versions of an API specification associated with a particular application execution technology such as J2EE e.g. an application that references an external class that does not belong to a particular version of the specification may be considered non portable with respect to that version of the specification. An application may be a multi tiered commercial application such a web based electronic commerce system for example comprising a plurality of components some of which may be executed within an application server while others may be executed outside application server e.g. at one or more web servers and or back end database servers . Alternately in other embodiments the application may be a single tiered application such as a simulation tool that may be deployed in its entirety to the application server . In various embodiments application application server and portability verification tool may each be implemented using any desired combination of programming languages and or scripting languages.

An application server may implement a number of different types of containers to provide access to various objects and support the application server services described above as well as to provide a variety of other functions such as multithreading state management and the like. Before an application component is executed it may have to be assembled into a module and deployed within an appropriate container. Various modules of the application may in turn be aggregated into a deployable and executable format such as an ear enterprise archive file in some embodiments. For example in a J2EE environment a web component may have to be assembled into a J2EE web module and deployed into a web container at the application server for execution and an enterprise bean may have to be assembled into a J2EE Enterprise Java Bean EJB module and deployed into an EJB container. In some embodiments a J2EE application may include one or more resource adapter modules that may contain code that implements various functions for connecting with an Enterprise Information System EIS tier. In addition in one embodiment the deployable or executable version of the application may also be bundled with one or more sharable optional packages that may for example include a library of functions that may be accessed from the application modules such as web module enterprise bean module etc.

As shown in each assembled module may include a corresponding set of class files e.g. files including executable code or byte code for the functions implemented by the module and one or more deployment descriptors which may specify metadata such as container settings associated with the module. For example web module may include class files A and deployment descriptors A EJB module may include class files B and deployment descriptors B etc. The specific types of information included within deployment descriptors may vary from one container to another. Optional package may include meta information . In some embodiments the entire application may itself include a single high level deployment descriptor in addition to the individual deployment descriptors associated with each component. Each module may be incorporated within a corresponding file such as a jar or java archive file and the contents of the file may be organized hierarchically e.g. in a logical directory structure according to a specification associated with the module type e.g. a web module may be organized according to a first hierarchy an EJB module according to a second hierarchy etc. In some embodiments a module file such as a jar file or an application file such as an ear file may be expandable into a corresponding hierarchy of directories and files including the corresponding class file hierarchy e.g. by executing a command such as jar tvf .

In one specific embodiment a deployment descriptor B for an EJB module may be included within an XML Extensible Markup Language file called ejb jar.xml . An ejb jar.xml file may include a plurality of elements including a root element bracketed by the XML tags and and various elements nested within the root element such as a enterprise beans element a relationships element and an assembly descriptor element. The enterprise beans element may contain descriptive information about various types of enterprise beans such as session beans entity beans and message driven beans. Information relating various entity beans to each other e.g. using container managed relationship functionality provided by the application server may be included in the relationships element and transaction and security information may be included in the assembly descriptor element. For one or more enterprise beans included in the module a corresponding element nested within the enterprise beans element may identify various bean attributes including a logical name for the bean an object class of the bean and one or more component interfaces for the bean. For example information for a session bean may be included between and tags information for an entity bean within and tags and information for a message driven bean within and tags. The object class of the bean which may be identified in a sub element bracketed by and tags is the class that implements the business methods and or lifecycle management methods of the bean. The fully qualified class name of the object class may be specified within the and tags e.g. a string uniquely identifying the location of the class within a class hierarchy such as the string com.lmn.xyz.myclassA for the class myclassA allowing the location of the corresponding class file e.g. within a directory com lmn xyz in the case of com.lmn.xyz.myclassA within the module to be determined. Similar information may be provided in deployment descriptors for other modules e.g. in other XML files such as web module resource adapter module and sharable optional package module including identifications and locations of each of the top level or root classes defined within the module. A variety of formats and techniques for implementing deployment descriptors may be used in different embodiments e.g. for some versions of J2EE standards annotations as well as XML may be used for deployment descriptors. As described below in further detail portability verification tool may be configured to examine the deployment descriptors associated with various components of an application to identify a set of root classes of the components and to recursively analyze the class files corresponding to the root classes to identify violations of portability criteria . The root classes may comprise entry point classes in some embodiments i.e. classes that are called by an application server when an application request arrives in order to pass the execution context to the application.

In one embodiment where the application is deployed in a J2EE environment the principle of operation of the portability verification tool may expressed using set theory terminology as follows. If C is the set of classes referenced by the J2EE application i.e. a complete closure of the classes referenced directly or indirectly by the application A is the set of classes defined directly within the J2EE application O is the set of classes defined by the optional packages both bundled and non bundled optional packages that the J2EE application depends on and S is the set of classes J2EE standard classes that the application is allowed to access depending on the version of J2EE standard or standards that the application is written against e.g. the EJB 2.1 standard the task of the portability verification tool is to accurately and efficiently identify the set N of non standard APIs where N is defined according to set theory as minus union union 

The set S may be determined in such an embodiment from the relevant J2EE specifications and the sets C A and O may be determined as described below in further detail.

Having identified the conditions for categorizing object classes as acceptable classes portability verification tool may be configured to analyze an executable version of the application to identify the set of classes referenced in the application block of . As described below in further detail in one embodiment portability verification tool may be configured to recursively inspect object code for various object classes referenced by the application starting with a set of root classes identified in deployment descriptors associated with the modules of the application. During the inspection of the object code for a given class classes referenced by the given class may be identified thus potentially allowing portability verification tool to generate an exhaustive list of all the object classes referenced by the application. If a referenced class does not meet at least one of the conditions for inclusion in the set of acceptable classes identified in operations corresponding to block portability verification tool may be configured to make a determination that the application violates a portability criterion block . A portability report which may indicate the results of the analysis i.e. a determination whether the application is portable according to the specified criteria and or identify any classes found to be unacceptable or non portable may be generated at the end of the analysis. Portability report may be organized in a variety of formats in various embodiments for example in one embodiment in addition to conclusions regarding portability of the application it may include a list of the classes found to be referenced from the application. In another embodiment portability report may include a representation of the calling hierarchy or call graph for the referenced classes i.e. information identifying the specific classes that are referenced from each class in the application and or the sequence in which they are referenced .

Having identified the set of root classes portability verification tool may be configured to begin iterating over the classes in the To Be Analyzed set analyzing each class in turn. The next class to be analyzed may be selected from the To Be Analyzed set block . The manner in which the next class is selected from the To Be Analyzed set may differ in different embodiments for example in one embodiment a class may be selected at random from the To Be Analyzed set while in other embodiments classes may be selected from the To Be Analyzed set in first in first out FIFO sequence or last in first out LIFO sequence. During the analysis of a given class portability verification tool may be configured to determine whether the current class is defined in a standard API specification block of . The standard API specification may for example be included in a specification document identified in a portability criterion . In one implementation the portability verification tool may be configured to automatically generate a database or list of the APIs supported by the specification e.g. in the form of an XML file representing the set S described above by analyzing the text of a specification document. In other embodiments a list of the APIs supported by the specification may be generated externally and may be provided to the portability verification tool e.g. as part of a parameter file used to specify a portability criterion. The use of an interface such as a parameter file to specify the list of APIs or the corresponding standard specification document may enable portability verification tool to adapt gracefully as portability requirements or standards change without for example requiring source code changes in the tool itself. The portability verification tool may be configured to search the database corresponding to the API specification to determine whether the current class is defined in the specification. The database may be implemented using a variety of techniques in various embodiments such as using a text file or files one or more tables of a relational database system an XML document object etc. Various specific techniques may be used to perform the search in the API database e.g. depending on the manner in which the database is implemented a text search e.g. using a tool similar to the grep tool provided in various UNIX based operating systems a relational database query or a set containment query expressed in a language such as Java e.g. using a java.util.Set.contains method may be used.

If the class is found in the standard API specification it may be removed from the To Be Analyzed set block and the next class may be examined. If the class is not found in the standard API specification portability verification tool may be configured to analyze the object code of the class to identify additional classes referenced from that class and recursively analyze each referenced class in turn. As shown in portability verification tool may be configured to begin a search for a class file i.e. a file containing executable code or byte code corresponding to the current class being analyzed block . In the search for the class file portability verification tool may attempt to locate the class file among the modules of the application e.g. web module EJB module and Resource Adapter Module or in optional package block . If the class file is found within the modules of the application or in an optional package a byte stream representing the object code for the class may be loaded from the class file into memory block of reached by following the path through the connecting node labeled . The byte stream may then be examined to identify any classes referenced by the current class block of as described below in further detail in conjunction with the description of . If one or more referenced classes are found as determined in decision block of the referenced classes may be placed in the To Be Analyzed set block of . Whether referenced classes are found or not the current class may be removed from the To Be Analyzed set block of reached via connecting node and any remaining classes in the To Be Analyzed set may be analyzed starting with the operations corresponding to block of

In one embodiment portability verification tool may include a class file loader configured to perform the search for the class file described above. A class file loader may be provided a class name and a search path e.g. a set of file and or directory locations as inputs and the search path may be set to point to the modules of the application and or the optional packages so that for example classes belonging to the sets A and O described above may be identified using the search path. For example an exemplary search path for such a class loader may be specified as a colon separated list of jar files and directories such as as1 app1 x.jar as1 app1 y.jar as1 home opt. In this example when searching for a named class the class file loader may first examine the file x.jar located in the directory as1 app1. If the class is not found in x.jar y.jar in the same directory may be searched. The jar files x.jar and y.jar may each contain application module elements or components. If the class is not found in y.jar the directory as1 home opt which may contain optional packages may be searched. Files and or directories within the opt directory may be searched recursively as well until either a class file corresponding to the named class is found or no more files or directories remain to be searched. In one embodiment a fully qualified name for the current class may be provided as input to the class file loader. The class file loader may be implemented using any desired programming and or scripting language or languages in various embodiments. In one implementation for example where the Java programming language is used the class file loader may be implemented using the java.net.URLClassLoader class to load the class files. The search path may be formatted as one or more URLs Universal Resource Locator and passed as a parameter to a constructor for the URLClassLoader class in such an implementation and a method such as getResourceAsStream String resourceName may be used to find the class file.

In one embodiment where for example the application is deployed in a J2EE environment the class loader may be configured to use a search path which may also be termed a class path that follows class loading rules that are specified within a standard specification such as a J2EE platform specification. The application may be packaged using the Java Archive JAR format into a file with a .ear enterprise archive extension. The .ear file may include an application level deployment descriptor the application s own J2EE modules e.g. modules and which may themselves be packaged as jar files war files or rar files according to the JAR format libraries such as optional packages help files documentation etc. The class loading rules may include for example specific techniques to be used to indicate a path to the classes of an optional package from an application module or jar file. A JAR file may reference the classes of another jar file by naming the referenced file in a class path entry in the referencing file s manifest file according to one such rule. The referenced jar file may be named using a URL relative to the referencing file s URL. The manifest file may be placed in a specific directory within the referencing file such as META INF MANIFEST.MF and the class path entry within the manifest file may be specified as a list of jar files separated by spaces. The class path format and the rules for locating the class paths included in the specification may also be used by the class file loader during portability verification in some embodiments.

If the current class is not defined in the standard API specification and is not found in the application modules or the optional packages the class may be placed in the set of non portable classes e.g. in set N as described above block of and removed from the To Be Analyzed set block of . The operations corresponding to blocks onwards may then be repeated i.e. if any classes remain to be analyzed a particular class may be selected as the next class to be analyzed and operations corresponding to blocks onwards may be repeated for that class. If no classes remain to be analyzed as detected in decision block portability verification tool may be configured to generate portability report . If any classes are found in the non portable set as determined in block of reached by following a path through connecting node from portability verification tool may be configured to indicate that the application does not meet portability criteria and may include a list of the non portable classes in the report block of . If no non portable classes were found during the analysis portability verification tool may be configured to indicate that the application did not violate the portability criteria block of .

It is noted that by using the technique of recursively examining referenced classes as depicted in the embodiment of a transitive closure of all the classes that are referenced in the application e.g. set C as defined above starting from the root classes may eventually be examined. Furthermore unlike some conventional portability verification techniques the technique described above does not require a list or repository of non standard or vendor specific APIs to be generated or maintained. It is also noted that some of the operations illustrated in and may be performed in a different order in some embodiments for example the check as to whether the class is defined in the standard specification block may be performed after the search for the class files in the application modules and optional packages block . In one embodiment the operations of searching for the class among the application modules may be performed in a separate step than the operations of searching for the class among the optional packages.

In some embodiments optimizations may be made to some of the operations illustrated in . For example in one implementation portability verification tool may be configured to maintain a history or record of classes that have already been analyzed and may be able to avoid repeated analysis of the same class file. If a chain of references such as class A class B class C class D is followed during the analysis in such an implementation i.e. if class A references class B class B references class C class C references class D and class D references no further classes and the byte code each of the classes is examined for referenced classes as illustrated in portability verification tool may store a record of its analysis of the chain of references. If later in the analysis process class B is encountered again e.g. via another chain of references the portability verification tool may be configured to check whether class B has been analyzed before and may be able to avoid re loading and re analyzing classes class B class C and class D. In another optimization the analysis of different chains of class references may be performed in parallel in some implementations. For example in one such implementation portability verification tool may be multithreaded and each of two or more of its threads may be assigned to analyze a particular root class and the classes referenced directly or indirectly by the particular root class. In some configurations the number of threads that may be used for such parallel analysis may be governed by a configurable parameter e.g. an input parameter provided to portability verification tool .

As noted above in some embodiments portability verification tool may be configured to analyze a byte stream of executable code of a given class to identify any other classes referenced from the given class e.g. after reading the contents of the corresponding class file into memory using a class loader. The format in which executable code for a class is stored may in general vary from one execution environment to another and may be based on a formal object file format specification e.g. issued by a standards body. In some embodiments portability verification tool may be designed to support analysis of executable code in a variety of formats. In one such embodiment portability verification tool may be configured to receive information e.g. via an input parameter identifying or describing the specific format in which the executable code for a given application is organized.

In one specific embodiment where the Java programming language is used to implement the application the object code within a class file of the application may be formatted according to a standard defined in the Java Virtual Machine Specification. is a block diagram illustrating an exemplary class file structure organized in accordance with such a standard according to one embodiment. As shown the class file structure may include a plurality of elements such as Magic Number Minor Version etc. arranged in a specific sequence defined in the corresponding specification. Some elements may be of fixed length as indicated in column labeled Field Length Bytes while the length of other elements such as Constant Pool and Interfaces may vary from one class file to another based on the values of other elements in the class file. The size of the Constant Pool table for a given class file for example may be a function of the value of the Constant Pool Count element in that class file. Since the lengths of various elements of a class file structure are either invariant across all class files or determinable from values stored within the class file it may be possible to navigate to any element of interest within any given class file. For example as described below portability verification tool may be configured to navigate to the Constant Pool table to identify strings representing one or more classes referenced from the class corresponding to the class file.

The various elements of class file structure may represent the following information. Magic Number may be used as an identifier for the class file format itself. Minor Version and Major Version may identify the specific version of the class file format identified by Magic Number. Constant Pool Count may indicate the number of entries in Constant Pool which may be organized as a table of string constants class and interface names field names and other constants that are referred to within the class file. Class names may be stored in fully qualified form within Constant Pool . Access Flags may be a mask of flags used to denote access permissions to the class file. This Class and Super Class may be pointers into the Constant Pool table identifying the names of the current class i.e. the class whose executable code is in the class file and its parent class respectively. Interfaces Count may indicate the number of direct superinterfaces of the current class and Interfaces may include pointers into Constant Pool table where the names of the superinterfaces are stores. Fields Count may indicate the number of fields declared in the current class and described in the Fields element . Similarly Methods Count may indicate the number of methods declared in the current class and described in Methods structure and Attributes Count may indicate the number of attributes of the current class stored in Attributes structure .

In embodiments where the format illustrated in is employed for storing the executable version of an object class portability verification tool may be configured to identify referenced classes from the names stored in the Constant Pool table . In some implementations portability verification tool may utilize an existing set of utilities or functions such as the Byte Code Engineering Library BCEL available from Apache Software to extract names of referenced classes from the Constant Pool table . For example BCEL provides a package called org.apache.bcel.classfile to access and manipulate class file structure and includes interfaces such as org.apache.bcel.classfile.Visitor to provide access to various elements of the class file structure.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

