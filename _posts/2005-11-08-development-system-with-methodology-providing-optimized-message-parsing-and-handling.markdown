---

title: Development system with methodology providing optimized message parsing and handling
abstract: A development system with methodology providing optimized message parsing and handling is described. In one embodiment, for example, a computer-implemented method is described for improved processing of certain types of messages, the method comprises steps of: loading metadata at design time, the metadata characterizing a particular message type; based on the metadata, automatically generating source code for creating runtime components highly optimized for the particular message type; compiling the source code into the runtime components, for deployment in a runtime environment; and at runtime, processing messages of the particular message type with the runtime components, so that messages are processed in a manner that is highly optimized for the particular message type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07844957&OS=07844957&RS=07844957
owner: Sybase, Inc.
number: 07844957
owner_city: Dublin
owner_country: US
publication_date: 20051108
---
The present application is related to and claims the benefit of priority of the following commonly owned presently pending provisional application s application Ser. No. 60 595 962 filed Aug. 19 2005 entitled Development System with Methodology Providing Optimized Message Parsing and Handling of which the present application is a non provisional application thereof. The disclosure of the foregoing application is hereby incorporated by reference in its entirety including any appendices or attachments thereof for all purposes.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Computer Program Listing Appendix under Sec. 1.52 e This application includes a transmittal under 37 C.F.R. Sec. 1.52 e of a Computer Program Listing Appendix. The Appendix which comprises text file s that are IBM PC machine and Microsoft Windows Operating System compatible includes the below listed file s . All of the material disclosed in the Computer Program Listing Appendix can be found at the U.S. Patent and Trademark Office archives and is hereby incorporated by reference into the present application. Object Description SourceCode.txt size 1196568 Bytes created Ser. No. 11 07 2005 4 22 48 PM Object ID File No. 1 Object Contents Source code.

The invention relates generally to data processing environments and more particularly to those data processing environments that process messages.

Computers are very powerful tools for storing and providing access to vast amounts of information. The first personal computers were largely stand alone units with no direct connection to other computers or computer networks. Data exchanges between computers were mainly accomplished by exchanging magnetic or optical media such as floppy disks. Over time more and more computers were connected to each other and exchanged information using Local Area Networks LANs and or Wide Area Networks WANs . Initially such connections were primarily amongst computers within the same organization via an internal network.

More recently the explosive growth of the Internet has provided access to tremendous quantities of information from a wide variety of sources. The Internet comprises a vast number of computers and computer networks that are interconnected through communication links. In order to make the best use of these resources various protocols have been developed. Health Level Seven HL7 for example is one of several American National Standards Institute ANSI accredited Standards Developing Organizations SDOs operating in the healthcare arena. Health Level Seven s domain is clinical and administrative data pertinent to healthcare. Level Seven refers to the highest level of the International Organization for Standardization ISO communications model for Open Systems Interconnection OSI the application level. The application level addresses definition of the data to be exchanged the timing of the interchange and the communication of certain errors to the application. The seventh level supports such functions as security checks participant identification availability checks exchange mechanism negotiations and most importantly data exchange structuring. HL7 is responsible for maintaining guides for HL7 messages that can stand alone or be embedded within ASC X12N transactions. As such HL7 addresses the movement of messages in a healthcare environment including the representation of the connections that exist between the information carried in the fields of HL7 messages.

HL7 is but one example of a messaging environment. Other examples include enterprise application integration EAI business process management database messaging real time systems e.g. satellites and monitoring devices and wireless communication. As is the case with HL7 messages these environments entail the movement of business application data in a given environment. This type of information typically includes a defined standard or format and employs metadata.

Most messaging systems tend to employ generic engines that at runtime discover information about what the given message is including using metadata at runtime in an interpreted fashion. Thereafter individual messages may be parsed. The generic approach has a major disadvantage in that the implementation of a generic engine requires a relatively large amount of conditional logic i.e. executable program logic to handle all the various scenarios that exist. This additional conditional logic requires additional processor CPU and memory resources. As most of this processing turns out to not be required for the given task at hand the generic approach ends up providing a highly inefficient solution. As a result disadvantages encountered include the following performance insufficient for high volume messaging underutilization of platform inadequate performance limited environments supported e.g. implemented in non portable programming language and unnecessary data normalization e.g. unnecessary code set conversion and unnecessary integer endian format conversion .

At the same time however there is increasing customer demand in the EAI market place for better performance so that businesses have quicker access to the business processes and information necessary for efficiently running one s business. Additionally given ever present economic constraints business customers also demand better utilization of hardware platforms that they have already invested in i.e. computer hardware operating system and application environments such as J2EE . Presently existing systems are widely viewed by customers as not meeting these demands.

One attempt to address the foregoing is a brute force hardware upgrade. This includes increasing memory of the host system increasing CPU speed of the host system and increasing the number of CPUs on the host system. However even with ever increasing hardware performance available the brute force approach has not provided a solution that is sufficient for customers demands. Other attempts have focused on fine tuning or caching schemes including tune supporting software i.e. database e.g. indexes tuning operating system cache message buffer space avoiding costly system calls to allocate memory preload and cache message definition metadata e.g. memory resident metadata and cache message definition metadata avoid overhead and tune host application e.g. caching parsers . Fine tuning may include manually crafting individual components by hand i.e. manual coding in an effort to optimize a particular deployment s processing.

These attempts have their own problems. As these attempts do not address the underlying problem of inefficient generic program logic these attempts lead to inefficient utilization of the given underlying platform. The generic nature of these solutions diminishes potential performance as the solutions do not address wasteful processing and do not take full advantage of what is known at design time. The generic nature largely disregards real world usage and squanders an opportunity to leverage a given customer s knowledge of messages likely to be received for processing. Although the manual crafting of individual components may optimize a given deployment developing components by hand is time consuming expensive and error prone. As a result of these disadvantages existing systems do not scale well. Accordingly a better solution is sought.

A development system with methodology providing optimized message parsing and handling is described. In one embodiment for example a computer implemented method of the present invention is described for improved processing of certain types of messages the method comprises steps of loading metadata at design time the metadata characterizing a particular message type based on the metadata automatically generating source code for creating runtime components highly optimized for the particular message type compiling the source code into the runtime components for deployment in a runtime environment and at runtime processing messages of the particular message type with the runtime components so that messages are processed in a manner that is highly optimized for the particular message type.

In another embodiment for example a computer implemented system of the present invention providing optimized processing of messages is described that comprises metadata available at design time for characterizing a particular message type a designer module for generating source code in response to the metadata the source code for creating runtime components highly optimized for the particular message type a compiler for compiling the source code into the runtime components and a runtime environment for deploying the runtime components wherein messages of the particular message type are processed in a highly optimized manner by the runtime components.

In yet another embodiment for example an improved method of the present invention is described for processing messages the method comprises steps of analyzing metadata at design time for a particular message type based on the metadata dynamically generating message handling components that are highly optimized for the particular message type and deploying the dynamically generated message handling components in a runtime environment such that messages having the particular message type are handled in a highly optimized manner.

In another embodiment for example a method of the present invention is described for dynamically creating customized message processing components the method comprises steps of passing information about a particular wire format to a parser generator which creates a first set of source code for a customized parser component passing the information to a serializer generator which creates a second set of source code for a customized serializer component compiling the first and second sets of source code for generating runtime versions of the customized parser and the customized serializer and wherein the customized parser and the customized serializer may be deployed for optimized processing of messages utilizing the particular wire format.

In still another embodiment for example a system of the present invention is described for processing messages that comprises metadata for a particular message type code generation modules for automatically generating based on the metadata message handling components that are highly optimized for the particular message type and a runtime environment that employs the components for processing messages of the particular message type in a highly optimized manner.

In another embodiment for example a system of the present invention for dynamically creating customized message processing components is described that comprises a parser generator for creating a parser component customized for a particular wire format a serializer generator for creating a serializer component customized for the particular wire format and a runtime environment for deployment of the parser component and the serializer component so that messages of the particular wire format are processed by components specifically customized for that wire format.

The following definitions are offered for purposes of illustration not limitation in order to assist with understanding the discussion that follows.

Coded Character Set A character set in which each character is assigned a numeric code value. Frequently abbreviated as character set charset or code set.

Data Scrubbing Data scrubbing is the process of fixing or eliminating individual pieces of data that are incorrect incomplete or duplicated before the data is passed to a data warehouse or another application.

Data Validation A process used to determine if data is accurate complete or meets specified criteria.

DOM Short for Document Object Model the specification for how objects in a Web page text images headers links etc. are represented. The DOM defines what attributes are associated with each object and how the objects and attributes can be manipulated.

Eclipse The Eclipse Platform is designed for building integrated development environments IDEs that can be used to create applications as diverse as web sites embedded Java programs C programs and Enterprise Java Beans.

Parser A software component that takes a serialized object and converts it into an in memory object e.g. DOM or Java object .

WFIM Wire Form Intermediate Model describes the logical and physical attributes of a Format. The logical attributes of the Format are stored in an XML Schema that is referenced from a WFIM file.

Wire format The physical attributes of a message. These attributes include data types tags field delimiters container delimiters coded character set etc.

XML Short for Extensible Markup Language a specification developed by the W3C. XML is a pared down version of SGML designed especially for Web documents. It allows designers to create their own customized tags enabling the definition transmission validation and interpretation of data between applications and between organizations. For further description of XML see e.g. Extensible Markup Language XML 1.0 specification which is available from the World Wide Web Consortium www.w3.org the disclosure of which is hereby incorporated by reference. The specification is also available on the Internet e.g. currently at www.w3.org TR REC xml .

Referring to the figures exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention which is implemented in desktop and or server software e.g. driver application or the like operating in an Internet connected environment running under an operating system such as the Microsoft Windows operating system. The present invention however is not limited to any one particular application or any particular environment. Instead those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms including Macintosh Linux Solaris UNIX FreeBSD and the like. Therefore the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts each block within the flowcharts represents both a method step and an apparatus element for performing the method step. Depending upon the implementation the corresponding apparatus element may be configured in hardware software firmware or combinations thereof.

The present invention may be implemented on a conventional or general purpose computer system such as an IBM compatible personal computer PC or server computer. is a very general block diagram of a computer system e.g. an IBM compatible system in which software implemented processes of the present invention may be embodied. As shown system comprises a central processing unit s CPU or processor s coupled to a random access memory RAM a read only memory ROM a keyboard a printer a pointing device a display or video adapter connected to a display device a removable mass storage device e.g. floppy disk CD ROM CD R CD RW DVD or the like a fixed mass storage device e.g. hard disk a communication COMM port s or interface s a modem and a network interface card NIC or controller e.g. Ethernet . Although not shown separately a real time system clock is included with the system in a conventional manner.

CPU comprises a processor of the Intel Pentium family of microprocessors. However any other suitable processor may be utilized for implementing the present invention. The CPU communicates with other components of the system via a bi directional system bus including any necessary input output I O controller circuitry and other glue logic . The bus which includes address lines for addressing system memory provides data transfer between and among the various components. Description of Pentium class microprocessors and their instruction set bus architecture and control lines is available from Intel Corporation of Santa Clara Calif. Random access memory serves as the working memory for the CPU . In a typical configuration RAM of sixty four megabytes or more is employed. More or less memory may be used without departing from the scope of the present invention. The read only memory ROM contains the basic input output system code BIOS a set of low level routines in the ROM that application programs and the operating systems can use to interact with the hardware including reading characters from the keyboard outputting characters to printers and so forth.

Mass storage devices provide persistent storage on fixed and removable media such as magnetic optical or magnetic optical storage systems flash memory or any other available mass storage technology. The mass storage may be shared on a network or it may be a dedicated mass storage. As shown in fixed storage stores a body of program and data for directing operation of the computer system including an operating system user application programs driver and other support files as well as other data files of all sorts. Typically the fixed storage serves as the main hard disk for the system.

In basic operation program logic including that which implements methodology of the present invention described below is loaded from the removable storage or fixed storage into the main RAM memory for execution by the CPU . During operation of the program logic the system accepts user input from a keyboard and pointing device as well as speech based input from a voice recognition system not shown . The keyboard permits selection of application programs entry of keyboard based input or data and selection and manipulation of individual data objects displayed on the screen or display device . Likewise the pointing device such as a mouse track ball pen device or the like permits selection and manipulation of objects on the display device. In this manner these input devices support manual user input for any process running on the system.

The computer system displays text and or graphic images and other data on the display device . The video adapter which is interposed between the display and the system s bus drives the display device . The video adapter which includes video memory accessible to the CPU provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a cathode ray tube CRT raster or liquid crystal display LCD monitor. A hard copy of the displayed information or other information within the system may be obtained from the printer or other output device. Printer may include for instance an HP LaserJet printer available from Hewlett Packard of Palo Alto Calif. for creating hard copy images of output of the system.

The system itself communicates with other devices e.g. other computers via the network interface card NIC connected to a network e.g. Ethernet network Bluetooth wireless network or the like and or modem e.g. 56K baud ISDN DSL or cable modem examples of which are available from 3Com of Santa Clara Calif. The system may also communicate with local occasionally connected devices e.g. serial cable linked devices via the communication COMM interface which may include a RS 232 serial port a Universal Serial Bus USB interface or the like. Devices that will be commonly connected locally to the interface include laptop computers handheld organizers digital cameras and the like.

IBM compatible personal computers and server computers are available from a variety of vendors. Representative vendors include Dell Computers of Round Rock Tex. Hewlett Packard of Palo Alto Calif. and IBM of Armonk N.Y. Other suitable computers include Apple compatible computers e.g. Macintosh which are available from Apple Computer of Cupertino Calif. and Sun Solaris workstations which are available from Sun Microsystems of Mountain View Calif.

Software system includes a graphical user interface GUI for receiving user commands and data in a graphical e.g. point and click fashion. These inputs in turn may be acted upon by the system in accordance with instructions from operating system and or client application module s . The GUI also serves to display the results of operation from the OS and application s whereupon the user may supply additional inputs or terminate the session. Typically the OS operates in conjunction with device drivers e.g. Winsock driver Windows implementation of a TCP IP stack and the system BIOS microcode i.e. ROM based microcode particularly when interfacing with peripheral devices. OS can be provided by a conventional operating system such as Microsoft Windows 9 Microsoft Windows NT Microsoft Windows 2000 or Microsoft Windows XP all available from Microsoft Corporation of Redmond Wash. Alternatively OS can also be an alternative operating system such as the previously mentioned operating systems.

In accordance with the present invention the generic engine approach is eschewed in favor of an approach employing specialized components. In particular dynamically created components are utilized and thus are very specific i.e. customized for and thus highly optimized for the types of data that they will be processing. Central to any messaging system is the ability to parse serialized data and transform in memory data objects into serialized messages. The components of the system of the present invention provide this capability in a manner that can be utilized in a variety of applications. For example message parsers and serializers can be integrated into technologies such as message brokers business process integration servers extract transform load solutions data replication wireless messaging database messaging and the like.

During design time usage of the system by the developer user these components are designed tested and generated within a graphical user interface known as the Message Designer which allows the developer to compile at design time everything that he or she knows about the metadata of the target message format thereby eliminating unnecessary conditional code and unnecessary conversion of metadata . Metadata itself refers to data about data which is used to capture the logical and physical structure of a message e.g. what elements exist in a message what are their data types what the data s cardinality is tags delimiters and the like . The metadata may be the pre existing data that describes the logical and physical structure of a given message format or may be discerned from self describing data e.g. XML files . In either case the metadata itself is represented in an XML markup file in the currently preferred embodiment.

In order to achieve increased performance the system of the present invention adopts an approach that moves away from generic metadata driven engines to optimized components which are generated by translating metadata into an executable form. As a result conditional logic is restricted to the dynamic nature of the run time data. For example if an element repeats in an unbounded fashion i.e. unknown at design time conditional logic must exist to loop through instances of the repeating data. However any information that is known at design time will be manifested in code in a highly efficient manner. Unnecessary conversion of elements of metadata such as tags and delimiters is eliminated. Further the coded character set of the message format is recognized and captured at design time thereby eliminating the need to query that through some means at runtime.

As a further optimization in the system of the present invention the generated components perform just in time work. For example as message data arrives over the wire in a particular form the components leave that data in that particular form until the moment that that data is actually needed to be in a different form. For example data validation is not performed unless it is necessary. Similarly data formatting is not done until necessary for example changing decimal format date format and character set conversion are not performed until necessary. In most cases the data may be left alone i.e. does not need to be normalized and may instead be forwarded to other systems in its present format.

The system does not maintain unnecessary copies of parsed data. For example when a system parses messages it will often create a duplicate of the data that has been parsed e.g. by maintaining a message buffer of parsed data and maintaining an in memory representation of that buffer . That approach is inefficient as it uses far more memory than is required. The system of the present invention in contrast employs a memory efficient approach that maintains only a single buffer and instead uses references to point into buffer positions items may be indexed as well.

The approach of the present invention may be summarized as follows. Rather than load metadata describing messages at run time the system of the present invention uses metadata as source to generate executable code. Anything that is captured in metadata is compiled into code thereby eliminating unnecessary conditional code. Literal values are converted into the precise binary form required at run time and are included in the generated code. The system eliminates wasteful run time processing by deferring unnecessary conversions and formatting such as JIT data type conversion coded character set conversion JIT validation and JIT data formatting. Unnecessary copies of parsed data are not kept in contrast to prior art systems . Data may be inserted and retrieved in a direct manner e.g. direct get and set access operations thereby avoiding less efficient approaches such as tree traversal in a DOM . All told the present invention avoids the prior art approach of loading metadata at runtime and processing messages in a generic but highly inefficient manner.

Overall system design is perhaps best described in terms of design time and run time system architecture and operation. is a simplified block diagram illustrating design time . Conceptually the design time involves three processes component design and construction build generate and test and packaging . During the component design and construction process the user creates message definitions with a Message Designer . The Message Designer allows the user to capture metadata that defines the characteristics of serialized data. With this metadata the user can generate parsers serializers and data objects. Once the design process is complete the user can test components. Prior to generating these components the user sets preferences which affect the build. These preferences include logging validation and performance instrumentation. The deployable unit generated by the design time tools is a set of JAR files in the currently preferred embodiment. Java class files are packaged as JAR files using standard tools. The Message Designer does not include other deployment tooling in the currently preferred embodiment as generated components may be used in products with very different run time environments.

Runtime is illustrated in . As shown it involves parsing and serialization of data use of the packaged components . Messages e.g. message are handed to parsers e.g. parser based on type. For example an HL7 A07 message would be handed to a parser built specifically for that message type. As the parser processes the message it generates events that are passed to a populator. The populator knows the data object and how events should be processed. At the end of a parse a valid data object should exist. Serializers e.g. serializer take a single data object as input and produce a serialized representation of the object as output message . A serialized buffer is employed that conforms to a wire format specification detailed in the Message Designer e.g. types tags delimiters padding field length and the like .

The WFAPI is the Wire Format Application Programming Interface. It is used to read write and validate wire format definition files WFIM files . The WFIM Wire Format Intermediate Model is the metadata that describes the applicable wire format. The metadata includes information such as structure data types cardinality tags delimiters and the like. The WFIM serves both as input and output of the Message Designer . In the currently preferred embodiment WFIM information is passed as an XML document that describes the logical and physical attributes and the wire format. Supported wire formats in the currently preferred embodiment include Custom Wire Form XML HL7 X12 EDIFACT SWIFT and FIX.

The Generator represents generators for parsers serializers data objects Java Schema Objects and XSDs. During system operation the Message Designer calls a parser generator passing it a WFIM object leading to the generation of parser source which is in turn compiled into a parser class. It calls separate generators for the serializer and the data object. During the generation process a WFIM is passed to a generator which produces an XSD e.g. XSD . The XSD serves as input to serializer and data object generation. The XSD is also used to model data objects in applications that use this technology e.g. Business Process Management System . Similarly a serializer generator is called. Input to the serializer generator is an XSD and a WFIM file. The output of the generator is a Java source code file which is subsequently compiled into a serializer class. Finally a Java Schema Object data object generator is called. The input is an XSD. The generator produces Java code for the data object which is then compiled creating compiled data object classes.

The Parser Source represents the Java code generated by the parser generator. This comprises the Java source representing the logic needed to parse the message defined by the Message Designer. Similarly the Serializer Source represents the Java code generated by the serializer generator. This Java source represents the logic needed to serialize the messaged defined by the Message Designer. In the currently preferred embodiment one Java .java file is generated for each parser and for each serializer. The Java Schema Object Data Object Source represents the Java code generated by the data object generator. There may be one or more Java .java files generated per data object. The Compiler is a Java compiler such as provided in the Java JDK . The compiler takes the foregoing Java source files as input and produces the desired respective Java classes. These compiled classes are in turn instantiated at runtime as runtime objects Parser Serializer and Java Schema Object .

The Java Schema Object JSO will now be described in further detail. As described above the JSO is a runtime data object. Like the parsers and serializers the Java Schema Object is generated for a specific application. The source metadata for a Java Schema Object is an XML Schema file which provides the structure of the data and the data types or the closest approximation . It is populated by generated Parsers and it is serialized by the generated Serializers. The Java Schema Object can be quickly populated and data can be retrieved very quickly. Although the JSO is currently implemented as a Java object those skilled in the art will appreciate that the data object could be implemented with similar technologies such as XML Beans or Java Architecture for XML Binding JAXB . Regardless of its particular implementation form the data object should allow for the storage of raw data i.e. not require data normalization and it should provide direct access without the need to do expensive tree traversals.

The WFIM document is linked to a content model file that describes the logical model of the Order message type. The parser is built specifically to parse a message that conforms to the definition described in the WFIM . Like the parser the serializer is built specifically to serialize a message with the physical attributes described in the WFIM . The data object generated is built specifically to hold the data extracted at parse time or needed for serialization.

Recall that the data object in the currently preferred embodiment is implemented as a Java Schema Object JSO . The JSO serves as the data container that is populated by the generated parsers and serialized by the generated serializers. Its part in code generation is simply to provide the necessary getters and setters. These getters and setters provide direct access to data without the need to do a tree traversal e.g. DOM . Thus the JSO is both a runtime container and a part of code generation. Although the JSO is the current data container another data container can be used as long as it provides direct access to data for setting and retrieving data.

A Wire Format Metadata API is provided for reading and writing WFIM files. In addition it provides a means by which applications such as the Message Designer create and modify wire format metadata.

Parsers are message type specific runtime components. During the earlier parser generation process that creates the runtime parser wire format metadata is read and translated into optimized code which ultimately is compiled to generate a given runtime parser. In order to simplify the generation of message type specific parsers a common Parser API is provided for implementing behavior common across different message types. Parser code logic may be partitioned into two groups of code the Serializer API and the code produced by the Serializer Generator.

During runtime operation a parser receives messages in buffer form whereupon it parses that buffer to produce a data object containing message data. Specifically a given parser takes as input a message buffer for its specific message type i.e. a serialized data object with a well defined physical form and then proceeds to populate a message type specific data object. As the parser identifies elements of data events are generated. The events are passed to the data object via a populator mechanism. The data object represents the in memory representation of the message buffer.

As illustrated in the system includes interfaces allowing the Message Designer to invoke the Parser Generator Engine passing it preferences and the location name of the WFIM . Given the URI of the WFIM the Parser Generator retrieves the wire format metadata. The generator then builds the parser source using the preferences specified by the user. Once the Parser Generator constructs the Java source for the Parser it invokes the Java compiler which produces the necessary compiled parser class files for runtime.

Generated serializers are message type specific components that take a data object as input and produce a serialized message with the appropriate wire format. Thus a given message type specific serializer takes a message type specific data object as input and produces the serialized form of the data object which is then placed in the data buffer. Like parsers the serializers included code logic that may be partitioned into two groups of code. The majority of the serializer logic is based on a Serialization API the Serializer Generator produces a thin layer of code on top of the Serialization API.

The system includes interfaces for serializing as illustrated in . The Message Designer invokes the Serializer Generator Engine passing it preferences and the URI of the WFIM . Given the URI of the WFIM the Serializer Generator Engine retrieves the wire format metadata. The Serializer Code Generator reads a wire format definition i.e. detail the attributes of a message type and produces a serializer for that specific wire format. The XSD name and location are provided in order to provide code generation capabilities related to data extraction from the data object.

Using the preferences specified by the user and the WFIM the Serializer Generator Engine builds the serializer source . Here the Serializer Generator Engine produces a Java source file representing source code of a message specific serializer. Once the Serializer Generator Engine constructs the source for the Serializer it invokes the Java compiler which produces the necessary compiled class file s for runtime. The now generated serializer includes the features specified by the preferences e.g. coded character set performance instrumentation etc. . A separate generator produces class files representing the data object consumed by the aforementioned specific serializer.

The following description presents method steps that may be implemented using processor executable instructions for directing operation of a device under processor control. The processor executable instructions may be stored on a computer readable medium such as CD DVD flash memory or the like. The processor executable instructions may also be stored as a set of downloadable processor executable instructions for example for downloading and installation from an Internet location e.g. Web server . The Eclipse Platform may be used for editing and compiling the Java programs below.

The model for a particular message may be represented as a hierarchical structure in memory having a root node with several associated attributes or children. The root node represents the message in its entirety and the children represent the various parts of the message. For example given a purchase order message the purchase order root node may be called purchase order which in turn has different children such as account number order date order items and the like. Individual children may have their own attributes such as specific data type e.g. String or date time tag s delimiter repeating versus nonrepeating and so forth. In this manner everything about a specific wire format may be captured by this in memory model.

Once the model has been created the system is now ready to pass the model on to the parser generator which iterates through the model generating the corresponding parser source code in a buffer at step . In the currently preferred embodiment the source code is generated using the Java programming language. However those skilled in the art will appreciate that the method may be implemented using programming languages other than Java such as C C C Visual Basic or the like. Code generation proceeds using tree traversal technique as follows. Starting with the root node which itself has particular attributes the method generates code that represents parsing of the root node. For example root attributes include information about the message encoding and locale and the method therefore at this point generates parser source corresponding to those attributes.

In this manner the method at this point may iterate through the model and generate snippets of source code for the various nodes and attributes present in that model. Should the method detect any missing mandatory attributes or other errors in the metadata during this iteration it may report those to the user for input or correction. The generation of source yields a buffer that comprises an entire Java source code file which in turn represents the particular parser of interest for the given wire format under consideration . After generation is complete the source buffer is written to the file system as indicated by step . Subsequently the source code file Java may be compiled into a Java class .class file as indicated by step . Throughout the generation and compilation method steps the Message Designer monitors processing and reports back to the user any errors detected.

By way of example a parser generate method may be constructed as follows for creating program code for parsing a tag and data field 

As shown the method is invoked with a TagAndDataField component object and returns a string buffer of the generated Java method for parsing the tag and data field. In operation the generate method generates code for tag parsing based on tag type including converting the tag literal into its run time format. The operation of the method is straightforward. Beginning at line 18 the method generates a method signature for the Java method that is being generated for this particular object to be parsed . This is followed by program logic that constructs the rest of the generated method. For example local variables for the method are generated beginning at line 27. This is followed by program logic that generates Java code to perform the actual parsing for the tag of the parsed tag and data field beginning at line 40. Similarly program logic to generate code for parsing the data following the tag begins at line 58.

An example of an actual generated Java method created from the above parser generate method is as follows 

The generated method illustrated above is a parseFirstName method that has been created for parsing a First Name tag and data field. As shown the generated method includes program logic for parsing the tag e.g. beginning at line 11 and program logic for parsing the data e.g. beginning at line 20 until a corresponding delimiter is found if any . Having parsed the particular First Name tag and data field at runtime the generated method may now push a corresponding data type object into an event queue which is subsequently used to populate the data object.

The remaining steps correspond to similar steps previously described for method . Specifically the system passes the model on to the serializer code generator which may iterate through the model for generating corresponding serializer source code in a buffer at step . The generation of source yields a buffer that comprises an entire Java source code file which in turn represents the particular serializer of interest for the given wire format under consideration . After generation is complete the source file is written to the file system as indicated by step . Subsequently the source code file .java may be compiled into a Java class .class file as indicated by step .

By way of example a corresponding serializer generate method may be constructed as follows for creating program code for serializing the previously illustrated tag and data field 

Importantly the serializer generate method generates program code for retrieving field data via a get method i.e. corresponding to object getter and setter access methods beginning at line 16. Code that serializes field values i.e. returned from the get access method invocation is generated beginning at line 63. Should the generate method encounter bad input e.g. malformed hex string it will throw an exception. At the completion of code generation the generated Java code is returned in a buffer codeBuffer .

An example of actual generated Java code created from the above serializer generate method is as follows 

As shown the generated code checks to see if the desired data element exists. In the event that it does the generated code proceeds to create the corresponding output context and data type for serialization. The actual call to perform the serialization occurs at line 15 upon invocation of a serializeTagAndDelimiterField routine.

Integration brokers provide technology to share data amongst information systems within an enterprise. Typically integration brokers are built upon message based middleware. Integration brokers receive data from source nodes transform the data and route the data to target nodes. This requires the ability to parse transform and serialize data. In most cases integration broker are stateless. The handling of each inbound message occurs within the context of a single transaction.

Business Process Integration BPI provides all of the capabilities of an integration broker but does so within the context of a stateful business process. A business process commonly involves communication with several systems over a variety of transports with a variety of protocols. For example a business process may query data from a database transform the data and then serialize the data to a queue.

Extract Transform Load ETL solutions are commonly used to move data from one source to another. ETL might be used to move data from a legacy system to a new system. It may also be used to populate a data warehouse. It can also be used to move data from database to database including performing data scrubbing when necessary. Unlike Integration Brokers and BPI ETL is often done in batch.

EDI Servers read parse transform and serialize records often producing files as output. Parsers can be used to deserialize EDI records and Serializers can be used convert in memory objects into EDI records.

Databases may be allowed to interface directly with messaging systems. For example an insert in a database table might lead to the creation of a message that is placed on a queue.

Data producing applications provide data for other applications and databases. For example the data producing application might be a user interface that collects information for a credit application. This data could then be serialized and place on a queue to be routed to one or more back end systems.

Data consuming applications receive data from other systems. For example a user interface might be used to display real time information regarding objects in orbit around the earth. The data source might be an application that reads sensor data and then propagates the data to a monitoring console.

While the invention is described in some detail with specific reference to a single preferred embodiment and certain alternatives there is no intent to limit the invention to that particular embodiment or those specific alternatives. For instance those skilled in the art will appreciate that modifications may be made to the preferred embodiment without departing from the teachings of the present invention.

