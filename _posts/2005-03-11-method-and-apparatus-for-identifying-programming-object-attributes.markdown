---

title: Method and apparatus for identifying programming object attributes
abstract: The present invention provides a method and computer-readable medium for searching for programming objects on a computer system. Under the invention, object attributes that are stored outside of a static attribute storage area are inspected during the search for programming objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07584169&OS=07584169&RS=07584169
owner: Microsoft Corporation
number: 07584169
owner_city: Redmond
owner_country: US
publication_date: 20050311
---
This is a divisional of and claims priority from U.S. patent application Ser. No. 09 871 550 filed on May 31 2001 and entitled METHOD AND APPARATUS FOR IDENTIFYING PROGRAMMING OBJECT ATTRIBUTES which claimed priority from a U.S. Provisional Application having serial number 60 219 861 filed on Jul. 20 2000 and entitled MICROSOFT SPEECH SDK SAPI 5.0 .

The present invention relates to object oriented programming. In particular the present invention relates to identifying attributes of programming objects.

In object oriented programming an object is a set of programming instructions that supports one or more methods and or has one or more properties. A method in an object can be called by instantiating the object loading the object into memory and then making a call to the method exposed by the object. A property of an object can be set by instantiating the object and then setting the property.

In some programming environments multiple objects may expose the same method but may work in different ways. At times these differences can be significant and an application that wants to invoke the method may want to know how the object will behave before it instantiates the object.

To allow for this some object oriented systems provide lists of attributes for objects that have been registered with the system. In particular the Component Object Model COM uses a technique known as Component Categories to maintain a list of object attributes in the local registry. This list can be queried before a COM object is instantiated to determine if the object meets a set of attributes.

Although the Component Categories technique is useful it has several limitations. First it relies on the attributes being statically present on a local computer. As a result COM objects must have their attributes stored on each local machine resulting in redundant sets of data. In addition object classes that are made available dynamically or that have their attributes stored outside the local machine cannot be found using component categories.

Second when searching Component Categories it is difficult to find objects with desirable but not mandatory attributes. Under Component Categories each of the search criteria is considered mandatory. If an object does not meet the search criteria it is not returned. Thus optional criteria cannot be placed in a first search for objects.

Because of this an object or application performing a search must do several search iterations to find objects with optional attributes. In particular the searching application must perform a first search for required attributes then perform separate searches for each optional attribute.

Lastly the Component Categories technique does not integrate well with systems that change the behavior or attributes of objects after the objects have been instantiated. In many programming environments objects are written in a general fashion to support a set of basic methods but the manner in which they support them is dependent on their data source. For example a text to speech object can be written to support the basic methods involved in converting text into speech while the sound of the voice for example male or female can be set by selecting a data source that contains the attributes of the voice. If one data source is used with the text to speech object a male voice is heard if a different data source is used with the same text to speech object a female voice is heard.

These types of systems do not work well with Component Categories because a single object listed in the Component Categories cannot have conflicting parameterizations. Taking the example above the text to speech object cannot have an attribute for gender set to both male and female .

Because of this programmers that want to use Component Categories with such adaptable objects have had to generate different objects for each different combination of attributes. Thus instead of creating and registering one COM object programmers must create and register a separate COM object for each set of attributes that they want to support for the object.

The present invention provides a method and computer readable medium for searching for programming objects on a computer system. Under the invention object attributes that are stored outside of a static attribute storage area are inspected during the search for programming objects.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way o example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is preferably allocated as addressable memory for program execution while another portion of memory is preferably used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is preferably executed by processor from memory . Operating system in one preferred embodiment is a WINDOWS CE brand operating system commercially available from Microsoft Corporation. Operating system is preferably designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device within the scope of the present invention.

Servers and have access to databases and respectively. The databases contain data and or programming objects and can be found in a storage medium or in the active memory of the server. Each client also has access to data and programming objects that are stored on storage devices or active memory in the client.

In one embodiment network connection is an Internet connection that provides access to other servers and networks in addition to LANs and . In other embodiments network connection is a private connection between LAN and LAN . Each of the clients and servers of LANs and may also be connected to a separate dial up network such as network .

Under the present invention a method and computer readable medium are provided that allow applications to identify the attributes of objects without requiring the object s attributes to be present in a static attribute storage location such as the local registry or a local file. In addition the present invention allows applications to designate optional attributes for the object when making a single search call. Under one embodiment these optional attributes are used to organize a list of found objects so that objects that contain the optional attributes appear in the list in a priority order based on which optional attributes are matched.

In step of an application calls a method named EnumTokens which is exposed by a category object . Under most embodiments when the application calls the EnumTokens method it passes a list of required attributes and a list of optional attributes to the method. Thus with a single call the application is able to specify both required attributes and optional attributes that it wants in an object.

Implicit in step are the steps of . In particular before calling EnumTokens application instantiates category object at step . The process of instantiating an object is shown by a dotted line in such as insantiation line . The resulting category object exposes interfaces that include at least the EnumTokens method and a SetId method. At step application calls the SetId method to initialize category object so that it points to a category path in the local registry shown as registry in . For example in a speech recognition embodiment category object could be initialized to a voices category by setting it to point to a registry path of 

Once category object has been initialized application calls the EnumTokens method as shown by step of .

At step of EnumTokens searches for objects that match the search criteria it received. The result of this search is a list of pointers to a set of specialized objects that the present inventors call object tokens. Under the present invention an object token is a small object that can be used to access the attributes of another larger object. In general there is one object token for each object of interest. Thus in step there is one object token for each object that has attributes that match the required attributes provided to EnumTokens.

The details of step are shown in the flow diagram of . In step EnumTokens instantiates an EnumTokenObject object as shown by instantiation line of . EnumTokenObject is a standard COM enumerator that maintains a list of entries and exposes methods to organize and retrieve those entries. After EnumTokenObject has been instantiated EnumTokens is returned a pointer to an interface on EnumTokenObject that exposes the methods for organizing and retrieving entries in the list.

At step EnumTokens accesses registry using the category path for Category object . Beneath this category path EnumTokens looks for the registry key Tokens which contains object data for objects that fit within the category associated with Category object . An example of the content of the Tokens registry key is shown in .

In the Tokens key is defined by a category path and the Tokens keyword . The next level below Tokens keyword contains token names such as token names and . For example in a text to speech embodiment token names under the voices category can include MSMary and MSSam which are the names of text to speech voices that can be used when generating a speech signal. Each token name represents a separate object under the category.

Beneath each token name is a collection of object data some of which is placed beneath an Attributes key such as Attributes keys and . Beneath each Attributes key is a list of searchable attributes and attribute values for the object represented by the token name. For example Attributes key contains attribute attribute value pairs and .

At step EnumTokens selects the first token name under the tokens key and at step instantiates an object token for that token name. For example in object token is instantiated. After object token has been instantiated a pointer to an interface on object token is returned to EnumTokens. The pointer is not shown in for simplicity. Using the pointer EnumTokens calls a SetId method exposed by the object token s interface to initialize the object token at step . In particular the SetId method is used to set a pointer in object token so that the object token points to the registry token name. This is shown in by pointer .

Once the object token has been initialized EnumTokens calls an OpenKey method exposed by the object token at step . This method instantiates a data key object not shown for simplicity which supports a method known as GetStringValue for accessing the data under the token name in the registry.

At step EnumTokens calls GetStringValue once for each required attribute. For each call GetStringValue returns the value associated with the attribute name. At step the returned attribute values are compared to the required values and if all of the required attributes match at step a pointer to the object token is added to the master list controlled by EnumTokenObject . If one or more of the returned attributes do not match the required attributes at step the object token is released at step .

After either step or step the next token name under the Tokens key is selected at step and the process of returns to step . The steps of are then repeated for each token name under the Tokens key.

After the last token name s attributes have been searched in the process of the process of continues at step where EnumTokens searches for objects that do not have object data listed under the Tokens key in the registry. To do this EnumTokens utilizes a specialized object that the present inventors call a token enumerator.

Each category may have any number of token enumerators associated with it. The token enumerators for a category are listed under a Token Enums key in the registry path for the category. An example of the contents of a Token Enums key is shown in .

In the registry the names of the token enumerators are listed as individual registry keys directly beneath the Token Enums key. For example in token enumerator names and appear as individual keys beneath Token Enums key . Each token enumerator key has a data entry such as data entry that is denoted by the data name CLSID. The value in this data entry provides a unique Class Identifier for the token enumerator s programming object which can be used to instantiate the token enumerator.

As mentioned above in step EnumTokens uses the token enumerators to search for objects that do not have their attributes listed in a static attribute storage location such as under the Tokens key in the registry or some other relatively static file or memory location. Thus the token enumerator is used to find attributes for object classes that are dynamically made available. Such dynamic object classes include object classes that have an accessibility that is subject to change because the object class is located on a remote machine that may or may not be connected to the local computer or because the object class is loaded into the local computer only when the proper conditions exist for the object class. The process of step is shown in more detail in the flow diagram of .

At step of EnumTokens looks for the first token enumerator name under the Token Enums key. If there is a token enumerator name at step EnumTokens instantiates an object token for the token enumerator at step and initializes the object token to point to the object data for the token enumerator at step . EnumTokens then instantiates the token enumerator through the object token at step . This instantiation is shown in by instantiation line which runs from EnumTokens to a token enumerator .

At step after the token enumerator is instantiated EnumTokens retrieves a pointer to a EnumTokenObject interface which provides access to a list of object tokens created by the token enumerator. The steps performed by the token enumerator to form this list are shown in .

In step of the token enumerator identifies objects that fall within the category and the location of the object data for those objects. Note that each token enumerator may use different techniques to identify the objects that fall within the category. As a result different token enumerators may identify different objects and or different locations for the object data of those objects. For example one token enumerator may look in a remote network database for object data while another token enumerator may look in a file on the local machine for object data. In some embodiments a token enumerator checks to see what hardware devices are connected to a local machine and then selects particular objects from a list of possible objects based on the available hardware. Those skilled in the art will recognize that additional techniques may also be used.

After the objects and the corresponding object data have been identified the process of continues at step where the token enumerator instantiates an Object Token for each set of identified attributes. This instantiation is shown as instantiation line between token enumerator and object token . With each instantiation token enumerator receives a pointer to an interface on the instantiated object token.

At step the token enumerator initializes each object token so that it points to the location of the object token s object data. Note that each object token will point to a different location since each object token is associated with a different set of object data. To initialize each object token token enumerator uses the pointer to the token s interface to call a SetId method exposed by the object token. The results of this initialization is a pointer between the object token and the object data of the object represented by the object token.

At step the token enumerator instantiates EnumTokenObject which is a standard COM enumerator. At step the token enumerator calls methods exposed by EnumTokenObject to create a list of pointers that includes a separate pointer for each of the object tokens instantiated in step . When all of the object tokens have had their pointers added to the list the token enumerator returns a pointer that points to EnumTokenObject at step . This pointer is returned to EnumTokens of Category object thereby marking the end of step of .

After step the searching process of which involves searching for objects that do not have their object data statically listed under the Tokens key continues by repeating steps and . If there are more token enumerators listed at step the next token enumerator is selected and steps and are repeated. If there are no more token enumerators listed the process of ends at step thereby marking the end of step of .

After step the process of searching for objects that have certain attributes continues at step where EnumTokens determines which object tokens identified in step should be added to the list maintained by EnumTokenObject . Under most embodiments the token enumerator does not determine whether objects meet the required search criteria. As a result some of the object tokens in the list returned by the token enumerator do not meet the search criteria.

To determine which of these object tokens to add to the master list maintained by EnumTokenObject EnumTokens uses a process described in the flow diagram of . In step of EnumTokens accesses the first object token pointer in the list provided by EnumTokenObject and calls the OpenKey method exposed by the object token. This method generates a Data Key object not shown for simplicity that supports the GetStringValue method. This method is then used at step to retrieve attributes from the object data pointed to by the accessed objected token. In the GetStringValue call EnumTokens includes the attribute values that it wants returned and GetStringValue returns a pointer to a string containing the requested values.

At step EnumTokens compares the returned attribute values to the required search criteria. If the attribute values for the object match all of the required search criteria at step the pointer to the object token in EnumTokenObject is added to the master list in EnumTokenObject at step .

If the returned attributes do not match the required search criteria at step the process of continues at step where the pointer to the object token is released.

After either step or step EnumTokens continues at step where it selects the next object token pointer in EnumTokenObject . EnumTokens then repeats steps and for the new object token pointer.

Note that each token enumerator instantiates a separate instance of an EnumTokenObject and that each instance contains a separate list of object token pointers. Thus the process of must be repeated for each EnumTokenObject that was returned to EnumTokens.

Once the process of has been performed for each of the EnumTokenObject lists the master list contains pointers for all of the object tokens that meet the required search criteria.

Once the master list has been populated the object tokens in the list are ordered at step based on the optional attributes listed for the objects.

To order the list the optional attributes are first assigned a bit location in a bit string generated for each object token. The lowest bit position in the bit string is a flag that indicates whether the current object token is associated with a default object for the category. The bit positions above the lowest bit are assigned to the optional attributes based on the order of the attributes in the search request. The second to lowest bit position is associated with the last optional attribute specified in the search request the next bit position is associated with the next to last optional attribute and so forth ending with the highest bit position being associated with the first optional attribute in the search request.

For each object token the GetStringValue method is used to retrieve the value of each optional attribute. If the retrieved value matches the optional attribute value the corresponding bit in the bit string is set to 1 . If the values do not match the bit is set to 0 . When all of the object tokens have had their bit strings set the list is ordered based on the values of the bit strings. Thus an object token that has all of the optional parameters will be first in the list.

Note that because the default object is the lowest bit the default object will always appear in the list before objects that have similar optional attributes. Thus if two objects have the second and third optional attributes and one of the objects is the default object the default object will appear before the other object in the list.

Note that the ordering described above is only one example of the way in which the pointers may be ordered based on the optional attributes. Other ordering techniques may be used. For instance the pointers may be organized based on how many optional attributes each object matches without regard to the particular optional attributes that are matched. Thus an object that matches two optional attributes would always appear before an object that only matched one optional attribute.

By organizing the list of object token pointers based on the optional attributes the present invention provides an easy means for applications to find objects that contain optional attributes.

After the list has been ordered based on the optional attributes a pointer to EnumTokenObject is returned to Application .

In the description above EnumManagedTokens did not compare the attributes of the object tokens to the search criteria before adding the object tokens to EnumTokenObject . In other embodiments the token enumerator uses the GetStringValue method exposed by each object token to retrieve the object s attributes so that they can be compared with the required search attributes. Under this embodiment only those objects that match the required search attributes are added to the list contained in EnumTokenObject .

Note that during the search process the objects associated with the object tokens were never instantiated. Thus the present invention is able to indicate whether an object meets a set of search criteria without instantiating the object itself. Also note that the present invention is able to locate attributes of objects that are not found statically in the local registry. Thus under the present invention an object class may be made available dynamically or the attributes of an object may be stored on a remote server and may be accessed by a local token enumerator without instantiating the object and without requiring that the attributes of the object be added to the local registry.

Under one embodiment the attributes of objects can be placed in a Markup Language document on an Internet server. The token enumerator then initializes the object token with the Internet address of the document. When EnumTokens asks the object token for an attribute value the object token requests the document by sending an appropriate Internet request. It then parses the document into a string and provides a pointer to the string to EnumTokens.

Under some embodiments of the present invention object tokens can also be used to initialize an object to a particular set of attributes during instantiation of the object. A method for performing such initialization under one embodiment of the present invention is shown in the flow diagram of which is described below with reference to the block diagram of .

In step of an application instantiates an object token using a call to the standard COM method CoCreateInstance. At step application initializes object token by calling the SetId method in object token so that object token has a pointer to a set of object data . The object data includes the Class Identifier of the object to be instantiated as well as initialization values that the object will use to initialize itself.

At step application calls a CreateInstance method exposed by object token . This method retrieves the Class Identifier of the object to be instantiated from attributes . It then calls CoCreateInstance to instantiate an object at step .

Once object is instantiated CreateInstance calls the QueryInterface method exposed by object at step . It then uses the results of this method to see if object supports the IObjectWithToken interface at step .

If object supports the interface CreateInstance calls the SetObjectToken method in the IObjectWithToken interface at step . As part of the call to SetObjectToken CreateInstance passes a pointer to the object token s interface. Using this pointer SetObjectToken initializes the object in step by requesting attributes for the object using the GetStringValue method exposed indirectly by object token . For example the attributes can include a file location for a data file from which the object can be initialized. After it has retrieved the initialization information using the GetStringValue method object initializes itself using the information.

After step or if the object does not support the IObjectWithToken interface at step the process of ends at step by returning a pointer that points to the object.

Note that using the method of embodiments of the present invention allow different object data to be associated with the same object class. Thus two different sets of object data could contain the same Class Identifier for the same object class. Thus developers can assign different attributes to the same object while only registering the object class once. This is a substantial improvement over the prior art in which developers had to register different versions of the object class if they wanted to associate different sets of object data to the object class.

Although the present invention has been described with reference to particular embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention.

