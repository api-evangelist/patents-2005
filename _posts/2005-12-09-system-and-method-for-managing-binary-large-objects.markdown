---

title: System and method for managing binary large objects
abstract: The invention regards a system () and method for managing BLOBs. The system combines a file subsystem () and a database subsystem (), wherein the database subsystem () comprises relations between file names of files () comprising a BLOB () and BLOB names. In the event of modification of a file () containing a BLOB (), a new file, having a new file name, is created, where a relation between the new file name and the BLOB name is created within a database transaction in the database subsystem (). By thus extending the ACID-properties of database transactions to files, it is ensured that operations on BLOBs in the system () meet the ACID-requirements while keeping the efficiency of operations on files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07890481&OS=07890481&RS=07890481
owner: Nuance Communications Austria GmbH
number: 07890481
owner_city: Vienna
owner_country: AT
publication_date: 20051209
---
This invention relates to a system for managing Binary Large Objects BLOBs comprising a file subsystem arranged to create store modify and or delete files wherein said system is arranged for including a specified BLOB associated with a BLOB name in a specified file in said file subsystem. The invention moreover relates to methods of creating modifying and deleting respectively a specified file including a specified Binary Large Objects BLOBs in a system which system comprises a file subsystem arranged to create store modify and or delete files said specified BLOB having a BLOB name.

There are applications that need to process large amounts of data i.e. several hundreds of MBs stored in the form of binary large objects BLOBs . Typically the data relates to medical images sound movies and multi media files. When one or more such BLOBs are to be modified the well known ACID atomicity consistency isolation durability requirements must be fulfilled 

It should be possible to fulfil this requirement based on common off the shelf COTS software i.e. standard file system and database software using well known application programming interfaces such as Posix file system functions and SQL statements for database operations.

Moreover an additional requirement is that the identity of a file in a file system must be preserved i.e. it must not be lost. For example if a backup of a file is made the file is modified and then the backup should be restored. In this case it must be possible from just looking at the file names in the backup and in the file system which file on backup is related to the modified file.

In standard file systems such as DOS FAT NTFS Linux ext2 etc. simple operations such as create a file update the contents of a file rename a file delete a file are possible. These are not sufficient to fulfil the ACID requirements. Journaling file systems such as e.g. NTFS in certain configurations or Linux ReiserFS fulfil the ACID requirements for single files but not for sets of files. Moreover even though file systems typically are capable of storing BLOBs transactions on BLOBs are typically not supported. It has been suggested to simply store BLOBs in a file system and do without transactions on the BLOBs.

Standard database systems such as MS SQLserver or Oracle typically provide functionality for fulfilling the ACID requirements but they are not optimized for operating on sets of large files. It is well known that performance in standard database systems becomes a problem with large data sized. Most standard databases provide some support for transactions involving BLOBs that can have sizes of up to tens or hundreds of MB but they are not optimized for transactions involving hundreds of MB. This usually makes the standard databases unusable for managing BLOBs.

It is therefore an object of the invention to provide a system for managing binary large objects BLOBs which system should comply with the above mentioned ACID requirements and the requirement of preservation of a file identity.

This object is achieved when the system of the introductory paragraph is characterized in that said system moreover comprises a database subsystem and that said system is arranged to generate a file name to be associated with said specified file wherein said database subsystem is arranged to create a relation between of said file name and said BLOB name.

Hereby the functionalities of a file subsystem and a database subsystem are combined so that the functionalities of the file subsystem can be used for e.g. creating storing modifying and or deleting files whereas the functionalities of the database subsystem can be used for keeping track of which file in the file subsystem is related to a specified BLOB. Thus the system according to the invention alleviates the problems stated above by proposing a way of applying database transactions to files.

Within the system any BLOB name and file name should be unique and the relation between a file name and the BLOB name of the associated BLOB should be bijective so that any unique file name is associated with one unique BLOB name and any unique BLOB name is associated with one unique file name. It should be noted that the expressions a file name is associated with a BLOB name and a file name is combined with a BLOB name are synonymous with the expression a file name is related to a BLOB name and a relation exist between a file name and a BLOB name .

In the above it should be understood that said relation and or any relevant information regarding file name and or BLOB name are to be accessible by relevant components in the system.

Preferably the database subsystem is arranged to store modify rename and or delete said relation between said file name and said BLOB name. Hereby the relations in the database subsystem can be changed according to changes to BLOBs included in files in the file subsystem.

In a preferred embodiment of the system said relation is comprised in a table in said database subsystem which table is arranged to comprise relations between said BLOB name and said file name for each file including a BLOB. Hereby an easily realizable way of keeping track of the relations between BLOB names and file names is achieved.

Preferably the system further comprises a controller arranged to control processing of the system. The controller could be integrated in the file subsystem the database subsystem or it could be a separate component. The controller could be any data processing component arranged for controlling initiation of operations performed in the file subsystem and the database subsystem. Moreover the controller should be arranged to control communication or information exchange between the controller and the file subsystem and or the database subsystem or communication or information exchange between the file subsystem and the database subsystem.

Preferably said file name comprises a globally unique identifier GUID and a version index. Thus if the version index is dynamic i.e. changed and the GUID is static i.e. not changed upon modifications of a BLOB such a file name will provide a way of preserving the identity of the file comprising the BLOB whilst keeping track of any modifications of the file. Hereby the identity and the history of each file is visible in the system by means of the file subsystem and in backups even though new file names are created each time a BLOB is modified updated. This feature alleviates the disadvantages from creating completely new file names i.e. new file names with nothing in common with the old file names for each modification of a BLOB and retains most of the advantages of a file name preserving solution.

In yet a preferred embodiment said system is arranged to upon modification of a specified BLOB create a new file including the modified specified BLOB and having a new file name and to associate the BLOB name with the new file name in the database subsystem. The combination of creating a new file and associating the BLOB name with the new file name in the database subsystem guarantees that changes to a BLOB can be undone which is called rolled back in database terminology until they are committed and that the BLOB stays consistent in case of a failure of the system during updating the BLOB in that either the old file i.e. the unmodified file is in the file subsystem and the BLOB is associated with the old file or the new file i.e. the modified file is in the file subsystem and the BLOB is associated with the new file. Thus this system is superior to file systems in which file names are preserved during modifications.

Preferably the said new file name comprises said globally unique identifier GUID and an updated version index. Again a new file name thus created will provide a way of preserving the identity of the file comprising the BLOB whilst keeping track of any modifications of the file in that the version index is updated.

The invention moreover relates to methods as mentioned in the opening paragraph comprising features corresponding to the features of the system and thus having corresponding advantages. However in a preferred embodiment of the method of creating a specified file a step of generating a file name comprises the steps of generating a GUID and a version index for the BLOB and combining said GUID and said version index to a file name for a specified file comprising said BLOB. Hereby an easy way of generating file names is achieved. Typically the GUID constitutes an unchanging part of the file name and the version index constitutes a part which can be changed every time the specified is updated modified changed.

In yet a preferred embodiment of the method of creating a specified file according to the invention it further comprises the steps of starting a database transaction in said database subsystem wherein said database transaction comprises the step of combining said file name and said BLOB name checking if the steps of generating a file name of combining said file name and said BLOB name and of writing the BLOB to said specified file were successful and only if the previous steps were successful committing the database transaction. The above steps form together with the generation of a file name described in the preceding paragraph a system transaction consisting of the steps of generating a file name combining said file name and said BLOB name and writing the BLOB to the file in the file subsystem. By starting a database transaction and only committing it in case of success it is ensured that the ACID requirements are met.

The method of modifying a specified BLOB comprises the steps of starting a database transaction in a database subsystem that is part of the system retrieving the file name for a specified file comprising said specified BLOB creating a new file name combining the new file name and the BLOB name modifying the specified BLOB and writing the modified specified BLOB to a new file in the file subsystem where said new file is associated with said new file name checking if all previous steps were successful and if the check shows that the previous steps were successful committing said database transaction. Hereby it is assured that the ACID requirements are met during update modification of a BLOB in the system.

The method of deleting a specified BLOB having a BLOB name with a relation to a file name in said database subsystem where a relation exists between said BLOB name and a file name in a database subsystem comprises the steps of starting a database transaction in said database subsystem in said database subsystem deleting the relation between said BLOB name and said file name committing the database transaction if the previous steps were successful and in said file subsystem deleting said existing file including said specified BLOB if the previous steps were successful. In the above case a system transaction consists of the steps of deleting the relation between the BLOB name and the file name in the database subsystem and deleting the existing file in the file subsystem only if deleting said relation was successful. Again by starting and committing a database transaction and only deleting the file in case of success of the database transaction steps it is ensured that the ACID requirements are met.

It should be noted that throughout this specification the term BLOB Binary Large Object is meant to cover any data object that due to its size cannot be handled efficiently by the database system. The size of a BLOB could be any size in the range between a few hundred kB and thousands of MB of data. The size of a BLOB typically lies in the range between some tens and some hundreds of MB of data however the size of a BLOB is not limited to this range.

The term database transaction is meant to cover a sequence of information exchange and related work such as database updating that is treated as a unit in the database subsystem for ensuring data integrity within the system. For a database transaction to be completed and data changes to be made permanent the database transaction has to be completed in its entirety. In the database subsystem and in case of a database transaction being completed successfully the database changes are said to be committed when a database transaction does not complete the changes are rolled back. Moreover the term system transaction is meant to cover a transaction performed in the system and typically but not necessarily by use of both the database subsystem and the file subsystem. Each of the methods shown in is an example of such a system transaction consisting of all the method steps between the steps start and end .

Moreover it should be noted that the term manage a file is meant to cover any standard transaction or operation performed on files e.g. creating a new file deleting an existing file updating modifying an existing file and or renaming an existing file. Finally it should be noted that the term file is meant to cover a file in the file subsystem comprising all data for a certain BLOB being equivalent to the BLOB being included in the file .

The file subsystem and the database subsystem respectively could be any appropriate standard file system and database system respectively arranged for exchange of information regarding file names and BLOB names.

It should be understood that within the file subsystem and the database subsystem respectively all file names and BLOB names respectively should be unique.

The controller is a data processing component in the system controlling initiation of operations performed in the file subsystem and the database subsystem . Moreover the controller is arranged to control communication or information exchange between the controller and the file subsystem and or the database subsystem which is shown by the slanting arrows .

The horizontal arrows between the file subsystem and the database subsystem indicate possible communications or information exchanges. Thus the horizontal arrow pointing from the file subsystem towards the database subsystem indicates that the name of any file comprising a BLOB is transferred from the file subsystem to the database subsystem whilst the horizontal arrow pointing from the database subsystem towards the file subsystem indicates that a file name and an associated BLOB name is transferred from the database subsystem to the file subsystem . These information exchanges could be initiated by means of the controller .

The file name of each file could be a combination of a GUID and a version index. A GUID is an identifier that is unique within a certain context. Here the context encompasses all BLOBs managed by the system and method of the invention. In one embodiment of the system and method a GUID counter stored in the database could be used where the GUID counter is incremented each time a new GUID is required. The new value of the counter is used as the GUID. However algorithms for creating GUIDS are well known and do not form part of the present invention. In one embodiment of the system and method of the invention a counter stored in the database and which is incremented each time a new version index is required is used for providing a version index. The new incremented value of the counter is used as the new version index. Alternatively it is conceivable that a hash value using any appropriate well known algorithm for computing hash values such as e.g. MD5 computed from the new BLOB data is used as the new version index.

An example of a file name constituted by a GUID and a version index could be 123456 where the number to the left of the   i.e. 123 is the GUID and the number to the right of the   i.e. 456 is the version index. It should be noted that the combination of a GUID and a version index must be bijective i.e. the following requirements must be met 

The flow is started in the controller in step and continues to step which is performed in the database subsystem see and wherein a new database transaction is started. This database transaction is a combination of a file name generated in the steps and a BLOB name. After step the flow continues to step wherein a new GUID is generated. In the subsequent step step a version index is generated and in the subsequent step step the GUID and the version index are combined to a file name. As mentioned above an example of a file name constituted by a GUID and a version index could be 123456 where the number to the left of the   i.e. 123 is the GUID and the number to the right of the   i.e. 456 is the version index. Moreover the combination of a GUID and a version index must be bijective as mentioned above. Even though the steps to in are shown in the column under the controller CTRL which means that these steps are performed by the controller it is also conceivable that these steps could be performed by the database subsystem .

Subsequently the flow continues to step which is performed in the database subsystem see and wherein the BLOB name of the BLOB is associated combined with the file name created in step . In the following step step performed in the file subsystem see the data in the BLOB is written to a new file associated with the file name created in the steps to .

The method includes a subsequent step step of checking if all the previous steps were successful. If the check in step has the result that all the previous steps were successful the database transaction that was started in step is committed in step . Thereby the system transaction being the generation of a file name the combination of this file name and a BLOB name and the writing of BLOB data to a file having the file name in the file subsystem is committed.

If the check in step indicates that an error has occurred during any of the steps to the database transaction can be rolled back and any file created as part of the system transaction can be deleted. Note that even if an error occurs during the above deletion of the file the file subsystem stays consistent with the database subsystem some unneeded files might be left but the files in the system still fulfil the ACID properties and the unneeded files do not influence the correct operation of the system. Moreover they can be deleted at any time. The flow ends in step .

In the subsequent step step the file name is retrieved from the BLOB name e.g. by looking up a table comprising relations between file names and BLOB names in the database subsystem . The flow continues in step which is performed in the controller see . In step the GUID is retrieved from the file name associated with the BLOB name. Thereafter in step a new version index is generated and in the following step the GUID extracted from the file name is combined with the new version index generated in step to a new file name. In the example above regarding the file name 123456 where the number to the left of the   i.e. 123 was the GUID and the number to the right of the   i.e. 456 was the version index the new file name might be 123457 where 457 is the new version index.

In the subsequent step performed in the database subsystem see the BLOB name is associated with related to the new file name created in step .

Hereafter in step in the file subsystem see the modified updated BLOB is written to the file associated with the new file name.

Thereafter the flow continues to step wherein it is checked if all the previous steps were successful. If the check in step has the result that all the steps to were successful the flow continues to step wherein the database transaction is committed in the database subsystem . Thereby the system transaction is committed which as noted above comprises the generation of a new file name the combination of the new file name and the BLOB name and the writing of a modified BLOB to a new file with the new file name in the file subsystem.

However if the check in step indicates that an error has occurred during any of the steps to the database transaction can be rolled back and any file created in the file subsystem as part of the system transaction can be deleted.

If the system transaction was committed the method could comprise the step not shown of deleting the file including the unmodified BLOB i.e. the file previously associated with the file name having an old version index. However the method might also include preserving this file including the unmodified BLOB in the case where it is required to maintain older versions of a file BLOB.

Note that even if an error occurs during the above deletion of files in case of rollback of the database transaction the file subsystem stays consistent with the database subsystem some unneeded files might be left but the files in the system still fulfil the ACID properties and the unneeded files do not influence the correct operation of the system. Moreover they can be deleted at any time.

Due to the structure of the database subsystem the new file name will not appear in the database subsystem until the database transaction has been committed due to the read committed isolation level for the database transaction . Hereby this read committed isolation level of the database subsystem is propagated to the files in the file subsystem.

In the subsequent step step the pair consisting of the file name and the BLOB name is deleted in the database subsystem see .

In the subsequent step step a check is performed to verify if the steps and were successful. In the affirmative case of the check in step the flow continues to step wherein the database transaction started in step is committed.

This is followed by a cleanup step wherein the file that includes the BLOB and that had the file name related to associated with the BLOB name is deleted in the file subsystem see . Thereby the system transaction is committed.

However if the check in step shows that an error has occurred during the above database transaction it can be rolled back and the steps and are skipped so that both the relation between the BLOB and the file name in the database and the actual file remain unchanged and the consistency of the data is guaranteed. The flow ends in step .

In the case of the method in the system transaction comprises the deletion in the database subsystem of a BLOB name and its related file name and in the file subsystem deletion of an existing file arranged to include a BLOB.

It should be noted that the methods for modifying updating and deleting respectively an existing file typically are preceded by the method for creating a new file including a BLOB .

Moreover it should be noted that the methods described above could comprise further method steps in addition to those described. For example these methods could be extended to cover the manipulation of multiple BLOBs within a single system transaction by simply repeating steps to the steps to and or the step one or more times preceded with a single step of starting a database transaction succeeded by a check whether all previous steps were successful and a subsequent commit of the database transaction in the affirmative case.

The system and method described above uses a mechanism where BLOBs are identified by unique names that in turn are associated with changing file names. This is a specialization of a well known technique called indirection . The advantages of the system and method according to the invention are achieved by the combination of the capabilities of a database subsystem and a file subsystem. Hereby the performance problems encountered by storing BLOBs in a standard database and by modifying BLOBs stored in a file system are solved.

