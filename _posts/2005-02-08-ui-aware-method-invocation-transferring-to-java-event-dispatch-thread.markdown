---

title: UI aware method invocation transferring to java event dispatch thread
abstract: Methods and apparatuses are disclosed for transferring a method call from an invoke thread to an event dispatch thread. The invoke thread and the event dispatch thread may execute independent of one another and the event dispatch thread may have an associated queue. The method may include defining a new call on the invoke thread. The new call may include identification of a method, identification of an object, one or more arguments, and a coalescing indicator indicating a type of coalescing for the call. The method may further include sending, during execution of the invoke thread, the new call to the queue, one or more previous calls being stored in the queue, and coalescing the new call with one of the previous calls in the queue according to the type of coalescing indicated by the coalescing indicator.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07464382&OS=07464382&RS=07464382
owner: Sun Microsystems, Inc.
number: 07464382
owner_city: Santa Clara
owner_country: US
publication_date: 20050208
---
This application claims benefit of priority from U.S. Provisional Patent Application No. 60 582 871 filed Jun. 25 2004 for SWINGWORKER FRAMEWORK FOR LENGTHY JAVA SWING JFC INTERACTING TASKS which is hereby incorporated by reference.

This application relates to commonly assigned copending U.S. patent application Ser. No. 11 054 586 filed concurrently herewith for FRAMEWORK FOR LENGTHY JAVA SWING INTERACTING TASKS which is hereby incorporated by reference.

The present invention relates to the sending of method invocations to a Java event dispatch thread from outside the event dispatch thread.

The Java 2 Platform Standard Edition J2SE and the Java Development Kit JDK provide developers with access to a wide range of user interface UI and graphical user interface GUI components. The JDK provides flexibility and control over the appearance of UIs and GUIs.

Conventional graphics toolkits such as the Abstract Windowing Toolkit AWT provide application programming interfaces APIs for applications. The Java Foundation Classes JFC also commonly referred to as Swing or the Swing toolkit are a set of Java class libraries having components that build upon the AWT by providing additional UI and GUI components and services. The Swing toolkit incorporates the AWT and is included in the JDK and J2SE to provide a rich extensible GUI component library. The Swing toolkit is implemented in the Java programming language and enables building of applications with GUIs and graphics functionality that can run on any platform supporting the J2SE such as Microsoft Windows Linux and Mac OS X.

The Swing toolkit includes categories of components atomic controls complex data components text components menu components layout containers and top level window components. Examples of Swing components include buttons panels listboxes and checkboxes. In addition to the new components the Swing toolkit offers a customizable look and feel that allows the components to take on the appearance of various windowing systems or their own unique look and feel. For instance Swing allows applications to easily convert from a Java look and feel to a Windows look and feel. Developers have the ability to create their own look and feel for custom applications. Regardless of the desired look and feel a consistent API can be maintained for the component. Thus developers can code their application GUI once and run it in multiple look and feels.

Swing is not designed for multi threading. Access to a Swing component or class has to occur from a single thread specifically an event dispatch thread EDT . Thus once a Swing component has been realized e.g. when the component s paint method has been called all code that might affect or depend on the state of that component should be executed on the EDT. The EDT is responsible for processing all UI and GUI related events such as user interactions e.g. mouse clicks key presses notification of listeners of user input and all painting and graphics including repainting dirty regions or updated areas. Essentially every instruction to change something or request something from the Swing component is executed as an event on the EDT.

The EDT handles many different events as described above. At the EDT all of the events or tasks are queued and processed sequentially. Problems can occur when too many events are queued. If one event takes a long time to process on the EDT such as loading an HTML page all of the other events in the queue will have to wait to be processed. This waiting or delay is undesirable. It is generally perceived as the entire UI and application itself being unresponsive often referred to as freezing or blocking. 

Conventional techniques for attempting to reduce freezing or blocking include two Swing utilities. These Swing utilities are java.awt.EventQueue.invokeLater used for asynchronous method calls and java.awt.EventQueue.invokeandWait for synchronous calls. However the methods java.awt.EventQueue.invokeLater and java.awt.EventQueue.invokeandWait create runnable classes for every call to those methods. Each runnable class is executed as a separate event on the EDT. Creating new runnable classes for every call is computationally expensive and often results in the same freezing or blocking problem described above when many runnable classes are passed to the EDT.

Efficient techniques are needed for accessing Swing components from outside of the EDT including calling methods requiring execution of events on the EDT from outside of the EDT.

Aspects of the present invention include methods and apparatus including computer program products implementing and using techniques for accessing Swing components from outside an event dispatch thread EDT . Aspects of the present invention provide for efficient execution of events on the EDT responsive to method calls from outside of the EDT.

According to some aspects of the present invention methods and apparatus provide for efficient transfer of method calls from one thread such as an invoke thread to the EDT. The invoke thread and the EDT execute independently of one another. The disclosed techniques for transferring executing code avoid the unnecessary queuing of events on the EDT. Method calls are coalesced for execution on the EDT preventing the EDT from being overwhelmed.

According to one aspect of the present invention a new call is defined on the invoke thread. The new call includes identification of a method identification of an object one or more arguments and a coalescing indicator indicating a type of coalescing for the call. During execution of the invoke thread the new call is sent to a queue where one or more previous calls are stored. The new call is coalesced with one or more of the previous calls in the queue according to the type of coalescing indicated by the coalescing indicator. Calls are retrieved from the queue and executed in sequence as events on the EDT.

The foregoing along with other methods of aspects of the present invention may be implemented in software firmware hardware and combinations thereof. For example methods of aspects of the present invention may be implemented by computer programs embodied in machine readable media and other products. These and other features and benefits of aspects of the invention will be described in more detail below with reference to the associated drawings.

Reference will now be made in detail to some specific embodiments of the invention including the best modes contemplated by the inventors for carrying out the invention. Examples of these specific embodiments are illustrated in the accompanying drawings. While the invention is described in conjunction with these specific embodiments it will be understood that it is not intended to limit the invention to the described embodiments. On the contrary it is intended to cover alternatives modifications and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims. Moreover numerous specific details are set forth below in order to provide a thorough understanding of the present invention. The present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to obscure the present invention.

Embodiments of the present invention provide methods and apparatus including computer program products implementing efficient techniques for accessing Swing components from outside an event dispatch thread EDT . Embodiments of the methods and apparatus described herein provide efficient execution of events on the EDT responsive to method calls from outside of the EDT and in some embodiments interaction with the EDT to execute lengthy tasks.

Methods performed in accordance with embodiments of the invention provide efficient transfer of methods from one thread to another thread. Such transfer of executing code avoids the unnecessary queuing of events on the EDT thus minimizing and often eliminating the freezing or blocking phenomenon. In some embodiments the present invention provides coalescing of method calls for execution on the EDT preventing the EDT from being overwhelmed.

Embodiments of methods and apparatus of the present invention provide the capability of coalescing method calls on the EDT. Coalescing refers to merging two or more calls into one to be executed on the EDT. An example of coalescing is provided by the Consume method described below in which arguments are combined when the same method is called for the same object. Other types of coalescing are described below. Calls coalescing for the Consume method and the setProgress method described below improve application performance and the UI response time.

In in one embodiment the queue includes memory cells N. Before method calls are executed on the EDT they are stored in the cells N. Preferably the queue is provided in a FIFO arrangement. Cell represents the top of the queue from which calls are retrieved and executed one by one as events on the EDT . Generally the oldest call is situated at the top of queue in cell . A new call or most recent call is sent to the bottom of queue in one example cell N.

Embodiments of methods and apparatus of the present invention provide for the efficient transfer of method calls to the EDT. In one embodiment as shown in the class diagram of the methods and apparatus are implemented as an API with two classes 

 2 public class EDTExecutorService which implements the executor service interface from the java.util.concurrent package namely java.util.concurrent.ExecutorService .

In Call represents a method call to be executed on the EDT. When the method is to be called the Call object is created. The Call object encapsulates data describing the call. As shown in the Call object encapsulates several methods the operations of which are described below with respect to . These methods include coalesce Call callOnEDT callOnEDTSync and call . call is used anytime it is desired to call a method. When it is desired to coalesce two calls the coalesce Call method is used. Often subsequent processing varies according to the desired implementation.

where callee is the object to execute the method for method is the method to call callProperty is a coalescing indicator describing whether and how the call could be coalesced that is combined with another call and args are parameters also referred to herein as arguments for the method invocation. Thus the class Call has a pointer to the object to call a pointer to the method to invoke and parameters to pass.

Embodiments of the present invention provide for a plurality of calls to be coalesced when the calls have the same callee and method. Embodiments of the present invention provide for the calls to be coalesced in several ways. In one embodiment callProperty governs how the coalescing occurs. In this embodiment callProperty has one of three values plain onlyLast or coalescing. The value plain indicates that the Call cannot be coalesced onlyLast indicates that the Call is to replace a previous call e.g. for a progress bar or other progress notification for a component and coalescing indicates that the arguments for the Call are to be appended to the arguments for a previous call. Thus the method can be invoked with a single call providing the combined set of arguments. The calls can only be coalesced when the calls are for the same callee and for the same method.

In Call is extendible. The implementation above using callee method and callProperty is only one of many implementations. This implementation can be changed in many ways as desired. For example if a particular method call for a certain object is undesirable the call method can be overridden as can the coalesce Call method. Extending the Call class enables other operations to be carried out rather than calling the predefined method for the predefined object. In one embodiment callProperty is used while other embodiments provide coalescing using different techniques. Also the Call constructor can be customized as desired for a different implementation to execute code on the EDT. All such alterations and customizations are intended to fall within the spirit and scope of the present invention.

In the method coalesce is responsible for merging two calls into one using techniques described herein. When calls are coalesced the coalesce method returns a value of true. Using the coalesce method additional types of coalescing can be performed than the particular coalescing operations described herein within the spirit and scope of the present invention. The coalesce method can be implemented in many ways and can be customized as desired for the particular implementation.

In the EDTExecutorService is a class which submits a call for execution on the EDT. In addition EDTExecutorService can be used to submit runnables to the EDT. In one example in which a call is submitted the method is as follows 

The EDTExecutorService class resolves coalescing and ensures that the EDT is not overwhelmed with incoming calls. In one embodiment time slices are used to implement the EDTExecutorService.

In when coalescing is performed on method calls in queue method calls in two or more of cells N are combined. shows an example of one coalesce method performed in accordance with embodiments of the present invention.

In the method begins with calling the coalesce Call method invocation with another call as the argument in step . The supplied method call can be stored as a new call in one of the cells N. The coalesce method identifies one or more previous calls already stored in queue . When the methods identified by the new call and the previous call s are the same in step and the objects i.e. callees identified by the object identifiers in the new call and the previous call s are the same in step the arguments in the new call and previous call s are combined in step . In steps and when either the methods or the identified objects are not the same the coalesce method returns a value of False . In step in this embodiment the arguments are combined according to the callProperty value as described above. Finally in step the coalesce method returns a value of True as mentioned above.

In in step when the callProperty value is plain the new call is simply added to the bottom of queue . When the callProperty value is onlyLast the new call replaces a previous call. Or when the callProperty value is coalescing the arguments for the new call are appended to the arguments for the previous call so the coalesced call has the object identifier method identifier and combined arguments.

In part A shows how calls are delivered to the EDT . In part A the method begins with a user identifying a method and an object to call on the EDT . In step the callOnEDT method constructs the Call object for this method and object. As mentioned above the constructor for Call indicates that the identified method is be called for the identified object i.e. callee indicates how the call can be coalesced e.g. plain onlyLast or coalescing and passes particular arguments for the method. In step the newly defined call is submitted to the EDTExecutorService using the submit self method. The method continues in step when the EDTExecutorService accesses the queue also referred to herein as EDTExecutorService.callsQueue and attempts to coalesce the new call with any previous calls already in the queue using callProperty values as described above. For example when the callProperty value is onlyLast and a previous call is identified having the same method and same object coalescing involves replacing the previous call with the new call. When the new call is coalesced with any previous calls processing is complete for part A. When the new call cannot be coalesced in step the new call is added to the end of queue .

In Part B of method provides for the invoking of calls on the EDT and is initiated on EDT . Part B of method happens asynchronously with respect to part A of method . A special task is defined to run periodically each time executing calls from the queue . The frequency with which special task runs is preferably often enough so that users do not have to wait for the execution of calls. In this way freezing is avoided. In one example 20 times per second is often sufficient although other frequencies may be used depending on the desired implementation. In step every time the special task runs the EDT runs an execute method and a timer is tolled. Responsive to the execute method in step the EDTExecutorService accesses the queue and gets i.e. retrieves calls one by one from the queue for execution on the EDT . In step retrieved calls are executed in sequence by EDTExecutorService until the timer reaches a predetermined threshold e.g. 0.045 seconds. When the threshold is exceeded the execution of calls is postponed until the special task runs again. Subsequent execution by EDTExecutorService begins with the first call from the queue .

In in part B step involves calling method call on class Call . That is the identified method is called for the identified object passed in the constructor and passes the arguments as described above. Lastly in Part B of method a notifyWaitforResult message is executed in which a notification message is sent to any listeners indicating whether the new call was executed in step .

In part C demonstrates the calling of methods synchronously when it is desirable to wait for a result after calling a method. In part C the method begins in step with running the method callOnEDTSync that is to call the method synchronously. Responsive to callOnEDTSync in step the method callOnEDT is run as described above in part A. Then in step the waitForResult method waits for a result that is listens for the notification from step of part B. Any result is provided when the call is executed on the EDT in part B. In step the method proceeds with determining whether any exceptions were thrown when the method was called. When there are exceptions they are thrown. When no exceptions were thrown the result is returned to the user.

Many times a UI including frames buttons and other graphical representations is created on the main thread of an application. When these elements are visible the properties of these elements cannot be changed from other threads than the EDT. Thus when it is desirable to call a method which is not thread safe including the majority of Swing methods from any other thread than the EDT the methods and apparatus described above with respect to can be used.

Embodiments of methods and apparatus of the present invention are used for implementing a new SwingWorker which has several improvements over the original version. These improvements include delivering intermediate results by a Schedule and Consume method described below and sharing the state of a process using setProgress and firePropertyChange methods and a propertyChangeListener method also described below. In one implementation these new methods are incorporated as additions to the SwingWorker abstract class described above from which a subclass can be defined by a developer to perform GUI related work in a dedicated thread.

In background process and EDT execute independent of one another. That is background process executes regardless of what is happening on the EDT and is not dependent on any input or other interaction from EDT . Similarly EDT executes regardless of what is happening on the background process and only receives indirect input from the background process through queue . At some point during execution of the background process a Send data operation is called. In one embodiment the Send data operation is carried out by part A of method for transferring calls described above with respect to . Examples of Send data operation include the Schedule method setProgress method and firePropertyChange method described below. The Send data operation causes method calls to be sent to queue for later retrieval and execution on the EDT . Because background process and EDT execute independent of one another the method calls may be stored in queue for some time until they are retrieved. Those skilled in the art will appreciate that Send data operation may be called multiple times during execution of background process .

In independent of the storing of output method calls in queue at some point during processing on the EDT a Handle data operation is performed on the EDT. In one embodiment the Handle data operation is carried out by part B of method described above with respect to . The performing of Handle data operation is controlled by the EDT . The Handle data operation retrieves method calls stored in queue . The method calls can then be executed on the EDT . In instances when the Send data operation includes calling the Schedule method the Handle data operation includes calling the Consume method for outputting the method calls on the EDT . Those skilled in the art will appreciate that Handle data operation may be called multiple times during execution of EDT .

In the retrieving of method calls from queue and outputting of method calls on the EDT when Handle data operation is called happens asynchronously with respect to the sending of method calls to queue during Send data operation . That is there is no relationship between the Send data operation and the Handle data operation . The Send data operation is performed according to the schedule determined by background process regardless of when Handle data operation might be performed by EDT or anything else happening on the EDT and is not dependent on any input or other interaction from EDT . Similarly the Handle data operation is performed as determined by EDT regardless of when Send data operation might be performed by background process or anything else happening on the background process .

In in one embodiment the Send data operation can include any of several methods including a Schedule method a setProgress method and a firePropertyChange method. When the Send data operation includes the Schedule method the Handle data operation generally includes a Consume method. The Schedule method is called on the background process or some thread other than the EDT and Consume is called on the EDT . The Schedule method and Consume method cooperate to prevent the EDT from being overwhelmed by the queuing of method calls for execution thus making the desired application more responsive. In one embodiment as described above with respect to the coalescing of events provides for performing the Handle data operation periodically to retrieve method calls for output on the EDT e.g. every 50 milliseconds .

In the Schedule method is called as needed on the background process . The background process can be tailored to invoke Schedule as desired to push partial results to the queue for publication on EDT . In one embodiment the Schedule method calls the Consume method using the above constructor. In when Send data operation includes calling the Schedule method the Schedule method call is sent to queue and generally stored in one address also referred to herein as a cell described above with respect to .

In when the Handle data operation is performed one or more cells N starting from the top cell of queue are accessed and the method calls stored therein are retrieved. In one example when the Handle data operation is the Consume method the following command is made by the Handle data operation 

In another example when Consume is an object of type Call then the arguments needed to execute the call are encapsulated into the object. Thus the callee method and arguments are known. In this example the following command will be used 

In the Consume method retrieves method calls from queue and executes or otherwise outputs those method calls on the EDT . One example of a scheme for implementing a Consume method is set forth below. In this example a table.getModel method updates a table displayed on a GUI to include a row of data with the item argument. The method is as follows 

Those skilled in the art will appreciate that the table.getModel method is generally available in Swing.

An additional enhancement of performance is calls coalescing. Coalescing allows for updating a GUI fewer times than the number of update requests. The combination of calls scheduling and coalescing improves performance dramatically. Scheduling ensures that the EDT has enough time to handle painting key events mouse events and the like. Coalescing ensures that coalescable GUI updates are accumulated to save the GUI from more frequent updates than necessary.

Generally coalescing is performed as described above in part A of . With embodiments of the present invention the coalescing operation can be performed on method calls sent from the background process for output to the EDT at various stages and by various threads and methods. In one embodiment the background process performs coalescing of method calls when Send data operation is called. In another embodiment the Send data operation performs coalescing of method calls as they are stored in queue . In another embodiment a separate coalescing process performs coalescing of method calls before or after they are stored in queue . In yet another embodiment coalescing is performed by Handle data operation when the method calls are retrieved from queue .

In another coalescing example when the Send data operation is a setProgress method described below a plurality of cells of the queue identify the setProgress method. In this case only two cells are relevant the cell having the most current state information and the cell having the oldest state information. The difference represent the change in progress. These two cells are selected when the Handle data operation is called and any intermediate cells are discarded. The arguments in the two selected cells are then provided to the Handle data operation .

In a Schedule method is called at three different times during processing of the background process . Each call results in a block and being sent to queue for storage. In this example these blocks and represent first second and third partial results and or the arguments of those results to be output on EDT by the Consume method. But before being output the coalescing function ensures that what can be coalesced is coalesced. In this example the identified method and object in the blocks and are all the same so the three partial results are combined into a combined partial result with the object identifier method identifier and combined arguments. That is arguments passed by multiple Schedule method calls can be executed on the EDT by a single Consume method call in which the arguments are combined as shown in . In this example the three schedule operations Schedule Schedule and Schedule pass arguments and which are coalesced and executed in a single consume operation Consume . Such coalescing improves computational efficiency because updating a GUI is generally time consuming. With fewer Consume method calls the fewer times the GUI needs to be updated and time and computational resources are conserved.

State information can be updated on the EDT using two other methods when Send data operation is called firePropertyChange and setProgress. When state information is updated propertyChange listeners are called on the EDT.

In the firePropertyChange and setProgress methods have some similar functionality to the Schedule method. The setProgress method is a special case of firePropertyChange. The firePropertyChange method is called when the bound property changes for SwingWorker as known to those skilled in the art and described in java beans documentation for java.beans.PropertyChangeEvent which is hereby incorporated by reference. A PropertyChange event is delivered to the EDT whenever a bean changes a bound or constrained property. A PropertyChangeEvent object is sent as an argument to PropertyChangeListener and VetoableChangeListener methods. Normally PropertyChangeEvents are accompanied by the name and the old and new value of the changed property. If the new value is a primitive type such as int or boolean the new value must be wrapped as the corresponding java.lang. Object type such as Integer or Boolean .

The setProgress method is a special case because it is known that calls can be coalesced for the progress. The setProgress and firePropertyChange methods call propertyChangeListeners with the PropertyChangeEvent object.

A process can have many bounding properties. Progress is one of them. For example when a lengthy task accesses a website the bounding property might be the status of such connection. The firePropertyChange method would be called to update listeners on the property value.

In when calling the Send data operation includes calling of firePropertyChange or setProgress an object method identifier and arguments are passed to the queue and stored in a memory cell. In these situations the method identified by the method identifier is either firePropertyChange or setProgress. The differences are that while the Schedule method passes partial results the firePropertyChange and setProgress methods pass state information. The state information generally includes information representing the progress of one or more threads or processes. Another difference is that the schedule method essentially notifies the Consume method while firePropertyChange and setProgress notify propertyChange listeners. In addition while the Consume method is essentially part of the EDT listeners can be external to the process or invoked on the EDT as well. In one embodiment calling of the firePropertyChange or setProgress method on the background process triggers propertyChange listeners invocation on the EDT.

In one example a setProgress counter displayed on a GUI is incremented every time a new item is loaded and displayed. Listeners on the EDT are notified that the setProgress counter has changed. Other examples of how setProgress can be used include the progress bar and the pie shaped progress circle in the GUI of .

The Consume method and setProgress method both provide coalescing. In the Consume method coalescing includes joining arguments as described above. With the setProgress method the oldest state and the current state are retrieved for an object indicating progress of some operation. In one example a progress object has a value from 0 to 100 indicating an estimated percentage of completion of the operation. 0 indicates that no progress has been made and 100 indicates that the operation has been completed. So for example when the current state is setProgress 30 the user can receive this value and not have to bother with out of date state information such as setProgress 20 or setProgress 10 .

FirePropertyChange is a method used for disclosing a property which a process in progress may have. A process can have many different properties e.g. last username and password how much memory used internal cache state etc. The properties are essentially anything internal to the background process. FirePropertyChange indicates that the property was changed. For instance a button on the GUI can indicate status information e.g. connection open connection closed connection refused . Partial results can also be handled by FirePropertyChange.

In one example as shown in the GUI of an HTML page is loaded for display by a browser. In a first portion of the GUI a table has rows or paragraphs displaying a plurality of items submitted for auction. Each item has an image a title a name and detailed information which are provided as partial results. In a second portion of the screen detailed information describing a particular item is shown when that item is selected. When the HTML page is loaded for display by the browser the page is loaded paragraph by paragraph. Each paragraph can be pushed to the GUI to display however such pushing could cause too many events to be queued by the EDT resulting in freeze. Instead the Schedule and Consume methods are used as described above to provide the images text and other individual data objects within each paragraph as partial results. The Consume method outputs the items on the EDT for display on the GUI as soon as reasonably possible when Handle data operation is called.

Also in a setProgress method tracks the progress of the data loading and updates the GUI in particular a progress bar shown at the bottom of the GUI. The progress bar shows progress of the background process of loading the entire page from the Internet. The setProgress method updates the progress bar every time a new item is received and displayed in the table shown in the first portion of the GUI. A second setProgress method updates pie shaped progress circle indicating the progress of downloading all of the items in a particular row in this case associated with a particular auction item. The pie shaped progress circle serves as a preloading indicator for each auction item indicating the status of the loading of data describing that item.

In embodiments of methods and apparatus of the present invention provide increased responsiveness and a more real time experience as opposed to conventional applications which wait until all items are loaded and then show the entire GUI in one shot as a final result. By providing partial results and state information the methods and apparatus described herein provide a more responsive GUI for the user.

In in one embodiment each of four rows of information in first portion is passed as a separate argument of a respective Schedule method call. At some later time the Consume method is called on the EDT. Using the coalescing techniques described above the arguments are displayed on the GUI with a single call to the Consume method.

In in a preferred embodiment there are a plurality of SwingWorkers in operation. The SwingWorkers cooperate to split an otherwise complicated process into simpler and manageable pieces. One SwingWorker is responsible for loading tabular data for the items Table. The others are responsible for prefetching html documents for visible items in the table. When item becomes invisible the prefetching process for this item is canceled. Thus for example the user might click on a visible item to get more details on it in html format. If this data is prefetched the result will be instant. Thus the user experience is improved. An otherwise time consuming operation becomes an almost instant result using SwingWorker.

Other applications in which embodiments of methods and apparatus of the present invention can be used include table display applications such as financial applications. In one example stock quotes and other partial results are loaded at regular intervals from the Internet and the UI is responsive by updating a table in which the quotes are displayed. The table is updated so that the stock quotes are displayed shortly after being received.

In within computer system an operating system comprises program instruction sequences. The operating system provides a software platform upon which application programs may execute in a manner readily understood by those skilled in the art. The computer system further comprises one or more applications having program instruction sequences for performing the methods described above.

In the computer system incorporates any combination of additional devices. These include but are not limited to a mass storage device one or more peripheral devices an audio means one or more input devices one or more portable storage medium drives a graphics subsystem a display and one or more output devices . The various components are connected via an appropriate bus as known by those skilled in the art. In alternative embodiments the components are connected through other communications media known in the art. In one example processor and memory are connected via a local microprocessor bus while mass storage device peripheral devices portable storage medium drives and graphics subsystem are connected via one or more input output buses.

In mass storage device is implemented as fixed and or removable media for example as a magnetic optical or magneto optical disk drive. The drive is preferably a non volatile storage device for storing data and instructions for use by processor . In some embodiments mass storage device stores client and server information code for carrying out methods in accordance with exemplary embodiments of the invention and computer instructions for processor . In other embodiments computer instructions for performing methods in accordance with exemplary embodiments of the invention also are stored in processor . The computer instructions are programmed in a suitable language such as Java or C .

In the portable storage medium drive in some embodiments operates in conjunction with a portable non volatile storage medium such as a floppy disk CD ROM or other computer readable medium to input and output data and code to and from the computer system . In some embodiments methods performed in accordance with exemplary embodiments of the invention are implemented using computer instructions that are stored on such a portable medium and input to the computer system via portable storage medium drive .

In the peripheral devices include any type of computer support device such as an input output I O interface to add functionality to computer system . In one example the peripheral devices include a network interface card for interfacing to a network a modem and the like. The peripheral devices also include input devices to provide a portion of a user interface and may include an alphanumeric keypad or a pointing device such as a mouse a trackball a stylus or cursor direction keys. The I O interface comprises conventional circuitry for controlling input devices and performing particular signal conversions upon I O data. The I O interface may include for example a keyboard controller a serial port controller and or digital signal processing circuitry.

In the graphics subsystem and the display provide output alternatives of the system. The graphics subsystem and display include conventional circuitry for operating upon and outputting data to be displayed where such circuitry preferably includes a graphics processor a frame buffer and display driving circuitry. The display may include a cathode ray tube CRT display a liquid crystal display LCD or other suitable devices. The display preferably can display at least 256 colors. The graphics subsystem receives textual and graphical information and processes the information for output to the display often as a GUI. A video card in the computer system also comprises a part of graphics subsystem and also preferably supports at least 256 colors. For optimal results in viewing digital images the user should use a video card and monitor that can display the True Color 24 bit color setting. This setting enables the user to view digital images with photographic image quality.

In audio means preferably includes a sound card that receives audio signals from a peripheral microphone. In addition audio means may include a processor for processing sound. The signals can be processed by the processor in audio means of computer system and passed to other devices as for example streaming audio signals. In some embodiments programs for performing methods in accordance with exemplary embodiments of the invention are embodied as computer program products. These generally include a storage medium or media having instructions stored thereon used to program a computer to perform the methods described above. Examples of suitable storage medium or media include any type of disk including floppy disks optical disks DVDs CD ROMs magnetic optical disks RAMs EPROMs EEPROMs magnetic or optical cards hard disk flash card smart card and other media.

Stored on one or more of the computer readable media the program includes software for controlling both the hardware of a general purpose or specialized computer or microprocessor. This software also enables the computer or microprocessor to interact with a human or other mechanism utilizing the results of exemplary embodiments of the invention. Such software includes but is not limited to device drivers operating systems and user applications. Preferably such computer readable media further include software for performing the methods described above.

In certain other embodiments a program for performing an exemplary method of the invention or an aspect thereof is situated on a carrier wave such as an electronic signal transferred over a data network as one form of a computer program product. Suitable networks include the Internet a frame relay network an ATM network a wide area network WAN or a local area network LAN . Those skilled in the art will recognize that merely transferring the program over the network rather than executing the program on a computer system or other device does not avoid the scope of the invention.

In bytecodes may generally be reproduced downloaded or otherwise distributed through a network or stored on a storage device. In the described embodiment bytecodes are platform independent. That is bytecodes may be executed on substantially any computer system that is running on a suitable virtual machine . Bytecodes are provided to a runtime environment which includes virtual machine . Runtime environment may generally be executed using a processor or processors. Virtual machine includes a compiler an interpreter a runtime system and an operating system . Bytecodes may be provided either to compiler or interpreter .

In when bytecodes are provided to compiler methods contained in bytecodes are compiled into machine instructions. In one embodiment compiler is a just in time compiler which delays the compilation of methods contained in bytecodes until the methods are about to be executed. When bytecodes are provided to interpreter bytecodes are read into interpreter one bytecode at a time. Interpreter then performs the operation defined by each bytecode as each bytecode is read into interpreter . That is interpreter interprets bytecodes as will be appreciated by those skilled in the art. In general interpreter processes bytecodes and performs operations associated with bytecodes substantially continuously.

In when a method is invoked by another method or is invoked from runtime environment if the method is interpreted runtime system may obtain the method from runtime environment in the form of a sequence of bytecodes which may be directly executed by interpreter . If on the other hand the method which is invoked is a compiled method which has not been compiled runtime system also obtains the method from runtime environment in the form of a sequence of bytecodes then may go on to activate compiler . Compiler then generates machine instructions from bytecodes and the resulting machine language instructions may be executed directly by one or more processors. In general the machine language instructions are discarded when virtual machine terminates. The operation of virtual machines or more particularly Java virtual machines is described in more detail in by Tim Lindholm and Frank Yellin ISBN 0 201 63452 X which is incorporated herein by reference.

A number of implementations of the invention have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly other embodiments are within the scope of the following claims.

