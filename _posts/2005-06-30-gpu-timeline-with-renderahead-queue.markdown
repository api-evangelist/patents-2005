---

title: GPU timeline with render-ahead queue
abstract: Video editing and video playback utilizing a render-ahead queue for storing rendered video frames. The render-ahead queue facilitates the smooth playback of video in forward and reverse timeline direction, avoiding video glitches that occur when video frames are rendered at a rate that is less than the timeline rate of the video file. Embodiments of the present invention also include the use of a graphics processing unit in conjunction with the render-ahead queue to further ensure smooth playback of video.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07817900&OS=07817900&RS=07817900
owner: Microsoft Corporation
number: 07817900
owner_city: Redmond
owner_country: US
publication_date: 20050630
---
Embodiments of the present invention relate to the field of video rendering and play back of video and audio files. In particular embodiments of this invention relate to systems and methods utilizing a graphics queue to render and smoothly display video and audio files at the frame rate of a video timeline.

Common format standards for smooth playback of video files include displaying thirty frames of video for each second of a video timeline. During the video editing process smooth playback of video frames and audio sequences that make up video and audio files is often not obtained due to the processing of video files and the individual video frames and audio sequences that must occur prior to displaying the video file to a screen and outputting audio sequences to a speaker.

Several processes occur in video editing and playback which require central processing unit CPU resources. A number of these processes are part of the pre roll logic which includes seeking for files opening and decoding a first video file rendering effects to the video frames of the file displaying the frames to a screen and closing the first video file opening and decoding a second video file and so forth. Similarly the processing of audio sequences of an audio file as well as synchronization with video frames also requires CPU processing capacity. The CPU typically cannot perform all processes of the pre roll logic in the time it takes for one frame of video to be displayed e.g. one thirtieth of a second in order to smoothly playback the video and audio files. Consequently video and audio playback appears choppy or halting i.e. glitching as the CPU performs the required pre roll logic processes at a rate that is less than the video timeline.

Video playback in reverse also requires significant CPU resources. In addition to glitching in forward playback of video files reverse playback of most compressed video file formats e.g. WMV cannot be performed in real time. I Frame based video files which is a common form of real time video format store video frames as the difference from the previous frame. Thus in order to playback video frame X one must first determine the differences between frame X and the frame immediately preceding it on the video timeline e.g. frame X . Therefore reverse playback of video can be very expensive operations for the CPU to process requiring the CPU to decode all the previous frames to the preceding key frame in a video file. Once decoded video effects must be rendered by the CPU consuming more of its processing resources. This process makes it difficult for the CPU to decode render synchronize the video frames with the audio sequences and playback the video file in real time.

In addition to the processes of the pre roll logic CPU processing resources can be consumed by scheduled or random processes that occur in the background such as receiving an email which further limit the CPU resources that can be provided to performing the process of the pre roll logic. Thus as scheduled or random processes further require CPU processing time more glitches in the video playback can occur.

Accordingly a system and method for smooth playback of video in forward and reverse timeline directions is desired to address one or more of these and other disadvantages.

The deficiencies of the known art are overcome by providing smooth video playback in both forward and reverse timeline directions. A video file is decoded and the resulting video timeline is saved directly to video memory. Embodiments of the invention utilize the resources of a graphics processing unit GPU which processes the effects of video frames during a rendering process. The rendered video frames are stored on a render ahead queue in video memory. The frames are then removed from the render ahead queue and displayed to a screen.

In another aspect the embodiments of the invention utilize the render ahead queue and a second queue to smoothly playback video in reverse timeline order. Video frames are decoded in forward timeline order into memory and effects are rendered upon them. The rendered frames are stored on a second queue. The frames on the second queue are then removed from the second queue in reverse order and placed on the render ahead queue. The frames are then removed from the render ahead queue and displayed to a screen in reverse timeline order.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Referring first to an exemplary flowchart is provided of a method of displaying video in which the present invention may be implemented. The method is initiated when video files are accessed at by the central processing unit CPU and decoded at into a timeline sequence of video frames. Once decoded the CPU stores the timeline of video frames directly into video memory . Once in video memory a graphics processing unit GPU accesses a video frame and processes any effects that are needed at and then queues the processed video frame to a render ahead queue at . The GPU then removes the processed video frames from the render ahead queue at at the frame rate of the video timeline and displays the video frame to a screen at .

In another embodiment the CPU removes the processed video frames from the render ahead queue and displays them on a screen.

In another embodiment the present invention provides a system and method of playing back both video and audio files during video editing. Referring to an exemplary flowchart is provided of a method of displaying video and outputting audio in which the present invention may be implemented. The method is initiated when video files are accessed at by the central processing unit CPU and decoded at into a timeline sequence of video frames. Once decoded the CPU stores the timeline of video frames directly into video memory . Once in video memory a graphics processing unit GPU accesses a video frame and processes any effects that are needed at and then queues the processed video frame to a render ahead queue at .

The method also provides the processing queuing synchronization of audio files in conjunction with video files. Audio files are accessed at by the central processing unit CPU and decoded at into a series of audio sequences. Once decoded the CPU stores the audio sequences directly into memory . Once in memory the audio sequence is queued on an audio queue at .

The CPU instructs the GPU to remove the processed video frames from the render ahead queue at at the frame rate of the video timeline. The CPU initiates the process while the GPU does the heavy pixel processing. The CPU removes the audio sequence from the audio queue at . The video frame is synchronized with the audio sequence at and the video frame is displayed to a screen and the audio sequence is output to a speaker at .

In another embodiment the CPU removes the processed video frames from the render ahead queue removes the audio sequence from the audio queue synchronizes the video frame with the audio sequence and displays the video frame on a screen and outputs the audio sequence to a speaker.

The present invention overcomes the deficiencies of the known art that result in glitches during playback of video files by utilizing a render ahead queue. The render ahead queue is created in video memory and contains video frames upon which video effects have already been rendered. Video frames are obtained from the render ahead queue and displayed to a screen at the frame rate of the video timeline. Video frames are added to the render ahead queue at a rate that exceeds the video timeline playback rate. Video frames can also be added to the queue when playback of the video timeline is in a paused state allowing the number of video frames on the queue to be built up. Since video playback is started in a paused state the queue will always contain video frames upon initiation of playback.

Since the average rate at which frames are added to the queue exceeds the rate of the video timeline the queue remains full given no other inputs e.g. internal events like file switching external events like other processes using disc or CPU resources such as random background processes of the CPU described above. Therefore during video playback rendered video frames can be continuously accessed from the render ahead queue and displayed at the frame rate of the timeline providing a smooth playback of video.

If a process occurs that consumes CPU processing resources the render ahead queue permits smooth playback of video until all of the queued frames have been displayed on the queue. If the process requiring CPU processing resources ceases before all the video frames on the render ahead queue have been displayed the CPU can resume video processes to replenish the render ahead queue with video frames at a rate exceeding the video timeline thereby permitting continuous smooth video playback.

The render ahead queue also permits smooth playback of video when CPU resources are expended on video editing processes. For example seeking a temporally compressed media format file typically cannot be performed in the time required to display a video frame. Thus the render ahead queue permits video editing processes to simultaneously seek and playback video to a screen by displaying video frames that are held in the render ahead queue until the seek process is completed. Once the seek process is finished video frames are again added to the render ahead queue.

The size of the render ahead queue is dependent upon the hardware capacity of the computing devices used to edit and playback video. In one embodiment the render ahead queue contains up to thirty video frames which is up to one second of video timeline. In another embodiment the render head queue contains up to sixty video frames or up to two seconds of video timeline. In another embodiment the render ahead queue contains at least three frames of video. In another embodiment the render ahead queue contains at least five frames of video.

If the number of frames on the render ahead queue falls below a specified number e.g. three frames the buffer size can be reduced to attempt to continue smooth playback of video e.g. reduce buffer size from 640 480 to 320 280 . If playback still is not smoothly displayed the timeline speed can be reduced to slow playback which displays the frames in a slower but smoother order.

In addition to the render ahead queue the system and method of the present can additionally comprise an audio queue. In much the same way as the render ahead queue is utilized for creating a buffer queue of video frames the audio queue comprises audio sequences that are decoded from the audio files and placed into memory. By maintaining an audio queue audio sequences can be available for synchronization with the video frames at the rate of the video file timeline without resulting in audio sequences cutting out when CPU resources are expended on other processes. Also the audio needs to be rendered ahead with the video to so that the source files are reading at the same location. If audio and video attempt to read from different locations in a file it can result in the program to fail to respond i.e. hangs or cause poor disc performance.

In one embodiment a GPU is utilized to perform many of the processes previously performed by the CPU. In this configuration a computing device can act as a multiprocessor wherein a pipeline effect exists between the CPU providing decoded video and audio files to the GPU for further processing of video effects onto video frames queuing frames and displaying the video frames to a screen.

By utilizing a GPU the CPU is able to expend processing resources on other video editing processes such as synchronizing video frames with audio sequences and outputting the audio sequences to a speaker. Additionally the CPU resources are able to perform background processes decoding files and random processes such as processing the receipt of emails without causing disruption of the video rendering queuing and display processes.

Thus the GPU further ensures that the video render ahead queue and the audio queues contain video frames and audio sequences for smooth playback of video and audio files.

The GPU further enables the computing device to smoothly process and display complex playback processes such as reverse playback of I Frame based video files that would otherwise expend significant CPU resources.

The present invention utilizes the render ahead queue and a second queue to manipulate video frames allowing for smooth playback of video files in reverse order. Reverse playback can be accomplished by first playing the video file forward for short durations into a second queue and then removing them from the second queue in reverse order and placing them on the render ahead queue before displaying the frames in reverse order to a screen. The render ahead queue permits the computing device to smoothly display the frames in reverse order from the render ahead queue while executing the lengthy process of obtaining additional frames reversing their order and placing them on the render ahead queue for reverse playback. The process is repeated until reverse playback is ceased or the beginning of the video file is reached.

Most video files cannot be merely played back in reverse but rather first require processing of each video frame relative to adjacent frames before playback can occur. As discussed above I Frame based video files which is a common form of real time video format store video frames as a series of base frames or key frames between which are intermediate frames which are stored as differences between the base frame and the intermediate frame. Thus in order to playback video frame X one must first determine the differences between frame X and the frame immediately preceding frame X on the video timeline e.g. frame X . Thus for example if key frames are located at time and time and the video frame at time is desired the computing device must back up to the key frame at time and draw the frame at time by processing the differences between the frame at time and the key frame at time . The frame at time is drawn by adding the differences from the frame at time and so forth until the frame at time is drawn from the differences from the frame at time .

To obtain video frames in a reverse timeline order for display after frame X is displayed video frames preceding video frame X on the video timeline are located and loaded into video memory. Effects are then rendered onto the frames and the rendered frames are added to in a second queue in the forward timeline direction. The frames are then removed from the second queue in reverse order and added to the render ahead queue immediately following frame X in the reverse timeline direction. The number of frames loaded in the queue is dependent on the available video memory and the time required to display the X frames to a screen. This process is repeated for the entire duration that the frames are displayed to the screen in reverse timeline direction.

Due to the I Frame format of most video files described above frame stepping in the reverse timeline direction normally requires decoding of all video frames in the forward timeline direction until the frame is reached which is the starting frame of the reverse timeline direction. The render ahead queue permits smooth frame stepping in the reverse timeline direction by displaying frames on the render ahead queue that have been previously displayed while also seeking and processing the next segment of video in the reverse timeline direction and placing it in the render ahead queue for reverse playback as described above.

In one embodiment a specified number of video frames are maintained in the render ahead queue after they have been displayed to a screen. Then when a segment of video is desired in reverse timeline frame stepping the specified number of frames are already in the render ahead queue and available for display without requiring seeking and decoding the frames from a video file. For example if Y frames are maintained on the render ahead queue after display after Z frames a number less than Y on the render ahead queue are displayed in reverse timeline direction the method of the present invention seeks for the video frames that immediately precede the Y frames on the timeline and the frames are added to the render ahead queue in reverse order such that they will be displayed after the last Y frame is displayed in reverse timeline direction. In this embodiment the render ahead queue will always have between Y and Y Z frames in the queue available for display in reverse timeline direction. In this example Y and Z are variables representing a specified number of video frames based upon the amount of video memory available and the amount of video memory needed to render a current section of the timeline.

A video memory manager must be written to create and organize the render ahead queue and any other queues used in the present invention. At a video frame size of 640 480 each video frame requires 1.2 Mb of memory. On a low memory card such as 32 Mb after system requirements for memory are taken into account such as memory requirements for back buffers swap chains and the like there are about 20 buffers available for storing video frames. On a 256 Mb card there are in excess of about 200 buffers available for storing video frames. Since the amount of memory that is required by other processes or driver implementations cannot be calculated the amount of buffers that are available for video and audio playback cannot be determined until they are depleted.

To avoid out of video memory errors from occurring a custom memory manager is written that creates all the buffers needed in the video playback process of the present invention. When a buffer allocation fails e.g. a rendered video frame cannot be added to the render ahead queue due to running out of video memory instead of generating an out of memory error the custom video memory manager stalls the allocation of the rendered video frame until a frame present on the render ahead queue is removed. When the frame is removed the memory required for its storage on the queue is returned to the system for reallocation. The custom video memory manager then stores the rendered video frame on the buffer that was returned to the system for reallocation.

By utilizing this self correcting algorithm the render ahead queue can handle switching segments of the timeline that require different amounts of memory to run. When switching from a segment that uses less video memory the maximum size of the queue will increase to handle the new segment. Alternatively when switching from a segment that uses more video memory the maximum size of the queue will decrease to handle the new segment. For example if five video memory units are on the system and the current video segment requires four units the remaining one unit is available for use on the queue. If the current segment needs one memory unit then the queue will have four memory units.

The computer typically has at least some form of computer readable media. Computer readable media which include both volatile and nonvolatile media removable and non removable media may be any available medium that may be accessed by computer . By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that may be used to store the desired information and that may be accessed by computer . Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Those skilled in the art are familiar with the modulated data signal which has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media are examples of communication media. Combinations of any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of removable and or non removable volatile and or nonvolatile memory. In the illustrated embodiment system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. For example illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media. also shows a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that may be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive and magnetic disk drive and optical disk drive are typically connected to the system bus by a non volatile memory interface such as interface .

The drives or other mass storage devices and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components may either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into computer through input devices or user interface selection devices such as a keyboard and a pointing device e.g. a mouse trackball pen or touch pad . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to processing unit through a user input interface that is coupled to system bus but may be connected by other interface and bus structures such as a parallel port game port or a Universal Serial Bus USB . A monitor or other type of display device is also connected to system bus via an interface such as a video interface . In addition to the monitor computers often include other peripheral output devices not shown such as a printer and speakers which may be connected through an output peripheral interface not shown .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. LAN and or WAN may be a wired network a wireless network a combination thereof and so on. Such networking environments are commonplace in offices enterprise wide computer networks intranets and global computer networks e.g. the Internet .

When used in a local area networking environment computer is connected to the LAN through a network interface or adapter . When used in a wide area networking environment computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in a remote memory storage device not shown . By way of example and not limitation illustrates remote application programs as residing on the memory device. The network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of computer are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described herein.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized however that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

Although described in connection with an exemplary computing system environment including computer the invention is operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An interface in the context of a software architecture includes a software module component code portion or other sequence of computer executable instructions. The interface includes for example a first module accessing a second module to perform computing tasks on behalf of the first module. The first and second modules include in one example application programming interfaces APIs such as provided by operating systems component object model COM interfaces e.g. for peer to peer application communication and extensible markup language metadata interchange format XMI interfaces e.g. for communication between web services .

The interface may be a tightly coupled synchronous implementation such as in Java 2 Platform Enterprise Edition J2EE COM or distributed COM DCOM examples. Alternatively or in addition the interface may be a loosely coupled asynchronous implementation such as in a web service e.g. using the simple object access protocol . In general the interface includes any combination of the following characteristics tightly coupled loosely coupled synchronous and asynchronous. Further the interface may conform to a standard protocol a proprietary protocol or any combination of standard and proprietary protocols.

The interfaces described herein may all be part of a single interface or may be implemented as separate interfaces or any combination therein. The interfaces may execute locally or remotely to provide functionality. Further the interfaces may include additional or less functionality than illustrated or described herein.

This example illustrates the use of video frame allocation to buffers in video memory by a custom video memory manager as described above. In this example a video card contains ten 10 video buffers of memory labeled A J. The exemplary video editing entails two video timelines and one transition that is inserted between the two videos. During the video editing process each video requires two working buffers and the transition requires one working buffer that are used in the manipulation of the video frames and the transition in the editing process.

During the transition between Video and Video a total of five working buffers are required two working buffers to process and display Video one working buffer to process the transition and two working buffers to process and display Video . At this time only five buffers are available to store video frames on the render ahead queue.

Once the timeline continues to the point where only Video is being processed and displayed only two working buffers are required. Thus as before eight buffers are available to store video frames of Video on the render ahead queue.

Video contains video frames. is an illustration of the render ahead queue after video frame of Video has been decoded rendered and allocated to Buffer J. As described above the transition requires one working buffer and Video requires two working buffers. Thus after frame of Video has been queued on the render ahead queue a total of five working buffers are required before the transition and Video can be processed.

The order of execution or performance of the methods illustrated and described herein is not essential unless otherwise specified. That is elements of the methods may be performed in any order unless otherwise specified and that the methods may include more or less elements than those disclosed herein. For example it is contemplated that executing or performing a particular element before contemporaneously with or after another element is within the scope of the invention.

When introducing elements of the present invention or the embodiment s thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

In view of the above it will be seen that the several objects of the invention are achieved and other advantageous results attained.

As various changes could be made in the above system and methods without departing from the scope of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

