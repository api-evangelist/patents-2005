---

title: Configuration for binding software assemblies to application programs
abstract: A method, system and infrastructure that allow an application to run with specified versions of assemblies bound thereto, while allowing the application author, assembly publisher and/or an administrator to change the originally-specified version as desired. Each assembly may exist and run side-by-side on the system with other versions of the same assembly being used by other applications. An application manifest specifies any desired assembly versions, which may be redirected to another version (overridden) by an application configuration. A publisher configuration provided by an assembly publisher can similarly override the specified version. Lastly, an administrator configuration is capable of overriding other configuration versioning information. A table built from the manifest and any configuration redirection may be accessed during execution to quickly locate the appropriate version. The various configuration data structures themselves may be wrapped as assemblies, thereby enabling versioning of configurations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07073170&OS=07073170&RS=07073170
owner: Microsoft Corporation
number: 07073170
owner_city: Redmond
owner_country: US
publication_date: 20050321
---
This is a continuation of U.S. patent application Ser. No. 09 842 278 filed Apr. 24 2001 now U.S. Pat. No. 6 871 344 which claims priority to United States Provisional Patent Application Ser. No. 60 199 227 filed Apr. 24 2000.

The present invention is generally directed to computer systems and more particularly to executable computer code such as application programs that utilize shared assemblies.

At one time computer applications were monolithic blocks of executable code and data although some of their data such as variable settings could be maintained in separate files. This made tasks like moving or replacing the application simple. In contrast contemporary computer applications and other executable code such as an operating system component bind to and make use of shared components wherein in general a component is a self contained software entity offering a set of functions that can be used by a variety of applications. Such components include dynamic link libraries DLLs and objects such as OLE Object Linking and Embedding components and COM Component Object Model components including ActiveX controls. In turn some of these shared components depend on other shared components.

On any given machine at present there is one version of each of these components shared by applications such as the most recently installed version although some mechanisms are known that replace an installed component only when an available replacement component has a higher version number. The metadata maintained for using these components is generally maintained in the system registry and the application has the names of the needed components compiled into its binary code. Because in general the application does not change as components change to function properly global component sharing requires that any shared component function exactly like previous other versions of that component with respect to what an application expects. In practice however perfect backwards compatibility is difficult if not impossible to achieve among other reasons because it is impractical to test the many configurations in which the shared component may be used. For example both newer and older applications end up sharing the same component whereby over time fixing and improving the component becomes increasingly difficult. Moreover the practical functionality of a component is not easily defined. For example some applications may utilize unintended side effects in a component that are not considered part of the core function of the component e.g. an application may become dependent on a bug in a component and when the component publisher chooses to fix that bug the application fails. Of course on the other side application writers cannot test future versions of components.

As a result problems occur when a component is updated to its newer version such as when a new application or operating system service pack is installed with updated copies of components as the newly installed component versions become the ones used by other applications and components on the system. The sheer volume of applications and components that rely on other components magnifies this problem which is sometimes referred to as DLL Hell. 

One mechanism that provided sharing for some applications while enhancing the stability of other applications was provided in Microsoft Corporation s Windows 2000 and Windows 98 Second Edition operating systems. In general this mechanism provided a way for an application to be bound to a local copy of a component instead of a shared copy. However with this solution a component needed to be isolated per application which resulted in multiple copies of the same component version having to be maintained on the system. Additionally COM data was not isolated limiting this mechanism s usefulness with COM objects.

At the same time even if it was possible to permanently bind an application to one version of a shared component it is not always desirable to do so. For example a critical security fix may be made to a component but if an existing application were permanently bound to an earlier version of that component the application would not be protected by the security fix. In sum the existing models for sharing components have many problems and shortcomings.

Briefly the present invention provides a method system and infrastructure that allow an application to run with specified versions of components bound thereto while allowing the application author and or component publisher to change the version as desired. In an alternative mode an administrator may also have input e.g. the final decision as to specifying the version to be used. A component is often packaged with other components as an assembly wherein an assembly is set of one or more component files that are versioned and ship as a unit and thus as used herein a set of one or more components are also referred to as an assembly and a component publisher an assembly publisher.

Each assembly may exist and run side by side on the system with other versions of the same assembly being used by other applications. To this end the application provides an application manifest to specify any desired assembly versions. The application author may also provide e.g. at a later time an application configuration that overrides the binding information in the application manifest. The present invention also allows an assembly publisher to provide a publisher configuration that may similarly control which assembly version will be used. In a first alternative mode the application configuration when present is applied after any publisher configuration is applied and thus overrides the publisher configuration s binding information. In a second alternative mode the order of applying the configurations is reversed whereby the publisher configuration may change the application configuration s binding override information. In this second alternative mode the application configuration may have a setting therein that bypasses the publisher configuration in a safe mode of operation. Lastly preferably also in this second alternative mode an administrator configuration may be present that is capable of overriding the other configuration version binding information. Some or all of the various configuration data structures e.g. the publisher configurations themselves may wrapped as assemblies thereby benefiting from the characteristics of assemblies including versioning of configurations strong naming of configurations and so on.

In this manner the present invention enables applications to explicitly use different versions of assemblies from what the application as originally shipped had specified. This allows for exact management and control of assemblies during the lifecycle of the application. To determine the correct version at runtime in the first mode the present invention first interprets the application manifest e.g. released with the application followed by a publisher configuration if present that may redirect re map any assembly versions specified in the application manifest to other assembly versions. Then if an application configuration is present the application configuration is interpreted to redirect some or all of the current binding information e.g. for the current assembly version to another assembly version as specified therein.

In the second alternative mode the present invention first interprets the application manifest e.g. released with the application followed by the application configuration if present that may redirect re map any versions specified in the application manifest to other versions. Then if a publisher configuration is present and the application configuration does not bypass the publisher configuration via a special safe mode the publisher configuration is interpreted to possibly redirect the current binding information e.g. for that assembly version to another assembly version as specified therein. Lastly any administrator configuration is interpreted to possibly again change the bindings to assembly versions.

For efficiency the present invention may build tables in an activation context in a pre execution initialization phase to maintain the version mapping information rather than interpreting the manifest and any configurations each time an assembly is needed i.e. per request file mapping including adjusting for configurations is straightforward to implement but less efficient . The activation context tables provide fast mapping from assembly names provided by the application including version independent names to the correct versions as specified in the manifest normally fully named assemblies and altered by any configurations. Once built the tables may be cached e.g. such as in the first alternative mode for the time that the application instance runs lifetime of the process whereby the information therein is available as needed. In an alternative mode such as the second alternative mode the tables or other binding data may be dynamically recalculated.

To use the tables in the pre application execution phase when creating a new process the operating system checks for an application manifest in same file system directory as the calling executable. In the first alternative mode when an application manifest exists the operating system checks for an activation context for the application that was built from the manifest and configurations. If the activation context does not exist for example this is the first time application has been executed or it exists but is not coherent with current configuration a new activation context is created via the application manifest and configurations.

At runtime when a program requests creation of a global object the operating system automatically consults the activation context built from the application and configurations to locate and load the appropriate assembly version. The operating system also maps any uses of this named object to the appropriate version to allow for multiple versions of the code module to run simultaneously without interfering with each other. By the activation context built from the application manifest and the configurations an application may be efficiently bound to specific assembly versions and thereby be isolated from assembly version changes. At the same time changes to the bindings are enabled via the configurations.

Other objects and advantages will become apparent from the following detailed description when taken in conjunction with the drawings in which 

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

The present invention is generally directed to binding application programs to configuration also referred to as policy determined isolated versions of components including code and or data per application program or the like in a manner that allows multiple versions of the same component to exist and operate side by side on a system. For practical purposes components are often collected into an assembly which when referring to items such as a component is the lowest unit of storage packaged for activation distribution and versioning. Rather than deal with individual components of which there may be a relatively large number many of the actions regarding components that are grouped together can be handled by referring to their assembly. For example rather than list in the manifest the dependencies on a large number of individual components that are packaged together in a component assembly the manifest may simply list a dependency on the assembly. As used herein the term assembly will refer to one or more components whether referring to a single component e.g. one contiguous DLL or to a plurality of components grouped together.

Assemblies can be shared such as when more than one application or the like needs an instance of the assembly s code. To provide significant flexibility while being transparent to existing and newly developed applications the present invention has been implemented in an operating system with applications being run via the operating system. As will be understood however the present invention is not limited to applications and or an operating system implementation but rather is capable of being implemented by virtually any mechanism internal or external to executable code e.g. an application that needs or wants to use a specific version of an assembly. Note that as used herein an application program is not limited to any particular type of software product but includes any executable code such as operating system components drivers and so on that in turn use other assemblies. Notwithstanding the present invention will be primarily described with an application that uses assemblies such as DLLs and objects.

In general an application manifest is an XML extensible Markup Language formatted file or other suitable file that comprises metadata e.g. describing an application s dependencies on shareable assembly versions sometimes referred to as side by side assemblies and also includes metadata to describe any privatized assemblies described below . For example the application manifest specifies in its dependency data a dependency on a particular version e.g. v1.0.0.0 of a shared assembly assembly as represented in by the arrow between blocks and . Note that the application manifest may also specify dependencies on other assemblies. Further note that other data structures including a configuration described below which are not ordinarily considered side by side assemblies each may be wrapped as an assembly to thereby obtain the benefits that an assembly may have such as versioning naming and so forth. The wrapping of a configuration as an assembly including associated version information is generally represented in by the box labeled Configuration Version Data accompanying the publisher configuration in .

Two types of assemblies are possible those having strong names e.g. including a public key signature or the like such that any two different assemblies can be unambiguously identified and those having a simple name which may be ambiguous in the system and for example do not contain a public key. To provide isolation any simply named assemblies on which an application manifest specifies a dependency are treated as privatized assemblies of wherein the dashed box represents that the privatized assemblies may or may not be present for a given application . Privatized assemblies are those that the application does not intend to be shared with other applications. Privatized assemblies that have simple names are normally installed into the same folder as the executable application code whereby the assembly is isolated and the application is given the effect of being monolithic e.g. its assemblies are not influenced by different assemblies having the same simple name and so forth. By not being shared privatized assemblies with simple names thus have the benefit of virtually complete isolation at the expense of the benefits obtained by sharing. Assemblies having strong names do not need to be placed into the application folder for isolation purposes because assemblies with strong names are known to be the exact one the application needs. Thus instead of being privatized by storing in a certain directory such assemblies may be placed into a global assembly cache to obtain the benefits of sharing while effectively preserving isolation because an application that asks for a strongly named assembly will get a copy that is exact subject to configuration overrides as described below .

The application manifest and assemblies both privatized and global are installed to their appropriate file system locations at the time the application or assembly is installed. In general the application application manifest and privatized assemblies those not strongly named are copied to the application folder while strongly named assemblies may be copied to the global assembly cache e.g. one or more folders . Note that to provide side by side existence of assembly versions any existing assembly versions are not overwritten in the assembly cache when another version is installed although a version can be removed by other means at the risk of breaking an application that depends on that version . The assembly cache can be hidden and or access controlled to prevent assemblies from being easily removed. The installation and general usage of manifests and assemblies are further described in the aforementioned United States Patent Application entitled Isolating Assembly Versions for Binding to Application Programs. 

Example manifests in XML format are set forth in the tables below wherein TABLE1 is an example of a simple application manifest where the application depends on a side by side version of COMCTL32 

TABLE2 is an example of an application manifest where the application depends on a side by side version of COMCTL32 and an assembly is privatized to the application 

Assemblies may be dependent on other assemblies which in turn are dependent on other assemblies and so on. To ensure the proper versions of dependent assemblies one or more of the assemblies e.g. assembly each have an assembly manifest e.g. associated therewith that specifies its corresponding assembly s dependencies. To this end assembly authors that create a side by side assembly may also author an assembly manifest which is copied to the assembly cache with the corresponding assembly at the time of installation whereby that assembly manifest will be interpreted for proper version dependencies. Note that although not directly identified in it is understood that assemblies x and any other assemblies in the assembly cache each may have an assembly manifest associated therewith shown in as a set of other assembly manifests .

Each assembly manifest describes the assembly and includes information about its individual assemblies including for example the name and version of the assembly the items program files resources that make up the assembly and the binding path to items within the assembly e.g. for Win32 DLLs this is the location of the DLL relative to the root of the assembly whereas for COM Servers this is the CLSID class identifier ProgID programmatic identifier and other COM metadata . The assembly manifest may also include any dependencies on other assemblies object classes and global names.

Although the application manifest lists its dependencies on assembly versions it should be noted that technically the application is only dependent on the manifest specified assemblies themselves not necessarily the exact versions that are specified. Instead the specified versions are only those tested with the application and known to work.

In accordance with one aspect of the present invention the operating system e.g. including an assembly loading mechanism can bind the application to another version of a needed assembly in place of one specified in the application manifest . To this end configuration information that is separate from the shared assembly may be interpreted to determine which version to bind. Note that a configuration is separate from the shared assembly or assemblies to which it refers for example in that it is a separable entity therefrom normally contained as a file that can be added to or removed from a system at a later time and so on.

In a first alternative mode as shown in an assembly publisher can issue a publisher configuration with data therein that redirects a requested assembly version e.g. requested via the manifest or the application configuration to one that is specified by the assembly publisher. In general a publisher configuration file applies to a single assembly although a single assembly may have multiple associated publisher configuration files. Note that a publisher configuration applies to any application in the system that uses the corresponding assembly.

The publisher configuration enables an assembly publisher to effectively replace one assembly version with another version such as when a service pack is installed. As described herein in a first alternative mode the assembly publisher configuration is interpreted after the manifest is interpreted and thus can change an assembly initially specified by the application author. For example in the publisher configuration may include data that redirects the binding specified in the manifest version 1.0.0.0 to version 2.0.0.0 shared assembly .

As also represented in an application configuration including updated assembly version dependency data may be stored in the application folder to similarly override some or all of the information in the application manifest and or any modification by the publisher configuration . For example as represented in the application configuration may include data e.g. an instruction that redirects the current binding from version 2.0.0.0 to version 3.0.0.0 the shared assembly e.g. redirect version 2.0.0.0 to version 3.0.0.0. In this manner an application author can effectively update a manifest and or override a publisher configuration by distributing such a configuration without having to actually make changes to the application manifest or have a new one reinstalled. Note that other instructions directed to other dependent assemblies may be in the same configuration and that there may not be any relevant instruction for a given assembly.

In a second alternative mode the order of applying configurations is modified and also at least one other configuration may be applied. More particularly as shown in the application configuration including updated assembly version dependency data may be stored in the application folder to override some or all of the information in the application manifest and is applied before the publisher configuration is applied. For example as represented in by the arrow from block to block the application configuration may include data e.g. an instruction that redirects the manifest specified binding to version 2.0.0.0 the shared assembly e.g. redirect version 1.0.0.0 to version 2.0.0.0. In this second alternative mode an application author can thus similarly effectively update a manifest without actually changing the manifest.

As also represented in the assembly publisher can similarly issue a publisher configuration with data therein that thereafter redirects the currently requested assembly version in the present example modified by the application configuration to one that is specified by the assembly publisher. This mode enables assembly publishers to effectively replace selected assemblies with other versions. In this second alternative mode because the assembly publisher configuration is interpreted after the manifest and or any application configuration is interpreted the publisher can thus change the assembly specified by the application author. In the example shown in the publisher configuration includes data that redirects the binding to version 4.0.0.0 shared assembly as shown in via the arrow from block to block .

Lastly in this second mode an administrator configuration and its version data may have the final decision as to which version of an assembly an application any application on the machine will be bound. For example in the administrator configuration is stored as a file in a system folder and includes data that redirects the current binding to an earlier version version 3.0.0.0 shared assembly as shown in via the arrow from block to block . As can be understood the administrator configuration allows an administrator or the like to bind any system applications to a new assembly or a restore a binding to an older assembly e.g. version 4.0.0.0 back to version 3.0.0.0 as shown in and so on regardless of what other configurations may specify. With the various configurations updates to applications via new assemblies are possible but only in a safe controlled manner with the machine administrator having the final determination.

Although complete compatibility of a shared assembly should be thoroughly tested even the smallest change to a shared assembly s code may cause an incompatibility with some applications that consume them. In such an event in the second alternative mode wherein the publisher configuration data can override the application configuration data the application configuration file may specify that safe mode binding should be applied to the specified assembly. In the safe mode the publisher configuration resolution stage is avoided whereby the application operates with no publisher configuration overrides. To use the safe mode the application configuration or other system setting e.g. set by an administrator can explicitly instruct the operating system to bypass the interpretation of the publisher configuration whereby the application author or an administrator controls the version that is bound to the application. In this is represented by the wide arrow labeled Safe Mode from block to block . Any administrator policy still may make the final decision however.

It should be noted that the safe mode bypasses publisher configuration in the second alternative mode which may affect the version that is used even when the administrator configuration includes an instruction related to a version of that assembly. By way of an example as shown in consider the application configuration specifying the safe mode. If the administrator configuration includes an instruction to change version 4.0.0.0 back to version 3.0.0.0 but no others with respect to this assembly the change to version 3.0.0.0 will not be implemented in the safe mode because the application configuration has specified version 2.0.0.0 whereby the administrator configuration will see version 2.0.0.0 and not see version 4.0.0.0 to change it. However if not in the safe mode the version will be changed to 3.0.0.0 because the publisher configuration will have first changed the version to 4.0.0.0 as described above whereby the administrator configuration instruction for version 4.0.0.0 will apply and version 3.0.0.0 will be restored. To provide flexibility a configuration instruction can specify a range of versions to redirect e.g. change any version in the range from 1.2.3.4 to 5.6.7.8 to version 9.0.0.0.

Note that while two alternative modes are primarily described herein it can be readily appreciated that other such modes are feasible. For example it is feasible to have a third alternative mode similar to the first alternative mode described above wherein a publisher configuration is interpreted before an application configuration but the further including an administrator configuration as in the second alternative mode. Indeed the present invention is not limited to any particular ordering number and types of configurations and so on but rather contemplates any such combinations and permutations.

As described above binding starts with a reference for example that at least contains the name or other identifier of the assembly. A fully specified assembly reference e.g. in the manifest and or configurations contains the information necessary to disambiguate one assembly from another. Dependent assembly references which are constructed at link time are fully specified assembly references. However under some circumstances it may be desirable to provide only a subset of the assembly identity information yet still issue a bind. For example a partially specified assembly reference may be missing public key and or version fields.

Because partially specified references are ambiguous the binding process can employ special logic to locate and bind to these assemblies. More particularly a first step to resolving a partial specified assembly bind is to search for an assembly in the application directory that satisfies the specified fields in the assembly reference. The application directory is probed first as opposed to immediately searching for a matching assembly in the global assembly cache to provide an application author deployer with some control over the assembly that is finally retrieved through a partially specified bind request. In other words because the global assembly cache is a global install location which can be used by all applications searching the global assembly cache first may result in an assembly being returned that was not intended by the original author deployer.

Should the binding process be unable to locate a matching assembly in the application directory a lookup in the global assembly cache may be performed to attempt to find a matching assembly e.g. for strongly named files in the first alternative mode . If a match is not found in the global assembly cache the assembly bind may be failed e.g. in the first alternative mode or a download can be attempted e.g. in the second alternative mode . If a matching assembly has been located the binding process e.g. the binding initialization mechanism reads the manifest data for the assembly and constructs a new fully specified assembly reference from this data. Because the assembly reference is now fully specified binding configuration can be applied on this reference as described above that is the bind proceeds as if the original assembly reference was fully specified with the above described logic used to specify one assembly file that if located satisfies the bind request.

Although it is possible to dynamically interpret the manifest and or configurations to locate the appropriate version of an assembly each time an assembly is requested assemblies are requested frequently and thus it is more efficient to cache the information once. To this end the activation APIs cause an activation context for that program to be constructed if a valid one does not already exist for the application for example when the application is being run for the first time or the activation context exists but its information is invalid . Once created the activation context is maintained in a persistable binary form for caching. In general there is an activation context for each application that has an expressed assembly dependency and each activation context includes one or more mapping tables preferably hashed for quick lookup. As described below the operating system a runtime version matching mechanism therein uses the activation context to determine where to retrieve the version.

To construct the activation context the activation APIs call or otherwise include a binding initialization mechanism wherein the call is generally represented in by the arrow accompanied by the circled numeral one . If a new activation context needs to be constructed the binding initialization mechanism reads and interprets the application manifest as represented in by the arrows labeled with circled numerals two and three . More particularly as described above whenever the operating system e.g. a binding mechanism therein including the binding initialization mechanism is asked to perform a bind for a shared assembly the bind client e.g. an API called to load a DLL is required to provide a reference which describes the requested assembly. The version of the assembly reference may then be altered by a series of configuration resolution stages as described herein by which the binding mechanism decides which version of the assembly to return to the bind client. Configuration resolution allows a reference to an assembly constructed at compile link time to be modified after the application has been deployed without re compilation re linking of the assemblies involved.

As represented in in the first alternative mode described above the first phase in bind configuration resolution is publisher configuration by the arrows labeled four and five . In general publisher configuration allows shared assembly vendors to make compatibility statements between different revisions of their software. These per assembly configuration files are wrapped as strongly named e.g. COM assemblies and are installed into the global assembly cache e.g. as part of a service pack style update. Because publisher configuration assemblies may affect all applications on the system these assemblies should be installed separately from application installations otherwise an application may break other applications simply through installation.

In one implementation a publisher configuration assembly has the same name as the assembly it affects but with a further extension appended to the name e.g. .config . This publisher configuration assembly has a module reference to an XML configuration file that stores the actual binding redirect information. Moreover because assembly metadata contains a hash for the XML configuration file it is possible to validate the integrity of the configuration file.

A publisher configuration assembly is created by authoring an XML configuration file which may have any name and using an assembly linker tool or the like to create the assembly. For example as set forth below a publisher configuration file version 1.0.0.0 for an assembly named test is created e.g. having an XML configuration file named

Publisher configuration assemblies normally will be obtained directly from the publisher as part of a service pack style update intended to affect all applications on the system. Because there is no direct link between the publisher configuration and the applications it affects version redirects specified by the publisher configuration file may contain a codebase to the targeted version in the configuration file otherwise the operating system will not necessarily be able to locate the intended files. Another option is to install the redirected version of the assembly on the machine. Similarly assemblies targeted by administrator configuration can either be installed into the global assembly cache advertised to the user or located through a codebase provided in the administrator configuration file.

In this first mode the second stage of configuration resolution after any publisher configuration is applied comprises resolving any application configuration. As represented in by circled numerals six and seven if an application configuration exists the binding initialization mechanism reads and interprets the application configuration . To this end before a bind to the assembly can proceed the application configuration file if any is accessed and analyzed. For example the configuration data may be maintained as an application configuration file and accessed via an application base appbase directory e.g. the folder or other suitable directory. A name value pair in the application context specifies the name of the configuration file.

For example in an .exe runtime scenario the file is named with the same name as the executable but with a .config extension appended thereto e.g. appname.exe.config . An application author and or deployer may choose to provide such a configuration file thereby specifying version redirects for particular assemblies. For example a configuration file may be written by an application author to specify that references to a common shared assembly whether directly provided by the application or indirectly from a dependent assembly s dependency should use a particular version. As another example once an application deployer is confident that the application works with a newer version of a shared assembly the deployer can choose to change the application configuration file to automatically use the new version instead of the version set forth in the application manifest. When interpreting the configuration if a relevant binding redirect statement is found in the application configuration file the version of the assembly from the original reference is modified accordingly.

Whenever a binding configuration statement is made in a configuration file it is the responsibility of the author of the configuration file to ensure that the assembly targeted by the redirect can be found. In the case of the application configuration file the application author deployer may choose to package the files e.g. binaries for the target assembly with the application or alternatively provide information sometimes referred to as a codebase in the configuration file to tell the operating system where the files can be found. Another option is to install the redirected version of the assembly on the machine. Note that for privatized assemblies e.g. in the second alternative mode by attempting to locate the referenced assembly by consistently looking in the application directory an application author may simply copy newer privatized assemblies into the application directory and know that the newer assemblies will be automatically used by the application.

As generally described above a second alternative mode is provided in which the order of applying configurations is different a safe mode is available for bypassing publisher configuration and an administrator configuration may be present and if so is interpreted to override other configuration binding data. More particularly in this second mode the first stage of policy resolution comprises resolving any application policy. As represented in by circled numerals four and five if an application policy exists a binding mechanism reads and interprets the application policy . To this end before a bind to the assembly can proceed the application policy file if any is accessed and analyzed. As described above if not bypassed via the safe mode any publisher configuration is next applied as generally represented in by the arrows labeled six and seven .

In this second mode a third stage in the bind configuration resolution process is administrator configuration represented in by the arrows labeled eight and nine . Administrator configuration is the strongest form of configuration as it makes the final determination as to which version will be bound and cannot be bypassed. To provide administrator configuration the administrator configuration file e.g. named machine.config has the same schema as the configuration files used in the two previous stages of configuration resolution. Administrator configuration affects assembly binds that occur to any application on the system.

Once the configurations have been handled for a given assembly to which an application wants to bind only one version of that assembly remains. This information may be cached in the activation context the arrow labeled eight in or ten in and may be persisted e.g. in the first alternative mode so that it need not be computed again unless and until a configuration change occurs. Note that in the second alternative mode the application context is not persisted although it is feasible to do so.

By way of example represents some of the information that may be maintained in an activation context e.g. an activation context constructed for the application . In the activation context includes a table of contents e.g. providing offsets to its recordsets for rapid access to the data therein.

For persisted activation contexts because the configurations that may change the dependency information may change over time e.g. publisher configurations may be wrapped as assemblies which can be versioned new application configurations may be downloaded and so on in the first alternative mode the activation context includes a cache coherency section . The cache coherency section is used to detect whether a saved activation context is valid wherein when the activation context is not coherent with current configuration it is recomputed. A section per API that implements version specific binding is maintained.

To map the application s requests to the proper assembly versions the activation context includes a DLL redirector section and an object class redirector section . The DLL redirector section includes a record or the like for each DLL dependency that includes fields e.g. and that relate the DLL name used by an application to the exact pathname of the version determined following the above described configuration resolution process. The object class redirector section includes a record or the like for each object class e.g. Windows object class on which an application depends wherein each record includes fields e.g. and that relate the object class name used by an application to the DLL file it is in and a version specific name. Note that the fields are arranged in a manner that optimizes lookup e.g. the application provided request data corresponds to the search key and the records may be arranged in any way e.g. alphabetically by frequency linearly binary or so on to speed searches.

Via the activation context during runtime as described below an application s requests for assemblies can be efficiently satisfied with the correct version of that assembly. If a given assembly is not found in the activation context data the default assembly is used. To summarize when an application first runs the activation context built from the manifest data is cached whereby the global version independent named objects requested by an application are mapped to version dependent named objects as specified in the manifest and redirected by any configurations. As the application executes and requests a named object via one of the activation APIs the version independent named objects are applied in a version specific fashion by accessing the application context whereby the application gets the correct version.

When the application API receive the request the request data e.g. the application provided name is passed to a runtime version matching mechanism the arrow labeled two . The runtime version matching mechanism locates the correct activation context from among a store or the like of those maintained for the calling application and accesses the records therein to determine the correct version of the requested assembly the arrows labeled three and four . Via the tables in the activation context the runtime version matching mechanism will either return e.g. as a return parameter with the arrow labeled five the path and filename of the version specific assembly or a not found status or the like and or the path and filename of the default file to the activation API that called it in which case the activation API will load the default assembly. As represented in by the arrows labeled six through eight the activation API accesses the assembly cache to load the correct version of the assembly. Note that alternatively the runtime version matching mechanism may access the assembly cache on behalf of the calling API to obtain and or load the correct version which is either the one listed in the records or the default version if none was found. Further note that privatized assemblies may be loaded from the application directory. In any event the correct assembly version is loaded and the activation API returns from the call to the application the arrow labeled nine and the application can use the loaded assembly the arrow labeled ten .

Turning to an explanation of the operation of the present invention with particular reference to the flow diagrams of and as described above the mapping of an application to a specified version of an assembly or other data structures essentially comprises two phases an initialization phase in the first alternative mode and a runtime phase . In general the initialization phase constructs the activation context if needed that maps version independent assemblies to version specific assemblies based on the dependencies and other instructions provided in the various manifests and configurations. Then during a runtime phase the activation context is accessed as needed to rapidly locate and load the appropriate versions when an application requests an assembly to which it needs to be bound.

When step determines that an application manifest exists the binding initialization mechanism preferably branches to step to create the activation tables. Alternatively if activation contexts may be preserved rather than recomputed each runtime the binding initialization mechanism may check for an existing activation context e.g. for the application. If an existing activation context is found step branches to step to validate it otherwise step branches to step . Step checks the activation context to determine if it is coherent with current configuration and if so the existing activation context can be used step and the initialization process ends. If alternatively the activation context is not coherent with current configuration at step for example because a more recent configuration has been provided to the system the initialization process continues to step to recompute a new activation context .

In the event that the initialization process continues to step to create the activation context step represents obtaining the binding information from the application manifest. Steps and of are executed along with the steps of essentially to walk through the application manifest configurations and any assembly manifests in order to build up a dependency graph including replacing assembly information e.g. maintained as nodes in the graph according to configurations in the dependency graph and adding any new nodes to include the dependencies of any assembly manifests.

By way of example operates once the application manifest has it dependent assemblies added to the dependency graph step of and a requested assembly version node therein has been selected step e.g. via a top down left to right or other suitable progression for processing.

At step a test is performed to determine whether the assembly has a publisher configuration associated therewith e.g. in the global assembly cache. If not step branches ahead to test for an application configuration at step described below. If a publisher configuration is found at step step branches to step wherein the publisher configuration is interpreted to determine whether there is an instruction therein for replacing the assembly version that is currently under evaluation i.e. the one currently selected in the dependency graph either as originally specified in the manifest. If a replacement instruction is found step branches to step wherein a dependency graph is altered to reflect the replacement otherwise step effectively bypasses step . By way of example shows a dependency graph in which a node representing an assembly such as the node N has been replaced by a node N. Note that a list or other data structure may be used instead of a dependency graph.

At step a test is performed to determine whether the application has an application configuration associated therewith e.g. in the application directory. If an application configuration is found at step step branches to step wherein the application configuration is interpreted to determine whether there is an instruction therein for replacing the assembly version that is currently under evaluation i.e. currently selected in the dependency graph by identification in the manifest or as overridden by the publisher policy. If such a relevant replacement instruction is found step branches to step wherein the dependency graph is altered to reflect the replacement.

At this time the appropriate assembly version is known as specified in the manifest and as altered via any configuration instructions as described above. Step enumerates any dependencies in the assembly manifest that corresponds to this appropriate assembly e.g. to add dependent nodes to the dependency graph. Note that if an assembly representation node is already in the graph for a given assembly a pointer from the node may be added to show the dependency rather than place a new node in the dependency graph. Step marks the current node representing the assembly as having been handled and the process returns to step of to select step and evaluate any other nodes in the graph that have not yet been handled until none remain. Once the dependency graph is complete at step the data in the dependency graph is used to construct the activation context e.g. essentially by filling in the tables fields with the correct version information for each assembly present in the graph. When constructed the activation context is copied to the child process in the operating system data structure s defined environment process making it the process default.

Note that to avoid problems each configuration resolution stage is only evaluated once. For example if a subsequent version redirect occurs as a result of any later configuration resolutions the previous stages are not re consulted to re apply configuration. Re applying configuration after other forms of configuration are applied may result in circular infinite configuration redirects and add unnecessary complexity to the binding process. Notwithstanding in an alternative implementation the process may for example loop back to handle a situation in which a replacement assembly may have another configuration associated therewith that can cause replacement of the currently selected assembly and so on. Note that other safeguards against an infinite loop may be implemented to prevent a situation wherein versions have circular dependencies.

Beginning at step the activation API receives the application request including the version independent assembly name not the version specific name and passes it as a parameter or the like to the runtime version matching mechanism where it is received at step . If an entry for the name is in the activation context at step the runtime version matching mechanism returns the version specific information e.g. including the path and filename of the correct version based on the manifest at step . If an entry for the name is not found in the activation context at step at step the runtime version matching mechanism returns a not found status or alternatively can determine and return the path and filename of the default version . At step the activation API loads the appropriate version and returns a loading status or the like. The operating system also maps any uses of this named object to the appropriate version to allow for multiple versions of the code module to run simultaneously without interfering with each other whereby for example COM object data is isolated per object. At this time the correct version as specified in the manifests is loaded even though the application s executable code did not specify any version. Indeed by providing an associated manifest that can be stored into the application s directory an already existing application e.g. written and installed before the present invention can benefit from the present invention. In this manner the application runs with a controlled set of assemblies bound thereto.

Turning to the second alternative mode represent example steps that may be taken such as dynamically during runtime to determine which version of an assembly to bind. To this end the binding mechanism of e.g. of the operating system may check for an application manifest in same file system directory as the calling executable as represented in by step . If an application manifest does not exist the binding mechanism handles its absence in another manner step e.g. the operating system essentially will give the application default versions during runtime such as by first loading any requested component or assembly from the application s own directory when one is present and otherwise using the default assemblies from the assembly cache.

When step determines that an application manifest exists it is interpreted as represented by step . Then in this second mode step tests whether an application configuration exists for this application e.g. in the application directory. If not step branches ahead to to test for whether a publisher configuration applies as described below. If an application configuration is found at step step branches to step wherein the application configuration is interpreted to determine whether there is an instruction therein for replacing the assembly version that is currently under evaluation. If such a relevant replacement instruction is found step branches to step wherein the current assembly binding information is replaced.

If the safe mode is not specified at step step branches to step to test for a publisher configuration. If a publisher configuration is found at step step branches to step wherein the publisher configuration is interpreted to determine whether there is an instruction therein for replacing the assembly version that is currently under evaluation either as originally specified in the manifest or as replaced by application configuration as described above with respect to step . If a replacement instruction is found at step step branches to step wherein the replacement is made otherwise step effectively bypasses step .

The process continues to step which represents the start of the second mode s third phase of the configuration resolution process wherein a test is performed to determine whether the system has an administrator configuration e.g. in the system directory. If not step is executed as described below. If so step branches to step wherein the administrator configuration is interpreted to determine whether there is an instruction therein for replacing the current assembly version with another version. If a replacement instruction is found step branches to step wherein the replacement is made otherwise there is nothing to replace and step bypasses any replacement. In any event the process continues to step .

At this time the appropriate assembly version is known as specified in the manifest and as altered via any configuration instructions as described above. Step enumerates any dependencies in the assembly manifest that corresponds to this appropriate assembly for handling in a similar manner. These and other identified assemblies may be handled in a similar manner so that the correct versions as specified in the configurations are bound to the application.

As can be seen from the foregoing detailed description there is provided a method system and infrastructure to version globally named objects in the system. Application authors may create safe isolated applications by simply creating a declarative manifest that describes dependencies on these shared objects without needing to be concerned with coding the application to adjust to the version of the assembly being used. By the present invention assemblies can be safely shared and applications can be more completely isolated.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

