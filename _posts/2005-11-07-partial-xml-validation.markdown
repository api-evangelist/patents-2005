---

title: Partial XML validation
abstract: Modifying a portion of an XML document stored in a relational database includes converting operations on the document into an operator tree. The operator tree includes a first operator corresponding to a first portion of the schema for the modified data and a second operator corresponding to a parent portion of the schema for the modified data. A first and a second portion of the schema are extracted from the overall document schema. A first validation of the modified data using the first operator with the first portion of the schema is performed. This forms a partially validated XML document portion. Next, a second validation of the partially validated XML document portion with the second portion of the schema is performed using the second operator. The XML document constraints are verified and the modified data is merged into the XML document, thus avoiding a full validation of the XML document when certain XML Schema types are absent in the modified data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774321&OS=07774321&RS=07774321
owner: Microsoft Corporation
number: 07774321
owner_city: Redmond
owner_country: US
publication_date: 20051107
---
This application contains subject matter in common with the following co owned patent applications which are hereby incorporated by reference in their entirety U.S. Patent Publication No. 2006 0085489 corresponding to U.S. patent application Ser. No. 11 185 310 filed on Jul. 20 2005 entitled Memory Cache Management in XML Relational Data and U.S. Patent Publication No. 2005 0210002 corresponding to U.S. patent application Ser. No. 10 803 283 filed on Mar. 18 2004 entitled System And Method For Compiling An Extensible Markup Language Based Query.

The XML eXtended Markup Language provides a standard way of tagging data so that the data can be read and interpreted in a variety of ways such as by Web browsers. XML documents are used extensively in daily transactions. An XML Schema is a W3C World Wide Web Consortium standard that defines a schema definition language for an XML data model. Schema definitions can be used to validate the content and the structure of XML instance documents.

Normally an XML Schema is used to define the data format used in an XML document. If an XML document is to be updated the updated information must conform to the constraints placed on the document by the associated schema. The XML Schema document is an XML document that is expressed in a different way than the tables and columns of a relational database system. The type information supplied in an XML Schema document can also be used to check XML queries for correctness and optimize XML queries and XML storage. Thus verification that the data to be placed into the XML document meets the schema constrains is an important consideration. In some instances XML documents can be large. An example could be a customer list where a large number of customers are listed along with their customer numbers and one or more addresses and other relevant customer information. This information may be useful to transfer from one location to another via an XML format but it is also useful to edit or use the information via a relational database. The XML data stored in the relational database may be stored as a binary large object BLOB . Thus if updates to the customer list were needed then the structure of the stored data in the relational database storage must also match the schema.

Having the capability to store XML Schema documents in relational structures has at least the following advantages. The type definitions can be searched efficiently using relational index structures instead of parsing the XML Schema documents. Appropriate pieces of the XML schema documents e.g. CustomerType definition can be selectively loaded into memory buffers for validations of XML instances which provide a significant performance improvement. And SQL Structured Query Language views can be provided on the relational storage for relational users to know about stored XML Schema documents. But the techniques for manipulating data between SQL and XML are limited and some exact a heavy toll on SQL performance because of the verification of the entire XML document when an update to only a portion of the document is being made.

Modifying only a portion of an XML document stored in a relational database usually incurs the cost of an entire XML document validation. The present invention provides a technique to perform only a partial validation. The partial validation is performed on the data to be modified in the XML document and not the entire document. The method includes converting the document validation into an operator tree. The operator tree includes a first operator corresponding to a first portion for the validation of the modified data according to the XML schema and a second operator corresponding to the validation of the parent portion of the modified data according to the XML schema. A first and a second portion of the schema are extracted from the overall document schema. A first validation a deep validation of the modified data using the first operator with the first portion of the schema is performed. Next a second validation a shallow validation of the results of the first validation with the second portion of the schema is performed using the second operator. The XML document constraints are verified and the modified data is merged into the XML document thus avoiding a full validation of the XML document.

In one aspect of the invention a method is disclosed that provides an improved caching of metadata tables for translation of XML Schema data into a relational database structure. In one SQL implementation when a typed XML Column is modified via the modify method there is validation taking place to ensure the conformity of the new value. This validation is part of the query execution and therefore it is vital that its effect on performance is minimal. Traditionally applications that allow modification of a typed XML document will validate the whole document at the end of the DML Data Modification Language operation. In some SQL based machines this can result in a dramatic performance hit since an XML document can be very large up to 2 GB . To mitigate the performance degradation an algorithm and an operator can be used that will ensure at query execution time an XML data validation examines the absolutely minimal XML sub tree and still maintain the integrity of the XML document as a whole.

The format of this data may conform to a schema defining the data types used in the list. There are constraints used in the schema to define each field of data within the XML data content. If an additional address were to be added the additional address data must also conform to the schema defining the data of the XML format. An added address for example a shipping address entry may be represented in XML as follows 

The above example XML is for a customer identifier CID of . But there could be thousands of such entries. If placed in a relational database the re validation required for just one address entry may force the re validation of all entries of all customers in the database. An advantage would be to avoid re validating all multiple thousands of elements. In general it should be enough to make sure that the particular added new shipping address element is valid by ensuring that the schema allows the addition of a shipping address element in its content and that this shipping address element is of the correct structure.

In order to ensure the condition above it is sufficient in this example to look at the siblings of the shippingAddress element and its parent the customer element . If the query execution machinery can flow only the records representing the parent of the inserted element and its siblings without their content and the validation operator is knowledgeable of what is being validated then one approach is to execute the minimal number of operations that will ensure the validity of the whole document without re validating the whole document. In this particular scenario during query execution the validation operator will process couple of tens of rows and not the potentially thousands of rows if it had to validate the whole document.

In one embodiment of the invention XML query processing may involve storing the XML data in its own format as a BLOB Binary Large Object in a relational database as shown in . The XML data may be placed into relational form by either an on demand shredding of the data into a rowset of a pre defined shape or by accessing an XML Index which is already a rowset of pre shredded XML data. depicts a table having two columns a primary key column and a data column . In this example the BLOB data represented in the data column for customer ID contains only a billing address at . The data column BLOB for customer ID however contains both a billing and a shipping address at . If additional information for customer ID is desired such as new shipping address data the BLOB will have to be updated but the XML document will also have to be updated in conformance with its schema. Ordinarily this would involve a verification of the XML data for the entire document. But this is not desirable when the document is very large. In one aspect of the invention a full document validation may be avoided if only a portion of the relevant XML schema is used.

Referring to in a query sub tree with partial validation new data i.e. a new XML entity to be entered such as a shipping address of customer ID is acquired and a validation request is made . The data to be validated and the insertion node information are necessary to perform a deep validation operation . Deep validation is a recursive operation that will validate the complete logical XML Entity . In the example the deep validation uses information from selected schema constraints applicable to the tag of applies them to the specific data of the new XML entity and validates that the deep constraints of the schema are met by the new XML data. An insert operator may then be used to pre insert the new information into a form which may be used by the relational database.

A shallow validation operation requires both the insertion node information as well as parent node of the new XML entity and schema information . Here the minimal XML data needed for validating the content of the sub tree being modified is used. To obtain this limited schema information the extraction of the relevant schema information is needed. This extraction is further explained below. But in brief the query engine will fetch only the rows representing the parent of the elements being inserted or deleted and its siblings and will flow it through the request for shallow validation . The query execution machinery of an XML processor is augmented with XML specific operators. Deep validation is done by a special purpose validator. In one embodiment this validator may be composed of a single state machine which will not recurse into complex content and will ignore all simple data types. Once deep validation is performed at the output of and a shallow validation is performed at the output of then the new data may be merged with the existing data . A validation operator can perform XML validation on relational input representing the XML data. Executing the deep validation ensures the validity of the new data. Shallow validation of the parent of the new data guarantees that the integrity of the document is maintained. Once both are complete then a partial validation is performed. Partial validation allows the entry of new data without performing a full document validation which can be time intensive.

Partial XML validation works for most of the XML Schema constructs. But some XML Schema constraints such as ID IDREF and key keyref have the entire XML instance as their scope. As such validation of the modified data or its parent portion is inadequate. The occurrence of these XML Schema constraints in the modified data may cause the entire XML document to be validated. For example ID is an XML Schema feature that allows associating an identifier with an element using an xs ID type attribute or element. IDREF is a reference to one such ID. In one aspect of the invention ID is unique within a single XML instance or document or BLOB . Thus if were to contain an ID attribute the ID value is maintained to be unique within the XML instance. Similarly if were to specify an IDREF then the schema validation must ensure that the target ID of the IDREF exists in the same XML instance. IDREFS is a sequence of IDREF.Neither IDREF nor IDREFS should contain dangling references that is refer to non existent target ID . Key defines key values and keyref defines references to the key values. These require ensuring that the key value is unique within an XML instance and the keyref refers to an existing key value. Similarly a unique constraint can be defined for values that should be unique within an XML instance. All these require uniqueness checks within the new XML entity and the existence of the referenced nodes or values.

One aspect of the invention is the use of a procedure to extract the portion of the schema which is needed for partial validation. Co owned U.S. patent application Ser. No. 11 185 310 corresponding to U.S. Patent Publication No. 2006 0085489 filed on Jul. 20 2005 entitled Memory Cache Management in XML Relational Data teaches a method of extracting a relevant portion of schema and is incorporated herein in its entirety. The relevant portions of the schema are stored in a cache.

Specifically the XML input schema for the XML document is shredded into many relational tables and only the most frequently used pieces of schema can be selectively loaded and cached. Furthermore since the relational layout includes several primary and secondary indexes the loading of schemas will also be fast. Because XML schemas are shredded into tables XML instance validation loads only the necessary components to perform validation. During validation only parts of the schema that are used are loaded and cached. The schema cache stores the in memory representation of XML schema optimized for XML instance validation. XML schema components are loaded from metadata into main memory as read only objects such that multiple users can use the in memory objects for validation. If the XML schema is changed during the operation the schema cache entries are invalidated.

Once the required schemas are located in relational tables the parts relevant to Type Attribute or Element definition will be added to the XSD type cache. In implementation a reverse mechanism from the schema import is used first a symbol table is created and then validation structures are derived that are cached.

Because XML schemas are shredded into tables XML instance validation loads only the necessary components to perform validation. During validation only parts of the schema that are used are loaded and cached. The Schema Cache stores the in memory representation of XML schema optimized for XML instance validation. XML schema components are loaded from metadata into main memory as read only objects such that multiple users can use the in memory objects for validation. If the XML schema is changed during the operation the schema cache entries are invalidated.

During the final phase of persisting data the novel code populates metadata tables that describe the structure of the XML Schema types. illustrates a system of tables into which XML schema data is shredded. In one implementation the XML schema data is persisted as metadata in several tables a component table a reference table a placement table a facet table and a qualified name table . An ID component interfaces to the XML Schema data in order to assign an identifier e.g. a component ID to each component thereof. A cache memory interfaces to each of the tables and such that the contents of any single table or combination of tables can be accessed and persisted therein to provide improved data access with a relational database .

Accordingly illustrates a methodology of processing XML Schema data into tables. At step the XML Schema data is decomposed into related XML Schema components with assigned IDs. At step the XML schema is persisted as metadata in the tables. At step the validation process loads and caches only necessary schema components that are to be used. At step the tables are populated with data that describes the structure of the XML schema types.

In one aspect of the invention nodes are identified in an XML document. The identification of nodes enables the translation of queries and data modifications on an XML document into an operator tree and the subsequent insertion of node specific information in the process of deep and shallow validation. Co owned U.S. patent application Ser. No. 10 803 283 corresponding to U.S. Patent Publication No. 2005 01210002 filed on Mar. 18 2004 entitled System And Method For Compiling An Extensible Markup Language Based Query teaches a method of converting queries and data modifications on XML data into an operator tree for execution by a query processor and is incorporated by reference herein in its entirety.

One aspect of the invention includes the translation of an XML document into a tree structure. Such a structure is shown in . Translation of an XML structure into a tree will be further discussed below. The tree structure mirrors that of an XML document where tags data and constraints are reflected in the node structure. In the structure parent and sibling nodes are shown at and deep validation nodes are shown at . The topmost node has a subnode that is parent node for nodes and . Node is a parent node for nodes and . Node is a parent node for nodes and . Node is a parent for nodes and and node is parent for nodes and . In an aspect of the invention if node is not present in the tree structure but it is desirable to add it in then the structure and constraints of an XML schema which defines the XML document must be observed. A node structure can be generated for an XML document when the XML document is compiled.

In brief the method for compiling an XML based query includes receiving an XML expression by a database engine front end. The query is parsed by a relational query parser and embedded XML expressions are forwarded to an XML parser. The XML expression is parsed by the XML parser to yield an abstract syntax tree. The abstract syntax tree is then forwarded to an XML operation generator which transforms the abstract syntax tree into a unified tree including XML algebra operations. The unified tree is then forwarded to an XML algebrizer which converts the unified tree into a relational tree including enhanced relational algebra operations. The relational tree is grafted into a log op tree being produced for the enclosed relational query. The log op tree results in a query plan that is forwarded to a query processor for optimization and execution of the query at the query processor.

Referring now to query including XML expression may be received and manipulated by front end to generate a query plan for executing query . In addition to parsing query to yield a relational abstract syntax tree relational parser passes XML expression from query to XML parser . XML parser then parses XML expression to generate an XML abstract syntax tree

XML Algebrizer converts the XML operations within unified tree structure into a relational log op tree that includes enhanced relational operations. XML Algebrizer recursively traverses unified tree . For each node of unified tree a corresponding relational sub tree is generated via and . Each such relational sub tree includes a number of enhanced relational algebra operations required to perform the XML algebra operation in its associated unified tree node. The relational sub trees via are then inserted into relational tree . XML operation generator transforms the XML abstract syntax tree into an XML unified tree structure including XML algebra operations.

XML Algebrizer converts the XML operations within unified tree structure into a relational log op tree . Conventional relational algebra operations are inadequate to describe XML operations which access hierarchical data. Accordingly XML algebrization in accordance with the present invention converts XML operations into enhanced relational algebra operations. The relational log op tree may then become the basis for a query plan .

Either previously or as part of the method the XML document is converted to an operator tree structure step . The conversion of an operator tree structure involves parsing the XML document into an abstract syntax tree transforming the abstract syntax tree into a unified tree and converting the unified tree into the operator tree structure.

The modified XML data can be validated only by comparing the data and its attributes sometimes stored in metadata to the specific portion of the schema associated with the desired location in the XML document. Thus a first portion of the XML schema is extracted step . This first portion is associated with the data to be modified. A deep validation may be performed step . A deep validation is a validation of the inserted data. The deep validation checks the modified part against the format and constraints of the first portion of the XML data. A deep validation involves recursively validating a complete logical entity of the modified data. Thus the deep validation may take the modified data entity by entity e.g. word by word or number by number and validate the data against the extracted first portion of the XML schema. Once the deep validation is completed a partial validation is complete. The partial validation being a validation of only the modified data against the first portion of the XML schema.

But parent constraints may also place limitations on the validity of the data to be modified. These parent constraints are embodied in the parent portion of XML schema which is associated with the first portion of the XML schema. Thus a second portion of the XML schema is extracted step . This second portion is the parent portion of the XML schema. Extracting a portion of an XML document schema involves decomposing the XML schema into tables of schema components and storing the tables in a cache. The tables may be stored in a relational format.

A shallow validation is performed step . A shallow validation completes the validation process by comparing the partial validation results against the second portion of the schema. The second portion of the schema represents the parent data constraints the schema places on the modified data. Although the partial validation results may indicate that the modified data format and content are correct for the first portion of the schema deep validation the shallow validation checks that the modification comports with the higher level constraints of the second parent schema information. For example the shallow validation can confirm that the parent schema information allows the number of occurrences type and format of the modified data.

If the shallow validation does not comport with the parent schema constraints step then the method terminates as rejecting the modified data. If the modified data does comport with the first and second extracted XML schemas then the modified part of the document may be merged into the full XML document step . Note that this merger may be the modification of the XML data that is stored in relational format. In an alternate embodiment extracting the second portion of the XML Schema step may be combined with extracting the first portion of the XML schema step if a priori knowledge of the identity of the second potion of the XML schema is known at step .

In some instances the method may complete at step . In other instances such as where there is an instance of ID IDREF or key keyref a wider validation may be needed step . If there is no additional reference in the modified part then the process stops. If there are additional constraints on the modified part then a document wide validation for special XSD components is performed step .

Although not required embodiments of the invention can also be implemented via an operating system for use by a developer of services for a device or object and or included within application software. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs appliances lights environmental control elements minicomputers mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.

With reference to an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the form of a computer system . Components of computer system may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer system typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to Random Access Memory RAM Read Only Memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disk Read Only Memory CDROM compact disc rewritable CDRW digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer system such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer system may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM CDRW DVD or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer system . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer system through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory not shown . In addition to monitor computer systems may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer system may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer system although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer system is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer system typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web enabled interface for applications and computing devices making computing activities increasingly Web browser or network oriented.

For example MICROSOFT s .NET platform available from Microsoft Corporation includes servers building block services such as Web based data storage and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device one or more portions of an embodiment of the invention may also be implemented via an operating system application programming interface API or a middle man object between any of a coprocessor a display device and a requesting object such that operation may be performed by supported in or accessed via all of .NET s languages and services and in other distributed computing frameworks as well.

As mentioned above while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any computing device or system in which it is desirable to implement an XML partial validation scheme. Thus the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same similar or equivalent systems and methods achieved by embodiments of the invention.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention.

While aspects of the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the claimed invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

