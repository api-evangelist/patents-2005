---

title: Kernel validation layer
abstract: Systems and method of computer security are provided. In one implementation, a method is provided. The method includes monitoring incoming kernel mode calls and identifying a kernel mode call to verify using a predetermined criterion. The method also includes validating the identified kernel mode call, and processing the kernel mode call in accordance with the results of the validation of the kernel mode call. In another implementation a kernel application programming interface validation device is provided. The kernel application programming interface validation device includes a monitoring engine for monitoring incoming kernel mode calls, an analysis engine operable to examiner kernel mode calls, a validation engine operable to determine if a kernel mode call is valid using the results of the analysis engine, and a processing engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07587724&OS=07587724&RS=07587724
owner: Symantec Corporation
number: 07587724
owner_city: Mountain View
owner_country: US
publication_date: 20050713
---
Conventional computing systems include a user mode for providing user interaction with the computing system. The computing system can include a number of applications that can be interacted with by a user using for example a user interface. The user can direct the application to perform various functions. For example a user selection of a particular function in an application can result in a system call to an application programming interface API associated with the application in order to initiate a process for executing the selected function. The functions can be performed in a user portion user mode or can require access to a kernel portion kernel mode a more secure level of the computing system that includes the core operating system. A function running in the kernel mode can execute all instructions and have access to all the system resources including physical memory input output ports and other physical resources. In contrast a function running in the user mode can access a smaller subset of instructions and a virtual memory that belongs to the user space. For example functions such as opening a file or saving a file to memory require access to the computing system hardware e.g. a hard disk drive or other memory device which is only accessible through the kernel mode. Thus for example an open file call typically progresses from a user mode API to a kernel mode API. The kernel mode API then provides secure access to the device allowing for example access to physical memory address locations for opening a file.

Typically application programmers do not have access to the source code of a user mode API. However programmers can design programs to extend the functionality of the user mode API using for example known hooks associated with the API. Conventionally the applications are installed using an API interception or API hooking technique. Calls to or from the user mode API can be intercepted by an API interception application and additional functions performed prior to returning the call to the intended destination path. For example a third party application such as a security system can install an API hook to intercept particular system calls from applications in order to determine whether or not the process has been affected by malicious software commonly referred to as malware including spyware Trojans viruses and other harmful code. The security system can then allow the call to continue e.g. to the kernel mode if the call passes one or more security checks. Intercepted calls which fail the security check s can be terminated.

Malicious software can be designed to circumvent security systems based on API hooking. For example the malicious software can be designed to bypass the hook of the security system by calling the kernel API directly using an interrupt call or by inserting a jump command into the call thread prior to the hook in order to bypass the security system API hook.

In general in one aspect a method is provided. The method includes monitoring incoming kernel mode calls and identifying a kernel mode call to verify using a predetermined criterion. The method also includes validating the identified kernel mode call and processing the kernel mode call in accordance with the results of the validation of the kernel mode call.

Advantageous implementations can include one or more of the following features. The method can further include analyzing the identified kernel mode call. The analyzing can further include examining the kernel mode call to identify previous steps in the kernel mode call thread. The examination of the kernel mode call can identify a prior interception of the kernel mode call. The analyzing can further include searching the kernel mode call thread for one or more security features and validating the kernel mode call if the security features are found identifying a source library of the kernel mode call and comparing the identified source library with one or more allowed source libraries. The kernel mode call can be invalidated if the source library is not an allowed source library.

The processing can further include transmitting the kernel mode call to a kernel mode application programming interface if the kernel mode call is validated and otherwise processing a non validated kernel mode call. The otherwise processing can include terminating the kernel mode call generating an alert and logging the non validated kernel mode call. The verifying can further include matching a security feature in the kernel mode call with a reference security feature and validating the kernel mode call if the security feature matches the reference security feature. The monitoring incoming kernel mode calls can further include monitoring for particular types of kernel mode calls and intercepting all incoming kernel mode calls.

In general in one aspect an apparatus is provided. The apparatus includes a kernel application programming interface validation device. The kernel application programming interface validation device includes a monitoring engine for monitoring incoming kernel mode calls an analysis engine operable to examine kernel mode calls a validation engine operable to determine if a kernel mode call is valid using the results of the analysis engine and a processing engine.

In general in one aspect a computer system is provided. The computer system includes a user portion and a kernel portion. The user portion includes one or more user applications a user mode application programming interface and one or more user mode application programming interface interception applications. The kernel portion includes a kernel mode application programming interface and a kernel application programming interface validation device. The kernel application programming interface validation device is operable to monitor incoming kernel mode calls to the kernel mode from the user mode application programming interface analyze and validate the kernel mode calls and process the kernel mode calls.

In general in one aspect a computer program product is provided. The computer program product includes instructions to monitor incoming kernel mode calls identify a kernel mode call to verify analyze the identified kernel mode call validate the identified kernel mode call according to the analysis and process the kernel mode call according the validation of the kernel mode calls.

The invention can be implemented to realize one or more of the following advantages. Kernel mode calls can be monitored and analyzed in order to protect against malicious software. A kernel validation layer can be installed to intercept all incoming system calls from the user mode to the kernel mode. The kernel validation layer can monitor all system calls or particular system calls targeting a kernel mode API. System calls can be analyzed to validate the authenticity and integrity of the call. The kernel validation layer can validate the incoming call by verifying that the call had been intercepted by a security system. Thus calls which have been redirected to bypass an API interception for security purposes can be blocked at the kernel validation layer. Additionally the kernel validation layer can also validate an incoming call by examining a source library of the call as well as the stack history of the call thread.

The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features and advantages of the invention will become apparent from the description the drawings and the claims.

The user mode includes user applications and a user mode API and one or more user mode API interception applications . The user applications can include applications accessible by a user for performing different functions on the computing system. For example the user applications can include word processing database management email applications and any other user managed applications. The user applications can provide different functionality in response to user input. For example in a word processing application a user can open a file create a new file and save a file in response to user input.

To provide the requested functions the user applications can generate one or more different system calls which can be transmitted to the user mode API . Some examples of system calls include calls to open a file create a process load a library terminate a process open a registry key and perform other functions. For example the user of a word processing program can request the user application to provide e.g. open a particular saved file. The user application can transmit an open file call to the user mode API in response to the user request.

The user mode API is an interface through which the user applications can access the operating system and other kernel mode resources of the computing system . In one implementation the user mode API includes a number of different libraries e.g. .dll files which can be used to initially process a call received from a particular user application e.g. an open file call . In another implementation some of the calls to the user mode API can be completed in user mode without resources from the kernel mode . For example some functions can access information within the user mode such as a get current process function that retrieves an identifier of a calling process without accessing the kernel mode .

Other calls to the user mode API may require other e.g. kernel resources in order to provide the user requested function. In one implementation the user mode API is not allowed to directly access the kernel of the operating system. An interrupt can be associated with the user mode API and used to access higher security process levels. Thus in one implementation the user mode API can act as a gateway to the kernel mode API allowing the functionality of the kernel mode to be isolated from the user mode such that all calls to the kernel mode require an interrupt triggered by the user mode API .

For example when a user application sends a Create File call to the user mode API the call initially points to one or more libraries where the user mode API can perform some initial processing associated with the create file request. In one implementation because the create file call requires one or more system resources e.g. kernel mode resources an interrupt can be generated. The interrupt can include instructions e.g. a system call such as SYSCALL to access a privileged kernel function. Thus the interrupt allows the call to transfer from the user mode API to the kernel mode . After switching into the kernel mode the accessed kernel function can look up the correct pointer e.g. using a service table and call a corresponding function associated with the kernel mode API for executing the create process call. The kernel mode call can then perform the work to create a new file.

User Mode API interception applications can include one or more different interception applications used to provide additional functionality to the computing system . For example API interception applications can include functionality to provide operating system lockdown behavior analysis data encryption access cataloging profiling and other services. In one implementation the API interception applications can monitor calls into or from the user mode API . In one implementation the API interception application intercepts system calls leaving the user mode API . The API interception application can then intercept all user mode call threads directed to the kernel mode API .

In one implementation the API interception applications can each inject a hook to monitor for and redirect one or more particular calls which the hook is monitoring for. For example the hook may intercept particular types of calls while allowing other calls to pass. If a hook for a particular API interception application identifies a call which the hook is monitoring for the hook can cause the call to be redirected to the API interception application . The API interception application can then perform one or more functions on the call prior to returning the call back to the call s original destination path.

More specifically in one implementation the hook can be injected into machine instructions for one or more particular types of calls. The hook can then modify the machine instructions associated with that call type. When a hooked call is being processed by the machine instructions the hook modified instructions are executed in place of the original instructions. In one implementation the hook inserts a jump command that points to the API interception application . The jump command is a pointer that redirects the call to the API interception application . The API interception application can include instructions corresponding to one or more functions to be performed. For example in one implementation the API interception application is part of a security system. The security system can monitor one or more specific types of calls for malicious software such as spyware viruses Trojans or other malicious code which can harm the computing system . The security system can examine intercepted calls to prevent the malicious software from being transported into the kernel layer using the call command.

In one implementation the call can be initiated by malicious software. For example malicious software installed on the computing system can generate calls which mimic legitimate calls to the kernel mode API in order to infiltrate the secure kernel mode . In another implementation the malicious software could be the result of an interception by malicious software of a legitimate call directed to the kernel mode API . For example the malicious software can be used to generate an API interception application not shown that hooks into one or more calls prior to the hook of security system API interception application . The call can then be redirected to the malicious software application where the malicious software can perform one or more functions on the call causing the call to perform functions for the malicious software upon entering the kernel mode .

Upon interception of the call by the API interception application an analysis of the call by an analysis routine not shown of the API interception application can include analyzing the history call thread. The call thread can be examined to identify the past steps or functions performed since the origin of the call as well as the source of the call. The API interception application can use the analysis routine to identify any tampering or illegitimate sources associated with the call thread such as a suspicious source or interception of the call. In one implementation if malicious software or the effects of malicious software is detected by the analysis routine the call can be terminated. Alternatively the malicious software can be removed from the call thread by a cleaning routine not shown in order to allow a clean legitimate call to proceed. Furthermore discovery of the malicious software can trigger an action to identify and remove the source of the malicious software by the cleaning routine.

In one implementation if there are no threats identified in the call process by the analysis routine or if an identified threat has been removed by the cleaning routine the API interception application can insert a security feature such as a digital stamp or signature using a securing routine not shown . The security feature indicates that the call has been examined and has cleared the API interception application . The digital stamp or signature can be encrypted or otherwise protected from tampering. In another implementation a cookie can be inserted into the call indicating that the call has cleared the API interception application .

Finally an additional jump command or other pointer can be used by the user mode API interception application to redirect the call back to the process flow of machine instructions. In one implementation a jump command following the processes of the API interception application returns the call process back to the instruction list at a point below the first jump command that sent the call process to the API interception application . In one implementation the jump command points the call to the interrupt for transferring the call to the kernel mode API .

The kernel mode includes a kernel API validation layer a kernel mode API a hardware abstraction layer and hardware devices . The hardware devices can include the physical devices for operating the computer system . The hardware devices can include storage devices such as memory processing devices and other input output devices. In one implementation the kernel API validation layer can be provided as a kernel API validation device . The kernel API validation device can be a hardware device installed on the computing system to perform the same functions as the kernel API validation layer .

The hardware abstraction layer allows different software to be device independent by abstracting information from systems such as caches I O buses and interrupts and using hardware data to provide applications a way to interact with the specific requirements of the hardware devices on which the application or portion thereof is running interacting etc. In one implementation the hardware abstraction layer includes drivers that can be used to control the hardware devices by providing access to registers of hardware devices.

The kernel mode API is a part of the operating system of the computing system operating in kernel mode . In one implementation the kernel mode API is a secure API capable of accessing different kernel resources for example kernel objects such as mutex semaphore or the file system. The kernel mode API is accessed through an interrupt generated from the user mode API . The interrupt transfers control to a set of privilege instructions providing access to the kernel mode . An interrupt providing access to the kernel mode can include a system call instruction a trap gate an interrupt gate and a call gate. In one implementation the user mode API calls into the kernel mode API by identifying a kernel mode call corresponding to the received user mode API call.

The kernel API validation layer lies in the kernel mode between the user mode API and the kernel mode API . In one implementation the kernel API validation layer intercepts each incoming call from the user mode into the kernel mode API . The kernel API validation layer can intercept each call into the kernel mode API in order to verify that the calls are legitimate.

In one implementation the kernel API validation layer can be inserted into the secure process using for example a shim driver. A shim is a piece of code placed between layers or groups of hierarchical functions. Thus the shim driver provides for the kernel API validation layer between the layers of the user mode API and the kernel mode API . When a particular call transitions from the user mode to the kernel mode a kernel mode dispatch function calls the native kernel API function from a service table containing all kernel API addresses. The corresponding call is then placed into the kernel mode API in order to perform the desired function. In one implementation the shim driver can be used to replace the original service table function pointers with one or more function pointers. As a result the driver shim functions are called first from the service table. In one implementation the replaced service table function pointers can point to the kernel API validation layer for performing validation functions. In an alternative implementation the kernel API validation layer can be inserted into the kernel mode using different techniques. For example the system call dispatch function can be hooked or the software interrupt call can be hooked. Regardless of the insertion technique the kernel API validation layer can monitor intercept and process some or all of the incoming kernel mode calls.

The analysis engine examines calls which have been identified by the monitoring engine . The analysis engine can examine the call to identify the previous operations performed from the point at which the call was first initiated. For example the analysis engine can perform a stack backtracking to identify previous steps in the call history. If a step in the call thread is suspect further analysis can be performed or the call can be terminated. In one implementation the analysis engine can also examine the origin of the call to the kernel mode API . Kernel mode calls can only be legitimately performed through particular operating system libraries. The analysis engine can also examine the call to identify any security features placed in the call for example by a user mode API interception application that performs security functions. Upon identifying a security feature the analysis engine can examine the security feature to determine whether or not the security feature is recognized as authentic.

In another implementation the analysis engine can analyze the call for an indication that the call has been previously analyzed by a user mode security system. For example the analysis engine can examine the call for a security feature such as a stamp or signature indicating that the call cleared a security analysis performed by a user mode API interception application . In one implementation the stamp signature or other security feature placed within the call can be encrypted or otherwise secured against tampering.

The validation engine can validate or invalidate the call according to the analysis of the analysis engine . In one implementation if the analysis engine determines that a step in the call thread is suspect the call can be invalidated by the validation engine . Additionally if the analysis of the call determines that the call did not originate from one of the allowed libraries the call can be invalidated by the validation engine . Furthermore the validation engine can validate the call based on an identified security stamp or other feature placed into the call. For example the user mode API interception application can compare a security stamp or signature with one or more stored security features to determine the validity of the stamp or signature. In one implementation if the call has been validated by the user mode API interception application then the validation engine can also validate the call. In one implementation if a security feature is not found in the call thread malicious software may have caused the call to bypass the security system.

The processing engine can operate on the call according to the results of the analysis and validation engine . In one implementation if the call is validated the call can proceed to the kernel mode API as originally directed. In another implementation if the call is not validated the call can be denied and or otherwise processed. Otherwise processing can include logging the invalidated call or alerting a security system. In one implementation the call process can be terminated or otherwise blocked from proceeding.

The monitoring engine can monitor the incoming kernel mode calls to determine whether or not a particular incoming call requires validation step . In one implementation if a particular call does not require verification the call is allowed to proceed e.g. to the kernel mode API step . In another implementation all incoming kernel mode calls require validation.

If a call requires validation the kernel mode call is first analyzed by an analysis engine e.g. analysis engine step . In one implementation the analysis performed by the analysis engine includes examining the thread history of the call using stack backtracking. The past operations in thread of the call can be examined e.g. by analysis engine to identify any actions indicating that an unauthorized interception has taken place. The analysis engine can also examine the threat history of the call to determine whether or not the call was properly intercepted by a security system e.g. by a user mode API interception application functioning as part of a security system .

In another implementation the analysis engine can examine the origin of the call. The analysis engine can determine whether or not the call originated from one or more allowed libraries. In one implementation only particular allowed libraries in the user mode API are allowed to directly call into the kernel mode API. Additionally the analysis engine can examine the call thread for one or more security features installed by a security device such as a user mode API interception application.

Following the analysis the call can be validated or invalidated e.g. by validation engine step . If the call is validated the call is allowed to proceed to the kernel mode API step . The validation process can include determining if the call originated from a legitimate library. Validation can also include determining whether the call thread history indicates tampering or other indications that the call has been tampered with. Additionally the validation process can include verifying the authenticity of one or more security features located in the call thread.

In one implementation the validation engine can verify the encoding of a security feature or match the security feature to a stored security feature. In one implementation a security feature is required such that if no security feature is found by the analysis engine or if the security feature can not be verified the validation process fails. For example a kernel API validation layer can be designed to work with one or more user mode security systems. Consequently the API validation layer can be designed to identify particular security features in the call thread indicating that the call has been processed by the security system.

If the call is not validated the call can be otherwise processed e.g. by processing engine step . Otherwise processing can include terminating the call generating an alert and logging the non validated call. In one implementation non validated calls are only logged and then allowed to proceed. In one implementation an alert is generated to a security system which can then alert a user to the potential malicious software infection. The security system can also be alerted in order to perform an analysis or scan of the computing system in order to identify the source of the malicious software that affected the system call. In another implementation the call can be terminated and the monitoring engine can be notified such that any further detected calls of the same call type are also terminated. Additionally the source caller of the call can be terminated to prevent further calls.

The invention and all of the functional operations described in this specification can be implemented in digital electronic circuitry or in computer software firmware or hardware including the structural means disclosed in this specification and structural equivalents thereof or in combinations of them. The invention can be implemented as one or more computer program products i.e. one or more computer programs tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program also known as a program software software application or code can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file. A program can be stored in a portion of a file that holds other programs or data in a single file dedicated to the program in question or in multiple coordinated files e.g. files that store one or more modules sub programs or portions of code . A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

The processes and logic flows described in this specification including the method steps of the invention can be performed by one or more programmable processors executing one or more computer programs to perform functions of the invention by operating on input data and generating output. The processes and logic flows can also be performed by and apparatus of the invention can be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer will also include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user the invention can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The invention can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

An example of one such type of computer is shown in which shows a block diagram of a programmable processing system system suitable for implementing or performing the apparatus or methods of the invention. The system includes a processor a random access memory RAM a program memory for example a writable read only memory ROM such as a flash ROM a hard drive controller a video controller and an input output I O controller coupled by a processor CPU bus . The system can be preprogrammed in ROM for example or it can be programmed and reprogrammed by loading a program from another source for example from a floppy disk a CD ROM or another computer .

The hard drive controller is coupled to a hard disk suitable for storing executable computer programs including programs embodying the present invention and data.

The I O controller is coupled by means of an I O bus to an I O interface . The I O interface receives and transmits data e.g. stills pictures movies and animations for importing into a composition in analog or digital form over communication links such as a serial link local area network wireless link and parallel link.

Also coupled to the I O bus is a display and a keyboard . Alternatively separate connections separate buses can be used for the I O interface display and keyboard .

The invention has been described in terms of particular embodiments. Other embodiments are within the scope of the following claims. For example the steps of the invention can be performed in a different order and still achieve desirable results. Additionally implementations can be tailored for different types of operating systems including Windows OS LINUX and UNIX.

