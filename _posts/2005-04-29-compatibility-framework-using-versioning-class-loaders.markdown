---

title: Compatibility framework using versioning class loaders
abstract: A method and system for performing version-based class loading. In one embodiment, a first version is sought to continue running an application, where a first class is associated with the first version being sought. A first class loader capable of loading the first class is created. The first class is then loaded using the first class loader.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07703089&OS=07703089&RS=07703089
owner: SAP AG
number: 07703089
owner_city: Walldorf
owner_country: DE
publication_date: 20050429
---
Embodiments of the invention generally relate to the field of data processing systems and more particularly to a system and method for employing compatibility framework using version based class loaders.

Even though standards based application software e.g. Java based application software has the potential to offer true competition at the software supplier level legacy proprietary software has proven reliability functionality and integration into customer information systems IS infrastructures. Customers are therefore placing operational dependency on standards based software technologies with caution. Not surprisingly present day application software servers tend to include instances of both standard and proprietary software suites and often problems emerge in the operation of the newer standards based software or interoperation and integration of the same with legacy software applications.

The prior art application server depicted in provides a good example. shows a prior art application server having both an ABAP legacy proprietary software suite and a Java J2EE standards based software suite . A connection manager routes requests e.g. HTTP requests HTTPS requests associated with sessions between server and numerous clients not shown conducted over a network . A session can be viewed as the back and forth communication over a network between computing systems e.g. a particular client and the server.

The back and forth communication typically involves a client client sending a server server a request that the server interprets into some action to be performed by the server . The server then performs the action and if appropriate returns a response to the client e.g. a result of the action . Often a session will involve multiple perhaps many requests and responses. A single session through its multiple requests may invoke different application software programs.

For each client request that is received by the application server s connection manager the connection manager decides to which software suite the request is to be forwarded. If the request is to be forwarded to the proprietary software suite notification of the request is sent to a proprietary dispatcher and the request itself is forwarded into a request response shared memory . The proprietary dispatcher acts as a load balancer that decides which one of multiple proprietary worker nodes through are to actually handle the request.

A worker node is a focal point for the performance of work. In the context of an application server that responds to client server session requests a worker node is a focal point for executing application software and or issuing application software code for downloading to the client. The term working process generally means an operating system OS process that is used for the performance of work and is also understood to be a type of worker node. For convenience the term worker node is used throughout the present discussion.

When the dispatcher identifies a particular proprietary worker node for handling the aforementioned request the request is transferred from the request response shared memory to the identified worker node. The identified worker node processes the request and writes the response to the request into the request response shared memory . The response is then transferred from the request response shared memory to the connection manager . The connection manager sends the response to the client via network .

Note that the request response shared memory is a memory resource that each of worker nodes through has access to as such it is a shared memory resource . For any request written into the request response shared memory by the connection manager the same request can be retrieved by any of worker nodes through . Likewise any of worker nodes through can write a response into the request response shared memory that can later be retrieved by the connection manager . Thus the request response shared memory provides for the efficient transfer of request response data between the connection manager and the multiple proprietary worker nodes through .

If the request is to be forwarded to the standards based software suite notification of the request is sent to the dispatcher that is associated with the standards based software suite . As observed in the standards based software suite is a Java based software suite in particular a Java 2 Enterprise Edition J2EE suite that includes multiple worker nodes through .

A Java Virtual Machine is associated with each worker node for executing the worker node s abstract application software code. For each request dispatcher decides which one of the N worker nodes is best able to handle the request e.g. through a load balancing algorithm . Because no shared memory structure exists within the standards based software suite for transferring client session information between the connection manager and the worker nodes through separate internal connections have to be established to send both notification of the request and the request itself to the dispatcher from connection manager for each worker node. The dispatcher then forwards each request to its proper worker node.

A virtual machine VM as is well understood in the art is an abstract machine that converts or interprets abstract code into code that is understandable to a particular type of a hardware platform e.g. a particular type of processor . Because virtual machines operate at the instruction level they tend to have processor like characteristics and therefore can be viewed as having their own associated memory. The memory used by a functioning virtual machine is typically modeled as being local or private to the virtual machine.

Various problems exist with respect to the prior art application server of . For example as application development projects grow larger class loading becomes both increasingly important and cumbersome. Class loading is a technique used primarily by software developers to make programming code truly mobile. For example every mobile code system requires the ability to dynamically load code from outside a system e.g. from a network or a disk into the system. In Java this loading of the code is performed by class loaders. In other words class loading provides an essential benefit of having a Java virtual machine by converting a named class into the bits responsible for implementing that class. Also because of the class loading technique the Java runtime does not need to know anything about files and file system when running Java programs. However the conventional class loading does not provide any kind of versioning mechanism which often results in compatibility problems.

Although the conventional class loading mechanism hierarchy provides the developer with an extensive flexibility when assembling and extending an application it is also severely limited with dealing with independent parts of coding having different coding versions. When relatively independent parts of coding have to work together changing design or communicating protocol or interfaces becomes problematic or even impossible for newer versions particularly when the new version has to work with the old version of coding. For example classes are not capable of receiving constant enhancements during development of different versions since the same class is required to be in compliance with different versions. This problem is exasperated when a complex application with relatively independent parts needs to use different versions of the same base application programming interface API . In this case a part of the application remains unchanged relying on old API classes while another part of the application is further in development using newer API classes. The problem is further complicated when different interfaces and or services are used across the development project.

A method and system for employing compatibility framework using version based class loaders. In one embodiment an application seeks a particular version that is necessary to continue running the application. A class associated with the particular version is identified from a set of already packaged classes that are associated with various versions. An appropriate class loader is created that is capable of loading the class. The class loader is then used to load the class and its dependent classes if any.

Described below is a system and method for employing compatibility framework using version based class loaders. Throughout the description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.

In the following description numerous specific details such as logic implementations opcodes resource partitioning resource sharing and resource duplication implementations types and interrelationships of system components and logic partitioning integration choices may be set forth in order to provide a more thorough understanding of various embodiments of the present invention. It will be appreciated however to one skilled in the art that the embodiments of the present invention may be practiced without such specific details based on the disclosure provided. In other instances control structures gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate functionality without undue experimentation.

Various embodiments of the present invention will be described below. The various embodiments may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor or a machine or logic circuits programmed with the instructions to perform the various embodiments. Alternatively the various embodiments may be performed by a combination of hardware and software.

Various embodiments of the present invention may be provided as a computer program product which may include a machine readable medium having stored thereon instructions which may be used to program a computer or other electronic devices to perform a process according to various embodiments of the present invention. The machine readable medium may include but is not limited to floppy diskette optical disk compact disk read only memory CD ROM Digital Video Disk ROM DVD ROM magneto optical disk read only memory ROM random access memory RAM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM magnetic or optical card flash memory or another type of media machine readable medium suitable for storing electronic instructions. Moreover various embodiments of the present invention may also be downloaded as a computer program product wherein the program may be transferred from a remote computer to a requesting computer by way of data signals embodied in a carrier wave or other propagation medium via a communication link e.g. a modem or network connection .

Second the connection manager is protocol independent. A protocol handler can be plugged into the connection manager to support any one of a number of protocols by which a request can be conveyed to the connection manager . For example handlers for protocols such as the hypertext transfer protocol HTTP secure HTTP HTTPS simple mail transfer protocol SMTP network news transfer protocol NNTP Telnet File Transfer Protocol FTP Remote Method Invocation RMI P4 a proprietary protocol used by the assignee of this application and T3 available from BEA Systems Inc. may be provided at the connection manager so that it can receive a request conveyed from a client in accordance with any of these protocols.

Third the role of a shared memory has been expanded to at least include a a first shared memory region that supports request response data transfers not only for the proprietary suite but also the standards based software suite b a second shared memory region that stores session objects having low level session state information i.e. information that pertains to a request s substantive response such as the identity of a specific servlet invoked through a particular web page and c a third shared memory region that stores high level session state information i.e. information that pertains to the flow management of a request response pair within the application server e.g. the number of outstanding active requests for a session .

Fourth request notification queues Q through QM one queue for each of the worker nodes through has been implemented within the standards standards based software suite . As will be described in more detail below the shared memory structures and request notification queues help implement a fast session fail over protection mechanism in which a session that is assigned to a first worker node can be readily transferred to a second worker node upon the failure of the first worker node.

Shared memory is memory whose stored content can be reached by multiple worker nodes. Here the contents of the shared memory region can be reached by each of worker nodes in and . Additionally the contents of shared memory regions and can be reached by each of worker nodes through . Different types of shared memory technologies may be utilized within the application server and yet still be deemed as being a shared memory structure. For example shared memory region may be implemented within a connection oriented shared memory technology while shared memory region may be implemented with a shared closure oriented shared memory technology. A more thorough discussion of these two different types of shared memory implementations is provided in more detail below in section 5.0 entitled Implementation Embodiment of Request Response Shared Memory and section 6.0 entitled Implementation Embodiment of Shared Closure Based Shared Memory .

The connection oriented request response shared memory region effectively implements a transport mechanism for request response data between the connection manager and the worker nodes. That is because the connection manager is communicatively coupled to the shared memory and because the shared memory is accessible to each worker node the request response shared memory at perhaps its broadest level of abstraction is a mechanism for transporting request response data between the connection manager and the applicable worker node s for normal operation of sessions i.e. no worker node failure as well as those sessions affected by a worker node crash.

Although the enhancements of the application server of have been directed to improving the reliability of a combined ABAP J2EE application server it is believed that improved architectural features and methodologies can be more generally applied to various forms of computing systems that manage data processing and communicative sessions whether or not such computing systems contain different types of application software suites and whether any such application software suites are standards based or proprietary. Moreover it is believed that such architectural features and methodologies are generally applicable to data processing and communicative sessions regardless of for example any particular type of shared memory technology employed.

For example in operation the connection manager forwards actual request data to the first shared memory region request response shared memory regardless of whether the request is to be processed by one of the proprietary worker nodes or one of the standards based worker nodes . Likewise the connection manager receives response data for a request from the request response shared memory whether a proprietary worker node or a standards based worker node generates the response.

With the exception of having to share the request response shared memory with the worker nodes of the standards based software suite the operation of the proprietary software suite is essentially the same as that described in the background in one embodiment of the invention. That is the connection manager forwards request notifications to the proprietary dispatcher and forwards the actual requests to the request response shared memory . The proprietary dispatcher then identifies which one of the proprietary worker nodes is to handle the request. The identified worker node subsequently retrieves the request from the request response shared memory processes the request and writes the response into the request response shared memory . The response is then forwarded from the request response shared memory to the connection manager who forwards the response to the client via network .

In an alternative embodiment the ABAP dispatcher is integrated into the connection manager just as the J2EE dispatcher . Indeed it is contemplated that a single dispatcher may encompass the functionality of both dispatchers and . In the case where the dispatcher is integrated into the connection manager the connection manager identifies which one of the proprietary worker nodes is to handle a request and via its integrated dispatcher capabilities forwards the request to the request response shared memory . The identified worker node subsequently retrieves the request from the request response shared memory processes the request and writes the response into the request response shared memory . The response is then forwarded from the request response shared memory to the connection manager who forwards the response to the client via network .

The memory can include a shared memory area that is accessible by multiple operating system processes executing at the server . An example of a suitable server to be implemented using the client server system includes J2EE compatible servers such as the Web Application Server from developed by SAP AG of Walldorf Germany or the WebSphere Application Server developed by International Business Machines Corp. IBM of Armonk N.Y.

Client systems are used to execute multiple applications or application interfaces. Each instance of an application or an application interface can constitute a user session. Each user session can generate one or more requests to be processed by the server . The requests may include instructions or code to be executed on a runtime system e.g. the VM on the server . A VM is an abstract machine that can include an instruction set a set of registers a stack a heap and a method area like a real machine or processor. A VM essentially acts as an interface between program code and the actual processor or hardware platform on which the program code is to be executed. The program code includes instructions from the VM instruction set that manipulates the resources of the VM .

In one embodiment once classes A N of different versions e.g. A N being the corresponding versions are distinguished and recognized the classes are detected by a class detector and tagger detector tagger . The detector tagger refers to a module that not only detects such classes but tags the binary classes in such as way that their distinct version is distinguished within the class path. For example such tagging can be achieved by putting a version dependent prefix e.g. in each of the class respective package path. In one embodiment classes A N include the same class in different versions while in another embodiment classes A N refer to different classes in different versions.

In one embodiment having distinguished the various classes by their respective versions such as tagged versions A N a new class loader A N is constructed for each of the detected version of classes . These class loaders are generated using a class loader construction module which detects classes have distinct versions and in response generates a class loader to help facilitate loading of each of those classes . For example class loader A is created to help facilitate loading of class A by making use of the version tag .

The application in one embodiment then detects which version is needed for continuing use or execution of the application and classes of those versions are then loaded using the corresponding class loaders . The detection of which version is needed may be performed using an application based detector and selector or an independent module for detection and selection of classes and class loaders may be employed. For example the detector and selector first detects that class A is needed for continuing the application and as such it then selects the appropriate class loader such as class loader A that is capable of loading class A to help load the class . In one embodiment a server client application may use a version specific handshake between the server and the client to detect which version of classes is needed and accordingly the appropriate class is loaded. It is contemplated that in many instances more than one class simultaneously or subsequently may be loaded because of a need for a number of or a combination of versions .

In one embodiment prior to running the application appropriately packaged classes are provided i.e. the classes are associated with their appropriate versions before start running the application. Not only these classes are loaded through the file system but also from any other source capable of supplying binary data like using a Transmission Control Protocol Internet Protocol a database and the like. In other words different versions can be packaged on different locations in the Internet database tables and the like. The tagging is not to be restricted to the path including nether neither the package path nor the physical binary path. In one embodiment the packaged or tagged classes are not necessary provided within or during the already running application but that these classes are provided prior to starting or running the application. At any given point the application seeks a particular version that is needed to continue running the application. Once the knowledge about the needed version is obtained an appropriate class loader is created or taken from a pool as described with reference to or delegated as described with reference to . If then the class is to be loaded the appropriate class loader is used to load that class and it dependent classes if any as the appropriate class loader has information on how to find the appropriate class which has been previously tagged according to its version . It is understood that mechanism and techniques described here may also apply to other embodiments such as the ones described with reference to .

As used herein the term application is used broadly to refer to any type of program code executed on a computer and or transmitted over a network e.g. using a particular network protocol . One embodiment of the invention is implemented in an object oriented programming environment such as Java e.g. within a Java 2 Enterprise Edition J2EE platform engine . In this embodiment each of the illustrated modules such as modules is represented by objects and or classes. The classes and or objects of this embodiment comprise an API usable to configure compatibility framework using versioning class loaders within a Java environment. It should be noted however that the underlying principles are not limited to any particular programming environment.

The class to be loaded may also have dependent classes A A . In one embodiment the same class loader A is also capable of loading any dependent classes of class A . For example once a class loader A is created and is capable of loading class A the same class loader is also capable of loading any dependent or subsequent classes A A for that class A . This is accomplished using the same versioning class loader mechanism . In one embodiment the dependent classes may be assigned the same version tag such as as class A or in another embodiment the dependent classes are assigned a different version tag such as as illustrated. In either case dependent classes are tagged and identified in accordance with the version associated with the main class . Also the dependent classes are loaded by the same class loader capable of loading the main class .

In one embodiment detector and selector a module with detection and selection capabilities is used to detect the version of class needed to be loaded to continue running the application. Once a particular class detected an appropriate class loader from the pool is selected to perform class loading of the class. For example using the detector and selector if class A is required in by the application class loader A is selected from the pool to load class A . In one embodiment the same class loader A is also capable of and is used for loading any dependent classes A A of class A . In one embodiment the same tag such as associated with class A may be associated with its dependent classes or individual tags such as and may be assigned to the paths of the dependent classes .

In one embodiment application Z requests the respective version of classes A and B from application Y . Once this information is retrieved an appropriate corresponding class loader is constructed as described with respect to requested as described with reference to or directed redirected as described with reference to to the particular class. For example class A is requested and loaded by the corresponding class loader. The VM then detects that class B is needed for constructing class A and subsequently the VM requests for class B to be loaded using the same class loader. Class B is then loaded using the corresponding class loader.

Once both classes A and B have been loaded using the same class loader both classes have been loaded in the version required. Regarding class B other present dependent objects of class B are loaded automatically using the VM class loading mechanism without any visibility to the developer. In one embodiment using the versioning class loader mechanism several versions of the same class A B can be used simultaneously in the same virtual machine. For example a server could communicate with various versions of a client in the fields that remain invisible to the developer or programmer of an application.

Class B is also needed to completely define class A . In one embodiment the version of class B is then located and class B is defined in that version such as version B . Using class B class A is completely defined . Then the instance of class A is used for communication with application Y . Application Z communicates with application Y . Application Y communicates with application Z .

At processing block the application detects which version of the class is needed for continuing so that the class can be loaded. At processing block the appropriate class loader is detected and selected to load the class. The class loader loads the class at processing block . At decision block a determination is made as to whether there are any dependent classes of the class that are to be loaded. If there are no dependent classes the process ends at termination block . If there are such dependent classes the same class loader is used to load the dependent classes at processing block . The process ends at termination block .

At processing block the application detects which version of the class is needed for continuing so that the class can be loaded. At processing block an appropriate class loader to load the class is detected and selected from pool of class loaders. The class loader then loads the class at processing block . At decision block a determination is made as to whether there are any dependent classes of the class that are to be loaded. If there are no dependent classes the process ends at termination block . If there are such dependent classes the same class loader is used to load the dependent classes at processing block . The process ends at termination block .

At processing block the application detects which version of the class is needed for continuing so that the class can be loaded. At processing block an appropriate class loader to load the class is detected and selected by the master class loader. At processing block the appropriate class loader is directed by the master class loader to load the class. The class loader then loads the class at processing block . At decision block a determination is made as to whether there are any dependent classes of the class that are to be loaded. If there are no dependent classes the process ends at termination block . If there are such dependent classes the same class loader is used to load the dependent classes at processing block . The process ends at termination block .

The architectures and methodologies discussed above may be implemented with various types of computing systems such as an application server that includes a Java 2 Enterprise Edition J2EE server that supports Enterprise Java Bean EJB components and EJB containers at the business layer and or Servlets and Java Server Pages JSP at the presentation layer . Of course other embodiments may be implemented in the context of various different software platforms including by way of example Microsoft .NET Windows NT Microsoft Transaction Server MTS the Advanced Business Application Programming ABAP platforms developed by SAP AG and comparable platforms.

A hard drive or other storage device may be used by the system for storing information and instructions. The storage device may include a magnetic disk or optical disc and its corresponding drive flash memory or other nonvolatile memory or other memory device. Such elements may be combined together or may be separate components. The system may include a read only memory ROM or other static storage device for storing static information and instructions for the processors through .

A keyboard or other input device may be coupled to the bus for communicating information or command selections to the processors through . The input device may include a keyboard a keypad a touch screen and stylus a voice activated system or other input device or combinations of such devices. The computer may further include a mouse or other cursor control device which may be a mouse a trackball or cursor direction keys to communicate direction information and command selections to the processors and to control cursor movement on a display device. The system may include a computer display device such as a cathode ray tube CRT liquid crystal display LCD or other display technology to display information to a user. In some environments the display device may be a touch screen that is also utilized as at least a part of an input device. In some environments the computer display device may be or may include an auditory device such as a speaker for providing auditory information.

A communication device may also be coupled to the bus . The communication device may include a modem a transceiver a wireless modem or other interface device. The system may be linked to a network or to other device using via an interface which may include links to the Internet a local area network or another environment. The system may comprise a server that connects to multiple devices. In one embodiment the system comprises a Java compatible server that is connected to user devices and to external resources.

While the machine readable medium is illustrated in an exemplary embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine of the system and that causes the machine to perform any one or more of the methodologies of the present invention. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media and carrier wave signals.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

Furthermore it is appreciated that a lesser or more equipped computer system than the example described above may be desirable for certain implementations. Therefore the configuration of system may vary from implementation to implementation depending upon numerous factors such as price constraints performance requirements technological improvements and or other circumstances.

It is noted that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a Java 2 Enterprise Edition J2EE environment or environments defined by other releases of the Java standard or other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation .

It should be noted that while the embodiments described herein may be performed under the control of a programmed processor such as processors through in alternative embodiments the embodiments may be fully or partially implemented by any programmable or hardcoded logic such as field programmable gate arrays FPGAs TTL logic or application specific integrated circuits ASICs . Additionally the embodiments of the present invention may be performed by any combination of programmed general purpose computer components and or custom hardware components. Therefore nothing disclosed herein should be construed as limiting the various embodiments of the present invention to a particular embodiment wherein the recited embodiments may be performed by a specific combination of hardware components.

It should be appreciated that reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore it is emphasized and should be appreciated that two or more references to an embodiment or one embodiment or an alternative embodiment in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined as suitable in one or more embodiments of the invention.

Similarly it should be appreciated that in the foregoing description of exemplary embodiments of the invention various features of the invention are sometimes grouped together in a single embodiment figure or description thereof for the purpose of streamlining the disclosure aiding in the understanding of one or more of the various inventive aspects. This method of disclosure however is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather as the following claims reflect inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus the claims following the detailed description are hereby expressly incorporated into this detailed description with each claim standing on its own as a separate embodiment of this invention.

While certain exemplary embodiments have been described and shown in the accompanying drawings it is to be understood that such embodiments are merely illustrative of and not restrictive and that the embodiments of the present invention are not to be limited to specific constructions and arrangements shown and described since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure.

