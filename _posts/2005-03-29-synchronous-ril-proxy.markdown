---

title: Synchronous RIL proxy
abstract: A hardware-independent proxy layer for synchronous processing of commands in a mobile telephone is disclosed. Such synchronous processing may include receiving a function call of an application program interface (API) that is associated with a function to be performed by a mobile telephone, waiting to receive from a driver layer a result notify event indicating that the function has been performed, and, after receiving the result notify event from the driver layer, passing to the client first result data associated with the first result notify event. The API may be translated into an input/output control (IOCTL) code, which may be sent to the driver layer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07886311&OS=07886311&RS=07886311
owner: Microsoft Corporation
number: 07886311
owner_city: Redmond
owner_country: US
publication_date: 20050329
---
This application is related to U.S. patent application Ser. No. 11 092 062 filed on Mar. 29 2005 entitled UMTS RIL Extension. The disclosure of the above referenced U.S. patent application is incorporated herein by reference.

The invention relates generally to application programming interfaces APIs . More particularly the invention relates to a synchronous API mechanism for a radio interface layer RIL proxy that may be used for communication between clients and an RIL driver.

Mobile telephones are becoming commonplace. As users become more accustomed to using mobile telephones they are requesting more sophisticated uses of telephones. Ideally users would like their mobile telephones to perform the same functions as their personal computers or hand held personal digital assistants PDAs . Implementing such uses in a mobile telephone environment requires application developers to develop or adapt their software for use on a mobile telephone. However adapting or developing software for use on one original equipment manufacturer s OEM s mobile telephone does not necessarily guarantee that the software application will function on another OEM s mobile telephone due to the different radio implementations of different OEMs and due to the differences in different mobile environments.

In order to create a software solution adaptable to multiple different mobile systems and radios there is a need for some kind of a hardware adaptation layer i.e. a layer that isolates the specifics of a particular mobile system hardware from the bulk of the software system. Such a layer the radio interface layer RIL already exists. The RIL is a set of APIs providing a level of abstraction between the radio on a mobile phone and the software of the mobile phone. The RIL API set is roughly based on the Global System for Mobile Communication GSM AT interface as defined in GSM specifications 07.05 and 07.07.

The API set provides access to functionality contained within a mobile telephone such as a GSM or CDMA compatible telephone. Applications running on an operating system in the mobile telephone are allowed to issue commands without knowledge of the underlying radio structure of the mobile telephone and without specific knowledge of the modem type commands. For example the applications may be allowed to access phonebook entries restrict access to data and functionality using passwords access file and message storage and perform many other functions.

Unfortunately the packet switched data transmission services of the GSM system and the packet transmission service of the Universal Mobile Telecommunications System UMTS system are not fully compatible with each other. For example the General Packet Radio Service GPRS packet transmission service deviates from the UMTS standard with respect to quality of service QoS alternatives that can be defined for the data transmission connection. Thus when using a wireless terminal the problem may arise that a data transmission connection can be established only to a mobile communication network of a particular type.

U.S. patent application Ser. No. 11 092 062 discloses and claims an extension to the RIL to include an API set supporting UMTS features in Windows Mobile platforms for 3G Smartphone and PocketPC devices. Such an RIL extension may include APIs to support such features as 3G QoS secondary PDP context 2G and 3G switching voice group call service and voice broadcast call service.

A typical RIL may include a hardware independent proxy layer and a hardware specific driver layer. In a typical RIL proxy however an asynchronous mechanism may be used to communicate between clients and the RIL driver. Such an asynchronous approach may not provide an effective way for providing an efficient signal exchange due to heavy usage of the RIL. Therefore a synchronous RIL API mechanism would be desirable to enhance the communication efficiency between the client and RIL.

The invention provides a synchronous RIL proxy. The architecture of such a synchronous RIL proxy API may be designed to enable the RIL proxy to effectively communicate with the client and to enable the client to use synchronous and asynchronous mechanisms simultaneously. Such a synchronous RIL API mechanism may significantly simplify the usage of the RIL from the client perspective.

An example architecture of a hardware independent proxy layer for synchronous processing of commands in a mobile telephone may include a main thread for receiving from a client application a function call of an application program interface API . The API may be associated with a function to be performed by the mobile telephone. The proxy may then wait to receive a result notify event indicating that the function has been performed. After receiving the result notify event the proxy layer passes the result data directly to the client. The proxy layer may also include a notify thread for receiving a notify event from an RIL driver layer and passing the result notify event and the result data to the main thread. The main thread may translate the API into an input output control IOCTL code and prepare the client data sending to the driver and send the IOCTL code and client data to the driver layer.

The proxy layer may be further adapted to asynchronously process function calls of APIs associated with functions to be performed by the telephone. For example the main thread may be further adapted to receive from the client application a function call of a second API that is associated with the function. The main thread may return to the client application a response identifier to indicate that the driver layer has accepted an operation request associated with the second API. The notify thread may be further adapted to convey result data to the client application using a result callback function. The result callback function may include a response identifier having a value that is the same as that of the first response identifier.

Although not required the invention can be implemented via an application programming interface API for use by a developer or tester and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers e.g. client workstations servers or other devices . Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. An embodiment of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an example system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology compact disc read only memory CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as ROM and RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data . RAM may contain other data and or program modules.

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the example operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client devices can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

The RIL may include an API set which provides a level of abstraction between the radio on a mobile phone and the software of the mobile phone. The API set of RIL may be based on the GSM AT interface as defined in GSM specifications 07.05 and 07.07. The API set may provide access to functionality contained within a mobile telephone such as a GSM or CDMA compatible telephone. Applications running on an operating system in the mobile telephone may issue commands without knowledge of the underlying radio structure of the mobile telephone and specific knowledge of the modem type commands. For example the applications may access phonebook entries restrict access to data and functionality using passwords access file and message storage and perform many other functions.

The RIL may be divided into a hardware independent proxy layer called by various software components and a driver layer that may be hardware specific. It should be understood that an original equipment manufacturer OEM may replace the driver layer with their own layer containing implementation specific to their hardware. In an example embodiment the RIL may be a core component of a mobile telephone.

The RIL driver layer may be used to implement and roughly correspond to the commands such as AT commands specified by ETS 300 585 Digital cellular telecommunications system Phase 2 Use of Data Terminal Equipment Data Circuit terminating Equipment DTE DCE interface for Short Messaging Service SMS and Cell Broadcast Service CBS GSM 07.05 Fifth Edition April 1997 and ETS 300 642 Digital cellular telecommunications system Phase 2 AT command set for GSM Mobile Equipment ME GSM 07.07 version 4.4.1 Fourth Edition March 1999. The GSM specifications 07.05 and 07.07 are hereby incorporated by reference. Of course the RIL driver may be used to implement and correspond to other command sets such as CDMA commands or a combination of several command sets.

OEMs may use the RIL driver of the preferred embodiment or tweak it if they would rather talk with their radio over private APIs instead of via AT commands most likely for performance reasons .

Generally described the RIL driver layer may receive an RIL API call and cause the radio i.e. the receiver transmitter of the mobile phone PDA etc. to perform the function defined by the RIL API. The RIL driver may receive the RIL API call from a RIL proxy layer described below . The RIL driver layer may also process notifications received from the radio and transmit them to the RIL proxy layer. In an example embodiment the RIL driver layer may be a dynamic link library DLL that is running as a device driver inside the process space of a device manager the standard module that manages device drivers on the WINDOWS CE operating system . A Device Manager device.exe may be responsible for managing all the system drivers including the RIL driver.

The RIL proxy layer may include a layer that is called by various other layers of the core architecture such as a telephony service provider TSP layer an extended telephony API ExTAPI layer and a subscriber identity module SIM Manager using the platform specific commands of these core architectures. In an example embodiment the proxy layer may be a WINDOWS CE dynamic link library DLL that manages notifications callback functions and inter process function calls into the RIL driver layer. Modules that want to use the RIL simply link with this proxy DLL. The RIL proxy layer converts the core architecture specific commands into RIL API calls that will be understood by the RIL driver layer.

There are some important distinctions between the proxy and driver layers. In an example embodiment a separate proxy instance may be created for each module using the RIL proxy DLL. On the other hand the RIL device driver may be loaded only once and shared among all proxy layer instances. In other words a module using the RIL may be aware that only one radio module exists even though it links to its own proxy DLL. In addition the Device Manager s control of the RIL driver implies that the proxy and driver live in separate processes i.e. different address spaces . However the WINDOWS CE operating system exposes mechanisms allowing the proxy and driver layers to communicate without being concerned with the process boundaries.

Another architectural property of the RIL is that almost all of the functions may be asynchronous. When a module first registers with the RIL it may pass in two callback functions. One may be used for unsolicited notifications and the other for responses to function calls. For example when the phone receives a new incoming call RIL may use the unsolicited notification callback function to let each module know about the incoming call. Alternatively when a module calls RIL to obtain the signal strength the function call may immediately return a response identifier. Shortly thereafter RIL may use the function response callback function to convey signal strength information to the module. To ensure that function response callbacks are correctly matched up with function calls this callback structure may also contain the same response identifier value returned by the original function call. This asynchronous architecture may simplify RIL implementation.

If a module needs to call RIL functions in a synchronous manner it may need to make the function call and block until it receives the function response callback. U.S. patent application discloses and claims a synchronous RIL proxy.

The RIL may include a virtual serial port VSP . When an application makes a data connection it may retrieve a handle to the virtual serial port not the real data stream between the RIL and the radio . This allows the RIL to buffer and flow control the data stream so that control commands can be interjected. For example suppose an application has set up a data connection and is browsing on the Internet. The virtual serial port may enable the RIL to interject control commands to check for things like signal strength new SMS messages etc. However further suppose an application is receiving a facsimile. Due to strict timing issues in the case of a facsimile transmission the RIL may enter a dedicated data mode where the application has full control of the virtual serial port. That is the RIL may not attempt to interject any commands in the data stream. It should be understood that the VSP is similar to other communication ports and typically only one application can have the handle to the VSP at one time.

Referring now to a block diagram illustrating an example embodiment of an RIL in a mobile phone will be described. The mobile phone may include a SIM manager an emergency application a TSP a WAP layer a SMS manager a data stack and a VSP .

The mobile phone may also include one or more instances of an RIL proxy layer . The RIL proxy layer may provide communications between applications such as the SIM manager emergency application TSP WAP layer SMS manager and ExTAPI among others and an RIL driver layer . The RIL driver layer may provide communications between the RIL proxy layer and the radio hardware .

In terms of using the RIL from the point of view of both an application designer and an OEM the proxy and driver layers each expose a set of functions. For a program module to use the RIL it only needs to use functions specified in the proxy header file and then link with the proxy DLL. The proxy DLL may be implemented by calling functions specified in the driver header file. The driver header file may be provided to OEMs and may define the functions that an OEM must implement. In an example embodiment the implementation may be hardware specific so each OEM will be responsible for its own driver implementation. However one or more reference implementations of the driver source code included may be provided to OEMs to help them with this step. If an OEM uses radio hardware that is supported by one of these reference implementations it may not need to revise the RIL code.

At step input output control IOCTL codes are used to send the appropriate information for the RIL API to the RIL driver running in a separate process space. At step the RIL driver informs the radio to take the action specified by the command of the RIL API. In an example embodiment the RIL driver informs the radio to take action using an AT command interface as defined in GSM specs most prominently 07.05 and 07.07 . However sending AT commands may not be ideal for a given radio perhaps an OEM has a separate private API set that they can use to perform the same functionality as a given AT command. If this is the case the OEM may change the RIL driver to suit their needs. However in an example embodiment because the core architecture of the phone has been built on top of a set of RIL APIs that may be implemented via AT commands it is not necessary for the OEM to substantially modify the RIL driver so long as the radio understands AT commands. However due to different implementations of the AT interface some minor modifications may be necessary.

The method then proceeds to step where the RIL API returns with a unique ID generated by the RIL. It should be understood that after sending an AT command a response from the radio unit is awaited. RIL APIs may be asynchronous so these APIs will return immediately with a unique ID assigned to the call.

The method then proceeds to step where the RIL driver matches the response from the radio unit with the unique ID generated earlier and the RIL driver sends the response to the appropriate calling process via a callback function.

It should also be understood that radio units can also send unsolicited notifications for example when the phone switches cellular towers . In this case the RIL driver receives a notification from the radio and will broadcast a message to all users of the RIL layer who are interested in this class of notification.

Referring now to an example illustrating a method for an application to establish a voice call using RIL in accordance with an embodiment of the present invention will be described. It should be understood that establishing a voice call is only one of many functions that may be performed using the RIL APIs. The method outlined in is illustrative of one of these functions establishing a voice call . The method is implemented in telephone that includes an application layer an ExTAPI layer a TAPI layer other core modules a TSP a radio interface layer RIL and OEM hardware . It should be understood that the method does not describe optional IOCTLs that may be present.

The method begins when application calls the TAPI function lineMakeCall step . The TAPI layer calls the TSP with the following function call TSPI lineMakeCall step . The TSP calls the RIL with the following RIL function RIL Dial step . The RIL initiates the phone call by sending the corresponding command to the OEM hardware e.g. radio e.g. ATDT 555 1234 step . The TSP returns asynchronously a reply message to the TAPI layer indicating that the call has been initiated LINE REPLY message step .

The TAPI layer forwards the reply message LINE REPLY to the application step . When the OEM hardware detects that a connection to the number has been made then it sends a CONNECT response to the RIL step . The RIL sends a message RIL NOTIFY CONNECT to the TSP indicating that a connection has been made step . The TSP sends a state change message LINE CALLSTATE to the TAPI layer step . The TAPI layer forwards the state change message LINE CALLSTATE to the application step .

When the application wishes to drop the telephone call it calls the TAPI layer with a hang up request lineDrop step . The TAPI layer forwards the TSP the hang up request TSPI lineDrop step . The TSP handler passes the hang up request to the RIL RIL Hangup step . The RIL passes the hang up request to the OEM hardware e.g. ATH step .

The 762 patent provides tables that describe some of the features that may be implemented using an RIL example data structures that may be passed as parameters to some RIL APIs and returned with some RIL notifications some of the unsolicited RIL notifications that get passed to the notification callback and some of the RIL functions broken down by group.

The Universal Mobile Telecommunications System UMTS extension to the RIL provides a communication interface between the system software and the wireless radio stack. The architecture of the UTMS RIL as shown in may be designed as a standard interface with APIs and callback mechanisms that can be used across different platforms and multi radio hardware.

The RIL may be divided into two layers a hardware specific driver layer i.e. RIL Driver which processes AT commands as defined in 3GPP 27.007 and events and a hardware independent proxy layer i.e. RIL Proxy which performs arbitration between the multiple clients for access to the single RIL driver. The proxy layer may be a Windows CE based dynamic link library DLL that manages notifications callback functions and inter process function calls into the driver layer . Upper layer modules or clients e.g. SMS TSP in Telephony use the RIL application programming interface API by linking to this proxy DLL. The RIL driver services system requests for radio functionality including voice circuit switch CS and packet switch PS data SMS and notifies the system of changes in the radio state such as coverage signal strength and incoming calls. In particular the UMTS RIL driver provides the notification to the upper layer when the network changes between GSM GPRS and WCDMA HSDPA.

Thus the RIL may be divided into a hardware independent proxy layer called by various software components and a driver layer that may be hardware specific. It should be understood that an OEM may replace the driver layer with their own layer containing implementation specific to their hardware.

The telephony may provide support for CS data features such as voice call CS data connection CS video telephony SMS message SIM USIM USAT etc. The NDIS Network Driver Interface Specification and PPP Point to Point Protocol may be employed to support PS data features such as audio video streaming VoIP Voice over IP PS based video telephony PTT Push to Talk etc. The multiplexer MUX driver as defined in 3GPP TS 27.010 may be used to provide multiple concurrent channels to the radio protocol stack allowing the RIL to perform several functions simultaneously.

An example embodiment of a UMTS RIL may include any or all of the following features. It should be understood that a UMTS RIL according to the invention may include other features in addition to or instead of those described below.

Secondary PDP context. The secondary PDP context may be used to activate a PDP context while reusing the PDP address and APN Access Point Name from an already active primary PDP context but with a different QoS profile. When the downlink traffic flow arrives at access point on the GGSN the packet classifier on GGSN will make a PDP Context selection based on the TFT Traffic Flow Template which is always associated with a PDP context during the Secondary PDP Context Activation procedure and is used to discriminate between different users payloads and incorporate packet filters thus the traffic flow will be forwarded to that the secondary PDP Context with the suitable QoS attributes.

3G QoS profile. The 3G QoS profile supports four traffic classes such as conversational streaming interactive and background classes for different type of applications with different QoS requirements respectively. There are two QoS profiles for a PDP context i.e. the requested QoS profile and minimum QoS profile to provide different level QoS requirement.

Priority call service. The enhanced Multi Level Precedence and Pre emption Service eMLPP provides different call priorities in combination with fast call setup and pre emption for different applications. The maximum precedence level of a subscriber is set at the subscription time by the service provider based on the subscriber s need. The subscriber may select a precedence level up to and including the maximum precedence level subscribed to on a per call basis.

Voice group call service VGCS and voice broadcast service VBS . VGCS allows speech conversation of a predefined group of service subscribers in half duplex mode on the radio link taking into account multiple mobile service subscribers involved in the VGCS call per cell. VBS allows the distribution of speech generated by a service subscriber into a predefined geographical area to all or a group of service subscribers located in this area.

It should be understood that the foregoing description includes many implementation details that should not limit the scope of the present invention. For example instead of using a proxy layer and a driver layer the present invention may be implemented as a single abstraction layer between a telephony radio and a computer. The applications on the computer may communicate with the abstraction layer using top level APIs. On the other hand the telephony radio could respond to commands received from the abstraction layer.

It should also be understood from the foregoing description that the present invention may be used with mobile telephones as well as other devices such as hand held PDA devices. Some of these other devices may not have a permanent radio module. Certain changes known to those skilled in the art may be necessary to implement the invention in a device without a permanent radio module.

As described above a typical RIL proxy defines a set of asynchronous APIs. However a synchronous RIL proxy API may be designed to add a synchronous counterpart. Such an approach may simplify the communication between the RIL Proxy and the client. Also in accordance with such an approach a client may use synchronous and asynchronous mechanisms simultaneously.

To facilitate the understanding of a synchronous RIL Proxy APIs design a typical asynchronous API design is first described in connection with . When a client calls a function RIL xxx the function call may return a response identifier CommandID to indicate that the RIL driver has accepted the operation request. As shown the main proxy thread may transform the API call to an input output control IOCTL code and prepare the client data sending to driver and then send the IOCTL code and client data to the RIL driver . RIL IOControl will call corresponding functions per IOCTL code defined in RIL driver to complete the RIL function call performed by the client.

After the RIL driver gets the result from the radio it sends a notification event RIL NotifyEvent to pass the result data to the RIL proxy notify thread . Then the RIL proxy notify thread uses the result callback function to convey the result data to the client . To ensure that function response callbacks are correctly matched up with function calls this callback structure also contains the same response identifier command ID value returned by the original function call.

An advantage of asynchronous RIL API is that it provides flexibility of performing other tasks while an AT command is in progress. However it brings much more complexity to users. For example asynchronous RIL API may require a user to implement result callback functions to handle the AT command response which may lead to a program without a clear flow of control. Furthermore the asynchronous mechanism leaves the responsibility to users to match the responses to the correct API function calls which may result in a large or complicated result callback function implementation. In some cases the asynchronous mechanism may not be appropriate from the user s point of view. An example of such a case may be calling an RIL API that is dependent on another RIL API e.g. RIL GetPhonebookOptions and RIL ReadPhonebookEntries. The former API may be used to retrieve a phonebook storage location and the number of used locations the latter may be used to read the phonebook entry. In typical usage RIL GetPhonebookOptions is called first to get the number of used locations. This information may then be used as indexes to call RIL ReadPhonebookEntries to get the nphonebook entry. From a user s perspective it may be more normal and convenient to call these two APIs in sequence and get the result synchronously rather than handling the result asynchronously in the callback function.

It should be understood that the foregoing description includes many implementation details that should not limit the scope of the present invention. For example instead of using a proxy layer and a driver layer the present invention may be implemented as a single abstraction layer between a telephony radio and a computer. The applications on the computer may communicate with the abstraction layer using top level APIs. On the other hand the telephony radio could respond to commands received from the abstraction layer.

It should also be understood from the foregoing description that the present invention may be used with cellular telephones as well as other devices such as hand held PDA devices. Some of these other devices may not have a permanent radio module. Certain changes known to those skilled in the art may be necessary to implement the invention in a device without a permanent radio module.

