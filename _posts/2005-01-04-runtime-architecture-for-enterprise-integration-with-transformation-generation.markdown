---

title: Run-time architecture for enterprise integration with transformation generation
abstract: An enterprise application system including a run-time transformation server, and a message broker for routing and transforming data in the form of messages between a source application and a target application, including a plug-in for preparing requests to the run-time transformation server and for processing responses from the run-time transformation server. A method is also described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07930293&OS=07930293&RS=07930293
owner: International Business Machines Corporation
number: 07930293
owner_city: Armonk
owner_country: US
publication_date: 20050104
---
This application is a divisional application of U.S. patent application Ser. No. 10 104 785 filed Mar. 22 2002 now U.S. Pat. No. 7 146 399 which is a continuation in part of assignee s application U.S. Ser. No. 10 053 045 filed on Jan. 15 2002 now abandoned entitled Method and System for Deriving a Transformation by Referring Schema to a Central Model which is a continuation in part of assignee s application U.S. Ser. No. 09 904 457 filed on Jul. 6 2001 now U.S. Pat. No. 7 093 200 entitled Instance Browser for Ontology which is a continuation in part of assignee s application U.S. Ser. No. 09 866 101 filed on May 25 2001 now U.S. Pat. No. 7 099 885 entitled Method and System for Collaborative Ontology Modeling. 

The present invention relates to data schema and in particular to deriving transformations for transforming data from one schema to another.

Ontology is a philosophy of what exists. In computer science ontology is used to model entities of the real world and the relations between them so as to create common dictionaries for their discussion. Basic concepts of ontology include i classes of instances things and ii relations between the classes as described hereinbelow. Ontology provides a vocabulary for talking about things that exist.

There are many kinds of things in the world. There are physical things like a car person boat screw and transistor. There are other kinds of things which are not physically connected items or not even physical at all but may nevertheless be defined. A company for example is a largely imaginative thing the only physical manifestation of which is its appearance in a list at a registrar of companies. A company may own and employ. It has a defined beginning and end to its life.

Other things can be more abstract such as the species which is a concept that does not have a beginning and end as such even if its members do.

Ontological models are used to talk about things. An important vocabulary tool is relations between things. An ontology model itself does not include the things but introduces class and property symbols which can then be used as a vocabulary for talking about and classifying things.

Some properties also relate things to fundamental concepts such as natural numbers or strings of characters for example the value of a weight in kilograms or the name of a person.

Properties play a dual role in ontology. On the one hand individual things are referenced by way of properties for example a person by his name or a book by its title and author. On the other hand knowledge being shared is often a property of things too. A thing can be specified by way of some of its properties in order to query for the values of other of its properties.

Not all properties are relevant to all things. It is convenient to discuss the source of a property as a class of things also referred to as a frame or for end user purposes as a category. Often sources of several properties coincide for example the class Book is the source for both Author and ISBN Number properties.

There is flexibility in the granularity to which classes are defined. Cars is a class. Fiat Cars can also be a class with a restricted value of a manufacturer property. It may be unnecessary to address this class however since Fiat cars may not have special properties of interest that are not common to other cars. In principle one can define classes as granular as an individual car unit although an objective of ontology is to define classes that have important properties.

Abstract concepts such as measures as well as media such as a body of water which cannot maintain its identity after coming into contact with other bodies of water may be modeled as classes with a quantity property mapping them to real numbers.

In the ensuing discussion the terms class and class symbol are used interchangeably for purposes of convenience and clarity. Similarly the terms property and property symbol are also used interchangeably.

It is apparent to those skilled in the art that if an ontology model is extended to include sets in a class then a classical mathematical relation on C D can be considered as a property from C to sets in D.

If I C C then Cis referred to as a subclass of C and Cis referred to as a superclass of C. Also C is said to inherit from C.

A distinguished universal class Being is typically postulated to be a superclass of all classes in C.

The notion of a class symbol is conceptual in that it describes a generic genus for an entire species such as Books Cars Companies and People. Specific instances of the species within the genus are referred to as instances of the class. Thus Gone with the Wind is an instance of a class for books and IBM is an instance of a class for companies. Similarly the notions of a property symbol is conceptual in that it serves as a template for actual properties that operate on instances of classes.

Class symbols and property symbols are similar to object oriented classes in computer programming such as C classes. Classes along with their members and field variables defined within a header file serve as templates for specific class instances used by a programmer. A compiler uses header files to allocate memory for and enables a programmer to use instances of classes. Thus a header file can declare a rectangle class with members left right top and bottom. The declarations in the header file do not instantiate actual rectangle objects but serve as templates for rectangles instantiated in a program. Similarly classes of an ontology serve as templates for instances thereof.

There is however a distinction between C classes and ontology classes. In programming classes are templates and they are instantiated to create programming objects. In ontology classes document common structure but the instances exist in the real world and are not created through the class.

Ontology provides a vocabulary for speaking about instances even before the instances themselves are identified. A class Book is used to say that an instance is a Book. A property Author allows one to create clauses author of about an instance. A property Siblings allows one to create statements are siblings about instances. Inheritance is used to say for example that every Book is a PublishedWork . Thus all vocabulary appropriate to PublishedWork can be used for Book.

Once an ontology model is available to provide a vocabulary for talking about instances the instances themselves can be fit into the vocabulary. For each class symbol C all instances which satisfy is a C are taken to be the set of instances of C and this set is denoted B C . Sets of instances are consistent with inheritance so that B C B C whenever Cis a subclass of C. Property symbols with source Cand target Ccorrespond to properties with source B C and target B C . It is noted that if class Cinherits from class Cthen every instance of Cis also an instance of Cand it is therefore known already at the ontology stage that the vocabulary of C is applicable to C.

Ontology enables creation of a model of multiple classes and a graph of properties therebetween. When a class is defined its properties are described using handles to related classes. These can in turn be used to look up properties of the related classes and thus properties of properties can be accessed to any depth.

Provision is made for both classes also referred to as simple classes and complex classes. Generally complex classes are built up from simpler classes using tags for symbols such as intersection Cartesian product set list and bag. The intersection tag is followed by a list of classes or complex classes. The Cartesian product tag is also followed by a list of classes or complex classes. The set symbol is used for describing a class comprising subsets of a class and is followed by a single class or complex class. The list symbol is used for describing a class comprising ordered subsets of a class namely finite sequences and is followed by a single class or complex class. The bag symbol is used for describing unordered finite sequences of a class namely subsets that can contain repeated elements and is followed by a single class or complex class. Thus set C describes the class of sets of instances of a class C list C describes the class of lists of instances of class C and bag C describes the class of bags of instances of class C.

In terms of formal mathematics for a set S set S is P S the power set of S bag S is N where N is the set of non negative integers and list S is

Provision is also made for one to one or unary properties and for one to many properties. The target of a one to one property is a simple class. Generally the target of a one to many property is a complex class. For example a one to many property named children may have a class Person as its source and a complex class set Person as its target and a one to many property named parents may have a class Person as its source and a complex class Person Person as its target.

A general reference on ontology systems is Sowa John F. Knowledge Representation Brooks Cole Pacific Grove Calif. 2000.

Relational database schema RDBS are used to define templates for organizing data into tables and fields. SQL queries are used to populate tables from existing tables generally by using table join operations. Extensible markup language XML schema are used to described documents for organizing data into a hierarchy of elements and attributes. XSLT script is used to generate XML documents from existing documents generally by importing data between tags in the existing documents. XSLT was originally developed in order to generate HTML pages from XML documents.

A general reference on relation databases and SQL is the document Oracle 9i SQL Reference available on line at http www.oracle.com. XML XML schema XPath and XSLT are standards of the World Wide Web Consortium and are available on line at http www.w3.org.

Often multiple schema exist for the same source of data and as such the data cannot readily be imported or exported from one application to another. For example two airline companies may each run applications that process relational databases but if the relational databases used by the two companies conform to two different schema then neither of the companies can readily use the databases of the other company. In order for the companies to share data it is necessary to export the databases from one schema to another.

There is thus a need for a tool that can transform data conforming to a first schema into data that conforms to a second schema.

The present invention provides a method and system for deriving transformations for transforming data from one schema to another. The present invention describes a general method and system for transforming data confirming with an input or source data schema into an output or target data schema. In a preferred embodiment the present invention can be used to provide i an SQL query which when applied to relational databases from a source RDBS populates relational databases in a target RDBS and ii XSLT script which when applied to documents conforming with a source XML schema generates documents conforming with a target XML schema.

The present invention preferably uses an ontology model to determine a transformation that accomplishes a desired source to target transformation. Specifically the present invention employs a common ontology model into which both the source data schema and target data schema can be mapped. By mapping the source and target data schema into a common ontology model the present invention derives interrelationships among their components and uses the interrelationships to determine a suitable transformation for transforming data conforming to the source data schema into data conforming to the target data schema.

Given a source RDBS and a target RDBS in a preferred embodiment of the present invention an appropriate transformation of source to target databases is generated by 

Although the source and target RDBS are mapped into a common ontology model the derived transformations of the present invention go directly from source RDBS to target RDBS without having to transform data via an ontological format. In distinction prior art Universal Data Model approaches transform via a neutral model or common business objects.

The present invention applies to N relational database schema where N 2. Using the present invention by mapping the RDBS into a common ontology model data can be moved from any one of the RDBS to any other one. In distinction to prior art approaches that require on the order of Nmappings the present invention requires at most N mappings.

For enterprise applications SQL queries generated by the present invention are preferably deployed within an Enterprise Application Integration infrastructure. Those skilled in the art will appreciate that transformation languages other than SQL that are used by enterprise application infrastructures can be generated using the present invention. For example IBM s ESQL language can similarly be derived for deployment on their Websphere MQ family of products.

Given a source XML schema and a target XML schema in a preferred embodiment of the present invention an appropriate transformation of source to target XML documents is generated by 

There is thus provided in accordance with a preferred embodiment of the present invention an enterprise application system including a run time transformation server and a message broker for routing and transforming data in the form of messages between a source application and a target application including a plug in for preparing requests to the run time transformation server and for processing responses from the run time transformation server.

There is further provided in accordance with a preferred embodiment of the present invention a method for transforming data within an enterprise application product including receiving a message from a source application the message conforming to a source data schema generating a transformation for transforming messages conforming to the source data schema to corresponding messages conforming to a target data schema transforming the message from the source data schema to the target data schema using the generated transformation and sending the transformed message to a target application.

There is yet further provided in accordance with a preferred embodiment of the present invention an ontology modeler including a class builder for generating and editing classes within an ontology model a property builder for generating and editing properties of classes within the ontology model and a business rules builder for generating and editing business rules involving properties of classes within the ontology model.

There is additionally provided in accordance with a preferred embodiment of the present invention a method for building ontology models including generating classes within an ontology model generating properties of classes within the ontology model and generating business rules involving properties of classes within the ontology model.

There is moreover provided in accordance with a preferred embodiment of the present invention A schema to ontology mapper including a storage for storing a schema the schema including at least one primary data structure the primary data structure having at least one ancillary data structure and a map generating for generating a plurality of mappings including a class mapper for defining a primary mapping that is a correspondence between a primary data structure of the schema and a class of an ontology model and a property mapper for defining an ancillary relationship between an ancillary data structure of the primary data structure and at least one property of the class.

There is further provided in accordance with a preferred embodiment of the present invention a method for mapping a schema to an ontology model including receiving a schema the schema including at least one primary data structure the primary data structure having at least one ancillary data structure and generating a plurality of mappings including defining a primary mapping that is a correspondence between a primary data structure of the schema and a class of an ontology model and defining an ancillary relationship between a secondary data structure of the primary data structure and at least one property of the class.

There is yet further provided in accordance with a preferred embodiment of the present invention a schema transformation generator including a storage for storing a first mapping of a first schema into a central ontology model and a second mapping of a second schema into the central ontology model wherein the first schema includes at least one first primary data structure the first primary data structure having at least one first ancillary data structure wherein the second schema includes at least one second primary data structure the second primary data structure having at least one second ancillary data structure wherein the first mapping includes at least one first primary mapping that is a correspondence between at least one first primary data structure of the first schema and a class of the central ontology model and at least one first relationship between at least one first ancillary data structure of a first primary data structure and at least one property of a class and wherein the second mapping includes at least one second primary mapping that is a correspondence between at least one second primary data structure of the second schema and a class of the central ontology model and at least one second relationship between at least one second ancillary data structure of a second primary data structure and at least one property of a class and a transformation generator for generating a transformation from the first schema into the second schema using the first and second primary mappings and the first and second relationships.

There is yet further provided in accordance with a preferred embodiment of the present invention a method for generating a schema transformation including storing a first mapping of a first schema into a central ontology model and a second mapping of a second schema into the central ontology model wherein the first schema includes at least one first primary data structure the first primary data structure having at least one first ancillary data structure wherein the second schema includes at least one second primary data structure the second primary data structure having at least one second ancillary data structure wherein the first mapping includes at least one first primary mapping that is a correspondence between at least one first primary data structure of the first schema and a class of the central ontology model and at least one first relationship between at least one first ancillary data structure of a first primary data structure and at least one property of a class and wherein the second mapping includes at least one second primary mapping that is a correspondence between at least one second primary data structure of the second schema and a class of the central ontology model and at least one second relationship between at least one second ancillary data structure of a second primary data structure and at least one property of a class and generating a transformation from the first schema into the second schema using the first and second primary mappings and the first and second relationships.

The present invention concerns deriving transformations for transforming data conforming with one data schema to data conforming to another data schema. Preferred embodiments of the invention are described herein with respect to table based data schema such as RDBS and document based schema such as XML schema.

Reference is now made to which is a simplified flowchart of a method for deriving transformations for transforming data from one schema to another in accordance with a preferred embodiment of the present invention. The flowchart begins at step . At step a source data schema and a target data schema are imported. These data schema describe templates for storing data such as templates for tables and table columns or templates for structured documents. If necessary the source data schema and or the target data schema may be converted from a standard format to an internal format. For example they may be converted from Oracle format to an internal format.

At steps a common ontology model is obtained into which the source data schema and the target data schema can both be embedded At step a determination is made as to whether or not an initial ontology model is to be imported. If not logic passes directly to step . Otherwise at step an initial ontology model is imported. If necessary the initial ontology model may be converted from a standard format such as one of the formats mentioned hereinabove in the Background to an internal format.

At step a determination is made as to whether or not the initial ontology model is suitable for embedding both the source and target data schema. If so logic passes directly to step . Otherwise at step a common ontology model is built. If an initial ontology model was exported then preferably the common ontology is built by editing the initial ontology model specifically by adding classes and properties thereto. Otherwise the common ontology model is built from scratch. It may be appreciated that the common ontology model may be built automatically with or without user assistance.

At step the source and target data schema are mapped into the common ontology model and mappings therefor are generated. At step a transformation is derived for transforming data conforming with the source data schema into data conforming with the target data schema based on the mappings derived at step . Finally the flowchart terminates at step .

Reference is now made to which is a simplified block diagram of a system for deriving transformations for transforming data from one schema to another in accordance with a preferred embodiment of the present invention. Shown in is a schema receiver for importing a source data schema and a target data schema. These data schema describe templates for storing data such as templates for tables and table columns and templates for structured documents. If necessary schema receiver converts the source and target data schema from an external format to an internal format.

Also shown in is an ontology receiver builder for obtaining a common ontology model into which the source data schema and the target data schema can both be embedded. The operation of ontology receiver builder is described hereinabove in steps of .

The source and target data schema and the common ontology model are used by a mapping processor to generate respective source and target mappings for mapping the source data schema into the common model and for mapping the target data schema into the common ontology model. In a preferred embodiment of the present invention mapping processor includes a class identifier for identifying ontology classes with corresponding to components of the source and target data schema and a property identifier for identifying ontology properties corresponding to other components of the source and target data schema as described in detail hereinbelow.

Preferably the source and target mappings generated by mapping processor and the imported source and target data schema are used by a transformation generator to derive a source to target transformation for transforming data conforming to the source data schema into data conforming to the target data schema.

Reference is now made to which is a simplified flowchart of a method for building a common ontology model into which one or more data schema can be embedded in accordance with a preferred embodiment of the present invention. The flowchart begins are step . Steps and are similar to these same steps in as described hereinabove. Finally the flowchart terminates at step .

Reference is now made to which is a simplified block diagram of a system for building a common ontology model into which one or more data schema can be embedded in accordance with a preferred embodiment of the present invention. Shown in is schema receiver from for importing data schema. Also shown in is an ontology receiver for importing an initial ontology model. If necessary ontology receiver converts the initial ontology model from an external format to an internal format.

The initial ontology model and the imported data schemas are used by an ontology builder for generating a common ontology model into which the imported data schemas can all be embedded. In a preferred embodiment of the present invention ontology builder generates the common ontology model by editing the initial ontology model specifically by using a class builder to add classes thereto based on components of the imported data schema and by using a property builder to add properties thereto based on other components of the imported data schema.

A feature of the present invention is the capability to generate test instances of classes. In a preferred embodiment a test instance is represented as an XML document that describes the instance and some or all of the values of its properties. Generation of test instances is enabled both manually by a user filling in property values and automatically without user intervention.

Relational database schema RDBS also referred to as table definitions or in some instances metadata are used to define templates for organizing data into tables and table columns also referred to as fields. Often multiple schema exist for the same source of data and as such the data cannot readily be imported or exported from one application to another. The present invention describes a general method and system for transforming an input or source relational database schema into an output or target schema. In a preferred embodiment the present invention can be used to provide an SQL query which when applied to a relational database from the source schema produces a relational database in the target schema.

As described in detail hereinbelow the present invention preferably uses an ontology model to determine an SQL query that accomplishes a desired source to target transformation. Specifically the present invention employs a common ontology model into which both the source RDBS and target RDBS can be mapped. By mapping the source and target RDBS into a common ontology model the present invention derives interrelationships among their tables and fields and uses the interrelationships to determine a suitable SQL query for transforming databases conforming with the source RDBS into databases conforming with the target RDBS.

The present invention can also be used to derive executable code that transforms source relational databases into the target relational databases. In a preferred embodiment the present invention creates a Java program that executes the SQL query using the JDBC Java Database Connectivity library. In an alternative embodiment the Java program manipulates the databases directly without use of an SQL query.

For enterprise applications SQL queries generated by the present invention are preferably deployed within an Enterprise Application Integration infrastructure.

Although the source and target RDBS are mapped into a common ontology model the derived transformations of the present invention go directly from source RDBS to target RDBS without having to transform data via an ontological format. In distinction prior art Universal Data Model approaches transform via a neutral model.

The present invention applies to N relational database schema where N 2. Using the present invention by mapping the RDBS into a common ontology model data can be moved from any one of the RDBS to any other one. In distinction to prior art approaches that require on the order of Nmappings the present invention requires at most N mappings.

In general although a mapping from an RDBS into an ontology model may exist the nomenclature used in the RDBS may differ entirely from that used in the ontology model. Part of the utility of the mapping is being able to translate between RDBS language and ontology language. It may be appreciated by those skilled in the art that in addition to translating between RDBS table column language and ontology class property language a mapping is also useful in translating between queries from an ontology query language and queries from an RDBS language such as SQL standard query language .

Reference is now made to which is a first simplified illustration of a mapping from an RDBS into an ontology model in accordance with a preferred embodiment of the present invention. Shown in is a table denoted T having four columns denoted C C C and C. Also shown in is an ontology model having a class denoted K and properties P P P and P defined on class T. The labeling indicates a mapping from table T into class K and from columns C C C and C into respective properties P P P and P.

Reference is now made to which is a second simplified illustration of a mapping from an RDBS into an ontology model in accordance with a preferred embodiment of the present invention. Shown in are table T from and a second table denoted T having four columns denoted D D D and D. Column C of table T is a key i.e. each entry for column C is unique and can be used as an identifier for the row in which it is situated Column D of table T refers to table T by use of the key from column C. That is each entry of column D refers to a row within table T and specifies such row by use of the key from C for the row.

Also shown in is an ontology model having two classes denoted K and K. Class K has properties P P P and P defined thereon and class K has properties Q Q Q and S defined thereon. Property S has as its source class K and as its target class K. The labeling indicates a mapping from table T into class K and from columns C C C and C into respective properties P P P and P. The fact that C serves as a key corresponds to property P being one to one so that no two distinct instances of class K have the same values for property P.

The labeling also indicates a mapping from table T into class K and from columns D D and D into respective properties Q Q and Q. Column D corresponds to a composite property PloS where o denotes function composition. In other words column D corresponds to property P of S K .

The targets of properties P P P P Q Q and Q are not shown in since these properties preferably map into fundamental types corresponding to the data types of the corresponding columns entries. For example the target of P may be an integer the target of P may be a floating point number and the target of P may be a character string. Classes for such fundamental types are not shown in order to focus on more essential parts of ontology model .

Classes K and K and property S are indicated with dotted lines in ontology model . These parts of the ontology are transparent to the RDBS underlying tables T and T. They represent additional structure present in the ontology model which is not directly present in the RDBS.

Given a source RDBS and a target RDBS in a preferred embodiment of the present invention an appropriate transformation of source to target RDBS is generated by 

Reference is now made to which is a simplified illustration of relational database transformations involving constraints and joins in accordance with a preferred embodiment of the present invention.

As described in detail hereinbelow the present invention preferably uses an ontology model to determine an XSLT transformation that accomplishes a desired source to target transformation. Specifically the present invention employs a common ontology model into which both the source XML schema and target XML schema can be mapped. By mapping the source and target XML schema into a common ontology model the present invention derives interrelationships among their elements and attributes and uses the interrelationships to determine suitable XSLT script for transforming documents generating documents conforming to the target XML schema from documents conforming to the source XML schema.

It may be appreciated by those skilled in the art that the present invention applies to structured document formats other than XML. For example it applies inter alia to the message formats of Tibco Active Enterprise and IBM WebsphereMQ. Similarly the present invention applies to transformation languages other than XSLT. For example it applies inter alia to ESQL which is the transformation language of IBM WebsphereMQ and to the transformations used by Tibco MessageBroker.

It may be appreciated by those skilled in the art that the present invention can be employed to run in batch mode in response to GUI commands at design time and also in run time mode to generate transformations dynamically on the fly.

The present invention can also be used to derive executable code that transforms source XML documents into the target XML documents. In a preferred embodiment the present invention packages the derived XSLT script with a Java XSLT engine to provide an executable piece of Java code that can execute the transformation.

Preferably this is used to deploy XSLT scripts within an EAI product such as Tibco. Specifically in a preferred embodiment of the present invention a function similar to a plug in is installed in a Tibco MessageBroker which uses the Xalan XSLT engine to run XSLT scripts that are presented in text form. As an optimization the XSLT script files are preferably compiled to Java classfiles.

Reference is now made to which is a simplified block diagram of a run time architecture for implementing a preferred embodiment of the present invention within an enterprise application integration system. Shown in is an enterprise system including a source application such as an enterprise accounting system and a target application such as an enterprise inventory system. Source application and target application communicate via a messaging bus . Typically source application sends information to target application in the form of documents containing data. However source application and target application may use different schema for data representation. A document processed by source application typically must conform to a source data schema used by source application and similarly a document processed by target application typically must conform to a target data schema used by target application . Thus in general documents prepared by source application are not in a proper format to be understood by target application .

To facilitate document routing and transformation a Message Broker is used to perform simple address based and rule based routing and transformation. Message Broker is typically part of an enterprise application integration EA product such as IBM s WebsphereMQ or Tibco s Active Enterprise. Message Broker is a term used by Tibco. Within IBM WebsphereMQ it is referred to as an Integrator. For purposes of clarity the name Message Broker is used henceforth within the present specification.

Message Broker includes an adapter and a transform plug in . Adapter is a component that enables Message Broker to communicate with outside software. For example adapter may be used to query a database or to get information from an enterprise information system such as SAP. Plug in is a component that is dynamically loaded into Message Broker . Plug in is used to run XSLT within enterprise applications such as Tibco Active Enterprise and IBM WebsphereMQ which use their own transformation languages.

For some EAI systems use of adapter may be optional. Generally though vendors of EAI systems recommend use of an adapter rather than direct network access by plug in . Adapter may implement either i proprietary application programming interfaces APIs exposed by Message Broker such as Tibco Message Broker or WebsphereMQ Integrator or ii cross platform APIs such as Java Connector Architecture.

Also shown in is a run time transformation server which communicates with plug in via adapter . In a preferred embodiment of the present invention run time transformation server is used to assist Message Broker in converting documents from the source schema to the target schema Plug in is used to prepare requests and process responses for run time transformation server . There are several embodiments regarding the role of transformation server three of which are described in . For enterprise applications that run XSLT natively plug in may not be necessary. Specifically for architectures based on the implementation illustrated in where run time transformation server is not used and the purpose of plug in is to run XSLT scripts plug in is not necessary for enterprise applications that run XSLT natively. However for architectures based on implementations which use run time transformation server such as the implementations illustrated in plug in is also used to prepare responses and process requests from run time transformation server and as such is a necessary component even within enterprise applications that run XSLT natively.

Communication between adapter and run time transformation server is preferably achieved using an appropriate network request response protocol.

It may be appreciated by those skilled in the art that one or more additional nodes may serve as protocol bridges between adapter and run time transformation server translating among different network protocols. For example in one implementation of the present invention adapter communicates using Simple Object Access Protocol SOAP Web Services with a SOAP Web Services server such as Apache Jakarta Tomcat with Apache Axis. Such a SOAP Web Services server acts as a bridge passing communication over Remote Method Invocation RMI to run time transformation server .

Information about SOAP and Web Services is available though the World Wide Web Consortium at http www.w3.org 2002 ws.

Reference is now made to which is a simplified flowchart for a first implementation of the present invention within an enterprise application integration system. In this first implementation run time transformation server is not used. At step Message Broker receives a document from source application intended for target application . In this first implementation Message Broker is configured to know the source schema and target schema and to know which transformation to use for a given source schema and target schema. At step plug in runs the specified transformation and transforms the document from the source schema to the target schema. At step Message Broker sends the transformed document to target application .

Reference is now made to which is a simplified flowchart for a second implementation of the present invention within an enterprise application integration system. In this second implementation run time transformation server is used to provide plug in with an appropriate transformation such as an appropriate XSLT file. At step Message Broker receives a document from source application intended for target application . In this second implementation Message Broker is configured to know the source and target schema but not the transformation. Preferably Message Broker extracts an identifier for the source schema from an XML document received from source application . At step plug in requests a transformation such as an XSLT file or XSLT translet from run time transformation server . Preferably plug in issues a request to run time transformation server specifying a source and target schema and requesting a transformation therebetween.

At step run time transformation server generates the requested transformation in accordance with a preferred embodiment of the present invention. It may be appreciated by those skilled in the art that run time transformation server may already have the requested transformation available for example having cached it from a previous request or having it otherwise available in a memory store. In such a case step is omitted. At step run time transformation server sends the requested transformation to plug in . At step plug in runs the specified transformation and transforms the document to the target schema. At step Message Broker sends the transformed document to target application .

Reference is now made to which is a simplified flowchart for a third implementation of the present invention within an enterprise application integration system. In this third implementation run time transformation server is used to perform the transformations from source schema to target schema. At step Message Broker receives a document from source application intended to target application . In this third implementation Message Broker is configured to know the target schema. At step plug in sends the document to run time transformation server and requests that run time transformation server transform the document to a specified target schema.

Run time transformation server receives the source document and the target schema. Typically the source document includes information about the source schema. For example XML documents typically include references to the X schema to which they conform. Run time transformation server generates an appropriate transformation in accordance with a preferred embodiment of the present invention and at step run time transformation server transforms the document from the source schema to the target schema. It may be appreciated by those skilled in the art that run time transformation server may already have the requested transformation available for example having cached it from a previous request or having it otherwise available in a memory store. In such a case it is not necessary to generate the transformation.

At step run time transformation server sends the transformed document to plug in . At step plug in passes the documents to Message Broker and at step Message Broker sends the transformed document to target application .

Reference is now made to which is a simplified illustration of an enterprise application product such as Tibco Active Enterprise with the present invention therewithin. Shown in is a Message Broker data flow in which an input document is transformed for delivery to two targets each target having its own target schema. Unicorn Coherence is used to generate each of the source to target transformation in accordance with a preferred embodiment of the present invention. corresponds to the flowchart shown in .

It may be appreciated by those skilled in the art that source application and target application may use multiple schemata and as such the references to source schema and target schema are intended to include single schema and multiple schemata.

Applicant has developed a software application named COHERENCE which implements a preferred embodiment of the present invention to transform data from one schema to another. Coherence enables a user

Reference is now made to which are illustrations of a user interface for transforming data from one relational database schema to another using the Coherence software application in accordance with a preferred embodiment of the present invention. Shown in is a main Coherence window with a left pane and a right pane . Window includes three primary tabs and labeled Authoring Mapping and Transformations respectively. Authoring tab is invoked in order to display information about the ontology model and to modify the model by adding deleting and editing classes and properties. Mapping tab is invoked in order to display information about the RDBS and the mappings of the RDBS into the ontology and to edit the mappings. Transformations tab is invoked to display transformations in the form of SQL queries from a source RDBS into a target RDBS. In tab for Authoring is shown selected.

Left pane includes icons for two modes of viewing an ontology icon for viewing in inheritance tree display mode and icon for viewing in package display mode.

Inheritance tree display mode shows the classes of the ontology in a hierarchical fashion corresponding to superclass and subclass relationships. As illustrated in in addition to the fundamental classes for Date Number Ratio String and NamedElement there is a class for City. Corresponding to the class selected in left pane right pane displays information about the selected class. Right pane includes six tabs for class information display tab for General tab for Properties tab for Subclasses tab for Enumerated Values tab for Relations and tab for XML schema. Shown in is a display under tab for General. The display includes the name of the class Being and the package to which it belongs namely fundamental. Also shown in the display is a list of immediate superclasses which is an empty list for class Being. Also shown in the display is a textual description of the class namely that Being is a root class for all classes.

Tab for Enumerated Values applies to classes with named elements i.e. classes that include a list of all possible instances. For example a class Boolean has enumerated values True and False and a class Gender may have enumerated values Male and Female. 

As shown in City is selected in left pane and correspondingly right pane displays information about the class City. Right pane display information under Tab for Properties. As can be seen class City belongs to the package WeatherFahrenheit and has four properties namely Celsius of type RealNumber city of type String Fahrenheit of type RealNumber and year of type RealNumber. indicates that the property Celsius satisfies a constraint. Specifically Celsius 5 Fahrenheit 32 9.

In the tab for Mapping is shown selected. As shown in the left pane of two RDBS have been imported into Coherence. A first RDBS named WeatherCelsius which includes a table named Towns and a second RDBS named WeatherFahrenheit which includes a table named Cities.

The table named Cities is shown selected in and correspondingly the right pane display information regarding the mapping of Cities into the ontology. As can be seen the table Cities contains three fields namely Fahrenheit city and year. The table Cities has been mapped into the ontology class City the field Fahrenheit has been mapped into the ontology property Fahrenheit the field city has been mapped into the ontology property name and the field year has been mapped into the ontology property year. The RDBS WeatherFahrenheit will be designated as the source RDBS.

When tab for Mapping is selected the right pane includes three tabs for displaying information about the RDBS tab for Map Info tab for Table Info and tab for Foreign Keys.

The RDBS named WeatherCelsius is displayed in . As can be seen the table Towns contains three fields namely town Celcius and year. The table Towns has been mapped into the ontology class City the field town has been mapped into the ontology property name the field Celcius has been mapped into the ontology property Celcius and the field year had been mapped into the ontology property year. The RDBS WeatherCelcius will be designated as the target RDBS.

In the tab for Transformations is shown selected. As can be seen in the right pane the source table is Cities and the target table is Towns. The SQL query

Reference is now made to which is an illustration of a user interface for an application that imports an RDBS into Coherence in accordance with a preferred embodiment of the present invention. Shown in is a window for a schema convertor application. Preferably a user specifies the following fields 

Reference is now made to which are illustrations of a user interface for transforming data from one XML schema to another using the Coherence software application in accordance with a preferred embodiment of the present invention. Shown in is a window with package view of an Airline Integration ontology model in its left pane. The left pane displays classes from a fundamental package. A class Date is shown highlighted and its properties are shown in the right pane. Fundamental packages are used for standard data types. Shown in is a window with a hierarchical view of the Airline Integration ontology model in its left pane. The left pane indicates that FrequentFlyer is a subclass of Passenger Passenger is a subclass of Person and Person is a subclass of Being. The right pane displays general information about the class FrequentFlyer.

For purposes of clarity and exposition the workings of the present invention are described first through a series of twenty three examples followed by a general description of implementation. Two series of examples are presented. The first series comprising the first eleven examples relates to RDBS transformations. For each of these examples a source RDBS and target RDBS are presented as input along with mappings of these schema into a common ontology model. The output is an appropriate SQL query that transforms database tables that conform to the source RDBS into database tables that conform to the target RDBS. Each example steps through derivation of source and target symbols expression of target symbols in terms of source symbols and derivation of an appropriate SQL query based on the expressions.

The second series of examples comprising the last twelve examples relates to XSLT transformation. For each of these examples a source XML schema and target XML schema are presented as input along with mappings of these schema into a common ontology model. The output is an appropriate XSLT script that transforms XML documents that conform to the source schema into XML documents that conform to the target schema.

The underlying ontology is illustrated in . The dotted portions of the ontology in show additional ontology structure that is transparent to the relational database schema. Using the numbering of properties indicated in the unique properties of the ontology are identified as 

The symbol o is used to indicate composition of properties. The mapping of the source schema into the ontology is as follows 

The symbols in Table XI relate fields of a source table to a key field. Thus in table Sthe first field S.Name is a key field. The second field S.School Attending is related to the first field by the composition 10o9o6 and the third field S.Mother NI Number is related to the first field by the composition 4o5o6. In general if a table contains more than one key field then expressions relative to each of the key fields are listed.

The inverse notation such as 6is used to indicate the inverse of property 6. This is well defined since property 6 is a unique or one to one property in the ontology model. The indices of the target properties keyed on Child Name are 

The rules provided with the examples relate to the stage of converting expressions of target symbols in terms of source symbols into SQL queries. In general 

When applied to the following sample source data Tables XIII XIV XV and XVI the above SQL query produces the target data in Table XVII.

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The unique properties of the ontology are 

It is noted that Table Snot required in the SQL. When applied to the following sample source data Tables XXVIII XXIX and XXX the above SQL query produces the target data in Table XXXI.

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The unique properties of the ontology are 

Since the path 2o1 appears in two rows of Table XXXIX it is necessary to create two tables for Sin the SQL query. Based on the paths given in Table XXXII the desired SQL query is 

When applied to the following sample source data Tables XL XLI the above SQL query produces the target data in Table XLII.

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The unique properties of the ontology are 

In a fifth example the target property of Father Name in the fourth example is changed to Grandfather Name and the target table is thus of the following form 

The underlying ontology is again illustrated in . The unique properties of the ontology are as above in Table XLV.

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The unique properties of the ontology are 

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The unique properties of the ontology are 

When applied to the following sample source data Tables LXXII LXXIII LXXIV LXXV and LXXVI the above SQL query produces the target data in Table LXXVII

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The unique properties of the ontology are 

Since each of the source tables Sand Ssuffice to generate the target table T the desired SQL is a union of a query involving Salone and a query involving Salone. Specifically based on the paths given in Table LXXXV the desired SQL query is 

When applied to the following sample source data Tables LXXXVI and LXXXVII the above SQL query produces the target data in Table LXXXVIII.

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The properties temperature in Centrigade and temperaturein Fahrenheit are related by the constraint Temperature in Centrigade City 5 9 Temperature in Fahrenheit City 32 

Since each of the source tables Sand Ssuffice to generate the target table T the desired SQL is a union of a query involving Salone and a query involving Salone. Specifically based on the paths given in Table XCVI the desired SQL query is 

When applied to the following sample source data Tables XCVII and XCVII the above SQL query produces the target data in Table XCIX.

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The properties price cost of production and margin are related by the constraint price Product cost of production Product margin Product .

When applied to the following sample source data Tables CVIII CVIX the above SQL query produces the target data in Table CX

The underlying ontology is illustrated in . The dotted portions of the ontology in are additional ontology structure that is transparent to the relational database schema. The properties full name first name and last name are related by the constraint full name Person first name Person last name Person where denotes string concatenation.

When applied to the following sample source data Table CXVIII the above SQL query produces the target data in Table CXIX.

As illustrated in the ninth tenth and eleventh examples above the present invention allows for dependency constraints also referred to as business rules to exist among properties of a class. Correspondingly a target table column may be expressible as a function of one or more source table columns. In such a case the target symbol is generally expressed as a function of composites of source symbols. From a broader perspective since functional composition itself is a function of properties constraints can be considered as another type of function of properties and the expression of a target symbol in terms of source symbols is just a function of the source symbols.

Preferably dependency constraints express dependencies between class properties that are representations. Such constraints involve fundamental data types. Such constraints include arithmetic dependencies among numeric data string dependencies among character string data and look up tables. For example constraints can be used to convert between one date format and another such as between a format like 22 01 2002 and a format like Tues. Jan. 22 2002 and to convert between color spaces such as between RGB and HSL. In general a constraint includes any programming method that accepts one or more fundamental data types as input processes them and produces one or more fundamental data type as output.

In an alternate embodiment of the present invention dependency constraints can be incorporated within mappings directly. That is a given table column may be mapped to a function of properties rather than to a single property or to a composition of properties. For example rather than have temperature in Centigrade be a property of the class City in the mapping in Table XCIII may map T.Temperature to 5 9 Temperature in Fahrenheit 32 . An advantage of treating dependency constraints within mappings themselves is that this treatment generally avoids proliferation of dependent properties within the ontology model itself such as many dependent properties for a date each corresponding to a different date format.

Test instances as described hereinabove are useful for validating an ontology model. In a preferred embodiment of the present invention when a test instance is created or edited a validation is performed for consistency vis a vis the properties entered by a user or generated automatically and the business rules. For example such validation will determine if a person s first name is inconsistent with his full name.

A common ontology model for the source and target XML schema is illustrated in . A mapping of the source XML schema into the ontology model is given by 

Based on Tables CXX and CXXI an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the target schema should accomplish the following tasks 

A common ontology model for the source and target XML schema is illustrated in . A mapping of the source XML schema into the ontology model is given by Table CXVIII above. A mapping of the target XML schema into the ontology model is given by 

Based on Tables CXX and CXXI an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the target schema should accomplish the following tasks 

A common ontology model for the source and first target XML schema is illustrated in . A mapping of the source XML schema into the ontology model is given by 

Based on Tables CXXIII and CXXIV an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the target schema should accomplish the following tasks 

Based on Tables CXXIII and CXXV an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the target schema should accomplish the following tasks 

Based on Tables CXXIII and CXXVI an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the target schema should accomplish the following tasks 

A common ontology model for the source and target XML schema is illustrated in . A mapping of the source XML schema into the ontology model is given by Table CXX with an additional correspondence between the complexType and the container class set Book . A mapping of the target XML schema into the ontology model is given by Table CXXI with an additional correspondence between the complexType storage and the container class setBook .

Based on Tables CXX and CXXI an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the target schema should accomplish the following tasks 

A common ontology model for the source and target XML schema is illustrated in . A mapping of the source XML schema into the ontology model is given by 

Based on Tables CXXVII and CXXVIII an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the target schema is given by 

A common ontology model for the source and target XML schema is illustrated in . A mapping of the source XML schema into the ontology model is given by 

Based on Tables CXXIX and CXXX an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the first target schema is given by 

Based on Tables CXXIX and CXXX an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the second target schema is given by 

Based on Tables CXXIX and CXXX an XSLT transformation that maps XML documents that conform to the source schema to corresponding documents that conform to the first target schema is given by 

As mentioned hereinabove and described through the above series of examples in accordance with a preferred embodiment of the present invention a desired transformation from a source RDBS to a target RDBS is generated by 

Preferably the common ontology model is built by adding classes and properties to an initial ontology model as required to encompass tables and fields from the source and target RDBS. The addition of classes and properties can be performed manually by a user automatically by a computer or partially automatically by a user and a computer in conjunction.

Preferably while the common ontology model is being built mappings from the source and target RDBS into the ontology model are also built by identifying tables and fields of the source and target RDBS with corresponding classes and properties of the ontology model. Fields are preferably identified as being either simple properties or compositions of properties.

In a preferred embodiment of the present invention automatic user guidance is provided when building the common ontology model in order to accommodate the source and target RDBS mappings. Specifically while mapping source and target RDBS into the common ontology model the present invention preferably automatically presents a user with the ability to create classes that corresponds to tables if such classes are not already defined within the ontology. Similarly the present invention preferably automatically present a user with the ability to create properties that correspond to fields if such properties are not already defined within the ontology.

This automatic guidance feature of the present invention enables users to build a common ontology on the fly while mapping the source and target RDBS.

In a preferred embodiment of the present invention automatic guidance is used to provide a user with a choice of properties to which a given table column may be mapped. Preferably the choice of properties only includes properties with target types that are compatible with a data type of the given table column or compositions of properties wherein the final property in the composition has a target type that is compatible with the data type of the given table column. For example if the given table column has data type VARCHAR2 then the choice of properties may only include properties with target type string or compositions of properties whereby the final property in the composition has target type string. Similarly if the given table column is a foreign key to a foreign table then the choice of properties may only include properties whose target is the class corresponding to the foreign table or compositions of properties wherein the final property in the composition has a target that is the class corresponding to the foreign table.

More specifically in a preferred embodiment of the present invention a property whose target is a fundamental data type is referred to as a representation. Fundamental data types preferably include data types that can be processed by a digital computer such as 16 bit integers 32 bit integers floating point numbers double precision floating point numbers and character strings. Representations are preferably color coded within a GUI. For example representations may be displayed using green fonts. When mapping a given table column to a property of composition of properties the GUI preferably automatically guides the user so that the mapped property or the final property in the mapped composition of properties is green i.e. a representation and has an appropriate target data type.

Representations are significant with respect to generation of test instances as described hereinabove. When a test instance of a class is generated values of the class representations are preferably entered as strings or numbers. When other properties are entered however their values have to be set to instances of their target class. For example when a test instance of a class Person is generated his name and D number which are representations can be entered as a string and a number respectively. However his address which is a property from class Person to a class Address is preferably entered as an instance of class Address.

In a preferred embodiment of the present invention automatic guidance is provided in determining inheritance among classes of the common ontology. Conditions are identified under which the present invention infers that two tables should be mapped to classes that inherit one from another. Such a condition arises when a table T contains a primary key that is a foreign key to a table T. In such a situation the present invention preferably infers that the class corresponding to Tinherits from the class corresponding to T.

For example Tmay be a table for employees with primary key Social Security No which is a foreign key for a table Tfor citizens. The fact that Social Security No serves both as a primary key for Tand as a foreign key for Timplies that the class Employees inherits from the class Citizens.

Preferably when the present invention infers an inheritance relation the user is given an opportunity to confirm or decline. Alternatively the user may not be given such an opportunity.

In a preferred embodiment of the present invention a given column table may be mapped to a property of a subclass or superclass of the class to which the table corresponds.

Preferably representing fields of the source and target RDBS in terms of properties of the ontology model is performed by identifying a key field among the fields of a table and expressing the other fields in terms of the identified key field using an inverse property symbol for the key field. For example if a key field corresponds to a property denoted by 1 and a second field corresponds to a property denoted by 2 then the relation of the second field to the first field is denoted by 2o1. If a table has more than one key field then preferably symbols are listed for each of the key fields indicating how the other fields relate thereto. For example if the second field above also is a key field then the relation of the first field to the second field is denoted by 1o2 and both of the symbols 2o1and 1o2are listed.

Preferably deriving expressions for target symbols in terms of source symbols is implemented by a search over the source symbols for paths that result in the target symbols. For example if a target symbol is given by 3o1 then chains of composites are formed starting with source symbols of the form ao1 with each successive symbol added to the composite chain inverting the leftmost property in the chain. Thus a symbol ending with ais added to the left of the symbol ao1 and this continues until property 3 appears at the left end of the chain.

Preferably converting symbol expressions into SQL queries is accomplished by use of Rules 1 7 described hereinabove with reference to the examples.

Preferably when mapping a table to a class a flag is set that indicates whether it is believed that the table contains all instances of the class.

1. Begin with the target schema. Preferably the first step is to identify a candidate root element. Assume in what follows that one such element has been identified if there are more than one such candidate then preferably a user decides which is to be the root of the XSLT transformation. Assume that a element has thus been identified. Create the following XSLT script to establish that any document produced by the transformation will at minimum conform to the requirement that its opening and closing tags are identified by root 

2. Preferably the next step is to identify the elements in the target schema that have been mapped to ontological classes. The easiest case and probably the one encountered most often in practice is one in which the root itself is mapped to a class be it a simple class a container class or a cross product. If not then preferably the code generator goes down a few levels until it comes across elements mapped to classes. The elements that are not mapped to classes should then preferably be placed in the XSLT between the tags mentioned above in the correct order up to the places where mappings to classes begin.

3. Henceforth for purposes of clarity and exposition the XSLT script generation algorithm is described in terms of an element that is expected to appear in the target XML document and is mapped to an ontological class whether that means the root element or a parallel set of elements inside a tree emanating from the root. The treatment is the same in any event from that point onwards.

4. Preferably the XSLT generation algorithm divides into different cases depending on a number of conditions as detailed hereinbelow 

5. Next assume that the classes have been taken care of as detailed hereinabove in step 4. Preferably from this point onwards the algorithm proceeds by working with properties rather than classes. Again the algorithm is divided up into cases. Assume that the tags have been treated and that the main issue now is dealing with the elements that are properties of .

Suppose that the properties of are listed in a sequence complex type in the target schema. Assume for the sake of definitiveness that a complexType fu is mapped to an ontological class Foo with elements barmapped to respective property Foo.bar. Assume further that the source XML schema has an XPath pattern fu1 that maps to the ontological class Foo with further children patterns fu1 barr1 fu1 barr2 etc. mapping to the relevant property paths.

In a preferred embodiment of the present invention specific pieces of code are generated to deal with different maximum and minimum occurrences. Such pieces of code are generated inside the tags that were generated as described hereinabove. Preferably the general rule for producing such pieces of code is as follows 

Suppose that the properties of are listed in a choice complex type in the target schema. Assume again as above that fu is mapped to an ontological class Foo with each of barmapped to a property Foo.bar. Assume further as above that the source XML schema has an XPath pattern foo that maps to the ontological class Foo with further children patterns foo barr1 foo barr2 etc. mapping to the relevant property paths.

Preferably the general rule for producing XSLT script associated with a target choice bloc is as follows. Start with the tags . For each element in the choice sequence insert into the choose bloc and within that bloc insert code appropriate to the cardinality restrictions of that element exactly as above for sequence blocs including the creation of new templates if needed. Finally if there are no elements with minOccurs 0 in the choice bloc select any tag at random in the choice bloc and insert into the XSLT right before the closing .

Suppose that the properties of are listed in an all complex type in the target schema. Assume again as above that foo is mapped to an ontological class Foo with each of bar mapped to a property Foo.bar. Assume further that the source XML schema has an XPath pattern foo that maps to the ontological class Foo with further children patterns foo barr1 foo barr2 etc. mapping to the relevant property paths.

In a preferred embodiment of the present invention a general rule is to test for the presence of each of the source tags associated with the target tags by way of

6. In a preferred embodiment of the present invention when the elements of foo bar1 foo bar2 etc. have been processed as above in step everything repeats in a recursive manner for properties that are related to each of the barelements. That is if the target XML schema has further tags that are children of bar1 bar2 etc. then preferably each of those is treated as properties of the respective target classes of bar1 bar2 and so on and the above rules apply recursively.

It may be appreciated by those skilled in the art that enterprise applications may include multiple XML schema and multiple relational database schema. As each schema for an XML complexType and each relational database schema map into a class a collection of XML schema or relational database schema corresponds to a class of classes. The present invention is capable of representing an entire hierarchy with one model by supporting classes of classes.

A class of classes is a class in itself and its instances are also classes. For example a class Species may have instances that are classes Monkeys Elephants and Giraffes. The properties of a class of classes can be considered metadata for the instance classes. For example the class of classes Species can have properties such as average life span average weight average height and period of gestation. 

A class of classes is most useful in modeling enterprise data since it is a high level object that can include all of the various XML schema or all of the various RDBS that an enterprise employs. Examples of applications of a class of classes include 

More generally the present invention supports a multi level hierarchy having successive levels of classes of classes.

Reference is now made to which is a simplified dependency graph used for impact analysis in accordance with a preferred embodiment of the present invention. Shown in are eleven components within an ontology mapping and transformation system labeled A K. For reference the components are 

A direct property is a single property whereas an indirect property is a composition or properties. Preferably an indirect property includes a direct property as a special case. Similarly a direct inheritance is a class subclass pair. An indirect inheritance is a pair of classes C D where D inherits from C through chain of inheritances. Preferably an indirect inheritance includes a direct inheritance as a special case.

Preferably components are implemented as objects that can send and receive messages to and from other objects. Thus for example an indirect property PoPand an indirect inheritance C D are implemented as their own objects. Direct dependencies among the objects are indicated by in by directed edges within the dependency graph. If a first object depends on a second object either through a direct single edge or indirect multiple edge dependency then modification or deletion of the second object potentially impacts the first object. For example referring to a constraint depends directly on an indirect property and a mapping depends indirectly on an indirect property.

In a preferred embodiment of the present invention impact analysis is performed recursively. When a first object Y is about to be changed it notifies objects X that depend directly on Y of the intended change. The objects X in turn can recursively notify objects that depend directly on them. Each object so notified can send a reply to the notifying object with one or more instructions. For example an object X inter alia can send a reply to Y over ruling the intended change or a reply asking that a warning be issued.

After the first object Y is changed it notifies objects X that depend directly on Y of the actual change. As above the objects X can recursively notify objects that depend directly on them. Each object so notified can perform one or more instructions. For example if Y is deleted an object X depending on Y can inter alia modify itself appropriately delete itself or do nothing.

The dependency graph in includes sixteen edges namely AB AC BF BG BJ CD CE DE DF EJ FG FH GI HJ IK and JK. Each edge corresponds to a direct dependency. Table CXXXII lists each of these direct dependencies X Y and the behavior of X before and after Y is changed.

For example referring to edge J K suppose a component class L of a complex class K is about to be deleted. According to Table CXXXII K issues a notice to J and in turn J issues a notice to all of its dependents that J is about to be deleted. In particular suppose J is the target of a direct property H. According to Table CXXXII J notifies H that it is about to be deleted. In turn H sends back a warning to J indicating that if J is deleted then H will be deleted. In turn J sends a warning back to K indicating that if K is deleted then direct property H will be deleted. K informs the user of this. Similarly if an RDBS mapping C includes a map E that maps a specific relational database table to J then according to Table CXXXII J notifies E that it is about to be deleted. E takes no action.

If the user decides to proceed and delete K despite the warning regarding H then K sends a message to J indicating that K is deleted. J sends a message to H and to E that J is deleted. H is deleted and the mapping E is marked as corrupted. E sends a message to a mapping D of a column of the specific database table to a property of the ontology model. D and E each send a message to the RDBS mapping C that they are deleted. The RDBS mapping C is changed and C issues a notice to a transformation A that depends on C. Transformation A is marked for re calculation if necessary.

It may be appreciated by those skilled in the art that the dependency graph in and Table CXXXII can be adapted to have different components. For example the dependency graph can be expanded inter alia to include 

From a more general perspective in a preferred embodiment of the present invention models mappings schema transformations business rules and other objects are comprised are units referred to as concepts. A concept is a basic building block for a model. For example an ontology class and an ontology property are concepts. Preferably a concept may include information of a structure characteristic to a concept type. Concepts may contain pointers to other concepts. In a preferred embodiment of the present invention concepts have unique identifiers and lifetimes independent of changes to the information contained therewithin.

Dependencies between concepts can be classified as referential dependencies or content dependencies. A first concept has referential dependence on a second concept if the first concept depends on the existence but not on the content of the second concept. Typically a first concept referentially depends on a second concept if the first concept makes a statement about the second concept a statement that is not relevant if the second concept is deleted. An example of referential dependence is a business rule first concept that makes statements about properties second concept . Another example is a property first concept that states that its source class second concept has a certain characteristic property with type of the target property or alternatively a property first concept refers to a class second concept by building on the class.

A first concept has content dependence on a second concept if the first concept depends on information within the second concept. Typically this means that the first concept makes a statement the correctness of which depends on information within the second concept. An example of content dependence is a transformation first concept that depends on a business rule second concept .

In a preferred embodiment of the present invention internal proxy concepts are established for external concepts that exist outside of a model such as an external relational database schema.

In a preferred embodiment of the present invention concepts are implemented independently so that program code for a type of concept does not require knowledge about other concepts that depend thereon. Preferably concepts are programmed with generic mechanisms for other concepts to register their referential or content dependence including callbacks. Preferably a concept that changes or is deleted uses such callbacks to notify its dependents.

In a preferred embodiment of the present invention when a first concept notifies a second concept dependent on the first concept about an impending change or deletion the second concept sends a response. For example the second concept my respond inter alia by 

In a preferred embodiment of the present invention a concept notifies its dependents at least twice. First when an action such as a change or deletion is pending and again when the action is approved by a user who has seen warnings in response to the first notification. Upon receiving the second notification the dependent concepts must take appropriate actions such as changing or deleting themselves.

In a preferred embodiment of the present invention concepts that have broken referential dependencies are set to depend on a special undefined concept until a user replaces the undefined concept with a reference to a proper concept A similar approach is preferably used for content dependency as well. For example a business rule including a formula involving a specific property maintains the formula when the specific property is deleted by replacing the deleted property with undefined. 

In addition to its used with impact analysis the notion of a concept as described hereinabove can also be used as 

In reading the above description persons skilled in the art will realize that there are many apparent variations that can be applied to the methods and systems described. A first variation to which the present invention applies is a setup where source relational database tables reside in more than one database. The present invention preferably operates by using Oracle s cross database join if the source databases are Oracle databases. In an alternative embodiment the present invention can be applied to generate a first SQL query for a first source database and use the result to generate a second SQL query for a second source database. The two queries taken together can feed a target database.

A second variation to which the present invention applies is processing queries on relational database tables and queries on instance data of an ontology model. In such scenarios a target schema can be artificially constructed so as to correspond to the desired query. For example suppose two relational database tables Sand S are queries for columns A and B such that S.A has a different value than a given function f S.B . Such queries can arise when database tables are cleansed for inconsistencies. An artificial target relational database schema can be constructed with a target table T having a column C equal to S.A f S.B . Using the present invention a transformation can be generated to populate table T from data in tables Sand S and identifying non zero entries in T.C.

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will however be evident that various modifications and changes may be made to the specific exemplary embodiments without departing from the broader spirit and scope of the invention as set forth in the appended claims. Accordingly the specification and drawings are to be regarded in an illustrative rather than a restrictive sense.

