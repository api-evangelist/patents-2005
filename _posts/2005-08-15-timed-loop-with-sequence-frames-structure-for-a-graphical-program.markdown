---

title: Timed loop with sequence frames structure for a graphical program
abstract: A “timed loop with frames” node may be included in a graphical program. The “timed loop with frames” node may combine a timed loop with a timed sequence such that the timed sequence is executed at each iteration of the timed loop. The “timed loop with frames” node may be configured with first execution timing information that controls execution timing for the iterations of the loop. A plurality of graphical code portions may be included in the “timed loop with frames” such that a sequential order of execution for the graphical code portions is specified. The “timed loop with frames” node may be configured with second execution timing information that controls execution timing for the graphical code portions executed at each iteration.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07802229&OS=07802229&RS=07802229
owner: National Instruments Corporation
number: 07802229
owner_city: Austin
owner_country: US
publication_date: 20050815
---
This application claims benefit of priority of U.S. provisional application Ser. No. 60 601 692 titled Timed Sequence Structure and Timed Loop with Sequence Frames filed Aug. 13 2004 whose inventors were Jacob Kornerup Biren Shah Aljosa Vrancic Matthew C. Curtis and Steven W. Rogers.

This application also claims benefit of priority of U.S. provisional application Ser. No. 60 601 598 titled Combination Structure Nodes in a Graphical Program filed Aug. 13 2004 whose inventors were Jacob Kornerup Biren Shah and Aljosa Vrancic.

This application also claims benefit of priority of U.S. provisional application Ser. No. 60 601 948 titled Graphical Programming System with Deterministic Communication filed Aug. 16 2004 whose inventors were Aljosa Vrancic and Jacob Kornerup.

This application is also a continuation in part of U.S. patent application Ser. No. 10 893 745 titled Graphically Representing Timing in a Graphical Program filed Jul. 16 2004 whose inventors were Jacob Kornerup Jeffrey L. Kodosky Hugo A. Andrade Biren Shah Aljosa Vrancic and Michael L. Santori.

The present invention relates to the field of graphical programming and more particularly to a system and method for enabling a graphical program to execute a timed loop where a timed sequence of graphical code portions is executed in each iteration of the timed loop.

Traditionally high level text based programming languages have been used by programmers in writing application programs. Many different high level text based programming languages exist including BASIC C Java FORTRAN Pascal COBOL ADA APL etc. Programs written in these high level text based languages are translated to the machine language level by translators known as compilers or interpreters. The high level text based programming languages in this level as well as the assembly language level are referred to herein as text based programming environments.

Increasingly computers are required to be used and programmed by those who are not highly trained in computer programming techniques. When traditional text based programming environments are used the user s programming skills and ability to interact with the computer system often become a limiting factor in the achievement of optimal utilization of the computer system.

There are numerous subtle complexities which a user must master before he can efficiently program a computer system in a text based environment. The task of programming a computer system to model or implement a process often is further complicated by the fact that a sequence of mathematical formulas steps or other procedures customarily used to conceptually model a process often does not closely correspond to the traditional text based programming techniques used to program a computer system to model such a process. In other words the requirement that a user program in a text based programming environment places a level of abstraction between the user s conceptualization of the solution and the implementation of a method that accomplishes this solution in a computer program. Thus a user often must substantially master different skills in order to both conceptualize a problem or process and then to program a computer to implement a solution to the problem or process. Since a user often is not fully proficient in techniques for programming a computer system in a text based environment to implement his solution the efficiency with which the computer system can be utilized often is reduced.

To overcome the above shortcomings various graphical programming environments now exist which allow a user to construct a graphical program or graphical diagram also referred to as a block diagram. U.S. Pat. Nos. 4 901 221 4 914 568 5 291 587 5 301 301 and 5 301 336 among others to Kodosky et al disclose a graphical programming environment which enables a user to easily and intuitively create a graphical program. Graphical programming environments such as that disclosed in Kodosky et al can be considered a higher and more intuitive way in which to interact with a computer. A graphically based programming environment can be represented at a level above text based high level programming languages such as C Basic Java etc.

A user may assemble a graphical program by selecting various icons or nodes which represent desired functionality and then connecting the nodes together to create the program. The nodes or icons may be connected by lines representing data flow between the nodes control flow or execution flow. Thus the block diagram may include a plurality of interconnected icons such that the diagram created graphically displays a procedure or method for accomplishing a certain result such as manipulating one or more input variables and or producing one or more output variables. In response to the user constructing a diagram or graphical program using the block diagram editor data structures and or program instructions may be automatically constructed which characterize an execution procedure that corresponds to the displayed procedure. The graphical program may be compiled or interpreted by a computer.

A graphical program may have a graphical user interface. For example in creating a graphical program a user may create a front panel or user interface panel. The front panel may include various graphical user interface elements or front panel objects such as user interface controls and or indicators that represent or display the respective input and output that will be used by the graphical program and may include other icons which represent devices being controlled.

Thus graphical programming has become a powerful tool available to programmers. Graphical programming environments such as the National Instruments LabVIEW product have become very popular. Tools such as LabVIEW have greatly increased the productivity of programmers and increasing numbers of programmers are using graphical programming environments to develop their software applications. In particular graphical programming tools are being used for test and measurement data acquisition process control man machine interface MMI supervisory control and data acquisition SCADA applications modeling simulation image processing machine vision applications and motion control among others.

Many text based programming languages such as C BASIC Java etc. have an inherent control flow because statements execute in the order in which they appear in the program. In contrast for many types of graphical programs data flow is the main principle governing program execution. In other words in a graphical program that is based on a data flow model a node may execute when all data inputs have arrived at the node s input terminals. The node may then supply data to its output terminals when the node has finished executing and this data may then pass to input terminals of other nodes in the diagram that are connected to the node s output terminals. Thus for this type of graphical program execution of different portions of the program is data driven. Thus in a pure data flow model execution order for different portions of the graphical program is not necessarily guaranteed.

Therefore for many data flow based graphical programs it is necessary to introduce a layer of control flow over the basic data flow model. It is often necessary to explicitly specify an execution order for different portions of a graphical program to force the portions to execute in a desired sequential order.

According to one embodiment of the invention a loop may be included in a graphical program. A plurality of graphical code portions may be included in the graphical program such that the graphical code portions are associated with the loop. During execution of the graphical program the loop may execute the graphical code portions for a plurality of iterations. The loop may be configured with first execution timing information that controls execution timing for the iterations of the loop.

A sequential order of execution may be configured for the graphical code portions executed in each iteration of the loop. Also second execution timing information may be configured for one or more of the graphical code portions.

The graphical program may then be executed. During execution of the graphical program the loop executes the graphical code portions for a plurality of iterations where each iteration is executed in accordance with the first execution timing information. In each iteration of the loop the graphical code portions are executed in the sequential order and in accordance with the second execution timing information.

In various embodiments the steps above may be performed in any of various ways. In one embodiment including the loop in the graphical program may comprise including a timed loop node in the graphical program. The timed loop node may be configured with the first execution timing information. In one embodiment the user may include a timed sequence structure node within the timed loop node and configure the timed sequence structure node with the second execution timing information. Thus in each iteration of the timed loop the graphical code portions associated with the frames of the timed sequence structure node may be executed according to the second execution timing information. For example the user may configure the timing of the timed loop node and the timed sequence structure node so that the timed loop executes according to the desired execution period and other timing criteria and so that the frames of the timed sequence structure execute with the desired timing at each repetition of the timed loop.

In another embodiment the graphical programming development environment may provide an integrated structure a combination structure node that combines functionality of the timed loop and the timed sequence structure. Such a combination structure node is also referred to herein as a timed loop with frames structure node.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The following references are hereby incorporated by reference in their entirety as though fully and completely set forth herein 

U.S. Pat. No. 4 914 568 titled Graphical System for Modeling a Process and Associated Method issued on Apr. 3 1990.

U.S. Pat. No. 5 481 741 titled Method and Apparatus for Providing Attribute Nodes in a Graphical Data Flow Environment .

U.S. Pat. No. 6 219 628 titled System and Method for Configuring an Instrument to Perform Measurement Functions Utilizing Conversion of Graphical Programs into Hardware Implementations filed Aug. 18 1997.

U.S. patent application Publication No. 20010020291 Ser. No. 09 745 023 titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information filed Dec. 20 2000.

U.S. patent application Ser. No. 09 976 726 titled System and Method for Enabling a Graphical Program to Respond to User Interface Events filed Oct. 12 2001.

U.S. patent application Ser. No. 09 832 997 titled System and Method for Creating a Graphical Program Including a Plurality of Portions to be Executed Sequentially filed Apr. 10 2001.

U.S. patent application Ser. No. 10 893 745 titled Graphically Representing Timing in a Graphical Program filed Jul. 16 2004.

U.S. provisional application Ser. No. 60 601 692 titled Timed Sequence Structure and Timed Loop with Sequence Frames filed Aug. 13 2004.

U.S. provisional application Ser. No. 60 601 598 titled Combination Structure Nodes in a Graphical Program filed Aug. 13 2004.

U.S. provisional application Ser. No. 60 601 948 titled Graphical Programming System with Deterministic Communication filed Aug. 16 2004.

Memory Medium Any of various types of memory devices or storage devices. The term memory medium is intended to include an installation medium e.g. a CD ROM floppy disks or tape device a computer system memory or random access memory such as DRAM DDR RAM SRAM EDO RAM Rambus RAM etc. or a non volatile memory such as a magnetic media e.g. a hard drive or optical storage. The memory medium may comprise other types of memory as well or combinations thereof. In addition the memory medium may be located in a first computer in which the programs are executed or may be located in a second different computer which connects to the first computer over a network such as the Internet. In the latter instance the second computer may provide program instructions to the first computer for execution. The term memory medium may include two or more memory mediums which may reside in different locations e.g. in different computers that are connected over a network.

Carrier Medium a memory medium as described above as well as signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a bus network and or a wireless link.

Programmable Hardware Element includes various types of programmable hardware reconfigurable hardware programmable logic or field programmable devices FPDs such as one or more FPGAs Field Programmable Gate Arrays or one or more PLDs Programmable Logic Devices such as one or more Simple PLDs SPLDs or one or more Complex PLDs CPLDs or other types of programmable hardware. A programmable hardware element may also be referred to as reconfigurable logic .

Medium includes one or more of a memory medium carrier medium and or programmable hardware element encompasses various types of mediums that can either store program instructions data structures or can be configured with a hardware configuration program.

Program the term program is intended to have the full breadth of its ordinary meaning. The term program includes 1 a software program which may be stored in a memory and is executable by a processor or 2 a hardware configuration program useable for configuring a programmable hardware element.

Software Program the term software program is intended to have the full breadth of its ordinary meaning and includes any type of program instructions code script and or data or combinations thereof that may be stored in a memory medium and executed by a processor. Exemplary software programs include programs written in text based programming languages such as C C Pascal Fortran Cobol Java assembly language etc. graphical programs programs written in graphical programming languages assembly language programs programs that have been compiled to machine language scripts and other types of executable software. A software program may comprise two or more software programs that interoperate in some manner.

Hardware Configuration Program a program e.g. a netlist or bit file that can be used to program or configure a programmable hardware element.

Graphical Program A program comprising a plurality of interconnected nodes or icons wherein the plurality of interconnected nodes or icons visually indicate functionality of the program.

The following provides examples of various aspects of graphical programs. The following examples and discussion are not intended to limit the above definition of graphical program but rather provide examples of what the term graphical program encompasses 

The nodes in a graphical program may be connected in one or more of a data flow control flow and or execution flow format. The nodes may also be connected in a signal flow format which is a subset of data flow.

Exemplary graphical program development environments which may be used to create graphical programs include LabVIEW DasyLab DiaDem and Matrixx SystemBuild from National Instruments Simulink from the MathWorks VEE from Agilent WiT from Coreco Vision Program Manager from PPT Vision SoftWIRE from Measurement Computing Sanscript from Northwoods Software Khoros from Khoral Research SnapMaster from HEM Data VisSim from Visual Solutions ObjectBench by SES Scientific and Engineering Software and VisiDAQ from Advantech among others.

The term graphical program includes models or block diagrams created in graphical modeling environments wherein the model or block diagram comprises interconnected nodes or icons that visually indicate operation of the model or block diagram exemplary graphical modeling environments include Simulink SystemBuild VisSim Hypersignal Block Diagram etc.

A graphical program may be represented in the memory of the computer system as data structures and or program instructions. The graphical program e.g. these data structures and or program instructions may be compiled or interpreted to produce machine language that accomplishes the desired method or process as shown in the graphical program.

Input data to a graphical program may be received from any of various sources such as from a device unit under test a process being measured or controlled another computer program a database or from a file. Also a user may input data to a graphical program or virtual instrument using a graphical user interface e.g. a front panel.

A graphical program may optionally have a GUI associated with the graphical program. In this case the plurality of interconnected nodes are often referred to as the block diagram portion of the graphical program.

Node In the context of a graphical program an element that may be included in a graphical program. A node may have an associated icon that represents the node in the graphical program as well as underlying code or data that implements functionality of the node. Exemplary nodes include function nodes terminal nodes structure nodes etc.

Data Flow Graphical Program or Data Flow Diagram A graphical program or diagram comprising a plurality of interconnected nodes wherein the connections between the nodes indicate that data produced by one node is used by another node.

Graphical User Interface this term is intended to have the full breadth of its ordinary meaning. The term Graphical User Interface is often abbreviated to GUI . A GUI may comprise only one or more input GUI elements only one or more output GUI elements or both input and output GUI elements.

The following provides examples of various aspects of GUIs. The following examples and discussion are not intended to limit the ordinary meaning of GUI but rather provide examples of what the term graphical user interface encompasses 

A GUI may comprise a single window having one or more GUI Elements or may comprise a plurality of individual GUI Elements or individual windows each having one or more GUI Elements wherein the individual GUI Elements or windows may optionally be tiled together.

A GUI may be associated with a graphical program. In this instance various mechanisms may be used to connect GUI Elements in the GUI with nodes in the graphical program. For example when Input Controls and Output Indicators are created in the GUI corresponding nodes e.g. terminals may be automatically created in the graphical program or block diagram. Alternatively the user can place terminal nodes in the block diagram which may cause the display of corresponding GUI Elements front panel objects in the GUI either at edit time or later at run time. As another example the GUI may comprise GUI Elements embedded in the block diagram portion of the graphical program.

Front Panel A Graphical User Interface that includes input controls and output indicators and which enables a user to interactively control or manipulate the input being provided to a program and view output of the program while the program is executing.

A front panel is a type of GUI. A front panel may be associated with a graphical program as described above.

In an instrumentation application the front panel can be analogized to the front panel of an instrument. In an industrial automation application the front panel can be analogized to the MMI Man Machine Interface of a device. The user may adjust the controls on the front panel to affect the input and view the output on the respective indicators.

Graphical User Interface Element an element of a graphical user interface such as for providing input or displaying output. Exemplary graphical user interface elements comprise input controls and output indicators

Input Control a graphical user interface element for providing user input to a program. Exemplary input controls comprise dials knobs sliders input text boxes etc.

Output Indicator a graphical user interface element for displaying output from a program. Exemplary output indicators include charts graphs gauges output text boxes numeric displays etc. An output indicator is sometimes referred to as an output control .

Computer System any of various types of computing or processing systems including a personal computer system PC mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA television system grid computing system or other device or combinations of devices. In general the term computer system can be broadly defined to encompass any device or combination of devices having at least one processor that executes instructions from a memory medium.

Measurement Device includes instruments data acquisition devices smart sensors and any of various types of devices that are operable to acquire and or store data. A measurement device may also optionally be further operable to analyze or process the acquired or stored data. Examples of a measurement device include an instrument such as a traditional stand alone box instrument a computer based instrument instrument on a card or external instrument a data acquisition card a device external to a computer that operates similarly to a data acquisition card a smart sensor one or more DAQ or measurement cards or modules in a chassis an image acquisition device such as an image acquisition or machine vision card also called a video capture board or smart camera a motion control device a robot having machine vision and other similar types of devices. Exemplary stand alone instruments include oscilloscopes multimeters signal analyzers arbitrary waveform generators spectroscopes and similar measurement test or automation instruments.

A measurement device may be further operable to perform control functions e.g. in response to analysis of the acquired or stored data. For example the measurement device may send a control signal to an external system such as a motion control system or to a sensor in response to particular data. A measurement device may also be operable to perform automation functions i.e. may receive and analyze data and issue automation control signals in response.

As shown in the computer system may include a display device operable to display the graphical program as the graphical program is created and or executed. The display device may also be operable to display a graphical user interface or front panel of the graphical program during execution of the graphical program. The graphical user interface may comprise any type of graphical user interface e.g. depending on the computing platform.

As shown in in one embodiment the computer system may be coupled to another computer system via a network. The computer systems and may operate together to perform various operations described herein.

The computer system may include a memory medium s on which one or more computer programs or software components according to one embodiment of the present invention may be stored. For example the memory medium may store one or more graphical programs configured as described below. Also the memory medium may store a graphical programming development environment application used to create such graphical programs and or an execution subsystem used to execute the graphical programs. The memory medium may also store operating system software as well as other software for operation of the computer system.

Embodiments of the present invention may be involved with performing test and or measurement functions controlling and or modeling instrumentation or industrial automation hardware modeling and simulation functions e.g. modeling or simulating a device or product being developed or tested etc. Exemplary test applications where the graphical program may be used include hardware in the loop testing and rapid control prototyping among others.

However it is noted that the present invention can be used for a plethora of applications and is not limited to the above applications. In other words applications discussed in the present description are exemplary only and the present invention may be used in any of various types of systems. Thus graphical programs as described herein may be used in any of various types of applications including the control of other types of devices such as multimedia devices video devices audio devices telephony devices Internet devices etc. as well as general purpose software applications such as word processing spreadsheets network control network monitoring financial applications games etc.

The computer may operate with the one or more instruments to analyze measure or control a unit under test UUT or process . In one embodiment the computer may execute a graphical program involved with the instrumentation control system where timing of elements within the graphical program has been configured according to one or more of the methods described below.

The one or more instruments may include a GPIB instrument and associated GPIB interface card a data acquisition board and associated signal conditioning circuitry a VXI instrument a PXI instrument a video device or camera and associated image acquisition or machine vision card a motion control device and associated motion control interface card and or one or more computer based instrument cards among other types of devices. The computer system may couple to and operate with one or more of these instruments. The instruments may be coupled to a unit under test UUT or process or may be coupled to receive field signals typically generated by transducers. The system may be used in a data acquisition and control application in a test and measurement application an image processing or machine vision application a process control application a man machine interface application a simulation application or a hardware in the loop validation application among other types of applications.

The computer may operate with the one or more devices to a process or device to perform an automation function such as MMI Man Machine Interface SCADA Supervisory Control and Data Acquisition portable or distributed data acquisition process control advanced analysis or other control. In one embodiment the computer may execute a graphical program involved in performing the automation function where timing of elements within the graphical program has been configured according to one or more of the methods described below.

The one or more devices may include a data acquisition board and associated signal conditioning circuitry a PXI instrument a video device and associated image acquisition card a motion control device and associated motion control interface card a fieldbus device and associated fieldbus interface card a PLC Programmable Logic Controller a serial instrument and associated serial interface card or a distributed data acquisition system such as the Fieldpoint system available from National Instruments among other types of devices.

In one embodiment one or more graphical programs may be created which are used in performing rapid control prototyping. Rapid Control Prototyping RCP generally refers to the process by which a user develops a control algorithm and quickly executes that algorithm on a target controller connected to a real system. The user may develop the control algorithm using a graphical program and the graphical program may execute on the controller e.g. on a computer system or other device . The computer system may be a platform that supports real time execution e.g. a device including a processor that executes a real time operating system RTOS or a device including a programmable hardware element.

In one embodiment one or more graphical programs may be created which are used in performing Hardware in the Loop HIL simulation. Hardware in the Loop HIL refers to the execution of the plant model in real time to test operation of a real controller . For example once the controller has been designed it may be expensive and complicated to actually test the controller thoroughly in a real plant e.g. a real car. Thus the plant model implemented by a graphical program is executed in real time to make the real controller believe that it is connected to a real plant e.g. a real engine.

In the embodiments of B and B above one or more of the various devices may couple to each other over a network such as the Internet an Intranet or a LAN. In one embodiment the user operates to select a target device from a plurality of possible target devices for programming or configuration using a graphical program. Thus the user may create a graphical program on a computer and use execute the graphical program on that computer or may deploy the graphical program to a target device for remote execution on the target device that is remotely located from the computer and coupled to the computer through a network.

Graphical software programs which perform data acquisition analysis and or presentation e.g. for measurement instrumentation control industrial automation modeling or simulation such as in the applications shown in B and B may be referred to as virtual instruments.

The computer may include at least one central processing unit or CPU processor which is coupled to a processor or host bus . The CPU may be any of various types including an x86 processor e.g. a Pentium class a PowerPC processor a CPU from the SPARC family of RISC processors as well as others. A memory medium typically comprising RAM and referred to as main memory is coupled to the host bus by means of memory controller . The main memory may store a graphical program configured with timing according to one or more of the methods described herein. The main memory may also store operating system software as well as other software for operation of the computer system.

The host bus may be coupled to an expansion or input output bus by means of a bus controller or bus bridge logic. The expansion bus may be the PCI Peripheral Component Interconnect expansion bus although other bus types can be used. The expansion bus includes slots for various devices such as described above. In the illustrated embodiment the computer further comprises a video display subsystem and hard drive coupled to the expansion bus .

As shown a device may also be connected to the computer. In one embodiment the device may include a processor and memory which execute a real time operating system. In another embodiment the device may also or may instead include a programmable hardware element. In one embodiment the computer system may be operable to deploy a graphical program to the device for execution of the graphical program on the device . The deployed graphical program may take the form of graphical program instructions or data structures that directly represents the graphical program. Alternatively the deployed graphical program may take the form of text code e.g. C code generated from the graphical program. As another example the deployed graphical program may take the form of compiled code that was generated from either the graphical program or from text code that in turn was generated from the graphical program.

Many computerized applications require operations to be performed with precise timing. In particular many operations need to be performed as a loop i.e. need to be performed repetitively for multiple iterations where each iteration of the loop is precisely timed. Other operations need to be performed as a loop where each iteration of the loop is triggered by an event being generated. An entity referred to herein as a timed loop may enable these behaviors to be implemented for a graphical program. is a flowchart diagram illustrating one embodiment of a method for creating a graphical program operable to execute a timed loop. As described below the user may be able to specify various aspects of the timing of the timed loop. It is noted that illustrates a representative embodiment and alternative embodiments are contemplated. Also various elements may be combined omitted or performed in different orders. The method shown in may be used in conjunction with any of the systems or devices shown in the above Figures among other systems and devices.

The graphical program may be created in response to user input e.g. the user may create the graphical program by placing or dragging and dropping icons or nodes on the display and interconnecting the nodes in a desired fashion. In response to the user assembling the graphical program data structures may be created and stored which represent the graphical program. The nodes or icons may be interconnected in one or more of a data flow control flow or execution flow format. The graphical program may thus comprise a plurality of interconnected nodes or icons that visually indicate the functionality of the program. As noted above the graphical program may comprise a block diagram and may also include a user interface portion or front panel portion. Where the graphical program includes a user interface portion the user may optionally assemble the user interface on the display. As one example the user may use the LabVIEW graphical programming development environment to create the graphical program.

According to one embodiment the timed loop may be represented as a particular node or icon in the graphical program. Thus as shown in of a timed loop may be displayed in the graphical program in response to user input. For example during the process of assembling the graphical program as described above the user may cause the timed loop to be included in the graphical program by selecting a particular timed loop node or icon from a palette issuing a menu command to display the timed loop etc. In various embodiments the user may perform any of various actions to cause the timed loop to be displayed or included in the graphical program. Also the timed loop may have any kind of visual appearance within the graphical program. illustrates one exemplary icon that intuitively represents a timed loop.

As described above the loop may represent a portion of the graphical program which is executed repetitively during execution of the graphical program. Thus in the graphical source code i.e. one or more nodes to be executed repetitively may be associated with the timed loop in response to user input. In various embodiments the graphical source code may be associated with the timed loop in various ways. For the exemplary timed loop of the graphical source code may be associated with the timed loop by placing it inside the loop border . Thus the user may position one or more nodes or icons within the loop border such as function nodes sub program nodes etc. During execution of the graphical program the nodes or icons within the loop border may be executed at each iteration of the timed loop. The nodes or icons within the loop border may also be interconnected similarly as other nodes in the graphical program to indicate data flow control flow and or execution flow.

In other embodiments the graphical source code to be executed at each iteration of the timed loop may be associated with the timed loop in other ways. For example in one alternative embodiment the timed loop may have a separate block diagram which can be viewed separately from the main block diagram in which the timed loop node or icon is displayed. The user may arrange and interconnect nodes on the timed loop s block diagram similarly as for the main block diagram. During execution of the graphical program nodes on the timed loop s block diagram may be executed at each iteration of the timed loop. In another embodiment the timed loop may be configured with a reference to a portion of code to be executed at each iteration of the timed loop and this portion of code may be created or stored separately from the graphical program in which the timed loop node or icon is included.

In the timed loop may be configured with timing information in response to user input. In one embodiment the timing information may include an execution period which specifies a desired period at which the timed loop should execute during execution of the graphical program. In one embodiment the execution period controls the time at which execution begins for each iteration of the timed loop. For example if the execution period is 100 ms then iteration N of the timed loop may begin at time T iteration N 1 may begin at time T 100 ms iteration N 2 may begin at time T 200 ms etc.

In one embodiment the execution period for the timed loop may be based on a particular timing source. The user may specify a timing source to associate with the timed loop where the timing source comprises an entity useable as a source of timing and scheduling for the timed loop. The timing of the timed loop may be based on a periodic signal or pulse provided by the timing source. In one embodiment the units for the execution period of the timed loop may be based on the timing source. For example the user may simply specify a period of 100 without specifying a time unit. This may signify that a new iteration of the timed loop should begin at every 100th tick or pulse of the timing source. For a 1 kHz timing source this may correspond to a period of 100 ms. For a 1 MHz timing source this may correspond to a period of 100 s. In another embodiment the user may specify both a number of ticks and the desired units e.g. may directly specify a period of 100 ms.

In various embodiments the timed loop may be configured with any kind of timing source. One example of a timing source that may be used to control timing of the timed loop is a 1 kHz system clock provided by a PC computer system such as the computer system discussed above. Another example is the 1 MHz timer of RIO hardware boards from National Instruments Corp. In another embodiment the timing source may be based on internal countdown registers of the processor of the computer system that executes the graphical program. For example in one embodiment countdown registers of a Pentium processor may be utilized as a 1 MHz timing source. In other embodiments any of various other kinds of timing sources may be utilized. Examples of other timing sources include analog input analog output AI AO counter CTR and digital IO DIO ports on DAQ or other hardware boards.

In one embodiment the ticks or pulses of a timing source may not occur at regular intervals in time. Thus the timing of loop iterations may be controlled relative to ticks or pulses of the timing source but the iterations may or may not occur at regular intervals in time. For example in one embodiment the timing of the iterations of the timed loop may be based on an event where the event may or may not be generated at regular intervals in time. For example in one embodiment configuring the timed loop with timing information may comprise associating one or more events with the timed loop in response to user input. When an event associated with the timed loop is generated during execution of the graphical program an iteration of the timed loop may occur in response. In other words the graphical source code associated with the timed loop may execute each time one of the associated events is generated. Thus in this embodiment the generation of an event associated with the timed loop may constitute a tick or pulse of the timing source for the timed loop. For some applications it may be desirable to base the timing of a process performed by the graphical program on the generation of an event in this manner e.g. to configure the graphical program to perform an action or process each time a particular event is generated.

In one embodiment the timed loop may be configured to iterate in response to each occurrence of the event s associated with the timed loop i.e. a new iteration of the timed loop may begin each time the associated event is generated. In another embodiment the timed loop may be configured to iterate only after the event has been generated a certain number of times. For example where an event A has been associated with or specified as the timing source for the timed loop the user may specify an execution period of 50 to signify that a new iteration of the timed loop should begin every 50th time the event A is generated.

In various embodiments any kinds of events may be associated with or specified as the timing source for the timed loop including software generated or software based events and or hardware generated or hardware based events. In one embodiment one or more events associated with or generated by hardware devices may be associated with the timed loop. Thus the timed loop may iterate in response to an event being generated by a hardware device during execution of the graphical program. As one example the graphical program may perform a measurement function and may include a timed loop configured to iterate in response to each instance of an event generated by a data acquisition device. Other examples of events that may be associated with the timed loop include interrupts system events timer events etc.

In another embodiment one or more events associated with network operation may be associated with the timed loop. For example the timed loop may be configured to wake up or iterate in response to packet arrival event being generated where the packet arrival event indicates that a network packet has been received. As other examples the timed loop may be configured to iterate in response to a buffer full event where the buffer full event indicates that a network buffer is full or the timed loop may be configured to iterate in response to other kinds of buffer based events such as a buffer empty event or a buffer half full event.

In another embodiment one or more user interface events may be associated with the timed loop. The graphical program may have a graphical user interface that includes a plurality of user interface elements. Various user interface events may be associated with the user interface elements on the graphical user interface. For example user interface events may be generated in response to user actions performed on the graphical user interface such as clicking a button invoking a menu typing into a string control etc. Thus the timed loop may be configured to iterate in response to any of various kinds of user interface events.

In one embodiment the events associated with the timed loop may be events that are internal to the graphical program or internal to a graphical programming development environment with which the graphical program is associated. For example the events may include user interface event associated with a native user interface control on the graphical program s user interface. In another embodiment one or more events that are external to the graphical program or external to the graphical programming development environment may be associated with the timed loop. For example events such as ActiveX events or .NET events may be associated with the timed loop. As another example DAQ events or events generated by hardware devices may be associated with the timed loop as noted above.

Thus in various embodiments the user may associate any kind of timing source with the timed loop for acting as a trigger for iterations of the timed loop where the timing source may or may not cause iterations of the loop to occur at regular time intervals. In one embodiment the user may also specify a timing source name to identify a particular instance of the timing source associated with the timed loop described below .

In one embodiment the graphical programming development environment may enable users or vendors to construct their own timing sources. For example an interface to which a timing source must comply may be defined and users or vendors may create a timing source component or module that implements this interface. Ticks or pulses of the timing source or events generated by the timing source may be based on any arbitrary hardware or software function. The timed loop structure may be abstracted from the timing source e.g. may simply receive notification of ticks or events generated by the timing source but may not have any knowledge about what causes these ticks or events. This abstraction may facilitate the use of a plug in framework in which users or vendors may plug in or utilize custom timing sources that they create.

As an example a third party vendor of a particular measurement device may want users of the graphical programming development environment to be able to utilize the measurement device and in particular may want users to be able to control the timing of a loop based on an event generated by or based on a hardware function of the measurement device. Thus the vendor may create custom code that implements the interface defined for timing sources where the custom code is operable to generate ticks or events based on the operation of the measurement device. The vendor may provide the custom timing source to users e.g. as a software component or module so that the users can use the timing source to control timed loops in their graphical programs.

Referring again to of in one embodiment the timed loop may also be configured with an offset. The offset may specify the amount of time or the number of ticks or events generated by the timing source by which to delay the execution of the first iteration of the timed loop. Units for the offset may be based on the timing source similarly as described above. For example if the user specifies an offset of 30 and a period of 100 and if the timing source for the timed loop is a 1 KHz clock then the first iteration of the timed loop may begin executing at time T 30 ms and subsequent iterations may begin executing at times of 130 ms 230 ms 330 ms etc. As described below a timing source may effectively start when all the timed loops that utilize the timing source are ready to execute. I.e. time T 0 may occur as soon as all the timed loops that utilize the timing source are ready to execute. The offset specified for a timed loop may refer to an offset from the time when the timing source effectively starts i.e. an offset from time T 0.

If the graphical program includes multiple timed loops the loop offset values can be used to synchronize the timed loops or align their phases. For example the user can configure two timed loops to use the same instance of a timing source by specifying the same name for the timing source in the configuration dialog for each timed loop e.g. by specifying the same name in the Source name field of the configuration dialog of . For example the user can specify an offset of 0 for one timed loop and an offset of 100 for another timed loop. If the two timed loops have the same period then each Nth pair of iterations of the timed loops may be separated by 100 ticks of the timing source. For example if the period is 150 then the first timed loop may iterate at times T 0 T 150 T 300 etc. and the second timed loop may iterate at times T 100 T 250 T 400 etc.

In one embodiment the timed loop may also be configured with a priority. In one embodiment the graphical program may include multiple timed loops and the priority values of the timed loops may be used in prioritizing execution of the timed loops. The priority of each timed loop specifies when the timed loop executes relative to other timed loops. Priority settings may be utilized to create applications with multiple tasks that can preempt each other in the same graphical program. In various embodiments any desired priority system may be utilized. In one embodiment the higher the value the user specifies for the priority of a timed loop the higher the priority the timed loop has relative to other timed loops in the graphical program. In one embodiment priorities may range from 1 to 2 147 480 000.

In one embodiment one or more nodes e.g. sub program nodes in the graphical program may be configured to execute at a time critical priority. In one embodiment timed loops may execute at a priority below the time critical priority but above high priority which means that timed loops may execute in the data flow of the block diagram ahead of any node not configured to run at a time critical priority.

In one embodiment the timed loop may also be configured with a timeout value. As described above in one embodiment the timed loop may be configured to wake up and perform a loop iteration in response to an event being generated. However it is possible that the event that is supposed to trigger an iteration of the loop to execute may never be generated or may not be generated within an expected time frame. Thus the loop may effectively be stuck waiting for an event that never happens or happens late. The user may specify a timeout value e.g. a value in milliseconds to handle this situation. In one embodiment if the loop is not normally awakened before the timeout value elapses e.g. as measured from the time the last iteration of the loop finished executing then the loop may be awakened due to expiration of the timeout. As described below in one embodiment the timed loop may be passed a wakeup reason each time an iteration of the loop begins executing i.e. a data item indicating the reason the iteration of the timed loop began executing. In this situation the timed loop may be passed a wakeup reason indicating that the reason the loop iteration began is that the timeout expired. The user may include graphical source code in the timed loop to evaluate the wakeup reason and take appropriate action in the case of a timeout.

In various embodiments the timed loop may be configured with the timing information in in any of various ways. In one embodiment the timed loop may include one or more terminals to which the user can connect a wire s specifying the timing information. For example the timed loop of includes an input node also referred to as a configuration node to the left of the loop border. The input node includes various terminals to which the user may connect wires to dynamically set the respective properties during execution of the graphical program. For example the terminal labeled with the dt symbol represents the execution period of the timed loop. Thus the user can connect a wire to this terminal to specify the desired execution period for the timed loop. The input node may also include terminals for connecting wires to dynamically specify the loop s timing source priority offset mode and other timing information.

In other embodiments the user may configure the timing information of the timed loop in other ways. As one example the user may interact with a dialog box property page or wizard to statically configure various properties affecting the timing of the timed loop. For example the user may invoke a configuration dialog such as illustrated in e.g. by invoking a Configure option on a context menu for the timed loop or configuration node or by double clicking on the loop border or configuration node . The user may then interact with the configuration dialog to specify information such as a timing source period offset priority or other timing information. In one embodiment the user may utilize the configuration dialog to specify other properties of the timed loop as well such as a loop name whether or not to log timing data for the timed loop a timeout value for the timed loop a late mode defining behavior of the timed loop on late iterations etc.

In one embodiment the user may have the option to set properties of the timed loop both statically by using the configuration dialog and dynamically by connecting wires to terminals on the block diagram of the graphical program. For example checking the Use terminal checkboxes on the configuration dialog may cause the respective terminals to appear in the input node in . The user may then connect wires to the terminals in the input node to cause the respective properties to be set dynamically during execution of the graphical program. In the example the Use terminal checkboxes for the period and priority are checked. Thus the user can connect wires to respective terminals for these properties to cause the properties to be set dynamically during execution of the graphical program whereas other properties regarding timing information for the timed loop are statically configured through the configuration dialog.

If the user configures one or more properties for the timed loop e.g. the period priority offset etc. using the configuration dialog then the specified values may appear in the configuration node to the left of the timed loop. This allows the user to see how the timed loop is configured by simply looking at the block diagram of the graphical program i.e. by looking at the configuration node of the timed loop. In prior graphical programming systems the user typically cannot see how a loop or other structure node is configured by viewing information directly on the block diagram but rather is required to invoke a dialog or other window to view the configuration information.

Thus in one embodiment the configuration node may display terminals for specific properties that the user requested e.g. by checking a Use terminal checkbox in a configuration dialog as described above where the user can connect wires to the terminals to cause the respective properties to be dynamically set. The configuration node may also display values for statically configured properties of the timed loop where the values were specified using a configuration dialog as described above. For example the configuration node may include a plurality of displayed rows or fields where each row or field represents one of the properties of the timed loop. Some of the rows or fields i.e. the ones corresponding to properties that are set dynamically may visually indicate that they are terminals to which the user can connect wires. Other rows or fields i.e. the ones corresponding to properties that are statically configured through the configuration dialog may simply display the value specified by the user but may not visually indicate that they are terminals to which the user can connect wires.

However in one embodiment the user may still be able to connect a wire to a row or field corresponding to a property that is statically configured even though the row or field may not currently include or may not visually indicate a terminal for connecting a wire. The act of connecting a wire to the row or field may cause the row or field to change so that it includes or visually indicates a terminal. Thus the respective property may be automatically changed from a statically configured property to a property that is dynamically set by data from the connected wire.

In one embodiment the user may also be able to configure how information in the configuration node is displayed. For example the user may configure the properties shown in the configuration node to be represented either iconically and or textually. In one embodiment each row or field in the configuration node may by default display a small icon that visually represents the respective property of the timed loop. For example in the configuration node shown in a clock icon represents the timing source of the timed loop a staggered 3 2 1 icon represents the priority of the timed loop etc. The user may be able to request that text names for the properties be displayed in addition to or instead of the icons e.g. by selecting a menu item from a context menu for the configuration node .

Also in one embodiment the user may be able to specify which properties of the timed loop to show in the configuration node . For example the user may want some of the properties to be displayed and others to be hidden to avoid clutter on the block diagram. In various embodiments the user may be able to specify which properties to show in the configuration node in any of various ways. For example the user may be able to request that only the properties that are dynamically set i.e. the ones to which wires are connected be shown in the configuration node or the user may interact with a dialog box to check boxes to specify which properties to show or hide.

A configuration dialog such as the one shown in may also enable the user to select a timing source for the timed loop. In the example of the user has selected to use a 1 kHz PC timer as the timing source. The timing sources that appear in the Source type list box in the configuration dialog may depend on the configuration of the user s computer system. For example if one or more known hardware devices with known timing sources are connected to the computer system then the timing sources of these hardware devices may also appear in the list box. As one example if a National Instruments RIO hardware board is installed in the computer system then the 1 MHz RIO timer may appear as another timing source that the user can select. As described above in one embodiment the graphical programming development environment may provide a framework that allows users or third party vendors to create their own custom timing sources. Any custom timing sources that have been created may be registered with the graphical programming development environment and may appear as timing sources that the user can select in the configuration dialog.

In another embodiment the user may configure a timing source to be dynamically or programmatically set for the timed loop by adding graphical source code to the block diagram of the graphical program where the graphical source code specifies the timing source. For example the user may include one or more nodes in the graphical program to set up a timing source from a hardware device and may connect a wire specifying the timing source to a timing source terminal on the input node .

As discussed above in one embodiment one or more events may be associated with the timed loop. Any desired technique may be used to associate the one or more events with the timed loop. In one embodiment the user may utilize a graphical user interface to associate one or more events with the timed loop e.g. by interacting with a dialog box or wizard. For example the graphical user interface may display a list of events and allow the user to select the events of interest. In another embodiment the user may configure the block diagram of the graphical program with information specifying the one or more events e.g. by connecting one or more wires representing the one or more events to the timed loop.

In one embodiment the one or more events to associate with the timed loop may be dynamically determined during execution of the graphical program. Also the one or more events may be dynamically associated with the loop during execution of the graphical program or the events associated with the timed loop may be dynamically changed. In one embodiment a registration node or nodes may be included in the block diagram of the graphical program. The registration node may be executed to dynamically register an event with the timed loop. Similarly the graphical program may include one or more nodes operable to dynamically un register an event or dynamically change the events associated with the timed loop.

Occasionally an iteration of a timed loop might execute later than the time specified by the user. For example the timed loop may be configured with an execution period of 10 ms but an aberrant condition or preemption by another timed loop may cause a particular iteration of the timed loop to take longer than 10 ms to complete thus causing the next iteration of the loop to be late. For different applications it may be desirable for the timed loop to behave in different ways when late iterations occur. In one embodiment the user may be able to specify different modes to determine how the timed loop handles late iterations.

In one embodiment the user may be able to specify the following options for handling late iterations of a timed loop 

For example if the user specifies a period of 100 ms and an offset of 30 ms for the timed loop then the first loop iteration is expected to begin execution 30 ms after the first timing source starts running and in multiples of 100 ms after that i.e. at 130 ms 230 ms 330 ms etc. However it is possible for example that the first loop iteration occurs late e.g. due to data flow necessary for the timed loop to begin taking longer than necessary to reach the timed loop in the block diagram of the graphical program. For example the timed loop may not be ready to begin execution until 240 ms have elapsed.

Because other timed loops or hardware devices might already be running at the schedule originally specified the user might want to align the late timed loop with the already running global schedule which means the timed loop should align itself as quickly as possible with the originally specified schedule. In this case the first loop iteration would begin execution at 330 ms and subsequent iterations would continue to run at multiples of 100 ms i.e. at 430 ms 530 ms etc.

However if aligning the timed loop with other timed loops or other hardware devices is not important then the user may want the timed loop to begin execution as soon as possible and use the current time as its actual offset. In this case the first loop iteration would begin execution at 240 ms and subsequent loop iterations would begin at 340 ms 440 ms etc.

In some applications if an iteration of the timed loop occurs late then the timed loop might miss data generated by other timed loops or hardware devices. In one embodiment a buffer may hold data from the missed iterations. In one embodiment the user may want the timed loop to process the missed data before it aligns with the schedule specified. However a timed loop that processes the missed data may cause jitter which is the amount of time that a loop cycle time varies from the specified schedule. Thus in some applications the user may not want the timed loop to process the missed data. If the user does not want to process the missed data the timed loop can ignore older data in the buffer that the loop iterations missed and process only the latest data such as the data available at the next iteration and subsequent iterations.

In one embodiment the user may specify late mode options for handling late timed loop iterations such as described above by using a configuration dialog to statically configure the late mode options. For example the Timed Loop action on late iterations section of the configuration dialog illustrated in allows the user to specify various options. In one embodiment the timed loop may by default discard any data generated during missed iterations and maintain the originally specified schedule. For this mode setting the icon for the Mode property of the configuration node may appear with a D for discard and an M for maintain as illustrated in . The user can remove the checkmark from the Discard missed periods checkbox in the configuration dialog to cause the timed loop to instead process data generated by missed or late loop iterations. For this mode setting the icon for the Mode property of the configuration node may appear with a P for process. The user can remove the checkmark from the Maintain original phase checkbox in the configuration dialog to configure the timed loop to execute on a new schedule based on the execution time of the first iteration of the timed loop.

In one embodiment the late mode options for handling late timed loop iterations may also be configured dynamically or programmatically. For example the user may connect a wire to the Mode property of the configuration node where the wire specifies the desired late mode options. It is noted that in other embodiments the timed loop may be configured to behave according to late modes other than those described above. The section below titled Modes Defining Behavior for Late Timed Loop Iterations describes several other late modes in addition to the ones discussed above.

As described above an iteration of the timed loop that takes longer than the loop s execution period to complete may cause the next iteration of the loop to begin late. Thus in one embodiment the concept of an iteration being late may be based on the execution period of the timed loop. In one embodiment it may also be desirable to define a separate deadline to define lateness where the deadline is different than the loop s execution period. For example the timed loop may have an execution period of 200 s but the user may specify a deadline of 80 s for the timed loop. Thus any iteration that takes longer than 80 s to complete may overrun the deadline and thus finish late. For some applications it may be desirable to ensure that loop iterations complete within a defined deadline that is shorter than the execution period.

As described below in one embodiment the system may be operable to log timing data for the timed loop and present a graphical user interface that allows the user to view the timing data. Loop iterations that overrun the timed loop s deadline may be visually indicated or flagged to make the user aware of the problem. The user may then make adjustments as necessary e.g. by giving the timed loop a higher priority changing the functions performed by the loop to make it run faster or changing other parts of the graphical program so that they do not expect iterations of the timed loop to complete within such a short deadline.

Referring again to in the graphical program may be executed. In various embodiments the graphical program may be executed on any kind of computer system s or reconfigurable hardware as described above. As one example the graphical program may be executed on a computer system such as described above with reference to A A B and B.

The time at which the first iteration of the timed loop begins may depend on the relation of the timed loop to other nodes in the graphical program. In one embodiment the timed loop may begin executing immediately. In another embodiment other nodes may have to execute first before the timed loop can begin execution. For example in a data flow graphical program other nodes may need to execute first to produce data used by the timed loop such as data to set timing information for the loop e.g. data for wires connected to terminals of the input node of the timed loop. Thus in one embodiment one or more ticks of the timing source for the timed loop may occur or one or more instances of events associated with the timed loop may be generated without these ticks or events causing the graphical source code associated with the timed loop to execute or without these ticks or events being counted toward the offset value specified for the timed loop. In other words the ticks or event s associated with the timed loop may cause the timed loop to iterate only after the timed loop is ready for execution. Thus with respect to timing of the timed loop the timing source for the timed loop may effectively start when the timed loop is ready for execution even though actual ticks or events associated with the timing source may occur before then.

Once the timed loop begins execution the timing source and execution period of the timed loop may control the rate at which the timed loop executes. Ticks or pulses of the timing source may occur during execution of the graphical program or an event associated with the timed loop may be generated multiple times during execution of the graphical program. As described above the timed loop may be configured to iterate based on the ticks or based on the generated events e.g. a new iteration of the timed loop may begin in response to each Nth tick of the timing source or in response to every Nth time the associated event is generated. At each iteration of the timed loop the graphical source code associated with the timed loop may be executed as described above with reference to . The graphical source code associated with the loop may be operable to perform any desired operation.

In one embodiment the graphical program may include multiple timed loops that can execute concurrently. The multiple timed loops may enable the graphical program to perform multiple timed activities and control the timing for each activity. The priorities of the respective loops may be utilized to implement a preemptive execution model. In one embodiment the highest priority loop which is ready to execute may preempt all lower priority loops. In one embodiment each timed loop may be executed as a separate thread.

Different timed loops may utilize different timing sources or multiple timed loops may utilize the same timing source. As noted above in one embodiment the user may specify a source name for the timing source of a loop to identify a particular instance of the timing source. If two timed loops are configured with the same source name for the same timing source then both loops may share the same instance of the timing source. In this case timing information such as the offset for each loop is relative to the same starting point. However two timed loops with different names for the same timing source may be governed by different instances of the timing source. In this case timing of the two timed loops may be independent.

The functionality of receiving notification of the generated events or ticks of the timing source and causing a timed loop to iterate in response may be implemented in any way e.g. depending on the particular graphical programming development environment used to create the graphical program and depending on the particular type of timing source or events. For example in one embodiment the graphical program may execute under the management of an execution subsystem of the graphical programming development environment and the execution subsystem may intercept events as they are generated and may invoke execution of the graphical source code associated with the timed loop. The execution subsystem may interface with other software on the computer system to intercept or receive notification of the ticks or events associated with the timed loop. As one example where the timed loop is configured to iterate in response to an event generated by a data acquisition DAQ device the execution subsystem may interface with DAQ software to receive notification of the event.

In one embodiment the execution subsystem may include a timed loop scheduler that manages the execution of timed loops. Based on the timing source type and hardware capability all or some of the events associated with a timed loop may generate interrupts that notify the timed loop scheduler that an event or a timeout occurred. The timed loop scheduler may handle the interrupt check the list of timed loops associated with the timing source and trigger a new iteration of a timed loop if necessary. If there are multiple timed loops the timed loop scheduler may use the priority value of the timed loop that is triggered to determine if the timed loop should preempt a currently executing loop iteration of another timed loop. The timed loop scheduler may also control which timed loop continues its execution after the currently executing timed loop finishes its iteration. The scheduler may also reconfigure a hardware component of the timing source for the next notification.

In another embodiment the graphical program may not execute under an execution subsystem of the graphical programming development environment but may execute independently. In this case for example when executable code for the graphical program is created code operable to intercept or receive notification of the events may be linked in with the graphical program.

In various embodiments a timed loop may stop executing in response to any of various conditions. In one embodiment the timed loop may include a portion of graphical source code that is executed at each iteration of the timed loop where the graphical source code represents logic to control whether or not the timed loop continues executing. For example if the logic evaluates to a Boolean False value the timed loop may stop executing similarly to a While loop in the C programming language. In another embodiment the timed loop may be configured to execute for a specific number of iterations and then stop similarly to a For loop in the C programming language.

In another embodiment execution of a timed loop may be aborted programmatically through an application programming interface API call. For example in one embodiment the graphical programming development environment may provide a Stop Timed Loop node that the user can include in a graphical program. The user may configure the Stop Timed Loop node with the names of one or more timed loops to abort. When the Stop Timed Loop executes during execution of the graphical program it may cause the referenced timed loops to abort execution i.e. to stop iterating. The Stop Timed Loop node may be located anywhere within the block diagram of the graphical program e.g. may be located outside any timed loop. Thus in one embodiment a node that is external to a timed loop may execute to cause the timed loop to abort.

In one embodiment a timed loop may be passed a wakeup reason each time an iteration of the loop begins executing i.e. a data item indicating the reason the iteration of the timed loop began executing. For example as described below the wakeup reason may be received via a terminal in the left data node . The normal wakeup reason e.g. value 0 may indicate that the iteration began because it was normally scheduled at that time. There may be other reasons the iteration began. In particular if the timed loop is aborted through an API call as described above then the timed loop may be awakened i.e. a final iteration of the timed loop may begin and the timed loop may be passed a wakeup reason indicating that the reason this final iteration began is because of the abort call. The user may configure the graphical source code of the timed loop to check the wakeup reason and to execute cleanup code if necessary when the timed loop is aborted in this manner.

In one embodiment operation of the timed loop may be dynamically changed during execution of the graphical program. For example timing information for the timed loop such as its period offset etc. may be dynamically changed. In various embodiments the timing information may be changed using any of various techniques. In one embodiment the timed loop may include special data nodes that may be utilized for this purpose. For example the timed loop of illustrates a left data node attached to the left border of the timed loop and a right data node attached to the right border of the timed loop. The left data node may provide timing and status information about the current and or previous loop iteration such as if the iteration executed late the time the iteration actually started executing and when the iteration should have started executing. The user can wire data from the left data node to the right data node to cause future iterations of the timed loop to be dynamically configured during execution of the graphical program.

In various embodiments the left data node may return any kind of data regarding execution of the timed loop e.g. data regarding execution of the previous iteration of the timed loop or data specifying current property values such as the current execution period priority offset etc. of the timed loop. In one embodiment the left data node may include a plurality of terminals each corresponding to a different data item. For example each data item may be represented as a separate row or field in the left data node . The user may be able to configure the left data node to display only the data items of interest similarly as described above with reference to the configuration node .

The user may connect wires to the terminals of the left data node to receive the respective values of the data items. The wires may provide the data item values to other nodes within the timed loop and or to the right data node . As one simple example the user may connect one end of a wire to a terminal in the left data node to receive the current offset value of the timed loop and may connect the other end of the wire to an Add function node within the timed loop border. The Add function node may be configured to add a numeric constant e.g. 10 to the offset and the output of the Add function node may be connected to an appropriate terminal in the right data node . The right data node may include a plurality of terminals corresponding to various data items regarding execution of the timed loop similarly as described above for the left data node . Thus in this simple example the offset of the timed loop may be dynamically increased by 10 ticks of the timing source on each loop iteration. Future scheduling of the timed loop may take the dynamically changed timed loop properties into account i.e. so that subsequent iterations of the timed loop execute according to a new dynamically specified period offset priority etc.

Expected Start of Current Iteration The time for which the current iteration was scheduled to be started.

Expected Start of Previous Iteration The time for which the previous iteration was scheduled to be started.

Actual End of Previous Iteration The actual time the previous iteration finished executing. This value may be zero for the first iteration of the loop. 

Expected End of Previous Iteration The time the previous iteration was expected to finish executing. This value may be zero for the first iteration of the loop. 

Previous RT A Boolean value that evaluates to True if Actual End of Previous Iteration is greater than or equal to Expected Start of Current Iteration i.e. True if the last iteration overran the period .

Wakeup Reason An integer which indicates the reason the iteration of the timed loop began executing. The normal reason e.g. value 0 is because the iteration was normally scheduled at that time. There may be other reasons the iteration began. For example in one embodiment an asynchronous message to wakeup may be received from outside the loop. In another embodiment the loop may be awakened i.e. may be triggered to iterate because it was programmatically aborted. In another embodiment the loop may be awakened because an associated timeout expired.

As described above the right data node may be utilized to set new timing information for the next iteration of the timed loop. As one example the user may utilize the Previous RT value from the left data node to determine whether the last iteration of the timed loop overran the period. If so the right data node may be used to set a longer period for the timed loop. Similarly as for the left data node the right data node may include a plurality of terminals each corresponding to a different data item. The user may connect wires to these terminals to set desired properties regarding execution of the timed loop. In one embodiment the right data node may include terminals for setting properties such as 

Period The new period of the timed loop. The scheduled start time for the next iteration of the loop may be based on the new period.

In one embodiment the timed loop may be operable to pass on error or status information to other nodes in the graphical program. In the example of the timed loop includes an output node . The output node may return error information that the timed loop receives in the Error In input of the input node or may return error information that the timed loop itself generates during an iteration. For example in one embodiment if an external source causes the execution of the timed loop to abort then the output node returns an error. In one embodiment the output node does not return error information from any subdiagram that executes within the timed loop. In one embodiment if the timed loop receives an error in the Error In input of the input node then the timed loop may not execute i.e. the graphical source code associated with the timed loop may not be executed and the timed loop may simply pass on the error.

In one embodiment the graphical programming development environment may allow the user to create a graphical program that utilizes nested timed loops. As described above the user may include a first timed loop in the graphical program and may include graphical source code associated with the first timed loop such that the graphical source code is executed during each iteration of the first timed loop. In one embodiment a second timed loop may be included in the graphical source code associated with the first timed loop. The user may also associate graphical source code with the second timed loop. The user may configure the first timed loop to execute according to a first execution period and other timing information for the first timed loop and configure the second timed loop to execute according to a second execution period and other timing information for the second timed loop e.g. where the first execution period is relatively longer than the second execution period. Thus during each iteration of the first timed loop the second timed loop may be scheduled to iterate multiple times according to the second execution period and other timing information for the second timed loop.

In some cases the user may have a graphical program that includes one or more non timed loops which the user desires to convert to timed loops. For example the LabVIEW graphical programming development environment provides non timed While loops for use in graphical programs. In one embodiment the graphical programming development environment may provide a feature for automatically replacing a While loop or other non timed loop with a timed loop. For example the user may invoke a context menu of the While loop such as illustrated in and may select the Replace with Timed Loop option to cause the loop to be automatically replaced. The user may then configure the new timed loop with timing information as desired. Graphical source code associated with the old loop may be preserved when the loop is replaced with the timed loop. Similarly in one embodiment the user may invoke a command to automatically replace a timed loop with a While loop or other non timed loop.

In various embodiments controlling the timing of a timed loop in a graphical program in the manner described above may be implemented in any of various ways. In one embodiment the graphical program may execute under control of an execution subsystem. The execution subsystem may utilize a scheduler operable to control timing of timed loops in the graphical program as described above.

In one embodiment the execution of a timed loop may be governed by an alarm. The timed loop may set up an alarm with the scheduler before the loop begins execution. The alarm may comprise a wakeup event registered with the scheduler. The alarm may be created by specifying a timing source period offset and priority. There may be many alarms based on the same timing source.

Upon beginning execution the timed loop may wait on its scheduled alarm. The scheduler may then fire the alarm at the appropriate time causing the graphical source code associated with the loop to execute for one iteration. The scheduler may be operable to periodically fire the alarm where each firing time is determined based on the timing source period offset and priority as described above. Thus after each iteration the timed loop may wait for the next firing of the alarm. If the execution of the loop is terminated e.g. due to conditional termination logic of the loop the alarm may be deleted.

In various embodiments a graphical program that utilizes one or more timed loops such as described above may perform any function. In one embodiment the graphical program may include functionality for modeling or simulating a system. The timed loop s may be utilized in modeling or simulating the system. In other embodiments the graphical program may execute one or more timed loops to perform other functions. As a few examples the timed loops may be involved in performing an industrial automation function a process control function or a test and measurement function a real time application or any other desired function or application.

It is noted that in one embodiment timed loops such as described above may be used to coordinate activities performed by different graphical programs. For example a first graphical program may include a first loop timed based on a first timing source. A second graphical program may include a second loop that is also timed based on the first timing source. Thus the two timed loops may be synchronized with respect to a common timing source. In one embodiment both graphical programs may execute on the same computer system. In another embodiment the first graphical program may execute on a first computer system e.g. the computer system of and the second graphical program may execute on a second computer system e.g. the computer system of . For example the two computer systems may be coupled via a network and the first timing source may be accessible to both computer systems.

It is noted that represents one embodiment of a method for configuring a graphical program to repetitively perform a process at timed intervals and other embodiments are contemplated. In various embodiments any of various methods may be used to configure the graphical program with one or more nodes operable to periodically perform first functionality at times determined by an execution period. Some embodiments may not comprise displaying a loop icon in the graphical program. For example in one embodiment the user may create a graphical sub program operable to perform the first functionality. For example the graphical sub program may have its own block diagram on which the user arranges a plurality of interconnected nodes to implement the first functionality. The graphical program may be configured to periodically execute the graphical sub program according to a timed execution period. For example the graphical sub program may be represented as a sub program node in the block diagram of the graphical program where the sub program node is executed according to the execution period. The user may interact with the sub program node to specify timing information e.g. by using a configuration dialog or by connecting one or more wires to the sub program node in a manner similar to that described above.

A graphical programming development environment which allows users to create graphical programs that utilize timed loops such as described above may comprise a powerful and flexible means for developing a wide variety of applications. For example users may include multiple timed loops in a graphical program to develop a multi rate application. In various embodiments the graphical programming development environment may allow any number of timed loops to be included in a graphical program. In one embodiment the number may be limited to a maximum number e.g. 128. Each timed loop may have a unique timing source or may share the same timing source as one or more other timed loops. Each timed loop may have its own execution period. For example all the timed loops may execute at different rates or one or more timed loops may execute at the same rate. The user may configure the timed loops with desired execution periods and offsets to align the timing of the loop iterations in whatever manner desired.

The graphical programming development environment may enable the user to utilize a wide variety of timing sources to generate the ticks or events upon which loop execution is based. For example in one embodiment the timing source may enable iterations of the loop to be precisely scheduled with respect to time e.g. according to a 1 MHz or 1 KHz clock or precisely with respect to events generated by a hardware device. In one embodiment the timing source may enable iterations of the loop to occur in response to events that may not occur regularly in time as described above. The capability to align execution of loops precisely with respect to various kinds of timing sources and with respect to each other may be important for many applications.

The graphical programming development environment may also enable the user to configure multiple timed loops to execute at different priorities e.g. in accordance with the relative importance of each timed loop. The graphical programming development environment may also enable the user to configure timing information for a timed loop to be dynamically changed during execution of the graphical program.

For many applications it may be desirable to control timing relationships among individual nodes in the graphical program. is a flowchart diagram illustrating one embodiment of a method for specifying timing relationships among nodes in a graphical program. It is noted that illustrates a representative embodiment and alternative embodiments are contemplated. Also various elements may be combined omitted or performed in different orders. The method shown in may be used in conjunction with any of the computer systems or devices shown in the above Figures among other devices.

A user may first create the graphical program e.g. by interacting with a graphical programming development environment. As shown in a plurality of nodes may be arranged on a display in response to user input. In the plurality of nodes may be interconnected in response to user input. The nodes may be interconnected in one or more of a data flow control flow or execution flow format. The plurality of interconnected nodes may visually indicate functionality of the graphical program.

In user input specifying desired timing of a first node with respect to timing of a second node may be received. The user input may specify a desired timing relationship between execution of the first node and execution of the second node to be satisfied during execution of the graphical program. In various embodiments any kind of timing relationship or timing constraint between the first node and the second node may be specified.

In one embodiment the user input may specify desired timing of an execution point for the first node with respect to timing of an execution point for the second node. As used herein an execution point for a node may refer to an identifiable point in time pertaining to execution of the node during execution of the graphical program or may refer to a time pertaining to execution of the node at which a specific condition is or becomes true. One example of an execution point is the beginning of execution of the node. During execution of a graphical program a given node may begin execution at a time which is typically dependent upon the node s relationship or connections to other nodes in the graphical program. For example in a data flow graphical program a node may begin execution when all data flow dependencies for the node if any have been satisfied. The node may then execute for an amount of time which depends on functionality of the node or operations performed by the node after which execution of the node ends. The point at which execution of the node ends is another example of an execution point for the node i.e. an identifiable point in time pertaining to execution of the node.

In various embodiments the user input received in may specify any type of timing relationship or timing constraint between any kinds of execution points for the respective nodes. For example the user may specify a time interval to elapse between the time at which the first node begins execution and the time at which the second node begins execution. For example the user may specify a time interval of 100 ms to indicate that 100 ms should elapse between the times at which the respective nodes begin execution. As another example the user may specify a time interval to elapse between the time at which the first node ends execution and the time at which the second node ends execution. As another example the user may specify a time interval to elapse between the time at which the first node ends execution and the time at which the second node begins execution or vice versa.

In another embodiment the user input may specify a maximum amount of time to elapse between an execution point for the first node and an execution point for the second node. For example the user input may specify that no more than 50 ms should elapse between the time at which the first node begins execution and the time at which the second node begins execution. In another embodiment the user input may specify a minimum amount of time to elapse between an execution point for the first node and an execution point for the second node. For example the user input may specify that at least 200 ms should elapse between the time at which the first node ends execution and the time at which the second node begins execution.

Besides specifying timing relationships relating to the beginning of execution and the end of execution for the nodes the user input may also specify timing relationships relating to any other execution point for the nodes. For example where the first node has an execution side effect the user input may specify a maximum amount of time to elapse between the time at which the side effect of the first node occurs and the time at which the second node begins execution. As another example the user input may specify a desired time interval to elapse between the time at which a side effect of the first node occurs and the time at which a side effect of the second node occurs. In various embodiments the first node or the second node may have any execution side effect. For example the side effect may be caused by an input output operation or may be caused by a processor executing the graphical program interacting with a separate hardware device.

In one embodiment the timing relationship specified in may be associated with a particular timing source or clock similarly as the timed loop described above may be associated with a timing source or clock. Thus in one embodiment rather than specifying a time interval such as 100 ms the user may specify a number of ticks e.g. 100. The timing constraint between the first node and the second node may then be based on the specified number of ticks of the associated timing source.

In timing information may be displayed on the display to visually indicate the timing of the first node with respect to timing of the second node. In various embodiments the timing information may visually indicate the timing of the first node with respect to timing of the second node in any way. In one embodiment the timing information may be displayed on the block diagram of the graphical program. In another embodiment the timing information may be displayed separately from the block diagram.

Where the user input in specifies a numerical time value regarding timing of the first node with respect to timing of the second node displaying the timing information may include displaying this numerical time value. Displaying the timing information may also include indicating whether the numerical time value is an exact time interval a time maximum or a time minimum. For example where the user specifies a time maximum of 100 ms to elapse between an execution point for the first node and an execution point for the second node this may be indicated by displaying text such as 

In one embodiment displaying the timing information may comprise displaying a timing wire between the first node and the second node. One end of the timing wire may be connected to the first node and the other end may be connected to the second node. The specific time constraint may also be displayed with or displayed on the timing wire. For example illustrates an exemplary timing wire between a Read node and a Write node where the timing wire visually indicates that 100 ticks of a timing source should elapse between the time when the Read node begins execution and the time when the Write node ends execution. In this example a PID node is executed between the Read node and the Write node.

The timing wire may be a special wire that does not have the same meaning as other wires in the graphical program. For example in a data flow graphical program the graphical program may include a plurality of wires that indicate data flow between nodes in the graphical program. However the timing wire may not indicate data flow between the first node and the second node but instead may indicate a timing relationship to be satisfied during execution of the graphical program.

In one embodiment a node may have a plurality of points operable to accept connection of a timing wire. Each point may correspond to a different execution point for the node. Thus the timing relationship specified by the timing wire may depend on and may be visually indicated by the particular points to which the timing wire is attached on the respective nodes. In one embodiment the left side of a node may correspond to the beginning of execution of the node the right side of the node may correspond to the end of execution of the node and the middle of the node may correspond to the point when an execution side effect of the node occurs. Thus in the timing wire is attached to the left side of the Read node and the right side of the Write node to indicate that a timing relationship is specified between the beginning of execution of the Read node and the end of execution of the Write node. illustrates a similar example in which a timing wire is attached to the middle of the Read node and the middle of the Write node. Thus the timing wire of specifies a different timing relationship i.e. a time interval of 100 ticks between the time at which a side effect input operation of the Read node occurs and the time at which a side effect output operation of the Write node occurs.

In other embodiments timing information for the first node and the second node may be displayed using techniques other than timing wires. illustrates one alternative embodiment which illustrates the same timing relationship as .

It is noted that and may occur in various orders. For example in one embodiment the user may first specify the timing relationship between the first node and the second node by interacting with a dialog box or wizard and the timing information e.g. timing wire may then be displayed in response. In another embodiment the user may first cause a timing wire or other structure representing timing information to be displayed in the graphical program and may then configure the timing wire with information specifying a timing relationship.

In the graphical program may be executed. The graphical program may be executed in such a way that the visually indicated timing of the first node with respect to timing of the second node is satisfied. This may involve scheduling execution of nodes in the graphical program in a particular way or adjusting priorities of one or more threads in the graphical program so that the timing relationship is satisfied. It is possible that the user may specify a timing relationship that cannot be satisfied. In one embodiment it may be possible to determine before execution of the graphical program that the timing relationship cannot be satisfied. If so then the graphical programming development environment may inform the user e.g. at compile time or at the time the user specifies the timing relationship while editing the graphical program. In another embodiment the system may determine during execution of the graphical program that the timing relationship cannot be satisfied and may inform the user as the graphical program executes or after the graphical program finishes executing. In another embodiment the user may determine whether the specified timing relationships were satisfied by utilizing a visualization tool to view timing of the graphical program as described below.

In various embodiments the user may specify a timing relationship for any of various types of nodes located anywhere within the graphical program. As described above the graphical program may include one or more loops which have associated nodes that are executed for a plurality of iterations. In one embodiment the first node and the second node may be associated with or located within a loop. Thus for each iteration of the loop execution of the first node and the second node may be timed so that the visually indicated timing relationship is satisfied. illustrates the portion of graphical source code illustrated in where the graphical source code is executed in a timed loop. Thus for each iteration of the loop the Write node ends execution 100 ticks after the Read node began execution. In this example the timing source used to measure the 100 tick interval is the same as the timing source for the timed loop.

In another embodiment the user may specify a timing relationship between a node in the loop and the loop itself. For example the user may specify that execution of a first node should begin 50 ms after each iteration of the loop begins. For example this may be indicated by a timing wire similarly as described above where one end of the timing wire is connected to the loop border and the other end is connected to the first node.

The system may attempt to schedule execution of the nodes so that the timing relationship is satisfied from the beginning of execution of the loop. In one embodiment the timing relationship may not be satisfied for the first few iterations of the loop e.g. due to incomplete knowledge of execution times of the first node the second node or intermediate nodes executed between the first node and the second node. However the system may be operable to analyze the timing of previous iterations and adjust scheduling so that the timing relationship is satisfied for subsequent iterations of the loop.

In one embodiment a timing relationship between a first node and a second node may be dynamically modified during execution of the graphical program. For example where a time interval of 15 ms is originally specified between an execution point of a first node and an execution point of a second node the interval may be dynamically increased to 20 ms. For example the graphical program may include graphical source code operable to dynamically determine the actual timing of nodes that occurs during execution of the graphical program and dynamically adjust various timing relationships as necessary so that the graphical program executes with the proper timing. As another example the actual time interval that occurs between two execution points of two nodes may be dynamically determined and the execution period of a timed loop in the graphical program could be dynamically set to this time interval similarly as described above with reference to .

It may be desirable to enable the user to view various aspects of the timing of a graphical program. is a flowchart diagram illustrating one embodiment of a method for viewing timing of one or more loops in a graphical program. It is noted that illustrates a representative embodiment and alternative embodiments are contemplated. Also various elements may be combined omitted or performed in different orders. The method shown in may be used in conjunction with any of the computer systems or devices shown in the above Figures among other devices.

In a graphical program having one or more loops may be created. In one embodiment the one or more loops may include one or more timed loops i.e. the loops may be configured to execute according to particular execution periods. In another embodiment the graphical program may also or may alternatively include one or more non timed loops.

In timing analysis data regarding timing of the one or more loops during execution of the graphical program may be stored. The timing analysis data may include any kind of data useable to analyze timing of the one or more loops. For example for each of the one or more loops the timing analysis data may include data such as the time at which each iteration of the loop began and the time at which each iteration of the loop ended. In other embodiments timing analysis data regarding other aspects of the timing of the graphical program may be stored such as timing data for individual nodes in the graphical program. For example the timing analysis data may include data specifying the time at which a first node began and ended execution or specifying each time the first node began and ended execution if the first node is performed within a loop .

In various embodiments the timing analysis data may be stored at any location such as on a computer system on which the graphical program is executed or on another computer system to which the timing analysis data is transferred via a network. Also the timing analysis data may be stored on any kind of memory medium. Storage of the timing analysis data may occur concurrently with and or after execution of the graphical program.

In one embodiment timing analysis data may not be stored for every iteration of every loop. For example in one embodiment timing analysis data may be stored until a configurable maximum amount of storage space has been utilized or until an out of storage situation occurs. After the maximum has been utilized storage of timing analysis data may stop or previously stored timing analysis data may be overwritten. In another embodiment the user may be able to interactively request storage of the timing analysis data to start or stop as the graphical program is being executed. In another embodiment the user may be able to specify which loops in the graphical program to store timing analysis data for. For example the configuration dialog for specifying timing information for a timed loop has a checkbox for specifying whether or not to log timing data for the timed loop.

In a graphical user interface GUI for viewing timing of the one or more loops during execution of the graphical program may be displayed. For example the GUI may be associated with a visualization tool operable to receive the timing analysis data stored in and display the timing analysis data or display information computed based on the timing analysis data. In one embodiment the GUI may be displayed on a display of the same computer system on which the graphical program executes. In another embodiment the GUI may be displayed on a display of a different computer system. As one example the graphical program may execute on a first device and a visualization tool may execute on a desktop computer system coupled to the first device via a network.

In one embodiment the user may view the timing data for the one or more loops offline from the graphical program e.g. after execution of the graphical program has ended. In another embodiment the GUI may be displayed simultaneously as the graphical program is executing and may be continuously updated with new timing data so that the user can see the timing data of the one or more loops in real time or with a small time delay.

In various embodiments the GUI may display any of various kinds of information regarding timing of the one or more loops and any kind of visual presentation may be used in displaying the information. As described below in other embodiments the GUI may display information to graphically indicate other types of timing for the graphical program in addition to or alternatively to the timing of loops in the graphical program. The GUI may display absolute and or relative timing data. The GUI may display information enabling the user to see timing of individual iterations of the one or more loops performed during execution of the graphical program. For example information visually indicating a start time and an end time for each iteration and or a time duration for each iteration may be displayed. If the loops are assigned execution priorities the GUI may also indicate the respective priorities e.g. using a color coding scheme.

In one embodiment the GUI may indicate the timing of the loop iterations by displaying time increments along a first axis. Each individual loop iteration may be represented as one or more bars line segments or other indicators along the first axis. The length of each bar or line segment may represent a time duration for which the loop iteration executed. The start and end points of the bar or line segment may represent start and end times for the loop iteration. illustrates one exemplary GUI in which various bars represents times at which the corresponding loops were executing.

In one embodiment timing data may be displayed separately for each loop. In another embodiment the GUI may combine information for multiple loops. For example the GUI may visually indicate timing of multiple loops relative to each other and may indicate execution transitions between the loops e.g. as in the example of . Where multiple loops execute based on a common timing source the GUI may display information visually indicating timing of the multiple loops with respect to the common timing source. The GUI may display information that allows the user to distinguish the various loops from one another. In one embodiment the user may configure each loop with a loop name e.g. when creating the graphical program and the GUI may display the loop names to enable the user to identify the respective loops. For example in the user may have named the three loops background loop time critical loop and normal priority loop . also illustrates a scheduler task that schedules execution of the loops.

In the example of each vertical line indicates a point in time when execution switched from one task to another. In this example the GUI displays color coded flags to provide information about each transition to or from a loop iteration. A green flag indicates that the loop iteration started at that point a yellow flag indicates that the loop iteration was suspended at that point a blue flag indicates that the loop iteration was resumed at that point and a red flag indicates that the loop iteration finished at that point. If a loop iteration was suspended at some point and later resumed then that loop iteration may be represented by multiple bars on the GUI. The green and red flags may visually indicate when the loop iteration first began and finally ended. In another embodiment the displayed flags may be shape coded instead of or in addition to being color coded. In addition to the information noted above flags or other indicators may be utilized to visually indicate any of various other kinds of information regarding timing of a loop. For example colored flags may also be displayed to indicate iterations of the loop that occurred late i.e. loop iterations that began at a later time than they were supposed to. For example a late flag may appear on the GUI at a position indicating the actual time that an iteration began execution and may visually indicate that the actual time was later than a time when the iteration was scheduled to begin.

In one embodiment the GUI may be large enough to display only a portion of the timing data at a time. The user may adjust which portion of the timing data is displayed e.g. by scrolling a window to bring the desired portion into view. In one embodiment the user may be able to adjust the scale at which the timing data is displayed.

In some applications the graphical program may be operable to perform network communication i.e. may receive and or send data over a network. In one embodiment the GUI may display information to graphically indicate timing of the network communication together with the timing of the loops in the graphical program. This may enable the user to understand when the network communication occurs relative to iterations of the loops. illustrates a GUI similar to that of where another row has been added to indicate timing of network communication performed by the graphical program relative to loop iterations performed by the graphical program.

In one embodiment the GUI may display timing of one or more loops of a single graphical program. In another embodiment the GUI may display timing of loops that execute in multiple graphical programs. For example the GUI may display timing of a first one or more loops that execute in a first graphical program and a second one or more loops that execute in a second graphical program. Timing for any number of loops in any number of graphical programs may be displayed.

The GUI screen shots mentioned above are exemplary only. As noted above in various embodiments any kind of visual presentation may be used in displaying timing data of the graphical program s . illustrates one alternative embodiment for displaying timing data of a graphical program that performs three loops named Task A Task B and Task C . Times when each loop was executing are indicated in the graphical display on the left with white line segments. Thus each white line segment may correspond to an iteration of a loop. The user may click on each white line segment to display text information regarding the respective loop iteration in the pane on the right side of the display.

In other embodiments the GUI may visually indicate other types of timing for the graphical program in addition to or alternatively to the timing for loops in the graphical program. In one embodiment the GUI may visually indicate timing for individual nodes in the graphical program. As described above with reference to the user may be able to specify a desired timing relationship between a first node and a second node in the graphical program. Thus the GUI may visually indicate the actual execution of the first node relative to the actual execution of the second node. For example in one embodiment the actual execution of the first node may be indicated by a first length relative to a time axis and the actual execution of the second node may be indicated by a second length relative to the time axis. Also the GUI may visually indicate timing of an execution point of the first node relative to an execution point of the second node. For example if the user specified a desired time interval of 100 ms between the beginning of execution of the first node and the beginning of execution of the second node then the GUI may graphically indicate the actual time interval that occurred between the beginning of execution of the first node and the beginning of execution of the second node. The GUI may also visually indicate the times at which execution side effects of various nodes occurred.

In one embodiment the user may be able to cause the GUI to switch between various display modes. For example one display mode may display timing for loops in the graphical program and another display mode may display timing for individual nodes in the graphical program. In one embodiment timing data for both loops and individual nodes may be displayed simultaneously. For example the GUI may visually indicate timing both of loop iterations and of individual nodes executed within each loop iteration.

There may be other display modes as well such as a mode for displaying timing of threads executed by the graphical program. Other low level execution details for the graphical program may also be displayed such as semaphore accesses critical section accesses sleep spans etc. The user may also be able to specify viewing preferences to change the displayed information. The user may also be able to select which items to display information for. For example timing information for some loops or some nodes may be hidden from view if desired to simplify the display.

In one embodiment the GUI may display timing data on the block diagram of the graphical program. This may allow the user to easily relate the timing data to the corresponding portion of the graphical program and to see timing characteristics of particular portions of the graphical program. In another embodiment the GUI may primarily display the timing data but certain elements of the block diagram may also be included on the display. For example individual nodes may be displayed to enable the user to easily identify the nodes corresponding to various portions of the displayed timing data.

The timing data displayed by the GUI may allow the user to determine whether the timing of the graphical program s is occurring as intended. The user may be able to see when particular activities occur in the graphical program and also get a measure of how much time each activity takes to execute. An execution subsystem which executes the graphical program may attempt to schedule execution of various elements of the graphical program so that the specified timing criteria for the graphical program are met. However in some cases it may not be possible to satisfy the timing criteria e.g. if the user specified execution periods or time intervals that are too short. If timing is not occurring as intended then the user may adjust the timing criteria for various elements of the graphical program. For example if a loop consistently overruns its execution period the user may specify a longer execution period for the loop. As another example if a user specified maximum time interval between an execution point of a first node and an execution point of a second node was not satisfied then the user may specify a longer time interval. If timing criteria for other loops or nodes in the graphical program depends on or is relative to the timing criteria that changed then the user may also adjust the timing criteria for these other loops or nodes so that proper timing relationships among various elements of the graphical program are maintained.

In one embodiment the timing data may be programmatically analyzed to automatically detect situations where the specified timing criteria of the graphical program are not being met. The user may be informed of the problem e.g. by displaying a text message or by visually indicating an error condition on the display e.g. through color coding or other techniques to draw the user s attention to the problem.

In other cases the specified timing criteria for the graphical program may be satisfied with time to spare and the user may be able to adjust the timing criteria to make the graphical program execute faster. For example if the user specified an execution period of 25 ms for a loop and the GUI indicates that each iteration of the loop took less than 20 ms to execute then the user may adjust the execution period of the loop to 20 ms. In one embodiment the timing data may be analyzed to automatically detect situations where the specified timing criteria can be changed to make the graphical program execute faster.

In one embodiment the GUI may not only display timing data but may also allow the timing criteria for the graphical program to be re configured from within the GUI itself without having to switch to a block diagram editor or other context. For example the user may double click on a portion of timing data displayed for a particular loop to cause a configuration dialog for setting timing information for the loop to be displayed. The user may then change various aspects of the loop s timing information such as its execution period offset priority etc. The graphical program may then be configured with the new timing information for the loop. In one embodiment this may comprise automatically or programmatically changing a portion of the graphical program s block diagram e.g. to set new numerical values used on the block diagram or to re configure wires etc.

In one embodiment the graphical program may be re configured with the new timing information offline i.e. while the graphical program is not being executed. For example the graphical program may then be re compiled and executed again to determine whether the new timing information is appropriate. In another embodiment the graphical program may be re configured with the new timing information dynamically as the graphical program is being executed. The GUI may be continuously updated with new timing data so that the user can see the effects of the new timing configuration in real time or with a small time delay.

In another embodiment the GUI may allow the user to easily switch from the GUI to a block diagram editor for editing the graphical program. For example the user may be able to issue a command to cause the block diagram editor to be launched in a new window and the graphical program to be opened in the editor window. In one embodiment the editor window may be automatically scrolled to bring a particular element of the graphical program into view. For example the user may double click on a portion of timing data displayed on the GUI for a particular loop which may cause the graphical program to be opened in the editor and automatically scrolled so that the loop is in view. The user may then re configure the timing information for the loop e.g. by invoking a configuration dialog or changing wires connected to loop terminals etc.

In another embodiment the GUI may allow the user to specify setting changes for one or more hardware devices which the graphical program utilizes. For example the user may change hardware device settings that affect the timing of the graphical program. The specified changes to the settings may be automatically applied to the hardware devices. In one embodiment hardware events or status of hardware devices may also be displayed along with the timing data for the graphical program. For example information may be displayed to represent when the converters on a DAQ board are ready to be used in sampling data. This may aid the user in properly aligning the timing of his graphical program with the timing behavior of the hardware devices which the graphical program utilizes.

An alternative embodiment of the method may be utilized to display timing information for a text based program such as a program written in C C Visual C Visual Basic Java etc. In particular where the text based program includes one or more loops the GUI may display timing data for the one or more loops in a manner similar to that described above. For example for a C program that includes one or more While loops or one or more For loops the GUI may display timing data for the one or more While loops or For loops.

In some applications it may be desirable to execute a graphical program having multiple timed loops that are timed in a hierarchical fashion with respect to each other. The timed loops may not all execute at the same rate but may need to execute at rates which are derived from each other. As one simple example it may be desirable to have a first loop that executes at a rate of 1 MHz and a second loop that executes at a rate of 200 KHz where the 200 KHz timing source for the second loop is derived from the 1 MHz timing source of the first loop. In other words the timing source for the second loop may need to tick exactly at the same time as every fifth tick of the timing source for the first loop. Thus successive iterations of the second loop may begin execution at the same time as every fifth iteration of the first loop begins execution.

In any given application the number of timed loops in the graphical program and their timing relationships with respect to each other may be arbitrarily complex. During execution of the graphical program it may be necessary to properly align the timing sources of the loops with respect to each other and begin execution of the loops so that they are exactly timed with respect to each other in the desired manner. is a flowchart diagram illustrating one embodiment of a method for executing a graphical program which has a plurality of timed loops wherein the timed loops utilize timing sources that are related to or derived from each other. It is noted that illustrates a representative embodiment and alternative embodiments are contemplated. Also various elements may be combined omitted or performed in different orders.

According to one embodiment of the method a graphical program having a plurality of loops may be created as shown in . For example the user may include a plurality of timed loops in the graphical program as described above with reference to .

In a hierarchy of timing sources may be defined. Any type of timing sources may be utilized such as hardware or software based timing sources. In one embodiment the timing sources may be related to each other according to parent child relationships. For example one or more timing sources may be derived from a base timing source. For each timing source derived from the base timing source one or more timing sources may in turn be derived from that timing source. Additional timing sources may in turn be derived from these timing sources and so on for as many levels as desired. Thus the timing sources may be related to each other according to a tree hierarchy.

In various embodiments any of various techniques may be utilized to define the hierarchy of timing sources. In one embodiment the hierarchy of timing sources may be defined based on user input. For example the graphical programming development environment may be operable to display a GUI allowing the user to specify relationships among the timing sources. In another embodiment the user may utilize an application programming interface API to define the hierarchy of timing sources. For example the user may create graphical source code operable to dynamically define the hierarchy of timing sources during execution of the graphical program.

In each of the loops in the graphical program may be associated with one of the timing sources defined in . Thus the plurality of loops may be viewed as a group of loops that are grouped together due to the relationships among their respective timing sources. In various embodiments the loops may be associated with the timing sources using any technique similarly as described above with reference to . It is noted that and may occur in any order or may occur concurrently with respect to each other.

In execution of the graphical program may begin. For the group of loops in the graphical program to execute with the intended timing it may be necessary to control the manner in which their respective timing sources are started and control when the loops begin executing. As shown in execution of the loops may be delayed until every loop in the group is ready to execute. The determination of when the loops are ready to execute may depend on the type of graphical program. For example for a data flow graphical program a loop may be ready to execute when all data flow dependencies for the loop if any have been satisfied. As a simple example consider a graphical program with Loop A whose data flow dependencies become satisfied at time T Loop B whose data flow dependencies become satisfied at time T and Loop C whose data flow dependencies become satisfied at time T where T

After every loop in the group is ready to execute the timing sources for the various loops may be started. To satisfy the defined relationships among the timing sources the timing sources may need to be started in a certain order. Thus in an ordering for starting the timing sources may be determined based on their hierarchical relationship. In the timing sources may be started according to this determined ordering.

As described above the timing sources may be related to each other according to a tree hierarchy. The timing sources may be started in an order depending on their position within the tree. Each child timing source may be started before its parent timing source. According to one embodiment the timing sources may be started according to a post order depth first traversal of the tree.

As shown in once the timing sources have been started execution of the loops may be begun such that each loop executes based on its respective timing source i.e. iterations of each loop are timed by its respective timing source similarly as described above with reference to .

As discussed above with reference to in some situations the first iteration of a timed loop may not be ready to execute until a time that is after its designated offset e.g. due to late arrival of data flow or other causes. In different applications the user may want the timed loop to behave in different ways when such a situation occurs. In various embodiments the graphical programming development environment may enable the user to choose from any of various kinds of modes that define the behavior of a timed loop that is late in this manner. This section describes several exemplary late modes according to which the timed loop may be configured.

As an example suppose that a timed loop is configured with an execution period of 100 ticks and an offset of 30 ticks and suppose that the actual time required for one iteration of the timed loop to execute is 20 ticks. Thus in normal operation the first iteration of the timed loop should begin at 30 ticks i.e. its offset and subsequent iterations should begin at 130 ticks 230 ticks 330 ticks etc. i.e. as defined by the period 100 ticks . Assume however that the timed loop is not actually ready to begin execution until 240 ticks e.g. due to late arrival of data flow. Since the timing source is now at 240 ticks the scheduler may have choices in scheduling the first and subsequent iterations of the timed loop.

One dimension to the problem is whether or not the timed loop should be aligned with the originally prescribed schedule. In some applications other timed loops or hardware devices may already be running at the originally prescribed schedule. Thus it may be desirable to align this timed loop with the already running global schedule. This means that the timed loop should align itself as quickly as possible with its prescribed schedule. In the example above the first iteration of the timed loop should be scheduled to begin at 330 ticks and subsequent iterations at 430 ticks 530 ticks etc. However in other applications it may not be necessary to align this timed loop with the execution of other timed loops or hardware devices. In these applications it may be desirable to instead begin executing the timed loop as soon as possible. Thus the first iteration of the timed loop may begin execution immediately using the current time as its actual offset. In the example above this means that the first iteration of the timed loop begins execution at 240 ticks and subsequent iterations at 340 ticks 440 ticks etc.

Another dimension to the problem concerns whether the loop should catch up on processing data from missed periods. For example in one embodiment the timed loop may be a consumer of data generated by other timed loops or hardware devices. At each iteration the timed loop may be expected to consume or process data generated by the other timed loops or hardware devices. Since the timed loop is late the other timed loops or hardware devices may already have generated data missed by this timed loop. In the example above the timed loop is behind with the data from the periods starting at 30 and 130 ticks and we can assume that the data from the current period starting at 230 ticks has already been produced as well. If the data from the missed periods are available in a buffer it may be desirable for the timed loop to catch up by processing the missed data points before it is ready to join the defined schedule. However a timed loop that processes the missed data may cause jitter which is the amount of time that a loop cycle time varies from the specified schedule. Thus in some applications the user may not want the timed loop to process the missed data. If the user does not want to process the missed data the timed loop can ignore older data in the buffer that the loop iterations missed and process only the latest data such as the data available at the next iteration and subsequent iterations.

The two problem dimensions discussed above are orthogonal to each other. Thus four modes mode A mode B mode C and mode D may be defined to specify the behavior of a late timed loop as illustrated in . For completeness two additional modes mode E and mode F may also be introduced. These modes both specify a timed loop that ignores its given offset. A timed loop configured in mode E will be scheduled to run immediately when it is enabled by data flow. A timed loop configured in mode F will be scheduled to run one period later than the time when it is enabled by data flow.

The chart in illustrates the operation of the timed loop in the above example when it is configured in each of these six modes. In this chart X t denotes the value being produced say by a hardware device or another timed loop at time t and A t B t C t D t E t and F t denote the consumption of the data produced at time t when the loop is configured to behave according to the modes A B C D E and F respectively. For example when the timed loop is configured in mode A i.e. Catch Up Align with Schedule the timed loop may iterate to process the data from the missed periods before it is aligned with the global schedule. As shown in when the timed loop is configured in mode A at 240 ticks the timed loop processes the data that was produced at 30 ticks at 260 ticks the timed loop processes the data that was produced at 130 ticks and at 280 ticks the timed loop processes the data that was produced at 230 ticks. Having processed the data from the three missed periods the next iteration of the timed loop is then scheduled to begin at 330 ticks in line with the global schedule. Behavior of the loop when it is configured in modes B C D E and F is shown in a similar manner. In this example it is assumed that the timed loop has the highest priority allowing the timed loop to catch up as fast as possible.

To more precisely capture the semantics of the modes the following pseudo variables may be defined mapping iteration count to their values for that iteration 

This is the default behavior for the next iteration of the timed loop unless one of the other modes is explicitly defined through wiring on the right edge of the loop. The computations of the pseudo variables for the loop will proceed using the rules given for the current mode. Note that specifying the No Change mode on the right edge of the timed loop implies that a wired value for the offset will be ignored for the next iteration. A timed loop with the No change mode as its initial mode has an undefined behavior.

In another embodiment additional modes referred to below as primed modes may be defined where the additional modes all establish the phase on the first iteration based on the maximum value of offset and actual wakeup 0 the first wake up time for the loop . The primed modes may behave as follows 

C Wait multiple establish phase on the first iteration use specified offset if possible and process pending

As noted above in one embodiment the graphical programming development environment may provide an application programming interface API which can be used to programmatically configure timed loops in a graphical program. In one embodiment this API may take the form of various graphical program nodes that the user can include in the graphical program to configure or control various aspects of the timed loops. The following describes one embodiment of such a set of graphical program nodes. It is noted that the described nodes are intended as examples only.

error in The error in input describes error conditions that occur before this node runs. The default is no error. If an error occurred before this node runs the node passes the error in value to error out. This node runs normally only if no error occurred before this node runs. If an error occurs while this node runs it runs normally and sets its own error status in error out.

name out The name of the timing source created by the node. The name may be passed to other nodes that utilize it.

error out The error out output contains error information. If error in indicates that an error occurred before this node ran then error out contains the same error information. Otherwise it describes the error status that this node produces.

error in The error in input describes error conditions that occur before this node runs. The default is no error. If an error occurred before this node runs the node passes the error in value to error out. This node runs normally only if no error occurred before this node runs. If an error occurs while this node runs it runs normally and sets its own error status in error out.

parent The parent output specifies the name of the parent of the timing source deleted by the node. If the timing source has no parent then the parent output is empty.

error out The error out output contains error information. If error in indicates that an error occurred before this node ran then error out contains the same error information. Otherwise it describes the error status that this node produces.

replace F This input replaces any timing source entered in the timing source names input if a timing source by that name already exists in the hierarchy of timing sources.

parent This input specifies the valid timing source to be started after the all the timing sources in hierarchy name start.

timing source names This input specifies an array of names of the timing sources to add to the timing source hierarchy. If the replace input is True then the new timing source replaces any timing source with the same name that already exists in the timing source hierarchy. These timing sources start before the timing source specified by the parent input.

error in The error in input describes error conditions that occur before this node runs. The default is no error. If an error occurred before this node runs the node passes the error in value to error out. This node runs normally only if no error occurred before this node runs. If an error occurs while this node runs it runs normally and sets its own error status in error out.

error out The error out output contains error information. If error in indicates that an error occurred before this node ran then error out contains the same error information. Otherwise it describes the error status that this node produces.

replace T This input specifies whether to replace the group of timed loops entered in the synchronization group name input with the timed loop names entered in the loop names input. If the replace input is False and the timing source is a member of another hierarchy then the node may return an error.

synchronization group name This input specifies the name of the group of timed loops for which to synchronize the start times.

timeout ms 10000 This input specifies the amount of time the timed loop waits on other members of the synchronization group to arrive to the synchronization point. If any of the timed loops in the group do not arrive in time the timed loop may return an error. The default is 10 000 ms.

loop names This input specifies the names of the timed loops to synchronize. By default if the name of a timed loop is specified in the loop names input and the group specified by the synchronization group name input includes that timed loop then the node deletes the new timed loop from the current group and adds it to the group specified by the synchronization group name input. If the replace T input is set to False then the node may return an error to indicate that it could not add the timed loop to the synchronization group.

error in The error in input describes error conditions that occur before this node runs. The default is no error. If an error occurred before this node runs the node passes the error in value to error out. This node runs normally only if no error occurred before this node runs. If an error occurs while this node runs it runs normally and sets its own error status in error out.

error out The error out output contains error information. If error in indicates that an error occurred before this node ran then error out contains the same error information. Otherwise it describes the error status that this node produces.

priority This input changes the priority of the timed loop being aborted. The priority input may be used when the user wants to stop two or more timed loops and wants to ensure that one stops before the other.

error in The error in input describes error conditions that occur before this node runs. The default is no error. If an error occurred before this node runs the node passes the error in value to error out. This node runs normally only if no error occurred before this node runs. If an error occurs while this node runs it runs normally and sets its own error status in error out.

error out The error out output contains error information. If error in indicates that an error occurred before this node ran then error out contains the same error information. Otherwise it describes the error status that this node produces.

The timing of the receiving timed loop can be controlled from the GUI of by changing the values of the initial delay a delay introduced in the tenth iteration. The GUI also allows the user to change the late mode of the receiving timed loop allowing the different behavior caused by the different late modes to be observed.

The Receiver is late indicator on the GUI goes on whenever the previous iteration of the receiving timed loop was late.

The Items in queue indicator indicates the number of items in the queue between the sender timed loop and receiving timed loop.

The Initial receiver delay control controls how much time in milliseconds the receiving timed loop will be delayed. A delay less than 100 has no effect since the receiver has an offset of 100 ms. If the timed loop is in a mode that processes missed periods these extra elements will be received in the next iteration of the receiving timed loop. If the mode discards missed periods then the queue will contain this number of items until the sender is done.

The Receiver delay at iteration 10 control controls how much time to wait during iteration number 10 in milliseconds. This delay will cause the sender to add one extra element to the queue every 100 ms. If the timed loop is in a mode that processes missed periods these extra elements will be received in the next iteration of the receiving timed loop. If the mode discards missed periods then the queue will contain this number of items until the sender is done.

The user can run the graphical program and notice that Loop immediately begins plotting whereas Loop must wait 2 seconds before it plots because a Wait node delays data from reaching Loop for 2 seconds. The user can then click the Restart with Synchronization button to restart the timed loops so that their starts are synchronized. Both loops wait the 2 seconds before they start plotting even though there is no data flow reason keeping Loop from plotting. I.e. the start of Loop is delayed until Loop starts because the two timed loops are synchronized.

The user can then click the Restart w 0 Synchronization button to restart the timed loops so that their starts are not synchronized. Now the timed loops will behave like they did at the start i.e. Loop will wait and Loop will immediately begin plotting.

There are two timed loops a low priority timed loop and a high priority timed loop. The period of the high priority loop is twice as long as that of the low priority loop. When the low priority loop is running the Low Priority Loop tank indicator on the GUI of changes. When the high priority loop executes indicated by the High Priority loop is running LED it preempts the low priority loop. Therefore the Low Priority Loop tank indicator stops until the high priority loop finishes. As soon as the high priority loop is finished executing the Low Priority Loop tank indicator starts changing again. The user can change the controls on the GUI to see different timing and preemption characterisitics.

Many text based programming languages such as C BASIC Java etc. have an inherent control flow because statements execute in the order in which they appear in the program. In contrast for many types of graphical programs data flow is the main principle governing program execution. In other words in a graphical program that is based on a data flow model a node may execute when all data inputs have arrived at the node s input terminals. The node may then supply data to its output terminals when the node has finished executing and this data may then pass to input terminals of other nodes in the diagram that are connected to the node s output terminals. Thus for this type of graphical program execution of different portions of the program is data driven. Thus in a pure data flow model execution order for different portions of the graphical program is not necessarily guaranteed.

Therefore for many data flow based graphical programs it is necessary to introduce a layer of control flow over the basic data flow model. It is often necessary to explicitly specify an execution order for different portions of a graphical program to force the portions to execute in a desired sequential order. In some applications it may also be necessary to control timing of the respect graphical code portions.

In a plurality of graphical code portions may be included in the graphical program. Each graphical code portion may represent a sub task to be performed in a sequence with other sub tasks. Each graphical code portion may include one or more graphical program nodes. The graphical program nodes may be interconnected to visually indicate functionality of the graphical code portion. In one embodiment the graphical program nodes may be interconnected to indicate data flow.

In a sequential order of execution may be configured for the graphical code portions. For example the user may provide input to the graphical programming development environment to specify the sequential order of execution for the graphical code portions.

In first execution timing information may be configured for one or more of the graphical code portions. For example the user may provide input to the graphical programming development environment to specify the first execution timing information. In various embodiments the first execution timing information may comprise any kind of information that affects the timing of execution of one or more of the graphical code portions during execution of the graphical program. As one example the first execution timing information may specify a time when a graphical code portion should begin executing. Exemplary types of execution timing information are described below.

Executing the graphical program may comprise executing the plurality of graphical code portions. As indicated in the graphical code portions may be executed sequentially in the sequential order and in accordance with the first execution timing information. For example if the first execution timing information specifies that a particular graphical code portion should begin executing at a time T then execution of the sequence of graphical code portions may be controlled so that the graphical code portion begins execution at the time T.

In one embodiment the user may configure the timed sequence of graphical code portions with a timing source on which the execution timing is based. In various embodiments any of various kinds of timing sources may be used similarly as described above with respect to the timed loop structure.

As noted above the user may configure any of various kinds of execution timing information for the graphical code portions. For example in one embodiment the user may configure a deadline for a particular graphical code portion where the deadline specifies a time by which execution of the graphical code portion must complete. In one embodiment the specified time by which execution of the graphical code portion must complete may be relative to a time when the graphical code portion begins execution.

As another example in one embodiment the user may configure an offset for a particular graphical code portion where the offset for the graphical code portion specifies a length of time to wait before the graphical code portion begins executing. In one embodiment the offset may only apply to the first graphical code portion of the sequence. 

As another example in one embodiment the user may configure a start time for a particular graphical code portion where the start time specifies a time when the graphical code portion should begin executing. In one embodiment the start time may be an absolute time value with respect to the timing source . In another embodiment the start time may be relative to another time value.

As another example in one embodiment the user may configure a priority for a particular graphical code portion. During execution of the graphical program the graphical code portion may be executed according to the configured priority. The user may configure different priorities for different graphical code portions.

As another example in one embodiment the user may configure a timeout for a particular graphical code portion. The timeout for the graphical code portion may specify a maximum length of time the graphical code portion can wait before beginning to execute.

In one embodiment the user may configure execution timing information for a particular graphical code portion where the execution timing information is based on one or more execution time values for the graphical code portion that executed previously. For example the previous graphical code portion may execute to produce one or more execution time values and these execution time values may be used to control execution timing for the next graphical code portion. As one example the next graphical code portion may be timed to begin executing at say 50 ms after the previous graphical code portion completes execution. Thus in this example the previous graphical code portion executes to produce an execution completion time execution time value which is then used to control the execution start time for the next graphical code portion.

One technique for specifying the sequential order and the first execution timing information for the different graphical program portions is through the use of a timed sequence structure node also referred to as simply a timed sequence structure. The user may include a timed sequence structure node in the graphical program and may associate the plurality of graphical code portions with the timed sequence structure node such that the timed sequence structure node species a sequential order of execution for the graphical code portions. The user may also configure the timed sequence structure node with execution timing information for one or more of the graphical code portions. During execution of the graphical program the timed sequence structure node may be operable to control execution of the graphical code portions to cause the graphical code portions to execute in the desired sequential order and in accordance with the execution timing information.

In one embodiment the timed sequence structure node may include a plurality of ordered frames. The user may be able to specify the desired number of frames N for the timed sequence structure and may associate a graphical code portion with each frame. For example in one embodiment each frame may include an interior portion and the user may associate a graphical code portion with a frame by positioning or displaying the graphical code portion within the interior portion. The plurality of ordered frames may define an execution order for the corresponding portions of graphical source code such that during execution of the graphical program the portions of graphical source code are executed sequentially according to this execution order. For example during execution of the graphical program the portion of graphical source code in frame may execute first followed by the portion of graphical source code in frame followed by the portion of graphical source code in frame etc. up to the portion of graphical source code in frame N.

In various embodiments a timed sequence structure may have any of various appearances in the graphical program. In one embodiment only a single frame may be visible at a time. The user may be able to scroll through the frames to view the desired one. In another embodiment all or at least a subset of the frames of the sequence structure may be visible simultaneously. The frames may be positioned or laid out within the graphical program in any of various ways. In one embodiment the frames may be displayed side by side in a left to right order e.g. such that the right side border of one frame is also the left side border of an adjacent frame. In other embodiments frames may be positioned in an up to down order or in a combination of left to right and up to down orders.

Any of various techniques may be used in determining the execution order of the frames. In one embodiment the execution order for a particular frame may be inherently specified by the frame s location among the other frames. For example if the frames are displayed in a left to right order then execution of the frames i.e. execution of the graphical source code portions within the frames may also proceed in this same left to right order. In another embodiment the user may provide user input to specify a desired execution order for the frames.

The timed sequence structure may also allow the user to specify a timing source and specify various other execution timing information for the frames of the timed sequence structure. For example the user may configure one or more of the frames with deadlines timeouts start times priorities etc. similarly as described above.

As described above in various embodiments the user may be able to specify various types of information affecting execution timing of the frames in a timed sequence structure. Many applications need to perform a series of timed sub tasks and users are often interested in ensuring that the sub tasks have a specified time bound and a certain time delay. A time bound on a sub task specifies a time by which the sub task must finish its execution. A time delay specifies a time after which a sub task can start executing. Thus in one embodiment the graphical programming development environment may allow the user to specify time bounds and time delays for the frames in a timed sequence structure.

The timed sequence structure also includes an output node which propagates errors and the timing information from the last frame in the timed sequence structure.

In one embodiment each frame of the timed sequence structure may have a set of data nodes referred to as the left data node and right data node. The left data node returns timing information on the previous and current frame of the timed sequence structure. For example in the single frame of the timed sequence structure has a left data node that includes various data fields such as Deadline Start Priority etc. For example the Deadline data field specifies the point in time relative to expected start of current frame that the current sequence frame should finish executing. Other data fields of the left data node are described below. The frame in the timed sequence structure illustrated in also has a right data node that includes various data fields indicated by different icons. Data fields of the right data node for a given frame in the timed sequence structure may specify timing information for the next frame in the timed sequence structure. In this example the right data node fields may not be used since there is only one frame in the timed sequence structure. Data fields of the right data node are described below. For each frame in the timed sequence structure the user may invoke a dialog associated with the frame s right data node to statically configure the timing information for the next frame of the timed sequence structure. illustrates an exemplary dialog for specifying timing information for the next frame such as a Start time a Priority a Timeout and a Deadline.

As described above the user may invoke a configuration dialog associated with the configuration node of the timed sequence structure which allows the user to statically configure various aspects of the timing of the timed sequence structure. illustrates one exemplary configuration dialog. As shown this configuration dialog allows the user to specify a timing source for the timed sequence structure. The timing source may comprise an entity useable for timing and scheduling of frames in the timed sequence structure. In various embodiments the graphical programming development environment may allow the user to specify any kind of timing source similarly as described above with reference to timed loops. In the example of the Source list box displays four selectable timing sources. The 1 kHz clock item refers to a 1 ms system clock of the computer system. The 1 MHz clock item refers to a 1 us Pentium counter available on certain Pentium computer systems. The 1 kHz clock item refers to a 1 kHz timing source that resets on the first call of every invocation of the sequence. The 1 MHz Clock item refers to a 1 Mhz timing source that resets on the first call of every invocation of the sequence.

Thus in this embodiment there are two units of built in timing sources available milliseconds and microseconds. Each of these has a resettable version of the timing source. A resettable timing source does not have a creation overhead at the time of initialization and it resets to zero on the first call of every invocation of the sequence. For example if a timed sequence structure configured with a resettable timing source is placed within a loop then at the beginning of every iteration of the loop the timing source resets to zero. A resettable timing source may be more efficient than a non resettable timing source.

In other embodiments the graphical programming development environment may allow the user to configure the timed sequence structure with any of various other kinds of timing sources similarly as described above with respect to timed loops.

The configuration dialog of also allows the user to specify a Source name for the timing source. The source name specifies a name for the timed sequence structure s instance of the timing source. Multiple timed sequence structures may be configured with the same timing source and the same source name for the timing source. This means that all the timed sequence structures will share the same instance of the timing source. Thus timing information for each timed sequence structure such as the offset will be relative to the same starting point. However timed sequence structures configured with different names for the same timing source will be governed by different instances of the timing source. In this case timing of the timed sequence structures is independent from each other.

The configuration dialog of also allows the user to specify a Timeout for the timed sequence structure. A frame of the timed sequence structure may time out if it is not awakened by the timeout time specified.

The configuration dialog of also allows the user to specify an Offset for the timed sequence structure. The offset specifies the start time in absolute time for the first frame of the timed sequence structure. The offset is specified with reference to the start of the timing source. The default value for the offset is zero which means no offset i.e. start immediately.

The configuration dialog of also allows the user to specify a Deadline for the timed sequence structure. The deadline specifies a point in time when each frame must finish its execution. This specifies a time bound for each frame.

The configuration dialog of also allows the user to specify a Priority for the timed sequence structure. Higher values may signify higher priorities.

The configuration dialog of also allows the user to specify a Sequence name for the timed sequence structure. The sequence name may be useful to allow the user to make various API calls e.g. to group together several timed sequence structure and or timed loops to synchronize their starts. This name may also appear in a user interface that displays timing information for the timed sequence structure when the graphical program is executed to allow the user to identify the timed sequence structure.

As discussed above each frame of a timed sequence structure may have a set of data nodes referred to as the left data node and right data node. The left data node returns timing information on the previous and current frame of the timed sequence structure and the right data node specifies timing information for the next frame in the timed sequence structure. is an exemplary timed sequence structure with three frames in which the left and right data nodes are illustrated in more detail.

The left data node for a given frame may include a first set of data fields that return timing information for the previous frame of the timed sequence structure and a second set of data fields that return timing information for the current frame of the timed sequence structure. For example the middle frame in the timed sequence structure of is labeled with arrows showing that the top three fields Expected End Actual End and Finished Late in the left data node for the middle frame return timing information for the previous frame. The next seven fields in the left data node for the middle frame return timing information for the current frame i.e. the middle frame itself. As shown in the left data node for the first left most frame does not have data fields for the previous frame since there is no previous frame.

Expected End the expected end time in absolute time units from start of sequence of the previous frame. formula ExpectedEnd Expected Start Deadline 1 

Finished Late True if the deadline of the previous frame was missed. formula FinishedLate ActualEnd ExpectedEnd 

Expected Start the expected start time in absolute time units from start of sequence of the current frame.

Actual Start the actual start time in absolute time units from start of sequence of the current frame.

Wakeup reason the reason the scheduler woke up the frame. The possible values are 0 for normal wakeup 1 for Sequence Aborted possible reasons include the timing source got deleted and 2 for Async wakeup message received.

Timeout the maximum time in millisecs the sequence frame should wait to be woken up. Default value is 1 which means infinity. Valid values are 1 0 . . . 

Deadline the maximum point in time relavtive to expected start of current frame by which the current sequence frame should finish executing. Valid values are 1 0 1 . . . where 1 means unspecified.

Start Time the current frame was supposed to start. This is relative to the start of the previous frame. For example if the value coming out is 100 then it means that the current frame has a start value of 100 units of time after the expected start of the previous frame. Valid values are 1 0 1 . . . where 1 means unspecified.

Global end time timing source independent time stamp in nanoseconds of end of execution of the previous frame.

Global start time timing source independent time stamp in nanoseconds of start of execution of the current frame.

As shown in the right data nodes for the first and second frames include data fields for specifying timing information for the next frame in the timed sequence structure. However the right data node for third right most frame includes only a field for propagating error information since it is the last frame i.e. there is no next frame.

Timeout the timeout value specifies the maximum time the next sequence frame should wait to be woken up. Default value is 1 which means infiniately. Valid values are 1 0 1 . . . 

Deadline maximum point in time relative to expected start of next frame by which the next sequence frame should finish executing. Valid values are 1 0 1 . . . where 1 means unspecified.

Start time the next frame is supposed to start. Relative to expected start of the current frame. Valid values are 1 0 1 . . . where 1 means unspecified.

FIG. Frame Starts 0 100 200 ticks of the clock. Frame Deadlines 50 50 50. Frame Execution Times 40 60 40

For many applications it is necessary to perform a timed sequence of sub tasks such as described above repetitively where the timing of each repetition of the timed sequence is precisely controlled. is a flowchart diagram illustrating one embodiment of a method for creating a graphical program that performs a timed sequence of graphical code portions for a plurality of iterations where the timing of each iteration of the sequence is controlled. It is noted that illustrates a representative embodiment and alternative embodiments are contemplated. Also various elements may be combined omitted or performed in different orders.

In a plurality of graphical code portions may be included in the graphical program such that the graphical code portions are associated with the loop.

In the loop executes the graphical code portions for a plurality of iterations where each iteration is executed in accordance with the first execution timing information.

As indicated in in each iteration of the loop the graphical code portions are executed in the sequential order and in accordance with the second execution timing information.

In various embodiments the steps above may be performed in any of various ways. In one embodiment including the loop in the graphical program may comprise including a timed loop node such as described above in the graphical program. The timed loop node may be configured with the first execution timing information. In one embodiment the user may include a timed sequence structure node within the timed loop node and configure the timed sequence structure node with the second execution timing information. Thus in each iteration of the timed loop the graphical code portions associated with the frames of the timed sequence structure node may be executed according to the second execution timing information. For example the user may configure the timing of the timed loop node and the timed sequence structure node so that the timed loop executes according to the desired execution period and other timing criteria and so that the frames of the timed sequence structure execute with the desired timing at each repetition of the timed loop.

In another embodiment the graphical programming development environment may provide an integrated structure a combination structure node that combines functionality of the timed loop and the timed sequence structure. Such a combination structure node is also referred to herein as a timed loop with frames structure node.

A timed loop with frames structure node that combines the functionality of both a timed loop and a timed sequence may simplify the graphical program somewhat and make it easier for the user to configure the desired timing. For example the user may interact with a common dialog to specify timing information for both the timed loop and the timed sequence.

Having a single structure node that provides the combined functionality of the timed loop and the timed sequence structure may also allow the graphical program to execute more efficiently since a single execution system can manage the execution of the frames of the timed sequence structure within the timed loop.

In one embodiment the graphical programming development environment may provide a timed loop with frames combination structure node which the user can include in his graphical program e.g. by dragging and dropping it from a palette into the graphical program. In another embodiment the user may first include a timed loop node in the graphical program and may then request the graphical programming development environment to change the timed loop node into a timed loop with frames structure node or the user may first include a timed sequence node in the graphical program and may then request the graphical programming development environment to change the timed sequence node into a timed loop with frames structure node. For example the user may first include a timed loop in the graphical program. A regular timed loop name is semantically equivalent to a timed loop having a single frame. If the user desires a timed sequence of sub tasks to execute at each iteration of the timed loop then the user may create additional frames within the timed loop. For example the user may invoke a popup menu with menu items such as Add Frame Before and Add Frame After to create an additional frame. For example selecting the Add Frame After menu item on an empty Timed Loop would result in a two frame loop such as shown in . The menu may also include a Delete This Frame menu item that allows the removal of a frame from the loop. Within each frame of the timed loop the user may include a portion of graphical source code similarly as described above. Thus at each repetition of the timed loop the portions of graphical source code in the frames may execute sequentially according to the ordering of the frames similarly as described above.

The graphical programming development environment may also allow the user to configure timing of both the timed loop itself and the frames within the timed loop e.g. by statically setting timing information such as described above and or configuring timing information to be set dynamically during execution of the graphical program. For example configuration options and feedback available for a timed loop with multiple frames may comprise a union of the options and feedback available for an individual timed loop or timed sequence structure. This includes static configuration through the timed loop with frame structure s configuration dialog and runtime configuration and feedback using the right and left data nodes respectively.

Static configuration dialogs may be provided for configuring the timing of the loop as a whole as well as for individual frames. illustrates an exemplary dialog for configuring the timed loop as a whole. As shown the dialog provides controls for specifying timing information for the timed loop such as a timing source period priority etc. similarly as described above for timed loops. illustrates an exemplary dialog for configuring the right data node within each frame of the timed loop. As shown the dialog provides controls for specifying timing information for the next frame similarly as described above for timed sequence structures. Note that the right data node of the last frame provides configuration for the execution of the first frame during the next iteration. The left data node of the first frame provides feedback from the execution of the last frame during the previous iteration. Also note that the set of elements available through a given data node may change as frames are added or deleted at the ends of the sequence. Controls for specifying the period offset and late mode may only appear or may only be enabled on the dialog for the last frame in the timed loop since these properties affect timing for the next iteration of the timed loop. On the other hand the control for specifying the Start may appear or may be enabled on the dialog for all frames except the last frame.

At each iteration of the loop execution of individual frames within the timed loop may have the same semantics as the execution of frames within a timed sequence structure such as described above. Execution of the frames may proceed from left to right with the contents of frame i completing before anything in frame i 1 executes. The time at which a frame begins execution is controlled primarily by its Start value though execution may begin late if code which must execute before the frame does not complete in time.

The timing source for the individual frames may be the same as that of the overall timed loop or it may be a different timing source. If it is the same as the overall loop the user should ensure that the sum of each frame s period does not exceed the overall timed loop s period. In one embodiment the graphical programming development environment may indicate an error condition to the user if this is not the case.

In the embodiments described above timed loops or other elements may be included in a graphical program and configured with timing information manually i.e. in response to direct user input. In another embodiment the graphical program may be programmatically generated e.g. as described in the above incorporated patent application titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information . For example the user may utilize a tool or wizard operable to programmatically generate the graphical program. Thus timed loops and other graphical program elements described herein may be programmatically included in the graphical program and programmatically configured with timing information. Graphical source code may also be programmatically associated with the timed loops. It is noted that in one embodiment multiple timed loops may be programmatically included in the graphical program.

It is noted that various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a carrier medium.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

