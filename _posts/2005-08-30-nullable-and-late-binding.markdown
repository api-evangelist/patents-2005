---

title: Nullable and late binding
abstract: Systems and methods that enhance a programming language by introducing null unification on a type level in addition to a value level, for static types of both reference and value types T. An operator that adds a level of nullability (and removes such nullability) is introduced without a mention of the actual type, to steer overloading in a precise manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07716656&OS=07716656&RS=07716656
owner: Microsoft Corporation
number: 07716656
owner_city: Redmond
owner_country: US
publication_date: 20050830
---
As programming approaches and foundations have evolved application programming interfaces APIs and programming schemas have been developed to standardize and unify programming methodologies that were previously multi variant and relatively incompatible. Modem programming therefore often involves employing APIs and schemas in conjunction with reusable libraries. Such Programming languages continue to evolve to facilitate specification by programmers as well as efficient execution.

Compilers and or interpreters bear the burden of translating high level logic into executable machine code. In general a compilers and or interpreters are components that receive a program specified in a source programming language e.g. C C Visual Basic Java . . . and covert the logic provided thereby to machine language that is executable by a hardware device. However the conversion need not be done verbatim. In fact conventional compilers and or interpreters analyze the source code and generate very efficient code. For example programmers write code that sets forth a logical flow of operations that is intuitive and easy for humans to understand but is often inefficient for a computer to execute. Compilers and or interpreters can identify inefficiencies and improve program performance at the hardware level by eliminating unnecessary operations and or rearranging the execution of instructions while still achieving the intended results. In this manner programmers can create robust and efficient software programs.

Typically for Common Language Runtime CLR data types can be value types or reference types. Reference types are variables that are stored on a heap and referenced by a pointer stored on the stack or inside another object in the heap. Value types are variables that are stored directly on the stack. Consequently variables that are represented as reference types can be uninitialized termed null but variables that are represented as value types cannot be established in an uninitialized condition without risking indeterminate or even catastrophic results. Put differently a value type cannot be null because there is always a value and cannot be expressed as null.

Z has the type Nullable of Int and has a value of nothing e.g. via three valued or null propagating logic. Yet and as will be described in detail infra such can create problems in late bindings.

Moreover support for nullability across all types including value types is essential when interacting with null supported languages such as database languages e.g. SQL . A database language can employ a null value to indicate that the actual data value is unknown or missing. By providing null support within a general purpose programming language null supported languages and programming languages may be integrated e.g. code in the C programming language may read write or interpret nullable fields in a database language . The nullification problem has been previously addressed with many different strategies. Examples of such strategies include tuples variants convoluted pointer manipulations and boxing. However each of these strategies has one or more drawbacks.

For example boxing is an implicit conversion of a value type to the type object or to any interface type implemented by this value type. Put differently a value type that exists on a stack and obtain a pointer to a heap with a reference. Boxing a value of a value allocates an object instance and copies the value into the new object. Likewise unboxing is an explicit conversion from the type object to a value type or from an interface type to a value type that implements the interface. An unboxing operation typically consists of checking the object instance to make sure it is a boxed value of the given value type and copying the value from the instance into the value type variable.

Now consider the example of boxing a nullable. Typically the manner a nullable is implemented is via a structure that has a Boolean and value. This is achieved by automatically creating a multi element structure including an element for the underlying value and a Boolean element representing whether or not the underlying value is null e.g. flag indicating null or non null value for the underlying type . If the Boolean element is declared false for example the underlying type is considered null whereas if the Boolean element is true for example the value contained in the underlying value is considered the value of the nullable type variable.

For example nothing has no value and or value can be ignored. As explained earlier 5 of type nullable can be represented by a pair of boolean which is not null and has a value of 5 . As such the implementation for representing a nullable is via a structure that has a boolean and a value. Moreover considering a scenario of boxing a value 3 on the heap a reference to the value 3 can be obtained. Likewise when boxing the value of true 5 it is intuitively expected that there is a pointer to the heap that can contains true and 5.

Yet to box nothing and false then an inconsistency occurs because a reference is created to an actual thing when in fact the starting point was a nothing . For example the thing that has been referenced to does not represent nothing for a reference type. Put differently the starting point is an empty set yet the outcome is a set that contains the empty set and such represents an incorrect out come.

Moreover in a heap a distinction can be made between a boxed item and an integer yet a differentiation between nothing and the box nothing can be made which is undesirable. Accordingly if boxing a nullable type is desired if it is true and has a value such can be removed and boxed in manner wherein the boxing is aware of nullability.

An additional problem exists now that there is no trace that such previously existed as nullable as the representation of a boxed nullable int. is the same as a representation of a boxed int. Accordingly one cannot distinguish between nullable of T and boxed T.

Put differently reversal with fidelity when moving from a value type to an object via the boxing and vice versa for nullable types cannot be performed and a distinction is lost. Such can introduce problems for late binding. Referring to the example of 

Considering now the late bound addition of Dim C A B A can represent the no pointer nothing and B can be represented by the boxed 5. Yet it is not known that A and B are nullables. As such Visual Basic VB late bound addition will interpret nothing as zero and return a result of 5 instead of nothing which creates a difference in semantics depending on whether there is an early bound or a late bound. Such inconsistency is problematic and needs to be minimized. Put differently the overload and compiler can statically resolve the three valued or null propagating logic as the types are known at compile time yet for late binding and resolving at runtime the knowledge of nullability is unavailable.

Therefore there is a need to overcome the aforementioned exemplary deficiencies associated with conventional systems and devices.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

The subject innovation provides for systems and methods that enhance a programming language by introducing null unification on a type level in addition to a value level for static types of both reference and value types T. An operator that adds a level of nullability and removes such nullability is introduced without a mention of the actual type to steer static type overloading in a precise manner.

Accordingly a new operation can be implemented for types and expressions e.g. in form of a question mark that identifies nullability and symbol for removing nullability . For example considering an expression E on type T then E indicates as nullable of T. E operates on expressions and T operates on types. As such considering the example Dim C A B this indicates nullable of object object wherein the compiler can now perform static overload resolution. Put differently by providing such operator the programmer is enabled to change static type such that the overload resolution comes into play to perform the object object instead of object object. Accordingly the type name T need not be specified. Moreover such can be provided in form of a toggle that also has an opposite conversion e.g. expressed as E .

In a related aspect if no runtime support is available e.g. for nullability such as erasure of a nullable a compiler can trace nullability representation if T is a reference Type. If T is as a value type the following representations and type rules can be supplied 

As stated if T is a reference type then the compiler tracks the Nullable e.g. via metadata special metadata and the like with no different runtime representation. As such it must be erased and a determination made at run time. If

The run time type is represented by Tr and the compiler maintains that it is nullable and the type is erased to reference type As Nullable of Tr indicates an erasable representation and not represented by an actual type constructor and the compiler tracks that it is nullable at compile time. Accordingly there is no uniform representation for value type and reference type and the compiler has to know the case as it is hard wired into the compiler when there is no run time support.

In a related aspect if run time supported is provided wherein typically at run time an instance of the nullable type is known. The instance type is of the form S Nullable Of Nullable Of . . . Of T where T Nullable Of . . . wherein there is a number of nullables and then at some point a type that is not nullable e.g. a reference type or a value type . If T is reference type then when creating type S it can be represented S T. As such Nullable Of Nullable Of Object Object wherein the nullables are removed. If T is value type then S Nullable Of T thus Nullable Of Nullable Of Int Nullable Of Int . Thus with runtime support all levels of nullable up to a value type can be erased whenever the runtime attempts to instantiate a nullable type. For example at for just in time JIT compilers code generators when an actual type is constructed all type parameters are known and hence the correct representation can be unambiguously selected.

As stated earlier such requires runtime support wherein at run time when the type is instantiated the underlying execution mechanism knows about nullables and can supply null unification. It is to be appreciated that a Static type Nullable Of T exists but no such dynamic type nullable of T .

Moreover with runtime support the following generic nullable inducing function can be implemented e.g. for joins and databases 

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject invention are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs.

Furthermore the disclosed subject matter may be implemented as a system method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer or processor based device to implement aspects detailed herein. The term computer program as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Turning initially to a programming environment is illustrated that includes a null unification component via which the programming environment can provide nullable type support for programming languages wherein levels of nullability can be added or removed without a mention of the actual type to steer static type overloading in a precise manner.

The system includes one or more data structures that can be declared in the context of a programming language such as C C C Pascal Python Ruby Visual Basic Java and the like. The data structures can generally consist of an underlying type such as an integer float Boolean and so forth that can be declared to be a nullable type by associating a type modifier with the underlying type. The null unification component can enable a Nullable Of T as a static type for both value types and reference types as described in detail infra. Typically the value type describes a value that is represented as a sequence of bits stored on the stack. Likewise reference types can exist on a heap and supply a pointer. The null unification component can supply an operator that adds a level of nullability and removes such nullability that is introduced without a mention of the actual type to steer static type overloading in a precise manner. In general overloading is the practice of supplying more than one definition for a given function name in the same scope. The compiler is left to pick the appropriate version of the function or operator based on the arguments with which it is called.

Accordingly a new operation can be implemented for types and expressions e.g. in form of a question mark that identifies nullability. For example considering an expression E on type T then E indicates as nullable of T. As such considering the example Dim C A B such can indicate nullable of object object wherein the compiler can now perform static overload resolution. Put differently by providing such operator the programmer is enabled to change static type such that the overload resolution enters to perform the object object instead of object object. Accordingly the type name T need not be specified. Moreover the modifier can be provided in form of a toggle which also has an opposite conversion such as one expressed as .

then run time type is Tr and the compiler maintains that it is nullable and the type is erased to reference type As Nullable of Tr indicates an erasable representation and the compiler tracks that it is nullable at compile time. Accordingly there is no uniform representation for value type and reference type and the compiler has to know the case as it is hard wired into the compiler when there is no run time support. illustrates a compiler with a tracking component . As explained above if T is a reference Type and when no runtime support is available the tracking component can trace nullability representation.

In a related aspect if run time supported is provided wherein typically at run time an instance of the nullable type is known the instance type is of the form S Nullable Of Nullable Of . . . Of T where T Nullable Of . . . wherein there is a number of nullables and then at some point a type that is not nullable e.g. a reference type or a value type . If T is reference type then when creating type S it can be represented S T. As such Nullable Of Nullable Of Object Object wherein the nullables are removed. If T is value type then S Nullable Of T thus Nullable Of Nullable Of Int Nullable Of Int .

As stated earlier such requires runtime support wherein at run time when the type is instantiated the underlying execution mechanism knows about nullables and can supply null unification. It is to be appreciated that a Static type Nullable Of T exists but no such dynamic type nullable of T .

The compiler can accept as input a file having source code associated with processing of a sequence of elements. The source code may include various expressions and associated functions methods and or other programmatic constructs. The compiler can process source code in conjunction with one or more components for analyzing constructs and generating or injecting code.

A front end component reads and performs lexical analysis upon the source code. In essence the front end component reads and translates a sequence of characters e.g. alphanumeric in the source code into syntactic elements or tokens indicating constants identifiers operator symbols keywords and punctuation among other things.

The converter component parses the tokens into an intermediate representation. For instance the converter component can check syntax and group tokens into expressions or other syntactic structures which in turn coalesce into statement trees. Conceptually these trees form a parse tree . Furthermore and as appropriate the converter module can place entries into a symbol table that lists symbol names and type information used in the source code along with related characteristics.

A state can be employed to track the progress of the compiler in processing the received or retrieved source code and forming the parse tree . For example different state values indicate that the compiler is at the start of a class definition or functions has just declared a class member or has completed an expression. As the compiler progresses it continually updates the state . The compiler may partially or fully expose the state to an outside entity which can then provide input to the compiler .

Based upon constructs or other signals in the source code or if the opportunity is otherwise recognized the converter component or another component can inject code corresponding to facilitate efficient and proper execution. Rules coded into the converter component or other component indicates what must be done to implement the desired functionality and identify locations where the code is to be injected or where other operations are to be carried out. Injected code typically includes added statements metadata or other elements at one or more locations but this term can also include changing deleting or otherwise modifying existing source code. Injected code can be stored as one or more templates or in some other form. In addition it should be appreciated that symbol table manipulations and parse tree transformations can take place.

Based on the symbol table and the parse tree a back end component can translate the intermediate representation into output code. The back end component converts the intermediate representation into instructions executable in or by a target processor into memory allocations for variables and so forth. The output code can be executable by a real processor but output code that is executable by a virtual processor can also be provided.

Furthermore the front end component and the back end component can perform additional functions such as code optimization and can perform the described operations as a single phase or in multiple phases. Various other aspects of the components of compiler are conventional in nature and can be substituted with components performing equivalent functions. Additionally at various stages during processing of the source code an error checker component can check for errors such as errors in lexical structure syntax errors and even semantic errors. Upon detection error checker component can halt compilation and generate a message indicative of the error.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the innovation also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the innovative methods can be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects of the subject innovation is described that includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI.

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes various exemplary aspects. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing these aspects but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the aspects described herein are intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

