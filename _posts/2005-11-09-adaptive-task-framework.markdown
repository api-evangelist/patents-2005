---

title: Adaptive task framework
abstract: The subject disclosure pertains to systems and methods for performing natural language processing in which natural language input is mapped to a task. The system includes a task interface for defining a task, the associated data and the manner in which the task data is interpreted. Furthermore, the system provides a framework that manages the tasks to facilitate natural language processing. The task interface and framework can be used to provide natural language processing capabilities to third party applications. Additionally, the task framework can learn or be trained based upon feedback received from the third party applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07606700&OS=07606700&RS=07606700
owner: Microsoft Corporation
number: 07606700
owner_city: Redmond
owner_country: US
publication_date: 20051109
---
This application is related to co pending U.S. patent application Ser. No. 11 270 407 filed Nov. 9 2005 and entitled ADAPTIVE TASK FRAMEWORK . The entirety of the aforementioned application is hereby incorporated by reference.

Human languages are rich and complicated including huge vocabularies with complex grammar and contextual meaning. Machine interpretation of human language even in a very limited way is an extremely complex task and continues to be the subject of extensive research. Providing users with the ability to communicate their desires to an automated system without requiring users to learn a machine specific language or grammar would decrease learning costs and greatly improve system usability. However users become quickly frustrated when automated systems and machines are unable to interpret user input correctly resulting in unexpected results.

Natural language input can be useful for a wide variety of applications including virtually every software application with which humans are intended to interact. Typically during natural language processing the natural language input is separated into tokens and mapped to one or more actions provided by the software application. Each application can have a unique set of actions. Consequently it can be both time consuming and repetitive for software developers to draft code to interpret natural language input and map the input to the appropriate action for each application.

There is a need for a method or system that provides software developers with a standardized framework for adding a natural language interface to a software application. In addition there is a need for natural language interface that learns or adapts based upon user input and actions.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the provided subject matter concerns systems and methods for supporting natural language processing in which natural language input is mapped to a task. The system includes a task interface for defining a task the associated data and the manner in which task data is interpreted. Furthermore the system provides a framework that manages tasks to facilitate natural language processing. The task interface and framework can be used to provide natural language processing capabilities to third party applications. Additionally the task framework can learn or be trained based upon feedback received from the third party applications.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject invention are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

As used herein the terms component system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. In addition while the examples provided utilize the C and extended markup language XML programming languages numerous alternative programming languages may be used.

Furthermore the disclosed subject matter may be implemented as a system method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer or processor based device to implement aspects detailed herein. The term article of manufacture or alternatively computer program product as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

In general semantic analysis attempts to match natural language input to certain tasks or actions provided by an automated system. Typically semantic processing breaks the natural language input into strings of characters called tokens. The automated system can analyze the tokens as well as the user context to determine the appropriate task. The user context may include any information that indicates the user s current state such as recent user actions any software applications active on the user s computer or any other information indicative of the user s state.

A task may require information from the natural language input. Frequently tasks include slots that provide information about how to conduct the task. For example an airline reservation system can include a Book Flight task where the Book Flight task includes slots for the arrival and departure cities the arrival and departure dates and the number of passengers. The information required for those task slots can be retrieved from a natural language input e.g. I want a flight from Boston to Seattle with 2 passengers leaving on May 8 2005 and returning on May 25 2005 . In another example a word processing application can include a Create Table task having slots for the number of rows and columns and a line style. Those slots can receive values from the natural language input e.g. Insert a 2 by 4 table with dotted lines . A task slot is a holder for piece of data or information that may be retrieved from the natural language input.

Determining possible mappings from natural language input to the appropriate task slots is a complex problem that may be solved using a variety of different mathematical techniques. Conventional techniques include Hidden Markov Models HMM Maximum Entropy Minimum Divergence Models MEMD Na ve Bayes NB and Heuristic i.e. rule based approaches. Many techniques utilize a searching or decoding strategy e.g. a Viterbi search Beam search A search or other algorithm to determine the best solution out of a set of possible solutions.

The application can receive any manner of natural language input e.g. handwritten text tablet input speech and typed text . The application can process the natural language input to generate a query for processing by the task framework component . The query can be a simple string of text characters. The task framework component selects one or more application tasks based at least in part upon the query. The task framework component can provide the task with input data from the query and return the task to the application for execution.

In addition the task framework component can be trained to improve performance. Such performance can be enhanced by employing feedback to adjust ranking algorithms in one example to better match what users actually want from natural language systems or components. The task framework component can receive feedback from the application . This feedback can include explicit feedback such as user responses or reactions to the interpretation s of the natural language input or implicit feedback such as the actions selected by users. The task framework component can utilize any algorithm to improve interpretation of the natural language input e.g. Hidden Markov Models HMM Maximum Entropy Minimum Divergence Models MEMD Na ve Bayes NB and Heuristic i.e. rule based approaches .

The task framework component can be used with a variety of applications. For example a telephone speech server operating or application systems assistance web services e.g. airline reservations online shopping and event tickets and mobile devices e.g. email contacts and phone .

Possible implementations of a natural language processing system are described in detail below. The exemplary software code presented below is coded in the C programming language. However the natural language processing system and methods are not limited to the C language. Any suitable programming language or method may be utilized to implement the natural language processing system.

Referring now to the system provides a standard task interface. The task interface can handle most of the data exchange between the system and one or more applications. The task interface can provide software developers with a standardized system for defining tasks performed by the system. illustrates a task component in accordance with an aspect of the disclosed subject matter. The task component can include metadata about the task. For example the task component can include a name that identifies e.g. a task for booking airline flights may be named BookFlight . The task component metadata can also include a title that can be displayed to users. Additionally the task component can include a description that briefly describes the task. The description can be displayed to users either to allow the users to select the appropriate task or confirm that the appropriate task has been selected. The name title and description can be implemented using alphanumeric text strings.

The task component can include an entity component . The entity component can include one or more named entities. A named entity as used herein is a token that is known to have a specific meaning. The named entity can be task specific or can be utilized with multiple tasks. The task component can include a named entity NE recognizer component . The NE recognizer component can include one or more recognizers capable of matching tokens or portions of the natural language input to the entities included in the entity component . The NE recognizers are capable of recognizing tokens corresponding to the named entities contained within the entities component . These tokens have a specific task meaning. Recognizers may be general or may be specific to a certain category of tokens. For example a city recognizer may include a list of names e.g. Seattle Boston . Similarly a date recognizer may be capable of recognizing and interpreting dates such as Jun. 14 2005. The software developer may define certain recognizers when specifying a task.

The task component can also include a keyword component . The keyword component can include one or more keywords. Keywords can be used to select a task from a set of tasks. For example the BookFlight task keyword component can include keywords such as Book Flight airline and the like. The keywords can be determine by the software developer or automatically generated by the task framework. In addition the task framework can add additional keywords to the keyword component based upon natural language input user actions and or user feedback. Furthermore the keywords may be weighted such that the presence of certain keywords in the query is more likely to surface certain tasks. Such weight can also be used to rank or order a selected group of tasks.

The task component can also include a slot component that specifies or defines slots for information required for the task. The slot component can provide a mechanism for defining parameters used by the task. For example a task that books airline flights may include slots for the arrival city the departure city the flight date and time. The slot component can include any integer number of slots from zero to N. Typically information from the natural language input is used to fill the slots.

The slot component can also include an annotation component . The annotation component can include one or more annotations. Annotations are tokens that mark or indicate the significance of other tokens. The annotation component identifies an annotation token and uses that information to interpret other tokens within the natural language input. For example the token from when contained within a natural language input string that maps to a BookFlight task indicates that the token that follows is likely to contain the name of the departure city. Annotations may appear either before or after the relevant token. For example the token departure city when contained within a natural language input string that maps to a BookFlight task indicates that the token that precedes it is likely to contain the name of the departure city. Consequently the phrase leaving from Boston and Boston departure city can both be interpreted to fill the departure city slot with the value Boston. Annotations which appear before the token are called pre indicators while annotations which follow the relevant token are called post indicators. The annotation component can recognize task system defined annotations as well as task specific annotations.

The task component or task interface can provide software developers with a tool to define the actions available by their applications. Software developers can use this interface to define the tasks provided by their applications. This tool can provide a standard interface decreasing the software development cycle time. Either alternatively or in addition task components can be generated automatically by the task framework. The task framework can utilize user actions and feedback to generate task components or interfaces. Additionally the framework can use user actions and or feedback to modify task interfaces generated either by the framework an application or by a software developer. Consider the following exemplary task interface 

Task interfaces may be defined using extended markup language XML databases text files or in any other suitable manner. Software developers can define task interfaces such as the BookFlight task. Consider the following exemplary task interface 

The first line includes the task metadata including the name title and description. Next the task defines the keywords that can be used to locate the task from a collection of tasks. The task includes four separate slots Arrival City Departure City Arrival Time and Departure Time. Each of the slots includes one or more annotations. For example the Arrival City slot includes a list of Preindicators to going int and a list of Postindicators arrival city. The presence of any of those annotations in the natural language input will indicate the presence of the value for the Arrival City slot. A query such as I want a flight from Boston with an 8 30 departure time containing the keyword flight should retrieve the BookFlight task.

Consider the following additional exemplary task interface for creating a table such as might be used to create and insert a new table in a word processing document 

The system can provide a framework that uses an interface such as the task interface to provide a standard consistent architecture for natural language processing. As shown in the task framework component receives a query or queries from an application and passes back one or more tasks to the application. Each task is self contained and is responsible for its execution. The framework can be independent of the manner in which the task is executed. Consequently the framework can be used for a variety of applications e.g. speech assistance web services and other applications . The query can be a text string from the natural language input in which case the query can be tokenized or separated into individual words or groups of words. Alternatively the natural language input can be tokenized prior to being passed to the task framework component.

The task framework can include a task retrieval component . The task retrieval component uses the query to select one or more tasks from the collection of tasks contained within the task component . The task retrieval component may determine the appropriate task to be retrieved from the task component based upon keywords in the query. The collection of tasks in the task component can be indexed based upon the task keywords. The tokens contained within the query can be used to select an appropriate task or set of tasks. The application can also include additional information with the query. For example the application could pass user context information to the framework to be used in the selection of the appropriate task. The task retrieval component can use a variety of methodologies to select appropriate tasks. The task retrieval component can be trained to improve performance based upon user actions and responses to the selected tasks.

In addition the task framework can include a slot filling component . The slot filling component can be responsible for providing the best matching of the list of tokens from the natural language input or query with the task parameters. Typically a slot filling component can receive a list of tokens and one or more tasks. The slot filling component can generate one or more possible mappings of the tokens to the slots of the task. The slot filling component can generate a score or rank for each of the possible mappings of tokens to task slots. The slot filling component can use a mathematical model algorithm or function to calculate a score or rank for mappings. The slot filling component can utilize a heuristic function a hidden Markov model a Na ve Bayes based model Maximum Entropy Minimum Divergence Models MEMD blending strategies linear discriminative models or any combination thereof to calculate a score for a mapping of tokens to a task.

The slot filling component can include a method responsible for taking the natural language input culture information a list of tokens a list of named entities a task and a predetermined maximum number of desired solutions. Culture information can include information such as the writing system and formatting utilized by the relevant culture. Named entities identify tokens with a specific meaning to the slot filling system e.g. Boston . The slot filling component can produce a list of up to the maximum number of requested semantic solutions.

A semantic solution is a representation of a mapping of tokens to slots that can be used by applications. In addition the semantic solution can be more easily read by a user than the raw path data and may be presented to the user for verification. The semantic solution can be presented to users either as simple text or in a graphics display highlighting the semantic structure. A hierarchical tree structure representation may assist users in recognizing interpretations of natural language input. Consider the following exemplary semantic solution for the query I want a flight from Boston leaving on 10 23 05 for the BookFlight task 

The task framework can also include a logging component . Tasks can pass information or feedback to the task framework after completion of the task or during task processing. The logging component stores the feedback information. This information can be used to train the task framework and improve system performance. The feedback from tasks can include user actions. The task framework can include a defined intent interface to facilitate feedback. Consider the following exemplary feedback interface referred to as the intent interface 

The intent interface can include sufficient information to train the task retrieval component and the slot filling component . The interface provides a simple mechanism for applications and tasks to pass feedback to the task framework. Connectors such as and or or and modifiers such as less than or not can be ignored for the purposes of the intent interface to maintain simplicity for application developers however it is to be appreciated that these connectors can be added back into the interface without deviating from the intended use of the interface.

In addition the task framework or the slot filling component can include one or more GlobalRecognizers that provide the ability to recognize tokens that have special meaning to the task system in general. For example the token Boston has special meaning as the city of Boston Mass. The GlobalRecognizers property provides a set of recognizer components that identify special tokens making them available throughout the entire system and across multiple tasks. For example there may be several tasks that utilize city date or number entities. Entities are a mechanism for providing type information. For example the city entity includes a set of annotations e.g. city place and town . Occurrences of the annotations within the list of tokens indicate the likelihood of a city entity. GlobalRecognizers allows such entities or special tokens to be defined once rather than for each individual task.

The aforementioned systems have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Additionally it should be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several sub components. The components may also interact with one or more other components not specifically described herein but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems above and methods below may include or consist of artificial intelligence or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flowcharts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Additionally it should be further appreciated that the methodologies disclosed hereinafter and throughout this specification are capable of being stored on an article of manufacture to facilitate transporting and transferring such methodologies to computers. The term article of manufacture as used is intended to encompass a computer program accessible from any computer readable device carrier or media.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like displays e.g. flat panel and CRT speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection s . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems power modems and DSL modems ISDN adapters and Ethernet cards or components.

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

