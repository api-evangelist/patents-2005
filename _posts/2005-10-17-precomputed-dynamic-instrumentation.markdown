---

title: Pre-computed dynamic instrumentation
abstract: A system and method for instrumenting program instructions. A processing system includes a compiler and a profiler. The compiler is configured to notify the profiler of a compilation event corresponding to first program instructions. In response to detecting the event, the profiler is configured to intercept compilation of the first program instructions, determine whether an instrumented version of the first program instructions is currently available, instruct the compiler to compile the instrumented version of the first program instructions if available, and retrieve and instrument the first program instructions if not available. The profiler may maintain an instrumentation cache for storing instrumented versions of program instructions. The instrumentation cache may further include metadata which identifies portions of program code which have been instrumented and their location. The profiler may generally instrument program instructions once during the resident life of a corresponding application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07805717&OS=07805717&RS=07805717
owner: Symantec Operating Corporation
number: 07805717
owner_city: Mountain View
owner_country: US
publication_date: 20051017
---
This invention relates to computer processes and more particularly to the instrumentation of computer application code.

In order to gain a fuller understanding of the operation of software processes it is common to employ any of a variety of monitoring profiling and or analysis programs in conjunction with the software processes to be understood. Such monitoring profiling and analysis programs which for simplicity may collectively be referred to as profilers are available from many vendors or may be custom made for specific applications. As part of a profiling or monitoring process application code may be instrumented by adding instructions i.e. code sometimes referred to as probes to an application s original code. These probes may then generate additional data concerning the operation of the application during runtime.

Traditionally there have been two general approaches to the instrumentation of application code. One approach is static instrumentation and the other approach is dynamic instrumentation. However both of these approaches have disadvantages. Static instrumentation generally involves replacing an application s original executables with instrumented executables. However such an approach can be difficult to manage. One difficult with managing statically instrumented applications is the user needs to know which executables make up their application and which executable are instrumented and non instrumented. Another problem with static instrumentation is that digitally signed code generally cannot be instrumented. If a digitally signed assembly library or other code is instrumented the process which loads the instrumented code may reject it due to a failed signature verification.

In dynamic instrumentation application code e.g. intermediate code may be instrumented at the time the code is actually loaded for execution. For example in the Microsoft .NET framework bytecodes may be instrumented when a method or assembly is loaded for just in time JIT compilation. Alternatively code may be instrumented when a class is loaded in a Sun Microsystems Java environment. While the dynamic approach may avoid the need for replacing deployed executables on disk it may also entail significant performance implications due to the overhead involved. Further it may also be very difficult to support and maintain code while using a dynamic instrumentation approach because no instrumented files are generated that can be sent to support.

In view of the above an effective and efficient method and mechanism for instrumenting application code is desired.

A processing system is contemplated which includes a compiler and a profiler. The system is configured to support registration by various components for notification of events. The compiler is configured to notify the profiler of a compilation event corresponding to first program instructions. Responsive to the event the profiler is configured to intercept compilation of the first program instructions. The profiler is then configured to determine whether an instrumented version of the first program instructions is currently available. If an instrumented version is already available the profiler directs the compiler to the already instrumented version and the compiler compiles the previously instrumented version. If the profiler determines that an instrumented version is not currently available the profiler is configured to retrieve and instrument the first program instructions. The newly instrumented version is then stored in an instrumentation cache and provided to the compiler for compilation.

Also contemplated is an instrumentation system and method where a profiler generates and stores metadata corresponding to program instructions which have been instrumented. The metadata may indicate both the presence of instrumented versions of particular code and the locations of instrumented versions of code. In one embodiment the profiler may generally instrument program instructions only once during the resident life of a corresponding application.

These and other embodiments will become apparent upon reference to the following description and accompanying figures.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed descriptions thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The following description is presented to enable one of ordinary skill in the art to make and use the invention. Descriptions of specific embodiments and applications are provided only as examples and various modifications will be readily apparent to those skilled in the art. The general principles described herein may be applied to other embodiments and applications without departing from the scope of the invention. Thus the present invention is not to be limited to the embodiments shown but is to be accorded the widest scope consistent with the principles and features described herein.

Processor may be configured to execute instructions and to process data according to a particular instruction set architecture ISA . In one embodiment processor may be configured to implement an x86 compatible ISA although in other embodiments it is contemplated that any desired ISA may be employed such as the SPARC V9 ISA PowerPC compatible ISAs or MIPS compatible ISAs for example. SPARC is a registered trademark of Sun Microsystems Inc. PowerPC is a registered trademark of International Business Machines Corporation MIPS is a registered trademark of MIPS Computer Systems Inc. .

In various embodiments memory may comprise any suitable type of system memory as described above such as FB DIMM DDR DDR2 SDRAM or RDRAM for example. Memory may include multiple discrete banks of memory. Also in some embodiments memory may include multiple different types of memory.

In some embodiments computer may include more than one instance of the devices shown such as more than one processor for example. In various embodiments computer may be configured as a rack mountable server system a standalone system or in any other suitable form factor. In some embodiments computer may be configured as a client system rather than a server system.

In one embodiment processor may be configured to run operating system software such as a Microsoft Windows operating system IBM AIX operating sysetm or Sun Microsystems Solaris operating system. Operating system software may in turn provide an environment in which processor may execute additional software modules in the form of applications programs or processes designed to perform specific functions. Running operating system software or software modules may comprise executing instructions that are stored in memory .

Software modules that may be executed by processor may include in one embodiment client server software such as a web server or a web browser. Alternatively or in addition processor may execute software modules comprising network management software office productivity tools e mail programs etc. Many other types of software may be executed such as a virtual machine runtime environment a database an application server and diagnostic monitoring profiling or analysis software. Furthermore while executing such software processor may retrieve data from and store data in non volatile storage or in memory . In one embodiment one or more software processes may perform the function of profiling other software processes during operation gathering and storing data indicative of the operation of one or more of the other software processes.

Turning now to one embodiment of various components of a computing system are depicted. In the illustrated embodiment software processes are shown to include an application process event detection process code translator and profiler . Also shown is a storage device which includes uninstrumented application code and an instrumentation cache . Storage device may generally comprise non volatile storage such as a hard disk s . However those skilled in the art will appreciate that numerous types of storage devices and technologies volatile or non volatile may be utilized to store data.

Generally speaking provides a high level view of a system which is configured to support the instrumentation of application code for monitoring profiling or any other desired purpose. In one embodiment a computing system s runtime environment is configured to support dynamic translation of application code at the time of loading or execution. For example in one embodiment uninstrumented application code may comprise an application s original uninstrumented code which is stored on a disk . Such code may comprise an intermediate representation such as a bytecode representation or some other representation which is generally portable across computing platforms. Some examples of systems configured to use intermediate representations include Microsoft s .NET framework and some versions of Sun Microsystems Java language. Other embodiments may utilize computing platform specific representations whether intermediate or not.

In an embodiment wherein the application code is an intermediate representation compilation of the application code from the intermediate representation to a native language which is specific to a given platform may be performed at the time the application code is loaded for execution. Generally speaking when the application code is loaded for execution a code translator or compiler may be invoked to translate the application code to the native language. Code translator may for example comprise a just in time JIT compiler or similar component. The translated or compiled application code may then be executed. In some embodiments when an application is loaded for execution all code of the application may be translated compiled or otherwise made ready for execution. However in other embodiments certain portions of the application code may not be translated or compiled until needed. For example in one embodiment particular functions or methods of an application may not be translated until such functions or methods are encountered e.g. called or invoked during execution of the corresponding application code . Rather when the application code is initially loaded only the calls to such functions or methods themselves are translated. When the function or method is required during execution the corresponding code is located translated by the translator and executed.

In one embodiment profiler is configured to instrument application code by inserting additional code or otherwise modifying existing code of an application. Such a profiler may be configured to instrument the application code on disk prior to the application being loaded. Alternatively or in addition to the above profiler may be configured to instrument application code dynamically at the time the code is loaded for execution.

In one embodiment profiler may be configured to register with the underlying software subsystem to receive notification of various events. When such an event is detected by an event detection process the profiler is notified of the event s occurrence. Upon notification of a particular event the profiler may then take some action. In one embodiment the profiler registers to be notified when code translator is preparing to translate or compile application code. Notification of the compilation event may also include some identification of the application code e.g. function or method which is to be compiled. In response to the notification profiler may be configured to retrieve the identified application code and instrument or modify the intermediate code prior to the code being translated by code translator . After instrumenting the code the profiler is configured to direct the translator to the instrumented version of the code. The translator may then translate or compile the instrumented version of the code which may then be executed.

In addition to the above profiler may also be configured to maintain an instrumentation cache which is configured to store application code which has been instrumented or otherwise modified. In an embodiment including the instrumentation cache profiler may be configured to access the instrumentation cache in order to determine whether particular application code has previously been instrumented or modified. If a previously instrumented version is found the profiler may simply provide the previously instrumented version to the code translator for translation. In this manner as the code was previously instrumented the process of instrumenting the code may be bypassed on this occasion and the overhead and latencies associated with instrumentation may be eliminated.

In the embodiment of it is noted that the original application code remains on disk in an unmodified form. However in addition to the original code an instrumented version of the code is also created and stored in instrumentation cache . Accordingly application code may be instrumented in a dynamic manner while also having stored versions of the instrumented code. Having the stored instrumented versions available may facilitate debug or other diagnostic efforts when problems arise with the computing system.

Upon detection of the compilation start event decision block a profiler may check an instrumentation cache decision block to determine whether the code which is to be compiled has previously been instrumented. Various mechanisms may be utilized to determine whether particular code has been previously instrumented. For example when a compilation start event is detected the event may also provide some identification of the code to be compiled. Such an identification may comprise a token address or other identifier which corresponds to the code. The profiler may maintain metadata including an index or list which itself includes the token address or identifier. The presence of the identifier in the list may serve to indicate an instrumented version of the code is available. In addition the metadata may also identify the location of the instrumented version e.g. within the instrumentation cache . In this manner the profiler may quickly identify if particular code has already been instrumented and if so locate the instrumented version.

If a previously instrumented version of the application code is found in an instrumentation cache decision block then the instrumented version of the code may be made available to the compiler block . However if no previously instrumented version of the code is found in the instrumentation cache then the instrumenter may obtain the code which is to be compiled and instrument the obtained code block . Subsequent to instrumenting the code the instrumenter may then store an instrumented version of the code as well as corresponding metadata in an instrumentation cache block and provide the instrumented version to the compiler block . It is noted that blocks and may occur in any order or concurrently.

Turning now to one embodiment of a software system is illustrated which includes components based on a Microsoft Windows operating system and Microsoft .NET framework. While a Microsoft Windows operating system and .NET framework are utilized for purposes of discussion the methods and mechanisms described herein may be applied in other environments as well. In the illustrated embodiment a process and a profiler are shown coupled to a .NET framework which may be supported by a Microsoft Windows operating system Windows . Process may be for example an active server page ASP conforming to the ASP.NET specification. Windows may be one of Windows 98 Windows 2000 Windows XP or any other version of the Microsoft Windows operating system with which .NET framework is compatible. In one embodiment .NET framework includes a .NET profiling application programming interface API . Profiler may be an application written to use the functionality provided by the .NET profiling API and configured to instrument application code.

In addition to the above illustrates an instrumentation cache and original application code and metadata . In one embodiment instrumentation cache and original code are stored on non volatile storage such as a disk but other storage mechanisms are possible and are contemplated. Also illustrated is a compiler or translator . Compiler may comprise a just in time JIT compiler configured to compile from a portable intermediate code to a native code of a device on which the code is to be executed. As further illustrated in Windows may include environment variables envars a User32.dll and a list of Appinit DLLs . Envars are environment variables used by Windows to establish an operating environment for each process that is launched. User32.dll is a dynamic link library that may be linked to user defined processes at the time of launch such as process that utilize the Windows user interface functionality.

In one embodiment during the launch of process Windows may load various files or libraries into process using a procedure referred to as dynamic linking. Specifically in one embodiment Windows may load User32.dll into process . As part of the loading procedure for a windows process Windows may execute a function in User32.dll known as DLLMain with an argument of DLL PROCESS ATTACH. This function may execute a LoadLibrary function to load and initialize DLLs that are listed in AppInit DLLs . AppInit DLLS may include user specified DLLs etc. that may be dynamically linked to a process during initialization. In the illustrated embodiment one of the AppInit DLLs is an injector.dll . Injector.dll may be configured to read a set of values for environment variables from configuration file and set the environment variables for process according to these values.

Two environment variables in particular may control profiling of process . The first COR ENABLE PROFILING enables or disables profiling of process . For example setting COR ENABLE PROFILING may enable profiling and clearing COR ENABLE PROFILING may disable profiling. The second COR PROFILER may be used to identify a particular profiler such as profiler which itself may comprise a DLL to be used for instrumenting code corresponding to process . Accordingly injector.dll may retrieve and set values for environment variables COR ENABLE PROFILING and COR PROFILER that apply to process during the launch procedure. In one embodiment child processes which are spawned by a parent process may inherit the environment including environment variable settings of the parent process. Accordingly in one embodiment injector.dll may be configured to establish particular environment settings for an application upon initialization of the application. Such settings may then be applied to all processes of the application throughout the life of the application i.e. until all of the application processes are terminated . In one embodiment injector.dll may consult a configuration file not shown to determine whether a particular application is to be instrumented. In order to avoid the delay of reading from non volatile storage a copy of the configuration file may be maintained in memory for faster access.

Generally speaking operation of the system depicted in may be as follows. During installation or configuration of code corresponding to the profiler the profiler may be configured to register various software components with the underlying framework and or operating system . Such registration may include the registering of particular DLLs such as profiler.dll . In addition profiler.dll may be configured to register to be notified of particular events as discussed above. In one embodiment profiler.dll registers to be notified of compilation events corresponding to the JIT compiler . In particular profiler.dll may be notified upon the occurrence of an event which indicates JIT compiler is requesting or otherwise preparing to compile application code .

Upon detection of such an event profiler may determine e.g. via a configuration file whether the code which is to be compiled is to be instrumented. If the event corresponds to the initial loading of an application profiler may proceed with an instrumentation process as described below. Alternatively if the event does not correspond to the initial loading of an application e.g. a method is being invoked profiler may first perform a check to determine whether the code has already been instrumented and stored.

In the event of an initial loading of an application uninstrumented application code is retrieved for compilation. In one embodiment application code may comprise one or more assemblies suitable for use within a .NET framework . Generally speaking an assembly may comprise a distributable library of related classes and a definition of their scope. Included with an assembly may also be a manifest which contains metadata describing the exported classes in the assembly external dependencies required by the classes various permissions for using the assembly versioning information and so on. In addition to the above in one embodiment application code comprises an intermediate code such as byte code which has already gone through a compilation process from an original source language.

In one embodiment JIT compilation occurs at the assembly level whenever an assembly is first loaded. Method or functions encountered during compilation of the assembly are not themselves compiled. Rather an identifier e.g. a stub may be inserted for each such function or method. Only when a particular method is invoked is the body of the method compiled from the intermediate code to the native language of the machine. Upon initiation of code compilation JIT compiler or the underlying runtime notifies the profiler . In one embodiment compiler may notify the profiler via the IcorProfilerCallback JITCompilationStarted method of the .NET framework . Included in the notification to the profiler is an identifier which may be utilized to identify the particular code to be compiled. In response profiler intercepts the compilation process and invokes the instrumenter to instrument a body of code which may comprise a superset of the code which is to be compiled using intermediate language instructions. Subsequent to instrumenting the code the instrumenter stores the instrumented version in the instrumentation cache . In addition profiler generates metadata which may be used to identify and locate instrumented versions of application code within the instrumentation cache . In various embodiments profiler may be configured to only instrument selected methods of functions of a given assembly. In such a case profiler may not instrument application code upon initial loading. However even in such a case profiler may still generate and store metadata corresponding to the application. Such metadata may include the identification of various methods and functions of an application but may also indicate such methods and or functions have not yet been instrumented.

In response to detecting a JITCompilationStarted event corresponding to a method or function profiler may utilize a received identifier to identify the method or function to be compiled. The profiler may then access instrumented code metadata which could be on disk memory resident etc. to determine whether the corresponding method or function has been instrumented. If an instrumented version of the method is not available in the instrumentation cache profiler may then access code containing the body of the method to be compiled. For example by accessing the assembly containing that code. The code can then be instrumented and placed in the instrumentation cache as described above.

Once instrumented code has been acquired by the profiler various approaches may be used to modify the method body including using the SetILFunctionBody method provided by the .NET framework . In addition the profiler stores a copy of the instrumented version of the method in the instrumentation cache . Further the profiler modifies the metadata of the running process to contain all metadata required by the instrumented method. In one embodiment profiler may use the GetILFunctionBody method to obtain the method body. The profiler may then instrument the method body prior to allowing the compilation process to continue. Further the profiler may modify the instrumented code metadata to indicate the presence and location of the instrumented version of the code.

If in response to the detection of a JITCompilationStarted event the profiler determines an instrumented version of the code already exists in the instrumentation cache the profiler provides the JIT compiler with a pointer or other identifier of the location of the instrumented version. It is noted that the JIT compiler may not generally have any idea that the code being compiled is an instrumented version rather than an original version. Rather the JIT compiler simply proceeds with the compilation of the instrumented version of the code. In various embodiments application code may include metadata which includes offsets to methods and functions included therein. When profiler instruments code such offsets may generally be changed. Therefore the instrumented code metadata generated by the profiler may include a mapping of original offsets to new offsets.

However if the profiler determines an instrumented version of the method is not stored in the instrumentation cache or otherwise determines compilation of the original method code is desired or required decision block the profiler begins an instrumentation process. In one embodiment the profiler may use the identification e.g. functionID of the method provided by the notification to obtain further information regarding the method. For example in one embodiment the profiler may retrieve a class ID method ID metadata token and any other information deemed suitable or necessary block .

In one embodiment the profiler may first allocate new space for the method body which is to be modified block . However other embodiments may be configured to work directly on the method body itself rather than a copy. The profiler may then retrieve method body e.g. using GetILFunctionBody and instrumented the retrieved code block . The profiler may further set a pointer e.g. via SetThFunctionBody to the method body to point to the new modified version block . Setting a pointer in this manner may have the effect of directing the compiler to the instrumented code for compilation. In addition the profiler may modify corresponding meta to identify the location of the instrumented version block and store the instrumented version in an instrumentation cache block . It is to be understood that the activities depicted in may occur in a different order than that depicted and one or more may occur concurrently. In addition other embodiments may utilize more or fewer activities as appropriate.

In addition to the above various embodiments are contemplated in which the instrumentation cache may be populated in various ways and at various times. For example in the discussion above instrumentation and population of the instrumentation cache is generally described as occurring at load time or when a given method is called during runtime. However in other embodiments different approaches to instrumentation and cache population may be utilized. In one embodiment a hybrid approach to instrumentation may be utilized wherein both static and dynamic instrumentation are used. For example some portion of an application s code may be instrumented prior to loading while another portion of the application s code is instrumented during runtime as described above. In such an embodiment a profiler and or instrumenter may be operable in a standalone mode and may be operable to instrument specified assemblies libraries methods or other portions of code. The instrumented code may then be stored in an instrumentation cache. In this manner less instrumentation may be required at load time and or during runtime. Such an approach may serve to speed load time in some cases.

In one embodiment a separate configuration file may be utilized by the profiler which indicates how and when instrumentation may be performed. For example static instrumentation could be performed for specified DLL s while dynamic instrumentation could be reserved for only those DLL s in a global assembly cache GAC . All such combinations of static and dynamic instrumentation and use of configuration files are contemplated. In addition to the above a mode is contemplated wherein a profiler or instrumenter may observe operation of a specified code. During the observation made data may be stored which identifies various characteristics of the code being observed. Based upon the gathered characterizing data decisions may be made as what portions of code may be instrumented. Such decisions could be made manually i.e. by a person viewing the gathered data and making corresponding entries in a configuration file or automatically. For example in one embodiment the decision as to whether a portion of code is to be instrumented could be made automatically based upon the nature of the code itself i.e. certain types of called functions or methods may have a higher priority for purposes of instrumentation the behavior of code during execution i.e. some methods are called a relatively large number of time and so on.

It is noted that the above described embodiments may comprise software. In such an embodiment the program instructions which implement the methods and or mechanisms may be conveyed or stored on a computer readable medium. Numerous types of media which are configured to store program instructions are available and include hard disks floppy disks CD ROM DVD flash memory Programmable ROMs PROM random access memory RAM and various other forms of volatile or non volatile storage.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

