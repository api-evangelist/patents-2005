---

title: Method and system for monitoring performance on a mobile device
abstract: A method and system are provided for implementing performance monitoring of an application on a mobile device. An instrumentation tool is provided allowing a user to view the entities in an application file for a mobile device and selecting those entities for which performance monitoring is to be implemented. The instrumentation tool adds performance monitoring methods to the application file and generates a new instrumented application file that is transferred to the mobile device. When the instrumented application file is executed on the mobile device, the performance monitoring methods instrumented into the file execute generating data in a performance log file that is stored on the mobile device. This performance log file may be transferred to a remote device for further analysis in addition to viewing the performance log file on the mobile device. The user selected entities for performance monitoring in the application file may be saved to a configuration file that can later be loaded and modified by the user to facilitate further performance monitoring of an application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07788644&OS=07788644&RS=07788644
owner: SAP AG
number: 07788644
owner_city: Walldorf
owner_country: DE
publication_date: 20050324
---
A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention relates to a method and system for monitoring performance in an application where a user can select what entities in an application file are monitored and the monitoring commands are incorporated into a new version of the application file according to one embodiment of the present invention.

Many performance measurement tools exist in the commercial market each having its own specific capabilities. The most common of these systems perform full code instrumentation i.e. brute force instrumentation where performance monitoring is instrumented for all methods of an application. This can be particularly advantageous because it may capture all the calls made by the application during runtime. For example calls are dynamic and are not part of the static hierarchy of an application program. During application runtime a call may or may not be made. Using the following pseudo code as an example illustrates why a method call in an application may or may not occur during runtime.

In the above pseudo code either method left or method right is executed depending on the value of variable x. Full code instrumentation provides performance monitoring of all the calls including those to both method left and method right and may include monitoring of variable values such as variable x. For this and other reasons full code instrumentation for performance monitoring is common in conventional systems such as IBM s Rational PurifyPlus formerly Visual Quantify and Compuware Corp. s DevPartner Studio formerly NuMega .

Applications for mobile devices mobile applications present a particular challenge to performance monitoring in that the greater the instrumentation of the application code to be monitored the greater the overhead placed on the application and the limited resources of the mobile device. The limited processor capability and memory storage for mobile devices such as for example personal digital assistants PDAs and mobile phones means that greater instrumentation may result in greater execution times for the application as well as increased memory storage usage on the mobile device. This may be sufficient to cause the application to fail to execute on the mobile device or the mobile device to crash rather than just a degradation in performance. In addition the limited memory storage of most mobile devices prevents extensive logging of the performance monitoring data. The greater the amount of application code instrumented the greater the amount of memory or storage needed by a performance log file on the mobile device to store the performance monitoring data. Because mobile devices are not always connected to a network reliance on a server or other remote device to store the logging data may not be adequate to capture the necessary performance monitoring data. In addition the greater the degree of instrumentation of the application code the greater the extent to which the performance measurements are skewed by the resource requirements of the performance monitoring. For example the performance monitoring instrumentation code may be measuring its own resource consumption and impact on the application program.

The present invention presents an innovative method for addressing the challenges of performance monitoring in resource limited environments such as for an application running on a mobile device.

A method and system are provided for implementing performance monitoring of an application on a mobile device. According to one embodiment of the present invention an instrumentation tool is provided allowing a user to view the entities in an application file for a mobile device and selecting those entities for which performance monitoring is to be implemented. The instrumentation tool adds performance monitoring methods to the application file and generates a new instrumented application file that is transferred to the mobile device. When the instrumented application file is executed on the mobile device the performance monitoring methods instrumented into the file execute generating data in a performance log file that is stored on the mobile device. This performance log file may be transferred to a remote device for further analysis in addition to viewing the performance log file on the mobile device according to one embodiment of the present invention. The user selected entities for performance monitoring in the application file may be saved to a configuration file that can later be loaded and modified by the user to facilitate further performance monitoring of an application.

Performance monitoring refers to any profiling operation that measures the runtime behavior of an application on a mobile device. For example memory consumption is a runtime behavior of an application that may be profiled or monitored. Any measurable runtime behavior to include for example method or function calls made by the entity may be profiled or monitored according to the present invention. Performance monitoring is implemented on an entity basis as discussed below providing particular details on how selected entities in the application are performing. The terms performance monitoring and profiling are used interchangeable throughout this specification. Though the example embodiment discussed above relates to a mobile device the present invention may be applied to any processor based device in other embodiments of the present invention.

According to one embodiment of the present invention the instrumentation the addition of performance monitoring methods or functions in an application file is not a brute force monitoring of the application as conventionally known where the performance of the entire application is monitored. Instead the performance monitoring is tailored to user selected entities in the application allowing for focused monitoring and or reduced resource requirements facilitating the implementation of performance monitoring on mobile devices. Entities may be any element of an application and may include an entire application file such as an archive file a package a module a method a class a function a block of code and or a line of code. The instrumentation tool determines the entities available and presents those entities to the user according to one embodiment of the present invention. The instrumentation tool may be constructed in a way to use particular entities suited to the platform or programming environment for which it is written. For example an instrumentation tool for Java applications may allow the instrumentation of performance monitoring for entities such as for example Java ARchive JAR files classes and methods.

The instrumentation of an application file may be performed for a source code file an intermediate file e.g. a Java bytecode file or a binary file. For example if a source code file is being used a source code parser may be used by the instrumentation tool to determine the entities to be presented to the user to select for performance monitoring. Some programming languages such as Java have an intermediate step between source code and executable code. In Java source code is compiled into intermediate bytecode that contains abstract machine independent instructions that are later interpreted by a Java virtual machine application in the Java platform into machine specific executable code. Even binary code contains symbolic information that can be used to determine parts of the code such as entities. For example a compiler debugger may use this type of symbolic information. In the example embodiment of the present invention illustrated below instrumentation occurs at the intermediate Java bytecode level though in other embodiments instrumentation may occur at the source code or binary code levels.

The result of the instrumentation of an application file is the collecting of performance monitoring data on the mobile device. During the performance monitoring or profiling on the mobile device this data is collected and stored in a file. This file is generally stored on the mobile device because the mobile device will at times not be connected to any other device. However the file may be transferred to a remote device during periods of mobile device connectivity according to this embodiment. For example when a mobile device is connected to another device over a wireless connection such as an IEEE 802.11g wireless network Bluetooth or other wireless connection the file may be transferred to the remote device e.g. a personal computer or workstation releasing the storage space used on the mobile device. It is undesirable to transfer the data to any device therefore in one embodiment the mobile device or the instrumented file transferred to the mobile device may need to be affiliated or otherwise registered with the remote device to which the performance monitoring data will be transferred. This affiliation may occur automatically during the instrumentation process by incorporating affiliation information during the instrumentation of the performance monitoring methods or may occur during the transfer of the instrumented file to the mobile device. Alternatively the affiliation may require user specification in a manual or semi automated process in other various embodiments of the present invention. The transfer of the performance monitoring data to a remote device may also allow for greater processing analysis of the data than may otherwise be possible on the mobile device.

As previously stated the user interacts with the instrumentation tool through a graphical user interface . In a Java environment standard graphical user interface components are found in Java Foundation Classes and in particular the Swing set of components in one such class library. Java Swing includes features providing user interface components such as frames trees and tables in addition to buttons list boxes combo boxes and checkboxes. A window or frame is created and used as the main interface for accessing the instrumentation tool according to this embodiment. The user starts the instrumentation tool in a conventional manner such as for example clicking on an associated startup.bat file. is a screen shot of the instrumentation tool according to one embodiment of the present invention. The screen shot shown in is similar to the initially displayed frame except that the left side panel displaying the hierarchical tree structure of the application file e.g. JAR file the top right side panel displaying the path of the application file e.g. JAR file and the bottom right side panel displaying a list a list box of the names of the methods selected by the user for instrumentation to implement performance monitoring are all initially empty. The left side panel does not contain any packages classes methods or entities because the user has not yet chosen an application file for instrumentation. For this same reason the upper right side panel is also empty. The lower right side panel is similarly empty because methods are not available to be selected. Some of the drop down menu items may also be disabled because they can not be implemented at the moment. For example if no file is open then a Save menu item may be disabled in the File menu . Disabled menu items may be displayed in a shadowed or faded format in one embodiment though any method to differentiate disabled menu items including temporarily removing them from the menus may be used in various embodiments of the present invention. Alternatively the menu items may not be disabled and an error or other message may be provided if these menu items are executed at an inappropriate time. Once the user initiates the instrumentation tool the user may open a file to be profiled instrumented using any of the available means to do so. For example a file may be opened by selecting the Open option in the File drop down menu or by selecting an appropriate shortcut key combination such as CTRL O where available.

The instrumentation process is illustrated using Java in the following example according to one embodiment of the present invention. Java programs are those written in the Java programming language using class files that are compiled into bytecode for the Java virtual machine JVM of the Java platform. Bytecode is machine independent code generated by the Java compiler and executed by the Java interpreter. The Java interpreter decodes and executes bytecode for the Java virtual machine an execution engine that executes the bytecode commands in the Java class files on a microprocessor. is a diagram illustrating the Java source code to executable code model as interpreted for one embodiment of the present invention. The program illustrated is a simple program that displays the message Hello World . The Java programming language source code class file is compiled by the Java compiler into a class file containing Java bytecode that is interpreted for execution using other class files as necessary by the Java interpreter of the Java virtual machine . The instrumentation process adds instructions to the existing programs by engineering the bytecode using for example Apache Software Foundation s Byte Code Engineering Library BCEL according to this embodiment of the present invention. BCEL provides a framework to manipulate Java class files with the framework used to insert the performance monitoring methods necessary for the instrumentation of the application file. This embodiment is only one example of how the instrumentation of the programming code can be implemented and other methods may be used in other embodiments of the present invention.

At least one performance monitoring profiling method needs to be added to the application file to implement the instrumentation of the performance measurements according to this embodiment of the present invention. This embodiment uses the BCEL provided Java API to create a method object for the at least one performance monitoring method. In particular MethodGen of BCEL may be used in this process. A new Java class is created and defined according to the current class but also modified with the at least one profiling performance monitoring method. The result is a Java class incorporating the instrumentation methods that allow for performance monitoring. is a diagram illustrating the instrumentation of Java source code for a class using the instrumentation tool according to one embodiment of the present invention. The original Java class source code is shown before being acted on by the instrumentation tool . The resulting source code contains the additional profiling method calls that provide for the performance monitoring according to this embodiment of the present invention.

The MainGui class is responsible for displaying the user interface to include displaying the tree structure of the entities from one or more application files selected by the user. For example the MainGui class may display the tree structure of a Java Archive JAR file selected by the user. According to the embodiment shown in a CheckRenderer class is called by the MainGui class to assist in the display of the tree structure with the CheckRender class in turn triggering the TreeLabel class . The CheckRenderer and TreeLabel classes help display the entities in a tree structure with a check box at each node to allow selection of the associated entity at that node of the tree. The CheckNode class is the class for each displayed node of the tree. If a node in the tree is selected deselected by a user the CheckNode class selects deselects all the subordinate nodes for that node as well. For example if a class is selected all the methods of that class will also be selected. A selected class may be shown by a check in the check box according to this embodiment of the present invention. Selecting an already selected node a node with a check in the check box deselects that node clears the check from the check box as well as all subordinate nodes. This facilitates the selection process by allowing group selection deselection instead of requiring individual selection deselection of each entity.

The NodeSelectionListener handles node selection events and may populate a list box in the user interface with these selections. Events include the interaction between the user and the graphical user interface and are handled using graphical user interface GUI components. For example in Java components from the Abstract Window Toolkit AWT a collection of GUI components using native platform versions of the components or the Swing Set a code name for a collection of GUI components that run uniformly on any native platform that supports the Java virtual machine may be used to communicate these interactions with a Java program. is a diagram illustrating a simplified abstract model of event handling in Java . The event source is the object generating the event in question. For example for a click event on a button in the user interface the event source is the button clicked on. The event object contains the information related to the event. For example clicking on a button causes an object to be created containing the information associated with the event such as event type etc. The event listener is an object registered with the event source and having a method for event handling. The event object is passed to the event listener according to the abstract model shown in . is a diagram illustrating an example of event processing in the instrumentation tool according to one embodiment of the present invention. According to this example the JTree object the tree structure of the application file in the instrumentation tool is the event source . The NodeSelectionListener is the class for the event listener registered with the JTree object . When the user clicks on a node in the tree structure the JTree object a click or select event is initiated with the event information contained in an event object . The event object is passed to the NodeSelectionListener which generally calls at least one method to handle the event.

The JarParser class in verifies that a file selected by the user is a valid Java archive JAR file and if so creates a hierarchical tree structure of its contents. The user interface layer communicates with command collection layer and the processing layer using the interfaces which are described later in this specification.

Once the instrumented application file is generated it may be deployed transferred to the mobile device or it may first be further processed before being deployed. In the example embodiment above the instrumented JAR file is deployed to the mobile device where it can begin generating performance measurements. In another embodiment of the present invention a new JAR file application file is not created by the instrumentation tool process and only a Config configuration or instrumentation file is created containing the measuring points and methods for instrumentation. According to this embodiment both the original JAR file and the Config file are deployed to the mobile device. In this embodiment the Java class loader may need to be modified in order to perform the bytecode instrumentation at runtime. The Java class loader loads both the JAR file and the Config file classes while performing the instrumentation on the fly. According to this embodiment no code enhancement of the application file is made and instrumentation occurs only at runtime without changing the underlying application file e.g. JAR file . This is particularly beneficial in a case where an application file is enhanced by either an additional certificate or authentication in order to provide application security. Under these circumstances performing the instrumentation of the application file entities at runtime may be easier than performing code enhancement instrumentation before the certificate or authentication is generated for the application file which is generally prior to deploying the application file to the mobile device which would otherwise be necessary.

Otherwise restated in one embodiment of the present invention a code enhancement of the application file e.g. the JAR file may be performed and the enhanced i.e. instrumented application file may be loaded into memory during execution of the application and executed on the mobile device or other resource limited device . In an alternative embodiment the code enhancement instrumentation information is stored in a separate instrumentation file and this instrumentation file and the original unaltered application file are deployed to the mobile device or other resource limited device. Both files are loaded into memory during the execution of the application and the instrumentation of the application occurs at runtime. This alternative embodiment is particularly advantageous where the deployed application file e.g. the JAR file is controlled to prevent changes through some certification mechanism. The certification of the file may fail if the application file is modified after certification occurs. Therefore the certified application file must be deployed unchanged to the mobile device loaded into memory and the appropriate certification checks performed prior to code enhancement or instrumentation the details of which are provided in an instrumentation file of the entities in the application file.

