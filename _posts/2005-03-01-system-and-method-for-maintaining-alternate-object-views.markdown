---

title: System and method for maintaining alternate object views
abstract: A binding framework including a binder operable to associate and synchronize particular document objects with corresponding content objects performs unmarshalling to create the content objects from the XML documents. The content objects, which may in particular configurations be JAXB content objects, provide an alternate view to the XML data contained in the underlying XML documents. Java (i.e. user) applications then modify, or update the content objects via the alternate view, and rewrite, or update, the corresponding XML document during a marshalling process (i.e. writing the data from Java back into XML). The binding framework maintains the associations such that bound content objects are modifiable and may update the corresponding XML data in a non-destructive manner which avoids overwriting or “clobbering” other preexisting data contained in the XML document object during marshalling. The synchronizer employs the associations to maintain runtime consistency between the XML, or DOM view and the Java, or JAXB view.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07793255&OS=07793255&RS=07793255
owner: Oracle America, Inc.
number: 07793255
owner_city: Redwood City
owner_country: US
publication_date: 20050301
---
In a software development environment software developers typically employ different languages interfaces and development toolkits. Such development elements allow integration of software objects based on or developed under the various elements to effectively interoperate and build the specified system or application. In a large system or application there may be many developers each developing software objects or classes under a particular language or platform and many preexisting software objects which are integrated or interfaced via a toolkit or Application Programming Interface API .

Accordingly in a modern software development environment many software objects interoperate in the development environment and a build mechanism compiles interprets or otherwise processes the software objects into executable entities such as user applications. Unlike traditional development where interoperability and integration between dissimilar development platforms often became sufficiently convoluted so as to encourage the development of homogenous systems modern software development efforts typically incorporate development tools which strive to create interoperable software objects. Such modern systems strive to insulate developers from intricacies of code level interfaces and discrepancies. For example the JAVA language developed by SUN Microsystems of Palo Alto Calif. strives to present an operating system independent data definition language. Further extensions abstract data types and interface parameter passing ideally relieving the developer from the burden of such technical and implementation specific details. Therefore software developers may concentrate on the logic decision paths and information flows performed by software systems and avoid excessive distractions of technical implementation details which are instead handled by the compiler interpreter or runtime engine.

In a modern software development environment there tends to be an ongoing conflict between ease of use and function robustness. Development tools and languages which are intuitively less complex tend to have fewer features available to implement. Conversely robust software development packages having powerful options and adaptability tend to be complicated to learn. Commercially successful and or popular development platforms and languages tend to be those which have struck a near optimal balance between ease of use and richness of capabilities. One such language is the Extensible Markup Language XML which has been enjoying substantial popularity in the software development community as a means of expressing information and data in a readily transportable easily processable and OS operating system independent manner.

A typical XML implementation relies heavily on a programmatic interface to access and modify XML data or documents known as a document object model DOM . An XML document is structured data that follows XML syntax. Further a schema may exist that constrains the structure of the XML document discussed further below. The DOM is a programmatic interface for accessing XML documents in memory. Accordingly it is a representation of the XML data that is more appropriate for use when developing software that needs access to the data. Instead of reading the XML document as raw text the DOM is capable of reading the data into a memory structure that matches the structure of the data itself. It then provides general operations that allow programs to traverse access modify etc the data in the DOM.

Further XML data often corresponds to a schema. Each of the schemas defines the structure of a particular type of XML document. While DOM based data is not required to be schema compliant it is often beneficial to employ such a schema for consistency. However the XML format presented by the schema may not be particularly intuitive to the task at hand. Such schemas identify syntactical labels known as tags and attributes each of which receives a particular value in the resulting document. Therefore while the DOM may accept any well formed XML document whether schema compliant or nor the flexibility of the DOM may be usurped when confining development to a particular schema. Accordingly developers working with XML may tend to find it not particularly self documenting and modifying and or developing new code may appear somewhat cryptic. Paradoxically the benefits of XML provided by the definitive structure and parseability of the raw XML code may not serve to identify or document the task for which it is employed.

It would be beneficial to identify an alternate more intuitive view of XML objects i.e. data than the DOM provides. As indicated above an XML document may or may not be governed by an XML schema. In either case as long as the XML is well formed it can be parsed into a DOM. Given a schema that defines the structure of the XML data it may be possible to generate a better set of interfaces than what a generic DOM provides. For example consider a schema that defines purchase order elements with child elements for price description quantity etc. Rather than use a generic DOM it is possible to generate interfaces with intuitive operations like getPurchaseOrder getPrice etc. . . . . Accordingly the resulting code is more intuitive and self documenting thereby facilitating development efforts by relieving the developer from interpreting and understanding raw XML element and attributes.

One such alternate view is provided by the Java Architecture for XML Binding JAXB also developed by SUN Microsystems which generates Java classes from XML schemas. Accordingly JAXB provides an alternative to the DOM which is capable of representing the structured data contained in an XML document as structured data in memory. The difference between the two is that DOM is a single generic interface that can be used to read in any well formed XML document while JAXB generates a custom intuitive interface from the XML schema. A JAXB processor accepts XML schemas and generates corresponding Java classes and interfaces for use from a user application. A novice user unfamiliar with XML may employ the JAXB processor to generate alternate views of XML documents as Java objects. The generated Java classes and interfaces reflect the rules semantics of the source XML schema and are combined with utility packages for manipulating the generated classes and interfaces code as a development framework. This development framework allows Java code to interface with XML schema compliant data. Accordingly developers may employ known Java tools and development techniques for applications developed under DOM based XML data. JAXB facilitates the task of Java developers unfamiliar with the schemas to learn the generated interfaces and use them. Such generated interfaces are more intuitive for Java developers than generic DOM which tends to be highly focused on XML syntax and notation. Therefore developers need not be well versed in XML DOM and associated packages such as the SAX parser in order to develop applications conversant with native XML data.

However the alternate views provided by the above described conventional JAXB architecture imposes several trade offs. The JAXB view may not be capable of absolutely representing all features and characteristics of the corresponding XML document whereas the DOM representation is. Configurations of the invention describe a technique where advanced users of JAXB people that are experts in the field of XML can have the best of both worlds intuitive interfaces that mirror the schema AND the full representation of a DOM. Accordingly particular arrangements discussed further below maintain the JAXB data structures and the DOM synchronized with each other. There may be trade offs to consider when choosing JAXB over DOM JAXB is intuitive uses less memory not capable of representing the XML document fully. DOM is generic uses more memory capable of representing the XML document fully.

In further detail the DOM is a framework capable of representing substantially any well formed XML data in memory. Accordingly the DOM provides very generic access to the data however requires a very thorough understanding of the XML being represented. DOM is capable of representing the XML data in entirety even data that isn t traditionally considered significant such as white space comments etc . DOM is therefore memory intensive and typically incapable of representing anything other than the entire document such as portions or fragments. In other words one cannot tell DOM to search for and load a particular portion of the document without significant expertise in the field of XML processing tools.

In contrast JAXB is a databinding tool that allows incorporation of XML processing in Java applications it has a processor that is capable of generating the necessary artifacts for associating XML data with Java classes. JAXB also includes a framework that provides two main operations on XML data 1 unmarshalling which is the process of reading XML data into Java classes 2 marshalling which is the process of producing XML data from Java classes. When JAXB is used to process a schema it generates classes that have intuitive operations unlike the generic operations provided by DOM. JAXB however may not capture and or represent all aspects of the XML data consider white space comments etc . JAXB is capable of representing portions of documents and is generally much less memory intensive than DOM. There are some users that require features of both XML views such as the ease of use afforded by JAXB coupled with the lossless nature of DOM for example. Furthermore it is desirable to provide a framework that 

Configurations of the invention disclosed herein meet the above described needs by providing a binding framework including a binder operable to associate and synchronize particular DOM object such as an XML document with corresponding Java objects. An unmarshalling operation generates the corresponding Java objects from the XML documents. The Java objects which may in particular configurations be JAXB content objects provide an alternate view to the XML data contained in the underlying XML documents. Java applications then modify or update the content objects via the alternate view and rewrite or update the corresponding XML document during a marshalling process i.e. writing the data from Java back into XML .

It would be beneficial to develop a binding framework that maintains the associations such that bound Java objects are modifiable and may update the corresponding XML data in a non destructive manner which avoids overwriting or clobbering other preexisting data contained in the XML document object during marshalling. The binder employs the associations to maintain runtime consistency between the DOM view and the Java or JAXB view. In this manner the binder provides partial updateable binding by identifying changes made to the XML data via the JAXB alternate view i.e. from the Java application and updating or writing the modified data only to corresponding XML objects i.e. documents based on the DOM view without rewriting other XML data during the marshalling process. In particular configurations the binder maintains the association in the other direction as well changes to the DOM are synchronized back into the JAXB view.

In other words the DOM therefore is a framework that allows you to read in an XML document and represent it in a hierarchy of related objects. The hierarchy of the objects mirrors the hierarchy of the data in the XML document. The DOM and JAXB views therefore can be taken as comparable representations of the XML document or views of the XML document. Logically they represent the same data.

Therefore the generated Java objects derived from the DOM based XML documents occurs as a global so called unmarshalling operation creating parallel objects for all XML documents whether they are used or employed by the Java based alternate view or not. Further the rewrite or marshalling operation which replaces the Java objects back into the DOM counterparts occurs unselectively often overwriting unintended portions of the XML data from which it is based. Accordingly configurations discussed herein create or bind a selected subset of the XML documents to Java JAXB counterparts based on the classes of XML documents employed by the alternate view i.e. Java based code . Further configurations discussed herein provide updating of the XML documents from the bound content objects Java objects with only the Java based updates to avoid clobbering overwriting preexisting XML data in the bound XML objects accessible via the alternative JAXB view.

Configurations discussed herein therefore provide a method of updateable partial binding by creating associations between document objects in a markup language and managed objects in a content tree in which the document objects correspond to a class hierarchy structure. The method selectively modifies the managed objects and updates by traversing the generated associations that identify document objects corresponding to the modified managed objects in which the updates occur in a lossless manner which preserves unmodified data in the document objects. In particular arrangements the document objects in the markup language correspond to a first view from an application program and the managed objects in the content tree correspond to a second view from the same or a different application program. Note that the operations binding and generating synonymously mean the process by which artifacts are created that allow the runtime framework to associate XML data and Java classes. Typically there are two cases 1. compile an XML schema into a set of Java interfaces this is called schema to java or s2j as is known in the art 2. process a set of preexisting java classes and generate annotations and possibly a schema typically called Java to Schema or j2s .

Binding is therefore a two phase process. At compile time the framework generates a class structure of managed objects JAXB Java classes corresponding to the XML document structure defined by XML schemas thereby binding the structure of the schema in the JAXB classes. At runtime the framework provides marshalling and unmarshalling operations which serialize or convert between XML documents and instances of JAXB managed objects thereby binding XML data to Java and vice versa.

Further a compiler compiles an application programming interface API adapted for access by the application program and operable to modify the managed objects. In particular configurations the method validates the managed objects by comparing the data to the corresponding XML schema. The generated managed objects further define a content tree in which the content tree has a hierarchical structure derived from the markup definitions i.e. typically XML schemas . Updating or marshalling performs a lossless update of the XML objects from the modified managed objects in which lossless updating further includes retaining values of unmodified attributes in the XML objects.

In further detail the configurations disclosed herein maintain parallel synchronized views of object model such as the exemplary DOM by identifying markup definitions adapted for synchronous binding via alternate views and compiling the identified markup definitions to generate alternate classes corresponding to an alternate view. The method unmarshals markup documents corresponding to the markup definitions in which the markup documents include markup data and unmarshalling includes creating managed objects representative of the markup documents conforming to a corresponding one of the generated classes. A binder performs binding of the generated managed objects to the corresponding markup documents in which the binding includes associating managed objects in the generated classes to the markup documents from which the managed objects were generated. A repository or memory stores the associations as synchronous views indicative of corresponding markup objects and managed objects subsequent to modifying the managed object from a user application in which the user application is operable to process the markup documents and the managed objects of the synchronized alternate classes. The binder then marshals the modified managed objects by identifying via the associations updates made to the managed objects in which the markup objects correspond to the modified managed objects. The binding framework provided by the binder updates the corresponding markup objects with the modified managed objects in which updating further includes employing the associations for updating changes made by the user application and avoiding modifying existing markup data in the markup objects. Alternatively as indicated above the user application can also modify the DOM and the binder will synchronize those changes back to the Java classes.

In particular configurations unmarshalling further includes creating a content tree of managed objects from the markup documents the managed objects corresponding to the markup definitions. Identifying the markup objects includes identifying the modified managed objects from the generated managed objects and mapping via the associations markup documents corresponding to the modified managed objects. During marshalling the binder modifies the mapped markup documents in the DOM with updates made to the modified managed objects.

In other particular configurations the associations are indicative of updates to the data in the markup documents in which marshalling further includes modifying data corresponding to the updates and avoiding overwriting data extraneous to the updates in the modified managed objects. In this manner the markup documents define a first view of data the managed objects comprise a second view of the data in which the binding further includes synchronizing updates to the data from at least one of the first view and the second view such that marshalling further includes creating a markup document consistent with updates from the second view. In exemplary configurations the markup documents further define an XML content object tree and associating is indicative of relations between the content tree of managed objects and the objects in the XML content object tree. In the particular exemplary arrangement the content tree of managed objects is a JAXB content tree unmarshalled from a DOM based XML document tree.

The invention as disclosed above is described as implemented on a computer having a processor memory and interface operable for performing the steps and methods for monitoring and processing events in an information services network system as disclosed herein. Other embodiments of the invention include a computerized device such as a computer system central processing unit microprocessor controller electronic circuit application specific integrated circuit or other hardware device configured to process all of the method operations disclosed herein as embodiments of the invention. In such embodiments the computerized device includes an interface e.g. for receiving data or more segments of code of a program a memory e.g. any type of computer readable medium a processor and an interconnection mechanism connecting the interface the processor and the memory. In such embodiments the memory system is encoded with an application having components that when performed on the processor produces a process or processes that causes the computerized device to perform any and or all of the method embodiments steps and operations explained herein as embodiments of the invention to allow execution of instructions in a computer program such as a Java HTML XML C or C application. In other words a computer processor or other electronic device that is programmed to operate embodiments of the invention as explained herein is itself considered an embodiment of the invention.

Configurations disclosed herein provide a binding framework including a binder operable to associate and synchronize particular document objects with corresponding content objects. An unmarshalling operation generates the content objects from the XML documents. The content objects which may in particular configurations be JAXB content objects provide an alternate view to the XML data contained in the underlying XML documents. Java i.e. user applications then modify or update the content objects via the alternate view and rewrite or update the corresponding XML document during a marshalling process i.e. writing the data from Java back into XML . The binding framework maintains the associations such that bound content objects are modifiable and may update the corresponding XML data in a non destructive manner which avoids overwriting other preexisting data contained in the XML document object during marshalling. The synchronizer employs the associations to maintain runtime consistency between the XML document object view and JAXB Java view. In this manner the binder provides partial updateable binding by identifying changes made to the XML data via the JAXB alternate view i.e. from the Java application and updating or writing the modified data only to corresponding XML objects i.e. documents based on the DOM view without rewriting other XML data during the marshalling process.

Configurations of the invention provide a method of updateable partial binding by creating associations between document objects in a markup language and managed objects in a content tree in which the document objects correspond to a class hierarchy structure. The method selectively modifies the managed objects and updates by traversing the generated associations that identify document objects corresponding to the modified managed objects in which the updates occur in a lossless manner which preserves unmodified data in the document objects. In particular arrangements the document objects in the markup language correspond to a first view from an application program and the managed objects in the content tree correspond to a second view from the same or a different application program. Creating involves unmarshalling the document objects in the markup language to generate the managed objects in which unmarshalling includes identifying a class structure in a document object model DOM having a set of instances of the document objects and compiling the identified class structure to generate a second class structure JAXB Java classes corresponding to the managed objects.

The binding framework also includes a compiler to generate the artifacts to associate the XML data with the Java classes as discussed above about how the artifacts differ in S2J and J2S. In particular configurations the compiler compiles an application programming interface API for enabling the application program s to modify the managed objects. The generated managed objects further define a content tree in which the content tree has a hierarchical structure derived from the markup definitions i.e. schemas . Updating or marshalling performs a lossless update of the XML objects from the modified managed objects in which lossless updating further includes retaining values of unmodified attributes in the XML objects.

The unmarshalling operation shown by arrows creates the managed objects by defining a set of associations between the managed objects and the corresponding XML documents in the DOM subtree .from which they were derived. In the exemplary configuration employing JAXB as the binding mechanism in the binding framework a schema compiler discussed further below generates a Java code version of the source XML document translating the XML document into a Java JAXB object and defines an association between the source XML document and the generated managed object in Java. The Java managed object is an alternate view which may modify itself or other managed objects through execution shown by operation and which may be manipulated by other user code not specifically shown . For example the managed objects are modifiable by a user application based in Java via an application programming interface API or by any suitable software object shown and discussed further below. Upon successive completion of possibly several operations by the user application the user application requests the binder to update the data contained in the DOM by marshalling or writing the managed object back to the corresponding portion of the DOM such as the bound XML document shown by arrow . The binder maintains the associations such that only changes made to the managed objects are written to the DOM subset ultimately updating the corresponding XML data in the bound objects thus avoiding undesired changes or overwrites to the XML data stored in the XML documents . Conversely changes made via the user app using DOM APIs may update i.e. modify the DOM based view and employ the binder to synchronize changes over to the JAXB view thus illustrating the complementary properties of the dual views e.g. DOM and JAXB .

In operation the user application or other process selects or identifies the appropriate subset for updateable partial binding i.e. unmarshalling . At a previous or concurrent interval the compiler which may be an external application or operation receives or identifies the schemas and generates in the exemplary configuration Java classes corresponding to the selected XML documents . Note that the compiler may be separate from the binding framework generating the Java classes and APIs offline from the binding operation. The compiler may also generates an API corresponding to the generated classes to allow invocation from user code or the generated classes themselves may simply provide the API. The unmarshaller processes the XML document portion represented by the DOM subtree and creates corresponding content objects . . . in a content tree . A validator may check the unmarshalled objects for type consistency note that the validator performs an optional validation operation discussed further below . In the exemplary configuration the content objects are Java objects and the content tree is a Java content tree as specified in the corresponding Java class hierarchy . During unmarshalling the binder also creates the associations between each of the Java JAXB objects J J and J and corresponding DOM subtree . Subsequently such as at runtime as will be discussed in further detail below a user application invokes the generated Java objects via the API . The user application may access and modify the unmarshalled objects via the API . Following object manipulation from execution of the user application a marshaller receives the objects in the Java content tree and marshals the objects by updating the associated XML objects documents as indicated by the associations . A synchronizer moderates access and modifications to the multiple views of the objects provided by the DOM and JAXB Java bindings as the user application may attempt to modify either the DOM subtree or the Java object as will be discussed further below. The marshaller completes the update by updating only the changes to the DOM subtree made via the JAXB view of the objects thereby proceeding in a nondestructive or lossless manner.

A software entity such as a user application selectively modifies the managed objects as shown at step . The software entity such as a user application causes the binder to update by traversing the generated associations the DOM subtree corresponding to the modified managed objects in which the updating occurs in a lossless manner which preserves unmodified data in the document objects i.e. XML documents as depicted at step . Such updating and synchronizing of the bound objects typically occurs in response to an explicit request from the user code i.e. client application to synchronize the two views however alternate configurations may automate this approach. This so called marshalling operation employs the associations for tracking the changes made to the bound JAXB objects back to the DOM subtree i.e. DOM based versions and ultimately back to the raw source XML documents recall that while configurations discussed herein employ DOM compliant objects raw XML need not be DOM based . In this manner code written against the JAXB objects and interface provide a second view to the XML data which may losslessly update the XML data via the binding between the multiple views.

Note that the exemplary marshalling and unmarshalling operations employ the JAXB conversant binder for creating Java objects from corresponding XML. However the marshalling and unmarshalling operations may employ alternate languages from which to generate an alternate view of the XML data stored in the XML documents .

In order to manipulate the DOM subtree via the Java class view the binder unmarshals from the DOM subtree corresponding to the markup definitions in which the DOM subtree includes the markup data for updating as shown at step . Unmarshalling includes creating managed objects representative of the DOM subtree and conforming to a corresponding one of the generated classes . In the exemplary configuration unmarshalling further includes creating a Java content tree of JAXB managed objects from the DOM in which the managed objects correspond to the DOM subtree as depicted at step . Therefore the DOM subtree defines a first view of data the managed objects define a second view of the data and the binding further includes synchronizing updates to the data from at least one of the first view and the second view in which marshalling further includes creating a markup document consistent with updates from the second view as shown at step .

The source markup documents further define an XML content object tree in the DOM and the resulting associations are indicative of relations between the content tree of managed objects and the objects in the DOM as depicted at step . The generated managed objects further define an XML content tree the content tree having a hierarchical structure derived from the markup definitions i.e. XML schemas as disclosed at step . Accordingly unmarshalling the document objects in the markup language XML to generate the managed objects includes identifying the class structure in the document object model having a set of instances of the document objects . The compiler compiles the identified class structure to generate a second class structure shown as Java classes corresponding to the managed objects as depicted at step . Alternatively in other configurations the JAXB compiler may be bypassed and a developer actually hand codes the JAXB classes and a Java compiler processes the Java source code and generates the necessary artifacts to support the un marshal operations.

The unmarshalling operation may also invoke a validator for validating the unmarshalled objects. Accordingly unmarshalling may also include validating the managed objects by comparing the XML data to the constraints defined in the XML schema as disclosed at step . Validation may be beneficial for example for accommodating typecasting and or mismatches which XML allows but which JAXB is sensitive to. In alternative configurations type validation may also be performed during marshalling back into XML.

The binder identifies the counterpart source XML documents to bind the generated managed objects to the corresponding markup document in which binding includes associating managed objects in the generated classes to the markup documents from which the managed objects were generated as depicted at step . The binder stores the associations as synchronous views indicative of corresponding markup objects and managed objects as shown at step . The associations may be stored such as on a local disk drive or other memory structure operable for retrieval during the marshalling operation described further below. The associations therefore are operable to be indicative of subsequent updates to the data in the markup documents as depicted at step . Such associations allow later object modifications made by the user code via the JAXB view to be reconciled i.e. applied to the XML data. The associations will then allow the subsequent marshalling to only overwrite data corresponding to the updates and avoiding overwriting data extraneous to the updates in the modified managed objects as will be discussed further in the marshalling steps below.

Prior to runtime instantiation of the objects on behalf of the user application the binder further employs the compiler for compiling an application programming interface adapted for access by a user application program and operable to modify the managed objects as shown at step . As indicated above the operations performed by the compiler may be performed anytime prior to runtime object instantiation and may be discontinuous from user application execution. Such user applications are therefore operable to employ multiple views because the document objects in the markup language correspond to a first view from the application program and the managed objects in the content tree correspond to a second view from the same or another application program as depicted at step .

As indicated above the alternate view provided by the JAXB bound objects provide in the exemplary configuration a mechanism to employ Java code for modifying Java objects i.e. based on Java classes for XML data originally written and or stored in XML based on the schemas . Accordingly one or more user applications will modify the managed objects from the user application in which the user application is operable to process the markup documents and the managed objects in the alternate classes XML and Java as depicted at step .

Following modification and or revision of the objects in the content tree the user application uses the binder to marshal the modified managed objects as depicted at step thereby synchronizing the parallel views. Marshalling may be viewed as the reverse of the unmarshalling operation as shown by arrows and wherein marshalling performs a lossless update of the XML objects from the modified managed objects in which lossless updating further includes retaining values of unmodified attributes in the XML objects as shown at step . Accordingly the binder identifies via the associations markup objects corresponding to the modified managed objects as disclosed at step . Identifying the markup objects therefore includes identifying modified managed objects from the generated managed objects as depicted at step such as by flagging modifications on a per attribute or field basis.

The binder maps the identified modifications via the associations to the markup documents corresponding to the modified managed objects as shown at step . The binder employing the synchronizer to avoid concurrency conflicts maps the modified markup documents with updates made to the modified managed objects as depicted at step . The binder updates the corresponding markup objects with the mapped updates to the modified managed objects as shown at step in which updating further employs the associations for updating changes made by the user application and avoids modifying existing markup data in the markup objects as depicted at step .

In an exemplary configuration shown in a billing application has been developed employing a billing API A that modifies the DOM objects using standard DOM APIs and a shipping application employs a shipping API B based on JAXB objects . The shipping API B includes J API and J API for accessing the XML data from the J and J classes respectively in the binding of subset . The compiler generates the API B at some time prior to the marshalling process as indicated above the DOM based API A uses one of the existing standardized DOM APIs. Therefore the XML data objects are modifiable from either the shipping application or the billing application via the associations which employ the synchronizer to coordinate the updates made to the marshaled and unmarshalled objects.

Specifically the J API   is operable to modify the J object and the J API is operable to modify both instantiations of J and respectively. Further the billing DOM API   may also modify object illustrating the multiple views of object J. The DOM based non unmarshaled D object corresponding to DOM object D is likewise modifiable from the DOM API via the billing API A. It should be noted that the XML data in the J object is modifiable from both the J API interface from the shipping application as a JAXB object view and from the DOM API interface from the billing application via the DOM view. The user application uses the binder therefore to synchronize the two views in a non destructive manor.

It should be noted that the exemplary implementation discussed above employs XML based data as exemplary data for modification from multiple first and second views. Alternative configurations may employ other scripting languages and or database repositories. Accordingly the systems and methods discussed above with respect to the exemplary XML data are applicable to an alternative scripting or processing format or protocol operable for a particular user API.

Those skilled in the art should readily appreciate that the programs and methods for updateable partial binding as defined herein are deliverable to a processing device in many forms including but not limited to a information permanently stored on non writeable storage media such as ROM devices b information alterably stored on writeable storage media such as floppy disks magnetic tapes CDs RAM devices and other magnetic and optical media or c information conveyed to a computer through communication media for example using baseband signaling or broadband signaling techniques as in an electronic network such as the Internet or telephone modem lines. The operations and methods may be implemented in a software executable object or as a set of instructions embedded in a carrier wave. Alternatively the operations and methods disclosed herein may be embodied in whole or in part using hardware components such as Application Specific Integrated Circuits ASICs state machines controllers or other hardware components or devices or a combination of hardware software and firmware components.

While the system and method for updateable partial binding has been particularly shown and described with references to embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims. Accordingly the present invention is not intended to be limited except by the following claims.

