---

title: Methods and apparatus for creating middleware independent software
abstract: A system abstracts an object model by receiving an object model specification defining application semantics for an application to access, via invocations, objects identified in the object model specification. The system applies a categorical-based generator that applies at least one morphism to the object model specification to generate an abstraction interface object model that preserves application semantics defined within the object model specification and is independent of a middleware object access mechanism. The system also generates an implementation of the abstraction interface object model for a particular middleware object access mechanism used to access data within objects corresponding to the object model specification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07546309&OS=07546309&RS=07546309
owner: EMC Corporation
number: 07546309
owner_city: Hopkinton
owner_country: US
publication_date: 20050331
---
Modern computer software applications are often distributed between computer systems and require ability to access and exchange information with other remotely operating software applications. Such exchanges of data and access to functionality often take place over a computer network such as a local area network or a wide area network such as the Internet. Due to the complexities and varying mechanisms of implementing functionality and data formats within modern software applications software developers often employ software commonly referred to as middleware that provides a standardized mechanism for the exchange of information and access to functionality between two or more remotely operating software programs. Middleware is generally connectivity software that consists of a set of enabling services that allow multiple processes running on one or more machines to interact across a network.

Middleware allows a software developer to create a software application using calls to a middleware specific application programming interface or API in order to insulate the software developer from having to know the details of how to access the remotely operating software application and associated remote data structures or objects. By incorporating a set of middleware specific function calls into the application under development the software developer relies on the middleware transport and data access mechanisms and does not need to be concerned with details such as creation of connections to remote computer systems. Middleware is thus software that connects otherwise separate applications or separate products and serves as the glue between the applications. Middleware is thus distinct from import and export features that may be built into one of the applications. Developers often refer to middleware plumbing because it connects two sides of an application and passes data between them. For example there are a number of middleware products that link a database system to a web server. This allows a user application to request data from the database using forms displayed on a web browser and it enables the web server to return dynamic web pages based on the user application s requests.

One example of commonly used middleware architecture is called CORBA. CORBA is an acronym for Common Object Request Broker Architecture. The CORBA environment is an industry standard that is maintain by Object Management Group Inc. OMG of Needham Mass. USA. As described on OMG s web site CORBA provides a vendor independent architecture and infrastructure that computer applications use to work together over data networks. Using standardized protocols a CORBA based program from any vendor on almost any computer operating system programming language and network can interoperate with a CORBA based program from the same or another vendor on almost any other computer operating system programming language and network.

Conventional CORBA applications are composed of objects that are individual units of running software that combine functionality and data. Typically there are many instances of an object of a single type. For example an e commerce website would have many shopping cart object instances all identical in functionality but differing in that each is assigned to a different customer i.e. client browser and each contains data representing the merchandise that its particular customer has selected. For other object types there may be only one instance. As an example when a legacy application such as an accounting system is wrapped in code with CORBA interfaces and opened up to clients on a network there is usually only one instance.

For each object type such as the shopping cart mentioned above a developer using middleware such as CORBA defines an interface in an OMG Interface Description Language IDL . The interface is a syntax part of a contract that a server object offers to client programs that invoke functionality and access data within that server object. Any client that wants to invoke an operation on the object must use this IDL interface specification i.e. object specification to specify the operation it wants to perform and to marshal arguments i.e. parameters or data that the client sends and receives from the server for access to that object. When the invocation reaches the target object the same interface definition is used there to unmarshal the arguments so that the object can perform the requested data processing operation with the arguments. The interface definition is then used to marshal the results for their trip back to the client and to unmarshal them when they reach the client destination.

A conventional IDL interface definition is independent of a selected programming language but maps to all of the popular programming languages via industry standards. As an example there are standardized mappings from IDL to C C Java COBOL and other languages.

The use of a middleware specific interface such as a CORBA call that is separate from the middleware implementation enabled by the IDL is one essence of middleware such as CORBA and explains how conventional middleware enables interoperability between applications with all of the above noted transparencies. The interface to each object using a conventional middleware platform is defined very strictly. However CORBA and other middleware platforms hide the implementation of an object i.e. its running code and its data from the rest of the system that is middleware encapsulates the implementation behind a boundary that the client application may not cross. Clients access objects only through their advertised CORBA or other middleware specific interface invoking only those CORBA or other middleware operations that the object exposes through its IDL interface with only those CORBA or other middleware parameters input and output that are included in the invocation.

Prior to execution a developer using an IDL compiler compiles an object model specification defined in IDL into client IDL stubs and object skeletons and writes the code for the client and for the object implementation . The stubs and skeletons serve as proxies for clients and object e.g. server respectively. Because IDL defines interfaces so strictly the stub on the client side has no trouble meshing perfectly with the skeleton on the server side even if the two are compiled into different programming languages. If CORBA is the middleware that provides the object request broker ORB the CORBA ORB can even be produced from different vendors so long as it conforms to the CORBA standard.

In CORBA every object instance has its own object reference in the form of an identifying electronic token or string. Clients use the object references to direct their invocations identifying to the ORB the exact instance of an object that the client wants to invoke. Using the shopping cart example this ensures that the shopping cart object for one client is different from a shopping cart object of another client. The client acts as if it is invoking an operation on the object instance but the client is actually invoking a call on the IDL stub that acts as a proxy to the object . Passing through the stub on the client side the invocation continues through the ORB and the skeleton on the implementation side to get to the object implementation where it is executed. thus shows invocation through a single machine.

To identify the correct object the client knows the type of object that it is invoking e.g. that it s a shopping cart object and the client stub and object skeleton are generated from the same IDL object model specification . This means that the client knows exactly which operations it may invoke what the input parameters are and where they have to go in the invocation. Accordingly when the invocation reaches the target object all parameters are present. Additionally the local client s ORB and the remote object s ORB operate on a common protocol that provides a representation to specify the identity of the target object its operation and all parameters input and output of every type that they may use. Accordingly although the local ORB can tell from the object reference that the target object is a remote object the client does not know the physical operating location of the target object . There is nothing in the object reference token obtained by the client that the client holds and uses at invocation time that identifies the location of the target object . The token is opaque to the client. This ensures location transparency in order to simplify the design of distributed object computing applications.

Another example of middleware development environments are COM Common Object Model and DCOM Distributed COM developed by Microsoft Corporation of Redmond Wash. USA. COM refers to both a specification and implementation developed by Microsoft Corporation which provides a framework for integrating components. This framework supports interoperability and reusability of distributed objects by allowing developers to build systems by assembling reusable components from different vendors which communicate via COM in a manner similar to that of the CORBA example provided above. By applying conventional COM to build systems of preexisting components developers attempt to reap benefits of maintainability and adaptability. COM defines an application programming interface API to allow for the creation of components for use in integrating custom applications or to allow diverse components to interact.

However in order to interact COM components must adhere to a binary structure specified by Microsoft Corporation. As long as COM components adhere to this binary structure components written in different languages can interoperate using COM on the Windows platform only. Distributed COM is an extension to COM that allows network based component interaction. While COM processes can run on the same machine but in different address spaces the DCOM extension allows processes to be spread across a network. With DCOM components operating on a variety of other platforms can interact as long as DCOM is available on those other platforms.

Conventional mechanisms and techniques used for developing software applications that rely on middleware environments suffer from a variety of deficiencies. In particular when a software developer produces an object model specification using an interface description language IDL and compiles this object model specification using a conventional middleware compiler such as a conventional CORBA IDL compiler the conventional stubs and skeletons and any functionality exposed through the CORBA stubs or skeletons requires sophisticated knowledge of the IDL and its specific language mappings to Java C etc . Application programmers responsible for developing client application code who often lack this knowledge of middleware specific information are often slowed down in their development efforts by the middleware specific information produced within the generated IDL stubs and IDL skeletons .

As a specific example a CORBA interface typically consists of many IDL types including the interface itself one or more super interfaces enums exceptions sequences structs methods with parameters and return types and so forth. When presented with an IDL interface object model specification a conventional IDL to Java compiler emits the conventional IDL object model stubs and skeletons in above which are realized by a plethora of Java classes and Java interfaces each conforming to the IDL to Java mapping. While this object model is ORB vendor independent unfortunately the conventional emitted files are cluttered with middleware specific i.e. CORBA information such as CORBA markers interface repository information references to the CORBA ORB and its methods methods invoked by the CORBA ORB marshalling functionality and the like. Such middleware specific information is often distracting and confusing to client development programmers unfamiliar with CORBA. As a result the programmers who must utilize the stubs and skeletons must become familiar to some extent with middleware specific information presented within the interface stubs and skeletons . The programmers are thus less efficient. The programmers can become significantly more productive if they program using CORBA independent stubs and skeletons but conventional middleware development platforms do not provide such capability.

Additionally in the event that an owner of software desires to change the middleware system for example from CORBA to a middleware system such as COM the client application software that relies on the middleware system must be revised so that the middleware specific references utilized within the IDL stubs and skeletons comply with the new selected middleware environments. Accordingly initial selection of a conventional middleware environment can become an important decision when creating software using conventional middleware development techniques due to the future difficulty of switching to a different middleware platform after the software has been developed using a chosen middleware platform. As new middleware platforms enter the marketplace and or as existing platforms are equipped with more features or client application requirements change dependence upon a specific middleware platform can become problematic.

Embodiments of the invention include a software development system that significantly overcomes the aforementioned deficiencies and provides mechanisms and techniques that apply a categorical approach to these problems. As an example given an object model specified in for example an Interface Description Language IDL the system disclosed herein generates an abstraction of that object model that preserves the application semantics expressed in the IDL but that is middleware independent. In addition the system explained herein generates an implementation of that abstraction for a particular middleware such as CORBA or another selected middleware platform. As a specific example if the system disclosed herein receives as input a CORBA interface defined in IDL the system operates as explained herein to output an abstracted CORBA independent object model that exposes the functionality of the CORBA interface and also outputs an implementation of that object model using CORBA but that is hidden from the application developer.

In one embodiment a system operates a method of abstracting an object model by receiving an object model specification defining application semantics for an application to access via invocations objects identified in the object model specification. This can be the IDL object model specification used in the above example. The system applies a categorical based generator that applies at least one morphism to the object model specification. Application of the categorical based generator generates an abstraction interface object model that preserves application semantics defined within the object model specification and that is independent of a middleware object access mechanism e.g. CORBA COM TIBCO RMI etc. used to access data within objects corresponding to the object model specification. The categorical based generator also generates an implementation of the abstraction interface object model for a particular middleware object access mechanism e.g. for CORBA or another selected middleware used to access data within objects corresponding to the object model specification.

Application of the categorical based generator conceals all middleware related information in the implementation of the abstraction interface object model while preserving application functionality of an application that uses the object model specification in the abstraction interface object model.

In one embodiment application of the categorical based generator that applies at least one morphism to the object model specification comprises visiting each IDL type defined in the IDL once and for each IDL type visited applying a morphism to map the IDL type one to one and onto and in an invertible manner by defining at least one corresponding morphism for that type within the abstraction interface object model. The corresponding morphism preserves inheritance among application interfaces defined in the abstraction interface object model and preserves all relationships among the application interfaces.

Again using CORBA as an example middleware platform generation of the abstraction interface object model i.e. an abstracted interface object model conceals all the CORBA related information while preserving application functionality while generation of the implementation of the abstraction interface object model produces a CORBA implementation object model that implements the interfaces and abstract classes in the interface object model using CORBA but that is hidden form the programmer developing an application. In this manner a software developer can obtain the benefits of middleware such as CORBA without having to have knowledge of CORBA and without having interface calls cluttered with CORBA specific information. Additionally since the generated modules explained herein insulate the application developer from the underlying middleware implementation the middleware can be changed without having to re write application code thus saving significant time and expense.

Other embodiments include computerized devices such computer systems workstations or other devices configured or operable to process and perform all of the method and processing operations disclosed herein as embodiments of the invention. In such embodiments a computer system includes a memory system a processor a communications interface and optionally a display and an interconnection mechanism connecting these components. The memory system is encoded with a generator application that when performed on the processor produces a generator process that operates as explained herein to perform all of the method embodiments and operations explained herein as embodiments of the invention.

Other arrangements of embodiments of the invention that are disclosed herein include software programs to perform the method embodiment steps and operations summarized above and disclosed in detail below of the report generator process. More particularly a computer program product is disclosed that has a computer readable medium including report generator computer program logic encoded thereon that when performed in a computerized device provides operations of the generator application and process as respectively explained herein. The computer program logic when executed on at least one processor with a computing system causes the processor to perform the operations e.g. the methods indicated herein as embodiments of the invention. In addition the abstracted and implementation object models explained herein when encoded on a computer readable medium represent embodiments of the invention as well. Such arrangements of the invention are typically provided as software code and or other data structures arranged or encoded on a computer readable medium such as an optical medium e.g. CD ROM floppy or hard disk or other a medium such as firmware or microcode in one or more ROM or RAM or PROM chips or as an Application Specific Integrated Circuit ASIC or as downloadable software images in one or more modules shared libraries etc. The software source code and or object code or firmware or other such configurations can be installed onto a computerized device to cause one or more processors in the computerized device to perform the techniques explained herein as embodiments of the invention. Software processes that operate in a collection of computerized devices such as in a group of storage area network management servers hosts or other software development entities can also provide the system of the invention. The system of the invention can be distributed between many software processes on several computers or processes such as the generator process can execute on a dedicated computer alone and the report definitions can be remotely accessed. The generator may be integrated into a storage area network management application as well.

It is to be understood that the system of the invention can be embodied strictly as a software program as software and hardware or as hardware alone. Example embodiments of the invention may be implemented within EMC s Control Center and StorageScope software application s that provide management functionality for storage area network resources and in computerized devices that operate the ControlCenter software. ControlCenter is a trademark owned by EMC Corporation of Hopkinton Mass. USA.

Embodiments of the invention are able to receive an object model specified for example in an Interface Description Language IDL and are able to generate an abstraction of that object model that preserves the application semantics expressed in the IDL but that is middleware independent. In addition the system explained herein generates an implementation of that abstraction for a particular middleware such as CORBA or another selected middleware platform. As a specific example if the system disclosed herein receives as input a CORBA interface defined in IDL the system operates as explained herein to output an abstracted CORBA independent object model that exposes the functionality of the CORBA interface and also outputs an implementation of that object model using CORBA but that is hidden from the application developer.

Using CORBA as an example one purpose of the abstracted interface object model is to conceal all the CORBA related information while preserving application functionality. One purposes of the CORBA implementation object model is to implement the interfaces and abstract classes in the interface object model using CORBA. To do so the system disclosed herein provides a categorical based generator. Through application of morphisms to the object model specification the system conceals all middleware related information while preserving application functionality of an application that uses the object model specification.

Example discussions of embodiments disclosed herein use CORBA as a middleware platform for ease of discussion of processing. However it is to be understood that the system disclosed herein is not limited to CORBA and that other implementation object models could also be emitted based on various middleware technologies such as RMI Tibco or COM. Furthermore a no middleware object model could be emitted for a configuration that uses collocation.

Embodiments disclosed herein are based in part on the observation that in a typical CORBA or other middleware application IDL types are intertwined in various ways. For example methods in interfaces are parameterized with enums structs other interfaces and often throw exceptions. Similarly structs may contain members which are themselves structs enums or sequences thereof. Accordingly in order to generate the object models disclosed herein the categorical based generator analyzes the IDL object model. By applying the categorical approach of the system disclosed herein the categorical based generator only need to visit each IDL type once thereby significantly improving the generator s performance and memory requirements.

It is to be understood that the invention is not limited to receiving an object model specification in IDL. IDL is used in the examples herein since it is language and platform neutral. In other words IDL was chosen because it is platform and language neutral not due to its CORBA origins.

In step the generator receives an object model specification defining application semantics for an application to access via invocations objects identified in the object model specification .

As shown in sub step application of the categorical based generator generates the abstraction interface object model of the object model specification. The abstraction interface object model preserves application semantics defined within the object model specification while remaining independent of the middleware object access mechanism used to access data within objects corresponding to the object model specification . Generally then applying at least one morphism to the object model specification includes concealing all middleware related information in the implementation of the abstraction interface object model while preserving application functionality of an application that uses the object model specification in the abstraction interface object model.

In sub step application of the categorical based generator further generates the implementation of the abstraction interface object model for a particular middleware object access mechanism used to access data within objects corresponding to the object model specification . Generating an implementation of the abstraction interface object model for a particular middleware object access mechanism can do so for particular middleware object access mechanisms such as CORBA COM RMI and Tibco or others.

The illustrated IDL object model types and are displayed in italic while the interface object model types are displayed in regular font respectively. If h denotes a morphism applied in the generator then the illustrated standard categorical commutative diagram holds true and provides the definition of the morphism as used herein. Note that this diagram extends readily to parameterized methods.

Concerning where the morphism should be physically located since IDL generated types should not be modified the morphism does not preferably reside there. In one configuration the morphism could be instantiated as one or more static methods in some class however the homeomorphic access would then become verbose. The remaining alternative is placing the morphism in the types of the abstracted interface object model . Since the morphism maps application types one to one and onto it is invertible. For emitting cleaner code it is more convenient to implement the morphism from the interface object model to the IDL object model . This latter morphism is distributed among the many generated types in the interface object model .

In step the generator applies at least one morphism to map the IDL type one to one and onto and in an invertible manner by defining at least one corresponding morphism i.e. code for that type within the abstraction interface object model . The corresponding morphism preserves inheritance among application interfaces defined in the abstraction interface object model and preserves all relationships among the application interfaces. The categorical nature of the morphism is clearly exhibited in the following code snippet 

In step and as shown in the above first code snippet for each type in the object model specification the generator defines two morphisms h and hh with common i.e. identical implementations but each having different return types the return type of morphism hh being a categorical return type corresponding to a middleware specific type and the return type of the morphism h anonymizing the middleware specific type into a language type generic to the application.

This is shown in sub step where the generator defines different visibility attributes for each of the two morphisms h and hh the morphism hh having private visibility and being used within the class and the morphism h having public visibility and being used by other types

Accordingly two morphisms are defined h and hh with identical implementations but different return types and visibility attributes. As expected categorically the return type of hh is the corresponding CORBA type. However one essential goal of the interface object model is to conceal CORBA. Therefore the morphism h is provided which anonymizes the CORBA type into a java.lang.Object. The morphism hh is used extensively in the defining class and only there hence its private visibility. In contrast ho is used extensively by other types hence its public visibility.

To illustrate the categorical approach further as used in the system disclosed herein consider the following interface inheritance hierarchy in IDL 

Each CORBA implementation type implements the morphism differently. For interfaces structs and exceptions the morphism simply delegates to an instance of the IDL type. Consequently no copying overhead is incurred. Surprisingly for enums the morphism involves no delegation at all instead the morphism maps static instances based on their underlying integer values. The following second code snipet illustrates a non delegating morphism 

The generator maps IDL sequences by a C template like mechanism. When such a sequence is encountered in the IDL definition and only then a Java array to array adapter is emitted. Thus the mapping is parsimonious and effective. IDL types often map directly into standard Java types such as int String arrays of Strings etc such types appear identically in the object models.

Returning attention now back to the flow chart of processing steps in in step the generator defines an inverse morphism hInv that operates during execution to create a middleware specific implementation instance whose delegate is the IDL instance.

An example of an inverse morphism hInv is shown in the first code snippet shown above. The inverse morphism hInv operates as follows for exceptions interfaces and structs it simply creates a CORBA implementation instance whose delegate is the IDL instance. Hence in the CORBA implementation object model each such type must possess a constructor accepting a corresponding IDL instance this constructor however is hidden from application developers. For enums the inverse morphism like the morphism maps static instances based on their underlying integer value.

This is shown in the flow chart in step where the middleware specific implementation is a CORBA implementation and the implementation of the abstraction interface object model is a CORBA implementation object model. In this case the generator defines hInv to operate during execution for exceptions interfaces and structs to create a CORBA implementation instance whose delegate is the IDL instance and provides in the CORBA implementation object model a corresponding type that possess a constructor accepting a corresponding IDL instance that is hidden from the application.

In one example configuration the generation of the interface and CORBA implementation object models relies heavily on Java reflection. Specifically the generator reflects on each CORBA type in the IDL object model and emits when necessary corresponding types in the interface and CORBA implementation object models. Through reflection the generator examines CORBA markers in the IDL generated code in order to determine whether the CORBA type is an enum an exception an interface or a struct. More specifically IDL user exceptions are the only type derived from org.omg.CORBA.UserException. In the IDL object model each IDL interface SomeInterface invariably derives from an Operations Java interface SomeInterfaceOperations in this example. Each enum always has a protected constructor and methods with signatures from int int value and value .

Additionally an essential element of code generation that allows the generator to discover for example for a given interface all the types needed to support that interface in the interface object model. Reflection is used by the generator again and while reflecting on each type each of its constituent types is also discovered. These discovered types then fuel a recursive traversal. Consequently reflection finds three significant usages in the generator identifying the nature of the type enum exception interface sequence or struct providing information for generating each type in the generated object models and recursively discovering all the dependent types for fully constructing the emitted object models.

In step for each middleware specific type in the object model specification the generator performs a reflection technique and emits corresponding types in the abstraction interface object model and in the implementation of the abstraction interface object model. Details of performing reflection are shown in sub steps through .

More specifically in step the generator examines middleware specific markers in object model specification generated code to identify derived types that are middleware specific.

In step the generator obtains information for generating each type in the abstraction interface object model and in the implementation of the abstraction interface object model .

In step the generator recursively discovers all dependent types to fully construct the abstraction interface object model and in the implementation of the abstraction interface object model.

In step for each IDL type in the object model specification the generator emits programming language types. Specifically for each IDL type three Java types are emitted into three separate files as follows. For constructing the interface object model the Java interface helper is emitted declaring the morphism and the functional interface is emitted either a Java interface or a Java abstract class declaring the application functionality. The functional interface extends or implements the helper. For constructing the CORBA implementation object model the functional implementation is emitted a Java class that implements or extends the functional interface. The current generator supports IDL enums exceptions interfaces sequences and structs.

In step the generator emits an interface helper that declares the morphism and is used for constructing the abstraction interface object model as an interface object model.

In step the generator emits a functional interface that declares application functionality and extends and implements the helper.

In step the generator emits the middleware specific implementation object model that provide a functional implementation that implements and extends the functional interface.

At application runtime there is a brief moment when the interface object model meets the CORBA universe in the application s code. This occurs when a CORBA reference is first encountered in the application code such a reference could have been obtained by invoking the ORB s string to object on a stringified IOR or by querying a naming or trading service. The reference is immediately encapsulated in an appropriate interface in the CORBA implementation object model and is exposed as an interface in the interface object model. That latter interface becomes the single invocation point for that CORBA reference. Therefore each interface in the CORBA implementation object model must possess a public constructor that accepts a CORBA reference. At runtime that reference is immediately narrowed into a strongly typed CORBA interface which becomes the delegate of the CORBA implementation interface. The following third code snipet provides an example of this 

The abstracted interface object model manages interface upcasting very gracefully. Specifically since the interface object model preserves the interface hierarchy in the IDL object model excluding CORBA specific types interface upcasting maps transparently to Java upcasting. Regrettably downcasting is more problematic since CORBA downcasting is incompatible with Java downcasting. Hence for each interface that may require downcasting the generator provides a static downcast method which performs as follows it first applies the morphism on the interface that requires downcasting to retrieve the delegate then it applies the CORBA narrow operator to perform the downcast and finally it invokes the inverse morphism to create the required interface in the interface object model. An example of this downcast processing is shown below in the following code snipet 

Is to be understood that embodiments include the generator as a software application or as part of another application or as logic instructions and or data encoded within a fixed or removable computer readable medium such as a floppy disk hard disk or in an optical medium or in a memory system such as in firmware read only memory ROM or as in the previous examples as executable code within a memory system e.g. within random access memory or RAM . It is also to be understood that other embodiments provide the generator operating within a processor as a process. While not shown in this example those skilled in the art will understand that a computer system can implement the generator and may include other processes and or software and hardware components such as an operating system. Thus embodiments of the invention include the generator program existing as either code in unexecuted form on a computer readable medium e.g. as a software program on a transportable medium such as a CDROM or as an executing software process or as a computer system configured to operate as explained herein.

Other alternative arrangements of the invention include rearranging the processing steps explained above in the flow charts in such a way that the overall effect of the invention is the same. It is to be thus understood by those skilled in the art that the particular arrangement of processing steps in many instances does not specify implementation of embodiments. As such those skilled in the art of software development and computer related technologies will understand that there can be many ways and orders of representing the processing operations explained above and such alternative embodiments of the software code will still achieve the overall effects features and advantages of the invention as explained herein. In addition embodiments of the invention are not limited to operation on the computer systems shown above. The report generator can operate on shared computing resources or can be distributed among any number of computer systems. Furthermore embodiments of the invention may operate to map application code to middleware in a storage area network management application.

