---

title: System and method utilizing multiple processes to render graphical data
abstract: A system for rendering graphical data utilizes a plurality of graphics pipelines, a first process, and a second process. Each of the plurality of graphics pipelines is configured to render graphical data. The first process is configured to receive three-dimensional (3D) graphics commands from a graphics application and to receive input commands from a user input device. The first process is configured to buffer the received 3D graphics commands and to execute the received input commands, and the first process, for each of the buffered 3D graphics commands, is configured to begin processing a newly received command upon buffering the 3D graphics command. The second process is configured to interface the buffered graphics commands with each of the plurality of pipelines, wherein execution of the user input command affects an object defined by the graphics application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07432933&OS=07432933&RS=07432933
owner: 
number: 07432933
owner_city: 
owner_country: 
publication_date: 20050106
---
This application is a continuation of and claims priority to U.S. patent application Ser. No. 10 087 472 entitled System and Method Utilizing Multiple Processes to Render Graphical Data and filed on Mar. 1 2002 now U.S. Pat. No. 6 847 366.

The present invention generally relates to graphical display systems and in particular to a system and method utilizing multiple processes to render graphical data.

Computer graphical display systems are commonly used for displaying graphical representations of two dimensional and or three dimensional objects on a two dimensional display device such as a cathode ray tube for example. In this regard a computer graphical display system normally includes one or more graphics applications having graphical data that defines one or more graphical objects. When a graphical object is to be displayed the graphics application submits a command or a set of commands referred to hereafter as a drawing command for drawing the object. The drawing command includes or is associated with graphical data that defines the color value and possibly other attributes for each pixel of the object.

In response to the drawing command a graphics pipeline within the graphical display system renders the command s graphical data to a frame buffer. The data within the frame buffer defines the display attributes e.g. color for each pixel of a display device which display device periodically reads the frame buffer and colors each pixel displayed by the display device according to each pixel s corresponding color value in the frame buffer. Moreover by rendering the graphical data of the drawing command to the frame buffer the image displayed by the output device is eventually updated to include an image of the object defined by the graphical data of the drawing command.

Higher quality images are often defined by larger amounts of graphical data. However in general increasing the amount of graphical data defining an image to be displayed undesirably increases the amount time required for a graphical display system to render the graphical data. Indeed when a graphical display system is processing time consuming graphics commands other functions performed by the graphical display system such as receiving user input can be significantly delayed.

Generally the present invention provides a graphical rendering system and method that utilize multiple processes for rendering graphical data.

A graphical rendering system in accordance with an exemplary embodiment of the present invention utilizes a plurality of graphics pipelines a first process and a second process. Each of the plurality of graphics pipelines is configured to render graphical data. The first process is configured to receive three dimensional 3D graphics commands from a graphics application and to receive input commands from a user input device. The first process is configured to buffer the received 3D graphics commands and to execute the received input commands and the first process for each of the buffered 3D graphics commands is configured to begin processing a newly received command upon buffering the 3D graphics command. The second process is configured to interface the buffered graphics commands with each of the plurality of pipelines wherein execution of the user input command affects an object defined by the graphics application.

A method in accordance with an exemplary embodiment of the present invention can be broadly conceptualized by the following steps simultaneously running a first process and a second process rendering graphical data in parallel via a plurality of graphics pipelines receiving user input commands and graphics commands analyzing the received commands identifying three dimensional 3D graphics commands via the first process based on the analyzing step queuing each of the identified 3D graphics commands in a command queue via the first process interfacing the queued commands via the second process with the plurality of graphics pipelines and executing the user input commands via the first process.

In general the frame buffer stores graphical data defining an image that is to be displayed by a display device . In this regard the frame buffer includes a set of data for each pixel displayed by the display device . Each set of data is correlated with the coordinate values that identify one of the pixels displayed by the display device and each set of data includes the color value of the identified pixel as well as any additional information needed to appropriately color or shade the identified pixel.

By employing a plurality of graphics pipelines it is possible to increase rendering speed and or image quality. For example depicts an exemplary embodiment of a computer graphical display system having multiple pipelines . As shown by the system includes a graphics application a master graphics pipeline and one or more slave graphics pipelines . The pipelines may be implemented via hardware software or any combination thereof. It should be noted that the embodiment shown by depicts four slave pipelines for illustrative purposes only and any number of slave pipelines may be employed to implement the system in other embodiments.

The master pipeline receives graphics commands from the application . The master pipeline preferably renders the graphical data from two dimensional 2D graphics commands to the frame buffer and passes three dimensional 3D graphics commands to the slave pipelines which render the graphical data of the 3D graphics commands to the frame buffers respectively. As used herein a 2D graphics command refers to a graphics command that includes 2D graphical data but no 3D graphical data and a 3D graphics command refers to a graphics command that includes 3D graphical data. Note that a 3D graphics command may also include 2D graphical data.

Also note that other arrangements of the pipelines are possible in other embodiments. More specifically the master pipeline may be configured to render graphical data from 3D graphics commands in addition to or in lieu of graphical data from 2D graphics commands and one or more of the slave pipelines may be configured to render graphical data from 2D graphics commands instead of or in addition to graphical data from 3D graphics commands.

Each frame buffer may output a stream of graphical data to a compositor which may be implemented in software hardware or a combination thereof. The compositor is configured to provide to a display device e.g. a cathode ray tube a composite data signal based on each of the data streams from the frame buffers . The graphical data provided to the display device by the compositor defines an image to be displayed by the display device and is based on the graphical data rendered by the pipelines to the frame buffers . The compositor will be further described in more detail hereafter. Note that the pipelines the frame buffers and the compositor will be collectively referred to herein as a graphical acceleration unit .

In some situations it may be desirable to distribute some of the graphics pipelines across multiple computers. In this regard by distributing the graphics pipelines across multiple computers it is possible to divide the processing burden associated with the rendering performed by the pipelines across the multiple computers rather than having a single computer bear the entire processing burden alone. For illustrative purposes assume that each of the graphics pipelines is implemented via a different computer. However it should be noted that in other embodiments multiple ones of the graphics pipelines could be implemented via the same computer if desired.

When the graphics pipelines are implemented via different computers it may be desirable to utilize a network such as a local area network LAN for example to enable communication between the pipelines . Indeed in the exemplary embodiment shown by a LAN is utilized to interconnect each of the pipelines which preferably reside on different computers as described above.

Various types of network protocols may be employed to process the graphical data received from the graphics application . In the exemplary embodiment of the system described herein X Protocol is preferably utilized to render 2D graphical data and an extension of X Protocol referred to as OpenGL OGL Protocol is preferably utilized to render 3D graphical data although other types of protocols may be utilized in other embodiments.

By way of background OGL Protocol is a standard application programming interface API to hardware that accelerates 3D graphics operations. Although OGL Protocol is designed to be window system independent it is often used with window systems such as the X Window System for example. In order that OGL Protocol may be used in an X Window System environment an extension of the X Window System has been developed called GLX. For more complete information on the GLX extension to the X Window System and on how OGL Protocol can be integrated with the X Window System see for example Mark J. Kilgard Addison Wesley Developers Press 1996 which is incorporated herein by reference. Also see commonly assigned U.S. Pat. No. 6 249 294 entitled 3D Graphics in a Single Logical Screen Display Using Multiple Remote Computer Systems which is incorporated herein by reference as well.

The client computer preferably includes a client side GLX layer that can be implemented in software hardware or a combination thereof. In the embodiment shown by the client side GLX layer is implemented in software and translates each graphics command issued by the graphics application into one or more X Protocol commands for performing the functionality commanded by the issued command. In the preferred embodiment the X Protocol commands are communicated to the master pipeline via LAN interface and LAN .

The computer also includes an X server . The X server may be implemented in software hardware or a combination thereof and in the embodiment shown by the X server is implemented in software and stored in memory . The X server preferably renders 2D X Protocol commands such as commands to create or move an X window. In this regard an X server dispatch layer is designed to route received commands to a device independent DIX layer or to a GLX layer . A 2D X Protocol command i.e. an X Protocol command that does not include 3D graphical data is interfaced with the DIX layer whereas a 3D X Protocol command i.e. an X Protocol command that includes 3D graphical data such as an X Protocol command having embedded OGL Protocol is interfaced with the GLX layer . An example of a 3D X Protocol command is an X Protocol command that creates or changes the state of a 3D image within a 2D X window.

Moreover a command interfaced with the DIX layer is executed by the DIX layer and by a device dependent DDX layer which drives graphical data associated with the executed command through pipeline hardware to the frame buffer . A command interfaced with the GLX layer is transmitted by the GLX layer across the LAN to the slave pipelines . After receiving the command one or more of the pipelines execute the command and render the graphical data associated with the command to one or more frame buffers . Note that logic for implementing the master pipeline shown by generally resides within the X server and the pipeline hardware of .

Although the graphics application and the master pipeline are implemented via different computers and in the embodiment described above it is possible for the graphics application and the master pipeline to be implemented via the same computer in other embodiments. For example it is possible to store the graphics application and the client side GLX layer in the memory of the computer shown by .

Similar to computers and the computer of comprises one or more processing elements that communicate to and drive the other elements within the computer via a local interface which can include one or more buses. Furthermore an input device for example a keyboard or a mouse can be used to input data from a user of the computer and an output device for example a display device or a printer can be used to output data to the user. The computer preferably includes a LAN interface that allows the computer to exchange data with the LAN .

Similar to X server the X server of comprises an X server dispatch layer a GLX layer a DIX layer and a DDX layer . In the embodiment described above each command received by the computer includes 3D graphical data because the X server of master pipeline preferably executes each 2D X Protocol command. The X server dispatch layer interfaces the 2D data of any received commands with DIX layer and interfaces the 3D data of any received commands with the GLX layer . The DIX and DDX layers and are configured to process or accelerate the 2D data and to drive the 2D data through pipeline hardware to one of the frame buffers .

The GLX layer interfaces the 3D data with the OGL dispatch layer of the OGL daemon . The OGL dispatch layer interfaces this data with the OGL DI layer . The OGL DI layer and DD layer are configured to process the 3D data and to accelerate or drive the 3D data through pipeline hardware to one of the frame buffers . Thus the 2D graphical data of a received command is processed or accelerated by the X server and the 3D graphical data of the received command is processed or accelerated by the OGL daemon . Note that logic for implementing a slave pipeline generally resides within the X server pipeline hardware and OGL Daemon . Furthermore for a more detailed description of the foregoing process of accelerating 2D data via an X server and of accelerating 3D data via an OGL daemon refer to U.S. Pat. No. 6 249 294.

As set forth above the compositor is configured to form a composite data signal that is based on the graphical data stored in one or more of the frame buffers . The composite data signal defines the color values for the pixels of the display device and the display device updates its displayed image based on the color values received from the composite data signal . Various techniques may be employed by the compositor in forming the composite data signal such that the performance of the system and or the quality of the images displayed by the system are improved. For example the compositor may help to optimize performance of the system by utilizing data from different ones of the frame buffers in defining different portions of the image displayed by the system . In addition the compositor may improve image quality by utilizing the data stored in multiple ones of the frame buffers to perform jitter enhancement anti aliasing and or other image enhancement techniques. A more detailed description of an exemplary compositor that may be employed in the system is included in commonly assigned U.S. patent application Ser. No. 09 715 335 entitled System and Method for Efficiently Rendering Graphical Data which is incorporated herein by reference.

Furthermore it should be noted that the compositor may be removed from the system if desired. In such and embodiment each of the pipelines may be configured to render graphical data to a different display device . Such an embodiment is generally referred to as single logical screen SLS and is described in more detail in commonly assigned U.S. Pat. No. 6 249 294.

During operation a user of the system may submit input commands via one or more input devices included in the system . As an example the user may submit such commands via the input device of the client computer . Alternatively the user may submit such input commands via the input device of the computer implementing the master pipeline or via the input device of a computer implementing one of the slave pipelines . As described previously such input devices and may include various components such as a keyboard or mouse for enabling a user to submit inputs.

The input commands submitted by the user may perform a variety of functions. As an example an input command when executed may move or resize an object e.g. a window being displayed by the system . One type of object commonly controlled via the submission of user inputs is a graphical pointer e.g. an arrow that allows the user to select various displayed icons or other types of objects. To select a particular object the user submits via movement of a mouse for example input commands for moving the graphical pointer over the particular object and then submits a command via activation of the mouse for example for selecting the object over which the graphical pointer is displayed. Such a methodology for selecting an object is generally well known in the art and is implemented in most conventional window based computer systems.

Each input command submitted by the user is preferably passed to the master pipeline and executed by the master pipeline . As an example if the user utilized the client computer to submit an input command the input command is preferably received by the input device and transmitted over the LAN via LAN interface . Note that the input commands from the input device and the graphics commands from the graphics application may be interleaved when transmitted to the master pipeline .

Most input commands generally do not include 3D graphical data and are therefore 2D commands that may be executed by the X server of the master pipeline . Thus according to the techniques described herein the X server preferably executes the input commands submitted by the user of the system and renders graphical data based on the executed input commands to the frame buffer .

In some cases the master pipeline may receive from the graphics application a 3D graphics command that takes a significant amount of time for the master pipeline to process. For example a particular 3D graphics command may include a relatively large amount of graphical data. Due to the amount of graphical data included in the command it may take a relatively long time for the master pipeline to pass the command to the slave pipelines particularly when communication with the slave pipelines occurs over the LAN . As a result processing of the 3D graphics command by the master pipeline may delay other commands received by the master pipeline .

In another situation the 3D graphics command may require a reply to be communicated to the graphic application . For example according to X protocol a graphics command for drawing a new object requires the application to be informed when the new object has been created. Such notice includes an identifier for identifying the object and the graphics application utilizes this identifier in submitting future commands to modify or change the object. Note that various other types of commands may similarly require notices or replies to be provided to the graphics application .

Furthermore according to X Protocol when a graphics application submits a command that requires a reply future commands submitted by the graphics application should not be executed until the reply has been generated. Thus most conventional X servers are configured to wait for the generation of a reply when processing a command that requires a reply.

Thus the X server may be configured such that the processing of a command requiring a reply is not complete until at least one or more of the slave pipelines generates a reply. Such a reply may be communicated to the X server which then communicates the reply to the application . After communicating the reply to the application the X server may begin processing the next command received by the master pipeline . However the processing of a command in this way may cause some of the commands received by the master pipeline to be significantly delayed. In this regard commands received by the X server may be delayed while the X server is waiting for a reply.

Introducing a delay to the commands received by the master pipeline can be particularly problematic for input commands received from the user of the system . In this regard significant delaying of such commands may be confusing to the user. For example a user may submit an input via a keyboard but due to the delay caused by the master pipeline processing a time consuming 3D graphics command the system may not respond to the input command for a significant amount of time. During such time the user may be confused as to whether or not the system has detected the input. As a result the user may attempt to resubmit the input even though such resubmission may not be necessary.

In another example the user may move a graphical pointer by manipulating a mouse. However due to the delay caused by the master pipeline processing a time consuming 3D graphics command the input commands generated in response to the movement of the mouse may be significantly delayed. As a result the movement of the graphical pointer may be delayed causing the graphical pointer to appear frozen for a period of time. The freezing of the graphical pointer can be very frustrating for the user and can even result in the user selecting an unintended option or object.

To help reduce the amount of delay experienced by input commands received from the user of the system the X server may be multi threaded. In this regard the X server dispatch layer the DIX layer and the DDX layer may comprise one thread and the GLX layer may comprise another thread. Such an embodiment is illustrated in where the GLX layer is shown as a separate process referred to as 3D process relative to the X server dispatch layer the DIX layer and the DDX layer which are collectively referred to as 2D process . In this embodiment one thread of the X server is responsible for implementing 3D process and another thread of the X server is responsible for implementing 2D process .

In the embodiment shown by the X server dispatch layer of the 2D process preferably routes each 2D command including 2D input commands to DIX layer and DDX layer which render graphical data associated with such commands to the frame buffer similar to the techniques described above. In addition the X server dispatch layer of the 2D process stores each 3D graphics command into a command queue . After a 3D graphics command is stored into the command queue processing of the 3D graphics command by the 2D process ends and the 2D process may begin processing the next command received by the X server .

The GLX layer of the 3D process is configured to process each of the 3D graphics commands stored in the command queue similar to the techniques for processing 3D graphics commands described above. In this regard the GLX layer retrieves a 3D graphics command from the command queue and passes the 3D graphics command to the slave pipelines . One or more of the slave pipelines then execute the 3D graphics command. If the 3D graphics command requires a reply the GLX layer is preferably designed to wait for the reply from the slave pipelines before processing the next command in the command queue . Once the GLX layer has completely processed the current 3D graphics command the GLX layer preferably retrieves and processes the next 3D graphics command from the command queue .

In the aforedescribed embodiment any delays experienced by the GLX layer in processing the 3D graphics commands do not significantly delay the input commands received from the user of the system . In particular any input command received by the X server while processing a time consuming 3D graphics command is not significantly delayed. Moreover the input command may be executed by the 2D process while the 3D process is processing the time consuming 3D graphics command. As a result the performance of the system as perceived by the user is generally improved.

Note that utilizing multiple processes and to execute the commands received by the X server introduces various potential data errors. For example in separately executing 2D and 3D commands both the 2D process and the 3D process may attempt to communicate replies to the graphics application at the same time. If this occurs one of the replies may interfere with or overwrite the other reply causing a data error. Thus in the preferred embodiment steps are taken to ensure that both the 3D process and the 2D process do not attempt to communicate a reply to the graphics application at the same time. Note that there are a variety of techniques that may be employed to prevent the processes and from simultaneously communicating replies to the graphics application .

As an example when the 3D process determines that a reply should be communicated to the graphics application the process may assert a signal referred to hereafter as a lock signal that is communicated to the 2D process . When the lock signal is asserted the 2D process is preferably configured to refrain from communicating replies to the graphics application .

After asserting the lock signal the 3D process then communicates its reply to the graphics application . After communicating this reply the 3D process deasserts the lock signal. Once the lock signal is deasserted the 2D process may again communicate replies to the graphics application .

By implementing the foregoing reply overwrites may be prevented. In this regard when the 3D process is communicating a reply the 3D process prevents the 2D process from overwriting the reply by asserting the lock signal. Furthermore when the lock signal is deasserted the 2D process may communicate its replies. However while the lock signal is deasserted the 3D process is not communicating replies to the graphics application and a reply overwrite therefore does not occur.

In another embodiment which is depicted by the 3D process can be configured to queue replies to prevent reply overwrites. In this regard when the 3D process determines that a reply should be communicated to the graphics application the process preferably stores data indicative of the reply in a reply queue . The 2D process periodically checks the reply queue to determine whether any replies derived from the processing of 3D graphics commands are to be communicated to the graphics application . When such a reply is indicated by the reply queue the 2D process communicates the reply to the graphics application . Moreover the transmission of replies derived from both 2D commands and 3D commands are handled by the 2D process . By ensuring that such replies are serially transmitted the 2D process can ensure that none of the replies interfere with or overwrite any of the other replies.

In another exemplary embodiment which is shown by the X server may be single threaded. In such an embodiment the X server including the GLX layer generally performs the functionality described above for the 2D process and a component referred to as 3D command daemon separate from the X server generally performs the functionality described above for the 3D process . In this regard the X server dispatch layer preferably routes each 2D command including 2D input commands to DIX layer and DDX layer which render graphical data associated with such commands to the frame buffer similar to the techniques described above. In addition the X server dispatch layer of the 2D process routes each 3D command to the GLX layer . The GLX layer is preferably configured to store each such 3D graphics command into the command queue . After the 2D process stores a 3D graphics command into the command queue the processing of the 3D graphics command by the process ends. Thus the 2D process may begin processing the next command received by the X server .

The 3D command daemon of the 3D process is configured to process each of the 3D graphics commands stored in the command queue similar to the techniques described above for the GLX layer in previous embodiments. In this regard the 3D command daemon retrieves a 3D graphics command from the command queue and passes the 3D graphics command to the slave pipelines and one or more of the slave pipelines execute the 3D graphics command. If the 3D graphics command requires a reply the 3D command daemon is preferably designed to wait for the reply from the slave pipelines before processing the next command in the command queue . Once the 3D command daemon has completely processed the current 3D graphics command the 3D command daemon preferably retrieves and processes the next 3D graphics command from the command queue .

In the aforedescribed embodiment any delays experienced by the 3D command daemon in processing the 3D graphics commands do not significantly delay the input commands received from the user of the system . In particular any input command received by the X server while processing a time consuming 3D graphics command is not significantly delayed. Moreover the input command may be executed by the 2D process while the 3D process is processing the time consuming 3D graphics command. As a result the performance of the system as perceived by the user is generally improved.

Note that the 3D process and the 2D process of may employ the same techniques described above for preventing reply overwrites. In this regard the 3D process of may prevent the 2D process from communicating replies to the application at the same time that the 3D process is communicating a reply to the application . Furthermore in an alternative embodiment the 3D process of may queue its replies letting the 2D process handle the communication of such replies to the 2D process . Note that other techniques for preventing reply overwrites may be employed by the process and of .

Furthermore the processes and are configured to perform similar functionality in each of the embodiments described above. The primary difference between the embodiment shown by and the embodiments shown by is that the GLX layer of the X server in is not responsible for providing 3D graphics commands to the salve pipelines . Instead it is responsible for providing the 3D graphics commands to the command queue . Moreover the embodiment shown by can be implemented utilizing a single threaded X server which can be implemented by slightly modifying a GLX layer of a conventional single threaded X server e.g. modifying the GLX layer such that it stores 3D commands to the command queue . Slightly modifying a conventional X server in this way can be much simpler than converting a conventional single threaded X server into a multi threaded X server as may be done to implement the embodiment shown by . Thus the embodiment shown by may facilitate implementation of the system .

The preferred use and operation of the processes and and associated methodology are described hereafter.

In a first embodiment assume that the processes and are configured to prevent reply overwrites by having the 2D process refrain from communicating replies when a lock signal from by the 3D process is asserted. In this embodiment the 2D process determines in block of whether the master pipeline has received a new command to be processed. Such a command may be a graphics command from the application or may be an input command submitted by a user of the system . In block the process determines whether or not the command is a 3D graphics command. If the command is a 3D graphics command the process queues the command into the command queue as shown by block . Upon queuing the command the process returns to block and begins to process the next command received by the master pipeline .

However if the process determines in block that the command is not a 3D graphics command the process executes the command in block instead of queuing the command as described above. The process also determines in block whether or not a reply is to be communicated to the application in response to the command. If not the process returns to block and begins to process the next command received by the master pipeline .

If a reply is to be communicated to the application the process in block determines when it is ready to transmit such a reply. Once the process is ready to transmit the reply the process determines in block whether it is receiving an asserted lock signal from the 3D process . If so the 3D process is communicating another reply to the application and the process therefore refrains from communicating its reply. Once the process detects that the lock signal is deasserted the process communicates its reply to the application in block . At this point the process returns to block and begins to process the next command received by the master pipeline .

While the 2D process is performing the blocks shown in the 3D process is performing the blocks shown by . In this regard the 3D process determines in block whether there are any commands queued in the command queue . Any such queued command is preferably a 3D graphics command to be executed by the slave pipelines since the 2D process is preferably designed to execute each 2D command. If there is a command in the queue the process retrieves the next command on a first in first out FIFO basis and communicates the retrieved command to the slave pipelines in block .

The process also determines in block whether or not a reply should be communicated to the application in response to the command. If not the process returns to block . However if a reply is to be communicated in response to the command the process waits for the reply from one or more of the slave pipelines as shown by block . Once the process has received the reply from the one or more pipelines the process is ready to communicate the reply to the graphics application . However before communicating the reply the process first asserts the lock signal being communicated to the 2D process as shown by block . The process then communicates the reply to the application in block . Note that assertion of the lock signal in block prevents the 2D process from communicating a reply to the graphics application at the same time that the process is communicating a reply in block .

After completing the transmission of the reply to the application the process deasserts the lock signal in block thereby allowing the 2D process to again communicate replies to the application . At this point the process returns to block and begins to process the next command from the command queue .

Thus the 2D process may process 2D commands while the 3D process is simultaneously processing 3D commands. Moreover delays encountered by the 3D process preferably do not delay the processing of the 2D commands by the 2D process . As a result delays to the input commands submitted by the user of the system are likely to be reduced.

Moreover illustrates an operation of the 3D process in the present embodiment. As can be seen by comparing to the operation of the process in the present embodiment is similar to its operation in the previous embodiment. However instead of communicating a reply to the application as is done in block of the process in the present embodiment stores the reply to the reply queue in block . Furthermore since the 2D process handles the communication of each reply to the application in the present embodiment it is not necessary for the process depicted by to communicate a lock signal to the process .

