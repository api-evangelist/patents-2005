---

title: System and method for providing a unified iSCSI target with a plurality of loosely coupled iSCSI front ends
abstract: A system and method provides a unified iSCSI target using a plurality of loosely coupled iSCSI front ends. A cluster comprising a number of network elements and disk elements exports one or more logical units to iSCSI initiators. Each of the network elements is operatively interconnected with a replicated database which is utilized to share initiator data structures and lun mapping information. An iSCSI initiator may communicate with any of the network elements to access any of the logical units exported by the cluster.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08484365&OS=08484365&RS=08484365
owner: NetApp, Inc.
number: 08484365
owner_city: Sunnyvale
owner_country: US
publication_date: 20051020
---
The present invention relates to storage systems and more particularly to providing a unified iSCSI target using a plurality of storage system front ends.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

Storage of information on the disk array is preferably implemented as one or more storage volumes of physical disks defining an overall logical arrangement of disk space. The disks within a volume are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . RAID implementations enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of redundant information parity with respect to the striped data. As described herein a volume typically comprises at least one data disk and one associated parity disk or possibly data parity partitions in a single disk arranged according to a RAID 4 or equivalent high reliability implementation. The term RAID and its various implementations are well known and disclosed in by D. A. Patterson G. A. Gibson and R. H. Katz Proceedings of the International Conference on Management of Data SIGMOD June 1988.

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on the disks as a hierarchical structure of data containers such as files and blocks. For example each on disk file may be implemented as a set of data structures i.e. disk blocks configured to store information such as the actual data for the file. These data blocks are organized within a volume block number vbn space that is maintained by the file system. The file system may also assign each data block in the file a corresponding file offset or file block number fbn . The file system typically assigns sequences of fbns on a per file basis whereas vbns are assigned over a larger volume address space. The file system organizes the data blocks within the vbn space as a logical volume each logical volume may be although is not necessarily associated with its own file system.

A known type of file system is a write anywhere file system that does not over write data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks. An example of a write anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

The storage system may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network LAN wide area network WAN or virtual private network VPN implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file based and block based protocol messages in the form of packets to the system over the network. In the case of block based protocol packets the client requests and storage system responses address the information in terms of block addressing on disk using e.g. a logical unit number lun . These block base protocol packets may comprise SCSI encapsulated in TCP IP iSCSI .

In such block based storage system environments the luns exported by a storage system are only available by accessing that particular system. It should be noted that the term lun as used herein may refer to a logical unit number and or a logical unit. A noted disadvantage of such environments arises when the storage system suffers an error or otherwise becomes inaccessible due to e.g. a failure in network connectivity. As luns are only available by accessing the storage system those luns become inaccessible should the storage system become inaccessible. Such inaccessibility is unacceptable for many users of SANs who require high e.g. 24 7 data availability.

To improve the availability of luns storage systems may be coupled together in a cluster with the property that when one storage system fails the other begins servicing data access requests directed to the failed storage system s luns. In such an environment two storage systems are coupled to form a storage system cluster. Each storage system services data access requests directed to its luns and only services data access requests directed to the other storage system s luns after a failover operation has occurred. During the failover operation the surviving storage system assumes the identity of the failed storage system by for example assigning the failed storage system s Internet Protocol IP addresses to network adapters available on the surviving storage system. However a noted disadvantage of such clusters is that they are limited to two storage systems.

Another noted disadvantage of such clusters is that data access requests directed to a lun may only be serviced by one storage system at any given point in time. Thus if numerous data access requests are directed to a first storage system in a cluster the second storage system may sit idle while the first storage system is consumed with data access requests. While the disk subsystem of the first storage system may be able to process and or retrieve information associated with the data access requests it is possible that the network protocol stacks on the first storage system may become overwhelmed so that initiators may need to throttle their data access requests.

The disadvantages of the prior art are overcome by providing a system and method for configuring a cluster of interconnected storage systems as an iSCSI unified target. Illustratively each storage system of the cluster comprises one or more network elements N module and disk elements D module operatively interconnected by a cluster switching fabric. The present invention permits the cluster to be presented to an initiator client as an iSCSI target by encoding each N module to function as one of a plurality of front ends of the iSCSI target. As a front end any N module may cooperate with clients to open establish one or more iSCSI sessions and thereafter receive data access requests directed to the iSCSI unified target. A data access request received by an N module is forwarded from that module to an appropriate D module of the cluster for processing.

A management module M module is operatively interconnected with the cluster to provide a set of user interface tools that enable an administrator to create appropriate logical unit number lun maps create and or destroy luns and to perform other lun management functions. A replicated database RDB executes as a user application on each storage system and interfaces with a lun configuration process to centralize configuration of luns within the cluster. Modifications to the lun configuration are stored within the RDB. The RDB alerts each N module of a change which causes the N module to retrieve the changed information from the RDB and update its local configuration.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the network . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

Also interconnected with the cluster switching fabric is a management module M module . The M module executes various user interface UI and management functions for the cluster. Illustratively the M module processes commands entered by an administrator for creating and maintaining logical unit number lun configuration information in accordance with the illustrative embodiment of the present invention.

Each node is illustratively embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However it will be apparent to those of ordinary skill in the art that the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N module on the node while the other processor executes the functions of the D module .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises a plurality of ports adapted to couple the node to one or more clients over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network. Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over network by exchanging discrete frames or packets of data according to pre defined protocols such as TCP IP.

The network adapter may comprise a conventional network interface controller NIC or may in alternate embodiments comprise a TCP IP offload engine TOE and or an iSCSI target host bus adapter HBA each of which may provide a level of acceleration for use with the iSCSI protocol. In alternate embodiments there may be a plurality of network adapters each of which may accept iSCSI connections.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC link topology.

Storage of information on each array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

To facilitate access to the disks the storage operating system implements a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term ONTAP is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module a RAID system module and a disk driver system module . The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework see in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the logical unit space and the file system space where logical units are represented as named objects within the file system space.

Illustratively the SCSI target module includes a number of initiator data structures and or lun data structures . As described further below an initiator data structure is generated for each iSCSI initiator that logs into the N module. The initiator data structure contains various data associated with the initiator. Similarly a lun data structure is associated with each lun exported by the storage system and as described further below is utilized to store various metadata related to the luns. Initiator data structures and lun data structures are further described in U.S. patent application Ser. No. 10 619 122 entitled SYSTEM AND METHOD FOR OPTIMIZED LUN MASKING by Herman Lee et al. now issued as U.S. Pat. No. 7 523 201 on Apr. 21 2009 which is hereby incorporated by reference.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte KB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store meta data describing the layout of its file system these meta data files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

Operationally a request from the client is forwarded as a packet over the computer network and onto the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . Here the file system generates operations to load retrieve the requested data from disk if it is not resident in core i.e. in memory . If the information is not in memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the network .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by node in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows XP or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system the teachings of the present invention may be utilized with any suitable file system including a write in place file system.

In the illustrative embodiment the storage server is embodied as D module of the storage operating system to service one or more volumes of array . In addition the multi protocol engine is embodied as N module to i perform protocol termination with respect to a client issuing incoming data access request packets over the network as well as ii redirect those data access requests to any storage server of the cluster . Moreover the N module and D module cooperate to provide a highly scalable distributed storage system architecture of the cluster . To that end each module includes a cluster fabric CF interface module adapted to implement intra cluster communication among the modules including D module to D module communication.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers in conjunction with the SCSI target layer of the N module function as protocol servers that translate file based and block based data access requests from clients. As part of the processing of these requests the N module may have to request data services from the D Module . This may be achieved via file system primitive operations commands that are embedded within CF messages by the CF interface module for transmission to the D modules of the cluster . Notably the CF interface modules cooperate to provide a single file system image across all D modules in the cluster . A data access request received by an N Module is processed by that N Module. As part of the processing the N module may have to send requests to one or more D modules. A Locate function is illustratively implemented within CF interface . The Locate function interfaces with a volume location database described further below to identify the proper D module to which a data access request should be forwarded. Generally the Locate function identifies the D module that is currently serving the volume to which the data access request is directed.

Further to the illustrative embodiment the N module and D module are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the modules may be implemented as pieces of code within a single operating system process. Communication between an N module and D module is thus illustratively effected through the use of message passing between the modules although in the case of remote communication between an N module and D module of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between modules processes is the Inter Process Communication IPC mechanism. The protocol used with the IPC mechanism is illustratively a generic file and or block based agnostic CF protocol that comprises a collection of methods functions constituting a CF application programming interface API . Examples of such an agnostic protocol is the SpinFS protocol available from Network Appliance Inc. The SpinFS protocol is described in the above referenced U.S. Pat. No. 6 671 773.

The CF interface module implements the CF protocol for communicating file system commands among the modules of cluster . Communication is illustratively effected by the D module exposing the CF API to which an N module or another D module issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N module encapsulates a CF message as i a local procedure call LPC when communicating a file system command to a D module residing on the same node or ii a remote procedure call RPC when communicating the command to a D module residing on a remote node of the cluster . In either case the CF decoder of CF interface on D module de encapsulates the CF message and processes the file system command.

A data container e.g. a file or logical unit is accessed in the file system using a data container handle. is a schematic block diagram illustrating the format of a data container handle including a volume ID field an inode number field and a unique ifier field . The volume ID field contains a global identifier within the cluster of the volume within which the data container resides. The inode number field contains an inode number of an inode within an inode file pertaining to the data container. The unique ifier field contains a monotonically increasing number that uniquely identifies the data container handle . The unique ifier is particularly useful in the case where an inode number has been deleted reused and reassigned to a new data container. The unique ifier distinguishes that reused inode number in a particular data container from a potentially previous use of those fields.

In the illustrative embodiment a data container is represented in the write anywhere file system as an inode data structure adapted for storage on the disks . is a schematic block diagram of an inode which preferably includes a meta data section and a data section . The information stored in the meta data section of each inode describes the data container e.g. a file and as such includes the type e.g. regular directory vdisk of file its size time stamps e.g. access and or modification time and ownership i.e. user identifier UID and group ID GID of the file. The contents of the data section of each inode may be interpreted differently depending upon the type of file inode defined within the type field . For example the data section of a directory inode contains meta data controlled by the file system whereas the data section of a regular inode contains file system data. In this latter case the data section includes a representation of the data associated with the file.

Specifically the data section of a regular on disk inode may include file system data or pointers the latter referencing 4 KB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system when accessing the data on disks. Given the restricted size e.g. 128 bytes of the inode file system data having a size that is less than or equal to 64 bytes is represented in its entirety within the data section of that inode. However if the length of the contents of the data container exceeds 64 bytes but less than or equal to 64 KB then the data section of the inode e.g. a first level inode comprises up to 16 pointers each of which references a 4 KB block of data on the disk.

Moreover if the size of the data is greater than 64 KB but less than or equal to 64 megabytes MB then each pointer in the data section of the inode e.g. a second level inode references an indirect block e.g. a first level L1 block that contains 1024 pointers each of which references a 4 KB data block on disk. For file system data having a size greater than 64 MB each pointer in the data section of the inode e.g. a third level L3 inode references a double indirect block e.g. a second level L2 block that contains 1024 pointers each referencing an indirect e.g. a first level L1 block. The indirect block in turn contains 1024 pointers each of which references a 4 KB data block on disk. When accessing a data container e.g. file or logical unit each block of the data container may be loaded from disk into the memory .

When an on disk inode or block is loaded from disk into memory its corresponding in core structure embeds the on disk structure. For example the dotted line surrounding the inode indicates the in core representation of the on disk inode structure. The in core structure is a block of memory that stores the on disk structure plus additional information needed to manage data in the memory but not on disk . The additional information may include e.g. a dirty bit . After data in the inode or block is updated modified as instructed by e.g. a write operation the modified data is marked dirty using the dirty bit so that the inode block can be subsequently flushed stored to disk. The in core and on disk format structures of the WAFL file system including the inodes and inode file are disclosed and described in the previously incorporated U.S. Pat. No. 5 819 292 titled METHOD FOR MAINTAINING CONSISTENT STATES OF A FILE SYSTEM AND FOR CREATING USER ACCESSIBLE READ ONLY COPIES OF A FILE SYSTEM by David Hitz et al. issued on Oct. 6 1998.

A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes or flexible volume of a storage system such as node . An example of such a file system layout is described in U.S. patent application Ser. No. 10 836 817 titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT by John K. Edwards et al. and assigned to Network Appliance Inc. now issued as U.S. Pat. No. 7 409 494 on Aug. 5 2008. The underlying physical volume is an aggregate comprising one or more groups of disks such as RAID groups of the node. The aggregate has its own physical volume block number pvbn space and maintains meta data such as block allocation structures within that pvbn space. Each flexible volume has its own virtual volume block number vvbn space and maintains meta data such as block allocation structures within that vvbn space. Each flexible volume is a file system that is associated with a container file the container file is a file in the aggregate that contains all blocks used by the flexible volume. Moreover each flexible volume comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.

In one embodiment pvbns are used as block pointers within buffer trees of files such as file stored in a flexible volume. This hybrid flexible volume embodiment involves the insertion of only the pvbn in the parent indirect block e.g. inode or indirect block . On a read path of a logical volume a logical volume vol info block has one or more pointers that reference one or more fsinfo blocks each of which in turn points to an inode file and its corresponding inode buffer tree. The read path on a flexible volume is generally the same following pvbns instead of vvbns to find appropriate locations of blocks in this context the read path and corresponding read performance of a flexible volume is substantially similar to that of a physical volume. Translation from pvbn to disk dbn occurs at the file system RAID system boundary of the storage operating system .

In an illustrative dual vbn hybrid flexible volume embodiment both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a file. That is the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks e.g. level 1 L1 indirect blocks inode file level 0 L0 blocks. is a schematic block diagram of an illustrative embodiment of a buffer tree of a file that may be advantageously used with the present invention. A root top level inode such as an embedded inode references indirect e.g. level 1 blocks . Note that there may be additional levels of indirect blocks e.g. level 2 level 3 depending upon the size of the file. The indirect blocks and inode contain pvbn vvbn pointer pair structures that ultimately reference data blocks used to store the actual data of the file.

The pvbns reference locations on disks of the aggregate whereas the vvbns reference locations within files of the flexible volume. The use of pvbns as block pointers in the indirect blocks provides efficiencies in the read paths while the use of vvbn block pointers provides efficient access to required meta data. That is when freeing a block of a file the parent indirect block in the file contains readily available vvbn block pointers which avoids the latency associated with accessing an owner map to perform pvbn to vvbn translations yet on the read path the pvbn is available.

Whereas the aggregate is analogous to a physical volume of a conventional storage system a flexible volume is analogous to a file within that physical volume. That is the aggregate may include one or more files wherein each file contains a flexible volume and wherein the sum of the storage space consumed by the flexible volumes is physically smaller than or equal to the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume while each embedded flexible volume within a file utilizes a logical vvbn space to organize those blocks e.g. as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file which locations are then translated to dbns on disks. Since the flexible volume is also a logical volume it has its own block allocation structures e.g. active space and summary maps in its vvbn space.

A container file is a file in the aggregate that contains all blocks used by a flexible volume. The container file is an internal to the aggregate feature that supports a flexible volume illustratively there is one container file per flexible volume. Similar to a pure logical volume in a file approach the container file is a hidden file not accessible to a user in the aggregate that holds every block in use by the flexible volume. The aggregate includes an illustrative hidden meta data root directory that contains subdirectories of flexible volumes 

Specifically a physical file system WAFL directory includes a subdirectory for each flexible volume in the aggregate with the name of subdirectory being a file system identifier fsid of the flexible volume. Each fsid subdirectory flexible volume contains at least two files a filesystem file and a storage label file. The storage label file is illustratively a 4 KB file that contains meta data similar to that stored in a conventional raid label. In other words the storage label file is the analog of a raid label and as such contains information about the state of the flexible volume such as e.g. the name of the flexible volume a universal unique identifier uuid and fsid of the flexible volume whether it is online being created or being destroyed etc.

In addition to being embodied as a container file having level 1 blocks organized as a container map the filesystem file includes block pointers that reference various file systems embodied as flexible volumes . The aggregate maintains these flexible volumes at special reserved inode numbers. Each flexible volume also has special reserved inode numbers within its flexible volume space that are used for among other things the block allocation bitmap structures. As noted the block allocation bitmap structures e.g. active map summary map and space map are located in each flexible volume.

Specifically each flexible volume has the same inode file structure content as the aggregate with the exception that there is no owner map and no WAFL fsid filesystem file storage label file directory structure in a hidden meta data root directory . To that end each flexible volume has a volinfo block that points to one or more fsinfo blocks each of which may represent a snapshot along with the active file system of the flexible volume. Each fsinfo block in turn points to an inode file that as noted has the same inode structure content as the aggregate with the exceptions noted above. Each flexible volume has its own inode file and distinct inode space with corresponding inode numbers as well as its own root fsid directory and subdirectories of files that can be exported separately from other flexible volumes.

The storage label file contained within the hidden meta data root directory of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system such as the volume name that information is loaded into the storage label file . Illustratively the storage label file includes the name of the associated flexible volume the online offline status of the flexible volume and other identity and state information of the associated flexible volume whether it is in the process of being created or destroyed .

It should be noted that while this description is written in terms of aggregates and flexible volumes the teachings of the present invention may be utilized with storage operating systems having any data format. As such the description of aggregates and flexible volumes should be taken as exemplary only.

These applications illustratively operate in user mode to enable reconfiguration or re initialization of any of the applications without requiring the complete re initialization of the storage operating system which would result in a loss of data access for some length of time while the storage operating system was initializing. However it should be noted that in alternate embodiments the management process applications may execute in non user mode e.g. in kernel mode.

The management framework is illustratively based on a conventional common interface model CIM object manager that provides the entity to which users system administrators interact with a node in order to manage the cluster . The management framework implements various commands for configuring luns exported by the cluster. In accordance with the illustrative embodiment of the present invention the management framework manages the configuration and distribution of lun configuration information such as initiator data structures and or lun data structures described further below.

The VLDB is a database process that tracks the locations of various storage components e.g. flexible volumes aggregates etc. within the cluster to thereby facilitate routing of requests throughout the cluster. In the illustrative embodiment the N module of each node accesses a configuration table that maps the volume ID of a data container handle to a D module that owns services the data container within the cluster. The VLDB includes a plurality of entries which in turn provide the contents of entries in the configuration table among other things these VLDB entries keep track of the locations of the flexible volumes hereinafter generally volumes and aggregates within the cluster. Examples of such VLDB entries include a VLDB volume entry and a VLDB aggregate entry .

The VLDB illustratively implements a RPC interface e.g. a Sun RPC interface which allows the N module to query the VLDB . When encountering contents of a data container handle that are not stored in its configuration table the N module sends an RPC to the VLDB process. In response the VLDB returns to the N module the appropriate mapping information including an ID of the D module that owns the data container. The N module caches the information in its configuration table and uses the D module ID to forward the incoming request to the appropriate data container. All functions and interactions between the N module and D module are coordinated on a cluster wide basis through the collection of management processes and the RDB library user mode applications .

To that end the management processes have interfaces to are closely coupled to RDB . The RDB comprises a library that provides a persistent object store storing of objects for the management data processed by the management processes. Notably the RDB replicates and synchronizes the management data object store access across all nodes of the cluster to thereby ensure that the RDB database image is identical on all of the nodes . At system startup each node records the status state of its interfaces and IP addresses those IP addresses it owns into the RDB database. Additionally should an IP address ever be moved from one N module to another such modifications are stored within the RDB so that all elements of the cluster are able to determine the current cluster configuration. IP addresses may be moved from one N module to another for a variety of reasons. An N module may fail which would result in an automatic failover of its IP addresses to other N modules within the cluster. Alternately an administrator may manually move and or reassign IP addresses to e.g. load balance etc.

Also as noted the RDB maintains copies of lun data structures and initiator data structures so that each N module of the cluster may share lun configuration information to enable all N modules to present a unified iSCSI target in accordance with an embodiment of the present invention.

In the illustrative embodiment the RDB is implemented as a distributed facility so that each node maintains a local copy of the data contained within the RDB. However in alternate embodiments the functionality of the RDB may be implemented in a non distributed facility. For example the M module may maintain a central database that must be queried by each N D module that desires access. Alternately a single element N D module may be selected to maintain the RDB with each other element N D module querying the identified element for access. The use of a distributed facility improves performance but other techniques for enabling N D modules to have access to RDB s information may be utilized within the teachings of the present invention.

As noted above the SCSI target module illustratively includes a set of initiator data structures as shown in . The initiator data structure is in the illustrative embodiment created when an initiator first connects to e.g. establishes a session with an N module. Each initiator data structure is associated with a SCSI initiator i.e. a client of the cluster . The N module illustratively populates the various fields with data obtained during the connection stage or from an initiator data structure retrieved from the RDB as described further below. The initiator data structure includes various fields including e.g. a world wide name iSCSI Nodename field a SCSI status field and a lun map . It should be noted that in alternate embodiments the initiator data structure may have varying and or differing fields from the illustrative embodiment. The world wide name field contains the unique name e.g. iSCSI nodename associated with the initiator. The SCSI status field contains various status information concerning the initiator s SCSI connection. The lun map contains a mapping of virtual luns VLUNs to physical lun PLUNs . In the illustrative embodiment the lun map is generated along with the initiator data structure when a client initially logs into the storage system if an initiator data structure is not available from the RDB. As described further below each N module generates an initiator data structure for each initiator when the initiator first connects to the N module. The initiator data structures are illustratively distributed via the RDB so that modifications may be seen by all N modules within the cluster. The RDB alerts each N module of a change which causes the N module to retrieve the changed information from the RDB and update its local configuration. That is in the illustrative embodiment once any N module or D module updates its local copy of the RDB the RDB mechanism will each other instantiation of RDB within the cluster to retrieve the updated information. It should be noted that in other embodiments any distributed database implementation may be utilized with the RDB. As such the implementation described herein should be taken as exemplary only.

An exemplary lun map shown in maps VLUNs to PLUNs. A VLUN is a lun returned to a SCSI initiator in a storage system environment. An initiator may be assigned a set of VLUNs starting from zero and progressing up to the number of luns that the initiator is connected thereto. Conversely a PLUN is an actual lun associated with a vdisk managed by the storage system. As an intermediary between clients initiators and vdisks luns the storage system typically manages a larger set of luns than the set that is visible to an initiator.

The N module utilizes the LUN map to translate a VLUN from a SCSI initiator to the appropriate PLUN. The lun map has in the exemplary embodiment two columns. The first column VLUN identifies the virtual logical unit number that a SCSI initiator may access. In one embodiment of the present invention each SCSI initiator attached to the cluster has its own lun address space. The second column comprises of PLUNs that are mapped to corresponding VLUNs . Thus in the example shown in VLUN is mapped to PLUN . Similarly VLUN is mapped to PLUN . The use of VLUN to PLUN mapping enables each SCSI initiator to address a specific device with an initiator specific lun value i.e. a VLUN. If a lun value is not exported to a client the PLUN value associated with the VLUN entry in the lun map is empty. For example VLUN is not mapped to any PLUN value. Thus any data access request issued by the client and directed to VLUN will result in an error.

Each vdisk lun managed by the cluster has an associated vdisk descriptor that includes various data fields for information pertaining to the vdisk. These fields include volume name path name volume number storage system name storage system address PCPI number and a list of initiators e.g. iSCSI nodenames to which the lun is to be exported. It should be noted that the fields described herein are exemplary only in that additional and or differing fields may be utilized in accordance with various embodiments of the invention. For example the volume name field identifies the volume containing the vdisk. The path name field describes a path on the volume identified in the volume name field to the file containing the vdisk. Thus if the storage system name stored in field is System5 the volume name stored in field is vol0 and the path name stored in field field is vdisks vdisk then the vdisk identified by vdisk descriptor may be uniquely identified by the fully qualified path System5 vol0 vdisks vdisk. The list of WWNs stores the WWNs and or iSCSI names of clients initiators to which the lun is to be exported and that may access the lun. The list of WWNs may be set by an administrator when the vdisk is initially created.

The present invention is directed to a system and method for configuring a cluster of interconnected storage systems on an iSCSI unified target. Illustratively each storage system of the cluster comprises one or more network elements N module and disk elements D module operatively interconnected by a cluster switching fabric. The present invention permits the cluster to be presented to an initiator client as an iSCSI target by enabling each N module to function as one of a plurality of front ends of the iSCSI target. As a front end any N module may cooperate with a client to open establish one or more iSCSI sessions and thereafter receive data access requests directed to luns exported to that initiator. A data access request received by an N module is processed by that N module. As part of the processing the N module may send one or more requests to one or more D modules. As used herein a front end comprises a computer or other device to which one or more iSCSI connections terminate.

A management module M module is operatively interconnected with the cluster to provide a set of user interface tools that enable an administrator to create appropriate lun maps create and or destroy luns and to perform other lun management functions. A replicated database RDB executes as a user application on each storage system and interfaces with a lun configuration process to centralize configuration of luns within the cluster. Modifications to the lun configuration are stored within the RDB. The RDB alerts each N module of a change which causes the N module to retrieve the changed information from the RDB and update its local configuration.

If the appropriate initiator data structure is not available from the RDB the N module creates an initiator data structure for storage within the RDB. To that end the N module walks through each of the linked lun data structures associated with the storage system to identify the PLUNs that the initiator may access. This may be accomplished by example by searching for the initiator s WWN in the list of WWNs to be exported field of each of the lun descriptor objects . After the list of PLUNs that are accessible to the initiator has been identified the N module in step creates a lun map for this initiator that associates those PLUNs to VLUNs and incorporates the map into an initiator data structure associated with the initiator. Note that the lun map identifies the mappings of the virtual luns to be exported to the initiator with the physical luns associated with the storage system. The N module then stores the newly created initiator data structure in the RDB in step . Storage of the initiators data structure in the RDB ensures that all N modules share common information stored within data structure to enable proper lun management. Although the initiator data structure is not visible to other N modules if the initiator logs into another N module of the cluster the N module may retrieve the initiator data structure from the RDB without having to generate a new initiator data structure.

Once logged into the storage system the initiator may issue SCSI commands to any of its exported luns. Upon receipt of one of these SCSI commands the storage system first must determine if the initiator is permitted to access the lun identified in the SCSI command. This ensures that only those initiators with the proper security permissions may access the data stored on a lun.

The steps of an illustrative procedure for determining whether an initiator can access a lun are shown in . The procedure starts in step and then proceeds to step where an initiator sends a command directed to a lun associated with a storage system. The initiator uses a lun value associated with its VLUN value that represents the desired lun vdisk. The storage system then accesses the lun map associated with the initiator in step . In the illustrative embodiment lun map is located within the initiator data block that is associated with the initiator. In step the storage system maps the VLUN to a PLUN using the lun map. In step the storage system then checks whether an error occurred during the mapping process. If no error occurred then the storage system performs the requested command directed to the lun identified in the PLUN entry associated with the VLUN received from the initiator and the procedure completes in step . If however an error has occurred in step the procedure then branches to step where an error message is returned. For example an error could occur if the initiator attempts to access a VLUN that is not mapped to a PLUN on the storage system. Referring to the lun map shown in assume the VLUN is not exported to a client since there is no corresponding PLUN value within the lun map . In such a situation an attempt by the initiator to access lun number will result in an error message being returned. By utilizing the above described lun masking technique the storage system only needs to perform a single lookup of data namely identifying the VLUN sent by the initiator and its associated PLUN in the lun map. The procedure then completes instep .

A noted advantage of the present invention is that the lun configuration information is visible to each N module so that the cluster is presented as an iSCSI target with each of the N modules comprising an independent front end to the cluster. To that end changes in lun configurations are propagated to each N module.

The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Specifically it should be noted that the principles of the present invention may be implemented in non distributed file systems. Furthermore while this description has been written in terms of N and D modules the teachings of the present invention are equally suitable to systems where the functionality of the N and D modules are implemented in a single system. Alternately the functions of the N and D modules may be distributed among any number of separate systems wherein each system performs one or more of the functions. Additionally the procedures processes and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

