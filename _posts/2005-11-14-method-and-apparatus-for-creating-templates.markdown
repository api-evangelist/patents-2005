---

title: Method and apparatus for creating templates
abstract: A template creator creates a template class that stores at least one template parameter. The template creator also specifies at least one additional object to be created when an instance of the template class is created. A template user initiates the creation of a new instance of the template class. If an error occurs during the creation of the new instance of the template class, the template user receives a report identifying the error.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07779419&OS=07779419&RS=07779419
owner: Microsoft Corporation
number: 07779419
owner_city: Redmond
owner_country: US
publication_date: 20051114
---
This application is a Continuation of application Ser. No. 10 081 442 filed Feb. 19 2002 now U.S. Pat. No. 7 100 167 entitled Method and Apparatus for Creating Templates and incorporated herein by reference.

That application is a continuation in part of application Ser. No. 09 847 534 filed May 1 2001 now U.S. Pat. No. 7 275 250 entitled Method and Apparatus for Correlating Events and also incorporated herein by reference.

The present invention relates to computing systems and more particularly to a language for describing templates used to collect and correlate various events generated throughout a computing environment.

Computer systems such as servers and desktop personal computers are expected to operate without constant monitoring. These computer systems typically perform various tasks without the user s knowledge. When performing these tasks the computer system often encounters events that require a particular action such as logging the event generating an alert for a particular system or application or performing an action in response to the event . Various mechanisms are available to handle these events.

A computing enterprise typically includes one or more networks services and systems that exchange data and other information with one another. The enterprise may include one or more security mechanisms to safeguard data and authenticate users and may utilize one or more different data transmission protocols. At any particular time one or more networks services or systems may be down e.g. powered down or disconnected from one or more networks . Networks services or systems can be down for scheduled maintenance upgrades overload or failure. Application programs attempting to obtain event data must contend with the various networks services and systems in the enterprise when they are down. Additionally application programs must contend with the security and network topology limitations of the enterprise as well as the various protocols used in the enterprise.

Operating system components services and applications generate a variety of different events. A particular component or application may request to be informed of a particular event e.g. when a server crashes or when a user logs on to the system . Other components or applications may want to be notified when a particular series of events occur within a particular time period. For example a network administrator may want to know when a server crashes within three seconds of a user logging into the system. Server crashes alone may be relatively common and user logins may also be common such that the network administrator is not particularly interested in either event by itself. However when these two events occur within a few seconds of one another there may be a relationship between the two events e.g. the user login was at least partially responsible for the server crash .

Existing systems provide predefined functions that allow a network administrator or other user to create a relationship between two events. This relationship between two events is commonly referred to as a correlation between the two events. The predefined correlation functions provided by existing systems require the user to select from one of the predefined functions. If the correlation function desired by the user has not already been created the user must request that the developer or supplier of the functions create a new function to meet the user s needs. If the developer or supplier is willing to create a new correlation function this custom development work may be very expensive. Depending on the expected demand for the new correlation function the developer or supplier may not be willing to create the requested function.

If the developer is unwilling to create a new correlation function or the cost is too high the user can attempt to use an existing correlation function that is closest to the user s requirements. Such a solution may result in a significant number of unwanted event notifications or may result in a failure to notify the user of a desired sequence of events.

The system and method described herein addresses the limitations of the prior art by providing a template description language that allows a user to develop functions that identify certain events and correlations between multiple events and or data.

The system and method described herein supports a template description language that allows a user to create templates that are used to correlate multiple events and or data elements. The templates created using the template description language in turn create state machines to execute a function such as an event correlation function. The template description language supports the development of two general types of templates correlation helper templates and correlation scenario templates. A correlation helper template is used to parameterize a particular aspect of a correlation scenario. The correlation helper template does not define a complete correlation scenario but instead leaves one or more parameters to be defined by the user implementing the template. A correlation scenario template defines a specific correlation scenario and maintains its own correlation state. Correlation scenario templates can be used as building blocks to create larger more complex correlation scenario templates. The templates described herein allow a user to develop templates to perform any desired event and or data correlation functions.

In one embodiment a template creator creates a template class that stores at least one template parameter. The template creator specifies at least one additional object to be created when an instance of the template class is created. A template user initiates the creation of a new instance of the template class. If an error occurs during the creation of the new instance of the template class the template user receives a report identifying the error.

Another embodiment creates a first template class and designates inputs and outputs associated with the first template class. A second template class is created and inputs and outputs associated with the second template class are designated. A third template class is created by combining the first template class and the second template class.

In a particular embodiment a template description structure includes at least one template class that stores multiple template parameters. The template description structure also includes at least one template builder class that identifies at least one additional object to be created with each instance of the template class. The template description structure further includes at least one order parameter that identifies the order in which the template builder classes are instantiated.

The system and method described herein provides a template description language that allows a user to define templates that perform various correlation functions between events and or data. A correlation helper template is used to parameterize one or more aspects of a correlation scenario. The correlation helper template leaves one or more parameters to be defined by the user creating an instance of the template. A correlation scenario template may be used as a building block to create larger more complex correlation scenario templates.

Web Based Enterprise Management WBEM provides uniform access to management information throughout an enterprise. WBEM is an industry initiative to develop technology for accessing management information in an enterprise environment. This management information includes for example information on the state of system memory inventories of currently installed client applications and other information related to the status of the system. A particular embodiment of the event handling system is represented using Windows Management Instrumentation WMI developed by Microsoft Corporation of Redmond Wash. which provides an infrastructure to handle various events generated by event sources throughout an enterprise.

WMI technology enables systems applications networks and other managed components to be represented using the Common Information Model CIM designed by the Distributed Management Task Force DMTF . This model is used to perform correlation functions discussed herein. CIM is an extensible data model for representing objects that exist in typical management environments. CIM is able to model anything in the managed environment regardless of the location of the data source. The Managed Object Format MOF language is used to define and store modeled data. In addition to data modeling WMI provides a set of base services that include query based information retrieval and event notification. Access to these services and to the management data is provided through a single programming interface.

WMI classes define the basic units of management. Each WMI class is a template for a type of managed object. For example Win32 DiskDrive is a model representing a physical disk drive. For each physical disk drive that exists there is an instance of the Win32 DiskDrive class. WMI classes may contain properties which describe the data of the class and methods which describe the behavior of the class.

WMI classes describe managed objects that are independent of a particular implementation or technology. WMI includes an eventing subsystem that follows the publish subscribe model in which an event consumer subscribes for a selection of events generated by one or more event providers and performs an action as a result of receiving the event. WMI also provides a centralized mechanism for collecting and storing event data. This stored event data is accessible by other systems via WMI tools and or application programming interfaces APIs .

Although particular embodiments are discussed herein as using WMI alternate embodiments may utilize any enterprise management system or application whether web based or otherwise. The event providers and event consumers discussed herein are selected for purposes of explanation. The teachings of the present invention can be used with any type of event provider and any type of event consumer. Additionally the event handling system and method described herein can be applied to any type of enterprise or other arrangement of computing devices applications and or networks.

Event providers include for example systems services or applications that generate event data. An exemplary event provider is a disk drive or an application that monitors the status of a disk drive . The disk drive may generate an event indicating the available storage capacity on the disk drive or indicating the amount of data currently stored on the disk drive. The disk drive may also generate an event indicating that the disk drive is nearly full of data e.g. when ninety five percent or more of the disk drive s capacity is used .

Event consumers may request to be notified of certain events also referred to as subscribing to an event . An example event consumer is an application that manages multiple storage devices in an enterprise. The application may request to receive events generated by any of the disk drives or other storage devices in the enterprise. The application can use this event information to distribute storage tasks among the multiple storage devices based on the available capacity of each device and or the quantity of read or write requests received by each storage device.

System also includes a set of policies which are accessible by WMI module . Policies may control the configuration of one or more systems in the enterprise. Other policies may define various activities such as event filtering event correlation and the forwarding of events to particular devices or applications. A database is coupled to WMI module . Database stores various information related to the enterprise. For example database can store event data i.e. creating an event log policy data and enterprise configuration information.

The WMI module uses WMI features to provide a distributed architecture that is capable of selecting filtering correlating forwarding storing and delivering event data in an enterprise. The WMI module also allows event consumers to request data related to a particular event request data from a particular node or device in the enterprise define the manner in which events are correlated with one another define how certain events should be forwarded and define how to store event data.

The WMI module provides a policy based administration of the enterprise. The policy infrastructure allows administrators to set a policy in the Directory Service DS and the WMI module ensures that the proper set of WMI objects e.g. filters bindings correlators consumers and configuration objects are delivered to the proper devices or applications in the enterprise.

As shown in policies and database are separate from WMI module . However in alternate embodiments policies and or database may be integrated into WMI module .

Table 1 below identifies various types of event providers available in a particular embodiment. Additionally the table includes a description of the events generated by each event provider. For example the Win32 Provider generates events that include information related to the operating system computer system peripheral devices file systems and security for a particular device such as a computer system in the enterprise.

At block the procedure determines whether a new subscription for event information has been received. The procedure may also determine whether a request to revise an existing subscription has been received. If a new subscription or a revised subscription is received the procedure continues to block where the WMI module retrieves the requested event information and provides the information to the requesting event customer. Alternatively the procedure may log the subscription request and notify the requesting event consumer when the next event is received that qualifies under the consumer s subscription request.

The correlator correlates various events and creates additional events that are provided to multiple filters and . Each filter and includes various filter criteria that determines what event characteristics are required to allow the event to pass through the filter. Although each event is sent to all four filters the event may be rejected i.e. not pass through the filter by any or all of the filters. Similarly a particular event may pass through two or more different filters depending on the filter criteria associated with each filter.

Each filter and is associated with a consumer i.e. an event consumer and respectively. For example events that pass through filter are provided to event logging consumer which logs the event data to a storage device . The logged data can be retrieved at a later time for analysis or other purposes. Events that meet the criteria of filter are provided to event forwarding consumer which generates a forwarded event that is distributed to one or more destinations. Events that satisfy the criteria of filter are provided to mail consumer which generates and sends an email message in response to receipt of each event. The email message may contain information about one or more events such as the event type or the source of the event . Events that pass through filter are provided to scripting consumer which executes a script that may perform a function and or generate a script output .

Although the example of illustrates four filters and and associated consumers and respectively that receive events alternate embodiments may include any number of filters and associated consumers. Further the actions performed by consumers and are provided as examples. Alternate consumers may perform any type of action in response to receiving an event.

Each event filter analyzes the event using its own filter criteria block . Next each event filter determines whether the event meets the event filter s criteria block . This determination is performed by each event filter based on the filter criteria for that particular event filter. If the event does not meet the criteria for a particular event filter that event filter discards the event block . However if the event satisfies the criteria for a particular event filter that event filter passes the event to the event consumer that corresponds to the particular event filter block . The event consumer then performs one or more actions based on the event block . For example the actions may include generating an email message or forwarding the event to another system. The procedure of is repeated for each received event.

Correlator applies the received correlation functions to the events and data received from various sources throughout the enterprise. When the conditions of a particular correlation function are satisfied correlator generates an event which is distributed to various event consumers in the enterprise. In one embodiment the event is provided to event consumers that subscribed to receive that particular event.

Procedure then determines whether the state machine is in its final state block . If the state machine is not in its final state the procedure returns to block to again apply the update consumer to the state machine. If the state machine is in its final state the procedure continues to block which deletes the current instance of the state machine. If another correlation function is to be implemented a new instance of the desired state machine is created and executed.

Examples of events include a server crash a user logging into the system or a particular device becoming unavailable. Example data elements include the available disk space the current memory utilization and the number of users logged into particular servers. An example correlation function that correlates two events generates an email message when two different server crashes occur within five second of one another. An example correlation function that correlates an event with data generates an event when a server crashes and the available storage space on the server s hard drive is less than five megabytes. Another example correlation function pages an administrator when the available storage space on a server s hard disk stays below ten megabytes for at least five minutes. Any other selection of events and or data can be combined to create a correlation function based on the desires of an administrator or other user.

As mentioned above a state machine implements a desired correlation function that correlates events and or data. A set of commonly used state machines are provided for use by administrators or other users in defining correlation functions. These commonly used state machines require the administrator to fill in certain parameters but the administrator is not required to understand the programming language used to create the state machine. If the set of commonly used state machines does not include a state machine that performs the desired correlation function a new state machine can be created using the appropriate programming language. The programming language can be any database language or other non procedural language. In a particular embodiment the programming language is SQL.

Each state machine is a class object. One or more instances of a state machine can be implemented simultaneously to monitor different events and data. In a particular enterprise any number of instances of state machines may be operating simultaneously. In one embodiment of the invention SQL is used to query various states in any state machine.

In a particular example the schema for a state machine that detects a specific number of process crashes within a specified time period can be defined as follows.

An administrator wanting to use the correlation function defined by StateA first creates an instance of StateA. The administrator then provides a value for NumCrashes and RemainingTime. Thus the administrator need not understand the complete syntax of the state machine and need not understand the programming language used to define and create the state machine.

After defining the schema for the StateA state machine the transitions for the state machine i.e. the transitions from one state to another are defined by subscribing to various events. Specifically the transition is defined by the updating consumer and the event that causes the transition is defined by the event subscription. These event subscriptions function as the transitions for the state machine. When an appropriate event occurs the state machine transitions to the next state. The state machine transitions are defined by identifying the event that will cause the transition and identifying the action to perform based on the occurrence of the event. The action may include for example generating an email message logging event data to a file or forwarding an event to one or more destinations. The transitions are defined using updating consumer instances.

After defining the transitions for the state machine an updating consumer is used to update the state of the state machine. The updating consumer named update is a class object. One or more instances of the updating consumer can be implemented simultaneously to handle the updating of different state machines. An example updating consumer implementation is illustrated below. Update StateA where ProcessName ThisEvent.ProcessName set NumCrashes NumCrashes 1 In this example the updating consumer updates an instance of state machine StateA defined above. The ProcessName property is defined as ThisEvent.ProcessName which inserts the name of the process that crashed which is identified in the received crash event as ThisEvent . The property NumCrashes is incremented by one each time a crash event is received.

While a particular state machine is operating the various internal states of the state machine can be obtained e.g. queried . This allows an administrator or other user to observe the correlation as the various events occur in a system. Even if the conditions have not yet been met to generate the appropriate event the administrator can observe the current state or value of different properties e.g. how many crashes have occurred or how much time is left before the state machine is reset . The ability to observe the various states and properties of the state machine assists with troubleshooting and determining whether the desired correlation function has been properly established.

Various examples have been discussed herein in which two different events are correlated with one another or an event is correlated with data. However in alternate embodiments any number of events can be combined together to form a correlation function. Similarly any number of events can be combined with one or more data elements to create a correlation function.

The following example illustrates classes and class instances a correlation scenario updating consumers filters and bindings as used with the present invention. Example class and instances of the class 

The systems discussed above provide various state machines and other tools to correlate events and or data. The use of templates discussed below provide another tool that allows a user to create a parameterized scenario for the benefit of many other users. Once a template is created many users can utilize the template by simply specifying the appropriate parameter values. As used herein a template creator is an individual that creates one or more templates that are used by one or more template users . The templates created using the template description language described herein can be used to create a state machine for a correlation scenario.

A template provider is at the core of the implementation of templates. In a particular embodiment the template provider is a WMI Instance Provider. The template provider was developed to help administrators handle complex updating of consumer scenarios.

Each time a template user creates an instance of a template class discussed below the template provider creates a group of other instances referred to as target objects which are specified by the template creator at the time the template is created. The values in the target objects are parameterized by the values of the instance of the template class these values are provided by the template user . This process is referred to as instantiation. When an instance of a template is deleted the template provider automatically deletes all of the target objects that were created when the template instance was created.

If a failure occurs during the instantiation of the template class the error is reported to the template user block . If the template instance is created without error the template user is then able to utilize the new instance of the template class block . Additionally other users may utilize the new instance of the template class or may create another instance of the same template class using the procedures discussed above.

As mentioned above with respect to the first step in creating a template is the creation of a class that will store template parameters. This class is referred to as a template class and its properties are referred to as template arguments. An instance of the template class will be referred to as a template instance. The template class is created by the designer of the template and is designated as provided by the template provider described below . For instance the following is a valid template class 

The Active property allows a template instance to exist but not the objects that the template instantiates. This is useful for storing template instances that will be activated at a later time.

Template instantiation can occur when a template instance is created or modified. Template instantiation will take place if the template class does not inherit from MSFT TemplateBase or the template class does inherit from MSFT TemplateBase and the active property is True . When a template instance is modified e.g. one or more of its template arguments have changed then only target objects that change will be re instantiated. If the template instance is deleted then all target objects that it owns will be deleted as well.

The next step in creating a template is specifying what lower level objects need to be created when a user creates an instance of the template. This is done by creating instances of the TemplateBuilder class one for each instance that the template creator wants created whenever a template user creates an instance of the template class. The following is an example of the TemplateBuilder class.

In the above example Name is a unique name for this object within the context of this template. Template is the name of the template class for which this template builder is specified. Target is an embedded object that will be instantiated PutInstance will be called with it as an argument . ControllingProperty optional makes instantiation of the builder be dependent on a template argument. If the ControllingProperty property is specified then on instantiation the template provider will observe the template argument named by the property. If the value of this property is NULL or if the property is a boolean type and its value is false then the builder will not be instantiated. NamespaceProperty optional is the name of a property on the template object. At instantiation time the value of the NamespaceProperty specifies the namespace in which the target will be instantiated. Order optional identifies the order in which the template provider instantiates TemplateBuilders. The Order value is an integer that specifies that all builder objects having an Order X will be instantiated before builder objects having an Order Y where X

If the instance to be created by the builder is not parameterized by any template arguments TemplateObject is simply the instance to be created without any special qualifiers. An example TemplateObject is 

To support more complex string substitutions extension functions can be placed in the substitution string. More complex substitutions arise when dealing with substitutions involving SQL queries. Two extension functions supported by the template provider are 

The ConditionalSubstitution extension function allows String to be substituted if the template instance property specified by Identifier is not null. This is useful for templates that form SQL queries which may or may not have a where clause. The conditional substitution in this example would be the WHERE keyword. Using the original example this might look like . . .

The PrefixedWhereSubstitution extension function allows the property references of a VALID where clause of a SQL query to be prefixed with the value of Identifier. The TemplateQueryPropldentifier refers to a template parameter having a valid where clause as its value. A valid where clause is the substring of a valid SQL statement after the where keyword. An example of the PrefixedWhere substitution would convert the clause A 1 and B 2 or C 3 to MyIdentifier.A 1 and MyIdentifier.B 2 or MyIdentifier.C 3 . If WatchScopeExpr in the preceding example template class had a value of A 1 and B 2 or C 3 then 

When using both qualifiers key properties of the target objects created by other builders of the template can be referenced using the BUILDER.. syntax. RELPATH is a valid keyname. This allows one to use key properties of instantiated targets that are keyholed when creating other target objects.

It should be noted that there is nothing preventing the TemplateObject embedded object property of the TemplateBuilder from being yet another Template. This allows templates to be nested within other templates.

A Template instance can be associated with the instances that the Template Builder objects create on instantiation and vice versa. This association is defined as follows 

The template provider impersonates the client of its methods. This ensures that actions that are performed by the template provider such as instance creation will be done using the identity of the caller.

The template provider returns complex error information when creating template instances. This information is provided in the form of a COM Error object. The error object implements IWbemClassObject and its definition looks like 

As discussed above template functionality is independent of the updating consumer functionality. There are however two important advantages with using WMI Templates when constructing low level correlation scenarios. These advantages are 

There are different ways in which templates can be used with WMI Event Correlation such as Correlation Helper Templates and Correlation Scenario Templates.

A template can be used to parameterize a particular aspect of a correlation scenario. In this role the template does not define a complete correlation scenario. A distinguishing characteristic of this type of template is that it does not define any correlation state. Although this type of template is referred to as a correlation helper template it can be used in situations other than event correlation situations.

An example of a correlation helper template is one that handles the instantiation of EventFilter and FilterToConsumerBinding instances given a consumer ref and filter query string.

A correlation scenario template is one that encapsulates a specific correlation scenario. Unlike a correlation helper template a correlation scenario template is autonomous. It maintains its own correlation state and is comprised of correlation primitives correlation helper templates and even other correlation scenario templates. A desirable feature of the correlation scenario templates is that they can act as building blocks that a high level user e.g. a system administrator can assemble to create a larger more complex correlation scenario template. In order to realize this goal correlation scenario templates must be designed with well defined characteristics that allow them to be combined in many often unpredictable ways.

There are a few guidelines for developing helper correlation templates. Theses guidelines consist of a set of qualifiers that can aid tools that support instantiation of helper correlation templates. Since correlation template instantiation will mostly be instantiated by correlation scenario templates these qualifiers shown below in Table 2 will most likely be used for correlation scenario template design.

A domain expression is one that restricts the domain of the template input. An example of a domain expression might be Name Foo . This domain expression tells the template to only consider instances having a scenario property of Foo . A condition expression is one that identifies a particular condition of the template input that is of interest to the template. An example of this might be a template which performs actions on transition into a True and False state. The condition describing the True state is specified by a condition expression. The template can then automatically determine the False state by performing a NOT condition expression . The distinction between a domain expression and a condition expression allows efficient filtering to be performed by the correlation template.

For example imagine that there was only one expression passed to the template described above. Name Foo OR Name Bar AND Prop1 50 Here the domain expression would normally be Name Foo OR Name Bar and the condition expression would be Prop1 50. The implementation of the template is interested when Prop1 goes below 50 as well so it could perform the action that corresponds to the FALSE state. A template could do this through an event filter expression such as Select from InstanceModificationEvent where TargetInstance ISA MyClass AND NOT PropScopeExpr But this means that the updating consumers subscribed to this event will be indicated for instances that do not have a name Foo or Bar . The correct way to issue this query would be to split the domain and condition expressions and form a filter such as Select from InstanceModificationEvent where TargetInstance ISA MyClass AND ScopeExpr AND NOT PropExpr Correlation Helper Template Example

Correlation scenario templates parameterize correlation scenarios. Thus correlation scenario templates should follow all the guidelines for designing scenarios using correlation primitives. They should also follow the guidelines for designing helper correlation templates. Design guidelines for correlation scenario templates impose even more structure than helper correlation template design so that templates can be easily composed. There are two categories of correlation scenario templates. These are ones that use events as their input event based and ones that use a data set as their input data based .

Event based correlation scenario templates allow for the correlation of events. With event driven scenarios users are concerned with things such as how often an event occurs if the event has occurred within a certain amount of time etc. An important characteristic of event driven correlation scenario templates is that they typically do not need to be initialized. An event occurs and its action is taken immediately or soon thereafter . Typically the user is unable to discover the state of the inputs to this scenario since events occur instantaneously and cannot be reviewed at some later time.

Although all correlation actions are taken as a result of some event such as a WMI event the input to a certain class of correlation scenario templates is better described by a data set description. Also since data exists in the real world part of the correlation scenario template implementation is concerned with going out and discovering the current state of the data. A data driven correlation scenario template is concerned with things such as whether A met a particular condition for 5 minutes or what is the trend of A etc. There are two subtypes of data based correlation scenario templates property based and condition based.

Property based correlation scenario templates are concerned with a specified property of the data set. This means that the scenario will maintain some state that is related to the value of the specified property. Examples of this type of scenario are trend or average correlation templates. These scenarios would be concerned with keeping the average or trend of a specified property. Property based correlation scenario templates usually require the property be of a certain type. For example the trend or average updating consumer scenario would require the property to be one of the numeric types.

A condition based correlation scenario template is concerned with watching a specified condition. This means that the scenario will keep some state that is based on the truth value of the condition over the specified data set. Examples of this type of scenario is seeing if a certain condition holds over each element of the data set for a specified amount of time if a certain condition holds for a specified number of elements of the data set at any given time etc.

Correlation scenario templates formally declare their input and output using class level qualifiers. The following table describes examples of these class level qualifiers.

Correlation Scenario templates also define one or more property level qualifiers that can appear on a template class property. This property is called the correlation Id property. A Correlation Id is the unique id of the state instances of a correlation scenario. This id is usually determined from the id of the data or the events that the state instances represent. The correlation Id property is the name of the property of the data or event that has a value that can be used as the correlation Id. The name of this property as input to a correlation scenario template helps the template implementation derive a unique id for the correlation state instances. For correlation scenario templates having multiple instances per scenario this id will typically be the relative pathname of the data instance it represents. Some scenarios have only a single instance per scenario. In these cases the correlation Id will most likely be the class name of the data instance s it is representing.

An important point about correlation Ids is that the they need to be the id of the real world data instance it represents. In the cases where there is a single correlation scenario template having state representing real world data instances this previous statement is obvious. However when correlation scenario templates have state that represents the data instances of other correlation scenario templates known as layered correlation scenario templates the correlation Ids must be that of the original real world data instances not of the immediate correlation data instances. In other words the Id of the real world data instance must be propagated when layering correlation scenario templates. This rule allows correlation templates to be combined later using joining correlation scenario templates.

The bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is stored in ROM . Computer further includes a hard disk drive for reading from and writing to a hard disk not shown connected to bus via a hard disk drive interface e.g. a SCSI ATA or other type of interface a magnetic disk drive for reading from and writing to a removable magnetic disk connected to bus via a magnetic disk drive interface and an optical disk drive for reading from and or writing to a removable optical disk such as a CD ROM DVD or other optical media connected to bus via an optical drive interface . The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for computer . Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it will be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards random access memories RAMs read only memories ROM and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into computer through input devices such as keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to the processing unit through an interface that is coupled to the system bus e.g. a serial port interface a parallel port interface a universal serial bus USB interface etc. . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor personal computers typically include other peripheral output devices not shown such as speakers and printers.

Computer operates in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. In certain embodiments computer executes an Internet Web browser program which may optionally be integrated into the operating system such as the Internet Explorer Web browser manufactured and distributed by Microsoft Corporation of Redmond Wash.

When used in a LAN networking environment computer is connected to the local network through a network interface or adapter . When used in a WAN networking environment computer typically includes a modem or other means for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via a serial port interface . In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Computer typically includes at least some form of computer readable media. Computer readable media can be any available media that can be accessed by computer . By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other media which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The invention has been described in part in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

Although the description above uses language that is specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the invention.

