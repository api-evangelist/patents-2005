---

title: Recognizing event patterns from event streams
abstract: System and method for identifying a pattern. A method of the invention compiles a pattern description where the pattern description defines a series of a first event and a second event relating to the first event. The first event is received and includes a type parameter data, a time parameter data, and a substance parameter data. A system of the invention includes a script component for associating or attaching a first script to the first event. The first script defines the type, time, and substance parameters of the second event as a function of the parameters of the first event according to the pattern description. A pattern recognition engine executes the attached first script and the executed script identifies the second event and thereby identifies the pattern.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07627544&OS=07627544&RS=07627544
owner: Microsoft Corporation
number: 07627544
owner_city: Redmond
owner_country: US
publication_date: 20050520
---
Embodiments of the present invention relate to the field of event stream processing. In particular embodiments of this invention relate to identifying a pattern in a plurality of events.

Business enterprises use computer systems with applications to monitor and process business activities and transactions. For example an online store selling purses may use a business application to receive online sales orders an inventory application to manage the purses in the inventory and communicate with the supplier or other applications or services to create online interfaces. Business entities handling complex transactions and activities may employ distributed computer systems. For example financial institutions which handle credit card and ATM transactions may receive thousands of transactions every ten minutes.

Each of the various activities or transactions may be treated as a single event by business applications or software. For example in the online purse boutique store a user login session may be treated as an event and a consumer swiping her credit card at a shopping mall may be treated as another event by the financial institutions. While each single event may be significant analysis of each single event may not be beneficial. Instead business entities or other organizations may be interested in occurrences of multiple events according to a specific pattern. Such accumulated information from the specific pattern represents a higher level event and is beneficial and meaningful for further analysis.

For example single events such as a user s login session of an online store placing an item in her shopping cart or the like may be trivial. However the online store may be interested in a specific pattern of 1 user login 2 place item to the shopping cart 3 proceed to check out and 4 no further action from the user. Such pattern may indicate that the user has abandoned her shopping cart because a she is not pleased with the shipping and handling charges b she decides to compare prices of the item before purchasing c the user clicks the Purchase button but the handling server did not receive the request or other reasons.

Current systems process events and attempt to match events to particular interested patterns. For example in identifying the abandoning of the shopping cart pattern the online store may design an application to identify a given sequence of events such as 1 user login 2 shopping cart update 3 checkout and followed by no action from the user in the next ten minutes. However such pattern matching requires the online store to ask a software programmer to customize the application to handle the abandoning of the shopping cart pattern. In other systems pattern matching is accomplished as a hindsight process by performing analysis during offline period and or only after data from events is stored in a database or data warehouse.

These systems lack generic pattern recognition implementation to efficiently identify any given patterns from a series of events. In addition customized codes or routines require existing systems to process correlation of event data and evaluation of patterns together. For example in identifying a pattern the existing systems wait for the occurrences of events to correlate data from events before determining whether a pattern has occurred. When a new pattern is to be evaluated a new set of customized routines are needed to configure the existing system to evaluate the pattern.

Accordingly a system and method for identifying a pattern in a plurality of events by monitoring incoming events and correlating monitored events are desired to address one or more of these and other disadvantages and shortcomings.

Embodiments of the present invention overcome shortcomings of the known systems by compiling a pattern description to define a series of events. A script or a set of executable code is attached or associated with each event and the script defines data parameters to correlate the events according to the pattern description. Embodiments of the invention execute script of each event to determine whether the event matches a particular pattern.

According to one aspect of the invention a method identifies a pattern in a series of events. The method compiles a pattern description. The pattern description defines a series of a first event and a second event relating to the first event. The first event is received and the first event includes a type parameter data a time parameter data and a substance parameter data. The method also attaches a first script to the first event. The first script defines type time and substance parameters of the second event as a function of the parameters of the first event according to the pattern description. The attached first script of the first event is executed. The executed script identifies the second event and thereby identifies the pattern.

According to another aspect of the invention one or more computer readable media having computer executable components identify event patterns. A pattern compiling component compiles a plurality of pattern descriptions. Each of the pattern descriptions defines a series of events in a sequence. An event component collects a plurality of events. Each of the plurality of events has data parameters relating to each of the plurality of events. A script component associates a script to each of the plurality of events. The script defines data parameters of a subsequent event in the series of each of the plurality of events according to the pattern description of each of the plurality of events. A pattern recognition engine executes the script of each of the plurality of events to identify the subsequent event in the series and thereby identify the pattern.

In accordance with a further aspect of the invention a system identifies a pattern in a plurality of events. A plurality of collecting computers collects related events as a series of pattern events. A first set of computers identifies a first portion of the pattern in each collected series. Each of the collected series matches the first portion of the series of pattern events. A second set of computers identifies a second portion of the pattern in each series in which the first portion of the pattern has been identified by the first set. The first portion of the pattern and the second portion of the pattern match the series of pattern events. Each series of events including the first and second portions of the pattern is accumulated and stored for evaluation.

Appendix A describes exemplary algorithms for implementing a method of one embodiment of the invention.

Referring first of a block diagram illustrates a system for identifying a pattern in a series of events according to one embodiment of the invention. For example the system includes a computing device not shown in such as the computer in including a computer server a collection of computing devices linked by a common communication network such as an internet an intranet or the like or other computing system that is capable of executing a plurality of pattern recognition engines and a script component . The system includes an event component for receiving a plurality of events . The event component may include a user interface UI or an application programming interface API that receives a plurality of events from an event source. Using the above online store as an example the event component may receive events as event streams from a web server that receives user login sessions or the like. In the ATM example the event component may receive the ATM transactions from ATM machines and the common communication network. The events include occurrences of discrete steps of activities such as ATM transactions user login or interaction with a commercial web site a user login session with a secured network or the like. On the other hand a non occurrence of an activity may be represented by an event which is missing in the events .

The system also includes a pattern compiling component responsive to compiling a pattern description which defines a series of events in a sequence. For example in the abandoning of the shopping cart example above the pattern description may define the pattern as 1 user login 2 place item in the shopping cart 3 checkout and 4 no completion of the purchase of item s in the shopping cart in ten minutes. As another illustration of the pattern a pattern description of an ATM fraud may define a series of automatic teller machine ATM transactions as 1 a first attempt to make an ATM transaction in location A by a customer s ATM card and 2 a second attempt to make another ATM transaction with the same card in different location B within ten minutes of the first attempt.

Another example of the pattern description is to identify theft or shoplifting at a hardware store. For example items in a hardware store may be marked with a radio frequency identification RFID tag which contains information relating to the items such as item number item serial number per unit price or other metrics information of the item. An RFID tag reader at a checkout counter emits radio signals to scan the presence of the RFID tags in the hardware store to register the items that are being purchased by the customer. Another RFID tag reader is also located at the exit of the hardware store to monitor the items as they leave the store. An interesting pattern in this situation is the hardware store s system indicates that the RFID tag reader at the exit scans an item s RFID tag showing that the tag has not been scanned at the checkout counter. Such a pattern i.e. no checkout scan may indicate a possible theft or shoplift.

A further pattern description example may be illustrated by a hacker attack pattern where 1 a successful virtual private network VPN login session is recorded 2 no attempt to log in to a domain is recorded and 3 a failure or success attempt to log in with the Telnet using the same IP address is recorded. Such pattern of events indicates that the domain is under a hacker attack or someone is attempting to access the domain without using the necessary client component.

According to one embodiment of the invention every event pattern can be decomposed in several pieces of information illustrated in Table 1 

Embodiments of the present invention instead of analyzing data relating to events after they are being stored in data warehouse watch or monitor the streams of events and evaluate the events in real time to determine the patterns which indicate meaningful or useful information.

Referring again to to achieve this the system includes a script component that compiles the pattern description into set of small scripts where each script describes the reaction on individual event type that may occur in the events . The script includes executable codes expressions routines functions conditions or algorithms for indicating how to handle a particular event in order to find the next event in the pattern description. The script defines parameters of the next event as a function of the parameters of the particular event. Table 2 shows examples of operations included in the script.

Returning to events with associated or attached scripts are forwarded to a plurality of pattern recognition engines for execution. For example as illustrated in Table 2 the associated script of each of the events includes various operations and the pattern recognition engines which execute the script. In one example the pattern recognition engines and N are individual instances of the pattern recognition engine .

The script includes one or more operations for the pattern recognition engine to process according to the pattern description. For example the script includes parts such as next event conditions and data accumulation logic . As illustrated in Table 2 the script attached or associated with each event indicates how to process subsequent events according to the pattern description to be discussed in further details in . Also shown in an instance of the PRE is a generic script interpreter to execute the script and contains the recognition state for individual pattern instance. For example the PRE may be an executable module in the system that performs execution of the script such that the PRE receives the script at a process event handle processes the next event conditions at pattern event expectations stores pattern instance data and exposes properties according to the script at Status Wakeup JoinEvents and GetData . For example in the online shopping cart example after an Login event the PRE executes the script and updates the status as Waiting i.e. waiting for the subsequent event . The PRE also outputs the Wakeup time of 10 05 20 to monitor the status . The JoinEvents or GetHash describes the parameter data that needs to be correlated in the subsequent event and GetData allows the external environment to retrieve the data accumulated so far. To allow the support for time restrictions and patterns based on event non occurrence the PRE also exposes the method OnWakeup which may change the status similar to merging a new event.

In other words the PRE may be a set of computer executable instructions that performs interpreting and executing the script which may include one or more operations or routines according to the pattern description. As such embodiments of the present invention through the implementations of the script and the PRE are versatile in adapting to processing events and evaluating patterns of different conditions and parameters because the PRE relies on an external environment e.g. the script and the event to process relevant events and scripts . The advantages of the embodiments of the invention at least eliminate the need for customized code or pattern processing for different users and different events because regardless of the types of events or types of patterns each user is interested in the system compiles the pattern description associates the script that meets each user s needs so instances of the PRE may execute the script to determine the occurrence of the pattern.

In one embodiment a host environment including a computer a computing system a server a plurality of servers or other automated event receiving processes or applications provide the pattern description and or the script for each event.

In another embodiment the PRE may be implemented as a small C class programming language which may be implemented as user data type UDT or other programming languages models or the like. The small C class may be responsible for holding the state of recognition of one individual instance of the pattern. The state may include the expected events and timeouts and the data accumulated from the events or other data according to the script . In this embodiment the event may be passed to the PRE also a C class UDT containing the event type the timestamp when the event happened e.g. from the machine in which it happened and some data relating to the substance of the event . In one implementation of embodiments of the invention the event is passed to the PRE through the routine OnEvent.

As an illustration the abandoning of the shopping cart pattern is described in . illustrates evaluation of a pattern with a pattern description defining the pattern as a series of events E E E E where E stands for Login E stands for ItemAdded E stands for Checkout and E stands for non occurrence of the event Pay. If there is a series of events that contain these four events the series may indicate that the user has abandoned her shopping cart. An event source shows that events EV EV EV are currently waiting to be processed. Initially the event EV indicates that it is the event type Login with an event time of 10 00 00 and an event substance data of SessionID 589043543 State WA and City Redmond. The script attached to the event EV includes the following operations to process the event EV a an event type ItemAdded is to be expected within five minutes b correlate this event with the event type ItemAdded based on SessionID and c set data provided by the event EV .

The event EV is passed to the PRE which executes the attached script of the event EV . For example after executing the script the PRE indicates that an event type of ItemAdded needs to occur before an event time of 10 05 20. The PRE also needs to correlate the SessionID data of the EV with the ItemAdded event so that they belong to the same series i.e. the same user and a given login session . In other words the script of the event EV defines the type time and substance parameters of the next or expected event as a function of the parameters of the event EV according to the pattern description. It is to be understood that other identifying data among the events may be used so as to correlate data among the events during execution of the script.

In one embodiment the Login script for the event EV is an activating event which indicates that it is the first event in a series. As such a snap shot of the execution of the script by the PRE shows that the event EV is the first event in a series A because the EV is the first of the defined pattern e.g. the Login event . Also the status of the series A is Waiting because the script indicates that an event ItemAdded is expected to occur by the same user under the same SessionID. Alternatively if the event ItemAdded does not occur in the time required by the script of the EV the series A is discarded because the events no longer match the defined pattern description. That is the operation WakeUp in the script indicates the PRE is to update the status of the series A to determine if the expected event has occurred. The GetHash 0 called on the PRE will now return the hash of the SessionID.

Referring now to a new event EV is received from event source and the event type is ItemAdded with an event time of 10 00 20 and the SessionID is also 589043543. As the parameter data of the event EV corresponds to the expected event defined by the script of the event EV it is determined that the event EV belongs to the same series A as the event EV. For example in determining that the event EV belongs to the same series A as the event EV it may be achieved by finding the proper PRE instance based on hash and invoking the instance of PRE with the script for ItemAdded which may ignore the event EV if it does not match exactly. Here the snapshot of the pattern recognition processing shows what happens when the event EV belongs to the series A. In this case the script associated with the event EV defines the next or expected event and the PRE executes the script accordingly. For example the script of the event EV indicates that another ItemAdded event may occur within the next 5 minutes the checkout time is to be determined and SessionID is used to correlate data with the next event. After execution the PRE shows the parameter data of the next event in the series A. For example another ItemAdded event can occur before 10 05 20 i.e. 10 00 20 5 minutes and if the Checkout event does not occur before 10 05 20 the series A does not match the abandoning of the shopping cart pattern according to the pattern description.

Referring now to a new event EV is received from the event source with the following parameter data event type Login event time 10 02 31 and SessionID 589077625. In one example the script for Login indicates that this is an activating event the event EV is determined to start a new series B because the SessionID does not match that of the events EV and EV . As such a snapshot indicates that the event EV is the first event in the series B. Also note that the script of the event EV defines a next event e.g. ItemAdded to occur before 10 07 31 or the like and a new instance of the PRE executes the script of the event EV .

Referring next to another event EV is received with an event type of Checkout an event time of 10 02 40 and a SessionID of 589043543. The parameter data of this event EV matches the parameter data defined by the script of the event EV . As such a snapshot shows that the event EV belongs to the series A and it is the third event in the series A. The script of the event EV indicates that a Pay event is not expected in the next five minutes. As such the PRE executes the script of the event EV and indicates that the Pay event must not occur before 10 07 40. Otherwise the status of the series A is set to indicate that the series A does not match the pattern of abandoning of the shopping cart. 

Referring to the timeout that was set for Pay results in exposing the time 10 07 40 via the WakeupTime property. In addition the PRE remembers that if this timeout occurs the new status should be Match as no more events are expected for the pattern. For example a host environment e.g. the host environment that manages large number of PRE instances may keep a sorted list or an index based on WakeupTime. The index may be used to find all instances that need to be woken up. For example at 10 08 it may be determined that the method OnWakeup of the PRE instance needs to be called. When this happens the PRE instance sets its Status to Match which indicates to the host environment that the pattern of abandoning of the shopping cart is matched.

In one embodiment the PRE exposes the state of the event series and the data relating to the pattern to the host environment for analysis of the event series and the pattern. As an example such hosting environment can keep Hashtables based on GetHash and sorted list based on WakeupTime both pointing to sets of PRE instances. This in memory host environment may output the matched patterns as output events. The in memory host environment keeps multiple instances of the engine in its storage such as volatile non volatile or a combination of volatile and non volatile memory and delivers the incoming events and script operations e.g. wakeup notifications to the proper engine instances. The in memory host environment also discards the irrelevant events and or the PRE having status as NoMatch. 

In a file based host environment parameter data of the event series and the data relating to the pattern may be organized by serializing all instances of the PRE in a collection of files or a file to allow recovery of the accumulated state in case of crash of the host environment the PRE or a combination thereof.

Another implementation of a host environment may be an SQL based host environment which implements the PRE as a UDT User Data Type new feature of SQL so that script operations e.g. timeout notifications and large number of input events are efficiently delivered to large number of waiting instances of the PRE using indexes on the properties accessible to the PRE . The SQL based host environment may include a data view of the incoming events or the event streams by promoting some or all of the data from the PRE into SQL columns so that all the instances of event composition are visible and may be queried as a table to be discussed in . In another example the table or data structure storing the matched pattern events may be partitioned.

It is to be understood that other patterns may be evaluated and identified to meet the user s interest and additional examples or applications of the embodiments of the invention may be employed with departing from the scope of the present invention.

Referring now to a diagram illustrates a data structure for storing data relating to a pattern according to one embodiment of the invention. An event data structure stores events in a table . A script operation table includes the pattern description with the script operation for each of the events to be identified. In one implementation events are stored as UDTs in the table . The table may include columns for the Event Type and the Hash of the join criteria to join events. For example for an online shopping event the event type may be Login Checkout ItemAdded or the like and the hash may be based on the SessionID. In one embodiment the columns in the table may be included as a clustered index so as to optimize the physical storage of the table in disk sectors of the memory of computing systems such as the computer of .

Deploying a new pattern type into such hosting environment may be achieved by inserting rows into table that contain the scripts for the operations to be executed for each of the event types. Initially the table may be empty and as one ore more events are received from the event stream or event source rows of the table begin to fill with data relating to the events. The event table and the script operation table are correlated to the pattern table where the patterns are evaluated and identified. The pattern table includes information derived from the event table the script operation table and executed script information from the PRE. In one implementation of the pattern table a SQL statement may define the pattern table as 

In one embodiment the pattern table is sorted and organized by pattern types . For example as shown in the pattern table a pattern P is indexed above a pattern P. Also as illustrated the pattern P includes one or more pattern instances as shown by rows within pattern P where each row for each pattern instance indicates the pattern is waiting or expecting additional events. In addition to the index or sorting of pattern types one embodiment of the invention organizes the pattern table by indexing the status column and the wakeup column .

Therefore as rows of new events are created in the event table and the corresponding script operation table instances of PRE execute the script according to the script operation table to identify subsequent events in the series of pattern events to be evaluated. As such embodiments of the invention implement an algorithm to independently identify each pattern in parallel. In other words one instance of the PRE may execute the script associated with events to evaluate the pattern P while another instance the PRE may execute the script associated with events to evaluate the pattern P. Appendix B illustrates exemplary implementation of the algorithm and illustrate an exemplary method derived from the algorithm.

A first set of computers next identifies a first portion of the pattern in each collected series. Each of the collected series matches the first portion of the series of pattern events. For example a computer may be configured to evaluate patterns P P and P while a computer may be configured to evaluate or identify patterns P and P . These patterns P P may be regarded as events by a second set of computers . Hence the second set of computers receives the events i.e. patterns P P from the first set to identify a second portion of the pattern in each series. As such the first portion of the pattern identified by the first set and the second portion of the pattern identified by the second set are accumulated and stored for evaluation. In other words the first set may be regarded or treated as the collecting computers for the second set . As shown in a computer of the second set receives as events from both the computers and of the first set. On the other hand a computer in the second set receives as events from the computer of the first set and from a computer of the plurality of collecting computers .

According another embodiment of the invention one or more hosting environments described may be a part of a distributed infrastructure for pattern matching on event streams so that some nodes e.g. hosting environments may b in memory compositions of hosting environments some may be file based while others may be SQL based hosting environments. In addition there may be scenarios in which some other processing is performed on the event streams between the compositions. Examples of such processing may include executing custom code business rules or transformations on the event streams.

As the matched patterns are evaluated by the first set and the second set of computers data from the matched pattern and or parameter data of the pattern events may be outputted to a host environment e.g. SQL based host environment or to a workflow business process analysis host environment for further processing of the matched pattern.

Referring now to flow charts illustrating a method for identifying a pattern in a series of events implemented by a hosting environment according to one embodiment of the invention. In one embodiment exemplary algorithms in Appendix A describes one implementation for identifying a pattern in a series of events. Initially when a new event is received at it is immediately or substantially immediately associated with a script at based on the event type. At different paths may be taken to determine whether the event should activate a new series. For example as described in a Login event is an activating event because it is the first event in the series. If the event is activating a new series is created at and is added to the set of series that are waiting for events at . For example in an in memory hosting environment this may be creating of a new PRE instance and registering it in a hashtable and a sorted list on wakeup time. In another embodiment where an SQL based hosting environment is implemented the SQL based hosting environment may insert the PRE instance as UDT into the Patterns table. It next proceeds to receive one or more events at .

If the script is not activating the series that may be possibly interested in this event are to be processed at . For example this may be achieved by first calling the OnEvent method of the PRE instance and passing the incoming event with the attached script. The PRE performs the next two operations at by evaluating the pattern description. It is important to note that matching of the hash value does not necessarily mean that the correlation condition is satisfied. For example suppose the hash was for some string that is to be used for correlation according to the pattern description like social security number or name. As such the PRE computes the actual pattern description against the data of the incoming event and the state accumulated in the series so far. If the evaluation of the pattern description is negative the event is ignored for the series.

If the evaluation is positive at the event is merged into the PRE. As a result of merging the event with the accumulated state the status of the PRE instance may be changed or updated. For example if a Pay event was received for the given SessionID the status changes to No Match . At based on the status the hosting environment determines what to do with this series. If the status is Match e.g. a series of events has matched a pattern the series is considered successfully complete and the series may be removed from the set of waiting instances and the accumulated data is sent as composite event at . Alternatively the matched series may be kept for queries and analysis in another table as illustrated in .

If the status is No Match the series may be discarded or ignored at . At if the status is Waiting the series is left to wait for more events by proceeding to .

In another embodiment of the invention the event may not merge with any existing series or start a new series but a copy or a clone of the series may be created before . As such both a related or subsequent event and the cloned copy of the series are processed. As an illustration suppose a pattern description P defines the following three events 

Events A B and C where the x value of event A is equal to the x value of event B and the y value of event B is equal to the y value of event C.

In identifying the events A B C initially an event ev is received where the x value is 1 and does not have a y value. Based on the pattern description the event ev is an activating event because it only includes an x value without an y value. As such the event evil starts a new pattern series S. A second event ev is received and includes an x value of 1 and an y value of 2. The pattern series S would identify the event ev as an event in the pattern P because the both x values of the events ev and ev are the same.

On the other hand if there is an incoming event ev that includes an x value of 1 and an y value of 3 the pattern series S would ignore the event ev because it is not a related or a subsequent event that is event C that has an y value that is equal to the y value of B i.e. ev .

Advantageously in this embodiment the present invention clones or copies the series S which includes event ev such that there are two copies of the series one copy is the original copy of the series S and the other copy will be used in a new series S. As such the series S would have the event ev in the series. On the other hand the new series S has the events ev and ev. With this implementation when the incoming event event ev is received both the series S and S will evaluate and identify whether the event ev may match the pattern P. The series S would include the event ev because the x value of the event ev is equal to the x value of the ev. The series S however would ignore the event ev because the y value of the event ev is not equal to that of the event ev. Next suppose a new event ev is received with only an y value of 3. In this situation the series S and S will evaluate the pattern description. With the cloned or copied series the series S identifies the event ev as the event C and there is a matched pattern. On the other hand the series S would not identify the event ev as the event C. If there is no cloned series S or cloned event ev the pattern would not be matched because the event ev B x 1 y 2 would be identified by the original series S and the event ev would be ignored by the original series S because it would only expect the event C according to the pattern description. This cloning is necessary because another more relevant match may occur in the future.

According to the embodiment described above the compilation of the pattern description and attaching of the event scripts determine whether cloning of the existing series may take place. For example when the series is waiting for non occurrence such as the event Pay in the shopping cart example this type of event must be directly merged with no cloning because the pattern description is to terminate the series. If on the other hand we are merging some event like the event B above which includes the additional relationship or condition with the event C the pattern description would require cloning of the series because it may take one series to identify the pattern.

In another embodiment where series of events are waiting for an occurrence of an event the waiting series may also be modified based on timer as illustrated in . For example at a time period is calculated by a timer by keeping a timestamp of the last event from the event source. Alternatively the event source may send signals on fixed intervals which will cause the algorithms described in Appendix A or Appendix B to execute. At for each series that is waiting for a later event i.e. Wakeup time

It is important to note that the methods illustrated in and the corresponding algorithms described in Appendix A are exemplary and may be implemented in any order. For example when PRE is used inside an SQL based hosting environment millions of instances may be affected with a single operation e.g. UPDATE operation during which each instance of PRE may be executed in parallel with other PRE instances.

The computer typically has at least some form of computer readable media. Computer readable media which include both volatile and nonvolatile media removable and non removable media may be any available medium that may be accessed by computer . By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that may be used to store the desired information and that may be accessed by computer . Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Those skilled in the art are familiar with the modulated data signal which has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media are examples of communication media. Combinations of any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of removable and or non removable volatile and or nonvolatile memory. In the illustrated embodiment system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. For example illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media. also shows a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that may be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive and magnetic disk drive and optical disk drive are typically connected to the system bus by a non volatile memory interface such as interface .

The drives or other mass storage devices and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components may either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into computer through input devices or user interface selection devices such as a keyboard and a pointing device e.g. a mouse trackball pen or touch pad . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to processing unit through a user input interface that is coupled to system bus but may be connected by other interface and bus structures such as a parallel port game port or a Universal Serial Bus USB . A monitor or other type of display device is also connected to system bus via an interface such as a video interface . In addition to the monitor computers often include other peripheral output devices not shown such as a printer and speakers which may be connected through an output peripheral interface not shown .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. LAN and or WAN may be a wired network a wireless network a combination thereof and so on. Such networking environments are commonplace in offices enterprise wide computer networks intranets and global computer networks e.g. the Internet .

When used in a local area networking environment computer is connected to the LAN through a network interface or adapter . When used in a wide area networking environment computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in a remote memory storage device not shown . By way of example and not limitation illustrates remote application programs as residing on the memory device. The network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of computer are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described herein.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized however that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

Although described in connection with an exemplary computing system environment including computer the invention is operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An interface in the context of a software architecture includes a software module component code portion or other sequence of computer executable instructions. The interface includes for example a first module accessing a second module to perform computing tasks on behalf of the first module. The first and second modules include in one example application programming interfaces APIs such as provided by operating systems component object model COM interfaces e.g. for peer to peer application communication and extensible markup language metadata interchange format XMI interfaces e.g. for communication between web services .

The interface may be a tightly coupled synchronous implementation such as in Java 2 Platform Enterprise Edition J2EE COM or distributed COM DCOM examples. Alternatively or in addition the interface may be a loosely coupled asynchronous implementation such as in a web service e.g. using the simple object access protocol . In general the interface includes any combination of the following characteristics tightly coupled loosely coupled synchronous and asynchronous. Further the interface may conform to a standard protocol a proprietary protocol or any combination of standard and proprietary protocols.

The interfaces described herein may all be part of a single interface or may be implemented as separate interfaces or any combination therein. The interfaces may execute locally or remotely to provide functionality. Further the interfaces may include additional or less functionality than illustrated or described herein.

In operation computer one or more computer readable media having computer executable components execute computer executable instructions such as those illustrated in to implement the invention.

The order of execution or performance of the methods illustrated and described herein is not essential unless otherwise specified. That is elements of the methods may be performed in any order unless otherwise specified and that the methods may include more or less elements than those disclosed herein. For example it is contemplated that executing or performing a particular element before contemporaneously with or after another element is within the scope of the invention.

When introducing elements of the present invention or the embodiment s thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

In view of the above it will be seen that the several objects of the invention are achieved and other advantageous results attained.

As various changes could be made in the above systems and methods without departing from the scope of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

Exemplary algorithms for each PatternType P in MergeLogic in parallel according to one embodiment of the invention 

For example the algorithm begins with a loop for each event type in the order or sequence expected by the pattern. For example in the script operation table the pattern description for the pattern P defines the pattern as have event types E E E and the script for the events E E and E evaluates the parameter data. In the script operation table the following variables are defined for each event PatternType EventType IsActivating and Script.

The algorithm determines first if the Event type is activating or is part of one or more existing series of pattern events by providing the following exemplary SQL statement 

In the exemplary implementation above a function InitializePRE is user defined function implemented in C that accepts the activating event and the corresponding script. The function returns a PRE instance with Status Waiting that was initialized with the event data and according to the Script. Note also that the columns in Hash Status and Wakeup in the table are not set in the insert statement they are byproduct of modifying the PRE. This statement can possibly result in thousands of new instances inserted all in a single scan of the Event table and inserting on the clustered index on the Pattern table.

Alternatively if the event type is not Activating all the events are merged into the corresponding patterns with statement like 

Here SQL statement will first estimate the most efficient type of Join. For example when the both tables are huge this will be Merge Join because we are using the same type of index including Hash. Behind the scenes the SQL server will 

Note that here the Hash is used just as heuristics there is small probability that the PRE will ignore the event e.g. on hash collision but different SessionID s. Also there may be cases in which more than one Hash column is needed for example two separate Hash columns for will be needed for patterns like 

For such patterns each the merge logic will also use different type of join for each event type e.g. join on x for e and join on y for e. This means also that two pattern types can share the table only if they have the same number of joins.

In summary this is a single UPDATE statement which will possibly modify thousands out of millions patterns. Some of those patterns may change their status. For example the status will change from Waiting to NoMatch if the Pay event was merged into PRE. The next challenge is how to change the status of the patterns when the change is due to not seeing any events in the given timeout. This timeout evaluation is achieved with another bulk operation on the Patterns table with SQL statement like 

Note that this operation uses the Wakeup Index and thus only the disk sectors containing patterns that have reached timeout are retrieved and updated. There is no chance of Deadlock because this operation is localized to the part of the table for the specific Pattern Type and is not performed simultaneously with the Merge for this Pattern Type.

The last statement assumes for example that Waiting is 0 and Match and NoMatch are 0. As side effect the patterns that are NoMatch are also deleted from the pattern table without being moved anywhere. But this was the idea to weed out the unnecessary events and output only the really useful ones.

Now that we have described the core idea of the correlation into patterns lets step back and look to what shall we do next with this data. There are clearly two very different scenarios 

Send the Matched Patterns into Subscription Routing mechanism such as business activity software applications etc. This way the people or systems interested in the pattern will get notified and can do the corresponding action e.g. activate Workflow for Possible ATM Fraud .

Just have the data available for Queries and Analysis in the usual SQL OLAP BAM sense. This has two sub variations 

Query ability and Analysis of the Matched patterns only e.g. what are the reasons people are leaving the sopping cart is it the shipping price In which state city this problem is causing us the most business losses 

Query ability and Analysis of all instances of the pattern including the ones not yet complete. This is especially critical for long running patterns such as observations about business activities. For example if we have a business that deals with Shipments it is critical to be able to query or get aggregations about the progress of the Shipments that are not yet complete. Imagine trucks carrying items marked with RFID tags for example .

From those options 1 is the easiest just get the matched patterns and send them as Events to the consumers or for further pattern evaluation. Option 2b is the most complex one because our data so far was encapsulated inside the PRE binary blob. . shows how this data is exposed for Query ability. Here the definition of the table is changed like 

Here all the columns needed for Query and Analysis are promoted as actual SQL columns. Promoting them from the UDT will have a little overhead on the CPU but there will be no additional Disk IO. In addition some of the columns may be marked as persisted and even used for indexes to speed up the queries.

Note that when the Query ability is needed it becomes impossible to reuse the same table for many pattern instances on the contrary the table itself is dedicated for specific pattern type does not have PatternType column and is dynamically created based on the pattern definition.

