---

title: System and methods for defining a software build
abstract: A software build framework includes and architecture to identify software components including sets of classes, or objects, and categorizes the objects into layers in the component. A set of build rules identifies allowable dependencies between the component layers among the same and other components in the system, as well as external entities such as off the shelf (OTS) and third party vendor products outside the development control. The build mechanism enumerates a set of dependencies for each of the components, and an enforcer analyzes the dependencies to identify dependencies in violation of the rules. The enforcer separates the compile time and runtime inheritance paths to detect indirect monolithic inheritance. In this manner, dependency rules define an efficient and optimal architecture which lends itself well to modifications, timely builds and deliverable releases, and enforces the dependency rules at compile time so as to avoid generating an obsolete or suspect build.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07640533&OS=07640533&RS=07640533
owner: EMC Corporation
number: 07640533
owner_city: Hopkinton
owner_country: US
publication_date: 20050330
---
A large software development environment relies on many developers or software engineers developing systems including many software elements. Each software element includes multiple objects and is spread across many files. Typically the files include source code or human readable versions of computer instructions and are modifiable by the developers. As is known in the industry the source code is compiled into object code and eventually into executable code which is a set of instructions executable by a processor on the target machine for which the system was developed. The process of transforming the source code to the executable running system is known as a build and involves a series of transformations from source code to executable code.

Software objects in conventional software systems include or inherit methods and attributes from other objects in the system. Inheritance is usually defined in terms of classes which inherit other classes or subclasses resulting in a complex hierarchical or matrix pattern of inheritance often called an inheritance lattice. Inheritance results in a dependency between the objects or classes as changes to a particular class triggers a need to propagate the change to classes which inherit or depend on the changed class. Such dependencies are resolved by a build which recompiles the affected entities to propagate the changes to dependent classes. In a large software system the build can become substantial and a modification to a particular class or object can have a rippling effect which traverses the inheritance lattice defined by the dependencies.

Modern software development methodologies are exhibiting a trend toward so called middleware based implementations. Middleware provides a vendor and platform independent interprocess communication mechanism using generic objects which may be instantiated under one platform or OS and received by another using the underlying mechanism provided by the middleware. A middleware based application may be ported or rebuilt simply by rebuilding on another middleware platform without modifying non middleware aspects.

One popular middleware implementation is CORBA. CORBA is the acronym for Common Object Request Broker Architecture OMG s open vendor independent architecture and infrastructure that computer applications use to work together over networks. Using the standard protocol IIOP a CORBA based program from any vendor on almost any computer operating system programming language and network can interoperate with a CORBA based program from the same or another vendor on almost any other computer operating system programming language and network.

Middleware such as CORBA may be beneficial in many situations. Because of the straightforward manner that CORBA integrates machines from so many vendors with sizes ranging from mainframes through minis and desktops to hand helds and embedded systems it is the middleware of choice for large and even not so large enterprises. One of its most important as well most frequent uses is in servers that must handle large number of clients at high hit rates with high reliability.

CORBA applications are composed of objects individual units of running software that combine functionality and data and that frequently but not always represent something in the real world. In a typical middleware based object oriented architecture there are many instances of an object of a single type for example an e commerce website would have many shopping cart object instances all identical in functionality but differing in that each is assigned to a different customer and contains data representing the merchandise that its particular customer has selected. For other types there may be only one instance. When a legacy application such as an accounting system is wrapped in code with CORBA interfaces and opened up to clients on the network there is typically only one instance.

In a large software system a build operation performs the various build actions to transform source or user modifiable code into executable or computer machine readable code. In a typical software system there may be thousands of software elements and several stages of compilation and code generation to build the software system into an executable version from the source code. Each of the software elements typically includes many classes or objects. Accordingly it is beneficial to limit or optimize dependencies between such software elements.

In a storage area network development environment the development effort may encompass a management application for storage arrays hosts and other nodes in the storage area network SAN . In such a development environment changes to the software elements are driven by many factors including release schedules custom versions patches and incremental releases to name several. The build operations should be deterministic such that changes made to the developer modifiable source code or application code repository do not have an unexpected effect on unchanged portions of the system. Changes to the system should have a predictable effect on other elements in the system and inconsistencies in the changes should be detectable by the build. For example removal of a particular element thought to be obsolete or superceded should not negatively impact the build for want of the removed element. Further the build should act as a line of first defense or backstop to isolate such issues should they occur. Accordingly it would be beneficial to identify dependencies between software elements and the objects contained therein to provide a deterministic and predictable outcome to changes to the system and effected promulgated by the build.

Unfortunately conventional build mechanisms suffer from several shortcomings. In a large development environment it can be difficult and time consuming to identify all dependencies between software elements in the software system. Further developers may have varying levels of familiarity with the environment and ensuring absolute compliance with dependencies may be subject to a human factor. For example a novice developer may be unaware of all dependencies relating to a software element to which they are making changes. Accordingly opportunities for inconsistency arise.

Configurations of the invention are base in part on the observations that such inconsistencies between software elements are best handled as early in the build process as possible. A large software system such as a SAN management application presents a complicated dependency inheritance lattice resulting in a resource intensive build operation. Inconsistencies such as misplaced or missing dependency references can cause the build to fail can result in an obsolete software element of object being employed or can result in a runtime anomaly or error. Accordingly it would be beneficial to define a set of build rules identifying allowable dependencies between the software elements such that developers may incorporate optimal and efficient dependency structures in developed software elements. It would be further beneficial to provide a build mechanism which enforces the dependencies to identify and correct inconsistencies prior to generating an apparent operational build lest such an inconsistency become a runtime anomaly at a customer site requiring field personnel and timely modifications to correct.

One particular distinction between the build system and architecture discussed herein and conventional build systems is that the former is designed for strict enforcement of inter component and intra component layer dependencies. The primary mechanism of dependency control is restriction of the Java compiler s source and class paths as intentionally defined by the software architect. The build system specifies a declarative domain specific language DSL for component library test and API layer dependency definition. The enforcement of intra component layer dependencies may be hard coded into the build system itself. The software architect or individual developers are responsible for defining component descriptors and the library dependency DSL. The build system acting as a software factory schema discussed further below invokes the code generators and compilers build processors employed by the build system. Such tools include IDL compiler component compiler COCO java bridge generator BRIDGEGEN ECCAPI model and component generator MODELGEN and a conventional Java compiler Javac discussed further below.

In a typical conventional build environment each class or compilation unit inherits or includes other classes which is dependent upon. These classes in turn inherit other classes resulting in the inheritance lattice described above. In a large software system the dependencies pursued by each class may be substantial. Since such dependencies trigger cumulative inheritance the resulting inheritance lattice tends toward a monolithic environment in which few classes are hidden from other classes. In conventional build systems unreferenced but needed dependencies ore often inherited indirectly via other classes. Further unneeded classes are often not removed from the dependency inheritance traversal pulling in additional unnecessary classes which tends to promote the indirect inheritance and monolithic nature of the build environment. The overall effect is towards over inclusion which causes the build to perform more slowly because of unnecessary dependency inheritance references and which increases the liklihood of indirect inheritance masking saving an otherwise misstated dependency. For example if A depends on inherits B and B inherits C A generally has visibility into C. Even if A does not explicitly have a reference to C the compiling entity will have access to C s definitions and will not flag A for want of a definition in C if A improperly according to the rules employs classes or objects in C.

Configurations discussed further below substantially overcome the above described shortcomings by providing a software architecture and build mechanism which enumerates a set of build rules applicable to software elements in a large software system such as the SAN management application and enforces the build rules during the build process to identify nonconforming dependencies and allow correction prior to full generation or delivery of a suspect build. The architecture identifies components including sets of classes or objects in a software element or component and categorizes the objects into layers in the component. A set of build rules identifies allowable dependencies between the component layers among the same and other components in the system as well as external entities such as off the shelf OTS and third party vendor products outside the development control. The build mechanism enumerates a set of dependencies for each of the components and an enforcer analyzes the dependencies to identify dependencies in violation of the rules. Further the enforcer separates the compile time and runtime inheritance paths to detect indirect monolithic inheritance. In this manner dependency rules define an efficient and optimal architecture which lends itself well to modifications timely builds and deliverable releases and enforces the dependency rules at compile time so as to avoid generating an obsolete or suspect build.

In further detail the method of building a software system according to a set of architectural build rules discussed further below includes identifying a plurality of software elements components for inclusion in a build in which the software elements are collectively operable to provide a set of instructions and data for operation of the software system and designating for each of the software elements a plurality of layers each of the layers representing a set of compilation units operative to perform according to a predetermined functional scope. An enumerated set of build rules is indicative of allowable dependencies between the layers of the software elements and developers define a set of dependencies between the software elements in which the dependencies are indicative of an association between the designated layers of the software elements. The build system enforces the build rules by analyzing the defined dependencies and identifying defined dependencies that are contrary to the enumerated build rules.

The build rules are employed to generate a set of build instructions operable to selectively invoke build actions based on the dependencies such that changes to a particular compilation unit initiate successive build actions on dependent compilation units according to the dependencies. The build instructions are aggregated in a build file and the resultant invoked build actions may include compiling inheriting linking i.e. binding labels executing code generators and interpreting.

Further in the managed information environment generating the build file invokes a compile time classpath defining a network of dependencies between the compilation elements and executing the deployable entities invokes a runtime classpath defining a network of dependencies between instantiated classes in which the compile time classpaths and runtime classpaths are different. The classpaths enables enforcing to identify dependencies contrary to the build rules by identifying a compile time omission rather than runtime failure.

In operation the build system identifies a build target and corresponding build action identifies dependent compilation units from the dependencies and conditionally performs the build action upon the build target when a dependent element corresponding to a dependency changes. An enforcer determines if the identified dependent compilation unit corresponds to the build rules and enumerates in the build file if the compilation unit corresponds to the build rules the identified compilation unit as corresponding to the build action. The enforcer therefore omits the identified compilation unit from triggering the build action if the compilation unit does not correspond to the build rules. In this manner the enforcer validates the defined dependencies against the build rules in which the build rules are operable to identify each dependency as valid or invalid and generates the build file accordingly.

The successive build traverses the build file to identify build targets and corresponding build actions and performs build actions corresponding to build targets identified from traversing. Because of omission of invalid dependencies the build file identifies if at least one of the build actions encounters a dependency contrary to the rules the build target currently being attempted and indicates the corresponding failure typically a undefined reference .

In the exemplary configuration the developer defines a set of dependencies each of the dependencies associating a layer of a first software element with a layer of a second software element the associated layer of the first element dependent on the layer of the second software element wherein changes to the layer of the second software element result in a build action to the layer of the first element. The layers lend an organization to the build such that the functional scope includes an architectural set portion and an application set in which the application set including an interface layer and an implementation layer and the architectural set includes a delegation layer and a middleware interaction layer. Accordingly the build rules are further indicative of layers adapted to depend from other layers for example restricting a higher layer from depending on a lower layer in which the higher layers are defined by the public interface of the component. The rules further enable the enforcer to enforce build constraints by compiling software objects in the designated layers according to the dependencies such dependencies further including intercomponent intra component and external runtime . The enforcer identifies dependency violations prior to runtime such that the intra component dependencies limit dependency on less public layers in the same component the intra component dependencies are limited to the interface of other components and external dependencies limit dependency to predefined external entities.

In the exemplary arrangement the build system executes a build script generator to generate a build script in which the build script is operable to perform the build of each of the software elements according to the build rules and the dependencies. Each of the software elements is a component having a corresponding descriptor and at least one interface file and each of the software elements is inclusive of a set of software objects in which the software objects indicative of a class and compilable as an individual executable entity in which each executable entity operable as an instantiation of the class.

Alternate configurations of the invention include a multiprocessing computerized device such as a workstation handheld or laptop computer or dedicated computing device or the like configured with software and or circuitry e.g. a processor as summarized above to process any or all of the method operations disclosed herein as embodiments of the invention. Still other embodiments of the invention include software programs such as a Java Virtual Machine and or an operating system that can operate alone or in conjunction with each other with a multiprocessing computerized device to perform the method embodiment steps and operations summarized above and disclosed in detail below. One such embodiment comprises a computer program product that has a computer readable medium including computer program logic encoded thereon that when performed in a multiprocessing computerized device having a coupling of a memory and a processor programs the processor to perform the operations disclosed herein as embodiments of the invention to carry out data access requests. Such arrangements of the invention are typically provided as software code and or other data e.g. data structures arranged or encoded on a computer readable medium such as an optical medium e.g. CD ROM floppy or hard disk or other medium such as firmware or microcode in one or more ROM or RAM or PROM chips field programmable gate arrays FPGAs or as an Application Specific Integrated Circuit ASIC . The software or firmware or other such configurations can be installed onto the computerized device e.g. during operating system for execution environment installation to cause the computerized device to perform the techniques explained herein as embodiments of the invention.

Embodiments of the invention are directed to techniques for strict enforcement of inter component and intra component layer dependencies. One particular mechanism of dependency control is restriction of the Java compiler s source and class paths as defined by the software architect. The build system specifies a declarative domain specific language DSL for component library test and API layer dependency definition. The enforcement of intra component layer dependencies are defined into the build system itself. The software architect defines component descriptors and library dependency DSL. The build system acting as a software factory schema discussed further below invokes code generators and compilers build processors invoked by the build system.

In a typical conventional build environment each class or compilation unit inherits or includes other classes which is dependent upon. These classes in turn inherit other classes resulting in the inheritance lattice described above. In a large software system the dependencies pursued by each class may be substantial. Since such dependencies trigger cumulative inheritance the resulting inheritance lattice tends toward a monolithic environment in which few classes are hidden from other classes. In conventional build systems unreferenced but needed dependencies are often inherited indirectly via other classes. Further unneeded classes are often not removed from the dependency inheritance traversal pulling in additional unnecessary classes which tends to promote the indirect inheritance and monolithic nature of the build environment.

Configurations discussed further below substantially overcome the above described shortcomings by providing a software architecture and build mechanism which enumerates a set of build rules applicable to software elements in a large software system such as the SAN management application and enforces the build rules during the build process to identify nonconforming dependencies and allow correction prior to generation or delivery of a suspect build. The architecture identifies components e.g. software elements including sets of classes or objects and categorizes the objects into layers in the component. A set of build rules identifies allowable dependencies between the component layers among the same and other components in the system as well as external entities such as off the shelf OTS and third party vendor products outside the development control. The build mechanism enumerates a set of dependencies for each of the components via a descriptor file and an enforcer analyzes the dependencies to identify dependencies in violation of the rules. Further the enforcer separates the compile time and runtime inheritance paths to detect indirect monolithic inheritance. In this manner dependency rules define an efficient and optimal architecture which lends itself well to modifications and timely builds and deliverable releases and enforces the dependency rules at compile time so as to avoid generating an obsolete or suspect build.

To illustrate a typical dependency assume the architect has decided on the rule A shall never depend on B . Sometime later new developers come along without knowing the rule. Suppose they added an instantiation of B to the A.java source. The developers have effectively introduced a dependency into the code. Upon compilation of A.java Javac i.e. java compiler will dutifully search for B.class in the classpath. Based on the project specific dependency rules defined by the architect the build system ensures that B.class will not be resolvable by the classpath. Javac then dutifully searches its sourcepath for B.java so that it can compile it into the coveted B.class. Again based on the rules the build system will make sure that B.java is not resolvable by the sourcepath. At that point Javac has run out of options and has no choice but to exit with a compilation error about B. This is the behavior the architect would like to enforce since it immediately notifies developers that something is amiss and prevents accidental dependencies from occurring.

In contrast conventional build systems have a monolithic src java directory and a monolithic class directory and Javac is given free reign to access all sources and classes. When a dependency rule is violated Javac compensates because it can either find the missing class in the all encompassing classpath or it can find the source in the all encompassing src java directory. The dependency rule violation may not manifest itself until run time in the lab or worse in the field.

Configurations herein further distinguish conventional build arrangements because the compile time classpaths and run time classpaths are different. Conventional builds are bound by a mandate that the compile time and run time classpaths be the same. The novel build system discussed herein does not follow this model. To illustrate suppose A depends on B and B depends on C . At run time it is apparent that all three A B C should be in the classpath. In the designers minds though A is only allowed to depend on B . Suppose the developer inadvertently instantiates C from within A. This violates a dependency rule and it would go unnoticed if at compile time we used a classpath with A B and C because Javac would find C s class and compile everything . Suppose at some later date developers decided that C was no longer needed and B was modified to no longer depend on C. Based on the project design C could then be thrown away however A still illegally depends on it. One way to spot this problem up front is to build A with only B in the compile time classpath. In this manner Java can t resolve C and will fail the build immediately.

Of significance is the notion that the build should fail if any dependency rules are violated. The intent is that issues must be resolved early in the development cycle and not later when the product is already deployed. The build system or mechanism discussed herein is used in support of application server component development. Such components are particularly applicable to a component server as disclosed in copending U.S. patent application Ser. No. 11 096 246 filed Mar. 31 2005 entitled SYSTEM AND METHODS FOR IMPLEMENTING A SOFTWARE COMPONENT DEVELOPMENT ARCHITECTURE assigned to the assignee of the present application and incorporated herein by reference. From the build system s perspective a component is roughly equivalent to a set of deliverable artifacts i.e. a jars . The rules governing component development dependencies and compilation are strict and follow a consistent pattern. The build system need only concern itself with the set of rules and then build the components accordingly.

In the exemplary configuration the deployment system includes a Storage Area Network SAN management server and an associated SAN having a plurality of associated SAN nodes such as storage arrays connectivity devices and hosts generally all operable to receive and execute a corresponding portion of the deployed build . The SAN management server maintains a management application infrastructure such as a SAN management application for monitoring and managing the exemplary SAN. The management application infrastructure in conjunction with the various SAN nodes provide information retrieval services to a user community not specifically shown . Optimal efficient operation of the deployed build on the SAN management infrastructure therefore provides uninterrupted effective services to the user community.

Referring again to the engineering build system the build system typically operates as a software engineering facility or software factory for maintaining and developing a code base of deliverable software to the users. The build system employs a plurality of developer modifiable software elements . . . N generally typically known as source code in the application code repository . As indicated above the software elements or components include and inherit other software elements defining a set of dependencies . A set of build rules define allowable dependencies among the elements discussed further below. A build generator generates build instructions referencing various build processor e.g. compilers and code generators depending on the nature of the software elements source code . The build generator includes an enforcer responsive to the build rules for maintaining allowed dependencies .

In operation the build generator generates build instructions subject to the enforcer to permit only allowed dependencies for aggregation as a build file . The build file includes a set of ordered commands having build targets and build actions discussed further below to perform the build. The build file invokes the build processors such as code generators compilers and interpreters for performing build actions on the software elements to generate the build targets. In general as is known in the art software typically undergoes one or more transformations by such build processors during a build to produce running application code executable files from human readable source code modifiable by the developers . The collective activity of the build file therefore produces object files maintainable as a code base representing a particular build. The code base is transported to a deployment system as indicated above to effect delivery of the software system such as the exemplary SAN management application. In a particular configuration the exemplary SAN management application may be the EMC Control Center ECC Application marketed commercially by EMC Corporation of Hopkinton Mass.

The developer defines a set of dependencies between the software elements in which the dependencies are indicative of an association between the designated layers of the software elements as shown at step . The associations are typically constraints such as inheritance and inclusion which imparts to the build process a need to recompile or reprocess a dependent software element or object prior to recompiling or rebuilding those from which it depends. An enforcer enforces the build rules by analyzing the defined dependencies and identifies defined dependencies that are contrary to the enumerated build rules as depicted at step . Typically a found violation results in identification of the offending dependency and possible termination of the build pending correction of the improper dependency . Alternatively a noncompliant build instruction may be met with a warning if the deviation is minor. It is desirable to detect such deviations during the build stage at the build system otherwise deviations may not be detectable until a deployed build fails at the deployment system .

It should be noted that the generally accepted notions of classes and objects as employed in the software industry are employed herein. In the discussion herein an object is generally employed as an instantiation of a class the class denoting a particular compilation unit. In contexts applicable to either runtime or compile time occur a class refers to the compilation or user modifiable source entity and an object refers to a runtime instantiation of the compiled executable object. Where the distinction between runtime and compile time is not particularly significant such as when classpaths for runtime and compile time are similar this distinction bears less merit.

In the application code repository each component has release code that is source code that makes up the component test code and meta data in the form of a component descriptor XML file defining the dependencies which is the primary input to various code generators . The code generation utilities including the various build processors that will be invoked include 

The IDL compiler is invoked one or more times per component. The number of iterations is driven by the dependency tree learned from the descriptor.xml file . Generally speaking the IDL compiler can emit stubs or skeletons. The stubs and skeletons will be redirected into their appropriate layers as defined in the rules section. For example 

In addition to descriptor.xml files input to COCO includes the classes of the skel sources created by the IDL generator. Thus it must be invoked after IDL is compiled and will take as its input the class directories that hold the compiled stubs and skels. Its output will be another source root under the component s mware directory INPUT mdl classes skel OUTPUT mware src java coco 

In addition to the descriptor.xml files input to BRIDGEGEN includes the classes of the skel sources created by the IDL generator. Thus it must be invoked after IDL is compiled and will take as its input the class directories that hold the compiled stubs and skels. Its output will be another source root under the component s imp mdl directory. The bridge generator BRIDGEGEN is employed to implement bridging morphisms between the generic middleware independent representation of the application codified in the application portion layers and the middleware specific representation discussed herein as a CORBA based implementation. Further details concerning the bridging morphism may be found in copending U.S. patent application Ser. No. 11 095 406 filed Mar. 31 2005 entitled METHODS AND APPARATUS FOR CREATING MIDDLEWARE INDEPENDENT SOFTWARE incorporated herein by reference.

In an exemplary configuration the build instructions define the build file generated by the build generator including a perl script engine driving the build generator . The resultant build file is received by a build utility for executing the build actions in the build file which in the exemplary configuration is the Ant utility represented as the build processors . Therefore the build generator produces the eabuild build.xml file that Ant will use. The batch file is a driver interface to the perl script. The ant.pl and LogText.pm files are both symbolic links to the same files that facilitate the main build system. A user properties template provides an example of how the user can perform adhoc modifications to the compilation process. The code base resulting from the build file is a set of jar kits. A kit is simply a collection of categorized jar files. An installation is a directory tree with jars and other files placed in a way similar to a real installation with the addition of tests and test components which aid the developer in debugging . A component coclass represents application functionality invoked by or included by the component being built and includes substantial application functionality i.e. developer coding effort.

As indicated above the build system employs Ant to drive the low level actions of compilation and will use Ant s inherent dependency checking mechanism and Javac interface to enforce rules. Due to the complexity of the rules the number of individual classpaths to manage and the expectation that the number of components could grow well into double digit figures an Ant file generator is employed however alternate configurations may employ a makefile or other build file for example. Note that the generator enforces dependencies by disallowing build actions and conditions in the build file . It therefore simply create an XML file based on the descriptor .xml files and the build rules suitable for Ant and then it will let Ant analyze for missing or circular dependencies upon Ant s invocation.

With respect to dependency processing the build script generator s input are the descriptor.xml of each component depend.xml of libraries tests and the API interface layer. The generator will loop through all component descriptor.xml files and store metadata in a series of associative arrays.

The descriptor.xml file exemplified below in Table I is used by three build processors the build script generator COCO BRIDGEGEN during compilation and the component server framework during run time . There are many elements and attributes but only a small portion are typically significant to the build script generator .

A label attribute of each component provides the real name of the component and the version attribute may be used later for jar file creation. The system attribute lets us know whether this component is a system component or a user component it has a subtle effect on the compilation classpath . A test attribute defines whether or not a component is a test component it has a subtle effect on kitting .

Based on such information and the general rules for intra component inter layer dependencies and inter component dependencies the build generator can create the Ant targets for any given component layer. Furthermore for each component the build system determines its immediate dependencies and the full recursion of its dependencies. For example if A depends on B and B depends on C then A s immediate dependency is B further A s fully recursed dependency is B and C. These relations are illustrated further below in the component dependencies and build rules examples of and Table II.

A middleware delegation layer includes identifiers for invoking middleware references and operations and a middleware layer includes processing logic for middleware invocations. The middleware delegation layer and middleware layer further define the middleware portion of the component . In the exemplary configuration separation of the middleware portion allows seamless rebuilding of the application functionality defined by the application portion which constitutes much of the SAN management application in the deployed build for ease of portability.

A developer or design team enumerates a set of build rules indicative of allowable dependencies between the layers of the software elements as shown at step and illustrated in an exemplary manner below in Table II. The build rules define from an architectural and or methodology standpoint allowable dependencies such that dependencies which increase complexity trigger excessive recompiles or tend to hide visibilities which may mask errors or inconsistencies are avoided.

In the exemplary configuration using the layer architecture of the build rules are further indicative of the layers which are adapted to depend from other layers as shown at step . Such build rules include restricting a higher layer from depending on a lower layer the higher layers defined by the public interface of the component as depicted at step enforcing build constraints by compiling software objects in the designated layers according to the dependencies the dependencies further including intercomponent intra component and external runtime as shown at step and identifying dependency violations prior to runtime the intra component dependencies limiting dependency on less public layers in the same component in which the intra component dependencies are limited to the interface of other components and external dependencies limiting dependency to predefined external entities as disclosed at step .

Developers define a set of dependencies between the software elements in which the dependencies are indicative of an association between the designated layers of the software components as depicted at step . In particular contexts each of the defined dependencies associates for example a layer of a first software element with a layer of a second software element the associated layer of the first element dependent on the layer of the second software element such that changes to the layer of the second software element result in a build action to the layer of the first element as shown at step . Therefore the build dependencies identify files which are recompiled based on changes to other files. Such changes may be source code changes made by developers or object code changes made by recompilations of files.

By traversing the dependencies the build generator generates a set of build instructions in which the build instructions are operable to selectively invoke build actions based on the dependencies such that changes to a particular compilation unit trigger a recompilation of dependent entities such as a class or object as shown at step . Each of the resultant build instructions initiate successive build actions on dependent compilation units according to the dependencies . Accordingly the build generator identifies a build target such as a .jar object file and corresponding build action as depicted at step . Depending on the nature of the dependent file the resultant build action may includes compiling inheriting linking i.e. binding labels executing code generators or interpreting as shown at step and invoke the corresponding build processors .

Therefore the build process includes executing the build script generator to generate a build script or file in which the build script is operable to perform the build of each of the software elements according to the build rules and the dependencies in which each of the software elements is a component having a corresponding descriptor and at least one interface file and each of the software elements is inclusive of a set of software objects . The software objects are indicative of a class and are compilable as an individual executable or object entity i.e. a .jar file in which each executable or compiled entity is operable as an instantiation of the class as depicted at step . Further generating the build file invokes a compile time classpath defining a network of dependencies between the compilation elements such that executing the resulting deployable entities invokes a runtime classpath defining a network of dependencies between instantiated class. However the compile time classpaths and runtime classpaths are different as shown at step . Separation of the runtime and buildtime compile time classpaths provides the separation to avoid the monolithic cumulative inheritance described above.

The build system enforces the build rules by analyzing the defined dependencies and identifying defined dependencies that are contrary to the enumerated build rules as shown at step . The enforcer therefore validates the defined dependencies against the build rules in which the build rules are operable to identify each dependency as valid or invalid thus building the build file . Enforcing the allowed dependencies includes identifying dependencies contrary to the build rules by identifying a compile time omission rather than runtime failure as shown at step . Build issues are correctable during development and therefore avoids masking errors which might occur as runtime issues after release i.e. at a customer site. The enforcer therefore determines if the identified dependent compilation unit corresponds to the build rules as shown at step . In the exemplary configuration the enforcer identifies if at least one of the build actions encounters a dependency contrary to the build rules the build target as shown at step and performs the following conditional branches. The build generator enumerates in the build file if the compilation unit corresponds to the build rules the identified compilation unit as corresponding to the build action as shown at step . Therefore the build generator writes a build instruction to effect the build action appropriate to the compilation unit typically invoking one or more of the build processors N. In contrast the build generator omits if the compilation unit does not correspond to the build rules the identified compilation unit from triggering the build action as shown at step . Therefore resultant execution of the build file fails because of the omitted improper dependency flagging further development activity for correction.

Following generation of the build file execution of the build file causes the build system to traverse the build file to identify build targets and corresponding build actions as shown at step . The build system identifies dependent compilation units from the dependencies codified in the build file and conditionally performs the build action upon the build target when a dependent element corresponds to a dependency change as discussed above with respect to the build processors N. The build system responsive to the build file invokes the corresponding build processors to perform the build actions corresponding to build targets identified from the traversal of the build file thus resulting in the deployed build defining the application for execution on the management application infrastructure .

For example suppose the descriptor.xml files reveal that A depends on B and B depends on C. It is possible for A s HDL to include B and for B s IDL to include C. So the include path used to parse A.idl must include directories for B and C. However the include path used to parse B.idl must only include C. This way the build system can catch errors. Suppose B.idl also included D.idl an IDL from the D component then the build would die when the IDL compiler couldn t find the include file. Note developers could avoid this problem by defining an absolute or relative path to D.idl thus avoiding the need for the IDL compiler to consult the include path. It is understood that the developers will not attempt to defeat the build system in this manner since it is beneficial to allow the build system spot errors at compile time.

Those skilled in the art should readily appreciate that the programs and methods for defining and enforcing software build dependencies and visibility as defined herein are deliverable to a processing device in many forms including but not limited to a information permanently stored on non writeable storage media such as ROM devices b information alterably stored on writeable storage media such as floppy disks magnetic tapes CDs RAM devices and other magnetic and optical media or c information conveyed to a computer through communication media for example using baseband signaling or broadband signaling techniques as in an electronic network such as the Internet or telephone modem lines. The operations and methods may be implemented in a software executable object or as a set of instructions embedded in a carrier wave. Alternatively the operations and methods disclosed herein may be embodied in whole or in part using hardware components such as Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs state machines controllers or other hardware components or devices or a combination of hardware software and firmware components.

While the system and method for defining and enforcing software build dependencies and visibility has been particularly shown and described with references to embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims. Accordingly the present invention is not intended to be limited except by the following claims.

