---

title: Method and system for hierarchical resource management involving hard and soft resource limits
abstract: The present invention manages resources in a computing device to facilitate the allocation of resources amongst competing clients operating on the device. A hierarchy of budgets is constructed to encode restrictions on the aggregated use of a resource allocated by a resource provider to one or more clients. A resource manager validates and arbitrates requests to allocate resources to the one or more clients by resource providers in accordance with the budgets comprising the hierarchy. The resource manager notifies clients of availability and shortages of resources to promote compliance with the restrictions encoded in the budgets of the hierarchy.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08091088&OS=08091088&RS=08091088
owner: Microsoft Corporation
number: 08091088
owner_city: Redmond
owner_country: US
publication_date: 20050222
---
In general the present invention relates to resources in a computing device and more particularly to managing resources in a computing device.

Operating systems employ resource management schemes to limit the interference between applications implement policies that prioritize and otherwise control resource allocations and generally manage the overall behavior of a system that is running many independent software applications.

Existing resource management schemes are largely first come first served. Counter based resource management schemes such as those used in the Digital VAX VMS the BSD UNIX and the WINDOWS NT operating systems attempt to maintain an absolute count of resource use by one or more processes. Counters may track for example kernel memory utilization Central Processor Unit CPU utilization or Input Output I O data transfers.

One of the problems with counter based resource management schemes is determining what the limits are and the consequences of reaching or exceeding the limits. More often than not the limit is simply raised when it is reached. In the context of the WINDOWS operating system setting limits on the use of certain resources is generally achieved through mechanisms such as job objects kernel quotas CPU affinities and various ad hoc resource specific limits. Resource use can also be capped along functional lines as for example when the memory manager caps the use of kernel virtual address space based on how it is to be used. Another example is when the use of kernel pool by the Transmission Control Protocol Internet Protocol TCP IP is dynamically capped based on the type of packet that is currently being transmitted e.g. a packet representing voice data might have a higher cap on the use of kernel pool than a packet that does not in order assure a quality voice transmission.

In some cases resource management schemes are based on setting relative priorities of the processes competing for the resources to aid in arbitrating resource contention as is currently done for example in the scheduling of CPU resources. In addition resource management schemes may be based on privileges i.e. requiring processes to have privileges to carry out certain operations to effect the allocation of resources as is currently done for example by requiring a process to have the privilege to lock physical pages in memory.

There are several problems with existing resource management schemes. As most resources are system wide managing resources on a first come first served basis can lead to denial of service problems. This is because resources may be subject to unbounded consumption by other applications other users or network visible services. Reliance on the existing mechanisms creates an unpredictable environment in which applications often cannot acquire the resources needed to run because errant selfish or malicious applications have already absconded with them. The problem is particularly acute in large terminal services machines.

Priority based resource management schemes only worsen the competition. Since applications cannot independently establish their priority relative to other applications it is generally not possible to set priorities to share the resource fairly. In most cases it is not even possible to define priorities fairly. In the case of CPU resources this often leads to applications artificially boosting their priorities to ensure access regardless of the demands present elsewhere. The end result is that applications will compete at the inflated priority level nullifying any fairness policy the priority scheme was aiming to accomplish.

With no limits on resource competition it is very difficult to provide pre defined levels of service to specific applications. An administrator or service provider generally cannot specify either a minimum or maximum amount of resources for an application. This presents problems in server consolidation scenarios and forces the administrators and service providers to support consolidation by for example dynamically adjusting priorities to manage CPU utilization by specific applications.

Some systems have attempted to overcome some of the problems inherent in resource management through the use of resource guarantees. Instead of just setting limits or priorities applications may contract for implicitly allocated resources upfront. Guarantees eliminate instantaneous competition for resources by adding a layer of indirection between requesting a resource and actually using it. By explicitly reserving resources in a first come first served manner a client obtains a contract regarding future use of the resource e.g. guaranteed I O latency regardless of any other outstanding guarantees. Bandwidth is one example where resource guarantees are particularly important for the implementation of multimedia applications. However guarantees themselves are resources and allocation of guarantees may fail.

As personal computers move into the living room and take on many new roles resource management becomes more important particularly when managing conflicts in resource usage. In addition server computers need to manage resources more effectively in order to provide a more predictable operational environment.

The foregoing problems with the prior state of the art are overcome by the principles of the present invention which is directed toward methods systems computer program products and data structures for managing resources in a computing device. The present invention is further directed toward methods systems computer program products and data structures for managing resources in a computing device to facilitate the allocation of resources amongst competing processes or threads operating on the device.

According to one aspect of the invention a budget encodes resource requirements and restrictions for one or more clients. Any number of processes threads or a combination thereof executing on behalf of a client may be associated with a single budget. A particular process or thread may also be associated with multiple budgets but is subject to only one budget at any instant in time. The processes and threads compete for resources based on among other considerations the requirements and restrictions encoded in the active budget.

In accordance with yet another aspect of the invention the active budget for a particular process or thread may change numerous times over the course of its lifetime depending at least in part on the client on whose behalf the process or thread is executing. In the case of a service process that is performing a service for one or more clients on a set of concurrently executing threads the client on whose behalf the process or thread is currently executing may be determined using resource client identity impersonation. Resource client identity impersonation temporarily associates a process or thread with a client by assuming the client s resource identity to locate and temporarily attach to the client s active budget. Typically this is accomplished by examining the active budget for the current client thread.

According to another aspect of the invention the budget encodes resource requirements and restrictions for the client or clients associated with the budget at least in part by maintaining one or more of three quantities for each resource supported for the client s the quantities indicating a limit L a reservation R and a commit C. 

According to one aspect of the invention the budget limit L represents a maximum on the amount of a resource that the client s associated with the budget can obtain from the provider of the supported resource i.e. the resource provider. Limits may be either hard or soft a distinction that dictates the appropriate behavior when the threshold is reached. If the limit is hard it is an absolute maximum and may be enforced by taking one or more actions such as failing requests to allocate the resource or employing rate control. However if a limit is soft then the limit only serves as an advisory to the relevant resource provider in deciding whether or not to fulfill a client s request to allocate the resource. Typically the resource provider makes a determination whether to provide soft resource allocation based on resource utilization level and whether the allocation can be reclaimed when needed with minimal performance overhead.

According to one other aspect of the invention the budget reservation R represents a pre allocation of a resource that ensures that future requests to allocate the resource on behalf of a client up to the amount of the reservation R will likely succeed also referred to herein as a guarantee. The budget reservation R is constrained by the budget limit L whether the limit is hard or soft. The budget reservation R may further represent a sufficient amount of the resource to span multiple allocations each allocation carving out a portion from the budget reservation.

According to one other aspect of the invention the budget commit C represents the amount of a resource that a resource provider has thus far allocated to the client s with which the budget is associated. Like the reservation value the budget commit C is constrained by the budget limit L whether the limit is hard or soft. In addition the budget commit C may exceed the reservation value R. 

According to still another aspect of the invention a budget hierarchy links together the resource requirements and restrictions encoded in separate budgets. Budgets in a budget hierarchy are organized in an n ary tree format with each budget object having at most one parent and an unbounded number of children. As such a budget hierarchy may be considered to have a single root budget which has no parent. Clients associated with a child budget in a budget hierarchy are also subjected to the resource limit L of a parent budget including the root budget. A parent budget may function as the default active budget unless a child budget is not explicitly created. The limit imposed on the client is the more restrictive of the limits maintained in the child and parent budgets referred to herein as the effective resource limit.

According to yet another aspect of the invention budget hierarchies may be external or internal. External budget hierarchies may be explicitly constructed in advance of their use based on policy considerations. Internal budget hierarchies may be dynamically constructed by a client attempting to self manage resource consumption by the threads and processes executing on its behalf. A client may be permitted to escape from the budget hierarchy of which its currently active budget is a part if it has sufficient privileges for example to subject an application to a policy other than that encoded in the current budget. An application that needs to limit the resources available to a new process can create a child budget in order to contain potentially malicious or dangerous behavior.

According to one other aspect of the invention additional limits may be encoded in a budget or elsewhere to dynamically change the resource restrictions imposed on a client based on how the client is using the resource. A client s use of a resource may vary over time depending on modes of operation and the like. The client defines the additional limits by the types of use and communicates the current use of the resource by indicating an active flavor. The active flavor is one of a plurality of flavors that represent the various uses to which a resource may be put. In this manner clients within the constraints imposed by their associated budgets may partition their use of resources based on the type of use. Typically the active flavor can be communicated to the resource manager explicitly for example by passing it as a parameter to a resource allocation API or implicitly for example by setting the active flavor into the user mode and or kernel mode memory state for the client.

According to still another aspect of the invention the resources that may be supported in a budget include discrete rate based and guaranteed resources. A discrete resource is a resource that is allocated to a client for exclusive use by the process or thread executing on its behalf. Discrete resources include resources that are constrained by actual physical limitations on the operating system or by artificial limitations imposed by the design of the operating system. Rate based resources include usage patterns of any discrete resource with respect to time such as the rate of CPU consumption I O or network bandwidth and the like. Guaranteed resources may be associated with either or both discrete resources and rate based resources. A guaranteed resource serves as a voucher for the future availability of a resource up to a designated amount.

According to still another aspect of the invention the clients for which resources may be managed may include applications or groups of applications. A client may optionally function as a budget manager having privileges to encode resource requirements and policy rules in a budget on behalf of other clients.

According to yet another aspect of the invention a resource manager centralizes the administration of resources including implementing the budgets monitoring available resources and recovering from resource allocation failures. The resource manager may further provide interfaces to specify budget constraints and communicate with resource providers. A resource manager may validate resource allocation requests forwarded from resource providers on behalf of clients in accordance with a dynamic policy state. The dynamic policy state represents the current state of resource management policy including the identification of currently executing processes and threads their relative importance as might be indicated for example by a priority level and their currently active budgets. The resource manager further arbitrates conflicts between a requesting client and a target client in accordance with an allowed action set specified for processes and threads executing on behalf of the target client in the dynamic policy state. The allowed action set ranges from passive actions for the target client to voluntarily cede resources for reallocation to a requesting client pro active actions to forcibly reclaim resources from a target client and aggressive actions that result in terminating the target client from which resources are reclaimed. The resource manager may optionally enforce rate control of a resource on behalf of a resource provider.

According to one other aspect of the invention resource providers allocate resources to requesting clients and reclaim resources from target clients separately from but in accordance with the resource manager s validation and arbitration determinations. As resources are allocated and reclaimed the resource providers further interact with the clients budgets directly or indirectly in cooperation with the resource manager to record the consumption and release of supported resources.

According to still another aspect of the invention resource notification services are provided to facilitate notifications regarding a resource to requesting and target clients from resource providers and the resource manager. Notifications include among others notifications related to resource arbitration and notifications that resource usage has reached or exceeded a threshold.

In accordance with yet other aspects of the present invention a computer accessible medium for managing resources in a computing device is provided including a medium for storing data structures and computer executable components for creating maintaining and querying budgets reserving and managing resources recording consumption of resources and arbitrating resource conflicts. The data structures define the resources and resource providers budgets and other policy data in a manner that is generally consistent with the above described systems and methods. Likewise the computer executable components including the resource manager and resource manager interfaces to the budgets and resource providers are capable of performing actions generally consistent with the above described systems and methods.

To successfully run an application on a computing device the device s operating system must provide the application with various resources. A computing system suitable for implementing an improved method for managing those resources to facilitate their efficient allocation and use in accordance with embodiments of the present invention is described in detail in the following discussion.

In general the resources that may be managed in an embodiment of the present invention include any quantifiable resource for which it is meaningful to allocate all or part for the use of an application or the operating system under circumstances where the resources may be temporarily or permanently depleted or otherwise unavailable. Some examples of resources that may be managed are described in detail below. The resources are typically allocated amongst competing processes or threads operating on the device. The competing processes or threads may be executing on behalf of one or more applications or the operating system.

The most familiar resources that may be managed in an embodiment of the present invention are based on real and virtualized hardware physical memory pages disk blocks peripheral devices virtual address space pagefile space CPU time object namespaces etc. Some of these resources are implicitly allocated. For example scheduling the CPU allocates CPU time requesting an I O operation consumes bandwidth throughout the I O system and accessing an invalid address generates a page fault.

In most systems there are only a few fundamental or base resources of note typical examples include disk storage I O CPU kernel virtual address space KVA user virtual address space UVA and physical page frames. Most other resources are typically composited from these fundamental base types. Although KVA and UVA are abstractions built on top of physical memory they represent a fundamental resource in that the amount of KVA and UVA space is limited by the number of logical address pins and operating system design and not the amount of underlying physical memory.

Examples of resources that may be managed in an embodiment of the present invention implemented in the MICROSOFT WINDOWS NT operating system include but are not limited to non paged and paged pool system page table entries PTE for virtual pages partitioned off the KVA pagefile space paging rate and AWE memory. Each of these resources whether base or composite may be defined by some set of characteristics that arise from artifacts and or design decisions or requirements present in the operating system. A list of such characteristics is given below 

Limited Absolute Resources In many cases the availability of particular resources may be constrained by artificial limits imposed by the operating system. For example due to a fixed number of slots in some table the data structures used by the operating system may be limited. On the other hand anything that can be counted the total number of page faults I O bytes transferred context switches CPU time etc. maybe considered a resource when combined with an artificial limit. Most of the resources that fall under the counted category are typically implicitly allocated by the application that needs the resource. In a typical environment the operating system may also limit simultaneous resource consumption for example by restricting the number of active network connections it may concurrently support.

Rate based The rate at which a resource can be allocated can also be a resource. For example CPU time scheduled I O page faults and context switches can all be limited by the rate at which they can occur. Such limits may be either artificial imposed by the operating system or a practical limitation e.g. a maximum sustainable possible I O rate . Limited resources may be differentiated from rate based resources in that limited resources are accounted for and limited based upon absolute quantities e.g. total CPU time consumed total page faults incurred or total non paged pool allocated . Rate based resources may also differ from other types of resources in that a rate based resource is typically automatically replenished in the absence of resource use over some duration of time.

Guarantees In the case of most allocated resources the operating system must arbitrate for resource availability instantaneously. Depending upon the state of resource use by other clients the operating system may be unable to satisfactorily address a resource request for an extended period of time. For example a low priority thread may remain starved until the system boosts its priority or alternatively all higher priority threads cease to be in a ready runnable state. To alleviate this difficulty particularly for clients that have bounded latency requirements that are necessary to support quality of service QoS levels the system may offer guarantees regarding resource availability. Examples include promising to provide 100 milliseconds ms of CPU time every second or to transfer 2 megabytes of I O data per second or to service up to 80 hard page faults per second. Such guarantees are meaningful only because the system will later act to realize them thus there is necessarily some restriction on the number of such promises the system may concurrently make. In this regard guarantees may themselves be considered to be a resource.

The resources that may be managed in an embodiment of the present invention include both renewable and non renewable resources. Resources can be categorized as renewable or non renewable based on how they are replenished. Renewable resources are consumed when allocated to an application but are automatically replenished with the passage of time. Most implicit rate based resources such as CPU rate I O bandwidth and page fault rate are renewable. Non renewable resources are replenished when the application returns the allocation. Memory blocks devices counted limits and data structure limits are all examples of non renewable resources. Most resources are non renewable.

The resources that may be managed in an embodiment of the present invention also include reclaimable resources. A reclaimable resource is one the system can retrieve from an application without the application s cooperation. The most severe form of retrieval is to simply terminate the application so that all of its resources are relinquished to the system. However individual resources can be retrieved in many cases with the effect on the application varying from degraded performance to reduced functionality and possibly to abnormal exit. Examples of reclamation include un mapping a memory resource de scheduling an application invalidating handles and ceasing to honor guarantees. Certain resources of course cannot be reclaimed in the sense described here typically such resources are infinite in quantity but any portion allocated to a client is consumed and cannot be returned to the system. Examples include monotonically increasing quantities such as total CPU time consumed and total page faults incurred.

In a typical embodiment the resource manager is implemented in a kernel mode component but could be implemented elsewhere without departing from the principles of the present invention. The resource providers are typically implemented as either user or kernel mode components. Examples include memory managers and CPU reserve and IO categorization mechanisms. In one embodiment a user mode resource provider interacts with a kernel mode resource manager using a kernel mode resource provider as a proxy.

As noted earlier the resource manager operates in conjunction with resource providers and clients to manage the allocation of resources to the clients by the resource providers in accordance with a dynamic policy state. The dynamic policy state is embodied at least in part in one or more budgets A B C formed in accordance with a policy module . In one embodiment the policy module may comprise one or more policy managers and a policy database . In general the policy module operates to encode in the policy database certain preferences such as the priority of specific clients and other static or relatively static policy data. The budgets A B C on the other hand generally encode the dynamic resource requirements and restrictions of a particular client or set of clients. The use of the policy module in the management of resources will be described in further detail with reference to .

The budgets A B C may be active or inactive. An active budget is one that is currently associated with a client . An inactive budget is one that has typically been created in advance for one or more clients to represent policy considerations but for a number of reasons is not currently associated with a client . In a typical embodiment a budget is implemented in a budget object. Budget objects are associated with one or more processes or threads currently executing on behalf of a client . Among other uses the resource manager uses the active budgets to determine how much of what resources the associated process or thread may use at a given point in time. In one embodiment budgets may be dynamically created and or activated and associated with any one or more of groups of related applications A unrelated applications B and budget managers C. The groups of related applications A unrelated applications B and budget managers C together comprise the clients for whom resources are managed. The use of budgets to manage resources will be described in further detail with reference to .

In one embodiment the functions of the resource manager include among others enforcing budgets A B C including administering advance reservation requests for resources and bandwidth guarantees monitoring available resources and arbitrating resource contention. The functions of the resource manager may further include adding and removing dynamic resources that may or may not be controlled by third party resource providers.

In one embodiment the functions of arbitrating resource contention among competing clients may be embodied in a resource arbitrator module . In a typical embodiment arbitration is performed at the request of a resource provider . In one embodiment the resource arbitrator determines whether resources should be reclaimed from an outstanding allocation to one client i.e. a target client to satisfy an outstanding request for the resource from another client i.e. a requesting client. The resource arbitrator makes such arbitration determinations in conjunction with the dynamic policy state i.e. the current budget objects and other policy data as will be described in further detail with reference to .

In one embodiment the resource manager is further provided with a resource manager interface to facilitate communication with the clients the resource providers and other components of the resource management system . In particular the resource manager interface may be used to control interactions between the resource manager and the budgets A B and C as well as between the resource manager and the components of the policy module . In one embodiment the resource manager interface may further control interactions between the resource manager and resource notification services . The resource manager may optionally use resource notification services to notify interested clients about resource availability and management. Upon receiving a notification clients may in turn cooperate with the resource manager to release resources that are in short supply to facilitate efficient resource management. In some cases client cooperation with notifications may help to avoid having to arbitrate resource contention later on.

In one embodiment the resource manager may further include a resource rate controller to enforce rate control of resources on behalf of a resource provider i.e. to control the consumption of a resource by one or more clients per unit of time.

In a typical operating environment the resource providers may control interactions between the resource provider the clients and the resource manager via one or more resource provider interfaces .

Internally budgets track three quantities for each supported resource a limit L a reservation R and a commit value C . In the discussion that follows the threads processes etc. associated with the budget are referred to as clients of the budget where client generally refers to the client on whose behalf the thread or process is executing. For ease of description references to threads include processes or any logic executing on behalf of a client unless otherwise indicated. At any instant an executing thread s resource usage is subject to a single budget i.e. the active budget object . At the same instant the active budget object may be associated with multiple threads executing on behalf of the same or different clients . The budget s parameters and the actual budget object representing the budget may vary over time due to policy decisions implemented by the resource manager or due to manipulation by the multiple threads and or processes with which it is associated. Furthermore budgets may be hierarchically related in order to express relationships between different clients on whose behalf threads are executing such that the resource usage of one client may be tied to the resource usage of other clients associated with budgets in the same budget hierarchy.

The limit value L represents a maximum amount of a resource that a budget may reserve for future use by the budget s clients. Though limits typically remain constant following budget creation a system component with sufficient privilege may subsequently modify these limits. Limits may be of two types hard or soft. A hard limit is an absolute limit on the amount of resources that may be assigned to a budget at the normal service level. If the limit is soft then resource allocations in excess of the limit value L are disbursed to the requesting client at a sufficiently degraded service level such that the system s ability to satisfy normal resource requests remains unimpaired. Such lower service level resource disbursements allow clients to make use of resources that might otherwise be underutilized

The reservation value R represents a maximum amount of a budgeted resource that a client of the budget can reserve and is always bounded by the limit L regardless of whether L is hard or soft. As such the reservation value R imposes a maximum on the amount of a resource that the clients of the budget will be able to subsequently allocate at the normal service level without requiring resource arbitration. Since reserved resources are effectively unavailable for reservation by other clients all reservations are typically conservative so as to minimize resource under utilization and unnecessary resource contention.

The commit value C records the actual amount of resource that a resource provider has allocated to a client of the budget. Because a limit L that is soft marks the threshold at which resource allocations cease to be provided at the normal service level the commit value C may be written as the sum of two values normal commit Cn and excess commit Ce . All allocations up to the limit L are considered to be of the Cn type which indicates that the resource provider allocated Cn resource to clients at the normal service level. Ce represents the fraction of commit that is granted to applications at a degraded service level and is only granted to an application if both L is soft and Cn L i.e. when the resource provider has already allocated the full amount of the soft limit. Thus when L is a hard limit then Ce is necessarily zero.

The limit L itself serves as a loose upper bound on the amount of a resource that may be reserved R . R is constrained by the other reservations present in the client s budget hierarchy as will be described below with reference to and reservations elsewhere in the system. Since resource allocations classified as excess commit Ce are reclaimable clients typically use excess resource allocations to perform optional or non time critical processing e.g. to provide additional MP3 video display effects etc. .

The aim of soft limits is to ensure that resources in the system are not underutilized particularly in the absence of contention. For resources that are idle for example it is generally safe for a resource provider to classify the resource as excess and allow it to be allocated to needy clients. For resources that can be explicitly reserved in advance of being committed i.e. finite resources as opposed to rate based resources a resource provider may speculate as to which portions of a reserved but uncommitted resource are unlikely to be used in the near future. The resource provider may then disburse such resources to a requesting client but must be sure that the resource can be reclaimed quickly efficiently and likely without the explicit cooperation of the client . Otherwise the resource provider may subject clients that have made advance reservations to unreasonable delay while the necessary resources are reclaimed. Thus there are only a handful of resources for which the concept of soft limits is both meaningful and practical for the resource manager to implement.

In an example implementation of a soft limit suppose that at time a the value of C was Ca and at time b was Cb such that a

A typical use of soft limits is to avoid under utilization of CPU. When a budget has a limit L of a certain percentage of CPU consumption and there is no contention for CPU then there is generally no reason that the clients of the restricting budget cannot consume all of the CPU as otherwise the CPU would go completely unused . The difficulty in simply disbursing the available CPU to the clients in question is that it must be easily revoked should any other clients not bound to the restricting budget become ready. If the CPU could not easily be reclaimed and disbursed to a legitimate client the usefulness of the soft limit L set in the restricting budget would be thwarted. While achieving zero reclamation cost is difficult to achieve it can be greatly minimized in certain cases. In the case of CPU for example once the limit L has been exceeded the priority of the restricted threads can be dramatically lowered before allowing them to continue execution. Thus in the absence of CPU contention the restricted threads are scheduled on the CPU and their operation continues unhindered. Should any other unrestricted thread not associated with the budget become ready or should contention for CPU otherwise occur the lowered priority ensures that the restricted threads do not interfere with the legitimate activity of the unrestricted threads. When the resource is replenished the restricted threads priorities are restored to their former levels.

Typically a resource provider will determine whether to provide excess resource allocations i.e. whether to impose soft limits as opposed to hard limits based upon the amount of time in which reclamation can be achieved. In this manner the reclamation time may be used to bound the wait time that a legitimate normal resource allocation Cn may encounter assuming the resource is held in Ce allocations in other budgets. Note in general as described above that the reclamation time can be bounded only for portions of a Cn allocation that are less than R other portions of R can at worst be delayed by the time required to reclaim the resource from the Cn allocations given to other clients.

By allowing soft limits a client of a budget may partially compensate for an artificial limitation set on its reservation requests due to unused reservations made by other clients in the system. It should be noted that soft limits may appear to negate the effectiveness of budgets in constraining resource usage as they permit committed usage to be unbounded. However allocations beyond the soft limit are typically limited to resources that would otherwise be under utilized. Not all resource providers may support soft limits. For example the use of soft limits to avoid under utilization may not be desirable when the goal is to provide consistent performance as opposed to optimal performance . Thus not all supported resources in a budget may be subject to a soft limit L .

Soft limits provide a means by which resource under utilization may be combated but do not offer a means by which interested parties may receive advance notice that the resource usage tracked by a particular budget has passed a certain threshold. To address this omission resource budgets support the notion of sentinels or alarms on resource usage by optionally including a budget sentinel value . The only restriction on the value of budget sentinels is that they are less than or equal to the current resource limit L set in the budget if the resource limit L is contracted to a value less than the sentinel s value then the sentinel is invalidated . The sentinel s value bears no ordering relation to the current normal commit Cn or reserve values R for the resource in question. When the current normal commit Cn value of a particular resource exceeds the sentinel value other clients may be notified for example by using the notification services described in detail with reference to below. Upon receipt of such a notification the client may react as it sees fit e.g. by adjusting resource usage modifying resource limits etc. . In a typical embodiment to avoid severe performance degradation in cases of hysteresis in which the current normal commit Cn value oscillates back and forth across the value of the budget sentinel sentinel notifications are one time events once the notification has been issued the sentinel remains inactive until an interested listener e.g. a client or system administrator explicitly reactivates it.

A budget may be part of a budget hierarchy as will be described in detail with reference to below. For simplicity in the following discussion the limit is assumed to hard such that Ce 0 and thus C Cn. For a generalized discussion Cn may be substituted for C below. When part of a hierarchy in addition to the L R C and budget sentinel values described above each budget may include accumulated reservation value in which the accumulated amount of resource reservation R of all hierarchically related budgets below the level of the current budget is maintained also referred to as the sub tree reservation. The accumulated reservation value facilitates the enforcement of budget restrictions for budgets that are part of a budget hierarchy as will be described in detail with reference to below.

A budget hierarchy typically comprises a root budget and one or more child budgets A B and C. The child budgets may in turn comprise additional child budgets A B C D E and F. The resource manager uses the root level budget to impose the final barrier to admitting or denying a resource reservation request initiated by the client of one of the budgets in the budget hierarchy . Any such reservation request must satisfy the budget constraints present at each level of the hierarchy between the initiator s budget and the root. Thus a request initiated by a client of budget F must satisfy not only the constraints of budget F but also of budget C and root budget .

In one embodiment once a resource request is admitted by the resource manager in accordance with the budgets in budget hierarchy requests are generally further reviewed by the appropriate resource provider to ascertain whether it is practicable to admit the reservation request in light of outstanding reservations and allocations. Note that a request that is practicable to admit may be preemptively denied by the resource manager under the constraints specified by the budgets in the budget hierarchy .

In a typical embodiment to improve the performance of traversing up the budget hierarchy the resource manager may cache the total accumulated amount of reservation made in a sub tree of the budget hierarchy at the sub tree s root budget. In this manner a resource reservation request initiated by a client of a non root budget also referred to herein as a derived budget need only be checked against the requestor s budget and all the budgets above it in the hierarchy. In the illustrated example a request initiated by a client of child budget F is checked against the requestor s budget i.e. the child budget F itself and all of the budgets above it in the budget hierarchy in the direct path to the root budget and not sub tree budgets A B or budgets at the same level child budgets A E.

Note that a derived budget need not necessarily have a limit L that is less than the limit specified in any of its ancestors. This is because external policy may link a pre defined budget into a budget hierarchy in response to the launch of an application of a client . In cases in which the local limit i.e. the child budget s limit is greater than the limit in an ancestor the correct result will still be achieved as the request will be blocked higher up the tree.

In a typical embodiment a root budget is not an absolute partition of the system s resources unless the summation of the L values across all root level budgets exactly equals the total available resources in the system. Since limits L can be adjusted post budget creation and result in an over subscription of resources resource partitioning is instead typically accomplished by requesting a reservation of resource guarantees e.g. CPU bandwidth guarantees .

As noted earlier budget hierarchies provide a mechanism to express rules concerning the resource requirements and restrictions of the budgets belonging to the hierarchy. An example of a budget hierarchy and the rules that are expressed in the hierarchy is illustrated in . In the example a system administrator wishes to constrain the aggregate use of CPU by the clients A B C D and clients X Y Z to no more than 80 percent of the available CPU in the system. However clients A B C D may use up to 50 percent of the CPU as shown in aggregate use rule while clients X Y Z are restricted to just 40 percent as shown in aggregate use rule . Expressing this type of rule using a single standalone budget proves difficult particularly since the individual limits of 50 and 40 percent add up to more than the desired effective limit of 80 percent as set forth in aggregate use rule L L L e.g. 50 40 90 80 . However a system administrator can achieve the desired result by creating the illustrated budget hierarchy formed in accordance with an embodiment of the present invention.

As shown the illustrated budget hierarchy example is comprised of budgets B with limit Lof 50 percent and B with limit Lof 40 percent each of which is derived from a root budget B with limit Lof 80 percent . Clients A B C D are associated with budget B and clients X Y Z are associated with budget B. The resource manager enforces the limits in the example budget hierarchy by restricting the respective amounts of committed resources to the limits Land Lin budget B and budget B as illustrated in aggregate use rules committed B

As shown in the illustrated example budget hierarchy budget hierarchies in general provide a means of apportioning resource limits L to clients in order to encapsulate their respective resource use while imposing an effective limit equal to the most restrictive of the limits specified in a client s local budget i.e. the child or derived budget and the limits encoded in the budgets along the path to the corresponding root budget.

In general the following invariants hold regarding any budget hierarchy . A limit L for any budget may be hard or soft. In addition the limit L is typically greater than or equal to the reservation R and is also greater than or equal to the normal commit Cn . If the value of the limit L is soft then the excess commit Ce may be greater than or equal to zero and is generally bounded by the amount of idle resource available in the system. If the limit L is a hard limit then no excess commit value is usually permitted i.e. the Ce is usually zero a requirement that is typically enforced by the resource manager . The amount of reservation R for any budget is restricted not only by the budget s limit value L but also by the reservations and limits set elsewhere in the budget hierarchy . As such the limit L typically serves only as a loose upper bound on the amount of reservation R that may be made. Lastly the normal commit value Cn can always reach the value of R even if this requires the resource manager in cooperation with the resource provider to reclaim any excess committed resource Ce that may have been reserved or allocated to other clients . Any portion of the normal commit value Cn that is less than R also obtains a performance benefit in that a hierarchy traversal for limit considerations is avoided because the value of R in the budget has been previously validated against the limits in the hierarchy. Again the maximum value that the normal commit value Cn may have is bounded by L but due to hierarchy restrictions and over subscription of resources it may never reach this value.

In a typical embodiment of the resource management system such budget enforcement and consumption recording may be achieved through the use of client resource identity impersonation a generalized overview of which is illustrated in . Client resource identity impersonation temporarily associates a process or thread with a client by allowing the process or thread to assume the client s resource identity in order to locate and temporarily attach to the client s active budget . The resource manager is then able to properly enforce the active budget s restrictions and record consumption for the resource that the process or thread is using on behalf of the client . In a typical embodiment the client s resource identity may be derived from the application ID or other identifying information that the system maintains for the client such as the current token.

In a typical embodiment client resource identity impersonation is appropriate when a service i.e. the process or thread operating on behalf of the service both allocates and relinquishes a resource while temporarily attached to the client s active budget . If the service allocates a resource that persists beyond the impersonation period such as objects handles or memory for local caches this should not be charged to the client since those resources are typically maintained by the service in order to facilitate other future requests for different clients. Thus in a typical embodiment upon receipt of a client request the service first determines whether resource client impersonation is appropriate given the nature and lifetime of the resources required to accomplish the client s task. Even if the service ascertains that impersonation is the appropriate course of action the service must have sufficient privilege to locate and attach itself to the client s budget . If the service has insufficient privilege to accomplish resource client impersonation or determines that such impersonation is inappropriate the service may take alternate action to limit resource usage as described below.

Since a process or thread operating on behalf of a service may offer services to any number of clients but may allocate persistent resources in response to particular client requests such as handles the process or thread may desire to impose some type of limitation on this usage in a per client manner. The service process or thread can thus take one of two approaches to limiting its own resource consumption in a per client manner either limiting the rate at which a given client can invoke the service or partitioning its own budget to reflect its clientele.

In the first case the service can control the rate at which a particular client forces the service to deplete its own resources by using the rate controller function provided by the resource manager to limit the rate at which the client may invoke the service. This can mitigate the effect that a particular client s requests may have on the service s ability to address the needs of all the clients in the system. To avoid the overhead of apportioning every client budget with a rate limit for every service by default no such limits are typically present in any budget . Rather a service interested in imposing such a limitation may dynamically insert the limit into the client s budget an operation which typically requires appropriate access rights. For example a resource provider may automatically attempt dynamic limit insertion based upon a failure code returned when attempting to charge for a particular resource. The resource manager may then enforce the limit using the resource rate controller when enforcing the client s active budget . Since any client associated with a budget may cause additional per service limits to be inserted in the budget the resource manager may periodically purge the least recently used budget entries during rate replenishment.

In the second case the service assigns a flavor to each client of interest and dynamically inserts the desired resource limits associated with this flavor into its own active budget . This allows the service to ration its own resource usage in a per client manner. Note in this case the burden of tracking which flavor corresponds to which client falls upon the service and not the resource manager whereas in the first case once the limit is inserted into the client budget the resource manager will automatically enforce adherence to it.

Note that the use of flavors illustrated in the second case may also be applied in a similar manner to clients that want to manage their own use of resources based on type of use. In that case the client maintains its own flavors and corresponding flavor resource limits and dynamically inserts those limits into their active budget depending on how they are currently using a particular resource.

Drivers may limit resources in a manner similar to services. In general however correct impersonation becomes difficult as the driver may not necessarily execute code in response to a client request but rather in response to an external event. As such the driver may not be in the appropriate context when it performs resource allocations. If a driver wishes to take the impersonation approach it may maintain references to the appropriate budgets itself and manage their use appropriately. Again such an approach leaves client budgets susceptible to driver resource leaks and or errant resource use. Moreover issues of fairness arise when considering persistent kernel state allocated by drivers but charged to client budgets. In a typical embodiment drivers may avoid such problems by partitioning their own budgets using per client flavors and flavor resource limits as described above and allocate resources accordingly. However because drivers do not execute in the context of a single client the active flavor can be specified explicitly to the resource allocation APIs as a parameter or by passing a reference to the actual budget or implicitly associated with the current client or current processor for the duration of the drivers execution.

Notification services provide a reliable and lightweight event notification mechanism to interested clients . Clients may choose the desired delivery method the delivery methods having various levels of delivery assurance. In a typical embodiment the notifications consist of a bitmask representing a set of events that have occurred. In addition auxiliary notification parameters associated with a notification may be optionally communicated between a client and a notification provider e.g. the resource manager or a resource provider typically by using an out of band application programming interface API .

In one embodiment the notification services utilizes a pull system to manage event delivery giving clients the freedom to decide when if ever to retrieve the full notification bitmask . The first occurrence of an event in a client s interest set some client specified subset of the notification provider s supported bitmask triggers the delivery technique specified by the client whereas subsequent events either of the same type or not are batched into the stored bitmask. As such repeat occurrences of a particular event are lost until the client opts to retrieve the bitmask at which point the batched bitmask is reset i.e. cleared . Depending on the chosen delivery method this approach gives clients the freedom to process notifications at their own volition. Example uses of the resource notification services will be described with reference to resource arbitration in below.

In a typical embodiment the resource provider provides the resource manager with the information necessary to determine whether resources should be reclaimed from some outstanding allocation in order to satisfy the requesting client s request. The resource manager in turn makes this determination in conjunction with the dynamic policy state embodied in the policy module . As described with reference to the policy module comprises among other components a policy database of client priorities and user preferences that is populated by a higher level entity such as a policy manager or a budget manager C. The details of the policy module will be further described with reference to .

As an example the policy database may indicate that the user has assigned the highest preference to the requesting client . The dynamic policy state may also indicate a potential reclamation target client E as well as a set of allowed actions that may be taken against the target in order to reclaim the resource. Depending on the current policy reflected in the dynamic policy state the resource manager may respond to the calling resource provider s arbitration request by instructing the provider to satisfy the requesting client s allocation request by using any means necessary including reclaiming resources that may have been allocated to one or more target clients E in accordance with an action specified in the allowed action set for that target.

In attempting to reclaim resources for use by the requesting client D the resource provider selects a potential target client E from which resources can be reclaimed. If the resource manager does not suggest a target for the reclamation as indicated in the dynamic policy state the resource provider may choose a client of its resources as it deems appropriate. Once the resource provider chooses a target the resource manager may issue a resource notification using the resource notification services in an effort to solicit cooperation from one or more targets to release the resource in question. Alternatively or in addition the resource provider may proceed to reclaim the resource by issuing its own resource notification again using the resource notification services and or using one or more actions selected from a set of actions as indicated in the dynamic policy state. The set of actions may range anywhere from passive contacting the target client E and requesting that it voluntarily cede an amount of the resource e.g. issuing the notification to proactive forcibly reclaiming the resource to aggressive terminating the target . In one embodiment well written clients can cooperate seamlessly with passive actions by obeying the various notifications issued by the resource manager and various resource providers concerning resource state changes. Example notifications might include release units of resource X or possibly freeze state for later resumption. 

When the client does not cooperate with the notification such as by ignoring issued notifications or alternatively when the target client E is a legacy application that predates resource management or has chosen not to participate in resource management or is otherwise unresponsive then the resource provider may escalate its attempts to free resources using either the proactive or aggressive actions.

As noted earlier a reclaimable resource is one than can be safely retrieved from an application without the application s cooperation. Resources can always be reclaimed transparently from an application but the potential effect on the target client E may vary from degraded performance to reduced functionality to abnormal termination. Reclamation is preferable to a more aggressive action e.g. terminating the application only insofar as the effect on the target s behavior is predictable and will not lead to an unexpected termination. For instance reclamation methods can include ceasing to honor bandwidth guarantees de scheduling an application invalidating handles and un mapping a memory resource. In this instance reclamation is considered reasonable only in the first two cases as it may have a non deterministic effect in the latter two cases.

It should be noted that resources that cannot be reclaimed as earlier described such as total CPU time consumed and total page faults incurred are not generally subject to resource arbitration. This is because allocation failures of resources that cannot be reclaimed typically arise only due to artificial budgeted limits L enforced by the resource manager in which case resource arbitration is unnecessary.

As shown in the illustrated embodiment in the dynamic policy database state may comprise policy database entries that are identified by a unique tuple. As processes or threads are launched or created they are mapped to an tuple. Each tuple may include an indication of the relative priority and the allowed action set for the mapped processes and threads. The data entries may also identify the budget or budgets that may be actively associated with the processes and threads mapped to the tuple.

In a typical embodiment the allowed action set describes the set of actions that are considered acceptable in the course of arbitrating a resource conflict. For any tuple that is not at the highest priority level at least one such action must be specified. As described earlier the allowed actions may range in severity from passive to pro active to aggressive. Example actions include requesting that a client cede resources with timeout transparently reclaiming reserved resources reclaiming allocated resources requesting that the client save state and move to a quiescent state or forcibly terminating the client to reclaim the resources in contention. If no actions are specified in the allowed action set then any process or threads mapped to the corresponding tuple are immune to all resource arbitration actions and are considered to be of infinite priority.

Among other uses the dynamic policy database state aids the resource manager in the resolution of any conflicts that may arise as a result of an allocation failure and subsequent arbitration request from a resource provider . In suggesting a potential course of action to a resource provider the dynamic policy database state advantageously enables the resource manager to significantly improve upon the first come first served allocation policies found in contemporary versions of WINDOWS and other operating systems.

Another aspect of the policy module is to store information in the policy database that describes in advance the resource requirements and or limitations of a particular client . In one embodiment the operating system may query and utilize this stored information to ensure that a process or thread executing on behalf of the client begins its existence subject to the relevant resource requirements and restrictions contained in an appropriate budget or budget hierarchy . The requirements and restrictions are applied at process creation time to prevent the process or thread from executing outside the requirements and restrictions specified in the policy module . The policy managers may take advantage of this feature to among other things isolate potentially rogue applications clients or ensure that certain clients can startup only if the operating system can reserve a set of required resources in advance.

In a typical embodiment the requests for validation and arbitration may be implemented in the form of a query specifying the tuple corresponding to the client that issued the resource request . The query is applied against the dynamic policy database state and a result list is returned containing a list of the processes or threads whose corresponding tuples are of priority less than the specified tuple. In a typical embodiment the resource provider may optionally supply with the query a list of processes or threads currently using the resource in question so that the result list retrieved from the dynamic policy database state may be appropriately trimmed to a reasonable number of entries.

The workflow includes a process to transfer control from a resource provider to the resource manager prior to allocating a resource followed by a process in which the resource manager receives from the resource provider a request to validate a client s resource reservation or allocation request. The resource manager commences validation at decision block at which time the resource manager consults the active budget associated with the allocation request i.e. the active budget associated with the process or thread that initiated the request. As described with reference to the resource manager enforces the current budget limit L reservation R and commit C values in the active budget and any budget hierarchy of which the active budget is a part. In so doing the resource manager may deny the request should the request exceed the budgeted values. In that case at process the resource manager may enforce rate control if the resource provider has requested rate control or may return control to the resource provider at process block which in turn returns control to the client at process denying the client s resource reservation or allocation request.

Should the request fall within the budgeted values the resource manager may admit the request. At process block the resource manager may further inform the resource provider of the portion of a client s allocation request that can be satisfied from the client s pre reserved pool. Control is returned to the resource provider at process block after which the resource provider may attempt to allocate the resource as needed by the requesting client. At decision block should the allocation succeed then at process control may be returned to the requesting client. Otherwise should the allocation fail then resource contention has occurred. At this point at process block the resource provider may optionally consult the resource manager for resource arbitration and reclaim resources where possible in accordance with such arbitration as previously described with reference to . Once sufficient resources have been reclaimed the resource management workflow may resume at process block to retry the allocation request in the same manner as previously described.

In one embodiment the create budget interface may be used by policy managers and clients to create and manipulate budgets and budget hierarchies . In a typical embodiment the budgets are created as budget objects as previously described with reference to . The default behavior of the interface may automatically link the newly created budget object to the caller s currently active budget to form part of a budget hierarchy . In one embodiment the caller may override the default behavior by optionally specifying a parameter that indicates the desire to escape the current hierarchy. By escaping the current hierarchy a budget effectively becomes its own root budget. Such a maneuver would release the budget from the constraints present elsewhere in the current budget hierarchy.

In most instances clients will not manage the creation of their own budgets as manually doing so would be difficult error prone and burdensome. Rather the task of budget creation is left to a human or software service acting as administrator with both the knowledge and authority to execute it correctly using a policy manager . In that case the policy manager may use the create budget interface to create the budget at the same time the process or thread with which the budget may be associated is created. The data used to generate a budget e.g. what parameters should be used to populate the budget limit L which reservations to perform in advance etc. may be garnered from the policy database or from automated administration software using heuristics to tune system behavior. In a typical embodiment the policy database may be populated in advance upon consideration of the availability of resources the nature of the client and user preferences.

Generally no resource is committed or reserved in a budget when it is initially created using the create budget interface . Therefore budgets which require pre population to achieve machine partitioning and isolation are typically first created by a policy manager using the create budget interface and then passed to a reserve resource interface to accomplish the necessary reservations as will be next described.

A budget may be dynamically associated with process groups processes or possibly threads at process creation time. For example in one embodiment once created using the create budget interface a budget may be passed as an argument to a routine that handles process or thread creation such that the new process or thread is automatically associated with and therefore subject to the resource restrictions specified in the budget.

The create budget interface may be used to externally partition resource usage by specifying a parameter indicating one or more flavors at the time of budget creation. In the absence of such an indication the default behavior of the create budget interface may be to create budgets having a single neutral flavor against which all resource usage is charged. Alternatively or in addition one or more flavors may be dynamically inserted into the budget following its creation as described with reference to the insert flavor interface below. This is in addition to the client s use of flavors to internally partition resource usage for example to limit exhaustion of resources by a particular task or to reserve resources for use in recovering from errors.

In one embodiment a reserve resource interface may be used by a client to reserve one or more resources for future use. In this manner a transactional means of acquiring resources is imposed on clients in order to avoid deadlock conditions involving the ordering of resource acquisition. However this is primarily an aid to the client if the client so desires the interface may be called multiple times to reserve resources independently or over time. Since reserving a resource generally makes that amount of resource unavailable system wide reservations are typically conservative in nature. Soft limits may be used to ameliorate the potential for overuse of reservations and to avoid the under utilization of resources.

In a typical embodiment once the reservation has been successfully made the reservation value R is updated to reflect the reservation and the client may commit up to this amount of the resource as represented in the budget s commit value C without the need for resource arbitration it may commit up to the limit L at the normal service level. When the limit L of the budget is a soft limit the client may commit resource in excess of the limit L at a degraded service level such that the system may efficiently reclaim it for other Cn allocations in the future.

In one embodiment the reserve resource interface provides a means to validate the reservation request i.e. to admit or deny the reservation request in the context of the currently active budget and applicable budget hierarchy if any. The actual reservation of the corresponding resource is typically handled separately by the resource provider itself. In this manner two levels of control upon resource requests are enforced one by the resource manager in accordance with the currently active budget and budget hierarchy if any and one by the resource provider . Thus a reservation request that may be admissible in terms of the currently active budget and budget hierarchy may fail when presented to the appropriate resource provider and likewise a reservation request that would have been deemed acceptable by a resource provider may be preemptively denied by the resource manager .

Once the reserve resource interface is used to validate a particular reservation request in the context of the applicable budget hierarchy the responsibility of determining whether the actual resource reservation can be satisfied i.e. allocated given all outstanding reservations falls upon the resource provider . Accordingly a register admission callback interface may be provided so that the resource manager can confirm whether the client s reservation request was or was not granted by the resource provider . Reservation requests that have been granted render that portion of the resource unavailable for normal commit Cn use by other clients . Therefore when the request is granted the resource manager updates the appropriate budget or budgets in the budget hierarchy to accurately reflect the current state of outstanding resource reservations.

In one embodiment a query budget interface may be used by a client to examine specific restrictions and requirements maintained in their budget . For example the ability to query a budget may be particularly useful for clients that inherit a budget or have an externally assigned budget. By examining the current state of their budgets the clients may make an informed decision on how to adjust their resource usage to stay within their budgets. For example after querying their budget a client may wish to register with the resource manager and resource providers to receive notifications that a desired resource has become available and the like. As another example rather that waiting to receive a notification the client may decide instead to modify their budget as they deem necessary in an effort to more quickly obtain the resources that they need assuming that they have sufficient authority to do so . As a further example resource managers may use notifications to request that cooperating clients reduce their resource consumption by reducing the sizes of their cached information or changing the set of algorithms being used to tradeoff space vs. time or time vs. space. Resource managers may further adjust the limits in budgets to keep the system from running too short on resources.

A record consumption interface may be provided to resource providers to track the consumption of resources over time. In one embodiment each resource provider participating in the resource management system is responsible for invoking the record consumption interface after the allocation of a supported resource to a client i.e. after the resource is committed. The resource manager may then track the committed resource value Cn in order to facilitate any possible future resource manager decisions aimed at reclaiming resources. In contrast tracking and managing which portion of the committed resource may be classified as excess commit Ce is typically left to the resource provider as described below with reference to surplus amounts.

In a typical embodiment the use of the record consumption interface to track the consumption of a resource does not require that the amount have been reserved in advance e.g. by using the reserve resource interface . When a resource is available it is by default implicitly reserved at the time it is allocated to the client . Should enforcing the currently active budget prohibit the resource manager from admitting the full amount of the recorded consumption as part of the normal commit Cn the record consumption interface may report back the surplus amount to the resource provider . In that case resource providers that support soft limits may optionally disburse the surplus amount to the client as excess commit Ce assuming the client has indicated that excess commit Ce resource is acceptable. Since excess commit Ce resources may be more readily reclaimed then normal commit Cn some clients may prefer to forego excess commit and wait until resources that can be allocated at normal commit are available. In the case of most implicitly consumed resources the associated resource provider typically has considerable flexibility in managing excess commit Ce allocations of resources.

In a typical embodiment the resource provider specifies in the record consumption interface the identity of the resource being charged. In this manner the resource manager is able to charge the consumption to the correct resource. Further the resource manager may also determine whether a dynamic limit needs to be inserted into the budget using the insert limit interface as in the case of certain dynamically introduced resources as will be described in further detail below.

A set sentinel interface may be provided to policy managers clients and services to register for a one time notification when the normal commit Cn value tracked for a particular budget has exceeded the budget s sentinel value . Should additional notifications be desired the policy managers and clients may explicitly re register using the set sentinel interface . In one embodiment the registrant may specify the desired method of notification delivery which will include at least all of the notification mechanisms supported by resource manager as generally described with reference to . As an example sentinel based notification may be useful to change a resource billing model once the resource consumption exceeds the budget s sentinel value.

An insert limit interface may be provided to policy managers to dynamically insert limits L into budgets . For example when resources are consumed by a service operating on behalf of a client as described with reference to services may insert limits in the client s active budget to control the rate at which a client can force a service to deplete the latter s resources through the use of the insert limit interface . On subsequent invocations the client will be subjected to the dynamically inserted limit. In a typical embodiment only trusted policy managers and services may possess the requisite privilege to perform a dynamic limit insertion into a target budget as maliciously inserting low limits into client budgets may constitute a denial of service attack.

An insert flavor interface may be provided to clients including services and drivers operating on behalf of clients to dynamically insert flavors into budgets as previously described with reference to . In one embodiment a client may use the insert flavor interface to perform flavor insertion on its own currently active budget. Dynamic flavor insertion into budgets belonging to different clients may defeat the purpose of flavors which are generally intended to provide clients a means of managing their own resource use within the constraints imposed by their own budget. To avoid this difficulty internal and external partitioning of resources using flavors must rely on distinct sets of flavors.

In the example introduced in a service may use the insert flavor interface to delineate a flavor partitioning of its budget based on the identification of a particular client on whose behalf it is operating. Establishing a mapping between the client and flavor is left entirely to the service. A similar scenario may be employed by drivers that would like to ration their resource usage based on the particular client on whose behalf resources are being consumed. Thus the burden of flavor management falls upon the service or driver that chooses to dynamically insert them using the insert flavor interface .

Alternatively or in addition in cases where there is no need for dynamic flavors such as network drivers wishing to partition their allowed memory usage between a pre defined static set of packet types flavors need not be dynamically specified using the insert flavor interface . Rather the desired flavors can be specified at budget creation time using the create budget interface possibly yielding a performance benefit.

Flavors are also useful for implementing error recovery and improving software robustness and reliability. By reserving resources with a flavor used only for recovering from low resource situations in a system software can still function sufficiently to recover. For example a client needs enough resources available to respond to a resource manager notification that it should reduce resource consumption by shrinking caches.

Lastly a set budget interface may be provided to services and other components to among other uses temporarily attach a process or thread executing on behalf of a client to a particular budget such as described with reference to the client resource identity impersonation scenario in . For the duration of the attach operation all of the service s resource usage may be charged to a specified budget. In cases in which a resource is reserved allocated and released during the period of attachment the set budget interface provides a way for services performing operations directly on behalf of a requesting client to charge resource consumption against the client s budget and not their own.

The foregoing discussion has been intended to provide a brief general description of a computing system suitable for implementing various features of the invention. Although described in the general context of a personal computer usable in a distributed computing environment in which complementary tasks may be performed by remote computing devices linked together through a communication network those skilled in the art will appreciate that the invention may be practiced with many other computer system configurations. For example the invention may be practiced with a personal computer operating in a standalone environment or with multiprocessor systems minicomputers mainframe computers and the like. In addition those skilled in the art will recognize that the invention may be practiced on other kinds of computing devices including laptop computers tablet computers personal digital assistants PDAs cell phones game consoles personal media devices or any device upon which computer software or other digital content is installed.

For the sake of convenience some of the description of the computing system suitable for implementing various features of the invention included references to the WINDOWS operating system. However those skilled in the art will recognize that those references are only illustrative and do not serve to limit the general application of the invention. For example the invention may be practiced in the context of other operating systems such as the LINUX or UNIX operating systems.

Certain aspects of the invention have been described in terms of programs executed or accessed by an operating system in conjunction with a personal computer. However those skilled in the art will recognize that those aspects also may be implemented in combination with various other types of program modules or data structures. Generally program modules and data structures include routines subroutines programs subprograms methods interfaces processes procedures functions components schema etc. that perform particular tasks or implement particular abstract data types.

