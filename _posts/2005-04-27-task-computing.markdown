---

title: Task computing
abstract: Task Computing computer system by segmenting the system into a plurality of implementation tiers of a presentation layer, a remote procedure call programming interface (API), a middleware layer to which the presentation layer interfaces via the remote procedure call API to real-time, dynamically generate a computer implemented task interface at the presentation layer to a semantically described source of function as a service on a computer system, and a service layer and a function source realization layer providing the semantically described source of function as the service on the computer system to which the middleware layer interfaces. Real-time and dynamically composing an executable task that comprises one or more services using the generated task interface at the presentation layer to one or more services on the computer based upon the semantically described application-, device- and service-rich computer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761885&OS=07761885&RS=07761885
owner: Fujitsu Limited
number: 07761885
owner_city: Kawasaki
owner_country: JP
publication_date: 20050427
---
This application is related to and claims the benefit of priority under 35 USC 119 to Provisional Application U.S. Ser. No. 60 565 851 entitled TASK COMPUTING SYSTEMS by Yannis Labrou Ryusuke Masuoka Duy Huynh Zhexuan Song and filed Apr. 28 2004 in the U.S. Patent and Trademark Office the contents of which are incorporated herein by reference.

This application is related to and claims the benefit of priority under 35 USC 119 to Provisional Application U.S. Ser. No. 60 603 251 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song and filed Aug. 23 2004 in the U.S. Patent and Trademark Office the contents of which are incorporated herein by reference.

This application is related to and claims the benefit of priority under 35 USC 119 to Provisional Application U.S. Ser. No. 60 628 557 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song and filed Nov. 18 2004 in the U.S. Patent and Trademark Office the contents of which are incorporated herein by reference.

This application is related to and claims the benefit of priority under 35 USC 119 to Provisional Application U.S. Ser. No. 60 639 805 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song and filed Dec. 29 2004 in the U.S. Patent and Trademark Office the contents of which are incorporated herein by reference.

This application is related to U.S. Ser. No. 10 733 328 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song filed Dec. 12 2003 in the U.S. Patent and Trademark Office the contents of which are incorporated herein by reference.

The present invention is directed to real time dynamically composing and executing complex tasks based upon semantically described application device and service rich computing environments.

Personal Computing may be referred to as a paradigm in which a user operates a single device and accesses uses applications that reside on that device. Personal computing requires that the user has a sufficient understanding of the user s computing environment and of the applications that are available on the user s computer so that as a knowledgeable user the user can adequately utilize the available resources to execute complex tasks. This is computing as most users experience it on a daily basis the burden of learning how to achieve complex tasks resides with the user who has to understand each of the applications running on the user s machine and of the functions that the user s machine supports to manually transfer data between applications cut paste to manually invoke each application and the specific functionality that relates to the task and to eventually devote full attention and time to the execution of the complex task. Accomplishing complex tasks relies on the user s understanding of the task on one hand and of the available resources devices and applications on the other so that the user can combine them into a workflow that the user will execute and the final outcome of which will be a completed task.

A shift from Personal Computing to a more task oriented view of the computing environment would be as follows 

For example as one feature of an operating system when the user inserts a music CD into the CD tray a window pops up suggesting to the user tasks the user can perform from that point on. A typical listing of these options can include 

Each of these options also mentions the application to be used to perform the action. The focus is on the action or task to be performed rather than the application used to perform the task.

However here the operating system uses a pre specified list of actions or tasks that are associated with the occurrence of a specific event inserting a music CD or connecting a digital camera so that when the event occurs the relevant listing of actions is presented to the user to act upon. In that sense the system s response is hardwired and does not include flexibility beyond that which as been programmed into the system as to the possible actions to be performed as a result of the triggering event. In other words the system shows the same set of the actions that can take place when a digital camera is connected to the computer the programmer of the operating system has prepared this specific list of actions for the particular event. Applications can change the items in the list but there is not an easy way for end users to change it.

In another example of an operating system the user may be presented with a choice of actions depending on a file type. That is a separate list of tasks is presented to the user for each of the following file types Documents Pictures Photo Album Music Music Artist Music Album and Videos. For example if the file type is a picture a list of picture tasks is presented 

This list of tasks is again pre compiled and associated with the specific file type. There is not an easy way for end users to modify the list.

In another example of office suite software a smart tags feature is available. The smart tag feature highlights text in the current document while using an editor and offers the user a drop down menu of actions that can be performed with the object that that text denotes. For example if the text represents a name then this feature may identify the object associated with that name to be a person and may offer the following list of possible actions 

The options are enabled by identifying that the string of characters in the document might represent a name. The system relies on the syntactic features of the text to identify that this particular piece of text represents a name. However a string of characters that does not resemble a typical American name e.g. Lusheng Ji may not be identified as a name related to a person. The reason is that the part of the system that identifies a piece of text as a name is a pretty simple program script that attempts to identify easily identifiable patterns in the syntactic form of the text. Once the nature of the text is identified correctly or incorrectly e.g. person address etc. a pre compiled list of possible actions is presented to the user. It is possible for application programmers to create smart tags for other domains and applications such as identifying addresses and invoking a map application etc.

Another example of an attempt to present to the user a more task oriented view of the computing environment is now discussed. When a user types an address in the search box of a search engine the service will return above the usual search results a link to a mapping function that if followed will provide a map of the address.

However it is not obvious that the user might be searching for the map of the typed address. Other reasonable possibilities exist the user might want a phone number listing associated with this address or if that address is a business the user might want to see the BETTER BUSINESS BUREAU record for the searched business or to check the weather in that vicinity and so on. In its current form the search engine guesses what type of thing in this case an address the typed text stands for and it returns a hard wired task associated with this type of entry.

Therefore in a task oriented view of the computing environment the focus is on the task that can be performed and not on the application to be used for executing the task. Moreover the user does not need to know which application will be used for the task. If the user chooses to execute one of the suggested tasks the proper application will be instantiated accordingly and invoked launched .

However the computing examples mentioned above exhibit similar features that do not allow real time dynamic composition of executable tasks as follows. In some manner the type or nature of the user s input text or event is guessed in effect the system attempts to infer the meaning semantics of a string relying on its syntactic features. A system makes a guess of plausible tasks that the user might wish to perform given that input that guess is hardwired into the system so effectively it is not the system that makes the guess in real time but it is the programmer of the system that made the guess when programming the system way before the user interacts with the system. The appropriate application is automatically invoked upon the user s selection whatever the user selected in a second step instantiated with the proper input whatever the system guessed in a first step a static cause effect or trigger response mechanism.

Although the above computing examples can increase the user s convenience the conventional systems still retain the following personal computing features 

The functionality has been designed into the application the application s programmers have programmed hard wired the system s response. As a result this is not a flexible and scalable approach because the range of possibilities has been decided during design time.

The system has limited ways to accommodate the user s actions and wishes and it cannot accurately perceive the nature semantics or meaning of the input. Despite the different technologies used in each of the examples the system relies on correctly guessing the meaning of the input by its syntactic features.

The system employs a cause effect or trigger response mechanism in the sense that a certain type of input results to a single action application invocation . Complex user tasks entail more complex workflows with complex sequences of events and actions that would not be possible technologically speaking with the simplistic techniques used in these discussed examples.

Also Personal Computing i.e. the idea of a user owning and operating a computer that runs the user s applications and holds the user s data is giving way to computing environments with less well defined boundaries. As computers get permanently connected to computer networks the distinctions between local and remote applications and data collapse or even worse they are confusing to computer users. Moreover users can access and interact with devices that are not computers in the sense of personal computers but still possess significant computing power and can serve the users goals and help them accomplish a variety of tasks cameras printers smart appliances etc. . For one thing the average user may not even be aware of what is possible or feasible in such computing environments as available resources devices and applications may be constantly changing. In other words the personal computing approach is infeasible in a setting replete with devices and applications that are not a priori known to the user.

Accordingly there is a need to real time dynamically discover publish compose manage and execute tasks in a computing environment often referred to as ubiquitous pervasive computing environment which requires a fundamentally different approach to the problem of the user accomplishing tasks in the computing environment.

It is an aspect of the present invention embodiment described herein to provide a real time dynamically discovering publishing composing managing and executing complex tasks based upon semantically described application device and service rich computer computing computer system environments.

According to another aspect of the embodiments described herein a user can practically effectively efficiently dynamically in real time rely on a flexible and unified task user interface discovering publishing composition service and or task management and execution functions to manage interaction and to interact with a pervasive computing environment.

Task Computing is a new paradigm to real time dynamically discover publish compose manage and execute complex tasks in application device electronic service and content rich computer network environments i.e. execute tasks in realization layer . Task computing is based upon semantically describing e.g. through Semantic Service Descriptions SSDs services of computing devices that according to their semantics can be composed on the fly by end users into executable tasks. Therefore according to the embodiments described herein Task Computing system has a multi layer computer system architecture of three or more programmed computing and or computer readable information layers e.g. semantic instances Semantic Service Descriptions of a presentation client processing layer a middleware server processing layer to which the client layer interfaces via a remote procedure call mechanism and a plurality of services in a plurality of computer systems layer.

According to the embodiments described herein the term service refers to computational embodiments of functionality from universe of function source realization layer of computer devices computer applications software electronic services and computer or machine or both readable content.

The term task refers to a composition of one or more actions according to discovered computer system services that for example a user wants to perform. According to the embodiments described herein a task is automatically user driven or any combination thereof is composed and managed via a computer implemented task interface . In case of a user a task as a composition of one or more services is managed e.g. discovered published composed executed etc. at the presentation layer . In an unlimiting example a composition of services view on projector weather info of business address of my contact is a task that comprises four services of view on projector weather info business address and my contact. In other words a task comprises a composition of one or more services .

The term composition refers to forming by putting together a plurality of services according to provided functional characteristic s of services as semantically described such as without limitation semantic inputs and outputs of a service for example data object type for input consumption output production of the service . An example of a functional characteristic of a service can be a precondition and an effect of the service to determine service composability. An example of a precondition and an effect of a service can be input and output data object types for a service .

The term semantic instance or semantic object refers to a set of descriptions on some item based on one or more ontology. A Semantic Service Description SSD describes a service function based upon one or more service function ontology.

The term publish refers to making the Semantic Service Description SSD available through one or more service discovery mechanisms.

TASK COMPUTING designates a type of computer system that supports automatic or user driven or both any combination thereof real time dynamically discovering publishing composing managing and executing a task that comprises one or more services based upon semantically described application device and service rich computer computing computer system environments .

Two Task Computing Client embodiments referred to as Semantic Task Execution EditoR STEER software to discover and compose into executable tasks the semantically described services and as Pervasive Instance Provision Environment PIPE software to publish and manage semantic instances and or semantic services are described in related commonly assigned pending U.S. patent application Ser. No. 10 733 328 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song filed Dec. 12 2003 in the U.S. Patent and Trademark Office owned by FUJITSU LIMITED assignee of the present Application the entire contents of which are incorporated herein by reference. The embodiments described herein relate to technologies and or in improvements in technologies used for real time dynamic composition of semantically described services into executable tasks as well as management e.g. discovery creation publication manipulation etc. of the semantically described services .

In according to the embodiment s described herein one or more Task Computing Systems TCSs are provided according to a client server computer system architecture based upon a remote procedure call mechanism. A TCS is logically and in implementation segmented into a presentation processing layer providing client type programmed processes as Task Computing Clients and a middleware processing layer providing server type programmed processes in which the segmented presentation and middleware processing layers are interfaced according to any remote procedure call mechanism such as Web services WS as a Task Computing Environment Web Service Application Programming Interface TCE WS API . The concept of Web services is well known. Therefore according to the embodiments described herein generally a TCS comprises a Task Computing Client TCC providing client type processes at the presentation layer and the TCC interfaces with the middleware server processing layer via a remote procedure call API such as Web services WS in which case the TCC is referred to as a WS TCC . A TCS that uses Web services as an example of a remote procedure call mechanism is herein referred to as WS TCS . By using a remote procedure call mechanism such Web services any application including third party applications e.g. MICROSOFT WORD EXCEL OUTLOOK ADOBE ACROBAT etc. that can make a remote procedure call such as Web service calls or can incorporate remote procedure invocation capability could become a Task Computing Client TCC . The embodiments described herein use Web services as an example of a remote procedure call mechanism however the present invention is not limited to such a configuration and any remote procedure call mechanism can be used.

Therefore using Web services as an example of a remote procedure call API Semantic Task Execution EditoR Web Services Task Computing System STEER WS TCS is an example of a WS TCS which comprises a STEER WS Task Computing Client STEER WS TCC at the presentation processing layer interfaced via a STEER WS API with the middleware server processing layer .

A Pervasive Instance Provision Environment Web Services Task Computing System PIPE WS TCS is another example of a WS TCS . A PIPE WS API exposes middleware server management tools that are generally used for managing e.g. creating publishing removing manipulating etc. semantic object instances and or SSDs used in Task Computing as well as managing tasks . An application client that uses PIPE WS is herein referred to as a Semantically Described Service Control Mechanism SDSCM examples of which are White Hole Service Manager Real world object semanticizer and database semanticizer described in more detail below. For example a WS TCS that uses PIPE WS comprises a Web services Task Computing Client application client or SDSCM such as White Hole Task Computing Client White Hole at the presentation processing layer which interfaces via the PIPE WS API with the middleware server processing layer .

Through the use of Web services Task Computing Clients WS TCCs such as without limitation STEER WS TCC and White Hole Service Manager Real world object semanticizer and database semanticizer as programmable computing components e.g. Task Computing Client software at the presentation layer users can manage e.g. discover publish compose execute manipulate tasks based upon semantically described services made available by the middleware server processes through TCE WS API .

In according to today s computing environments a user is surrounded by functionality referred to as the realization layer which comprise devices or computer mediated services such as electronic services e services available over the Internet applications that run on computing devices that the user operates content available on a computer readable medium or simply devices that support a specific function. Examples of such devices application e services and content include without limitation telephones computer displays cameras entertainment devices centers televisions Personal Digital Assistants PDAs radio communication devices e.g. mobile phones etc. audio players fax machines printers weather services map services office suite computing software e.g. email application address book etc. multimedia computer readable media e.g. music compact disc movie digital video disc DVD etc. Internet sites databases etc.

In the functionality or services presented by the realization layer can comprise for example without limitation listening to music e.g. in case of an entertainment device downloading songs watching streaming videos listening to radios providing contact information checking addresses on a map etc. Conventionally the realization layer has been designed to provide functionality to the user by means of the user interacting with and or operating each device or service for example if the user want to call a colleague with the phone provided in the room she is visiting and the phone number of the colleague is stored in the user s electronic address book application on the user s laptop the user must start laptop application look up the phone number in question and then dial the phone number manually on the phone. In other words a user cannot compose a task . Even when the applications e services and devices can physically communicate with one another i.e. a communication link among them exists they cannot exchange data in a way that is meaningful to the user s task unless the designers of the realization layer have designed the computer system source of function for example a computing device with that specific task in mind. When faced with plethora of sources of functions the user cannot perform tasks that utilize functionalities from all these sources unless the sources of functions have been designed for that task. Moreover the casual user is often not unaware of what such tasks are possible.

In according to the embodiment described herein the service layer comprises a service function from the function source realization layer and a semantic service description correspondingly semantically describing the service function of the function source realization layer as the service of the computer system as networked non networked or both . According to an aspect of the embodiments described herein the relationship between service function and SSD can be many to many n m for a particular function source . For example one SSD to a plurality of service functions where one saves a service function composition with a plurality of service functions in the composition as an SSD . And one service function to many SSDs where one gives a plurality of kinds or types of semanticization of a singe service function . For example in a case where a book lookup service function which returns authors prices photos etc. for an ISBN input can be grounded by semantic services such that one returns the author contact and another SSD returns an image etc. More particularly according to the embodiments described herein a service layer comprises service functions available by the realization layer and Semantic Service Descriptions SSDs corresponding to the service functions together forming available computer system as networked non networked or both services . The SSD exposes on a computer network a service function of a realization layer . Certain embodiment s of SSD is are described in the related commonly assigned pending U.S. patent application Ser. No. 10 733 328 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song filed Dec. 12 2003 in the U.S. Patent and Trademark Office owned by FUJITSU LIMITED assignee of the present Application the entire contents of which are incorporated herein by reference.

Therefore Task Computing is a new paradigm for how a user interacts with service functions of realization layer sources of functions for example a computing device that emphasizes a task that the user wants to accomplish while using the computing device rather than emphasizing the specific means for how to accomplish the task. Task computing fills the gap between what users want done and a service function of a computing device that might be available in their environments. Task computing presents substantial advantages over traditional approaches such as the current personal computing paradigm namely it is more adequate for non expert computer users it is a time saver for all types of users and is particularly suited for the emerging pervasive computing type of computing environments.

In therefore according to the embodiments described herein to provide a computer system architecture software and or programmable computing hardware that would be flexible to extend and build upon a distinct and modularized middleware server processing layer is created whose functionality is made available to the presentation processing layer through remote procedure call application programming interfaces APIs so that application developers and users can use them to access Task Computing functions such as service discovery and composition into executable tasks including construction save execution monitoring publishing management etc. of services and or tasks . A remote procedure call mechanism such as for example Web services provides location i.e. different processing layers on different computers platform and programming language independence required for end user application development.

As discussed above ubiquitous pervasive networked computer computing environments are populated by a multitude of devices and other functionality e services applications content that is often transient in nature moreover end users or even developers that are creating an application for a ubiquitous environment might not know in advance what functionalities resources and corresponding service functions could be available at a given time and more importantly what they can be used for. To take advantage of this dynamism it is necessary that service functionalities can be discovered and combined at runtime rather than design time. Therefore the embodiments described herein use as an example Semantic Web technologies because if computer network resources are sufficiently self described by machine readable semantics it is possible to build an infrastructure that understands enough about the resources as computer system services to permit end users do what application developers typically do by bringing their own understanding of what resources provide and can be used for. The concept of Semantic Web is well known.

More particularly according to the embodiment s described herein the Task Computing utilizes the well known concepts of Semantic Web and Web services. However to deliver a real functioning system in a truly dynamic and ad hoc ubiquitous computing environment according to the Task Computing described herein the following are established and implemented 

 1 As shown in providing a task interface to computer system sources of functions . The task interface comprises a Task Computing System TCS logically segmented into 1 a presentation processing layer that comprises a Task Computing Client TCC and 2 a middleware server processing layer to which the TCC at the presentation layer interfaces with a remote procedure call mechanism API such as Task Computing Environment TCE Web Services API for example STEER WS API and the PIPE WS API . The API exposes the middleware server processing layer to be interfaced by the presentation processing layer . The task interface also comprises a Semantic Service Description SSD layer that semantically describes service functions . An SSD is discovered by the middleware processing layer to be presented at the presentation layer via a TCC and a service function is executed for example as part of a task to be executed by the middleware processing layer according to a control command provided for example at the presentation layer via the TCC and based upon the SSD for service function to be executed.

 2 Separation of semantic service descriptions SSDs and service implementations to provide together a service layer 

 3 Separation between discovery of a service or a saved task as the case may be mechanisms and discovery ranges and manipulation capability of services within and between those ranges by conceiving a concept of sphere as a subset of remote procedure call API running on computers and accessible by remote Task Computing Clients to achieve discovery ranges for services .

 4 Ability for users and applications to dynamically create and manipulate services that can be made available and shared with others or made unavailable when necessary i.e. provide service control management and

Therefore as shown in the separation of the above described layers is both logical conceptual and in implementation useful in building a Task Computing where the user can perform complex tasks that have not been neither implicitly nor explicitly designed into the computer network system thus multiplying the uses of the sources of functionality devices applications content and e services . The present invention is not limited to the Semantic Web and other semantic type technologies or framework that allows data to be shared and reused across application enterprise and community boundaries can be used by the embodiments described herein.

In the function source realization layer as the bottom most layer encompasses the universe of computer devices computer applications software electronic services and computer or machine or both readable content where all functionality available to the user originates. Service functions described in more detail below of the function source are computational embodiments of functionality. Such service functionality generally emanates from at least three different types of sources devices applications software and over the Web e services. These three sources are loosely defined and unlimiting categories because the boundaries between them can be highly malleable. In an example device originating services are the core functionality that the device is designed to deliver. For example a phone s device main functionality is making phone calls service . Similarly application software originating functionalities are service functions of the software that is executing on a computing device . For example a personal information management PIM application s functionalities includes storing and retrieving contact information of persons. Finally e services and or content s service functionality is for example a service function that is executing on some remote server to deliver the service functionality through access to the Web beyond the boundaries of a user s local network. Contents as a fourth source of functionality can be very useful namely content that is made available as a service function this type of service function can be very convenient as an information sharing mechanism between users. Therefore services herein refers to computational embodiments of functionality from universe of function source realization layer of computer devices computer applications software electronic services and computer or machine or both readable content. Therefore a service as a computational embodiment of functionality from a function source realization layer has interface characteristics for interacting with the service which can comprise a description of the service including name of the service function s performed etc. and functional characteristics of the service such as input output to the service . Further according to the embodiments described herein a computer implemented user interface to a computer system service is according to semantically described based upon ontology input data and output data of a service . For example a service described in a Semantic Service Description SSD to display a file on display projector can be named View on Projector which accepts a File as input and no output parameter.

In the service layer is sources of functionality made computationally available as service functions via Semantic Service Descriptions SSDs . The SSDs allow discovery and access to execution of the service functions . Each service function is associated with at least one Semantic Service Description SSD which for example is encoded according to OWL S which is a Web service ontology language based upon Web Ontology Language OWL using the Resource Description Framework RDF Extensible Markup Language XML exchange syntax and a SSD can be created on the fly via PIPE WS TCC as services might be created made available dynamically. The SSD embodiment described is not limited to an OWL S implementation and any computer interpretable language construct for describing properties and capabilities of computer system service functions including Web services can be used. The SSD comprises three parts profile process and grounding where the profile part allows users to manipulate the service in semantic layer and the grounding part allows users to actually invoke services . Services represent available functionality in the Task Computing universe and SSDs of these services are meant to shield the user from the complexity of the underlying sources of service functionality and make it easy for the user to employ these service sources in accomplishing interesting and complex tasks. An embodiment s of Semantically Described Services is described in related commonly assigned pending U.S. patent application Ser. No. 10 733 328 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song filed Dec. 12 2003 in the U.S. Patent and Trademark Office owned by FUJITSU LIMITED assignee of the present Application the entire contents of which are incorporated herein by reference.

In middleware server processing layer components are responsible for discovering services or deciding how services can be composed into executable tasks executing the services and monitoring service execution and enabling and facilitating a variety of management operations including the creation and publishing of semantically described services . In other words the purpose of the middleware processing layer components is to abstract all service resources as semantically described services that can be made available e.g. at the presentation layer via TCCs to either users or the applications that seek to manipulate them.

In the presentation processing layer utilizes the capabilities of the middleware processing layer to enable users to execute tasks by combining all available service functionality . A variety of programmable computing clients e.g. software clients programmable computing hardware clients or both etc. using Web services referred to as WS TCCs WS applications and or WS web based interface applications accessible with a web browser herein all referred to as a WS TCC are provided to execute tasks by combining all available service functionality via the middleware processing layer . According to an embodiment described herein the middleware layer components are exposed through well defined Web services application programming interfaces WS APIs thereby allowing creation of WS Task Computing Clients WS TCCs that utilize these APIs .

Defining the task computing environment Web services APIs at the middle processing layer for unrestricted accesses to the core functionalities of Task Computing such as service discovery composition execution save creation management opens a whole array of possibilities. For example WS TCCs are not bound to a particular implementation of Task Computing modules as long as a user can make Web Service calls the user can work on any platform and use any programming language to create WS TCCs and access services .

In therefore according to the embodiments described herein a Task Computing Environment Web Services TCE WS API is provided. Subsets of the TCE WS API can be used for various task computing purposes and herein are referred to as STEER WS API when used in the STEER WS TCS PIPE WS API when used in one or more PIPE WS TCSs and Sphere of Management SoM WS API when used to provide a Sphere for cross environment task computing as discussed in more detail below . According to the embodiments of the present invention herein will be described the following 

Herein will be described in more detail various Web Services Task Computing Client WS TCC embodiments such as Semantic Task Execution EditoR Web Services STEER WS TCC which is based upon the STEER WS API and is software to discover and compose into executable tasks the semantically described services . A STEER WS TCC as a presentation layer component of a WS TCS provides a variety of computer implemented user interfaces. Therefore herein will be described a computer displayed graphical user interface referred to as STEER WS Extended XT TCC a computer displayed graphical user interface embodied in a radio device such a mobile phone and referred to as Mobile PhoneSTEER WS TCC a STEER WS Spatial Information System SIS TCC a VoiceSTEER WS TCC and a Tasklet WS TCC .

Also herein will be described application clients based upon PIPE WS API which are Semantically Described Service Control Mechanism SDSCM to manage services such as create remove modify services . In particular herein will be described a Service Manager Real world object semanticizer a database semanticizer and a media publisher .

Also herein will be described a concept of sphere of management for cross environment service discovery and execution.

Also herein will be described an expanded usage advanced behaviors of Semantic Service Descriptions SSD such as communication language accommodation e.g. spoken language internationalization and new parameters. A SSD is a vehicle to communicate parameters of the service from the service itself to WS TCCs . More particularly new kinds of parameters to enhance the Task Computing environment are implemented comprising a Relaxed Type for service input locations of services multi language services and service management functions.

Also herein will be described Task Computing Client internal services such as Instance Creator Instance Copier Instance Interceptor Instance Saver and Property Chooser.

Also herein will be described new services are designed and implemented which include 1 semantic instance serializing services 2 information providing services 3 time temperature services 4 snapshot services 5 OWL formatter service and 6 text formatter service.

In according to an aspect of the embodiments described herein an SSD window displays SSD parameters properties for a selected service in the service window . The SSD window can be useful for example in testing a task as part of composing a task .

In the task window provides selectable graphical displays of services that have been selected in the discovered services window . In the task window upon selection of a discovered service compatible services according to service s functional characteristic based upon ontology are automatically identified and a graphical display of the service also automatically comprises one or more selectable functional characteristic buttons representing available or valid compatible services for the selected discovered service. Selection of a functional characteristic button displays a selectable list of other discovered services that can consume produce of a preceding service whereby composition of one or more services together as indicated by displayed lines connecting the graphical displays of services creates a task . More particularly in the task window a user composes a directed service graph as a task . In case of using input output data object type of a service as functional characteristics of the service an output functional characteristic button is differentiated from an input functional characteristic button by color or any other known computer display differentiation methods.

Other STEER WS TCC computer implemented user interfaces of Mobile PhoneSTEER WS TCC STEER WS SIS TCC VoiceSTEER WS TCC and Tasklet WS TCC will be described in more detail further below.

With reference to Task Computing system has an architecture that provides a foundation for finding the services available in the current environment constructing and manipulating a user centric task view of the available services and executing the resulting tasks composed of multiple services. It even lets the end users dynamically and easily create new services as necessary. Three characteristics elements of Task Computing system are as follows 

 1 Uniform abstraction of all functionality as services . As discussed herein in Task Computing the middleware server processing layer serves to abstract all resources as semantically described services . A semantically described service is a service function available through remote procedure calls such as without limitation WSDL Web Service Description Language a UPnP Universal Plug and Play CORBA RMI RPC DCE DCOM service functions for which a semantic description a file in a language intended for describing services for example OWL S has been specified. When specifying such semantic descriptions a specified ontology is specified for the domain that the service act upon. Regarding ontologies software tools can be used to create ontologies and whenever possible existing or available ontologies can be used. The OWL S service descriptions express a functional characteristic of a service function being semanticized for example the input and output as semantic objects and the owner creator location etc. of the service . The description also includes grounding information so that the actual WSDL and or UPnP service can be properly executed. In providing these descriptions semanticizer tools such as without limitation real world object semanticizer database semanticizer internal service instance creator etc. described and or referred herein have been used for mapping ontology objects to WSDL parameters and creating any necessary grounding grounding is expressed through XSLT scripts . Web Service interfaces have been provided for the middleware server processing layer based upon which an intuitive task user interface at the presentation client processing layer is provided.

The Task Computing middleware can also be viewed as a dynamic repository of semantic service descriptions. Apart from the APIs for accessing and manipulating these descriptions which are discussed herein means is provided for querying this repository directly by implementing a API that will process any RDF Query Language RDQL query against the service descriptions JENA 2.0 is used as an example for the processing of RDQL queries . For example the developer could filter the services presented to the user for task composition by some feature of the services such as location even though an explicit API for that purpose is not provided. This capability extends the power of the application developer and as certain queries become more useful they can be permanently added to the middleware as APIs that execute pre specified RDQL queries.

Abstraction of functionality as services makes functionality universally accessible and allows the Task Computing infrastructure to interact with such functionality. A Task Computing system transforms the functionality of the user s computing device from applications and OS of the devices in the environment and of the available eservices on the Internet into abstracted services . This abstraction paves the way for having fewer pre arrangements to deal with the functionalities available in the environment but by itself alone might not suffice to provide user real time manipulation and composition of functionalities into tasks so that the embodiments described herein also provide a presentation layer to support real time dynamic management of a task that comprise a plurality of services .

 2 Provide intuitive to a user and or a system manipulation of abstracted services based on semantic service descriptions SSDs . Intuitive manipulation of services is made possible through the use of Semantic Service Descriptions SSDs ontologies are the mechanism for achieving such a user and or system intuitive manipulation. The concept of SSD is described in related commonly assigned pending U.S. patent application Ser. No. 10 733 328 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song filed Dec. 12 2003 in the U.S. Patent and Trademark Office owned by FUJITSU LIMITED assignee of the present Application the entire contents of which are incorporated herein by reference.

If for example instead of SSD only WSDL Web Service Description Language source of function is used to describe the functional characteristics of a Web Service the WSDL described Web Services requires that programmers understand their semantics beyond the WSDL descriptions and develop the code to use the services in the right way. As a result end users interaction with functionalities is limited by the scope of these programs in ways predefined by the developers. The additional semantics supplied in an SSD by mapping ontology objects to source of function parameters such as without limitation WSDL parameters and creating any necessary grounding allows the Task Computing infrastructure to help users manipulate the services without this deep knowledge. For example semantics can be used to constrain the manipulation of services by users or to present the user possible tasks in the current environment. If only WSDL is relied upon for a service composition based on semantic inputs and outputs of services the composition would not be restricted to any compositions of a service that produces for example an XML Schema Definition XSD string with another one that consumes an XSD string thus possibly leading to non executable or invalid service compositions. Therefore according to the embodiments described herein a composition refers to forming by putting together a plurality of services according to provided functional characteristic s of services as semantically described such as without limitation semantic inputs and outputs of a service for example data object type for input consumption output production of the service . An example of a functional characteristic of a service can be a precondition and an effect of the service to determine service composability. An example of a precondition and an effect of a service can be input and output data object types for a service . In particular the SSDs of services provide finer granularity of the services inputs and outputs so that for example a service that generates an Address semantic object will only be composable with semantically compatible services.

Another mechanism of providing user intuitive manipulation of services is by giving appropriate service names according to a natural language such as a Route from My Home to service name the composed service names of compatible services can serve as a natural language task representation s for example View on Projector My File Route from Company 1 to A City Name Airport . Ontologies can also support mechanisms such as compositions based on subclass super class relationships and semantic object translations that are very natural for end users. Therefore composition of a task is based upon a natural language sentence or in other words a composed task reads like a natural language sentence. More particularly the embodiments described herein provide assigning a name to the service as an element e.g. a phrase of a natural language sentence to support composability of the services to map into composability of natural language elements as a natural language sentence. Therefore Task Computing system allows very rich and interesting ways for the end users to interact with the services of the environment .

 3 A user can guide a real time and or dynamic late binding type composition of a task via a computer implement user interface based upon 1 and 2 for example as shown in .

As shown in by exposing the functionalities of Task Computing middleware server processing layer by Web services a WS TCC at the presentation processing layer can be freed from the implementation of the modules of the Task Computing middleware server processing layer . A WS TCC developer can use any programming language on any operating system as long as Web Service calls can be made thereby providing a WS TCC . Even third party applications MICROSOFT WORD EXCEL OUTLOOK ADOBE ACROBAT etc. that can make Web Service calls or can incorporate Web services invocation capability could be a potential WS TCC .

In functionalities such as discovery composition execution monitoring save and so on are supported in STEER WS API . Generally the TCE WS API such as STEER WS API and PIPE WS API described in more detail below with reference to rely on a Service identifier SID parameter which is something that uniquely identifies a semantically described service function described in an SSD . Typically according to the embodiments described herein SID is a string of a Uniform Resource Locator URL to the semantically described service function described in the SSD . For example shows an example computer source code that uses STEER WS API to synchronize the local knowledge about discovered services . shows another example computer source code of using STEER WS API to invoke tasks with multiple services . In an unlimiting example in ServiceList parameter is the input string that for example uses to delimit multiple tasks and uses I to delimit service identifiers within a task and a WS TCC can have the program loop of in its own code to invoke and monitor a task execution. Therefore in the present invention the source codes such as which utilize TCE WS API to invoke remote procedures in the middleware server processing layer are embodiment implementations of WS TCCs such as STEER WS TCC

According to an aspect of the embodiments described herein the service discovery modules discover service functions according to any service function discovery mechanism via the third party discovery module or remote site discovery module using a remote third party discovery module . The third party discovery mechanisms can be for example as Universal Plug and Play UPNP technology JINI technology BLUETOOTH etc. or any combination thereof. For example a CYBERLINK UPNP and or INTEL UPNP TOOLKIT implementation can be used in third party discovery module to discovery service descriptions broadcast within the sub network by UPnP. Also the service discovery modules can discover Semantic Service Descriptions SSDs via local discovery module and remote site discovery module .

According to an aspect of the embodiments described herein JENA by HEWLETT PACKARD DEVELOPMENT COMPANY is used to store SSDs . The parsing and indexing modules comprise parsing and analysis functions to parse and analyze SSDs . For example according to an aspect of the embodiments described herein an SSD is parsed using JENA by HEWLETT PACKARD DEVELOPMENT COMPANY with support of PELLET and OWL S API by MINDLAB UNIVERSITY OF MARYLAND USA. In particular a service is discovered is equivalent to the SSD of a service is found. A SSD which is discoverable by one of the service discovery modules is sent to the central module through the register interface where the SSD is first parsed for example by JENA with PELLET support. Once the SSD is parsed PELLET is ready to answer RDQL queries. By asking queries from the service parsing and indexing module and based upon the query results the service composition and task execution planning module completes a service composition s as a task and determines the execution plan for the task in response to a task execution command from a TCC . Once an execution plan is determined the central module invokes a related service function s via the execution modules that comprises a grounding invocation provided in the SSD to invoke a service function . The discovery modules discover services that can comprise service functions and Semantic Service Descriptions SSDs . The above description of the service parsing and indexing are not limited to such a configuration and any mechanism to parse and analyze SSDs can be used other than JENA and PELLET.

According to an aspect of the embodiments described herein as an independent module a WS TCC can use any kinds of underlying service discovery mechanisms or execution mechanisms as long as a unified and high level abstracted discovery and execution mechanisms are implemented according to a Web services API s for example by implementing a Web Service interface for underlying BLUETOOTH SDP IR RENDEZVOUS JINI etc. . Therefore for example the only thing a user needs to specify is the Uniform Resource Locator URL of the Web Service Definition Language WSDL files for STEER WS API to interface with the service layer e.g. discovered services . As along as the Web Service API is provided the whole underling discovery procedure by the TCE WS API is transparent to the user at the WS TCC in presentation processing layer . For example one of STEER WS API can be using BLUETOOTH discovery modules to find and execute BLUETOOTH based services . Another STEER WS API can be using UPnP discovery modules .

In PIPE WS TCS is another example of a WS TCS to publish and manage semantic object instances. The PIPE WS API extracts Task Computing management functionalities into independent modules and exposes them as standard Web Service interfaces accessible by any WS TCC such as White Hole Service Manager Real world object semanticizer and Database semanticizer . More particularly PIPE WS API provides a Web services interface for PIPE WS TCSs to manage services such as publishing operating system or application objects device services etc.

According to an aspect of the embodiments described herein with the support of Web Service interfaces Task Computing middleware server processing layer can incorporate a new concept of sphere of management for cross environment discovery and execution mechanisms by accessing other Task Computing middleware server processing layer modules through Web services. A set of TCE WS APIs for cross environment discovery and execution for example a subset of STEER WS API and PIPE WS API is herein referred to as Sphere of Management SoM WS APIs . Therefore SoM WS API is used to manage provide remote services . Cross environment herein generally refers to taking into consideration a computer system network characteristic where a plurality of sub networks as different or other network environments e.g. private networks virtual private networks subnets intranets etc. are in communication with each other based upon known techniques and each computer network environment might comprise computer network services or sources of functions i.e. function source realization layer and service layer which should discoverable and executable as part of Task Computing Environment .

According to an aspect of the embodiments described herein the following STEER WS API are used as SoM WS API .

According to the embodiments described herein to realize a Sphere the SoM WS API middleware server processing programs execute are installed on another remote computer system . A middleware server processing programs instance can internally access other Sphere middleware server processing layers instances via TCE WS API i.e. remote Sphere API instances or whatever implements a remote API to incorporate services running in different networks different platforms and or different technologies BLUETOOTH for example discover the services and execute the services as tasks .

Therefore a Sphere is realized by a set of remote APIs such as SoM WS API that provides a consistent view for Cross environment Service Discovery Publishing Execution and Management. The concept of Sphere is extended to a Filtered Sphere. A Filtered Sphere is a pair of Cross environment service discovery SoM WS API and a service filter. A WS TCC applies a filter when it adds a link to a remote sphere API with or without a friendly Sphere name and calls it a Filtered Sphere. In general a filtered SoM WS API provides an optional string as a friendly Sphere name and requires a URL to the service discovery SoM WS API which are according to WSDL and a partial query e.g. a string according to RDF Data Query Language RDQL which is a query language for RDF or any other query language can be used as the filter . A query is based upon service property ies in an SSD of the service .

In the forgoing two examples the owner eq Bob Smith and location eq Conference Room are examples of RDQL query as service filters. In the first case My Services at Company 1 are filtered according to those services in which the service property owner is equal or owned by Bob Smith. In particular a query s is according to a value s of a service parameter s . In this case a query determines if Bob Smith is equal to a value of a service property owner. When STEER WS TCC uses a filter to find the services from the STEER WS API only those services that match the filter are shown under the category defined by the friendly service name. The filter does not have to be a complete RDQL query as long as the STEER WS API can understand it. Therefore when the concept of filtering services is applied to a Sphere a Filtered Sphere or Virtual Sphere can be realized as only filtered services in a remote computer system are provided. In other words specifying a query in a service discovery realizes a user s Virtual Sphere or Sub Sphere. 

Therefore according to the embodiments described herein a single sphere can provide multiple filtered spheres. As long as the filters are different the sets of services found for different filtered spheres are perceived independently by the WS TCC user. The filtering mechanisms are applicable not only to the service discovery mechanism on remote spheres API but to the local and pervasive e.g. UPnP service discovery mechanisms as well.

In the execution sample source code can be used for cross environment task execution. To make the procedure transparent to a user when parsing the semantic service description SSD of a cross environment service the grounding part of the SSD can be rewritten to point to the TCE Web Services API TCE WS API of other cross environments or alternatively the other cross environment end which implements TCE WS API can rewrite the SSD i.e. rewrite OWL S to provide the SSD through its TCE WS API in a way that execution goes through specific Web services .

Therefore based on the STEER WS API and PIPE WS API technologies a cross environment service discovery publishing execution and management is described herein. As shown in multiple WS TCCs such as STEER WS TCC run execute in different network environments . Within its own range a STEER WS TCC can find a set of services . Then by using STEER WS TCC Web services a STEER WS TCC can communicate interface with Web Service instances of other STEER WS TCC and get their service discovery results.

In as an example there are four STEER WS TCC referred to as STEER Clients through . Each has its own discovery range which is depicted as a cloud. Each STEER WS TCC has a Web services API . To discover a service outside its range the Web services of each of the other WS TCCs are called e.g. Web services of STEER WS TCC are called . For example in STEER Client calls the findAllServicelds Web Service of STEER Client to retrieve all services that are discovered by STEER . Once the service id list is retrieved STEER Client uses findServiceProperty Web Service to retrieve the semantic service description of services and registers them in its own engine. During the registration a new service identification is created. The identification indicates that the service is a remote service remote service identifier and from where it is initially discovered. Now STEER Client can use the services as if they are in its own discovery range

To invoke a remote service a STEER WS TCC will use the Web Service interface of other STEER WS TCCs too. In the above example STEER Client will encode the input of the service if there is an input and send the request to STEER Client . As the result STEER Client will receive a reference identifier about the request. Next STEER Client will poll STEER Client about the execution status by using the reference identifier. There are four possibilities 

According to an aspect of the embodiment described herein the cross environment service discovery and execution can be deployed as a hierarchical structure or in any other configuration. For example in STEER Client uses the Web Service interface to discover and execute the services of STEER Client . When STEER Client communicates with STEER Client it gets not only the services that are initially discovered by STEER Client but the services from STEER Client as well. STEER Client does not know the difference between them. It simply thinks that the services are all from STEER Client . To invoke a service it will send the request to STEER Client Web Service interface . Once STEER Client receives the request it will check its own middleware processing engine and find out that the service is actually from STEER Client . Then STEER Client will relay the request to STEER Client . Once STEER Client is polled by STEER Client it will poll STEER Client and send whatever it gets to STEER Client .

In each instance of a Task Computing System TSC in this case STEER WS TCS can typically discover and execute those services that run on the same machine or system that the Task Computing middleware is running i.e. local to that device generally available services on the Internet and devices and services in the same subnet. Consider a situation where Alice who is visiting Bob wants to show the map from Bob s home to Carol s place on Bob TV. In this case Carol s contact information is available in Alice s PIM accessible through Alice s TCS at Alice s home however the display service is in Bob s apartment 9 TCS . This scenario is referred to as extending the range of a task or extending the range of Task Computing so that it can discover and execute services in another Task Computing Environment. In addition services associated with each respective TCS might run behind a firewall which further complicates the matter. Web Service interfaces of the middleware layer is instrumental in engineering a solution to extending the range of Task Computing system.

With reference to a more detailed explanation is described which is referred to as Sphere of Management or SoM. In four TCS nodes each with its own discovery range that is depicted as a cloud and its middleware layer that includes four programmable modules or units discovery central execution and management represented by D C E M. A middleware layer that is considered remote with respect to a computing environment is referred to SoM API to realize a Sphere. If one node wants to discover a service outside its range it must first know which TCS the service resides at and the WSDL of the Web Service exposed by that other node . This information can be exchanged for example online or by e mail between the TCS human operators another option would be to run a directory where human owners of TCSs can publish their TCSs.

Then the discovery web services can be invoked in the same manner that a client local to the remote TCS would invoke them in order to get the list of services in that node and the SSD of each service in the remote node TCS . For example TCS calls the Web Service of TCS to retrieve all services that may be discovered by TCS and then register them in its own discovery module s . These services are treated by TCS just as other services that are directly discovered by TCS but the discovery module of TCS adds a flag to its internal representation of these services to indicate where the services were initially discovered. After the initial discovery TCS may poll TCS to check on changes of the list of TCS services.

Execution is also supported through the Web Service API s . A user from TCS can create a new task with services from both TCS and TCS and execute it. Services that are initially discovered by TCS do not require any special treatment. However services in TCS might require an extra operation because they might be behind a Firewall and TCS can not directly invoke them. In this case TCS gets help from TCS in execution. First TCS will send an execution request about a specific service to TCS along with the context input parameters etc. through the Web Service APIs and get a reference id as a response. During the time that TCS is executing the service TCS will use that reference id to poll TCS about the status. Finally after the execution in TCS is complete the updated context output etc. is returned as the last polling result. The rationale for this design is that during polling TCS may return something back such as the current execution status or extra information regarding execution etc. and through polling it is easier for TCS to monitor the status.

Once a TCS node is exposed to external users anyone can discover and execute its services they are web services after all . A security technique would be to add a user identification mechanism in our Web Service API and or to build on top of Web Services security standards as discussed in more detail further below.

Sphere of Management extends beyond just two TCSs . In TCS uses the Web Service interface to discover and execute the services of TCS . When TCS communicates with TCS it receives not only the services that are initially discovered by TCS but the services from TCS as well. To invoke a service from TCS TCS sends the request to TCS . Once TCS receives the request it checks its own engine and upon determining that the service is actually from TCS it will relay the request to TCS . Once TCS is polled by TCS it will poll TCS and will forward the response to TCS .

Service discovery is referred to as the process of finding services through the SSDs of the services as related to a user s context. As discussed above given the separation of service implementation and SSD discovery is reduced to the acquisition and processing of the SSDs of service functions by a TCS . The implementation of service discovery relies on one or more discovery mechanisms a TCS comprising the middleware processing layer can exploit multiple underlying service discovery mechanisms and a service might be discoverable through multiple discovery mechanisms. Users or the services or their providers may set the discovery mechanism employed for the discovery of a particular service. Changing the discovery mechanism for a service may affect who can discover a service. Although service discovery mechanisms are orthogonal to discovery ranges some discovery mechanisms are more suited for a specific discovery range than others see Table 1 . Next each discovery range will be described.

1. Empty Services in empty discovery range are those that cannot be discovered by anyone. Empty is not an entirely conceptual range any service that is made unavailable even for its owner may assume this range. For example a user does not want the service providing her contact information discovered by others due to privacy considerations or even by herself because it is annoying to always discover a service that she does not intend to use may choose the empty range for this service. When later she wants to use her contact for displaying on a kiosk the route from the airport she is at to her home she may move the service into the private discovery range.

2. Private Services in the private discovery range are discoverable only by their owner and typically reside on the user s own computing device which runs the TCS . For example the local resource handling services such as My File which lets the user select and expose a file on her device assumes by default this discovery range. Here the TCS uses a file system based discovery mechanism combined with notifications using sockets to implement this discovery range.

3. Group by Subnet discovery range is most closely related to ubiquitous environments because of its ad hoc and spontaneous nature of grouping. Services that happen to be on the same subnet of the user such as a part of a company Intranet or a home network will be discovered enabling a very localized discovery mechanism. For example UPnP can be used as the discovery mechanism to implement this range. Specifically UPnP s discovery mechanism is used to find the UPnP devices on the subnet not all of which are Task Computing enabled services and for each UPnP device the TCS invokes one specific UPnP action getDescriptionURL to determine if the UPnP device represents a Task Computing enabled service and if so the TCS proceeds to download the SSD from the UPnP device. Other discovery mechanisms such as JINI can also be used in the same way as UPnP to implement this discovery range.

4. Group by Interest discovery range refers to services discovered by any arbitrary group of people perhaps bound by similar interests or group membership such as the group of employees of a company or the members of a golf club. This discovery mechanism can be provided by combining web services with callbacks and polling mechanisms.

5. Public Services in this discovery range can be discovered by anyone. A good discovery mechanism for this range is an open semantic service directory examples include Web pages with links to SSDs of publicly available services or a search engine for semantic web services like Universal Description Discovery and Integration UDDI a semantic service search engine version . Alternatively users can share the SSDs by emailing them to each other or by sharing them over a peer to peer network.

According to an aspect of the embodiments described herein a cross environment PIPE WS TCS can also be provided for cross environment management of services thereby providing cross environment application clients of Semantically Described Service Control Mechanism SDSCMs to manage tasks services . For example in case of a cross environment White Hole Task Computing Client the White Hole stores the WSDL URLs of PIPE WS APIs that are not necessarily running on the same machine as the White Hole . Once an object is dragged and dropped into the White Hole it sends publish requests using one of Insert Web services shown in to other PIPE WS APIs other than or along with the one on the same device. In this way the semantic instance of a service object can be created and published in other networks thus cross environmentally. According to an aspect of the embodiments described herein alternatively the White Hole allows the user to select PIPE WS APIs to use described in more detail further below . For example a SDSCM Task Computing Client such as White Hole that uses the PIPE WS in a computer environment a service in a remote environment can be published as long as a Web Service call can be made for the PIPE WS in the remote environment

A White Hole which is a user interface tool for publishing services using PIPE WS API can be extended to accommodate multiple PIPE WS APIs to deal with service publishing in two or more cross environments . A White Hole can provide a startup dialog box or an option setting dialog box for a user to set the following White Hole parameters 

A single White Hole GUI can accommodate multiple PIPE WS APIs by showing a dialog box for the user to choose which PIPE WS API to use to publish as a service a semantic object dropped into the White Hole . Or provide multiple instances of White Hole each with a different color or image for each remote PIPE WS API to make it easy for the user to differentiate and remember which icon corresponds to which PIPE WS API . More particularly White Hole user interface options accommodate visual and or audible as the case may be differentiation among provided or available Spheres. 

Regarding cross environment service management the PIPE WS API is extended by adding new Web Service interfaces for service management. Therefore a new Web Service Task Computing Client WS TCC application client that uses PIPE WS API as a SDSCM called Service Manager is created. One main function of Service Manager is to use PIPE WS APIs to manage services in a plurality of computer system environments . In an unlimiting example the management actions of the Service Manager include change service name and description change service expiration time change service discovery range change Sphere of the services change service invocation limit and so on. In particular the Service Manager can be used to fulfill cross environment service management as follows. Each PIPE WS API has an option to decide whether remote users can use it to manage its services . If the option is set to be a True value a remote user can add the PIPE WS API in the user s Service Manager . From the Service Manager tool a user can check all details about the services managed by the remote PIPE WS API and do basically all management actions remotely as long as the PIPE WS API is accessible.

The implementation of STEER WS API and PIPE WS makes it possible to provide a large variety of Task Computing user interfaces for WS TCCs because a presentation processing layer of a WS TCC can be freed from the implementation of the modules of the Task Computing middleware processing layer . User interface examples of WS TCC are described herein for 1 a radio device user interface 2 location place aware icon e.g. balloon computer display screen graphical user interface 3 voice command user interface 4 multiple inputs outputs in a user interface and 5 Tasklet WS TCC . The Task Computing system environment can provide any combination of the foregoing user interfaces .

According to the embodiments described herein a mobile phone user can experience Task Computing in any Web enabled mobile or radio communication phone . A Task Computing Mobile Phone STEER Web Services Task Computing Client referred to as Mobile PhoneSTEER WS TCC is provided to manage tasks on a mobile phone. Typically according to the present invention a Mobile PhoneSTEER WS TCC is a Web WS client for mobile phones which can be implemented in any computer programming language that is installable and executable on the mobile phone such as Java 2 Platform Micro Edition J2ME Binary Runtime Environment for Wireless BREW any other language that might be installable on the mobile phone so that applications written in that language can be executed on the mobile phone or any combinations thereof. Web clients might be pre installed in Web enabled phones and can vary widely in terms of the kind of Hyper Text Markup Language HTML they can process. More particularly Web clients can be implemented via any Web and or Wireless Application Protocol Wap browser software that interprets a markup language document to display information. According to another aspect of the embodiments described herein a Mobile PhoneSTEER WS TCC can be a custom client application. The presentation processing layer of Mobile Phone STEER WS TCC may be implemented similar to a Web based User Interface for Task Computing or Hosted STEER also referred to as TCC II and described in the related commonly assigned pending U.S. patent application Ser. No. 10 733 328 entitled TASK COMPUTING by Ryusuke Masuoka Yannis Labrou Zhexuan Song filed Dec. 12 2003 in the U.S. Patent and Trademark Office owned by FUJITSU LIMITED assignee of the present Application the entire contents of which are incorporated herein by reference.

However according to the embodiments described herein the Mobile Phone STEER WS TCC relies on WS API to interface with the middleware server processing layer and look and feel of Mobile Phone STEER WS TCC for managing tasks is adapted to fit the specific requirements of a mobile phone such as a much smaller screen size. illustrates an example of a user experience using a Task Computing mobile phone where a user may request a list of discovered services in multiple pages create compose a task and execute the task . All operations happen in the relatively small display area of mobile phone .

The network connection for Web access while performing Task Computing on a mobile phone can be IR BLUETOOTH WLAN for WLAN enabled mobile phones or a mobile network GSM CDMA etc. . The choice of network does not affect the operation of the Mobile Phone STEER WS TCC on the mobile phone because all communication necessary for Task Computing is carried over by high application level communication protocols such as without limitation Hypertext Transfer Protocol HTTP with displayable data in the form of HTML or other markup language based format.

Next the mobile phone UI is described. When at operation the user at the mobile phone directs a mobile phone browser software to a computing environment by entering a URL for that environment the user sees a listing of the services that are available in that environment . The listing might be presented in a single scrollable page or in multiple pages that require that the user selects a next page link in order to reach them. At operation if the user selects a service at operation the selection becomes an element of the service composition i.e. task creation referred to as current service composition e.g. News.com is selected by the user in the example . At operation after a service is selected the user is directed to a page that contains a listing of only those services that can appear in a composition with the selected service s e.g. open print save store favorite view locally . The displayed list in operation as before can appear in a single scrollable page or in multiple pages. At operation at the top of the page with the listing of services the previously selected services e.g. News.com are displayed in the order that they might appear in a valid service composition. In operation the display is the current service composition it might also scroll across the display as a banner. Every time the user selects a service e.g. operation a display page is updated to display the current service composition and the listing of services that can appear in the current service composition until no additional services exist that can be used in the current composition at which point at operation the user has the option of executing the service composition. More particularly operations through are operations to compose a task via a mobile radio device. In the example at operation there are no more additional services that can be used in the current composition of the task however if additional services are available additional services would be listed similar to the operations through . According to an aspect of the embodiments described herein the user can execute the composition as soon as it becomes executable even if it is not complete. At operation execution status of a task is displayed. At operation an execution completion of a task is displayed.

In available discovered services within or at a location place are represented as icons according to the embodiment described herein as balloon icons at a corresponding area in the location place e.g. in an office floor map is a location place in which services are discoverable at various areas within the office . In order to display potentially a large number of services with 3D coordinates and realize an intuitive user computer display interface the following mechanisms are provided 

1. The services are represented by same computer display screen visual components i.e. displayed icon same type of visual component but with different styles colors size fonts etc. or a different visual component for each service as the case may be . In a visual component referred to as balloon of varying sizes and colors is used.

2. A service having a location is placed at the location in a displayed map. A service without a location is placed outside the map in a tabular or some other organized way .

4. Keep balloons small usually and display an enlarged balloon when operated or a cursor is on or close to that balloon.

5. Express the physical height Z coordinate by the balloon s shadow . The physically higher service in a location the larger and or more blurred the shadow gets. Other display techniques can be used to emphasize a Z coordinate of a service at a location.

6. Represent an execution of two service potentially with translation services between them composition by dragging one of the balloons and dropping it onto the other.

7. When a balloon is selected only composable balloons services keep their colors or are high lighted. Others turn to another color indicating non composable services such as gray or stay the same respectively.

9. When the pin is selected only deletable balloons services keep their colors or are high lighted. Others turn to another color indicating non deletable such as gray or stay the same respectively.

10. Change the language used for displaying service names and descriptions based on a user language selection as described above concerning communication language selection .

11. Provide the button to show more comprehensive STEER WS SIS TCC interface if the user wants to create more complex compositions than what can be created in this interface.

Therefore is an example of location aware icon e.g. balloon user interface. Although the example uses a displayed balloon as an available service representation the present invention is not limited to such a configuration and any display representation overlaid on a displayed user area image can be used. This can be implemented by event driven object oriented programming. When STEER WS SIS TCC is started it initializes the figures internal data and sets the event handling codes for appropriate events. Basically those pairs of events and event handling codes correspond to the items in the list above. In the event handling codes appropriate Web Service calls into TCE WS API such as STEER WS API and PIPE WS API are made. Then the event loop will take care of events and another loop for discovery to update the balloons and internal data when there are changes in services availabilities. In selectable graphical displays of an update button updates the displayed information. According to an aspect of the embodiments described herein updating of displayed information in any of the user interfaces by a TCC can be automatic. A selectable graphical display of a language button provides the displayed information according a selected spoken language such as Japanese described in more detail further below under a multi language Task Computing system .

More particularly VoiceSTEER WS TCC is a voice driven user interface developed for example in C . A user can request tasks by speaking to a VoiceSTEER WS TCC the implemented VoiceSTEER WS TCC uses MICROSOFT S AGENT AND SPEECH SDK along with calls to TCE WS API . Each service is mapped to a phrase normally the service name and once the VoiceSTEER WS TCC hears a sentence recognize a voice sentence it will attempt to match the sentence into a sequence of services . Then a task is built based on the service sequence and is executed. One challenge of the voice interface is the recognition rate of human speech defining a grammar set that raises the rate to an acceptable level is very important. Another challenge is how to identify and filter the semantically invalid commands tasks such as Print on Office Printer My Video that should be ignored even if Print on Office Printer and My Video are valid service names. According to the embodiments described herein the VoiceSTEER WS TCC matches a complete sentence with valid executable tasks according to a Grammar Diagram which is generated by a central module of the middleware processing layer and is made available through the STEER WS API .

One important attribute of the Grammar Diagram is that it has a one to one mapping with a grammar rule set of a speech recognition engine. More specifically a sentence is a semantically meaningful command i.e. a valid task if and only if a path from the start state to the end state in the diagram can be found such that the sentence is a concatenation of the names of edges i.e. a valid composition of services . For instance Open My File or View on Projector Weather Info of Business Address of My Contact are valid commands or tasks . The Grammar Diagram is determined solely by the ontology and the semantic descriptions of services i.e. determined based upon SSD . Use of SSD raises the recognition rate significantly and that the semantically invalid commands or invalid tasks would be completely avoided. A Voice UI can be desirable for Intelligent Transportation System ITS applications of Task Computing .

There are two merits for having a small vocabulary set. First it is very easy to train a speech recognition system. Second recognition rate is high because there are fewer words and sentences to discern from each other.

Because a Task Computing service composition can have a grammatical structure recognition rate by a speech recognition system can even be further improved as follows. One can have an increased recognition rate for recognizing the whole sentence at once rather than recognizing each component in the sentence one at a time. This is basically because even if the recognition fails in one part of the sentence it can still recognize it if other part is recognized i.e. one has to consider joint probability . For example take the spoken phrase Open My File. Assume the recognition rate for Open is a and for My File is b. If the recognition is done separately for Open and My File the recognition rate can never exceed a as one has to recognize Open first. But if the system tries to recognize the whole sentence Open My File the recognition rate will be 1 1 a 1 b a b ab a b 1 a . As a is less than one and b is positive recognition rate is always larger than a. Therefore speech recognition rate can get higher when the sentence is longer.

Therefore according to an aspect of the embodiments described herein VoiceSTEER WS TCC adds additional paths for a and the between service paths. By this the user can have more natural sentences. For example 

It is also possible to omit one or more translator services in a command sentence because even an ambiguous command sentence might still be recognizable. For example in by having direct connections from File node to Contact node with services of Weather Info of and Map of Business Address of service in the command sentence can be omitted by the user such as

and VoiceSTEER WS TCC can still recognize the sentence. In this case if there is an ambiguity in what the user wants VoiceSTEER WS TCC can clarify by asking the user. In this case when there is another link from Address node to Contact with a service of Home Address of and the user asks the above sentence and VoiceSTEER can ask the user a clarifying question to compose a valid task 

By reversing the direction of the connections and replacing the start node and the end node in the recognition diagram VoiceSTEER WS TCC can recognized other languages with noun verb order such as Japanese.

Some services have multiple inputs such as Fax service takes a fax number and a file as inputs. According to an aspect of the present invention a STEER WS TCC asks in a recursive way for missing inputs from a user during task execution. For example in the following conversations between a computer and a user of Task Computing system 

In the first conversation user wants to invoke a task which comprises three services Fax Fax number of and Ryusuke Masuoka a Contact providing service . By checking the task i.e. service composition the computer determines that service Fax takes two inputs one is Fax Number and the other is File . Since Fax Number is provided by the sequence the computer now asks the user for the other input File . Then user tells the computer to get the input from the service My File . With all inputs specified the computer then starts the execution of the task .

The second conversation is about the situation when the Fax Number is not initially specified. In this case user is further asked to provide a service composition which gives the Fax Number .

In the above two examples due to the characteristics of speech used for the interface of VoiceSTEER WS TCC it is often not easy or natural for a user to provide all inputs from the beginning in one sentence. Therefore when such situations are detected the execution engine controls the VoiceSTEER WC TCC computer to prompt the user for more inputs before and or during execution. This can be thought as mapping a complex service composition diagram spatially into user interaction that spans temporally between the user and the computer.

Dealing with multiple outputs is essentially same. For example assume there is a service which is called Bioinformatics Talk and which produces a Contact data object as its speaker a Schedule data object for its schedule and a File data object as its presentation material. Using VoiceSTEER WS TCC 

In the above task composition scenario the computer via user prompts to further define the task will add the schedule into PIM read out the speaker contact and show the presentation material on the projector using three separate services Add Schedule into PIM Tell Me and View on Projector services.

For services with more than two inputs outputs or when there are more than one service with multiple inputs outputs the procedure is similar. This technique can be used recursively until the task is well defined. Alternatively the computer can execute whatever parts executable in the service compositions and asks the user there is no other parts executable without specifying further service compositions necessary.

Although the foregoing multiple inputs outputs description is described in the context of voice recognition the present invention is not limited to such a configuration and those techniques are also applicable for other Task Computing Clients using Graphical and other User Interfaces. For example Task Computing clients can pop up windows asking for missing services and or for additional functional characteristics of the services such as without limitation data object inputs and outputs of a service . See for example showing a task construction GUI pane in which a directed graph of composed services as a task to deal with multiple inputs outputs is displayed.

A Tasklet TCC is a very light processing weight Task Computing Client TCC which executes OWL S files of a service s or a service composition s task s . Among other ways of making Tasklet TCC to execute OWL S files including from the command line the preferred way is to invoke the Tasklet TCC by double clicking or some other appropriate OS operations the OWL S files to be executed. When the Tasklet TCC reads the OWL S files it will execute the services or the service compositions by using STEER WS APIs . Tasklet TCC might show the control UIs of the service function within its own window. In particular with reference to the Tasklet TCC invokes the executeOWLS API to execute an OWL S description.

Advanced features of 1 a Relaxed Type for service input 2 locations of services 3 multi language services and 4 service management functions in Semantic Service Description to support the versatility of services is provided as follows 

Some services accept a broad range of input except a small subset. For example service View on Projector accepts File as a functional characteristic except Audio File and Video File where Audio File and Video File are the subset of File. If input of View on Project is represented as File Audio File Video File another new problem can be encountered i.e. when another service such as My File generate File as output the inference engine does not know that there two services that can be composed.

The cause of the problem is that the descriptive power of the current service description language is limited and the composition conditions can be too strict. Our solution for the problem is to extend the current service description language by supporting two types of input for a service . One input is called parameter type T which is the exact domain of input and the other second input is called relaxed type T which is a larger domain that input could also fall into. For example an input type Tis acceptable if

For example in service View on Projector Tis File and Tis File Audio File Video File . Input type File is acceptable. WebPage a subclass of File is acceptable as well. But Audio File is rejected. Thing a super class of File is rejected as well.

An example of a piece of Semantic Service Description of View on Projector service that uses Relaxed Type is 

In STEER inference engine relaxed type is supported. This Relaxed Type can be implemented as follows When STEER composes the services it checks if there is Relaxed Type. If there is no Relaxed Type parameter it uses usual algorithm to match services and execution. If it finds the Relaxed Type for the service A the service B preceding the service A the service B matches with the service A only when the output of B is a subclass of the input Relaxed Type of A and the output of B has non empty overlapping with the input Parameter Type of A. When STEER execute the composition STEER checks the output of B to see if it really falls in the input Parameter Type of A before invoking A with the output of B.

Including location information in Semantic Service Description is another new feature. The location information can comprise the coordinates in 2D 3D Euclidean coordinate systems or any other coordinate system reference to the coordinate system and or the text description of the location. A piece of Semantic Service Description of View on Projector related to location is 

Upon service discovery the a TCC extracts via the TCE WS API e.g. findAllServices and getServiceProperty the location information out of the semantic service description and support spatial based filtering or presentation of services to the user an example is the Location Aware Balloon UI described above .

As services change their location the services can use UPnP and other discovery mechanism to update their service descriptions with new location. If the location change does not happen so often this is a viable option. If the location change is often it is more efficient to use a service management function discussed next.

The Task Computing embodiments described herein supports any communication language such as without limitation spoken languages of English Chinese Simplified Chinese Traditional Greek Hindi Japanese Korean Spanish and Turkish thereby providing a language independent Task Computing . The language independent procedure comprises two operations 1. service profiles such as a service name description and 2. user interface.

1. Regarding the service profiles such as service name description in semantic service description xml lang attribute is used to describe service names and service descriptions in different languages. For example below is an example portion of a Semantic Service Description file written in XML that describes a service name called open in English and in Chinese 

2. Regarding user interface is a flow chart of displaying WS TCC user interface such as STEER WS TCC in any language according to an embodiment of the present invention. According to an aspect of the embodiments described herein as an example in various STEER WS TCC user interfaces a table is maintained for all computer display user interface strings that are used. For each string in the table multiple versions in different languages are kept. The string table is described in XML and is loaded when the STEER WS TCC is launched. The STEER WS TCC computer user interface for example displays strings using a language based on a user s selection.

In at operation a user is prompted via a computer user interface e.g. a computer display screen graphical user interface GUI voice interface etc. to choose a language. At operation if determined that the language is not supported English is selected as default. At operation a language code and sentence order are determined e.g. retrieved from computer readable media determined by software etc. . At operation necessary strings for a computer user interface in the selected language are retrieved from the table which in this example are strings for a GUI. In this example at operation a service name and service description in the selected language is determined from an SSD and the determined service name service descriptions and retrieved GUI strings in the selected language and in correct sentence order are displayed in a computer display screen user interface. Therefore at operation at one time STEER WS TCC displays service names service descriptions and computer user interface strings in the selected language. If at operation semantic service description of a service does not support the selected language language a default language for example English will be fetched and displayed. Meanwhile the sentence order is taken into account for multiple languages. As described herein a user can specify which language version of a service name and a service description of a service to retrieve using STEER WS TCC . Of course the above described language independent operations in Task Computing may be provided in any WS TCC such as without limitation the SDSCMs

Regarding sentence order for example in English the sentence order is VO verb object but in Japanese the sentence order is OV object verb . Such language order information is also kept in maintained by STEER WS TCC or at operation it can be made so that the user sets it at the start up time of STEER WS TCC . When displaying compositions at operation STEER WS TCC will pick the correct sentence order based on the selected language selected sentence order or both.

Service Management Function s SMFs can be viewed as meta services for services see . SMFs exist because of services but not vice versa. If a service is gone the SMF of the service should be gone as well. Each SMF has its own description written in OWL S. Therefore to link an SMF with a service the SSD of the service either includes the SMF descriptions or have links to SMF descriptions. In the latter case SMF descriptions can reside anywhere. Similarly the implementation of SMF can be deployed anywhere and is not necessary to stay on the same device as the service itself.

From a user interface point of view SMF are treated just like other services . This is especially useful in VoiceSTEER WS TCC . For example the following SMFs can be performed as tasks 

According to the embodiments described herein REI policy language is used to establish access policies to services . REI is a policy specification language. The concept of REI is known. In REI policy engine determines who has what kinds of access rights based on policies set of access security rules facts information provided by a user and or client side and ontologies. The REI engine is provide with a Web Services interface so that it can be centralized or distributed. The REI engine and or Web Services interface to the REI engine can be replaced for this framework. Any policy engine with remote procedure call interface or even a software module for policy engine within the service is sufficient.

1. At operation when a new user registers at the counter a credential is issued to the user. The credential includes information about the user such as name status and location as well as meta data about the credential such as its creation time expiration time and digital signature which guarantee its integrity.

2. At operation the user gets on the network for the office the user s Task Computing client client for example STEER WS TCC discovers all services that are currently available in the environment and or spheres that are connected at the time of discovery. Some of the services are public and some of them have access control. The information of the services is described in their semantic service descriptions . The user s Task Computing client may check the status of the service by reviewing its semantic service description . The semantic service description tells informs the Task Computing Client whether it requires access control and what kinds of credential s is needed if so.

3. At operation when the user wants to invoke a service through her Task Computing Client the client will check the status of the service . If the service is public the client will invoke it as usual. If the service is access controlled the client will send an extra parameter to the service i.e. user s credential s along with usual TCE Web services parameters to execute the service . According to another aspect of the embodiments described herein the client can send an extra parameter to the service via a secured connection such as HTTP over SSL etc.

4. At operation the service receives the request it will first verify the integrity of the credential by checking the digital signature in the credential. If the signature is not valid the request will be rejected immediately. Next the expiration time in the credential is checked. If the time is expired the request will be rejected too. When the credential is proved to be valid the fact s in the credential will be extracted and inserted into a REI engine . Then the service will ask REI engine whether the user is authorized to invoke the service based on the service s policies.

5. At operation the REI engine will answer the query based on the ontology the policies of the service and the facts about the user.

The REI engine does not have to be centralized or running at different place from the service . For example it is possible to setup one single REI engine for the whole corporate campus or each device such as printer can have a REI engine of its own. In fact in a pervasive environment it is not common to have a REI engine that all services can access. In our design as long as the instance of REI engine has enough information about the policies facts and ontologies the answer will be given.

The foregoing discussed mainly about services determining the access rights of the client through facts provided by the clients maybe certified through a digital signature issued by a Certificate Authority which issues certificates its policy and ontologies.

Sometimes one wants a service to use not only its own private policy but also policies shared by certain communities. This is particularly useful when one wants to realize the delegation of rights from one user to another without accessing the service itself. In ubiquitous environments a service is often hosted by a device with limited computing resources. It might be too much burden for such devices to support the real secure access to those policies and to manage those policies. 

Multiple sites for shared policies might be corresponding to organizational hierarchy geographical structure etc. If the service belong to the department X hosted in the building Y the service might want to use the shared policy sites for X and Y

Initially for one time the person in charge of the service sets for the service one or more sites to be checked for shared policies to be used for access control calculation. The accesses to those shared policy sites might be secured for example HTTP over SSL . When the service needs to calculate the access control it will check the sites specified for possible updates. If there is no update for any of the sites the service goes on to calculate the access control based on the cached policies along with facts provided by the clients its policy ontologies and other information. If there is any update for any of the sites the updated policy is downloaded the cache is updated and the calculation will be done with the latest shared policies.

As to delegation of rights it can be done through shared policy sites. One can delegate a right which he she has the right to delegate for example to print on a certain printer by updating the shared policy with a statement that he she delegates the right to a certain person or group etc. through possibly secure connection to the shared policy site. The next time when the service calculates the access control it uses the updated shared policy and the person with the delegated right gets to use the service.

In order to revoke the original user updates the shared policy to add a revocation statement which says that he she revoke the right to the person. Or the original user may remove the original delegation statement from the shared policy.

It is not always the case where the service wants to authenticate the client. Sometimes the client wants to authenticate the service or to determine if the client has the right to execute the service in advance. If it can be determined in advance the client can warn the user that it is not accessible or decide to hide the inaccessible services from the user.

In Task Computing a service is identified through its Semantic Service Description SSD by the client. The SSD tells what the service is its internal processes how it can be executed etc. Therefore by giving the digital signature in the SSD itself or separately through other mechanisms the service can be authenticated by the client. The digital signature needs to be signed by one of the authorities that the client also trusts. The digital signature can be for the parts of the SSD or for the whole SSD. It might be digitally signed partially only for important parts of the SSD.

In order for the client to determine if it has the right to execute the service the SSD can be used as a vector for the policy information of the service. The SSD can contain the policy itself in it or the pointers to the policies it uses ex. URL s . The policies may include the shared policy discussed above in the Shared Policy and Delegation section. When the client obtains the policy information in the SSD the client can determine if it has the right to execute the service with the information in the SSD along with the facts about the clients ontologies and other information.

The service might not necessarily expose all of its policies in its SSD but it still merits the client as even the partial information can reduce the chances that the user executes the service in vain.

Previously users must install the software before using Task Computing Client. It is time consuming and sometimes hindrance for user adoption of Task Computing. A solution for the problem is to generate a portable or removable media or device such as CD or UBS flash memory that includes not only the Task Computing Client but the executing environment as well such as Java runtime so that user can start using Task Computing without any installation.

The portable or mobile TCC can also be combined with the issuance of credential that is crucial for access controlled services for user s convenience. When the user registers at the counter a credential is generated and can be added into the portable media or device. Then she may use the media or device on her own machine to access services based on the authorities that are assigned to her. The credential can be set as read only so that no further changes can be made. It makes more difficult for the user to misuse the credential when the Task Computing client on the media or device is made to read the credential from the fixed path in the media or device. Note that memory device is not the only choice other media such as CD DVD can be used as well.

3. In Wendy creates a STEER TCC Stick with credential for Bob. STEER TCC Stick can be for example a USB memory device with all the things necessary to run STEER TCC a Task Computing client including Java runtime.

4. In using the software Credential Creator Wendy creates and saves the credential in the credential folder of the STEER TCC Stick. The credential includes his name affiliation status Intern and metadata of credential its creation date expiration date time delegation information etc. and the digital signature signed with the company 1 s private key. is an architecture diagram of service access control according to an embodiment of the present invention.

5. In Bob runs the STEER TCC out from the STEER TCC Stick on his laptop . is a general service access control system flow architecture according to an embodiment of the present invention. In TCC discovers the service i.e. discovers the SSD in OWL S of the service . The SSD describes the service s partial policy and the facts including values of its attributes in the signed certificate. The TCC can decide if the service is trustworthy based on the certificate and decide if the service is what the user wants to use potentially through interaction with the user. For example the service s certificate is signed by Company 1 which the user decided to trust at the time of check in to the Company 1 office and the user can decide whether the service is trust worthy. Then it can check if the user and TCC meet the service s policy so that it can use it. If the user decides and directs the TCC to invoke the service the TCC will send the facts including attribute values along with the other parameters of Web Service invocation. The service checks the digital signature of the certificate expiration time and others to determine the facts sent are valid. Then using the facts its private policy ontologies and shared policy for example one at Company 1 Policy Site the service decides if the user has the right to invoke the service and responds accordingly.

6. In Bob finds the Secure Print service with the key icon. In Secure Print OWL S file it says it requires the company 1 credential. It can say it requires one of multiple credentials. When STEER TCC finds the requirement statement it shows the key icon for the service in this case Secure Print .

7. In Bob tries to use the Secure Print but he fails as an Intern is not allowed to use the service . Based on the Secure Print OWL S file STEER TCC looks for the company 1 s credential in its credential folder. When it finds it it sends the credential along with service invocation parameters in the Web Service call . Secure Print checks the digital signature of the credential to make sure it is valid. So that facts in the credential are not modified. First the service makes sure the credential is not expired. If not then it uses these facts in the credential to determine if the caller has the authority to use the service by the REI policy engine which is called through Web Service API. If the result from the policy engine is okay the Secure Print prints the file. If not it sends back a message which says the request has been turned down. In this case Bob as an intern does not have the right to print so he is turned down. 

9. John uses the software Delegation Manager to assert the delegation of the right to Bob by John to the Company 1 Policy Site securely. There is a statement at the company 1 Policy Site that a Senior Employee has a right to delegate the right to the interns.

11. After that John revokes the delegation using the Delegation Manager the delegation assertion created previously is removed from the company 1 Policy Site .

Therefore access control is determined based upon the following elements 1 facts provided by the Task Computing Client authenticated by the digital signature 2 the service private policy 3 a shared policy and 4 ontologies. A service can use multiple shared policies depending on its configuration. Each time these listed service access control elements are mixed to determine the access control. is a matrix of the service access control elements according to an embodiment of the present invention. More particularly is a service access control discussed above with reference to . In at operation Client calculates acceptability of service composition based upon client policy and service public attributes C P S A . Service attributes are facts about the services such as without limitation cost to use the service any certification information operational information etc. Even though operation does not use the service s private attributes if they have not been provided operation increases the possibility that the service might be acceptable to the client. At operation Client calculates feasibility to the service of the client using service composition based upon client attributes and service s public policies C A S P . Again operation increases the possibility that the service might be feasible even though the client might not have access to the service s private policy. At operation the service calculates acceptability of or authenticates the client based upon all service accessibility factors of client attribute and service s public and private policy C A S P S Pand or as the case may be service S A . is an example listing of facts private policy for the Secure Print service and the shared policy for the company 1 used in the above scenario. More particularly in Task Computing system a service access control handling can handle access to a service as described herein.

Next will be described four other semanticizer client applications as SDSCMs that provide semantic objects to be used in Task Computing namely 1 a real world object semanticizer client 2 a database semanticizer client 3 a media publisher and 4 White Hole .

In the real world object semanticizer client comprises programmed processes of 1. a recognition processing engine 2. semanticizier process and 3. publisher .

The recognition engine recognizes tags codes voice video gesture etc. The recognition process might be active i.e. it is always on and it recognizes the object on its own or passive triggered by the users or programs . As for tags and codes appropriate readers are used as the recognition engine as for voice visual gesture recognition engines of corresponding multimedia input are used. Some recognition engines usually are error prone. However by giving some constraints on data patterns specific for the purpose may boost the recognition rate. For example in case of voice recognition one can limit the vocabulary and grammar used. Using additional confirmation processes by the recognition engine when the recognition rate is low also helps improve overall recognition rate of the system. For example a user might command the following task to the voice recognition based real world object semanticizer client .

The variations of the above sentences can also be used in other cases by changing book to other semantic object names ISBN to the property names of the semantic object and the value especially values such as ISBN or number can be well constrained .

Sometimes partial whole semantic objects themselves might be encoded in the tags and codes or in the voice command . Especially RFID tags with large memory and QR tags can hold semantic objects in plain text or encoded format. Alternatively it is possible to have an RFID tag with a pointer to a semantic instance that can be downloaded its SSD created and published.

As soon as the recognition engine recognizes an object or objects it will pass the information onto the semanticizer .

From the information passed by the recognition engine the semanticizer process first tries to find the information about the corresponding object. For example in RFID case it might consult the local or remote database for the objects with the RFID s. t. Next the semanticizer process generates the semantic object. For instance the Book semantic object by consulting a local or remote database based upon the ISBN number obtained from the recognition engine . In the circle dotted lines represent a passive mode case in which recognition of a real world object is triggered by the user. Alternatively the recognition engine and semanticizer process might be invoked by an external module via an API for the external module to obtain the semantic object s of the physical object.

The semantic objects might be stored as separate files in the local file system and the system might simply obtain the semantic object through the file which matches the information. For example the semanticizer just picks the file with the same name as the RFID data and returns the semantic object in the file.

In case where the whole semantic objects are passed on to the semanticizer it does nothing but in case of the partial semantic objects the semanticizer might or might not attach additional information about the object.

When the semanticizer is supposed to return a single or fixed number of semantic objects and it cannot determine them it might ask the user to select appropriate ones from possible ones or arrange the recognition process to happen again.

At the end the semanticizer will pass on those semantic objects on to the publisher or return them to the programmatic API module.

The publisher provides those semantic objects as semantic object providing services. It will publish a single semantic object providing service if a single semantic object is provided by the semanticizer. Or it will publish multiple semantic object providing services when multiple objects are given. Or in some cases a single service which lets the user select one or more semantic objects from its user interface from multiple objects. Or a mixture of these methods. As for publishing mechanisms a PIPE WS API can be used.

According to an aspect of the embodiments described herein the recognition may be triggered by the user for example clicking a button. Or it may be initiated by a function call from the programmatic API module. If the function call requires the return value of the recognized semantic objects the semanticizer will return the semantic objects to the programmatic API module. In this case the semanticizer might not send the semantic objects to the publisher. The function calls from the programmatic API module can be implemented remotely such as using Web Services calls.

Most formatted data today is stored in relational databases. A database semanticizer makes the data from the databases available as semantic objects such as in RDF or more specifically in OWL. More particular database semanticizer processes semi structured text data. Typically according to the present invention the database semanticizer comprises two major modules 1. a user interface to create the mapping between a database schema and an ontology and 2. a Semantic service process to provide semantic objects from the database based on the mapping given above.

Optionally the database semanticizer can create the semantic objects from all or part of the data from the database in a single or multiple files based on the mapping created in the process 1.

The user interface to create the mapping can be graphical. More specifically it can show the database schema on one side in a GUI window and the ontology on the other side in another GUI window which the user plans to map the database to. The user can manually specify the mapping between the database schema and the ontology. Typically according to the embodiments described herein the user picks a semantic object in the ontology on one side and an item in the database schema on the other side and specify to the system e.g. by clicking a Map button that they are to be mapped. The user repeats the process until the user specifies all desired mappings. Using the mapping specification created as above the semantic service process maps the data real values out from the database and creates a semantic instances with the values mapped accordingly. However the system can also provide suggestions on the possible mapping based on the syntactical clues in the schema and the ontology. The system can provide on the spot checking of the mapping consistency. When the mapping is done it will save the mapping for example as a file for the future use. The database semanticizer client can use a created semantic object to create a service by creating an SSD based upon the PIPE WS API as described herein.

The semantic service process comes with not only programmatic APIs to generate a semantic object based upon the mapping but also a user interface for the user to pick up from one or more generated semantic objects. When the semantic service is executed the semantic service provides the user interface for the user to pick up one or more semantic objects then the semantic service returns the semantic objects selected as its return value. For the sake of efficiency especially when the database holds huge number of data the semantic service connects the database each time to provide the user interface and map the data to the semantic objects based on the mapping. But it is also possible for the database semanticizer to have the semantic objects created from the database based on the mapping given and provide its functions through those semantic objects.

Like directory publishing service the media publishing service allows user to select a file audio video or image from a device and get a corresponding semantic instance. However the way how the service is launched is different. When user plugs in a device such as memory device digital camera CD ROM DVD ROM or external hard drive to a computing device a program is launched to check whether there are files audio files video files image files etc. in the device. If so a dialog box will be popped up asking whether the user wants to publish them. If user decides to do so a new service s is generated.

The service is extremely useful when user wants to share her files audio video pictures etc. carefree. She simply needs to plug the device and click OK. Then everything is set for her. She can use those newly published services composed with other services to accomplish her tasks. If she prefers with one option set even the OK clicking can be omitted and the whole service publishing process can be made fully automatic. The media publisher client can use a created semantic object to create a service by creating an SSD based upon the PIPE WS API as described herein.

When something is dropped input into the White Hole the tool first decides its type as follows a if it is an OWL or OWL S object the white hole just passes it to PIPE WS API discuss next b if it is a URL to a OWL or OWL S file the white hole downloads the content of the URL and passes it to PIPE WS API c if it is a known semantically speaking OS application object or a semantic object the white hole semantic izes the object see table . Semantic ization is the process of creating a semantic object from an OS application object e.g. as described in unlimiting examples of Real world object semanticizer and database semanticizer for creating semantic objects . A TCS can support ten types of OS application objects such as file and URL from OS contact and schedule from PIM application etc. . White Hole determines the semantic type of objects by their name extension and content. Once the type is determined an OWL template for the type is retrieved and filled with the values extracted from the original object. Then the OWL description of the object is generated and passed on to PIPE WS API . For example if a user drops a contact item from a PIM application the white hole first loads the OWL template for the contact type then retrieves the name company email phone etc. from the contact item and fills them into the template. Finally the complete OWL object is passed on to PIPE WS API .

PIPE WS API which is part of management tools in the middleware server processing layer is a tool to service ize semantic objects and to publish them see the possible outputs of the white hole semantic object in OWL or semantic service description in OWL S need to be service ized prior to publishing. So a service with associated semantic description is created which when invoked will return the semantic object itself. Specifically PIPE WS API first dynamically creates a web service which returns the semantic object as its output when invoked next a semantic service description for the newly created service is generated see Table . During this process the name description output type and grounding details of the service are determined and described in a high level in OWL S . Therefore a Task Computing system supports objects defined via a Task Computing system and or any OWL object as well.

The outcome of the service ization is a Semantic Service Description or SSD which is either the original one that the user dropped into the white hole or the one PIPE WS API created to describe the newly created web service. PIPE WS API can be used to publish the SSD depending on the discovery range as discussed above that the user chooses. For example if the user wants to publish it as a group by subnet service PIPE WS API will create a UPnP device with a getDescriptionURL action that points to the OWL S file.

Even though PIPE WS API is described in relation to the White Hole client PIPE WS API can be a completely independent tool with a Web services interface so that it can be called by any other components in a TCS and used to publish objects or services. Conversely a PIPE WS API can call other TCE WS API such as STEER WS API . One important usage of PIPE WS API is to realize a so called semantic object bank service which is a persistent repository of semantic objects. A bank service can be used by users in an environment to leave such things as files contacts schedule etc. as semantic object providing services in the environment so that people maybe later can use those services to accomplish tasks .

PIPE WS API also includes a management user interface which helps users to organize the semantic objects or services that the user has published through PIPE WS API . The functions comprise 

New services are designed and implemented which include 1 semantic instance serializing services 2 information providing services 3 sensor services such as without limitation time weather related temperature and or anything that can be sensed 4 snapshot services 5 OWL formatter service and 6 text formatter service.

The services in this category consume any types of semantic instances serialize them and pass the information to users. One example is Tell Me service. It takes a semantic instance serializes it into a human understandable string and reads it out. Details of Tell Me service are as follows.

Once a semantic instance arrives the semantic instance is first parsed by the Tell Me service. Then Tell Me service will check its transformation script repository to see if there is any serialization transformation available for the class of the instance or any classes of the object properties of the instance. The transformation script could be but not limited to Extensible Stylesheet Language XSLT script. If such a script is found it is first applied to the instance and transforms the instance or a part of the instance into a string. This transformation process is applied recursively when the instance includes other instances as its object properties. For example a Contact instance can include an Address instances as its hasBusinessAddress and hasHomeAddress object properties and corresponding scripts are applied to the instance. 

Next the result of the transformation or the instance itself if no such script is found is sent to a general serialization module. The purpose of the module is to serialize any semantic instances using a default logic. In the above example if there is no script for the address instance the instance will be serialized as 

The last step of the Tell Me service is to read the serialized string out. The serializing module of the Tell Me service can also be used by many other similar services such as Show Me service to display the string in a ticker device.

The Tell Me service can be extremely useful when used in combination with VoiceSTEER. This is a service which has one or more input and no output semantically . It reads out the semantic object s which it receives as input. When the semantic object is of a known type to this service it uses internal mechanisms such as an XSLT script for each know type to determine how to read the object. If the object is unknown to the service it first looks for the object ontology to see if there is information on how to read it. If it also fails it uses a default way to read it out using the ontology the object refers to.

Labels for properties such as Street Address for co streetAddress is defined in the ontology to which Address object refers. A semantic object can be serialized into a string by giving a transformation function such as an XSLT code piece . If within the ontology file a serialization function is defined or Tell Me service knows how to serialize the Address object in its own knowledge base it might apply the function and read this object out like 

This Tell Me service accepts any objects as its input. It can have multiple names such as Tell What is Those names can be provided in the same OWL S file or in separate OWL S files. That will give a natural way for user to examine a semantic object. For example if you a service called Temperature returns the current room temperature user can ask VoiceSTEER 

The service can have other names and be made to accept specific kinds of object so that the service can be combined with automatic translation services insertion mechanism of Task Computing Clients. For example let Where is a Tell Me service with the different name which accepts Location objects. Assume that there is a service Commander Data which provides the Contact information of Commander Data including his location and Location of service which extracts the Location from Contact . Then you can say to VoiceSTEER 

Then Location of service will be inserted automatically and the service composition Commander Data Location of Where is will be executed and the location of Commander Data will be read out. Of course you can say 

By making the service to accept specific kinds of object it can also be made so that the service can be combined with service management function of semantic services. For example let Where is a Tell Me service. Assume the View on projector service provides the location information in its SSD. Then you can ask VoiceSTEER 

Then the Location of service management function the details of service management function are discussed in more detail below is automatically added between Where is and View on Projector. 

 Where is will be executed and the location of View on Projector will be read out. Of course you can say 

Even though Tell Me service is explained in the context of usage with VoiceSTEER where it would be most useful it can be used along with any Task Computing Clients.

Information providing services take no input and once invoked creates a semantic instance as output. The difference between information providing services and instance providing services is that the instances generated by the information providing services are different from time to time but those generated by the instance providing services are always the same. Some examples of information providing services are temperature service time and date service.

Take the Temperature Service as an example once invoked it checks the current temperature by the sensor and creates a semantic instance with the latest value. It is very useful when combined with Tell Me service mentioned above when user commands Computer Tell me the temperature of the conference room through a voice based Task Computing Client she will hear The temperature is 75 degree. 

 3 Sensor services such as without limitation time weather related temperature and or anything that can be sensed is a type of information providing service.

Sensor services such as Time Temperature services are the semantic object provider services. Once invoked the services may consult devices Web Services Web Pages and or other information sources and return the current time temperature as semantic objects.

A snapshot service will capture a still image from imaging devices such as digital camera digital video camera scanner etc. and returns an image semantic object when it is invoked.

An OWL formatter service accepts semantic objects as its input formats them into a human understandable way and returns it as its output. In one of implementations in current technologies it formats the semantic objects in the Table format in HTML using the ontologies used for the descriptions of those objects and returns the HTML s themselves or the URL s to them.

A text formatter service accepts semantic objects as its input formats them into one of pre determined text formats and saves it as text files appends it to some file etc. For example a text formatter service can accept a Book semantic object and format it into a BibTeX format and append it to the user s own BibTeX file. Or a bioinformatics object such as Protein can be formatted into a format used by Blast application by another text formatter service.

It can be implemented using XSLT and other scripts. For example a text formatter service can hold the table of the pairs of a semantic object and a corresponding formatting XSLT script. When it receives a semantic object the text formatter determines which XSLT script to use to format it by the table and it pops up the dialog box for the user to select which file to save it or to append it to.

In general those internal services are too generic provide and or consume any Thing . So those internal services are provided in different ways by Task Computing Clients from other local and pervasive services . Even though an internal service might be treated very differently from other services its Semantic Service Description is not different on the surface. This allows saving internal services into a composite service and sharing the composite service with others.

The execution of a composition with internal services is as follows. When the execution engine encounters an internal service the execution engine knows it because all internal services are described as a ordinary WSDL Web service with a known WSDL URL the engine will check the WSDL operation name and decide which internal service it is. Once it is decided instead of directly invoking a WSDL web service the engine launches a special module to handle the internal service.

According to an aspect of the embodiments described herein one can implement a real web service at the constant URL for the internal service which serves the same purpose as the internal service. It is useful in some cases when some clients which do not have internal service mechanisms implemented can still invoke the service at the URL. Obviously it is more efficient to invoke it as an internal service in our approach.

The following implemented internal services are described herein 1 Instance Creating Service 2 Instance Copier 3 Intercepting Service 4 Instance Saving Service and 5 Property Choosing Service. Instance creator instance copier interceptor and instance saver are four internal client services that are related to task execution flow control. They share some common modules when dealing with semantic objects. The common modules make it possible for user to dynamically save the semantic instance as a file or to publish a local or pervasive instance providing service. It can be made so that it will feed the semantic instance or its object property to a semantic service composition. User can also load the semantic instance from a file in the local storage or on a Web site for the whole instance or object properties of the instance. It can be made so that it load the semantic instance as a result from a semantic service composition execution. The common modules also perform validity check for the data based on the ontology such as Integer Time etc. .

In a selectable graphical display for Instance Creator is shown. Instance creating service is a service that generates an interactive interface for any semantic type based on the ontology and allows user to create a semantic instance of that type from the interface. It is useful in the case when user wants to test a service with input but does not have any services that provide that type of input. Instance creating service can be put before any services that take input. The output type of the instance creating service is the same as the input type of the service after it.

Copier service is placed between two services in an execution sequence. At its point in the execution flow it just copies its input to its output and does nothing else. It is used mainly for saving compositions with some of the inputs to the composition copied to multiple services. Without the copier the saved composition needs to have multiple inputs that should be exactly the same. With the copier the saved composition can have only one input. Internally within the saved composition the instance copier as the first service accepts the input the input is then copied to multiple services within the composition. The input and output type of the copier is the same as the output type of the previous service.

Interceptor service is placed between two services in an execution sequence. Once inserted it stops at its point in the execution flow parses and displays the output of the previous service. User has chances to review and update the value before continue. If she is not satisfied with the result she might choose to stop the execution. Meanwhile the intermediate results can be saved into a file or published as a semantic instance. Interceptor service can be placed between any two services. The input and output type of the interceptor is the same as the output type of the previous service.

In a selectable graphical display for Instance Saver is shown. Instance saving internal service analyzes and saves any semantic instances. In some scenarios the output generated by a service cannot be consumed by any other services within the environment. Without the instance saving service the result will get lost. With it user has an extra option to store the result for future use or use it in another environment where a service is available to consume it. Instance saving service can be placed after any services that generate outputs. The input type of the instance saving service is the same as the output type of the previous service.

Property chooser is a service that extracts a part of an output and sends to the next service. It is useful in the case when a service is only interested in part of the output that is generated by another service. For instance My Contact service allows user to select a contact item from her Outlook and generates a Contact instance. Map of service accepts an Address instance and displays the map of the address. These two services can not be linked together because there is no super sub class relationship between Contact and Address. However notice that Contact instance has a property called hasBusinessAddress which has Address type. Property chooser service is used here to help user to discover this type of possible composition.

Property chooser service can be placed between two services where the input of the second service is a property of the output of the first service or recursively so . The input type of the property chooser is the same as the output type of the service prior to the property chooser and the output type of the property chooser is the same as the input type of the service after the property chooser.

Described herein is implementation of a Task Computing computer system by segmenting Task Computing environment into a plurality of computer system implementation tiers of a presentation client processing layer a remote procedure call application programming interface API a middleware server processing layer to which the presentation layer interfaces via the remote procedure call API to real time dynamically generate a computer implemented task interface at the presentation layer to a semantically described computer system source of function as a service on a computer system a service layer and a function source realization layer providing the semantically described computer system source of function as the service on the computer system to which the middleware processing layer interfaces and real time dynamically composing an executable task that comprises one or more services according to the generated task interface at the presentation layer to one or more services on the computer system. A computer service is in real time and dynamically composed into an executable task using the generated interface to the service on the computer based upon the semantically described application device and service rich computer. According to an aspect of the embodiments described herein a user practically effectively efficiently dynamically in real time relies on a flexible and unified user interface composition and execution functions to manage interaction and to interact with a pervasive computing environment.

Task Computing is the approach that a seeks to exploit SemanticWeb technologies so that the larger semantic web of resources will be immediately available to ubiquitous computing applications and b is quite agnostic about the nature of the resources as regardless of how they are discovered accessed connected to or communicated with a service abstraction can be used to make them usable by a Task Computing system. Task Computing relies on semantically described services as the universal abstraction of all functionality and in addition Task Computing has a larger scope than device to service interoperability as composable tasks may involve many services . For example a typical Task Computing system task might real time dynamically utilize 5 6 services .

The above described preferred embodiments of the present invention are implemented in software as stored on any known computer readable media and or programmable computing apparatus hardware controlling a programmable apparatus computing device for example a programmable electronic device that can store retrieve present for example display and process data any type of electronic programmable computing apparatus such as without limitation a personal computer a server and or a client computer in case of a client server network architecture networked computers in a distributed network architecture a terminal device a personal digital assistant a mobile device .

The many features and advantages of the invention are apparent from the detailed specification and thus it is intended by the appended claims to cover all such features and advantages of the invention that fall within the true spirit and scope of the invention. Further since numerous modifications and changes will readily occur to those skilled in the art it is not desired to limit the invention to the exact construction and operation illustrated and described and accordingly all suitable modifications and equivalents may be resorted to falling within the scope of the invention.

