---

title: Tool for identifying causes of memory leaks
abstract: A method for identifying memory leak causes is provided. The method initiates with tracking a number of allocations of objects during a time period. Potentially leaking objects are identified and object lifetime tracking instrumentation is injected into the code to track potentially leaking objects. Then, object lifetime logs are generated for each of the potentially leaking objects. A computer readable medium and a system are also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07313661&OS=07313661&RS=07313661
owner: Sun Microsystems, Inc.
number: 07313661
owner_city: Santa Clara
owner_country: US
publication_date: 20050318
---
This application is related to U.S. patent application Ser. No. 10 893 090 filed on Jul. 16 2004 and entitled METHOD FOR MONITORING HEAP FOR MEMORY LEAKS and U.S. patent application Ser. No. 10 893 069 filed on Jul. 16 2004 and entitled METHOD FOR IDENTIFICATION OF OBJECTS CAUSING MEMORY LEAKS. These applications are herein incorporated by reference in their entirety for all purposes.

Most of the programming languages run time systems support dynamic memory allocation and reclamation. In object oriented languages memory can be reserved and released on a per object basis e.g. through object acclamation and reclamation. In some languages for example C freeing memory occupied by an object is done explicitly by calling a special system function. In other object oriented languages e.g. Java that feature so called automatic memory management memory occupied by objects that are not in use anymore is reclaimed automatically by a run time subsystem called a garbage collector. In Java an object is considered unused and available for reclamation if it is not reachable directly or transitively from any object graph root. These roots omitting some second order implementation specific details are stack frames i.e. object type local variables of currently executing methods and object type static variables of currently loaded classes.

A memory leak in a program written on a language such as C with manual memory management is a well known problem that happens when a program does not explicitly free some objects or rough memory area that is previously reserved. If in the course of program execution allocations without reclamation repeat over and over again these allocations may ultimately exhaust all the available memory causing the program to crash.

A language such as Java that features automatic memory management is in theory designed to avoid exactly this kind of a problem. Thus memory leaks in C sense are not possible in Java since every object that is not reachable will sooner or later be automatically reclaimed. However another kind of memory leaks is still possible in Java. Such leaks happen when some object remains reachable but is not used anymore i.e. the program does not read or write its data fields. For example a program may allocate a temporary object attach it to some permanent automatically growable data structure such as an instance of java.util.Vector use this object for some time and then logically discard it. However the object remains attached to the permanent data structure and though not used cannot be reclaimed by the GC. Over time a large number of such unused objects can exhaust the memory available for the program making the latter stop.

A more subtle kind of a memory leak is when some data structure is designed poorly and keeps growing unlimited when it shouldn t. A classical example is a persistent object cache that is not flushed properly. Strictly speaking objects in such a cache are not unused the program can request any of them at any moment. However if the cache does not take care of evicting some objects periodically it may ultimately grow too large again exhausting the memory available for the program.

In light of the foregoing it is desirable to implement a scheme for a method to identify memory leaks occurring in an object oriented program. More specifically a programmer looking for a memory leak typically needs to a identify particular objects that are leaking and b find out why they are leaking i.e. what other objects reference the leaking one s and thus prevent them from being reclaimed by the garbage collector.

In U.S. patent application Ser. No. 10 893 069 a method that identifies particular objects that are leaking is provided. A tool that uses this method can pinpoint objects that are likely leaking giving the programmer for example their addresses in memory contents locations in program where they have been allocated and so on.

However problem b above is not addressed. Existing tools typically provide a partial solution to this problem through the so called heap dump feature. One skilled in the art will appreciate that the contents of the entire object heap of the application in question can be dumped and analyzed through this feature. By analyzing a heap dump the programmer can identify chains of references from garbage collector roots to leaking objects. This information is sometimes sufficient to determine the root cause of the leak.

In certain situations however knowing just what objects hold a leaking object in memory is still insufficient. This is typically the case when these other objects appear to be created and managed by some third party libraries or other code with which the programmer is unfamiliar. In that case knowing the types contents etc. of these objects responsible for a leak may not be of much use to the programmer. What the programmer needs to understand is what actions e.g. function calls in the program resulted in a leaking object attached to certain data structures which prevent it from being garbage collected. Described below is a method and system that implements a scheme to identify memory leaks occurring in an object oriented program.

Broadly speaking the present invention fills these needs by providing a scheme for identifying memory leaks. The present invention can be implemented in numerous ways including as an apparatus a system a device or a method. Several embodiments of the present invention are described below.

In one embodiment a method for identifying memory leak causes is provided. The method initiates with tracking a number of allocations of objects during a time period. Potentially leaking objects are identified and object lifetime tracking instrumentation is injected into the code to track potentially leaking objects. Then object lifetime logs are generated for each of the potentially leaking objects.

In another embodiment a computer readable medium having program instructions for identifying memory leak causes is provided. The computer readable medium includes program instructions for tracking a number of allocations of objects during a time period and program instructions for identifying potentially leaking objects. Program instructions for injecting object lifetime tracking instrumentation to track potentially leaking objects are included. Program instructions for generating object lifetime logs for each of the potentially leaking objects are also provided.

In yet another embodiment a system for identifying memory leaks for an object oriented application is provided. The system includes a microprocessor configured to execute the object oriented application and a memory in communication with the microprocessor. Memory leak identification logic configured to identify memory leaks is included. The memory leak identification logic includes logic for tracking a number of allocations of objects during a time period logic for identifying potentially leaking objects logic for injecting object lifetime tracking instrumentation to track potentially leaking objects and logic for generating object lifetime logs for each of the potentially leaking objects.

Other aspects and advantages of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the invention.

An invention is described for a system and method for evaluating whether an object oriented program has memory leaks and identifying the cause of the memory leaks. It will be obvious however to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

The embodiments of the present invention provide a tool capable of collecting processing and presenting data that may be used to determine if a memory leak is occurring and the cause for the memory leak. In one embodiment a profiling tool may be used to inject code into the application in order to provide a profile. One such profiling tool is discussed in application Ser. No. 10 783 863. The injected code then generates events when it gets executed. From these events a system administrator is able to detect memory leaks and determine the cause of the memory leaks. Discussed below is a brief overview of the profiling tool that may be used in conjunction with the memory leak detection embodiments. Thereafter an enhancement of the tool to identify the cause of the memory leak is discussed.

Application Ser. No. 10 893 069 describes a technique for identification of leaking objects based on tracking the allocation and garbage collection patterns for all objects in the running application. This technique identifies types and allocation sites for objects that are leaking. However it does not give the user a real insight into the reasons why the leaking objects are being held in memory i.e.

Tools that provide features for memory leak debugging for example OPTIMIZEIT from BORLAND JPROBE from QUEST SOFTWARE and JPROFILER from EJ TECHNOLOGIES can provide answer to question 1 above by performing a so called heap dump and then finding all chains of references that point to given objects. However they don t provide an answer to question 2. Since the leaking object may end up attached to some obscure data structure defined for example deeply in the code of a third party library these tools are rendered useless for this function. Therefore the user may have no clue about when how this data structure was created what it is used for and how their object got attached to it.

Discussed below is how potentially leaking objects can be identified in an improved manner as explained in U.S. patent application Ser. No. 10 893 069. Thereafter according to the embodiments of this invention a tool is provided to aid a user in identifying the reasons for such objects to leak.

According to the embodiments of U.S. patent application Ser. No. 10 893 069 each object allocation site i.e. a location in the application s code where object allocation instruction s are located is instrumented so that every time an object is allocated the information about this event is recorded. Instrumentation may be performed in either the source or the binary code and in many possible ways. For example a call to a special predefined function may be inserted just before or just after the call to the new operator as in the following example one skilled in the art will appreciate that while the code samples provided in this application are written in Java the invention is not restricted to a Java programming language. That is any suitable object oriented programming language may utilize the profiling tool discussed herein 

The recordObjectAllocation className method is called every time an object is allocated and it records the fact that an object of the given type has been allocated by the application. Thus it is possible to provide data about the number and types of allocated objects. This method may also sample the current stack contents to obtain the full call path that leads to the given object allocation. Stack sampling can be performed differently depending on the programming language environment and platform used. It can be implemented as e.g. a low level mechanism written in assembly language that traverses the physical stack for a given thread. For high level languages such as Java a special mechanism such as the Java Virtual Machine Profiler Interface JVMPI Application Programming Interface API in the Java standard may exist that returns the contents of the stack corresponding to the Java program methods. The JVMPI is a two way function call interface between the Java virtual machine and an in process profiler agent.

The embodiments described herein provide a scheme that allows for easily distinguishing between leaking and non leaking objects in most situations. Additionally the scheme can identify where leaking objects are allocated which in turn can assist in quickly identifying the root cause of the problem in order to correct the memory leaks. As most memory leaks develop as a gradual increase in the number of unused objects the scheme described herein is well suited for the identification of these gradual increases. In one embodiment the scheme requires support from the virtual machine or a run time system on top of which a program in question runs. The system should be able to intercept object reclamation events for individual objects also referred to as object garbage collection events and garbage collection finish events i.e. when a given garbage collection cycle is finished and the user application that was suspended to make garbage collection possible is ready to be resumed . Once the event is intercepted the system should notify a user or a special profiling debugging tool about this event. If a system can intercept object allocation events as well it may also be useful this can be used as an alternative to injected calls such as recordObjectAllocation described above . It should be appreciated that support for interception of object reclamation events is available for example in modern Java virtual machines where it can be implemented either using weak references instances of a special library class such as java.lang.ref.WeakReference standard library class . Alternatively support for object reclamation may be available through special application program interfaces designed to be used by profiling and debugging tools such as JVMPI and Java Virtual Machine Debug Interface JVMDI .

As mentioned above the embodiments described herein take advantage of the fact that a typical memory leak appears as a steadily growing group of objects of some type which never gets reclaimed. One embodiment of this invention provides a way of distinguishing objects associated with memory leaks from other healthy groups of objects of the same type that are either short lived i.e. reclaimed quickly or long lived but have been allocated once and do not grow in number any longer. In order to distinguish objects in these groups three kinds of events are tracked object allocation object reclamation and garbage collection i.e. a garbage collection finish event. The virtual manager or any other suitable run time system is enabled to intercept these events.

In another low overhead embodiment described further below a system administrator is able to detect memory leaks in running applications without impacting application performance. The running application is written in an object oriented language. For this embodiment to work it is necessary that the VM or runtime system that executes the application features Mark and Compact Copying or other suitable garbage collector object reclamation mechanism that preserves the order in which objects have been allocated. Here again the scheme exploits the fact that a memory leak demonstrates an object allocation reclamation pattern where some objects remain alive after each garbage collection event. Thus the age spread for these objects grows steadily irrespective of the number of object changes. The object age is defined as the number of survived garbage collection events.

As illustrated further below the object s allocated during a given epoch and surviving a garbage collection that ends this epoch are referred to as a surviving generation. It should be further appreciated that the terms garbage collection and object reclamation are interchangeable as used herein. In the Figures described below illustrate embodiments that detect a memory leak and provide information on the location of the memory leak. Further embodiments that do not add noticeable runtime overhead are discussed in more detail U.S. application Ser. No. 10 893 069.

In Table captures the sequential epoch numbers and the number of surviving objects for each sequential epoch number. That is each row of the table corresponds to a surviving generation of objects. Here whenever an object is allocated and Table is updated Table is checked if a line for the corresponding epoch exists. If a line for the corresponding epoch exists then the number of objects in this line is incremented. If a line for the corresponding epoch does not exist then a new line is created with the initial value equal to one. Whenever an object is reclaimed and Table is updated accordingly the counter in the corresponding epoch line of Table is decremented. Thus if the object associated with epoch of Table is reclaimed the number of surviving objects associated with epoch would be reduced by 1 resulting in 0. When the counter reaches zero the table is compacted so that there are no lines in Table with a number of objects equal to zero. It should be appreciated that the number of non empty lines in Table represents the number of surviving generations. That is in Table there are five surviving generations as there are five lines or rows. As the number of surviving generations increases it is more likely that a memory leak is present.

The method of then breaks off into four branches where the four branches may be executed in parallel e.g. four concurrent threads may be executing each branch. It should be apparent to one skilled in the art that the code representing one or more of the branches for example the one that registers object allocation events may be executed on behalf of the threads of the user application or the code may be executed by a thread specially set up by the profiling tool for the corresponding task. In the first branch operation detects an object allocation event. It should be appreciated that object allocation events may be detected as discussed in application Ser. No. 10 783 683. Then in operation the epoch number and object allocation event are recorded. Thus Tables and are being built as described above in this branch. In operation the number of objects associated with the epoch number is incremented as described with reference to the Tables of . In decision operation it is determined whether or not to continue. One skilled in the art will appreciate that the explicit check for continuation may or may not be present in the real implementation such a check can be effectively replaced with for example an operation to terminate the corresponding thread of execution by force. If it is desired to continue the method returns to operation and repeats as described above. If it is determined not to continue the branch terminates.

In the second branch in operation a garbage collection finish event is detected. After detecting the garbage collection finish event the epoch counter is incremented in operation . For example another epoch line may be added to the epoch number of surviving objects table discussed above or an appropriate global counter may be incremented. Then in operation it is determined whether or not to continue. If it is desired to continue the method returns to operation and repeats as described above. If it is not desired to continue the branch terminates. In the third branch an object garbage collection event is detected. In one embodiment reclamation of an object occurs here. The method then advances to operation where the epoch number and object garbage collection event are recorded. Then in operation the number of objects associated with the epoch number is decremented due to the reclamation of the object. Thus the Tables described above in may be compacted here. In decision operation if it is desired to continue the method returns to operation and repeats as above while if it is not desired to continue the branch terminates.

In the fourth branch in operation the number of epochs having surviving objects is checked. This number may then be displayed in a graphical user interface in order to alert the user as to a possible memory leak. One exemplary embodiment of the graphical user interface includes . The method then advances to operation where it is determined whether or not to continue. If it is determined to continue the method returns to operation while if it is not determined to continue the branch terminates. One skilled in the art will appreciate that a certain number of time periods i.e. epochs may have to occur prior to concluding that a memory leak is occurring. That is the data structures referred to above are built to a certain point in order to have a suitable confidence level to conclude that a memory leak is present.

In order to keep track of object allocations and reclamations in the Java programming language platform it is possible to use the following mechanism in one embodiment of the invention. All object allocation sites are instrumented such that immediately after an object is allocated a method referred to as trackObjectAllocation Ojbect obj is called. This method reads the current epoch number the stack trace for the call and eventually associates an object with all this information. In one embodiment for the profiling system JFLUID of the assignee this is done by creating a unique object ID as a combination of the object s class id epoch number and the serial number of the object itself. This ID along with the stack trace is sent to the JFLUID client tool that maintains the call stacks epoch number of surviving objects tables and presents the final results to the user.

The trackObjectAllocation method also creates a weak reference an instance of the java.lang.WeakReference class for obj and puts a WeakReference obj ObjectID obj pair into the special hash table that it maintains. Additionally the above weak reference is associated with a single reference queue an instance of java.lang.ref.ReferenceQueue class which is also maintained. This mechanism allows for a notification when obj gets reclaimed. To get a notification a separate thread is run in parallel with the main program that keeps querying the reference queue for discarded objects using the ReferenceQueue.remove method. Once this method returns with a WeakReference instance the corresponding object obj is about to be garbage collected. The hash table is accessed to get the unique object ID for obj and remove WeakReference obj from the table. Finally the objectID obj is sent to the JFLUID client tool that updates the corresponding epoch number of objects table accordingly.

Ultimately the JFLUID tool allows the user to request information about the number of live objects for each type their average age expressed in survived epochs and the maximum number of surviving generations. Information can be sorted by each of these numbers. If the user suspects that the program has a memory leak the user can choose sorting types by the maximum number of surviving generations and then check periodically if this value is relatively large and keeps growing for some type. If that is the case the user can further determine which combination of allocation site call stack results in objects with the largest number of surviving generations. It should be appreciated that knowing the leaking class and this location may be a significant help in identifying the root cause of the memory leak.

To enhance the embodiments described above to aid the user in understanding the reason of why certain objects are leaking discussed below are embodiments that provide a history of object s life that the user can further analyze. The proposed technique is described in the context of the Java programming language and platform. However its general principles should be applicable in whole or in part to other programming languages runtime systems that implement the same principle of dynamic object allocation and automatic garbage collection. The embodiments below describe a tool that can essentially perform the controlled execution of the user s application make the application generate data about this execution and collect and present this data.

Initially the tool identifies objects that are leaking i.e. types classes and allocation sites for such objects. In one embodiment this is achieved using the technique described above with references to and as further described in application Ser. No. 10 893 069.

In one embodiment all allocation sites identified as possible sources of leaking objects should be instrumented e.g.

In essence the regsiterObjectAllocation call registers creation of the object and the location in the program code where it happened. Note that registerObjectAllocation and other instrumentation calls discussed below take two parameters. The first parameter is the leaking object itself. The second parameter may be referred to as a code location identifier. The code location identifier is used to identify a location in the source code where the instrumented action is performed. It should be appreciated that code location identifier may take many different forms for example it may be some combination of the source code file identifier and the source line number in that file and so on.

Next the tool instruments all or some locations in the program where instances of the class in question can be passed around . Locations where instances of the class may be passed around include locations in the code where 

Such locations can in the simplest form be identified based entirely on the type information for leaking objects. In other words if it has been determined that leaking objects belong to an imaginary class shown below 

The terms Instrumentation or instrumented as used herein mean that calls to special functions also referred to as methods are inserted or injected into the application code. These special functions are defined in a library that provides an API callable from the target application. This library is logically a part of the tool and is designed to collect and convey information between the target application and the tool. It should be appreciated that instrumentation can be done in many ways. In the simplest to explain form for ease of illustration the tool can process the source code of the application and transform it in the following way same code examples as above are used 

An equivalent of the above described example can be performed by analyzing and transforming the compiled program representation e.g. the binary code or the bytecode as it is the case with Java. It should be appreciated that instrumentation can be done statically at class load time or dynamically at runtime e.g. using code hotswapping.

One skilled in the art will realize that the above code is given for purely illustrative purposes and embodiments of this invention can be used in many different methods for registering potentially leaking objects checking if the given object is registered as a potentially leaking one and recording various events happening with the object. For example some run time systems in particular some Java Virtual Machines may provide an API for explicitly tagging objects. That is a runtime environment itself may provide some space in each object or associated with each object where one or more tags for a given object may be stored. In that case there will be no need to maintain the explicit leakingObjectsTable data structure. Also logging of the information about object allocations and object pass around may be recorded in many different forms. For example a log record may be optimized for space and time efficiency by replacing text such as Object passed with just a single byte or a combination of a few bits denoting the corresponding event. In addition the logging data may be sent over the network instead of being written into a file and so on.

What is eventually presented to the user is a list of objects that are likely leaking which may be referred to as suspicious objects as detected through the embodiments described above with reference to along with the corresponding pass around logs. These pass around logs also referred to as an object lifetime log may be text consisting of records such as 

In another embodiment this object lifetime log is interactive e.g. double clicking at a given line in the log will open an editor window positioned at the corresponding location in the source code thereby enabling a user to easily gain access to the corresponding location in the source code.

In yet another embodiment the user may not see any explicit log at all. Instead by pressing a key repeatedly the user will cause the editor to highlight the locations in the program where the given object was allocated and then passed around in order of the corresponding events.

The log data can be further correlated in an automated manner with the result of a heap dump. For example the user may click on the log line where a reference to the object is assigned to some other object s field and see what holds the latter in memory. Using the above data the user can easily determine what actions in their applications caused the given objects to leak.

In one embodiment the logic mentioned above is computer code stored in memory that accomplishes the functionality described with reference to the flowcharts of . Display of is included with the computing device and is used to display the GUIs described above. Of course display may be integrated into computing device . One skilled in the art will appreciate that each logic element described herein may a hardware component software or a combination of hardware and software.

In summary the present invention provides a scheme for notifying the user about a memory leak in an object oriented program and identifying the cause of the memory leak. The object oriented code is instrumented to identify potentially leaking objects. Such objects are then tracked through injected code. The injected code generates object lifetime logs so that a determination may be made as to whether the object is leaking and the corresponding cause for the leaking object. Through the object lifetime logs a user may determine the cause of a leaking object. In one embodiment the object lifetime log is interactive enabling a user to gain access to a corresponding location in the source code through an editor window.

With the above embodiments in mind it should be understood that the invention may employ various computer implemented operations involving data stored in computer systems. These operations include operations requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing.

The above described invention may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributing computing environments where tasks are performed by remote processing devices that are linked through a communications network.

The invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which can be thereafter read by a computer system. A communications medium includes an electromagnetic carrier wave in which the computer code is embodied. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs magnetic tapes and other optical and non optical data storage devices. The communications medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

