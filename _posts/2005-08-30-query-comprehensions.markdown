---

title: Query comprehensions
abstract: The subject disclosure pertains to interaction with one or more collections of data. Queries and domains are presented as separate entities. A number of compositional operators are provided to manipulate a generic collection of data at a low level. Query comprehensions can specify interactions with one or more collections at a higher or more intuitive level. The query comprehensions can be translated or mapped to operators that can be employed to interact with one or more data collections and return results where applicable.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07730079&OS=07730079&RS=07730079
owner: Microsoft Corporation
number: 07730079
owner_city: Redmond
owner_country: US
publication_date: 20050830
---
This application is related to U.S. patent application Ser. No. 11 170 545 filed Aug. 30 2005 and entitled PROGRAMMATIC QUERY ASSISTANCE .

A database is a collection of data or facts organized in a systematic manner and persisted to a storage device by a database management system. The data can be structured according to a variety of methods or models. For example a hierarchical data model associates each piece of knowledge with a record and places the records in a tree data structure such that each record is owned by only one entity. An extension of the hierarchical model is the network model that arranges the records in a graph data structure allowing for a record to have multiple parents and children. A database can also be represented using a simple flat file model. In such a model the information is stored in a plain text file with one record per line. At present XML is a popular format for storing data or text hierarchically. However the most common model employed today is still the relational database model wherein mathematical relations based on set theory and predicate logic represent the data.

The organized nature of database data enables computer programs to retrieve answers to questions easily and efficiently. In particular computer programs can create manipulate and retrieve data from a database utilizing a query. For a relational database management system the query can be formatted utilizing the structured query language SQL . For example to extract the complete customer records for all customers with the last name Smith the SQL query expression could be formatted like SELECT FROM customers WHERE lastname Smith . In this example the keyword SELECT indicates the query is a retrieval query the keyword FROM specifies which table of the database the data is to be found in this case customers and the keyword WHERE designates that only the rows with columns matching the given parameters should be returned.

In the event that XML is utilized to store data hierarchically a different query language is employed to interact with XML. XML Path Language XPath is a language recommended by the World Wide Web Consortium W3C for addressing portions of an XML document. In XPath the previous SQL example would be formatted as xmlDoc.selectNodes customer lastname Smith . In this example the query returns all customer element nodes that have a lastname child node with the value Smith. The W3C is presently developing a language called XQuery that is built on XPath. XQuery is designed to query XML data to retrieve and manipulate data from XML documents or a data source capable of being viewed as XML data.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described query systems and methodologies are disclosed herein. In accordance with one aspect of the disclosure query comprehensions are provided. Query comprehensions provide a concise and compositional mechanism for specification of queries. Query comprehensions are data format or shape agnostic and therefore are able to be employed over one or more arbitrary collections. Query comprehensions can be translated or mapped to more primitive operators that can interact with collections of various types. Queries are thus separated from domains. Accordingly a single query could be utilized to retrieve relational data as well as XML for example.

In accordance with another aspect of the subject innovation abbreviations can be utilized. Abbreviations are shorthand notation for more complex query comprehensions. To evaluate an abbreviation the abbreviation is first eliminated by translation to a corresponding expanded comprehension. The comprehension can then be mapped to one or more sequence operators which can be utilized to interact with collections.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject invention are now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the claimed subject matter.

As used herein the terms component and system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. Furthermore various exemplary code snippets are provided throughout in various programming languages executable by various architectures. It should be appreciated that these examples are provided for purposes of clarity and understanding and are not meant to limit the scope of the disclosed subject matter to the languages or architectures provided.

As used herein the term infer or inference refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the disclosed subject matter.

Furthermore the disclosed subject matter may be implemented as a system method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer or processor based device to implement aspects detailed herein. The term article of manufacture or alternatively computer program product as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick jump drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Turning initially to a query system is depicted in accordance with an aspect of the disclosed subject matter. Query system includes a query component and a translation component . Query component can receive retrieve or otherwise acquire or obtain one or more query comprehensions. A query comprehension is a concise and compositional expression of a query. In particular query comprehensions are easy to comprehend by understanding each sub expression in isolation. Compositionality produces a language that is easy to comprehend and ensures that the semantics and typing rules of the language can be defined clearly. In addition query comprehensions are language or data format agnostic. Hence queries are separated or independent of a domain. Query component is communicatively coupled to translation component . Translation component obtains a query comprehension from the query component and translates transforms or maps the query comprehension to one or more primitive operators among other things.

Operators such as sequence operators interact with one or more data collections. A data collection can embody a generalized collection or monoid. A collection can be but is not limited to being a mathematical collection such as lists e.g. ordered . . . sets bags and an operational collection including arrays enumerables enumerators cursorables and cursors. Sequence operators can provide monad operations on collections including but not limited to filtering mapping transforming accumulation and folding. For example operators can facilitate filtering by analyzing a collection and throwing out values that do not satisfy a predicate. Additionally or alternatively operators can perform some transformation on every element or sum all values in a collection. In one particular aspect of the innovation a fixed set of operators can be employed to provide base or primitive operations on collections. Stated differently the sequence operators provide the low level building blocks upon which query comprehensions can be built. A high level syntax can be utilized to define a query comprehension that translates into one or more query operators. This means that the underlying operators are bound to whatever sequence operators are in scope. This implies that by importing a particular implementation the query syntax can effectively be rebound by a user for instance. In particular query comprehensions can be rebound to a sequence operator implementation that attempts to distribute the execution of the query over several data sources.

By way of example and not limitation a query comprehension can be specified that looks like SQL structured query language or has a SQL style format and is translated by translation component into one or more query operators or an expression including query operators. In this instance the query would not be restricted to operations on relational data as is the convention. Rather the query could operate over relational tables objects XML Extensible Mark up Language as well as other data formats and or shapes. The query comprehension is independent of or divorced from a data domain. The query can operate over arbitrary collections.

Turning to a query translation component is illustrated in accordance with an aspect of the subject innovation. Translation component is operable to translate a query comprehension into an expression specified with operators. As a result the query comprehension can be specified very concisely at a high level and translated to a more expansive and primitive expression that represents the semantics of the query comprehension. Query translation component can include a map component a type inference component and an optimization component . The map component can include and or interact with a map that identifies operators that correspond to query comprehensions or elements thereof. In addition some or all types may not be explicitly denoted by a query comprehension for purposes of precise and or concise expression. Accordingly type inference component can be employed to infer one or more types associated with a translated query comprehension. Types can be inferred based on context including but not limited to the semantics and or syntax of the query comprehension and corresponding operators. Optimization component can also be employed by the translation component to facilitate generation of a translated query comprehension that is optimal in terms of execution. For instance optimization component can interact with map component . Where different operators can be employed to capture the semantics of the query comprehension operators can be selected that optimize execution. Furthermore it should be appreciated that optimization component could also reorganize group ungroup or otherwise manipulate an operator expression produced by translation component to produce the best possible expression for execution.

The discussion that follows provides a few exemplary cases to facilitate clarity and understanding with respect to aspects of the subject innovation. Consider the following types that model companies customers and orders 

It should also be appreciated that by giving the iteration variable an explicit type when drawing from an untyped collection the elements of a collection can be accessed in a strongly typed way. For example 

It should also be noted that when the From clause includes only one source collection the generic translation could be simplified and with the omission of an intermediate tuple. Hence an optimized translation could be 

In another example a query is specified that returns the collection of distinct salaries for all software design engineers.

In yet another example all items that Paul Vick has purchased are returned. Note the variable C is in scope in the quantification over O 

Inside a translated query the identifier It is bound to the current row for instance. Members of It are automatically in scope. The notion of It corresponds to a context item for example as provided in XQuery. Besides It depending on the type of the underlying collection and if the corresponding overload is available as a sequence operator there my also be a special variable Position in scope that is bound to the position of It within the collection of items currently being processed. For example 

Thus far all example queries have returned a single result. A row is also just a single value with multiple fields. The following query projects the name position and salary of each employee 

It should be appreciated that query comprehensions need not return flat results. The next query returns a nested result that contains the name age and salary of software design engineers older than forty two 

As per SQL people do not always give names to columns in the result but still want to use that column for sorting. To support such a scenario anonymous types should support indexing and be allowed to contain unlabeled members. For example consider the next query comprehension 

Aggregate operators such as Min Max Count Avg Sum and the like operate on collections and reduce their argument collection to a single value. The aggregate function Count for instance has type signature Shared Count Src As IEnumerable Of T As Integer when defined as an extension method. By way of example the number of programmers can be counted using the following query 

With respect to aggregation over a subset of columns the values of the non aggregated columns can be implicitly aggregated into table and the overall results of the query is a signal row that contains this tables along with the results of the explicit aggregations. For example 

Query comprehensions can also employ transitive access. Many of the sequence operator aggregates take an additional delegates parameter. For example Orders.Sum O O.Price is shorthand for Orders.Select O O.Price .Sum . Without a lambda expression a programmer is forced in Visual Basic to write a much longer nested select Select Sum O.Price From O In Orders. Using transitive member access once can write Sum Orders..Price or Orders..Price.Sum . The single dot . retrieves the price of a single order whereas the double dot .. obtains the price of a collection of orders.

Quantifiers can be employed within query comprehensions. The existential quantifier Some I In Items Satisfies P I is an aggregate function that returns False when no element I in the collection Items satisfies the predicate P I . This implies that when the Items collection is empty the result is False. Dually the universal quantifier Every I In Items Satisfies P I returns False if there is an element I in the collection of Items that does not satisfy the predicate P I . This implies that when the Items collection is empty the result is True. Consider the following exemplary query that selects the names of all customers that have ordered wine 

Aggregate functions are often utilized in combination with grouping. In this section the long form is specified but these queries can be specified much more concisely using abbreviated forms defined later. The next query groups all employees into partitions where each employees has the same salary and then returns each distinct salary with the number of employees earning that salary 

The results of queries can be sorted using the Order By clause. The following query sorts all employees by their name and then by descending age as the tie breaker. Sort conditions can be followed by the modifier Asc or Desc that specifies the sorting order. The default sorting order can be either ascending or descending. In the following examples ascending will be assumed to be the default. Consider the following 

The Order By clause can refer to members bound in the From clause or in a comprehension involving grouping the members in the Group By clause as well as the members in the final Select list. Consider for example 

Query system of has been designed among other things to allow query expressions to be arbitrarily composed as query comprehensions. Such compositionality enables queries to be understood by understanding each individual sub expression. This is contrary to conventional query languages and systems including but not limited to SQL.

The SQL language and supporting system s are not compositional. Rather SQL is an ad hoc design with many special cases. It is not possible to understand a complex SQL query by understanding the individual pieces. One of the reasons that SQL lacks compositionality is that the underlying flat relational data model of SQL is itself not compositional for instance all tables must be flat. As a result instead of breaking up complex expressions into smaller units as described herein SQL programmers are forced to write a monolithic expression whose result fits in the SQL data model. A more serious negative consequence of the flat relational model is that it does not naturally generalize to deal with other forms of data such as XML and objects.

The subject innovation provides for and interacts with a query language based on the notion of monoids and monoid comprehensions. Monoids embody generalized collections and can include both strongly and late bound mathematical collections such as lists sets bags operational collections such as arrays enumerables enumerators cursorables and cursors. Where the type system is fully compositional there are no restrictions on what types can appear as components of other types. As a result rows objects XML active directory files registry entries and the like are all first class citizens.

The subject innovation can support special cases and thereby maintain the spirit of such languages as SQL by providing for abbreviations. Abbreviations can make query comprehensions more concise albeit less compositional. The semantics of such abbreviation can be defined by translation into the fully compositional explicit form.

Abbreviation component can receive retrieve or otherwise obtain or acquire abbreviations. Query abbreviations can be employed as an additional level of abstraction for particular situations or scenarios. In other words abbreviations can abbreviate or provide shorthand for specification of particular query comprehensions. Upon receipt or retrieval of an abbreviation abbreviation component can translate the abbreviation to a query comprehension. For example this could be implemented such that abbreviation consults a map among other things to facilitate translation. Accordingly system can receive a query abbreviation and translate or map that abbreviation to a query comprehension. That query comprehension can then be translated or mapped to one or more operators that can interact with and manipulate collections of data.

Abbreviations can be beneficial in a variety of specific scenarios including but not limited to iteration ordering flattening aggregation and grouping let binding composite predicates query fragments and joins. As per iteration variables when the From clause draws from only one source there is no need to give a name to the iteration variable. Consider the following query 

Abbreviations can also be utilized with respect to flattening nested collections. There can be two operators for selection such as Select and SelectMany where the latter is employed to flatten a nested result collection. As an example the Orders member of Customer can be a collection of type Set Of Order . Hence selecting the orders of a collection of customers would result in a nested collection of orders. To obtain a single collection of all the orders of all the customers one could write 

Abbreviations can also be employed with respect to aggregates and groupings. Queries involving aggregates and groupings are rather verbose since they need to drill into the Group field of the partition. The following query returns each unique salary and the number of employees when the minimum age of the employees with that salary is at least forty two years old.

Another form of abbreviation supported by the subject innovation is a let binding. A let binding allows one to compute a value and use it multiple times such as through an assignment. Consider the following let binding inside the From clause where Total is computed and utilized again by the Order By clause 

Abbreviations can also consist of composite predicates including but not limited to Any and Some. For instance composite predicates in SQL such as X circle around X Any Xs and X circle around X Some Xs can be defined as Xs.Any A X circle around X A and Xs.Some A X circle around X A respectively.

Abbreviations can further enable the specification of query fragments. It is not always necessary to write complete queries. For example Xs OrderBy Salary Asc Age Dec can be an abbreviation for Select It From Xs OrderBy Salary Asc Age Desc. Similarly Xs Where Price 100 can be an abbreviation for Select It From Xs Where Price 100. 

Joins can also be abbreviated. Since arbitrary nesting is allowed all the different kinds of joins can be expressed directly using normal Cartesian product. However different forms of joins can be represented as abbreviations. Inner joins in SQL correspond directly to Cartesian products with a filter 

Outer joins are used to traverse relationships Left Outer Join to navigate a one to many relationship Right Outer Join to navigate a many to one relationship and Full Outer Join to navigate a many to many relationship. It should be noted that because SQL cannot return a nested result it is forced to return a flat table that fills rows with nulls when the many side of the relationship is empty. That means that instead of writing a simple nested query to select all customers with the products of all their orders such as 

It should be appreciated that aspects of this disclosure including but not limited to abbreviations can be applicable to many data types or formats. To highlight this feature further the following example is provided to illustrate employment with respect to XML. Consider the following exemplary query that selects all books from Addison Wesley that are published since 1991 

The preceding set of examples is not comprehensive. Query comprehensions and abbreviations can be employed in a plurality of other instances for example in recursive queries pivot and unpivot and transaction blocks.

Turning to a query evaluation system is illustrated. System includes a receiver component a processor component and a data collection s . In accordance with one aspect of the disclosed subject matter query evaluation system can form part of a compiler as described in further detail below. Receiver component receives retrieves or otherwise obtains or acquires query comprehensions abbreviated query comprehensions or sequence operators. Receiver component is communicatively coupled to processor component . Processor component is communicatively coupled to data collection s and is able to interact with collection s . Upon receipt of a query comprehension abbreviation abbreviation thereof or sequence operators the processor component can evaluate a query as specified with respect to one or more data collections and return results where applicable. In the case where the received input is a query comprehension the processor component can translate the comprehension into sequence operators which can then be executed with respect to one or more data collections . If the received query is or includes an abbreviated query comprehension or an abbreviation the abbreviation can be translated into a query comprehension which can subsequently be translated to one or more sequence operators that are executable with respect to one or more data collections . Translation between query comprehensions and sequence operators and or abbreviations and query comprehensions can be performed as described supra with respect to or substantially similar thereto.

Turning to a custom abbreviation system is provided in accordance with an aspect of the disclosed innovation. Although a system may include native abbreviations for queries or query comprehensions it is also possible that a user may desire to create their own custom comprehension abbreviations utilizing system . System includes an abbreviation generation component and a map modification component . Abbreviation generation component is a mechanism that facilitates specification of a custom abbreviation and the manner in which it maps to a query comprehension s . For example generation component may include or interact with a graphical user interface GUI to aid in developing a custom abbreviation. Abbreviation generation component can be communicatively coupled to map modification component . A map can define the mapping or correspondence between an abbreviation and one or more query comprehensions. The map can already include those mappings for native or system defined abbreviations. Abbreviation generation component can transmit and map modification component can receive a new mapping for a custom abbreviation. Map modification component can then modify the abbreviation map or the like to include the new mapping. Thereafter the custom abbreviation can be employed the same as native abbreviation to facilitate query specification.

The aforementioned systems have been described with respect to interaction between several components. It should be appreciated that such systems and components can include those components or sub components specified therein some of the specified components or sub components and or additional components. For example translation component can include map component type inference component and optimization component or some combination thereof. Additionally or alternatively processor component could include query component and translation component . Sub components could also be implemented as components communicatively coupled to other components rather than included within parent components. Further yet one or more components and or sub components may be combined into a single component providing aggregate functionality. The components may also interact with one or more other components not specifically described herein but known by those of skill in the art.

Furthermore as will be appreciated various portions of the disclosed systems above and methods below may include or consist of artificial intelligence or knowledge or rule based components sub components processes means methodologies or mechanisms e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines classifiers . . . . Such components inter alia can automate certain mechanisms or processes performed thereby to make portions of the systems and methods more adaptive as well as efficient and intelligent. By way of example and not limitation type inference component can employ such methods or mechanism to infer types based on context.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodologies described hereinafter.

Additionally it should be further appreciated that the methodologies disclosed hereinafter and throughout this specification are capable of being stored on an article of manufacture to facilitate transporting and transferring such methodologies to computers or other processor based devices. The term article of manufacture as used is intended to encompass a computer program accessible from any computer readable device carrier or media.

Turning to a query processing methodology is depicted in accordance with an aspect of the disclosed subject matter. At reference numeral a query comprehension expression is acquired. A query comprehension can specify a query in a concise manner that is independent of a particular data type or shape on which actions are to be performed. Thus there is a separation between the query and the data to be queried. At the received query comprehension is translated to one or more operators. Operators such as sequence operators are more primitive methods that perform operations on arbitrary collections. The semantics of query comprehensions can be defined by translation into more primitive operators. The underlying operators are bound to whatever operators are in scope. Once translated from a query comprehension to operator s the query can be evaluated at . Evaluation can include manipulation and or retrieval of data. The query can be evaluated by executing the operator s on one or more collections of data. At results can be produced or returned where applicable.

Compiler can accept as input a file having source code associated with processing of a sequence of elements. The source code may include query comprehensions and abbreviations other expressions associated functions methods and or other programmatic constructs. Compiler may process source code in conjunction with one or more components for analyzing constructs and generating or injecting code.

A front end component reads and performs lexical analysis upon the source code. In essence the front end component reads and translates a sequence of characters e.g. alphanumeric in the source code into syntactic elements or tokens indicating constants identifiers operator symbols keywords and punctuation among other things.

Converter component parses the tokens into an intermediate representation. For instance the converter component can check syntax and group tokens into expressions or other syntactic structures which in turn coalesce into statement trees. Conceptually these trees form a parse tree . Furthermore and as appropriate the converter module can place entries into a symbol table that lists symbol names and type information used in the source code along with related characteristics.

A state can be employed to track the progress of the compiler in processing the received or retrieved source code and forming the parse tree . For example different state values indicate that the compiler is at the start of a class definition or functions has just declared a class member or has completed an expression. As the compiler progresses it continually updates the state . The compiler may partially or fully expose the state to an outside entity which can then provide input to the compiler .

Based upon constructs or other signals in the source code or if the opportunity is otherwise recognized the converter component or another component can inject code to facilitate efficient and proper execution. For example code can be injected to expand a comprehension abbreviation or translate from a query comprehension to sequence operators. Rules coded into the converter component or other component indicates what must be done to implement the desired functionality and identify locations where the code is to be injected or where other operations are to be carried out. Injected code typically includes added statements metadata or other elements at one or more locations but this term can also include changing deleting or otherwise modifying existing source code. Injected code can be stored as one or more templates or in some other form. In addition it should be appreciated that symbol table manipulations and parse tree transformations can take place.

Based on the symbol table and the parse tree a back end component can translate the intermediate representation into output code. The back end component converts the intermediate representation into instructions executable in or by a target processor into memory allocations for variables and so forth. The output code can be executable by a real processor but the invention also contemplates output code that is executable by a virtual processor.

Furthermore the front end component and the back end component can perform additional functions such as code optimization and can perform the described operations as a single phase or in multiple phases. Various other aspects of the components of compiler are conventional in nature and can be substituted with components performing equivalent functions. Additionally at various stages during processing of the source code an error checker component can check for errors such as errors in lexical structure syntax errors and even semantic errors. Upon detection error checker component can halt compilation and generate a message indicative of the error.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like displays e.g. flat panel and CRT speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems power modems and DSL modems ISDN adapters and Ethernet cards or components.

The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having or variations thereof are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

