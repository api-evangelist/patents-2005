---

title: Computer method and system for automatically creating tests for checking software
abstract: Computer system and method automatically generates a test source code for checking validity of an application written in an object oriented language. The application includes objects accessible through an interface implementing programming rules and object behavior rules. For each object, the invention extracts object methods and attributes of the object interface which are impacted by the object behavior rules and extracts the object identification. The invention fills the variable fields of a source code template with the extracted information. The template non variable source code is in conformance with the programming rules and implements a scenario for checking a set of object behavior rules; thus the filled template forms a generated test source code. For distributed applications, the specifications may be EJB or CORBA and the Test Generator uses templates for checking the life-cycle (creation, persistency, removal) of deployed objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07707553&OS=07707553&RS=07707553
owner: International Business Machines Corporation
number: 07707553
owner_city: Armonk
owner_country: US
publication_date: 20051208
---
The present invention generally relates to automatic creation of tests for software more particularly the present invention applies to creating tests for software written in an object oriented programming language such as Java or C .

To check a software work e.g. program routine procedure application or the like the developers have to decide what needs to be tested and how. Traditionally the developers generate unit tests for checking all the functions of the software. However it is not realistic to consider that all the functions of the software will be tested with all the possible inputs. In the same way when a software is written with an object oriented language it is impossible to test all the methods of a class for all possible inputs. Thus the developers try to design tests that highlight bugs in their software.

To help developers to write tests software companies have created tools to automate the generation of tests. There are two interests in using these tools they save time and induce reliability. However in order to make these tests more efficient there is a need to improve the logic behind the generation of test. The tests are automatically generated by these tools according to a logic which can be that the functions are systematically tested one after one with simple values such as 0 or null pointer as parameters. Other logics test functions in a random order or in the order they appear in the source code or according to a source coverage or according to a record of a previous execution of a function for a replay. So one example is to create calls of all the methods of a class in the order they appear in the source code calls to all the methods in a random order calls to setter fields methods then the getters etc. The input are taken either at random or in an set of values that are expected to be critical null pointer null integer value negative or positive value empty string etc . . . .

In the U.S. Pat. No. 5 708 774 the tests are automatically created for detecting errors in the successive levels of calls of functions in which are given parameters. If the test is positive e.g. no exception thrown or no bad assertion risen the result of a first test is used to create the next test these tests are not relevant because the scenario does not respect the business logic of the application. If a test is done on accordance with the semantic of the application an execution error for instance could be a good behavior for a test.

Ideally to be more efficient test generation should follow a scenario adapted to the business logic of the application operating that software. The difficulty to generate relevant tests is that the nature of the test is closely related to the semantic of the application under test. Unfortunately it is quite impossible to create test generators which can adapt to the semantic of the application. The test tools cannot discover this semantic and the generated tests are far from the test that would be performed by the programmer who has the knowledge of the semantic of the application under test. For example in an application managing bank accounts a class Account is written with methods deposit . . . withDraw . . . getBalance and getMaxDeficitAllowed it would be particularly relevant to check that one cannot withdraw an amount X if X is greater than getBalance unless this amount is less than getMaxDeficitAllowed getBalance .

However to improve test efficiency there is a need for a method to create test generators which can be used to test an application independently from its particular semantic but with a test scenario which is close to the logic of the programming of the application.

It is therefore an objective of the present invention to provide a method which creates a test generator testing a software written in an object oriented language according to the logic of the programming of the application.

These objectives are achieved as claimed in claims to with a method and a computer program for automatically generating a test source code for checking validity of an application written in an object oriented language comprising objects accessible through an interface implementing programming rules and object behavior rules said method comprising for each object of the application extracting the object methods and attributes of the object interface which are impacted by the object behavior rules and extracting the object identification filling the variable fields of a template of source code with the extracted information said template non variable source code being in conformance with the programming rules and implementing a scenario for checking a set of object behavior rules said filled template being the generated test source code. When the application to be tested is a distributed application the specifications may be EJB or CORBA and the Test Generator can use templates for checking the life cycle creation persistency removal of the deployed objects.

The solution of the preferred embodiment relies on the programming standardization of behavior of objects such as the life cycle rules of objects for application in a distributed environment. Checking of the object behavior rules can be used as a basis for test scenario.

For instance Java 2 Platform Enterprise Edition J2EE refers to standards for developing and deploying enterprise applications Enterprise Java Beans EJB or Common Object Request Broker Architecture CORBA defining component models in which the business logic is encapsulated into business objects. In the EJB specifications Chapter 12. Entity Bean Component Contract for Bean managed Persistence contains programming rules describing the persistence of objects. The tests generated by the method of the preferred embodiment check that the behavior of the deployed objects of the enterprise application is in conformance with the recommendation of Chapter 12 Entity Bean Component Contract For Bean Managed Persistence of the EJB specifications 2.1. The scenario of the tests generated comprises checking a minimum of steps in the life cycle implementation of deployed objects of the application to be tested. This has the advantage of testing the essential part of the logic of the application.

Furthermore these tests can be created with the use of a template because the tests use the exported API of the software to be tested and the naming rules are described in the specifications that the software has implemented. Consequently the tests can be automatically generated and are particularly reliable programming errors free . However the generator can be written in any language even not in object oriented language.

One other advantage is that the tests automatically generated which are compliant with the specifications by the test generator of the invention will check that the deployed object lifecycle implementation is also compliant with the specification.

In the programming community the use of the invention has a beneficial impact for the education of the programmers as the generated tests follow the programming specifications and will highlight common best practices in object deployment testing to programmers not familiar with object deployment implementation specifications.

One very significant advantage is the fact that the test generator of the preferred embodiment creates tests for checking a minimum of steps in the lifecycle implementation of each deployed object which could be combined by the programmers knowing the semantic of the application to create more complete test scenarios corresponding to more concrete use cases. The tester can assemble the tests created by the generator to create new tests more detailed and closer to the business logic of the application.

Not represented on the Software Development Environment which may operate on a computer independent from the execution computer comprises a development framework which is a set of tools as editors compilers linkers available in its workspace to build the application. Also part of the Software Development Environment syntactic and semantic programming rules are described in specifications such as EJB or CORBA well known for developing business applications written in an object oriented language.

The developer creates an Application Executable to be tested. To create the Application Executable the developer defines in the Software Development Environment the object model with classes describing objects and methods idl files for CORBA java files and descriptor files for EJB and all the application artifacts following development specifications. The classes are then compiled and linked to form the Application Executable .

In the preferred embodiment the application to be tested is a distributed application deployed in two parts which are the client side component and the server side component. The deployed application comprises two executables one on the server side and one for the client side. The distributed applications are implemented on servers and are accessed by client applications which reach the objects of the server application through their API. Usually the server application is executed on one server or more and each user accesses the server application through a client application executed on his workstation. The Software Development Environment comprises a development framework including generators and runtimes which allows developers to generate several pieces of code which provide the communication between the server part and the client part where the deployed objects are used. The framework is used by the developer to manage the deployed application and to produce a client proxy. The client proxy is a component allowing a client application to call the server application through a simple Application Programming Interface API . All low level communications are hidden to the developer who then concentrates his efforts on the business aspects of the application.

The tester uses the same Software Development Environment for creating a Test Generator as described later in reference to . The Test Generator is developed in any type of language.

To perform the tests testing the code of the Application Executable the tester first invokes the Test Generator which produces the Generated Tests then still using the development framework of the Software Development Environment the tester creates the Test Executable as a client application for the Generated tests . The development framework helps the tester to create source code files deployment files and build files necessary to create a Client Application. As with many client applications the Test Executable is able to interface with the Application Executable call for Test Executable to Application Executable is represented in with a dotted line and can be run in parallel of the Application Executable through the same server or not. The Application Executable must be run through one or many Application Server call for Application Executable to Application Server is represented with a dotted line on one or many machines located in a network. The tester executes the client application for testing the server application in the Execution Environment . The Test Results are sent to the Software Development Environment and used by the tester to perfect the Application Executable code. The test environment with the client application based on the Generated Tests and the server application based on the Application executable is described later in reference to .

First the tester must select the deployed objects of the application for which he wants to generate a test. For each selected object the test generator reads all the artifacts describing this object as the java or C source code files and possibly descriptors as CORBA IDL files or EJB deployment files the Deployable Object Classes and Descriptors 

The tester creates the Test Generator in any programming language. The first step of the Test Generator is to create an internal representation table tree etc. of the selected objects with a pertinent and minimum set of information extracted from the Deployable Object Classes and Descriptors . The internal representation of an object comprises 

After step an optional step of checking not illustrated in could be provided by the Test Generator to be sure that all these information are valid then the test generation is performed.

The Test Generator reads in each object representation the information relevant to be inserted in a test source code template written in the object oriented language of the test to be generated. One test source code template is prepared for each test.

Each template follows a scenario which is in accordance with the programming logic described in the programming specifications. Furthermore in the preferred embodiment a basic set of test templates is provided in the Test Generator corresponding to a set of tests covering the object life cycle as recommended in the specifications the creation of objects the persistence of objects and the deletion of objects.

The first test is the creation of a deployed object . Included is creation of an instance checking that this instance can be reached by its primary key and checking that a second instance of the same object is impossible.

The following test corresponds to each attribute persistence save load . It comprises doing a creation of an instance and for each attribute of the object to set a value for this attribute to commit the instance to reach the instance by its primary key and to check that the corresponding attribute has been set to the correct previous value.

The third test is for the deletion of the object . It includes doing a creation of an instance immediately after doing the destruction of this instance and then check that this instance can t be reached by its primary key and check that this instance can t be removed twice.

An example template for each of these tests is provided later in reference to the description of . The Test Generator uses the template by inserting in each of the test templates prepared by the tester the information read in the object structure in order to obtain the corresponding test source code. Once all the test source codes are generated for each deployed objects selected by the tester answer Yes to test the test generation is completed. The tester compiles and links the test source codes creates the deployment environment of the test as a client application and executes the tests in the Execution Environment which generates reports.

It is noted that once the code of the application is tested as for the life cycle of its deployed objects the tester can efficiently create new tests more in relation with the business logic of the application on a clean code basis. It is also noted that the Generated Tests source code based on the standardized life cycle of the objects can be reused combined and repeated for testing other object behavior such as the robustness of the objects is not part of the standardized life cycle of the objects by repeating the creation tests of .

The client side application comprises the Generated Test source code of with an API for access to its objects the Client Proxy being used to interface the Server Side .

The Server Side comprises the Server Side Container which is generally a part of the Application Server of . According to an API this part of the Application Server calls the objects of the Application Software for which the executable is the Application Executable of to be tested. The standardized Application Programming Interfaces API s are also described in the published specifications such as EJB or CORBA as well as the naming rules.

By analyzing these java classes at it is possible to extract pertinent data forming the object representation 

The JNDI name external name of the object that the EJB is bound to is also extracted from the descriptor file . One can take as example the test automatically generated on a EJB BMP named Account whose home interface is bound to the JNDI name ejb ejbs AccountHome .

Hereafter is provided a sample of source code templates created according to the preferred embodiment and used by the Test Generator for creating test source codes . The sample of templates correspond to three tests for which the scenario is in line with the deployed object life cycle EJB 2.1 Chapter 12 specifications. The three tests form in the preferred embodiment a set of tests which are also in conformance with the programming rules of the same specifications.

The following figures and provide samples of source code of tests generated according to the preferred embodiment for checking the behavior of deployed objects of a distributed application. In and the template fixed words used by the Test Generator embedded in the source code are underlined. The variable fields filled by the Test Generator in the template are written in Italic in and . Some comments which can also be generated automatically by the Test Generator are indicated in generic font in and .

The code of the Test Generator is written in any type of language but the language for the test source codes is an object oriented language preferably the object oriented language used for the development of the application to be tested. This is the case if the tester as suggested in the preferred embodiment uses the same Software Development Environment than the developer of the application to be tested. The source code examples provided in the following figures are written for testing an EJB object written in Java language. The test framework used may be the well known Junit test framework but any other environment may be considered. More generally the generated code and the Test Generator depends on the chosen test framework. Last point the examples provided hereafter are tests created for checking the behavior of the same sample object Account provided in . To summarize the convention in the source code illustrated in the following figures 

In the source code the Test Generator automatically generates a method named getAccountHome used to produce a Home intermediate object. This intermediate object created with the JNDI name is used to create remote or local instances of tested EJB object. In the example remote instances are created the method would have been slightly different for local instances.

Then the test generator generates a method named testCreateAccount to test the creation of the EJB. The goal is mainly to test the callbacks methods called by the EJB container and implemented by the programmer ejbCreate . . . ejbFindByPrimaryKey . . . .

It is noted that the inputs of the methods called by the generated tests such as id owned and balance of the method create are generated automatically with a default or a random value which can be changed with the help of a user interface by the tester.

In order to test that the fields of the EJB are well stored in the underlying database of the testing environment and well loaded from the database into the memory by the callbacks ejbCreate ejbLoad and ejbStore that the developer has to write and that are indirectly called by the EJB container the test generator generates a method named testLoadStoreAccount .

The principle is to modify a field of the EJB and to perform a commit in order to make the underlying persistent support in general a database updated. Then one reads the value of the field expecting that it will be the same than the value set previously. To ensure that ejbStore . . . and ejbLoad . . . are called one might configure the application server so that it doesn t use some cache mechanisms. If it is not possible one can stop and restart the application server time is not really a constraint at the test running step .

The scenario of the test of the object persistence according to the preferred embodiment comprises the following tasks 

In order to test the removal of an object the Test Generator generates a method named testRemoveAccount .

The scenario for testing the removal of an object according to the preferred embodiment comprises the following tasks 

The three test scenario samples described above are particularly powerful for the test of Entity Bean which are Bean Managed Persistence BMP and for CORBA application.

For this type of object it is recommended to create a Test Generator according to the preferred embodiment for generation of tests checking adequacy of the life cycle of the BMP objects of the subject application creation deletion persistence of the objects in a data base with the recommendations of the EJB specifications.

CORBA is a specification used by a lot of market tools to provide facilities to build distributed application. Generally communication libraries are delivered with a code generator. From an abstract interface definition file written in the IDL standardized language Interface Definition Language the generator produces 

The first point is that according to the sub chapter 4.4 of the EJB specifications the invocation of EJB must be possible through CORBA i.e. the generated C or Java interface. Consequently other embodiments of the present invention adapt the test generator and the templates to be able to generate from the IDL definition a test using these naming rules to invoke the CORBA client interfaces.

The second point is that even when the server side is not implemented according EJB specification it s always possible to test the life cycle of server side object implementation using the same techniques. In this case the test is essential because as for Bean Managed EJB the implementation is provided by the user.

In the case where the Entity Bean are Container Managed Persistence CMP the life cycle is managed by the runtime of the chosen technology. This test could be useful to prove that the technology is safe and correctly used in the actual application environment.

More generally as a skilled person can understand a same kind of creation or remove tests may be generated for Session Bean and if the subject objects contain attributes with getters and setters usual naming conventions with some adaptation in the test template similar persistence tests can be created as well.

Once the tests have passed the tester can focus on testing the business logic of the application being confident that potential bugs that could arise are not due to the use of the distributed object technology.

Turning to the invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The computer readable medium may comprise both computer readable storage medium and communication medium. Communication medium can be an optical electromagnetic infrared or a propagation medium. Computer readable storage medium can be electronic magnetic or semiconductor system or apparatus or device . Examples of a computer readable storage medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code and supporting data will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers and interfaces .

Network adapters and interfaces may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters .

While this invention has been particularly shown and described with references to preferred embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the invention encompassed by the appended claims.

