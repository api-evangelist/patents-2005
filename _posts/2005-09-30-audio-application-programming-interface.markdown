---

title: Audio application programming interface
abstract: An audio application programming interface (API) enables an audio processing graph to be modified during processing. If they are received while the audio graph is playing or paused, graph modifying commands may be inserted into either an asynchronous command queue or a deferred command queue. The audio API may also include a clock manager for synchronizing clocks from a number of different connected audio rendering devices, applications, processors, functions, operations, modules, or other resources. The clock manager may provide an interface that enables a number of control groups to be defined. Each such control group may include a master clock, a slave clock, and a control.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07746803&OS=07746803&RS=07746803
owner: Microsoft Corporation
number: 07746803
owner_city: Redmond
owner_country: US
publication_date: 20050930
---
Audio application programming interfaces API s may enable a wide variety of applications to set up complex audio processing graphs and to render audio output to a variety of different output devices. During processing of such a graph it may be desirable to make a number of changes that modify the structure and or state of the graph. For example it may be desirable to add a new filter path to the graph. This may involve for example creating and adding a new voice and also a number of filters to mix points in the existing graph. Additionally it may be desirable to modify a path of an existing filter. This may involve for example changing a source buffer of a voice swapping filters inserting new filters or removing filters. A drawback of conventional audio API s is that they are limited with respect to their ability to allow changes to such graphs while the graphs are being processed without negatively affecting overall performance.

Audio API s may also have the ability to separate audio processing from rendering. This and other features of audio API s may create a number of clock synchronization issues that arise when an audio API is connected to audio rendering devices applications and processors that are using different clocks. For example one problematic scenario may arise when a connected rendering device is consuming audio samples at a different rate than an audio API and or a digital signal processor is producing the samples. Another problematic scenario may arise when the audio API is connected to a number of different rendering devices that are each consuming audio samples at a slightly different rate. Thus another drawback of conventional audio API s is that they are limited with respect to their ability to coordinate clock synchronization among different connected audio rendering devices applications and processors.

An audio application programming interface API enables an audio processing graph to be modified during processing. If they are received while the audio graph is playing or paused graph modifying commands may be inserted into either an asynchronous command queue or a deferred command queue. All pending commands in the asynchronous queue may be executed on a next processing pass. However all pending commands in the deferred queue will not necessarily be executed on the next processing pass. Rather commands in the deferred queue will be processed in accordance with a commit marker that is inserted into the deferred queue. On the next processing pass all commands that are ahead of the commit marker in the deferred queue may be processed atomically while all commands that are behind the commit marker may remain unprocessed in the deferred queue.

The audio API may include a clock manager for synchronizing clocks from a number of different connected audio rendering devices applications processors functions operations modules or other resources. The clock manager may provide an interface that enables a number of control groups to be defined. Each such control group may include a master clock a slave clock and a control. For each control group the clock manager may monitor the rate of the master clock in comparison to the rate of the corresponding slave clock. If the master clock rate is not sufficiently synchronized with the corresponding slave clock rate then the clock manager may use the control to adjust the slave clock rate to conform with the master clock rate.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

As set forth above during processing of an audio graph it may be desirable to make a number of changes that modify the structure and or state of the graph. Changes that modify the structure of the graph may be referred to as graph modifying commands while changes that modify the state of a graph may be referred to as parameter modifying commands A graph modifying command may be for example a command to create or delete a voice a command to create or delete a return or a command to create or delete a filter. A parameter modifying command may be for example a command to start a return a command to stop a return a command to start a voice a command to stop a voice a command to set a loop region a command to set a source for a voice a command to set a destination for a voice or a command to set a parameter on a filter.

Graph safe commands are commands that have no impact on a running graph. Graph safe commands may include for example a command to create a buffer or a command to get a graph state. Because graph safe commands have no impact on a running graph they may be safely executed immediately. By contrast because graph modifying commands and parameter modifying commands will modify the structure and or state of the graph they may in certain circumstances be unsafe to execute immediately because they may result in unwanted side effects. In particular when an application requests information about the structure or state of the graph it is important to provide an accurate snapshot of the graph to the application. However because they will modify the structure and or state of the graph graph modifying commands and parameter modifying commands may prevent an accurate snapshot of the graph from being returned to the application.

To assist in identifying when it safe and unsafe to immediately execute graph modifying commands and parameter modifying commands graph processing may be divided into two modes synchronous mode and asynchronous mode. While the graph is stopped there are no potential side effects from processing graph modifying commands and parameter modifying commands immediately. Thus the graph is considered to be in synchronous mode when it is stopped. Alternatively while the graph is playing or paused there are a number of potential side effects which may result from processing graph modifying commands and parameter modifying commands immediately. Thus the graph is considered to be in asynchronous mode when it is playing or paused.

An exemplary table that shows when the different commands types are executed during the different processing modes is shown below.

Commands that are not executed immediately may be divided into two categories asynchronous commands and deferred commands. Asynchronous commands are placed in an asynchronous queue while deferred commands are placed into a deferred queue. The commands are placed in each queue in the order that they are received. All pending commands that are placed in the asynchronous queue will be executed during the next processing pass. By contrast the pending commands in the deferred queue will not necessarily be executed during the next processing pass. Rather deferred commands will remain in the deferred queue until a commit marker is inserted into the deferred queue. After a commit marker has been inserted into the deferred queue all commands that are ahead of the commit marker in the deferred queue will be atomically executed during the next processing pass. Commands that are behind the commit marker in the deferred queue will not be executed during the next processing pass. Rather they will remain in the deferred queue until another commit marker is inserted and a subsequent processing pass occurs. The commands ahead of the commit marker in the deferred queue are executed atomically meaning that the commands are executed as a group without any intermittent operations being performed.

In addition to the commit marker a rollback marker may also be placed in the deferred queue. On the next processing pass the client application will have the opportunity to cancel or execute any of the commands in the deferred command queue that are ahead of the rollback marker

An exemplary asynchronous command queue is shown in . Commands are received from application thread and are placed in the asynchronous queue until they are processed by audio API processing thread . Commands are placed in the asynchronous queue in the order that they are received. On the next audio API processing pass commands will all be executed.

An exemplary deferred command queue is shown in . Commands and commit marker C are placed in the deferred command queue in the order that they are received. Commands are received before commit marker C and therefore they are placed in the deferred queue ahead of commit marker C. Commands are received after commit marker C and therefore they are placed in the deferred queue behind commit marker C. Because they are ahead of the commit marker commands will be atomically executed on the next audio API processing pass. Commands may then be cleared from the deferred queue . Because they are behind the commit marker commands will not be executed on the next processing pass. Rather they will remain in the deferred queue until another commit marker is inserted and a subsequent processing pass occurs.

In addition to the occurrence of a processing pass switching processing from asynchronous mode to synchronous mode from play to stop or from pause to stop may cause all pending asynchronous and deferred commands to be executed. Thus switching from asynchronous mode to synchronous mode may be considered an implicit processing pass with an implicit commit marker.

In addition to command processing another challenge related to audio API s involves clock management. In particular as set forth above audio API s may operate in connection with a number of different audio rendering devices applications processors functions operations modules or other resources each using a different clock. This may create a number of concerns when the clocks for these devices are not synchronized. An exemplary clock management system is shown in . Clock management system includes a number of control groups . Although three control groups are shown in a clock management system may include any number of control groups. Each such control group includes a respective master clock a corresponding respective slave clock and a respective control . Each master clock and slave clock may correspond to an audio rendering device application processor function operation module or other resource that is used in connection with the audio API or to the audio API itself. For example each master clock may correspond to a different audio rendering device while each slave clock may correspond to the audio API or to a connected digital signal processor DSP .

Clock management system also includes a clock manager . Clock manager includes an interface that enables control groups to be defined by registering a master clock a corresponding slave clock and if necessary a control for each control group . Clock manager is also responsible for monitoring control groups to ensure that each master clock is sufficiently synchronized with its corresponding slave clock . To accomplish this clock manager may compare the rate at which a master clock consumes samples against the rate at which a corresponding slave clock produces samples. If the difference between the master and slave rates is more than an acceptable threshold difference then clock manager may use the control group s respective control to adjust the rate at which the slave is producing samples.

A number of methods may be employed to determine whether the slave is sufficiently synchronized with the master. For example on an initial processing pass clock manager may obtain starting positions for a master clock and its corresponding slave clock. On each subsequent processing pass clock manager may obtain current positions for the master clock and its corresponding slave. The master absolute progress may then be calculated by subtracting the master starting position from the master current position and the slave absolute progress may be calculated by subtracting the slave starting position from the slave current position. The slave absolute clock rate may then be calculated by dividing the slave absolute progress by the master absolute progress. The error in the slave clock s rate may then be calculated by subtracting the slave absolute clock rate from the number 1. This error may then be filtered and compared with other measurements such as for example the slave s rate of change since the most recent processing pass.

With reference to computing system environment includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media include both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD RW DVD RW or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A graphics interface may also be connected to the system bus . One or more graphics processing units GPUs may communicate with graphics interface . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Although the subject matter has been described in language specific to the structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features or acts described above are disclosed as example forms of implementing the claims.

