---

title: Compiler supporting programs as data objects
abstract: A compiler supporting a language in which selected semantic objects are represented as data objects. The data objects may be used in multiple ways to expand the capabilities of the programming language. Data objects may be passed to applications and used to create executable instructions for that application. In this way, instructions written in the native language of the compiler may be used to control applications that accept programs in a language inconsistent with the native language of the compiler. The syntax checking and variable binding capabilities of the compiler may be used for those instructions that will be executed by an application separate from the object code generated by the compiler. The semantic objects represented as data objects may be selected based on express operations included in the source code or may be based on implicit type conversion.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07992140&OS=07992140&RS=07992140
owner: Microsoft Corporation
number: 07992140
owner_city: Redmond
owner_country: US
publication_date: 20050729
---
In some instances it is desirable to treat computer program instructions as data objects. This need arises for example when a computer programmer is writing a computer program that accesses data from another application. For example a programmer writing a program in the C programming language may wish to access a database that responds to queries written in the SQL programming language. To query the database from the C program the C programmer may insert SQL commands as strings in the C program. A C compiler does not convert the strings into executable code. Rather the C compiler stores the strings literally as they were entered by the programmer.

As the C program executes the strings will be passed to an application programming interface API for the database. The API may compile or interpret the string and provide the appropriate commands to the database to perform the desired access to the database.

Compilers for languages such as Lisp Scheme MetaML and Template Haskel will also create data objects representing code in a source code file if the code is explicitly quoted in the source code file.

The invention relates to a compiler that represents internal semantic objects within a source code file as data objects. In many instances the semantic objects will be expressions constituting program instructions in source code form. In one aspect the invention relates to processing the internal semantic objects according to a syntax used by the compiler to create the data object as an external semantic data structure. The data objects may be used in one of multiple ways. The data object may represent an expression or function that is to be performed by an application and may be supplied to that application to cause that application to execute the function or expression. In another aspect the invention relates to automatic selection of internal semantic objects for representation as data objects. A compiler may selectively create an external semantic data structure from an internal semantic object to be passed as a parameter to a method constructed to receive a data object representing source code may be based on the type of argument the method receives thus performing an implicit type conversion.

We have recognized that a computer language can be made more flexible by providing a compiler that selectively creates data objects from semantic objects in source code it compiles. The data objects may be created using a compile time implicit type conversion from a semantic object internal to the source code being compiled to a data object containing a syntactic data representation of the semantic object. Data objects may be created for internal semantic objects in any desired form such as a label an expression a delegate a method a class a statement block or any other unit or grouping of source code instructions. In the description that follows computer program instructions particularly expressions are used as an example of an internal semantic object.

The implicit type conversion may be regarded as a generalization of the type of T construct that allows programmers to obtain a run time System.Type instance from a given compile time type T. However a data object may be created from an internal semantic object in any suitable way.

Such a compiler can simplify development of applications that access other applications. Where the semantic objects are computer program instructions intended to be executed by an application that responds to instructions in a programming language other than the native language of the compiler code accessing that application may be written in the same source code language as the rest of the program. Further implicit type conversion avoids the need for a programmer to explicitly quoting code expressions.

With such a compiler a computer programmer can write instructions controlling access to an application in the native language of the compiler. Because the instructions are written in its native language the compiler may process those instructions rather than simply storing them as a string which can provide benefits such as allowing the compiler to detect syntax errors at compile time. Furthermore the compiler can perform name binding and variable capture that might otherwise have been performed manually by the programmer. As a result data objects representing computer program instructions available external to the compiler may reflect the semantics of their host language and may for example include variable names that have been resolved types that have been checked or conversions that have been inserted according to the semantics of the host language. Significantly this processing can occur at compile time and therefore reduce errors that could occur at runtime when code that is simply processed as a string is executed.

As an example of a system in which such a compiler may be used shows an application environment in simplified block diagram form. Application environment may be created on a desktop computer running the WINDOWS operating system. However the specific application environment is not a limitation on the invention. Any suitable operating system may be used.

Further any suitable hardware may be used to create application environment . One or more computers of any suitable type may be used to host application environment and the computers may be configured in a stand alone or networked configuration.

Under the WINDOWSindows operating system multiple applications may execute in an application environment. In the illustrated embodiment application environment executes applications that include compiler and database application . As is conventional each of the applications may consist of a group of computer executable instructions stored on a computer readable medium. The application environment may execute these instructions to perform functions of the application.

Compiler operates on source code . Source code may contain multiple semantic objects that define a program being developed by one or more programmers using the application environment . Source code may be created in any convenient way and may be stored on computer readable media associated with application environment . For example a human programmer may create source code by typing text at a keyboard not shown and storing it in a file associated with application environment .

The semantic objects within source code may define a desired application under development by a human user. In the illustrated embodiment source code defines an application that manages storing retrieving and otherwise accessing data maintained by database application . However the specific application implemented by the source code is not a limitation of the invention and source code may represent a program prepared for any desired application.

Compiler operates on the semantic objects contained within source code . As in a traditional compiler compiler may convert the semantic objects in source code into computer executable instructions stored as object code . Like source code object code may be stored in computer readable media associated with application environment . However object code may be stored in any suitable manner in any suitable location.

Object code forms a computer application that in this example is executed within the application environment . However the location at which object code is executed is not a limitation of the invention. Object code may be executed on the same computer on which compiler executes. Alternatively object code may be executed on a computer networked to the computer on which compiler executes. As a further example of a possible variation object code may be recorded on movable media and distributed to multiple computers that are not connected to the computer in which compiler operates.

In addition to creating object code compiler also creates one or more data objects that represent semantic objects contained within source code file . In the illustrated embodiment the semantic objects that are represented as data objects are expressions written in the source code language on which compiler operates herein referred to as the native language of the compiler. Examples of expressions that may appear in source code file include binary expressions unary expressions ternary expressions constant expressions field access expressions property access expressions method call expressions object initializer expressions object creation expressions collection and array initializer expressions array creation expressions cast expressions parameter reference expressions lambda expressions invocation of semantic trees expressions free variable capture expressions or outer variable capture expressions.

Though the data objects may be used external to compiler compiler may apply the syntax rules of its native language in creating those data objects from the internal semantic objects. For example the compiler may perform one or more operations that include type checking name binding variable capture overload resolution error checking or other processing steps traditionally performed by a compiler in creating a representation of a semantic object used internally as a program being compiled. The data object may be stored in a data structure with fields containing data representing the results of one or more of these compiler operations applied to the internal semantic object. Such a structure may be termed a semantic data structure.

In application environment some of the data objects created by compiler to represent internal semantic objects are used external to compiler . In the example of the data objects are provided to API for use in controlling database to perform an operation specified by the internal semantic objects.

Thus in contrast to the prior art in which source code instructions intended to control a separate application were quoted and passed to the application as a string or other literal form an external semantic data structure representing the source code instructions is provided. In the illustrated embodiment the internal semantic objects are expressions and the external semantic data structures are expression trees . Expression trees may be stored as data structures in computer readable media associated with application environment . In the illustrated embodiment the expression trees are stored on computer readable media accessible to the computer on which object code executes.

Each expression tree may be stored in a generic form. Storing the expression trees in generic form allows the expression trees to be used in multiple contexts because they may be readily customized for any specific context in which they are used.

Compilers often form internal generic representations of expressions or other semantic objects as part of the process of forming object code. In the illustrated embodiment expression trees may be in the form used internally by compilers as known in the art to represent expressions as they are being processed. In the described embodiment however unlike in an existing compiler data structures that represent selected semantic objects are stored in a manner that they may be accessed for processing within the compiler or accessed for processing outside of the compiler.

In the illustrated embodiment expression trees may be used to control database application to perform operations specified by instructions in source code . The expression trees representing instructions from source code are provided to API . In this example API is an application program interface to database application .

API converts the generic representation of the expressions contained within the expression trees into instructions in a format that may be executed such as by database application . As described above known compilers contain a portion that creates representations of expressions as an intermediate step in forming executable code. Known compilers contain a second portion that translates the generic representation of expressions into executable code in the form that can be executed by database application . API therefore mimics the function of the portion of a known compiler that compiles code into a format that may be executed by database application . As a specific example where database application responds to SQL queries API may be implemented using technology whether now known or hereafter developed that is used in an SQL compiler to convert a generic representation of expressions into code executable by the database application.

In one embodiment only a selected sub set of the semantic objects within source code are represented as external data structures. Compiler may be constructed to recognize constructs in source code that indicate certain semantic objects should be represented as external data objects. Those semantic objects could be represented as external data structures instead of or in addition to using those semantic objects to generate object code .

In the embodiment pictured in the semantic objects selected to be represented as external data structures are those semantic objects that are instructions for an application to execute. Compiler supports constructs to identify semantic objects to be represented in external semantic data structures. illustrate the syntax of instructions in source code file that may control compiler to generate the desired data structures. depicts a portion of source code that contains a sequence of instructions in source code form. The instructions and illustrate different ways in which instructions may be treated by compiler .

Instruction is a declaration of a delegate R. The delegate R may be used to refer to a function. The delegate R may for example be implemented as a pointer to a function. In the describe embodiment compiler may allocate storage space for the delegate R but does not generate object code for the delegate R.

Instruction is the declaration of a function f. In this example the function f receives an argument x that is of integer type and returns a value of Boolean type. The value returned depends on whether the value of the argument x is greater than 10. Compiler creates object code that performs the operations necessary to process the argument and compute the value returned. This code is executed whenever the function f is called elsewhere in the computer program.

In contrast instruction represents the declaration of an expression. Instruction begins with the keyword Expression which signifies to compiler to create an external data structure representing the argument of the expression. In this example the argument of the expression specifies a function e that performs the same operation as the function f. However compiler creates an external data structure when it processes instruction rather than object code as is created when the compiler processes instruction .

Instruction begins with the keyword Expression signifying that instruction defines an expression from which a data object should be created. In this example the expression to be represented by the data object produces a Boolean value indicating whether an argument to the expression x is greater than the product of the values of variables y and z.

A complexity arises in preparing an external data structure representing the expression contained within instruction . The expression operates on variables that are defined outside the expression and are not provided as run time arguments such variables may be called free variables or outer variables. The values of those variables may change during execution of a program. Accordingly in the described embodiment the data object representing the expression in instruction is not loaded with the values of the variables at the time the data object is create. Rather the data object is created to include a reference to information allowing the current values of the variables y and z to be obtained. A similar issues arises when an expression refers to another expression. Appropriate reference to the second expression must be included in the data structure representing the first expression. One way to implement a reference from one expression to another is to incorporate into an external semantic data structure a mechanism to reference another external semantic data structure.

Any suitable representation of the information necessary to access the values of variables y and z may be incorporated into the data object. For example a process called funcletting may be used. Funcletting involves capturing free variables or sub expressions inside code as data objects. The underlying representation of the information to represent the free variable or sub expression may be in any suitable form. As a specific example the data object may contain an address of the memory locations where those values are stored. The memory address may be an absolute memory address or may be an offset into a stack frame or other data structure. As another example of how the value of a free variable or outer variable may be indicated a pointer to a function that returns the value of the variable may be used.

The use of funcletting is not limited to providing a way to access an integer variable as shown in . Reference may be made to variables of other types.

By providing information that indicates where values of the variables used within the expression may be obtained at the time the expression is executed the data structure representing the expression may be readily converted to executable instructions that when executed perform the desired operation. The desired operations may be performed regardless of whether the conversion to executable instructions is performed at compile time or at runtime or at some intermediate time. Further the desired operations may be performed regardless of when the object code generated from the data object is executed.

Turning to a representation of a data object for storing a semantic object in source code is shown. Data object may be implemented in any suitable computer readable media and may have any form suitable to represent the semantic object. In this example the semantic object is an expression defined in source code and the data object is organized as an expression tree. The expression tree includes multiple fields each of which contain information useful in evaluating the expression. Expression trees are known in the art and compiler may create an expression tree from an expression in source code in any suitable way.

In this example the expression tree is represented with multiple fields including data fields and and operation field . Data fields and may store data and operation field may store an indication of an operation to be performed on the data in fields and .

Data object includes a further data field and a further operation field . Operation field may store an indication of an operation to be performed on the data in field and the results of the operation indicated by operation field . In addition data object includes a result field at . Result field may specify a location at which the result of evaluating the expression represented by data object is to be stored.

Data object representing an expression tree as pictured in is one example of a data object. Any suitable form of data object may be used. For example additional fields may be included but are not shown for simplicity. For example any number of data fields and operation fields may be used. In addition the data objects may include fields to indicate the number of data fields or the number of operation fields or fields to otherwise aid in representing an expression.

Turning to a second data object is illustrated. Data object like data object includes fields such as and that specify data and fields such as and that specify operations to be performed on that data. Likewise data object includes a result field that specifies where a result may be stored. Data object differs from data object in that it includes a reference field . In this example reference field includes an indication of where the data used to perform the operation indicated by operation field may be obtained. Reference field may contain a direct or indirect memory address or other indicator that allows the data to be obtained. For example reference field may contain the address of a function that will retrieve the appropriate data.

Once an expression is parsed from source code processing of that expression continues at block . At block the compiler checks the syntax of the expression. Syntax checking is also a known function of compilers and the processing in block may be performed as in a conventional compiler whether now known or hereafter developed. Syntax checking involves comparing the expression identified at block to a set of rules that define expressions that are allowed in the language that the compiler processes. For example if compiler processes source code written in a variant of the C programming language the syntax rules applied at block may be traditional rules for the C programming language augmented by rules that define the creation or use of data objects based on expressions in source code. For example conventional syntax rules may be augmented with rules defining the syntax that allow use of the Expression identifier as used in instructions or . Other conventional syntax rules may be used in modified form to reflect the additional processing capability made possible by representing expressions as data objects.

In the described embodiment the syntax checking at block applies to all instructions within source code including those instructions that are intended to be converted to data objects that are ultimately passed to an application program for execution. In this way errors in source code developed for execution by an application program such as the database application can be detected at compile time. Detecting errors at compile time is often desirable because it avoids runtime errors.

If the syntax check performed at block identifies a syntax error the process may continue to an error handling routine indicated at process block . The error handling routine may perform any desired action such as notifying a human user of compiler of the syntax error logging the error automatically correcting the syntax error or removing the expression with a syntax error from the source code being processed.

Following the syntax check processing proceeds to block . At block an intermediate representation of the expression is generated. Generating an intermediate representation of a source code expression is a known function of compilers. The intermediate representation is often used to facilitate various processing steps on the program being compiled such as removing redundant expressions and determining memory requirements for variables and other program objects. Many intermediate representations are known to be used in compilers. Any suitable intermediate representation may be used. In this example the intermediate representation includes expression trees that describe expressions in the source code. In this example the external semantic data structures formed to represent expressions can be the same as the intermediate representation of those expressions that would be formed by compiler . However the external semantic data structures and the intermediate representation used internally by the compiler may be different.

The process continues to decision block . At decision block a check is made as to whether the expression identified at block represents an expression for which an external semantic data structure needs to be retained. As described above in connection with external semantic data structures rather than object code are provided for expressions that use the indicator Expression. More generally a data object may be retained for any semantic object where there is an explicit operation in the source code indicating that the data object should be generated or an implicit indication that the data object will be used externally.

If an external data object is to be provided for the expression processing proceeds to block . At block a data object containing the intermediate representation of the expression is stored. In the example of each of the data objects is a data structure storing an expression tree. However depending on the specific type of expression or other semantic object processed any suitable form of data object may be employed.

Processing then proceeds to decision block . At decision block a check is made whether there are more expressions in the source code. Where more expressions exist processing returns to block where the next expression is parsed. Processing then continues with the identified expression. Conversely where no further expressions remain in the source code the process of ends.

If decision block determines that code should be generated from the identified expression as it is being processed processing continues to decision block . At decision block a check is made whether the identified expression uses an expression that is represented as a data object such that no executable code exists to implement that expression.

When an expression references a prior expression for which only a data object is available as a representation of that prior expression processing proceeds to block . At block the data object representing the prior expression is processed to generate object code from that data object. Thereafter processing proceeds to block where object code is generated for the expression being processed. The object code generated may include object code generated directly from the expression being processed and object code generated from the data object representing the prior expression.

Conversely when the expression being processed does not reference another expression for which executable code has not been generated processing proceeds to block . At block object code is generated for the expression.

Generation of object code from an intermediate representation of an expression such as a data object is a known function of compilers. Object code may be generated at blocks and using techniques used in conventional compilers whether now known or hereafter developed.

Once object code is generated for one expression processing proceeds to decision block . At decision block the check is made whether more expressions exist in the source code . Where more expressions exist processing returns to block for further processing. Where no further expressions exist the process ends.

Code fragment includes instruction defining a method called Where. The method defined at instruction has an argument . Argument has a type associated with it. In the example of argument has a type Func associated with it. When the method Where defined in instruction is called it should receive a parameter that is of type Func. Such a parameter may for example be passed as a delegate.

The method defined in code fragment includes a body . As body executes references to argument within method body result in execution of object code prepared by compiler corresponding to the function whose delegate was passed as a parameter.

The method defined at instruction includes a method body . As body executes when the argument is referenced within method body the external semantic data structure passed as a parameter is accessed. Method body may for example use the data structure to generate commands to access database .

By providing implicit type conversion significant flexibility is provided to a programmer generating source code . Because compiler selects the appropriate expressions to represent as external semantic data objects to pass to API the programmer is relieved of the burden of needing to know the specific representation of the arguments for each method of API and explicitly quoting those that are to be passed as data objects.

Having thus described several aspects of at least one embodiment of this invention it is to be appreciated that various alterations modifications and improvements will readily occur to those skilled in the art.

For example it is described that data objects formed for expressions in which parameters have been identified as having a type that is specified outside of the expression include a generic representation of that parameter. Parameters of data objects could be represented generically in data objects even if type information for that parameter is available. Further other aspects of an semantic object other than the type of its parameters may be represented generically in a data object with specific information obtained from context used to generate executable code from the data object.

Also expressions were used as an example of semantic objects that may be represented as data objects. Any desired semantic object such as a method or a class may be represented as a data object.

Such alterations modifications and improvements are intended to be part of this disclosure and are intended to be within the spirit and scope of the invention. Accordingly the foregoing description and drawings are by way of example only. The above described embodiments of the present invention can be implemented in any of numerous ways. For example the embodiments may be implemented using hardware software or a combination thereof. When implemented in software the software code can be executed on any suitable processor or collection of processors whether provided in a single computer or distributed among multiple computers.

Also the various methods or processes outlined herein may be coded as software that is executable on one or more processors that employ any one of a variety of operating systems or platforms. Additionally such software may be written using any of a number of suitable programming languages and or conventional programming or scripting tools and also may be compiled as executable machine language code.

In this respect the invention may be embodied as a computer readable medium or multiple computer readable media e.g. a computer memory one or more floppy discs compact discs optical discs magnetic tapes etc. encoded with one or more programs that when executed on one or more computers or other processors perform methods that implement the various embodiments of the invention discussed above. The computer readable medium or media can be transportable such that the program or programs stored thereon can be loaded onto one or more different computers or other processors to implement various aspects of the present invention as discussed above.

The terms program or software are used herein in a generic sense to refer to any type of computer code or set of computer executable instructions that can be employed to program a computer or other processor to implement various aspects of the present invention as discussed above. Additionally it should be appreciated that according to one aspect of this embodiment one or more computer programs that when executed perform methods of the present invention need not reside on a single computer or processor but may be distributed in a modular fashion amongst a number of different computers or processors to implement various aspects of the present invention.

Computer executable instructions may be in many forms such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

In embodiments described above object code is described. This term is also intended to be used in a generic sense to refer to compiled code. The term may encompass executable files files containing DLL s or other representations of a compiler output.

Furthermore the term compiler is also intended in a generic sense and the time at which the object code is generated in not intended to be a limitation of the invention. For example the term compiler may encompass applications sometimes referred to as Just In Time JIT compilers or interpreters.

Furthermore the term file is also used in a generic sense to refer to logically related data. The term is not intended to be limited to any specific organization of data by an operating system or any physical positioning on a storage media.

Various aspects of the present invention may be used alone in combination or in a variety of arrangements not specifically discussed in the embodiments described in the foregoing and is therefore not limited in its application to the details and arrangement of components set forth in the foregoing description or illustrated in the drawings. For example aspects described in one embodiment may be combined in any manner with aspects described in other embodiment.

Use of ordinal terms such as first second third etc. in the claims to modify a claim element does not by itself connote any priority precedence or order of one claim element over another or the temporal order in which acts of a method are performed but are used merely as labels to distinguish one claim element having a certain name from another element having a same name but for use of the ordinal term to distinguish the claim elements.

Also the phraseology and terminology used herein is for the purpose of description and should not be regarded as limiting. The use of including comprising or having containing involving and variations thereof herein is meant to encompass the items listed thereafter and equivalents thereof as well as additional items.

