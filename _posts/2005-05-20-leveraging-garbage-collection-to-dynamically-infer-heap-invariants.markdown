---

title: Leveraging garbage collection to dynamically infer heap invariants
abstract: A program analysis tool leverages the garbage collection process to dynamically infer invariants of objects or data structures created by a program on the heap during execution. During execution of the program in a garbage-collected execution environment, the program analysis tool tracks object allocations made by the program, and records some meta data relating to invariants tracked for the type of the object, which are initially assumed satisfied by the object. Whenever a garbage collection pass visits the object, the tool checks whether the object still satisfies the invariants, and updates the meta data accordingly. The tool finally reports the invariants reflected by the meta data upon the object's death or at termination of the program. The invariants can then be used to annotate the program source code and/or detect bugs that violate the invariants.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07912877&OS=07912877&RS=07912877
owner: Microsoft Corporation
number: 07912877
owner_city: Redmond
owner_country: US
publication_date: 20050520
---
As defined by Microsoft Computer Dictionary Fourth Edition Microsoft Press 1999 the heap is a portion of memory in a computer that is reserved for a program to use for the temporary storage of data structures whose existence or size cannot be determined until the program is running. To build and use such elements programming languages such as C and Pascal include functions and procedures for requesting free memory from the heap accessing it and freeing it when it is no longer needed. In contrast to stack memory heap memory blocks are not freed in reverse of the order in which they were allocated so free blocks may be interspersed with blocks that are in use. As the program continues running the blocks may have to be moved around so that small free blocks can be merged together into larger ones to meet the program s needs.

Microsoft Computer Dictionary Fourth Edition Microsoft Press 1999 further defines garbage collection as a process for automatic recovery of heap memory. Blocks of memory that had been allocated but are no longer in use are freed and blocks of memory still in use may be moved to consolidate the free memory into larger blocks. Some programming languages require the programmer to handle garbage collection. Others such as Java perform this task for the programmer. 

Many currently available programming language run time environments provide a garbage collector to actively and automatically manage heap memory. Examples of such run time environments include run time environments for the Java programming language the C programming language and Microsoft Corporation s .Net Common Language Runtime environment. The garbage collector periodically traverses the objects in heap memory to identify objects that are no longer in use so that the memory occupied by such dead objects or garbage can then be reclaimed. Although the garbage collectors may vary in design they generally operate by tracing or traversing through the live objects by following pointers from a root object or objects of a program in the heap. Those objects still reachable by tracing pointers from the root object s are considered live whereas any of the program s objects that can no longer be reached are dead or garbage. The garbage collector then reclaims the memory occupied by such dead objects.

Modern software packages allocate and manage a vast amount of information on the heap. Object oriented languages such as Java and C almost exclusively use the heap to represent and manipulate complex data structures. The growing importance of the heap necessitates detection and elimination of heap based bugs. These bugs often manifest themselves in different forms such as dangling pointers memory leaks and inconsistent data structures.

Unfortunately heap based bugs are hard to detect. The effect of these bugs is often delayed and may be apparent only after significant damage has been done to the heap. In some cases the effect of the bug may not be apparent. For instance a dangling pointer bug does not crash the program unless the pointer in question is dereferenced and on occasion may not cause a crash even then. Consequently software testing is not very effective at identifying heap based bugs. Because of the non deterministic nature of heap based bugs even if the buggy statement is executed on a test run it is not always guaranteed to crash the program or produce unexpected results. Moreover the effect of heap based bugs is often delayed as a result of which testing does not reveal the root cause of the bug.

Static analysis techniques such as shape analysis see e.g. M. Sagiv T. W. Reps and R. Wilhelm Parametric Shape Analysis Via 3 Valued Logic . 24 3 217 298 May 2002 overcome these limitations. They examine all valid code paths and can also provide soundness guarantees about the results of the analysis. Shape analysis has enjoyed success at determining the correctness of or finding bugs in algorithms that manipulate heap data structures. However in spite of recent advances such as described by B. Hackett and R. Rugina Region Based Shape Analysis With Tracked Locations 32nd . January 2005 and E. Yahav and G. Ramalingam Verifying Safety Properties Using Separation And Heterogeneous Abstractions . pages 25 34 June 2004 shape analysis algorithms are expensive and apply only to limited classes of data structures and properties to be checked on them. Moreover the results of static analysis while sound are often overly conservative and over approximate the possible set of heap configurations.

On the other hand dynamic analysis techniques have the advantage of precisely capturing the set of heap configurations that arise. Several dynamic analysis tools have been developed to detect special classes of heap based bugs. See e.g. T. M. Chilimbi and M. Hauswirth Low Overhead Memory Leak Detection Using Adaptive Statistical Profiling 11th . pages 156 164 October 2004 B. Demsky and M. Rinard Automatic Detection And Repair Of Errors In Data Structures 18th . pages 78 95 October 2003 R. Hastings and B. Joyce Purify Fast Detection Of Memory Leaks And Access Errors pages 125 136 January 1992 and N. Nethercote and J. Seward Valgrind A Program Supervision Framework . 89 2 2003. However there has been relatively little research at understanding the runtime behavior of the heap and applying this information for bug finding.

The following description details various techniques and tools for discovering data structure invariants which are properties or characteristics of the data structure that generally do not vary during execution of the program such as Foo.x is a constant or Object bar only contains objects of type Baz etc. . These techniques and tools leverage the garbage collection process in that the techniques and tools infer the invariants dynamically at runtime by analyzing the data structures on the heap as the garbage collector traverses the data structures.

In one exemplary implementation of this approach the technique is implemented in a heap executive or garbage collector that performs the garbage collection process for a run time environment in which a program executes. The program is run in this execution environment. As the program executes the heap executive tracks object allocations made by the program and records some meta data describing an allocated object based on the type of the object. This meta data represents the invariants that are to be inferred for the object. Initially it is assumed that the object satisfies all the invariants that an object of its type could satisfy and the meta data is initialized accordingly.

Then whenever the garbage collection process is run the heap executive updates the meta data of the objects on the heap. As the garbage collection process reaches each object the heap executive checks which of the invariants are still satisfied by the object. For any invariants no longer satisfied by the object the heap executive updates the meta data accordingly.

When an object dies either when identified as garbage or at program termination the heap executive reports the end state of the object s meta data. This end state reflects which invariants were satisfied across the lifetime of the object although the heap executive alternatively can perform the invariant checking over some other interval .

The invariants discovered through this technique could be reintroduced to the source code as static annotations e.g. in a language like Spec to facilitate further code development. Also the invariants could be learned then enforced at runtime or through static analysis to find bugs those parts of the program code that violate the invariants. In one example application the invariants discovered by the technique are introduced back into the source code of the program as static annotations. After changes in the source code from further development of the program the heap executive checks that the objects created by the program on the heap at run time continue to satisfy the invariants specified in these annotations.

In another particular application this dynamic invariant inference by leveraging garbage collection technique can be applied to the identification of heap based bugs using anomaly detection that is described by Trishul Chilimbi and Vinod Ganapathy HEAP BASED BUG IDENTIFICATION USING ANOMALY DETECTION U.S. patent application Ser. No. 11 134 812 filed concurrently herewith the disclosure of which is hereby incorporated herein by reference . More particularly the heap executive implements a runtime tool that analyzes heap behavior during execution of a program to identify relatively stable properties the invariants . The tool then detects the occurrence of anomalies deviating from the observed properties which may lead to finding bugs.

Additional features and advantages of the invention will be made apparent from the following detailed description of embodiments that proceeds with reference to the accompanying drawings.

The following description is directed to techniques for dynamic invariant inference leveraging garbage collection. The techniques are described by reference to an exemplary software analysis tool implemented in a heap executive of a run time program execution environment that provides garbage collection.

With reference to an exemplary software analysis tool for dynamic invariant inference leveraging garbage collection is implemented in a heap executive of a modified version of a run time software execution environment such as is provided in the Microsoft Corporation .Net run time platform or a Java virtual machine environment. Among other functions the heap executive manages memory allocation in and provides garbage collection for a heap memory used by a program for temporary storage of objects and other data structures . In general the objects are structured according to object oriented programming principles to encapsulate a data structure with a set of methods or functions that operate on the data. For expository convenience the term program object is hereafter used to refer to both objects and other data structures or data elements.

The heap executive provides a set of system level services including a heap allocator that provides allocation of heap memory for data structures to the program and a garbage collector that manages the allocated heap memory to reclaim memory from dead objects. The program calls the heap allocator through an application programming interface API to have space allocated on the heap for data structures or objects that the program dynamically creates during its execution. The garbage collector periodically runs a garbage collection process which traverses the objects created by the program on the heap to identify and reclaim space from any of the program s objects that are no longer reachable i.e. dead . The heap allocator and garbage collector can employ conventionally known memory allocation and garbage collection processes.

The heap executive additionally includes an invariant inference service that implements the dynamic invariant inference leveraging garbage collection technique described herein. The invariant inference service hooks the heap allocator and garbage collector services so that the invariant inference service can create and update meta data about the objects created by the program on the heap as the program executes. The invariant inference service also creates an invariant report with information of the invariants it has inferred about the objects on the heap.

With reference now to the invariant inference service leverages upon the garbage collection work performed by the garbage collector to also infer various heap invariants about the program under test. The invariant inference service discovers invariants dynamically as the program is run by analyzing the data structures on the heap as the garbage collector traverses the objects in a garbage collection pass. As is conventionally known the garbage collector periodically performs garbage collection on the heap as the program runs. The garbage collector traverses the data structures allocated on the heap starting from the program s root objects and test whether the data structures are reachable also herein referred to as a liveness or vitality check . The data structures that are no longer reachable from the root objects are considered dead and the memory that they occupied is reclaimed to the free memory pool for use in subsequent memory allocation.

In general the basic operation of the invariant inference service invariant inference leveraging garbage collection process is to track object allocations of the program and store some meta data representing invariants of the objects based on their respective type. In the exemplary implementation the invariant inference service optimistically assumes that the object will satisfy the invariants that an object of its type could satisfy. When the garbage collection is periodically run the invariant inference service updates the meta data of the objects. When the garbage collection visits each object on the heap to test whether the object is reachable the invariant inference service also checks whether the object satisfies the various invariants that it is tracking for the object. The invariant inference service updates the meta data of an object accordingly for any invariants that the object is found to no longer satisfy. When the object dies e.g. from garbage collection or at program termination the invariant inference service reports the final state of the invariants that it has tracked. The invariant inference service can compile a report of the heap invariants over the life of the program possibly including a post processing or off line analysis of the invariant data.

The exemplary implementation of the invariant inference service performs this heap invariant inference technique by inserting various hooks at various points into the normal heap management operations performed by the heap executive i.e. memory allocation by the heap allocator API service and the garbage collection operations of the garbage collector . More particularly the invariant inference service inserts an invariant inference service initialization routine at system startup of the heap executive . For tracking invariants while the program runs at stage the invariant inference service inserts a hook at object allocation by the heap allocator and hooks at the points that the garbage collector performs its object reachable test on an object and processes a dead object in its periodic garbage collection passes. Then at the program termination and system shut down stage the invariant inference service inserts an invariant reporting procedure . These parts of the invariant inference service are described in more detail below.

In this exemplary implementation of the invariant inference service the invariants are inferred across the lifetime of objects although the inference could alternatively be performed over other periods.

In an alternative implementation of the invariant inference service the invariant inference service could also defer creating and initializing the meta data for the object until the garbage collection iteration following the object s creation. This would potentially enhance efficiency by avoiding allocating meta data for short lived objects that do not survive long enough after memory allocation to reach a garbage collection. However the exemplary invariant inference service allocates the meta data at the memory allocation hook to also collect information as to the call site of the allocator for invariants relating to this information.

More specifically shows the invariant inference service s procedure to update its invariance inferences. As indicated at operations the invariant inference service repeats an iteration of the procedure for each invariant that it is tracking in its meta data for the respective heap object. At operation the service checks whether the current invariant being checked is still marked as satisfied in the meta data . If so the service tests whether the invariant is still satisfied by the object at operation . The service forgoes re testing the invariant if the invariant was marked as not satisfied in an update of the invariant inferences during a previous garbage collection iteration. If the test shows the invariant is no longer satisfied the service updates the meta data to show that the invariant was not actually satisfied by the object at operation . Otherwise the meta data is left unchanged and the service continues to repeat an iteration of the procedure checking the object for a next invariant.

If the garbage collector uses a garbage collection process that may move objects in the heap the invariant inference service further hooks the garbage collector s procedure that moves objects. With this hook the invariant inference service updates its mapping from the object address to its corresponding meta data. Also the invariant inference service updates the meta data to appropriately reflect any pointer fields that are forwarded in the move such as that the object s field pointing to one location has been forwarded to another location. Otherwise a constant pointer could appear to be variable since it changes value.

The invariant inference service can infer various invariants or characteristics of the data structures on the heap. In an exemplary implementation the invariant inference service infers a set of generic invariants of the program s heap objects as well as a set of type specific invariants of the objects. In alternative implementations the set of invariants can be extended to infer other invariants in addition to those inferred in this exemplary implementation or can omit invariants inferred by the exemplary implementation. Further the exemplary invariant inference service infers intra object invariants but alternatively can be extended to also infer inter object invariants.

The set of generic invariants that the invariant inference service in the exemplary implementation checks for all program objects include the following invariants for each of the program object s reference fields 

In the exemplary implementation the set of invariants inferred for program objects of type array t can include 

In an alternative implementation the invariant inference service can be extended to also infer inter object invariants in addition to intra object invariants listed above. In one example alternative implementation the invariant inference service infers inter object invariants as a post process following program termination. For use in this post processing the invariant inference service tracks memory addresses of the heap objects during program execution at garbage collection iterations and emits or logs these memory addresses in the meta data. After program termination the invariant inference service processes this information to reconstruct portions of the heap inferred as constant for a given garbage collection iteration. By then examining the object reference fields inferred as constant after program termination the invariant inference service reconstructs the portion of the heap that has remained constant for the life of the program and infers the inter object invariants. This alternative implementation can then infer inter object invariants such as the following 

The foregoing description provides representative examples of invariants that can be discovered via the invariant inference leveraging garbage collection technique and is not intended to be comprehensive or complete. Many other invariants of program objects on the heap that are similar to those discussed above also can be discovered using this technique.

In one example application of the above described invariant inference leveraging garbage collection process the invariants discovered by the invariant inference service can be reintroduced to the source code of the program in the form of static annotations specifying the invariants which may be in the format of a language like Spec or other similar annotation language. These annotations can be added to the source code by the programmer based on the invariant report produced by the service. Alternatively the addition of such annotations can be performed as an automated process which processes the invariant report produced by the invariant inference service and inserts corresponding annotations for certain invariants into the program source code. The annotations can aid the programmer in better understanding the source code to facilitate further code development. In addition the annotations can be used to enforce the invariants or to detect bugs parts of the code that violate the invariants either through use of static analysis of the program based on the annotations or dynamically at run time in a later execution of the program. In this way bugs in later edits to the program that cause violation of the invariants can be more easily detected.

More particularly in one implementation of the invariant inference leveraging garbage collection process in a debugger the heap executive with the invariant inference service is used on a program in development to detect the introduction of bugs during the development process. The program is subjected to the invariant inference process initially in a first invariant discovery run of the program. The invariant inference process is applied again in a debugging run after further edits have been made to the program. In the initial invariant discovery run source code of the program is compiled by compiler into the executable program . The executable program is run in the run time environment with the heap executive having the invariant inference service . When run in this run time environment the invariant inference process produces the invariant report as discussed above. At the annotator block static annotations specifying the invariants reported in the invariant report are added to the source code. The annotator can be manually added. Alternatively the annotator can be automated process that takes the source code and invariant reports as inputs and produces the annotated source code.

The source code then may be edited by the programmer in further development such as to add further features to the program or otherwise modify its operation. After these edits the edited and annotated source code is again compiled by compiler into the executable program and again run in the run time environment . Again the invariant inference process produces the invariant report . This time a bug detector processes the invariant report . The bug detector compares the invariants reported in this debugging run of the program to the invariants specified by the annotations in the edited and annotated source code . The bug detector reports any violations differences in the reported invariants from those specified in the annotations as bugs in a bug report . The bug detector can be implemented to operate as an off line or post process on the invariant report resulting from an execution of the program in the run time environment. Alternatively the bug detector can be implemented to operate in real time in combination with the invariant inference process such as also during garbage collection passes. In this way the bug detector can detect and report violations of the annotated invariants as the program is running.

In one particular application the invariant inference leveraging garbage collection described herein can be applied to the heap based bug identification using anomaly detection technique described by Trishul Chilimbi and Vinod Ganapathy HEAP BASED BUG IDENTIFICATION USING ANOMALY DETECTION U.S. patent application Ser. No. 11 134 812 filed concurrently herewith the disclosure of which is hereby incorporated herein by reference . More particularly the invariant inference service described herein can be used to infer relatively stable properties the invariants of heap objects in a first execution of a program or previous phases of execution of a long running program . Then an anomaly detection tool which may again be implemented using the invariant inference service detects the occurrence of anomalies where the objects heap behavior deviates from their previously observed invariants. The anomaly detection tool can be implemented as an off line process that compares the invariants reported by the invariant inference service in a first execution of the program to those reported in subsequent executions. Alternatively the anomaly detection can be implemented as a run time tool in which the invariants tracked by the invariant inference service are compared to invariants reported in a previous execution of the program or previous phases of execution of a long running program to detect the occurrence of anomalies where the object deviates from the previously reported invariants.

In a further example application the above described invariant inference leveraging garbage collection process also has application to behavior driven optimization of the program. The invariant inference process can be considered as a general purpose statistics gathering mechanism. In particular the invariant inference process can be used to track behavior of program objects which can suggest optimizations that can advantageously be applied to improve the program. For example one such behavior driven optimization application is to monitor how balanced is a Hashtable object i.e. how even is the distribution of stored objects among the buckets of the Hashtable . This is an invariant that can be discovered via the invariant inference process as discussed above. If the Hashtable is not very balanced this is usually an inefficiency that can be addressed by adjustment alteration or replacement of the Hash function. Therefore by reporting such invariants of program objects relating to their behavior the invariant inference leveraging garbage collection technique also can lead to behavior driven optimizations.

The above described exemplary software analysis tool incorporating the heap executive with invariant inference service can be implemented on any of a variety of computing devices and environments including computers of various form factors personal workstation server handheld laptop tablet or other mobile distributed computing networks and Web services as a few general examples. The software analysis tool and invariant inference leveraging garbage collection techniques can be implemented in hardware circuitry as well as in software executing within a computer or other computing environment such as shown in .

With reference to the computing environment includes at least one processing unit and memory . In this most basic configuration is included within a dashed line. The processing unit executes computer executable instructions and may be a real or a virtual processor. In a multi processing system multiple processing units execute computer executable instructions to increase processing power. The memory may be volatile memory e.g. registers cache RAM non volatile memory e.g. ROM EEPROM flash memory etc. or some combination of the two. The memory stores software implementing the analysis tool with heap invariant inference leveraging garbage collection.

A computing environment may have additional features. For example the computing environment includes storage one or more input devices one or more output devices and one or more communication connections . An interconnection mechanism not shown such as a bus controller or network interconnects the components of the computing environment . Typically operating system software not shown provides an operating environment for other software executing in the computing environment and coordinates activities of the components of the computing environment .

The storage may be removable or non removable and includes magnetic disks magnetic tapes or cassettes CD ROMs CD RWs DVDs or any other medium which can be used to store information and which can be accessed within the computing environment . The storage stores instructions for the software of the exemplary analysis tool implementing the heap invariant inference leveraging garbage collection techniques.

The input device s e.g. for devices operating as a control point in the device connectivity architecture may be a touch input device such as a keyboard mouse pen or trackball a voice input device a scanning device or another device that provides input to the computing environment . For audio the input device s may be a sound card or similar device that accepts audio input in analog or digital form or a CD ROM reader that provides audio samples to the computing environment. The output device s may be a display printer speaker CD writer or another device that provides output from the computing environment .

The communication connection s enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer executable instructions audio video or other media information or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired or wireless techniques implemented with an electrical optical RF infrared acoustic or other carrier.

The analysis tool and techniques herein can be described in the general context of computer readable media. Computer readable media are any available media that can be accessed within a computing environment. By way of example and not limitation with the computing environment computer readable media include memory storage communication media and combinations of any of the above.

The techniques herein can be described in the general context of computer executable instructions such as those included in program modules being executed in a computing environment on a target real or virtual processor. Generally program modules include routines programs libraries objects classes components data structures etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer executable instructions for program modules may be executed within a local or distributed computing environment.

For the sake of presentation the detailed description uses terms like determine generate adjust and apply to describe computer operations in a computing environment. These terms are high level abstractions for operations performed by a computer and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.

In view of the many possible embodiments to which the principles of our invention may be applied we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto.

