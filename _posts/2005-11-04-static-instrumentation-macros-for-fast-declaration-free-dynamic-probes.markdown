---

title: Static instrumentation macros for fast declaration free dynamic probes
abstract: Embodiments of the present invention provide a dynamic instrumentation system that uses statically defined probes. The probes may be defined using macro definitions. One or more libraries of macro definitions that are linked to static probes are provided in the computer system. Each probe is uniquely identified by a name having a well-defined prefix and a structured format. Probes may then be inserted at various locations and into the target software using standard macro calls. When the target software is compiled, the macro calls of each probe are expanded to calls to an existing function known as a probe handler function. Each probe handler function is identified in the computer system's symbol table with a unique symbol that corresponds to the name specified by the macro definition. When a probe is activated, the operating system kernel transfers control to an instrumentation kernel object. The instrumentation kernel object locates and runs the probe handler function to perform the actions requested for that probe.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08739135&OS=08739135&RS=08739135
owner: Red Hat, Inc.
number: 08739135
owner_city: Raleigh
owner_country: US
publication_date: 20051104
---
The present invention relates generally to monitoring computer systems and in particular to probing and tracing the operations of computer systems.

As computer systems become more complicated performance analysis must increasingly be performed on live production systems rather than in a development or test environment. Traditionally computer systems have been analyzed using debugging tools to set breakpoints at specific locations of an application. The breakpoint interrupts the running of the computer system and allows the developer to inspect the operation of the application and enter commands. However it is not always feasible to stop the operation of a computer system especially a production system in order to analyze its operations. In addition in order to understand systematic issues an impractically large number of breakpoints may be required.

Static probe are another known way of analyzing the operation of a computer system. Static probe are probes that have been pre installed in various locations such as the operating system kernel or other target software throughout the computer system. When a probe is activated or fired control of the computer system s operations branch to perform the actions associated with the probe without the need of a breakpoint. Thus static probes can be much more efficient than breakpoints. In addition static probe can be used on a production system because of their minimal effect on operations.

However known static probe tools also have their own disadvantages. For example the known static probe tools may require special programming skills and kernel programming. For example the Dtrace tool by Sun Microsystems requires special build changes to an application or operating system. In addition the Dtrace tool requires the use of elaborate declarations and special programming in a separate language called D. This makes Dtrace difficult to use or implement.

Accordingly it may be desirable to provide a system performance tool that is easy to use. It may also be desirable to provide a system performance tool with static probes that does not require special programming or elaborate declarations.

In accordance with one feature a method of linking a probe script to a statically defined probe is provided. The statically defined probe includes an indirect function call through a global function pointer. A name for the probe specified in the probe script is determined. A symbol having at least a portion that matches the name for the probe is then identified. A format of the probe is determined based on decoding the symbol. The probe script is converted into a probe handler function that comprises program code statements based on the format of the probe. The probe handler function is then linked to the global function pointer of the probe.

In accordance with another feature a method of translating a probe script into a probe handler function is provided. The probe script includes a name for a probe and a set of actions to be performed when the probe is activated. The name of the probe is identified from the probe script. A symbol having at least a portion that matches the identified name is then located. Parameters of the probe are determined based on the symbol. Program code statements are then determined for the probe handler function in order to implement the actions included in the probe script when the probe is activated and based on the determined parameters.

In accordance with another feature a method of instrumenting a program is provided. A macro definition that designates a name for a statically defined probe point is inserted into the program. The name comprises a global function pointer and encodes a format of the probe. The macro definition also includes a conditional indirect function call for the probe through the global function pointer. Calls to the macro are inserted into the program s source code at desired locations for the probe. The program source code is then compiled into object code and includes a dormant probe for each inserted macro call.

In accordance with another feature a computer system is configured to dynamically trace its operations based on a set of statically defined probes. The system comprises a processor a memory coupled to the processor and configured into a user space and a kernel space and an application process. The application process runs on the processor in the user space and comprises a set of probes at statically defined locations in the computer system. The probes are activated based on a conditional indirect function call for the probe through a macro call to a global function pointer. A probe manager is configured to translate a probe script into a probe handler function that runs in the kernel space. The probe handler function is loaded as an executable object in the kernel space to perform actions specified in the probe script for the probe.

Additional features of the present invention will be set forth in part in the description which follows and in part will be obvious from the description or may be learned by practice of the invention. It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention as claimed.

Embodiments of the present invention provide a dynamic instrumentation system that uses statically defined probes. The probes may be defined using macro definitions. In some embodiments one or more libraries of macro definitions that are linked to static probes are provided in the computer system. Each probe is uniquely identified by a name having a well defined prefix such as  systemtap probe  or  dtrace probe  and a structured format.

Probes may then be inserted at various locations and into the target software using standard macro calls. When the target software is compiled the macro calls of each probe are expanded to calls to an existing function known as a probe handler function. Each probe handler function is identified in the computer system s symbol table with a unique symbol that corresponds to the name specified by the macro definition. When a probe is activated the operating system kernel transfers control to an instrumentation kernel object. The instrumentation kernel object locates and runs the probe handler function to perform the actions requested for that probe.

The actions requested for a probe are specified in a probe script. The probe script may be written individually or retrieved from a library. In order to install the probe the probe script is translated into the probe handler function. In some embodiments the probe handler function is written in the same source code language as the target software.

The probe handler function can be specified without the need of a formal declaration. Instead a probe s symbol may be retrieved from the computer system s symbol table and is decoded to determine the characteristics of the probe handler function. In particular a probe script translator queries the symbol table to determine the probe s symbol. The translator then parses the symbol to determine the characteristics of the probe handler functions such as its parameters and data types. The translator passes this information to a builder module which generates program code statements for the probe handler function. The probe handler function can then be compiled and loaded into the kernel as an executable object. When a probe is activated the kernel branches operation to the object to perform the actions requested for the probe.

Reference will now be made in detail to exemplary embodiments of the invention which are illustrated in the accompanying drawings. Wherever possible the same reference numbers will be used throughout the drawings to refer to the same or like parts. provide a general description of the computer system its components and basic architecture. are then provided to explain some of the process flows related to implementing probes in a computer system.

As shown computer system may include a central processor a keyboard a pointing device e.g. mouse or the like a display a main memory an input output controller and a storage device . Processor may further include a cache memory for storing frequently accessed information. Cache may be an on chip cache or external cache. System may also be provided with additional input output devices such as a printer not shown . The various components of the system communicate through a system bus or similar architecture.

One skilled in the art will recognize that system may comprise various other components such as multiple processors additional storage devices etc. Such components are well known to those skilled in the art.

Hardware represents the components of hardware and firmware described above with reference to such as processor and memory . As noted such hardware and firmware are well known to those skilled in the art.

Operating system OS provides basic services for running other software on system such as drivers basic input output system code a file system and the like. OS is an integrated collection of routines that service the sequencing and processing of programs by hardware . OS may provide other services such as resource allocation scheduling input output control and data management. OS may be predominantly software but may also comprise partial or complete hardware implementations and firmware. Well known examples of operating systems that are consistent with the principles of the present invention include GNU Linux AIX by IBM and Sun Solaris by Sun Microsystems.

Kernel serves as the core of OS . Kernel is responsible for providing access to hardware and to various computer processes. Since there may be multiple programs running kernel also schedules when and how long the various computer processes can make use of hardware .

Probe object is a module or component of kernel that services a probe when it is activated. Probe object may be augmented by information about the name and location of entry points and external calls to functions not contained in the object . In some embodiments probe object is generated from compiled program code known as a probe handler function and linked with the runtime of OS into a stand alone object or module of kernel .

Event handler is a module of kernel that determines when a probe has been activated. In particular event handler determines when a program s execution has generated an event such as an interrupt or branch based on reaching a probe. Event handler may then determine whether a probe has been activated and transfers control to probe object . In some embodiments event handler is compiled program code and also linked with the runtime of OS into a stand alone module of kernel .

Probe manager provides a facility for statically defining probes and dynamically tracing the operations of system . For example probe manager may receive as its input a probe handler. The probe handler is a script that describes an association of probe handler functions with probe points and the actions to be performed when the probe point is activated or hit during operations by computer system . Probe points are the abstract names give to identify a particular place in kernel or user code such as application or a particular event e.g. a timer or counter that may occur at any time. As shown probe manager may comprise a script analyzer a translator a loader and a logger . These components and their respective functions will now be further described.

Script analyzer analyzes the script of the probe handler and resolves any needed symbolic references contained in the probe handler. For example script analyzer may resolve symbolic references to kernel user programs such as application or tapset information .

For example script analyzer may resolve run time addresses of references in the probe handler to function parameters local and global variables source locations and the like. Script analyzer may resolve this information using information such as resource information tapset information and probe library .

Translator translates the elaborated form of the probe handler into program source code such as C code known as a probe handler function. Each probe handler function may include various features such as locking checks safety checks and runaway prevention logic to ensure that the probe handler can safely run on computer system . Each variable shared amongst probes may be mapped to an appropriate static declaration and accesses may be protected by locks. Each group of local variables may be placed into a synthetic call frame structure.

Translator may wrap each probe handler function using a probe point registration application programming interface that is included with computer system . For probe points located in kernel translator may leverage an existing probe facility such as kprobes from IBM. For probe points located in user applications probe points may be inserted into specific processes executable segments using a macro call mechanism.

Translator may generate the probe handler function to include references to a common runtime that provides routines for generic lookup of tables constrained memory management startup shutdown input and output functions and other functions.

Loader compiles and loads the probe handler function from translator and links it with the runtime of operating system into a stand alone module of kernel such as probe object . For security reasons loader may cryptographically sign probe object so that it may be archived and later reused on computer system or on another computer without a compiler installed.

Logger records any relevant information about system when a probe is activated. Logger may be configured to collect information about kernel and user space applications such as instrumented application . Accordingly logger may collect information from virtually any aspect of computer system .

Resource information contains information to locate functions local variables types and declarations. In particular resource information comprises information for making resources of computer system available to programs. These resources may be items such as procedures e.g. functions or subroutines of operating system variables static data e.g. named constants or icons and the like. Each resource exists at an offset in a library file loaded into operating system and each resource may also have a name or symbol. 

In order for a program to access a resource in a library it must know the resource s byte offset in the file. Since libraries may change from time to time it is usually more convenient for the calling program to look up the byte offset in a data table inside the library. Accordingly resource information may include what is generally known as a symbol table which provides a mapping between a resource s name and the offset in the library file. For example embedded and linkable format symbol tables are well known to those skilled in the art.

Probe Library is a collection of information for defining and implementing probes. For example as shown in probe library may comprise macro definitions and script library .

Macro definitions provide a family of macro definitions that are accessible to kernel or other programs. For example one or more of macro definitions may be inserted into the header files of a program such as instrumented application . In some embodiments macro definitions may include attribute declarations into macros for a static function pointer variable in order to ensure that a probe s symbol appears in a symbol table of resource information .

Script library provides a family of probe scripts. For example script library may comprise various script files for probe definitions auxiliary function definitions and global variable declarations. A probe definition identifies one or more probe points and includes a body of actions to perform when any of the probes at the probe points are activated. An auxiliary function is a subroutine that may be used by a probe handler and other functions. A global variable declaration lists variables that are shared by all probe handlers and auxiliary functions. A basic script file may also include references to other files in script library or tapset information . In addition scripts in script library may include other related values such as the stringified version of actual input expressions such as 1num . Furthermore probe scripts may include one or more extensions in order to support multiple concurrent active probe scripts that are associated with the same probe point.

Tapset information may comprise libraries of script or program code that are used to assist or extend the capabilities of the basic script used in the probe handler.

Instrumented application may be any base of software that is targeted for instrumentation. For example as shown in instrumented application may comprise a probe . Probe defines a location in application in which instrumentation is requested. In some embodiments probe is inserted as a macro call into the source code of application .

In stage macro calls are inserted into the target program code that is to be instrumented. For example an administrator or developer may insert the selected macro definitions from macro definitions into the header file for instrumented application . The developer or administrator may then augment instrumented application with one or more macro calls at various locations of interest such as at the location of probe .

In stage instrumented application is compiled into object files that are executable by system . In some embodiments during compilation of instrumented application the macro calls for probe are expanded to calls to an existing probe handler function having a well defined prefix such as  systemtap probe  to its symbol in a symbol table of resource information .

In stage the developer or administrator links together the object files in order to build instrumented application . Unlike conventional tools embodiments of the present invention do not require any changes to the normal build process for application . Hence the compiled object files for instrumented application may be linked together to create an application binary that is executable by computer system . In some embodiments the probe handler function for probe is compiled into the same native program code as the source code of instrumented application and is loaded as an executable module or object into kernel . This allows kernel to merely branch its operations and avoid shifting to another execution environment. For example typical implementations of Dtrace probes require an augmented build process and formal declarations for the probes. In addition Dtrace probes are compiled into a different programming language i.e. the D language which also requires kernel to shift its operations more dramatically.

In stage the probe script is analyzed and references elaborated. In particular translator analyzes the probe script resolves any symbolic references for example to kernel user programs or any other tapsets. For example translator may resolve references to function parameters function pointers local and global variables and source locations to actual runtime addresses. Translator may perform this analysis by referring to probe library script library tapset information and resource information and generate a fully elaborated version of the probe script. Processing may then flow to stage .

In stage the script is translated into a probe handler function. In particular builder may translate the elaborated probe script into program code known as the probe handler function. For example builder may be configured to translate probe script into a quantity of C code. In addition builder may include various locking and safety checks when generating the probe handler functions. Each variable shared among probes may be mapped to an appropriate static declaration and accesses may be protected by locks. In addition each group of local variables in a probe handler function may be placed into a synthetic call frame structure. The translation of the probe script into a probe handler function is further described with reference to .

In some embodiments builder may wrap the probe handler function by an interface function that uses an appropriate probe point registration application programming interface. For example in some embodiments builder may use kprobes for location type probes targeted at kernel . Kprobes is a known dynamic instrumentation system that is included in the kernel of LINUX operating systems. Of course builder may also implement probes into user space programs such as instrumented application using inserted macro calls as described above with reference to . Accordingly embodiments of the present invention may provide comprehensive dynamic instrumentation that spans virtually all locations of computer system .

In stage the probe handler function is compiled and loaded. In particular probe manager compiles the script into native code such as C language code and links it with the runtime library to create a loadable kernel module. Processing may then flow to stage .

In stage the program handler function is loaded as a module or object into the kernel such as probe module . Since the probe handler function is built as a module of kernel kernel does not need to be recompiled or rebooted in order to provide the instrumentation requested by the probe. Thus computer system may continue with its normal operations. Processing may then flow to stage .

In stage operating system monitors for when a probe is activated. If a probe has not been activated then normal processing by computer system continues and probe processing loops back to stage .

If a probe has been activated then in stage system performs the actions specified in the probe. For example when probe in instrumented application is encountered application may make an indirect function call that is serviced by kernel . In response kernel invokes event handler saves the current instruction in a buffer and the instruction at that location is replaced by a breakpoint or branching instruction to execute the probe. Event handler determines whether the current event is for a probe or some other type of breakpoint or error by checking the information in resource information . If there is no probe registered for that location then event handler processes the event as a normal breakpoint and passes it on to an appropriate handler. However if a probe has been found then event handler invokes the probe handler function for example by executing probe module .

Once probe module has completed its actions kernel may resume at the instruction following the probed instruction. Normal operation by kernel and instrumented application may then resume. In addition in some embodiments probe module may be unloaded once it has completed its processing.

In stage a probe symbol is determined. In particular translator may search one or more symbol tables in resource information to locate the probe s symbol. In some embodiments translator can automatically find probes in the symbol table because of they are marked with a well defined prefix such as  systemtap probe  and ending with the name of the probe. Processing then flows to stage .

In stage parameters for the probe are determined. In some embodiments translator may identify the parameters from the probe based on decoding its symbol. For example a probe s symbol may include one or more fields between the prefix and the name that indicate the parameters of the probe. Probe parameters may relate to whether the probe is handling characters or numbers and the like. For example a probe s symbol may be  systemtap probe ns   name . Accordingly translator may decode the characters such as ns into the type information and type arguments for the probe. Processing may then flow to stage .

In stage program code for the probe handler function is generated. In some embodiments translator may generate C language code for the probe handler function. Since translator discovered the argument types for the probe from its symbol in the symbol table translator may synthesize a compatible routine. In addition since translator also determined the address of the static function pointer variable from the symbol table perhaps as an offset from a runtime address translator may set the probe handler function to point to this address as a synthetic function. The probe handler function may then call into the functions defined by the action statements in the probe script since the auxiliary information has been set up from parsing the probes symbol.

Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only with a true scope and spirit of the invention being indicated by the following claims.

