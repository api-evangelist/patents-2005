---

title: Application independent messaging system
abstract: A messaging system that isolates application programs from the underlying transport and routing mechanisms that are actually used to convey messages. This isolation is provided in part through the use of directory files. The directory files contain all of the specific details (e.g. conversion and routing parameters) necessary to interface with the transport and routing mechanisms. As the transport and routing details change (e.g. due to updated versions or new mechanisms) only the directory files need to be changed. The present invention further includes Message Processing Servers (MPSs) which provide additional messaging functionality such as message storage, tracing, reconciliation, statistical auditing, reformatting, content based routing and multicasting. As additional functionality is developed, this functionality can be flexibly incorporated into a new MPS.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07458079&OS=07458079&RS=07458079
owner: JPMorgan Chase Bank, N.A.
number: 07458079
owner_city: New York
owner_country: US
publication_date: 20051130
---
This application is a continuation of U.S. application Ser. No. 09 409 300 now U.S. Pat. No. 7 047 532 filed Sep. 29 1999 which claims the benefit of U.S. Provisional Application No. 60 108 285 filed Nov. 13 1998.

The present invention generally relates to inter system and intra system messaging systems and more particularly to a messaging system architecture which provides an abstraction layer between application programs and the messaging transport layer.

Starting decades ago with the mainframe computer the first wave of the computing revolution empowered enterprises to manage huge volumes of information fueling a massive growth in the scale of commerce worldwide. The introduction of the personal computer began the second wave of the continuing revolution bringing the power of information creation to individuals. One factor in the growth of computing has been the development of interfaces that enabled various computer program applications to pass data to each other and otherwise communicate with each other. This inter application or inter computer communication is generically described as messaging. 

Presently networks are emerging as the third wave of the computing revolution enabling both enterprises and the individuals to rapidly and easily communicate information throughout the world. However a significant problem which has impeded inter network and intra network communication is the diversity of the interfaces both hardware and software which have been developed throughout the years.

Recognizing this problem representatives of major computer and telecommunication companies beginning in 1983 developed and adopted a standard model for communication. The standard known as OSI Open Systems Interconnection is used to guide product developers and manufacturers so that their products will consistently work with other products. OSI was officially adopted as an international standard by the International Organization of Standards ISO .

The OSI model defines seven layers of functionality that takes place at each end of a communication. Although OSI is not always strictly adhered to in terms of keeping related functions together in a well defined layer many if not most products involved in telecommunications and messaging make an attempt to describe themselves in relation to the OSI model.

The key idea in OSI is that the process of communication between two end users in a telecommunication network can be divided into layers with each layer adding its own set of special related functions. The systems on each end of a communication in some manner incorporates these seven layers of function. In a given message between users there is a flow of data through each layer at one end down through the layers in the computer used by the sending user and at the other end when the message arrives another flow of data up through the layers in the receiving user s computer. The actual programming and hardware that furnish these seven layers of function is usually a combination of the computer operating system applications such as a Web browser Transmission Control Protocol Internet Protocol TCP IP or alternative transport and network protocols and the software and hardware that enables the computer to physically place a signal on a hardware line attached to the computer.

The seven OSI layers are graphically illustrated in . The seven layers are logically divided into two groups. The lower three layers are used when any message passes through the host computer. The upper four layers are used whenever a message passes to or from an application executing on the host computer. Messages between two host computers pass through all seven layers . Messages destined for some other host e.g. when the instant host is acting as an intermediate node in a network are not passed up to the upper layers but are forwarded to the host or another intermediate node .

The seven OSI layers include an Application Layer a Presentation Layer a Session Layer a Transport Layer a Network Layer a Data Link Layer and a Physical Layer . The Application Layer is the layer at which communication partners are identified quality of service is identified user authentication and privacy are considered and any constraints on data syntax are identified. Note that the Application Layer is not the application itself but rather provides an interface to the user. Some applications may perform application layer functions. Some implementations of the Application Layer include but are not limited to E mail newsgroups web applications file transfers host sessions directory services network management and file services.

The Presentation Layer is usually part of an operating system which converts incoming and outgoing data from one presentation format to another. For example the Presentation Layer might convert data from a text stream into a popup window. The Presentation Layer is sometimes called the syntax layer. Some implementations of the Presentation Layer include but are not limited to POP SMTP Usenet HTTP FTP TelNet DNS SNMP and NFS.

The Session Layer sets up coordinates and terminates conversations exchanges and dialogs between the applications at each end of the communication. The Session Layer sets up and manages session and connection coordination. Some implementations of the Session Layer include but are not limited to POP 25 532 80 20 21 23 53 161 162 and RPC Portmapper.

The Transport Layer manages the end to end control of the communication for example determining whether all packets have arrived and error checking. The Transport Layer ensures complete data transfer. Standards such as TCP and UDP are implementations of the Transport layer .

The Network Layer handles the routing of the data. This routing involves sending a message in the right direction to the right destination on outgoing transmissions and receiving incoming transmissions at the packet level. The Network Layer performs routing and forwarding of messages. Internet Protocol Versions 6 and 4 are implementations of the Network Layer . The Data Link Layer provides error control and synchronization for the Physical Level .

The Data Link Layer also furnishes transmission protocol knowledge and management. Standards such as SLIP PPP 802.2 SNAP Ethernet II are implementations of the Data Link Layer .

The Physical Layer is the layer that conveys a bit stream through the network at the electrical and mechanical level. Layer provides the hardware means of sending and receiving data on a carrier. Standards for the Physical Layer include RS X Cat 1 ISDN ADSL ATM FDDI Cat 1 5 as well as Coaxial Cables.

Even though the adoption of the OSI model has lead to a certain level of uniformity in messaging the diversity of the actual implementations of the model still remains a vexing problem for application programmers and system integrators. One result of this complexity is that applications have been forced to include hardcoded descriptions of the various other applications platforms formats and routing used for messaging. If any of these parameters change e.g. a new version of an operating system the application program must be modified recompiled and tested. This is a huge problem in conventional messaging architectures.

Accordingly there is a long felt need in the industry for a messaging architecture which allows diverse applications on diverse platforms to communicate with each other. Such an architecture should enable application developers to concentrate on the substance of their applications and disregard the complex physical infrastructure associated with messaging.

The present invention provides a messaging system which includes Application Programming Interfaces API which isolate application programs from the underlying transport and routing mechanisms that are actually used to convey messages. These APIs are also known as abstraction layers since the application can conceptually view the transport and routing mechanism abstractly and not be concerned with the details of the specific formatting and routing required for transport and routing.

One method by which the APIs of the present invention provide this isolation is through the use of directory files. The directory files contain all of the specific details e.g. formatting and routing parameters necessary to interface with the transport and routing mechanisms. As the transport and routing details change e.g. due to updated versions or new mechanisms only the directory files need to be changed without the need for recoding recompiling or extensive testing of the application programs. This solves a significant problem of the prior art in which the details of interfacing with the transport and routing mechanisms were hardcoded into the application program itself.

Another aspect of the present invention is that it enhances the ability for an application to take advantage of a transport mechanism s asynchronous messaging capability. This is a significant departure from and advantage over certain prior art which required applications to coordinate and manage the transmission and routing of a message all the way to its destination. In the present invention once an application has issued a message to the API control returns to the application which can then continue its substantive processing without having to concern itself with the transport and routing of the message. A huge advantage of asynchronous messaging is found in the area of testing. In the synchronous messaging prior art when a new or updated application was brought online testing of the application required that systems with which the application interfaced had to be taken out of service in order to test the new application. As the present invention enhances the capability of asynchronous messaging the new application can be tested by itself and testing of the messages it produces can be accomplished by the other systems at a time which is convenient for the other system. This advantage results in significantly faster cheaper and easier application development and testing.

The present invention further includes Message Processing Servers MPSs which provide additional messaging functionality such as message storage tracing reconciliation statistical auditing reformatting content based routing and multicasting. As additional functionality is developed this functionality can be flexibly incorporated into a new MPS.

As shown in the Global Technology Architecture GTA common Application Programming Interface API layer is the only one exposed to the Application . As used in the instant specification the present invention is sometimes referred to as a Global Technology Architecture GTA . The term global is used to denote the fact that in a preferred embodiment of the present invention the architecture is preferably adopted by and used in each of the computing operations of an enterprise throughout the world. The GTA common API includes the modules GTAPUT GTAGET GTACMIT GTABACK GTATERM and GTABEGIN that will be discussed in more detail below. The two most common modules are used by Applications to send messages GTAPUT and to receive messages GTAGET .

Beneath the abstraction layer lie the interfaces to the actual transport mechanisms. Illustrated in are two different types of messaging middleware used as the transport mechanism MQSeries and Function Router Queue Subsystem FRQS . FRQS is a proprietary messaging middleware product developed in house by the assignee of the present invention. MQSeries is a messaging middleware product offer by the IBM Corporation and is presently the de facto standard in the industry for messaging middleware. The use of MQSeries is a preferred embodiment of the present invention as the MQSeries is currently available for thirty five different platforms including but not limited to Win NT Win 95 Win 98 IBM s AIX platform Sun Solaris HP UX Platforms.

Although the present invention can easily be adapted to work with any messaging middleware such as DECMessageQ the present description shall be made with respect to the MQSeries and FRQS products as the operation of the present invention has been reduced to practice with respect to both of these middleware products.

As shown in the interface between the GTA common API and the FRQS system is direct without any further abstraction layer required. In contrast if a message is intended for transport using the MQSeries there are two additional abstraction layers or and . The present inventors have developed the GTA Messaging GMA layer in order to provide additional functionality that is not found in the MQSeries . In this respect a GTA Messaging message is a customized form of a native MQSeries message. As will be further described below the functionality provided by GTA Messaging includes logic for block processing asynchronous responses and archiving. The architecture of the GTA Messaging of the present invention is primarily accomplished through the use of additional headers attached to the message. These headers are read by the GTA Messaging APIs in order to extract the instructions for the desired processing to be performed by the API e.g. block processing .

If the partner application i.e. the message receiving application does not have access to the GTA Messaging functionality and accordingly cannot properly receive and interpret GTA Messages the GTA common API has the capability of sending messages using the Native MQ Messaging Layer . All systems which employ the MQSeries for the transport mechanism are capable of receiving messages generated by the Native MQ Messaging Layer .

Below the GMA layer and the Native MQ Messaging layer there is an additional abstraction layer denoted as the MQSeries Abstraction Layer . This abstraction layer provides a simplified wrapper around the MQSeries in order to further aid in simplifying the architecture of the present invention. The MQSeries abstraction layer also known as GMQ simplifies the MQSeries commands by defaulting certain options and simplifying the calling structure.

In relation to the OSI Model described with respect to the abstraction layers and of the present invention depicted in correspond to Application layer the Presentation Layer and the Session Layer . The MQSeries and FRQS of correspond to the Transport layer of .

Abstraction is a key concept of the present invention that frees Applications from being directly tied to a specific vendor product e.g. MQSeries . As further described below the present invention achieves a certain level of abstraction through the use of directories which contain the vast majority of the transport mechanism specific details. Abstraction is a process of deriving a simplified description or specification of a system in the present case MQSeries and FRQS that emphasizes some of the system s details or properties while suppressing others. A good abstraction is one that emphasizes details that are significant to the user and suppresses details that are immaterial to the functionality required by the user.

As an example of the abstraction provided by layers these abstraction layers simplify messaging such that an Application only needs to supply a small percentage of the fields that MQSeries requires to send a message apart from the message itself . The remainder of the required fields are populated by the abstraction layers using default data from public directories. Furthermore the abstraction laywers only allow an application to override a limited number of the default fields provide by the directories.

The present invention maintains most of the functionality at the abstraction layers so that an Application does not have to sense and discriminate for example differences in data formats. If an Application were to communicate directly to MQSeries there are numerous options which the Application would have to select with respect to sending a message. Therefore the abstraction layers reduce the number of selectable options thereby simplifying the task of messaging. This architecture is accordingly cheaper to maintain requires shorter training and prevents the inherent danger of allowing the Application to have full access to the Transport layer or .

As a specific example of the abstraction provided by layers MQSeries has one to ten priority codes. If multiple applications were communicating directly with MQSeries and each application set the same priority on all of the messages being sent e.g. the highest priority the priority function would become meaningless and none of the messages would be sent with a higher priority. In the abstraction layers of the present invention every request starts off as being treated of equal priority. Instead of allowing the Application to assign the MQSeries specific priority of one to ten the Application can only specify an increase or decrease from the presently assigned priority.

In general the simplification produced by abstraction results in the taking away of certain functionalities. Since most messaging middleware e.g. MQSeries is developed to satisfy the broadest range of users in a system according to the present invention the abstraction layers are developed to provide only the necessary functionality required by the Applications serviced by the system. In some cases the removal of functionality is actually a requirement of the system. For example in a preferred embodiment of the present invention the system operates in a banking environment. In this environment it is desirable to prevent access or changes to dynamic messaging queues in order to prevent a user from rerouting a message representing a money transfer thereby effectively misappropriating the money.

In one embodiment of the present invention applications running under the Customer Information Control System CICS pass the message and the control block to the GTAPUT module using a common area or a temporary storage queue. On distributed platforms GTAPUT is dynamically linked to the application at runtime. Linking is the process of converting a runtime library into an executable program. The messaging architecture of the present invention supports an application s logical unit of work with and without a Transaction Processing TP monitor. For platforms with a TP monitor such as CICS the architecture participates in a TP monitor s commit or rollback. In the absence of the TP monitor the present invention allows applications to explicitly issue GTACMIT and GTABACK see in commands to commit or rollback pending GTAPUT or GTAGET operations.

Applications need to manage Logical Units of Work LUW in order to maintain data integrity across multiple resources. When putting or getting messages applications must specify whether the messages are part of an LUW by using the appropriate calling options. The GTAPUT and GTAGET APIs performing message operations use the underlying service layers in to perform pending puts or gets. When the application issues a GTACMIT the module will use the underlying service layers to commit pending message operations. Conversely the GTABACK command is a backout command which will rollback pending message operations in the present invention. A call to GTABEGIN is used to start a unit of work that is coordinated by the queue manager and that involves changes to resources owned by other resource managers.

The control blocks sent to GTAPUT by the Application contain the parameters which enable GTAPUT to prepare the message for passage to the transport layer in this case MQSeries . As described above the parameters available to Application for passage to the Abstraction layer see are intentionally limited since it is desired that the architecture of the present invention be as simple as possible.

Using the limited parameters passed to it by the Application GTAPUT retrieves the full compliment of parameters required by MQSeries from Directory . Most of these parameters are default parameters retrieved from Directory based on the limited parameters specified by the Application . After MQSeries has performed all of its processing it transmits the message in its final form on the physical transportation mechanism. The records and illustrated in respectively represent an Archive record and a Trace record as will be discussed in greater detail below. Archiving and Tracing are options which are set in the Directory . In a preferred embodiment of the present invention the option of turning Archiving and Tracing on and off for messages is not given to an Application . Rather Archiving and Tracing are enabled disabled according to settings found in the Directory .

As a matter of convention in the present disclosure the Directories the MQSeries and the GTA Messaging APIs e.g. GTAPUT will be given the same character designation. It is readily appreciated that these modules tables and interfaces can and do exist as different physical entities at different physical locations but the function provided by each is the same regardless of where it is installed and used. For example the basic functioning of the module GTAPUT will be the same on a platform in New York as it is on a platform in London or Dallas. With respect to Directories a Directory at one location will naturally contain different entries which are required to support the applications residing on that platform while a Directory on a different platform will have entries required to support the applications on it s platform.

The most important parameter contained in the request block is called the service identifier. The service identifier is used by GTAPUT as a key to access the Directory in order to fill in all of the details required to send a message. As will be further described below with respect to Directory each service identifier will point to a different set of default parameters which GTAPUT can use to interface with MQSeries in order to send or receive a message. As a result of using the simple service identifiers and directory architecture the present invention enables the Application to be free of any of the details of the transport of a message. Although MQSeries is a preferred transport layer due to its wide commercial acceptance as illustrated in other transport mechanisms such as FRQS can be used. It is readily appreciated that other transport mechanisms can be used without departing from the architecture of the present invention.

Applications typically have predetermined destinations for their messages. For example Application running on a platform at location A has a regular need to send one type of message to a second application running on a different platform at location B and a different type of message to yet a different platform at location C. Using the architecture of the present invention a first service identifier e.g. Ser Id B points to all of the details required to send a message to the application at location B and a second service identifier e.g. Ser Id C is set up to point to the details needed to send a message to the application at location C.

When the Application needs to send a message to the application at location B it calls GTAPUT with a request block that specifies service identifier Ser Id B. Using the service identifier Ser Id B GTAPUT performs what is essentially a lookup in Directory in order to identify all of the parameters required by MQSeries to send the message. In this example supposing Application did not specify any overrides all of the parameters required to send the message are the default parameters found in the Directory for the service identifier Ser Id B. With all of the default parameters in hand the message is passed to the MQSeries which then transmits the outgoing message over the physical transmission means.

Other than the service identifier the request block from the Application can contain a block indicator which identifies if the message being sent is part of a block and a priority flag which indicates if a priority which is higher or lower than the default found in the directory should be used to send the message.

If an application has a requirement that different types of messages require different types of configurations such as priority and persistence then separate service identifiers exist for the different configurations. By adhering to this simplified architecture future changes to these configurations can be made by changes in the Directory without changing the code of the Application .

Furthermore in the example described above if there is change in the platform at either location B or C e.g. the platform changes to an AIX platform no change whatsoever is required to the Application . The changes required to accommodate the different platform are accomplished in Directory . Similarly if the receiving application to which Application send messages moves to a new location D only the Directory containing the messaging transport details is required to be changed. In either of the change scenarios just described Application A will still send a message using the exact same service identifier e.g. Ser Id B or Ser Id C and no changes to the Application are required.

GTAPUT is used by Applications to send messages asynchronously. This is a significant advantage over the prior art messaging systems which required that messaging occurred synchronously that is occurring at predetermined or regular intervals. One further significant advantage of the asynchronous messaging architecture of the present invention is that if such changes occur as described above all of the testing required to test the changes can be done without impacting other applications. For example if there is a change in Application it can send its messages asynchronously which can be received and processed by the receiving application when it is ready. In the prior art synchronous messaging systems both the sending and receiving applications had to be taken offline for such testing which resulted in significant costs associated with the testing. The asynchronous nature of the present invention avoids all of these costs associated with testing.

As shown in GTAPUT calls a directory services interface module GIDIRSVC to retrieve the configuration information related to the sending Application . This call is made using the service identifier specified by the Application in the request block. Since the Application may use GTAPUT many times to access different services the Application may need multiple service identifiers as described above.

In addition to the service identifier the sending Application specifies the sender application name and the sender subsystem to form a three part key to the Directory . The application name uniquely identifies the component of the application using messaging. For example the post trade component of a security movement and accounting system. The subsystem identifies the application system to which the component issuing the messaging function belongs. For example the security movement and accounting system. As described above the service identifier uniquely identifies the messaging service which an application component is requesting.

As will be further described below when an application is receiving a message it must similarly supply the receiver application name receiver subsystem and receiver service identifier in order to properly access the directory .

The Archive Q Open Option field indicates the mode in which the GTA messaging architecture should open the archive queue.

The Archive Queue field specifies the queue to which an exact copy of the message will be sent for archival purposes. The message will have the same GTA header and MQ Message ID as the original message. If archived on the sending side the term is Resend if archived on the receiving side the term is Replay.

The Archive Queue Manager field specifies the queue manager on which the archive queue is located. This field contains the default queue manager for the platform but can be specified as any remote queue manager.

The Destination Queue Open Option field indicates the mode in which the GTA messaging architecture should open the destination queue.

The Destination Queue field specifies the queue to which the message will be sent. This field is used in GTAPUT operations only and returned to the sending application through the return block.

The Destination Queue Manager field details the queue manager to which the message is being sent. The manager specified in this field must be set in conjunction with the destination queue.

In one embodiment of the present invention the Error Queue Messages field specifies the queue to which error messages are sent. Messages retrieved from a queue may exceed the memory allocated by the application for holding them. If this is the case the GTA messaging architecture indicates that a severe error has occurred and forwards the message to the error queue specified in this field. Likely settings include sending the message back to the queue it was received from the dead letter queue or an application specific error queue.

The Input Open Option field indicates the mode in which the GTA messaging architecture API should open the input queue.

The Input Queue field describes the queue which the GTAGET operation uses to retrieve incoming messages see below for GTAGET . As MQSeries only supports getting a message from the local queue manager no input queue manager needs to be defined.

The LUW Override Flag field indicates whether applications are allowed to override the logical unit of work LUW controls and put messages outside of the current LUW. Applications can specify in the request block whether or not the messaging operation should be included in the current logical unit of work.

The Message Format field is used to specify whether the message being put of type MQSTR or GTA VA. These types correspond to flat text data and binary data respectively. Valid settings for this field in the GTA directory service are 0 MQSTR format and 1 GTA VA format. This field is used within the architecture to populate the format field of the message header. The receiving application uses this field to determine whether the message should be converted upon retrieval.

The Message Persistence field indicates what persistence should be used when sending a message. Persistence regards what happens to messages on a queue when the queue manager is brought down. Persistent messages are logged and are guaranteed by MQSeries to not be lost in the case of the queue manager being brought down. Non persistent messages are not logged and are guaranteed by MQSeries to be removed from the queues when the queue manager is brought down. As a result of logging use of persistent messages incurs a performance impact.

The Message Priority field contains the default priority assigned to the message. Priority settings allow for certain messages to take precedence over others on prioritized queues. In a preferred embodiment all of the queues in the messaging architecture support priority messaging. The range of priorities supported by GTA messaging in a preferred embodiment is from 0 9. The range 5 7 is reserved for application messages with 5 being lower than normal 6 the default priority and 7 for high priority or urgent messages.

The field Native MQ Messaging Flag is used to determine whether a GTA message or native MQ message is being sent or retrieved. If native MQ messaging is turned off a GTA message with all GTA specific headers will be sent expected. Otherwise a message without any GTA specific information will be sent expected. Valid settings for this field are Y Native MQ messaging is turned on and N Native MQ messaging is turned off where GTA messaging will be used .

The Replay Archive Flag field indicates whether a copy of the message should be archived when it is retrieved. This is the standard archiving mechanism for GTAGET.

The Reply to Application Reply to Service and Reply to Subsystem fields dictate which directory entry the receiver must use when putting a reply. If the architecture uses distributed instead of centralized directory services it is necessary to pass the reply to information along with a message to ensure that the application receiving the application uses the correct directory entry when putting a reply message. The reply to application reply to service and reply to subsystem keys should be populated only when a response is necessary. If no response is required these fields are left blank. If these field are populated the receiving application assumes that a reply is required.

The Resend Archive Flag indicates whether the message should be archived on the sending side. This is the standard archiving used within GTAPUT . The archived message includes all of the same information found in the original message including the same message identifier. It will be put to the Archive Queue Manager Archive Queue.

The field Trace Flag indicates whether or not tracing is turned on for a given service identifier . Tracing messages can be sent to a centralized location to enable reconciliation processes to detect if messages are not being processed.

The Trace Persistence field indicates what persistence should be used when sending a tracing message. Persistence regards what happens to messages on a queue when the queue manager is brought down. Persistent messages are logged and are guaranteed by MQSeries to not be lost in the case of the queue manager being brought down. Non persistent messages are not logged and are guaranteed by MQSeries to be removed from the queues when the queue manager is brought down. As a result of logging use of persistent messages incurs a performance impact. Valid settings for Trace Persistence are 0 Not Persistent Default and 1 Persistent.

The Trace Priority field allows for certain messages to take precedence over others on prioritized queues. In a preferred embodiment all of the queues in the present messaging architecture support priority messaging. As previously stated in the preferred embodiment of the present invention the range of priorities supported by GTA messaging is from 0 9. The range 5 7 is reserved for application messages with 5 being lower than normal 6 the default priority and 7 for high priority or urgent messages. The default setting for trace messages is therefore 4 i.e. lower than all application messages.

The Trace Queue field describes the queue to which trace records should be sent for this application.

The Transport Method field describes the transport mechanism e.g. MQSeries should be used for the message.

The Wait Flag indicates when retrieving messages if application will wait for messages to arrive or whether it will exit immediately if the required message is not on the queue. The valid values for this entry are Y Wait for a message to arrive on the queue N Do not wait for a message to arrive on the queue.

Returning to based on the information retrieved from the Directory by the directory services module GIDIRSUC GTAPUT is ready to format the message for the chosen transport method. As previously described in a preferred embodiment of the present invention three different transport methods are supported GTA messaging using MQSeries native MQ messaging using MQSeries and FRQS messaging .

As previously described FRQS is a proprietary transport method developed in house by the assignee of the present invention. FRQS does not form any part of the present invention but a description of FRQS has been included herein to illustrate the operation of the present invention with transport mechanisms other than the MQSeries . If FRQS messaging is the chosen transport method a module FRQS PUT is called to put a message to the Transient Data Queue which puts the message in a Virtual Storage Access Method VSAM file . The receiving application then retrieves the message from the VSAM file .

If FRQS messaging is not selected the message will either be sent using GTA messaging or native MQ messaging . As previously described the difference between GTA messaging and native MQ messaging is that GTA messaging provides extra functionality not provided by the MQSeries e.g. block messaging . A GTA message or infrastructure message is defined as application data with GTA specific headers and trailers. A native MQ message contains application data only without any of the GTA specific headers or trailers. To support both types of messages the present invention uses configuration maintained within Directory to determine if native MQ messaging or GTA messaging should be used to send or retrieve a message. Therefore applications requiring the use of native MQ messaging must request a service through a service identifier which is configured appropriately to indicate the sending or retrieving of a native MQ message. Failure to use an appropriate service will result in the sending of a GTA message or an attempt to retrieve a GTA message ultimately causing an error.

GMASETUP performs the processing necessary to establish queue manager and local remote queue object connections. GMASETUP is used both for GTA messaging and for native MQ messaging. Supplied with the appropriate queue manager name and or queue object names from the Directory this module returns the queue manager handle and or the queue object handles as required by the calling application . The information is saved in a structure that can be referenced by subsequent modules. In an object oriented environment e.g. C GMASETUP connects the application to the queue manager and all associated local and remote queue objects request response trace audit and archive . Within CICS GMASETUP does not have to connect to the queue manager since the connection is kept open by CICS. However GMASETUP still has to open the queues that the application will use as specified as defaults in Directory . Outside of CICS GMASETUP has to connect to the appropriate queue manager and open the appropriate queues that the application will use.

For GTA messaging the GMASENDM module asynchronously sends at least one message to the request queue of a Message Processing Server to be described below . This module sets the appropriate MQ and GTA architecture options as specified from the retrieved Directory information fills in the GTA architecture header and MQMD MQ message descriptor for appropriate message processing and participates in logical units of work.

A message can be sent with a specific priority based on a value in the Directory which will override the default priority for messages on a queue. For block processing to be described below GMASENDM can accept a correlation ID or leverage the MQ layer to generate one. This correlation ID is kept in the CorrelID field in the MQ message header. A sequence number is used to populate the GTA architecture header block. This aids in the detection of messages missing from a block on the receiving side.

For native MQ messaging module GMASENDMQ is responsible for sending a native MQ messages. The module sets the appropriate MQMD header fields sends archive and trace messages if applicable and sends the application data using MQSeries . As with GMASENDM GMASENDMQ sends messages asynchronously. It sets the appropriate options to include or exclude the message in an logical unit of work LUW . The appropriate priority and persistence values are set based on the value passed by the calling application typically from the default values obtained from the Directory . GMASENDMQ appends the architecture header prior to sending the message. GMASENDMQ also creates archive and trace record provided the appropriate options are set.

Schematically illustrated in are the Destination Queue the Archival Queue and the Trace Audit Queue . Each of these queues are managed by the MQSeries . The Destination Queue represents the queue at the message receiving location. The Archival Queue is a queue used for archiving messages and the Trace Queue is used for tracing the transmission of messages both of which will be described in more detail below.

Once a receiving Application becomes aware of an arriving message the receiving Application then uses GTAGET to receive the message . As with sending of messages using GTAPUT the receiving Application calls GTAGET and passes a message buffer and parameters including the requested service identifier. GTAGET uses the passed parameters to perform a look up in Directory for the configuration settings based on the application name the subsystem identification and the service identification. GTAGET retrieves from the Directory which queue to check. GTAGET then retrieves the message from the appropriate queue and returns it to the Application and according to the settings in the Directory generates trace and archive messages. The Directory contains the destination queues for the trace and archive records.

As with GTAPUT GTAGET is used to retrieve messages sent asynchronously. GTAGET can be configured within its Directory to wait for a message to arrive. As previously described the Directory utilizes flag and valid time out intervals for GTAGET .

As also described with respect to messages can be passed either through GTA messaging or native MQ messaging. If GTA messaging has been used indicated by a flag in the Directory the directory services module GIDIRSVC calls module GMARCVM . GMARCVM retrieves the next message from the queue specified in the Directory for the identified service identifier. If the Directory indicates that archival or trace records are required GMASENDM is called to send these archive and trace messages to their respective queues .

GMARCVM examines the header of the message to determine whether or not the message is part of a block of messages and if so whether it is the first intermediate or last message of the block. This information is passed back to the Application along with the message data. If it is a broken block GMARCVM returns the appropriate error to the calling program. When retrieving messages from the queue the module GMARCVM allocates a dynamic storage area based on passed in size of the expected message.

If the Directory indicates the message to be received has been sent using native MQ messaging the directory services module GIDIRSVC calls module GMARCVMQ . Upon being called module GMARCVMQ sets the appropriate return block fields based on the header of the message sends archive and trace messages if applicable see and returns the message data to the Application .

If the retrieved message requires a response GTAGET provides the receiving Application a reply to service identifier and reply to application identifier which is used by the receiving Application when sending the response. This reply to service identifier enables the messaging architecture to identify the routing required for the response message through the use of directory . In a preferred embodiment the present invention does not force the receiving Application to generate a reply even if the sending Application has requested one. If the receiving Application does generate a reply message it can specify a correlation identifier equal to the unique message identifier of the request message when sending the response.

As previously described the present invention provides for two different type of messaging using the MQSeries native MQ messaging and GTA messaging. Native MQ messaging directly employs the MQSeries with out any additional functionality. GTA messaging provides an additional layer of functionality on top of the functions provided by the MQSeries. GTA Messaging provides a framework within which access to these additional services can be facilitated. A service is a common function provided for applications. For GTA Messaging the types of services provided include but are not limited to dynamic reformatting of messages content based routing persistent archiving auditing reconciliation and multicasting as well as any application specific services. Some of these services are directly provided for in the architecture of the present invention while access to other services e.g. vendor provided is facilitated by the architecture of the present invention.

GTA Messaging according the present invention provides a flexible server based approached to provide additional services to applications. These additional services are performed on the application s message by Message Processing Servers MPSs . illustrates the operation of a multicasting MPS .

The servers use the previously described APIs GTAPUT and GTAGET for the respective sending and receiving of messages. These APIs and provide both a common message interface for MPS servers and the necessary technical processing to support the message tracing and archiving facilities. In addition as previously described the GTA Messaging APIs are configuration driven through the Directory and allow for the servers to be insulated from the technical complexity of message queuing.

An encapsulation function is provided for the use of these servers to pass the context information of a message from the message received to the message s sent . Context information refers to fields set by a sending application which need to be associated with the messages when they are received by the destination application e.g. correlation and functional message identifiers.

By providing services to applications within separate MPSs additional services are added for applications by creating new servers . If an application wants to take advantage of a new service e.g. multicasting as illustrated in and described below in more detail the Directory configuration can be changed to route messages to the new MPS which performs the multicasting. Since all servers use the same message queue interface through GTA Messaging i.e. GTAPUT and GTAGET no changes need to be made to the existing application code.

In the multicasting example depicted in a mainframe application which is currently messaging to a single partner mainframe application may require to send the same information to a new application on an AIX machine. By using GTA Messaging the configuration information in Directory is updated such that the application sends the message via GTAPUT and MQSeries to multicast MPS which sends one copy of the message to the existing mainframe application and another copy of the message to the new AIX application. The multicasting MPS uses GTAGET and GTAPUT as previously described in order to receive the message and send the messages and . The actual implementation of the multicasting MPS can be accomplished in a number of ways. For example a two different Directories can be established one for gets and one for puts. In this embodiment a single service identifier can be used by GTAGET to retrieve the single message. In retrieving the single message the GTAGET Directory entries for the single service identifier also retrieves two service identifiers which are used by GTAPUT to retrieve the transport details for the two separate messages which are to be sent. Alternatively the GTAGET can retrieve a single service identifier which is used by GTAPUT to simultaneously retrieve all of the transport details for the two messages. In an alternative embodiment as depicted in both GTAGET and GTAPUT share a single Directory .

Furthermore if the new application required a different format message from the existing message being sent the message sent to AIX could first be sent through the reformatting engine in a different MPS not shown in and then forwarded on to the new AIX application. additionally shows trace records being recorded for each transmission of a message by MQSeries .

In this example no changes are required to any of the applications or the partner application or the new AIX application since all of the necessary routing information is maintained within the Directory and all of the necessary message processing i.e. multicasting and reformatting is performed by servers within GTA Messaging. The only application development required would be the reformatting rules to get from the message format of the mainframe to that of the new AIX application.

As mentioned earlier the GTA Messaging APIs GTAPUT and GTAGET provide message routing configured by a Directory . The directory lookups are based on the application calling the API and the parameters passed. For example within a GTAPUT call the entries in Directory controls message processing such as the immediate destination of the message which can be either a partner application or an intermediary messaging service Tracing and Reconciliation in which trace messages are be sent within the APIs to a central reconciliation facility to enable tracing the path of an application s message and Archiving in which exact copies of the message being sent can be forwarded to an archiving location where it can be offloaded and stored.

The Directory entries accessed by GTAGET provide similar configuration. Instead of the destination the Directory entries for GTAGET controls the location from which the message is to be retrieved e.g. which queue as well as a time out value. Archiving and tracing is also configurable although the message archived is the message received and the trace message may contain slightly different information.

An MPS either performs application services to the message itself e.g. reformatting or can be used to track important operational and statistical information on behalf of the application e.g. reconciliation and tracing.

As described above MPS servers use GTA Messaging e.g. GTAPUT and GTAGET as a common interface. Through configuration within the GTA Directory messages can be routed to any MPS to provide its service for an application. With this approach additional functionality can be added transparently to messaging applications by adding configuration entries in the Directory to route messages to the appropriate MPS . This architecture of the present invention facilitates a phased approach to developing functionality within separate MPS servers allowing services to be developed as they are required by applications.

By using the GTA Messaging APIs e.g. GTAPUT and GTAGET MPS servers have a common messaging interface and all of the processing available within the GTA Messaging APIs. Of particular value are the archiving and tracing functions. Through configuration via the Directory the GTA Messaging APIs are able send additional archive and trace messages. Archiving of the messages retrieved and sent by a particular MPS server helps facilitate testing and debugging. Enabling tracing at an MPS server helps troubleshooting and determining the status of an in flight message.

In addition to the above described multicasting service other services provided by MPSs include but are not limited to dynamic message reformatting dynamic content based routing archiving storage of copies of messages sent or received tracing and reconciliation detecting if messages sent are not delivered in a timely fashion and providing statistical information based on the message trace and audit records. Any messaging service which multiple applications share would be well suited to being implemented as an MPS . The architecture of using an MPS of the present invention provides system developers administrators with significant flexibility previously unknown. The buy build decisions constantly faced by such people is rendered less daunting as vendor products are more easily bound into the architecture primarily due to the use of Directories by the present invention. The vast majority of the details required to interface with a vendor product are simply coded into the Directories with little change required to existing applications. As the vendor product is upgraded typically only changes are required to the Directories and not to the applications which use the vendor product.

In a preferred embodiment a Message Storage MPS incorporates a Relational Database Management System RDBMS schema to store messages. A Message Store MPS is used for retrieving archive messages sent from within the GTA Messaging APIs and uploading them to the RDBMS.

Archiving is a service performed by an Message Storage MPS which allows the resending or replaying of messages. Resending of a message entails reissuing a GTAPUT call for a message already successfully sent such that any services applied to the first message e.g. multicasting and reformatting will be reapplied to the archive copy of the message. This allows for messages sent to be easily reprocessed if an error occurred downstream of the GTAPUT . For example if the reformatting rules were incorrect and a message needed to be passed through the reformatting engine another MPS again the message could be resent from the archives to the reformatting MPS and reprocessed.

Archiving occurring at the GTAGET allows for messages to be redelivered or replayed to the receiving application. In this case the message is not reprocessed by the architecture and is delivered in the same manner as the original message received by the application. This allows for an application which had an error to rollback its processing and reprocess previously received data. This facility is useful in environments where the same data needs to be reprocessed e.g. testing a development application or server.

The storage of the messages can be configured based on application requirements. By enabling archiving within the GTA Messaging API Directories a copy of the message processed by the API will be sent to an archive queue. The Message Store MPS provides a mechanism to offload messages from this archive queue. This allows access to both architecture and application components of the message including portions of the message headers and the entire application data. The information stored is at a minimum the amount necessary to retransmit the message from the archives. The use of an RDBMS structure for the storage of messages allows for applying existing querying tools to a message store database.

In an alternative embodiment applications which are unwilling or unable to invest in an RDBMS storage facility for messages may keep messages on the local archive queue and replay resend them using a provided GUI queue utility. The number of messages stored on the queue is limited by the application s system DASD restrictions.

Message tracing and reconciliation are two important services which can be performed by an MPS. To support reconciliation and tracing the GTA Messaging API is configured to send trace messages which detail the message which was processed as well as information about where it came from and where it is destined for. A Message Tracing MPS retrieves these messages and uploads them to a Message Tracing RDBMS.

The schema of the Message Tracing RDBMS is such that reconciliation can be performed to check if a message sent by an application is still being processed by the architecture and how long it has been in flight . The same schema also allows tracing the path a given message took and the services which were performed on it.

The trace messages sent to a Reconciliation MPS can still be examined after a message has been successfully reconciled as they are not purged. Queries may be run against the Message Tracing RDBMS using standard Structured Query Language SQL . These queries can identify the end to end path of any message with tracing enabled since all of the individual traces of the message are associated together by a unique identifier.

Reconciliation within the present architecture detects if messages are dropped by the messaging architecture and also detects if an application does not receive messages that have been sent. In one embodiment reconciliation can further determine if the message has been received in an acceptable amount of time. If not reconciliation can alert the sending application that the message has not been received. Reconciliation does not examine application data content and does not provide application end of day counts of messages processed. Instead the reconciliation function determines which messages have been reconciled and when they were reconciled. As described above based on the application sending the message and the services it requested the GTA messaging architecture can determine which messages have been outstanding too long and can send architecture messages to indicate that there is an error to be remedied.

These architecture messages are handled in a default manner by most applications. Special handlers process the trace and archive messages and can if desired perform actions such as sending alerts and writing logfiles. Applications requiring specific processing can have these architecture messages forwarded to any queue and process them with a custom handler.

To perform statistical auditing the trace information stored within the Message Tracing RDBMS can be summarized and stored in historical tables to support statistical auditing. Applications using an RDBMS for archiving can also summarize message statistics such as message length. These tables can then be queried using report and analysis tools to provide sophisticated performance and messaging usage reports.

Reformatting is an ideal service which can be performed by an MPS. Reformatting is a process by which a message is converted from one format e.g. a mainframe format to a different format e.g. AIX . A Reformatting MPS allows messages to be processed by dynamic content based reformatting rules defined by applications. A Reformatting MPS using GTA Messaging APIs supports reformatting a single message into one or more output messages while passing the context information of the first message.

Dynamic reformatting is an important component of the present architecture as a whole. It facilitates application isolation and allows messaging partners to pass messages without knowing the specific message format requirements of each other. These message formats are preferably stored in a repository in a Reformatting MPS and updated outside of the application s code when one of the messaging partners changes its message format.

Content Based Routing is another important service provided by an MPS. Such an MPS allows applications to define routing rules based upon the content of message. By defining in the Content Based Routing MPS the format of the input message applications could place specific routing information within the data fields contained in the message.

The multicast MPS uses GTAGET to retrieve the incoming message from the MQSeries message queue. As described above the arrival of the message is triggered to the MPS or the MPS actively polls MQSeries in order to see if any new messages have arrived. Using the service identifier contained in the message Multicast MPS calls GTAPUT which in turn does a look up in Directory . The Directory entry associated with the service identifier indicates that the message has to be sent to the three applications B C and D . Since the message needs to reformatted prior to being delivered to applications B and C the routing details contained in Directory with respect to these destination applications accordingly point to the reformatting MPS .

With respect to the sending of the message to application D GTAPUT calls MQSeries which sends message to the MQSeries connected to Application D . As previously described application D calls GTAGET using directory in order to retrieve message from the MQSeries . The message is essentially an exact copy of the message originally sent by the sending application since the message did not have to go through any reformatting.

With respect to the transmission of the message to applications B and C MQSeries is invoked by the multicast MPS through GTAPUT using directory and a message is sent to the destination queue in the MQSeries attached to the reformatting MPS . In this embodiment depicted in the directory in reformatting MPS is configured such that the service identifier specified in the message will cause the reformatting MPS to reformat the single incoming message twice once for application B and once for application C . In an alternative embodiment multicast MPS can send two separate messages to reformatting MPS one containing a service identifier for application B and a separate message containing a service identifier associated with application C .

Reformatting MPS calls GTAGET to retrieve the incoming message from the MQSeries queue. Using instructions found in a control block passed through from the original message from application A the reformatting MPS knows the format s in which the message should be formatted as required by applications B and C . In a preferred embodiment a single reformatting MPS is capable of performing reformatting operations into several different formats. In the example depicted in Application B could require that the message appear in one format while Application C requires the message in a totally different format.

After the reformatting MPS has formatted the message for each of the formats required by Application B and Application C it calls GTAPUT in order to actually transmit the messages. As previously described MPS can make two separate calls to GTAPUT each one with the appropriate service identifier required to send the message respectively to Applications B and C . Alternatively a single service identifier in Directory can be used by MPS through GTAPUT which simultaneously identifies the destinations as Applications B and C . Again using the lookup in Directory GTAPUT retrieves the parameters required to be passed to the transport layer to actually transmit the messages .

In the message destined for Application B is transmitted using the MQSeries . In contrast the transport layer which transmits the message destined for Application C has been designated as OTHER. This designation is to indicate that the architecture of the present invention can be customized to accommodate any reasonable transport layer.

Once the messages reach the input queues of the transport layers attached to the respective Applications B and C the applications and call GTAGET in order to retrieve the messages.

As briefly described above the GTA messaging architecture of the present invention supports the transmittal of blocks of messages. Block messaging refers to a set of messages which are delivered in the same order they were sent with no messages interspersed which do not belong to the block. This function is not support by native MQ messaging. Applications requiring the use of native MQ messaging will not have the ability to send and retrieve blocks of native MQ messages.

In one embodiment of the present invention denoted as block single the messages belonging to the block are internally blocked together into a single MQSeries message. The block may be named with an identifier provided by the sending application. This identifier may be for descriptive purposes only i.e. a functional identifier or may be used to by the receiving application to retrieve a specific block of messages from its input queue by using a correlation identifier. In an alternative embodiment denoted as block multiple a block is broken up into several MQSeries messages. In this embodiment a copy of the message ID of the first message in the block is copied into the correlation ID of the subsequent MQSeries messages forming the block. When sending messages it is the responsibility of the sending application to identify that it is sending a block of messages. It must identify which is the first message of the block the last message of the block and send the messages in the sequence they should be received. The sending application does not have to provide a meaningful identifier to tie the block together.

In the block single embodiment the architecture does not send the block of messages to the queue until all of the messages belonging to the block have been supplied by the application. When the last message of the block is provided the architecture creates a single infrastructure message which it sends to the queue. All block messaging must be committed within a logical unit of work. If a message belonging to the block can not be sent to the GTA messaging architecture the entire message should be rolled back.

When receiving messages an application is informed whether or not the message is the beginning of a block. This is provided for informational purposes so that the application can initiate the appropriate application processing. Subsequent GTAGETs will return the messages to the receiving application in the same order they were put. It is transparent to the receiving application whether the individual messages are being retrieved from an MQSeries queue or are segments of a larger block message.

Although the present invention has been described in relation to particular embodiments thereof many other variations and other uses will be apparent to those skilled in the art. It is preferred therefore that the present invention be limited not by the specific disclosure herein but only by the gist and scope of the disclosure.

