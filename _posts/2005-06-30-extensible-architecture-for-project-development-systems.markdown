---

title: Extensible architecture for project development systems
abstract: A software-development system or versioning system has a collection of modules for performing individual development functions such as document editing, keyword processing, and private-copy management. Each module has an interface compatible with that of the others, so that modules can be added to or substituted for the original modules, if the new modules conform to the interface. The architecture of this system supports the performance of development actions such as document merging and keyword expansion at any location within the system. The system operates upon documents and files as objects in an object space, rather than in name spaces.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07631298&OS=07631298&RS=07631298
owner: Microsoft Corporation
number: 07631298
owner_city: Redmond
owner_country: US
publication_date: 20050630
---
This application is a continuation of U.S. patent application Ser. No. 09 717 537 filed on Nov. 21 2000 now U.S. Pat. No. 6 915 507 entitled Extensible Architecture for Project Development Systems. 

The present invention relates to electronic data processing and more particularly concerns a system architecture for managing many documents or files that may assume different versions over the life of a project such as computer program development.

Complex projects of any kind involve the cooperation of large numbers of individuals and groups working on even larger numbers of interdependent items. In particular the development of application programs operating systems and other computer software commonly involves hundreds or thousands of people and documents numbering several orders of magnitude higher over time periods of months and years.

A major part of managing large projects concerns systems for controlling different versions of versioned items documents and files. In program development a source code control system typically includes several pieces almost always including a storage that provides efficient versioned storage of files a differencing merging engine for combining different versions of the same file modules for operating upon multiple file formats such as text and graphics documents and user interfaces for various parts of the system including those for differencing and merging.

To integrate heterogeneous control systems into a useful development tool requires an architecture for integrating the many individual parts with a high degree of concinnity. The organizing force of a software architecture resides in the interfaces among the parts of the overall system. Interfaces are commonly implemented as application program interfaces APIs . Traditional integration efforts coped with the depth and diversity of available source control systems by defining a high level API that abstracts both storage operations and user interfaces. For example Microsoft Corp. integrated these functions into its own development tools using an interface called MSSCCI Microsoft Source Code Control Interface . This interface proved inflexible provided a limited model of the underlying data and was unable to solve a broad range of important problems. This interface cannot mix pieces from different providers for performing other functions or for performing existing functions in a different manner. Its design was not future proof.

Another problem with traditional integration APIs is that they are based upon server namespaces. That is an object is referred to by its path name and file name on the server that stores the files under development. This makes it hard to rename files. The API cannot determine that a reference to a file called New refers to the same file that had been called Old . This was a problem even when all that was stored was source code and traditional systems often disallowed name changes altogether. However newer systems based on the World Wide Web require the names of objects to change often.

Existing development APIs have also been limited in their support for different kinds of files. They abstract the calculation of differences and merges as part of the storage. The types of files understood were bound into the products and could not be extended by third parties so as to create new file formats. This problem becomes more important as Web based systems grow in popularity. The Web employs many types of files and no single system can address all of these formats now or in the future. For Web style projects namespaces are a primary element of the software system. Moreover traditional integration APIs provide no semantic support for parallel development. Users must manage their own copies of different versions of their projects.

The MSSCCI architecture mentioned above is widely supported in the software development industry despite the fact that it remains a private interface without any formal standard. This and other available interfaces only support a small portion of the typical source code control functions. They are not extensible to additional functions or formats and they cannot be combined in mix and match combinations. Other current efforts address APIs and protocols for communicating with version stores mechanisms for holding multiple versions of documents and files. None of the conventional systems provide a deep or consistent way for substituting third party differencing and merging technologies into the versioned environment. This lack of any extensible architecture has hindered the development of versioning especially for document management where file formats are diverse and numerous and where designers seldom work together with the organizations that produce version stores. Although some existing systems provide core support for object based rather than namespace based storage they do not expose this capability deeply within their organization if they have any extensibility at all.

The present invention offers an architecture for extensible systems for managing projects having many individual versioned items. Because the described embodiments relate to software development projects the items will be referred to as documents or synonymously as files. 

Systems constructed according to the present architecture include a collection of modules for providing individual development services or functions. A client module processes user data and commands and coordinates the operation of the service provider modules. The term user herein refers broadly to a person or to another program or system of any kind that can initiate commands to the client module.

Each module has a mutually compatible interface. Thus modules not in the original system can be added or substituted for one or more of the original modules as long as all of them are compatible with the same system wide interface. Each of the elements of the system can be individually replaced or extended and the architecture supports the performance of functions at any place in its environment. Further the interface operates upon documents and files as objects in an object space rather than in one or more name spaces. A version store for the documents communicates with at least some of the service providers and can optionally be implemented as a database.

The architecture can implement the set of interfaces as an application program interfaces API that the client and the service providers all employ although other implementations are possible. Part or all of the API can be built specifically for use in this architecture or it can be adapted from other environments.

Aspects of the invention include a development client program a number of development service providers and a version store for holding development documents. The client receives commands from a user and passes them over its interface to compatible interfaces architected in the service providers. The multiple development service providers each have code for performing a development function and an interface that is compatible with all the other service providers so that they can be individually plugged into and unplugged from the system in any combination. A merge subsystem has in addition to a merge engine a merge broker for selecting among a number of selectable preprocessor modules and optionally also has multiple postprocessors. A keyword expansion subsystem has a keyword broker for selecting among multiple keyword expansion modules for different domains of keywords in different documents.

This description and the accompanying drawing illustrate specific examples of embodiments in which the present invention can be practiced in sufficient detail to allow those skilled in the art to understand and practice the invention. Other embodiments including logical electrical and mechanical variations are within the skill of the art. Skilled artisans will also recognize features and advantages of the invention other than those explicitly set forth. The scope of the invention is to be defined only by the appended claims and not by the specific embodiments described below.

In the following description Section 1 presents illustrative computer hardware and software environments capable of hosting the invention. This section includes an overview of an API that can be employed in implementing the invention. Section 2 describes an architecture of a software development system organized according to the invention. Section 3 further details a number of development service providers having novel features in connection with the invention.

Hardware components are shown as a conventional personal computer PC including a number of components coupled together by one or more system buses for carrying instructions data and control signals. These buses may assume a number of forms such as the conventional ISA PCI and AGP buses. Some or all of the units coupled to a bus can act as a bus master for initiating transfers to other units. Processing unit may have one or more microprocessors driven by system clock and coupled to one or more buses by controllers . Internal memory system supplies instructions and data to processing unit . High speed RAM stores any or all of the elements of software . ROM commonly stores basic input output system BIOS software for starting PC and for controlling low level operations among its components. Bulk storage subsystem stores one or more elements of software . Hard disk drive stores software in a nonvolatile form. Drives read and write software on removable media such as magnetic diskette and optical disc . Other technologies for bulk storage are also known in the art. Adapters couple the storage devices to system buses and sometimes to each other directly. Other hardware units and adapters indicated generally at may perform specialized functions such as data encryption signal processing and the like under the control of the processor or another unit on the buses.

Input output I O subsystem has a number of specialized adapters for connecting PC to external devices for interfacing with a user. A monitor creates a visual display of graphic data in any of several known forms. Speakers output audio data that may arrive at an adapter as digital wave samples musical instrument digital interface MIDI streams or other formats. Keyboard accepts keystrokes from the user. A mouse or other pointing device indicates where a user action is to occur. Block represents other input and or output devices such as a small camera or microphone for converting video and audio input signals into digital data. Other input and output devices such as printers and scanners commonly connect to standardized ports . These ports include parallel serial SCSI USB FireWire and other conventional forms.

Personal computers frequently connect to other computers in networks. For example local area network LAN connect PC to other PCs and or to remote servers through a network adapter in PC using a standard protocol such as Ethernet or token ring. Although shows a physical cable for interconnecting the LAN wireless optical and other technologies are also available. Other networks such as wide area network WAN can also interconnect PCs and and even servers to remote computers . Computers and have processors storage and communications equipment similar to those of PC although usually of higher capacity. illustrates a communications facility such as a public switched telephone network for a WAN such as an intranet or the internet. PC can employ an internal or external modem coupled to serial port . Other technologies such as packet switching ISDN ATM DSL frame relay are also available. In a networked or distributed computing environment some of the software may be stored on the other peer PCs or on computers and each of which has its own storage devices and media.

Software elements may be divided into a number of types whose designations overlap to some degree. For example the previously mentioned BIOS sometimes includes high level routines or programs which might also be classified as part of an operating system OS in other settings. The major purpose of OS is to provide a software environment for executing application programs and for managing the resources of system . An OS such as Windows or Windows NT from Microsoft Corp. commonly includes high level application program interfaces APIs file systems communications protocols input output data conversions and other functions.

Application programs perform more direct functions for the user. A user normally calls them explicitly although they can execute implicitly in connection with other applications or by association with particular data files or types. Modules are packages of executable instructions and data which may perform functions for OSs or for applications . Dynamic link libraries .DLL and class definitions for instance supply functions to one or more programs. Data includes user data of all types data generated and or stored by programs and digital data that third parties make available on media or by download for use in computer . Software elements can be embodied as representations of program instructions and data in a number of physical media such as memory non volatile storage and signals on buses etc.

Application programming interfaces APIs frequently serve as interfaces in software systems and are symbolized by the small ellipses in . An API is a contract between two or more independent pieces of software. This contract takes the form of a protocol between the pieces. The protocol specifies what functions may be requested by one piece from another piece. It specifies a format for transmission of the request which might include commands parameters and other data and a format for the return of any results or errors from the request. APIs can be implemented in a number of ways including machine code addresses static libraries DLL dynamic link library entry points COM component object model interfaces textual command languages or any mixture of these modalities. Any software model or object model that is capable of describing the contract between two programs objects or other software is capable of representing an API. Additionally an API can be expressed in a completely non software related fashion for example as a set of imperative recipes expressed in a language such as English. APIs are frequently defined in an abstract interface definition language IDL and in related documentation.

An API generally offers an entire set of functions that are called individually. An API contract can however have optional features. That is a software module might not implement all of the functions of the entire API definition because it cannot perform some of the functions of the full API because it does not need to invoke certain functions or for other reasons. Such subsetting of an API provides a convenient way to allow diversity in the contracting software modules and allows some participants in an API contract to have more limited participation than other participants in the same contract while still remaining compatible with them. A module is compatible with an API or other interface if it conforms to those of the interface definitions in the set that it needs in order to communicate data that that module processes or communicates to and from other modules in the system. An API definition can state explicitly that some of its parts are required for every module that uses it while other parts are optional providing additional functionality for those modules that choose to use them.

The OLE DB API implements an overall interface between a data provider and a data consumer . Both of these are software that manages certain types of data. A data provider directly exposes data to the consumer via the interfaces. Other providers provide services such as query processing and do not themselves expose data. In general a data store acting as a data provider need not necessarily support or expose all of the OLE DB interfaces although it must of course support the native functions of the data types that it manages. A data consumer can choose any desired level of interoperability with specific data providers and can sometimes even consume more than the provider itself supports if a service provider having the missing functionality is available. A consumer can query a provider to determine its capabilities.

A binder is an OLE DB object that binds resources named in a URL universal resource locator to an OLE DB object. Binding involves associating a column of a row set or a parameter of a command with a variable a binding denotes the association itself or a structure that describes the association. Patent application Ser. No. 09 717 533 now issued as U.S. Pat. No. 6 842 904 also describes binders. Root binder is an object that oversees the direct binding process. It maps bind requests to particular data providers such as . Provider binder is an object that performs direct binding operations on the URL namespace for which it is registered. It creates particular objects based upon the URL specified in the bind request.

An OLE DB enumerator is an object that retrieves information concerning a provider that is available on the system. In the Windows operating systems from Microsoft Corp. much of this information is contained in a registry and can be accessed thence directly if desired. However an enumerator abstracts the source of the information from an application making it reachable regardless of where it is actually kept. Enumerator obtains a particular data source object named in a bind request to provider . A data source object connects to a data store such as a database file or document that a user wishes to access. Sessions can then be created against the data source. A session is an individual connection that persist over a time until it is explicitly closed. Particular requests during a session can obtain commands rowsets and rows . A command in a data manipulation language issued during a session can obtain one or more rowsets. Rowsets can be used to navigate to a single row or to a data stream . A rowset in OLE DB as in relational database parlance in general is an object that contains one or more rows each having columns of data that satisfy a criterion in a query or other request. A row is a set of related columns that describe a specific entity. A data stream is data that encapsulates arbitrary data and may contain a document a file or other data in any format or in none. Rowsets can be used to navigate to a particular row and then to a stream containing e.g. a document.

The embodiment described below implements a versioning API VAPI within the OLE DB framework. The use of a database framework such as OLE DB as a foundation for a versioning system has several advantages. Version files are commonly written in the format of documents. Such development documents commonly represent source code in high level programming languages header files containing information about the programs under development and their relationships to each other assembly code executable binary code interfaces and their definitions libraries relational data and schemata components interfaces forms program manifests registry structures and contents web pages scripts forms images sound files metadata and other kinds of data. The present invention however is entirely agnostic as to types and can accommodate any kind of document or file type. OLE DB supports the concept of a document as an object that it can manipulate. It includes facilities for tagging them as to type so that the appropriate programs for processing them can be selected. Adding semantics for the additional processes required for versioning does not involve any distortions of the underlying mechanisms of OLE DB. Abstractions such as enumerators data sources and sessions in OLE DB can be mapped in a direct manner to services required from a versioning provider. OLE DB has a well defined set of services for locating rows and documents and for performing queries and returning arbitrarily large results. Other database systems as well have some of these attributes and would also be candidates for constructing a versioning system according to the present invention.

Past versioning systems store and retrieve documents as files having names and paths in directory trees in particular computers. In some settings such as the World Wide Web names change frequently and namespace based retrieval can often fail to find a desired document. In this embodiment documents are stored in a database which permits retrieval with queries designating characteristics that can be associated with the documents in a database row or other mechanism. Accordingly each document in the system is given a unique object identifier. The path and name of the document are also associated with the document thus allowing retrieval either by unique identifier or by namespace based file names. Because the OLE DB based VAPI operates in a fundamental way upon the database paradigm any VAPI function has the ability to query a document by any defined characteristic such as its name even though the actual file system name or server namespace might have changed in the meanwhile. When users make isolated changes to an object such as renaming it they are still able to refer unambiguously to the appropriate object because the VAPI provides names and abstractions for their isolated changes. Thus documents in the invention can be namespace neutral in a deep manner throughout every part of the versioning system.

Versioning systems also limit the types of documents that they support and do. not offer extensibility to other types in a simple or natural manner. Because the present system employs a database paradigm at its core rather than a file system model a document can be treated as an encapsulated black box or blob whose contents are irrelevant to any function that needs only to handle it as an entity. The type of the document is encoded as a characteristic associated with the document. When an API function retrieves a document and its associated characteristics the document type can be interrogated and appropriate action taken such as routing the document to an editor that understands that type of document. If a function desires to retrieve only a certain document type then that type can be specified in a query. New document types can be added merely by assigning them additional codes in a particular field or column of a database row associated with the document. The ability to handle new types of documents at the system level becomes important in World Wide Web development where file types proliferate for different kinds of data.

Moreover a database model for the VAPI allows further document characteristics to be enrolled as new columns or fields in the records or rows associated with the documents.

Client interacts via versioning interface VAPI with multiple individual providers of versioning services. Interface is a collection of individual API methods largely taken from the publicly available Microsoft OLE DB interface plus methods added specifically for versioning functions. This interface forms the entire set of interactions between client and all of the versioning service providers . Alternatively interface could be fashioned from some other existing collection of API methods could be constructed exclusively for this purpose or could be implemented in a form other than an API. The important point is that the contract provided by the interface can be understood and followed by the client and by all the service providers at least to the extent necessary to communicate commands and data to other modules in the same system. That is the interface can in some cases be subsetted and still remain compatible.

Individual ones of the providers such as offer query processing enlistment management defined below in conjunction with and other conventional versioning functions. Some or all of the providers communicate with a version store that holds documents and or other objects that constitute the entity being developed by the overall system for storing and retrieving the documents. Although shows only one store architecture permits multiple version stores within the same system all having the same interface and thus able to communicate with any other block in the system. The data store can also offer some common services indicated at to providers and to client if desired. Direct providers such as and communicate with version store via a conventional interfaces although it is possible that they could use the VAPI interface instead. Direct providers map requests from the client such as get and check in onto operations against the version store for storing retrieving and otherwise manipulating documents in response to user requests. Enlistment manager providers communicate with one or more enlistment stores these can be physically part of a version store or separate stores in a server or in other computers.

The invention thus employs a single interface among all service providers and the client. In this embodiment that interface is a collection of interface operations from the OLE DB standard. Therefore a provider such as that performs query processing can be unplugged from system and replaced by a completely different processor that offers the same set of services more query services or different query services merely by registering an enumerator for the new provider. Third party vendors can offer versioning services of new kinds by constructing the interfaces of their providers to be compatible with the single VAPI . Not all providers need recognize the entire VAPI set of interface operations. Provider for example might provide only limited operations that do not require all of the methods of the full interface such as file branching or labeling. Its VAPI is shown in dashed outline to indicate that it does not provide the full interface. While the interface methods that it does provide are the same as those of the full interfaces it does not provide the entire set of these methods.

Third party developers can write shells for provider that differ from the shells originally offered with the providers. Such shells might have different user dynamics additional or modified functions customizations for particular users and similar features. Object model can be supplied with the system to provide an API aimed at less sophisticated users for developing their own application programs and tools. Alternatively tools can be written directly to VAPI .

Versioning systems typically have separate components that provide services such as document editors for creating and modifying individual documents query processors for locating documents and merge engines for combining documents. The present invention accommodates service providers of conventional types if they are constructed according to the architecture described above. In addition however the extensible architecture permits third party providers to offer entirely new functions as well.

Any system that supports parallel development by multiple groups of people requires a merge service for combining multiple documents while identifying and or resolving any conflicts among them. This function is also called differencing and these terms are used interchangeably. In the present architecture conflicts can occur anywhere within the system. Efficiency often dictates that a merge should be performed at different locations in the system. Thus for example a merge could take place in a versioning store in a service provider or within the client itself. However merging at multiple places within the system can only happen in an extensible architecture that is neutral as to merge location. The present architecture abstracts both the type of merging that takes place and the time and location of the merge operation.

A merge returns a blob or arbitrary lump of data representing the merge results. The result document is typed to indicate which merge algorithm created it. One of several type specific user interfaces can then be selected for displaying the results to a user for conflict resolution if necessary. Even though the content of the result is opaque to the particular system component where the merge occurred and to the version store where the document resides the single interface architecture of the present system permits any component to route the document to a standard or custom plug in merge engine that understands the file format of the document and the information within it.

Upon invocation of a merge operation broker receives specifications of the documents to be merged and optionally a desired format for the output merged document. The broker determines an overall merge plan or strategy including which preprocessor to run which merge engine to employ and which postprocessor to run. In the high function development systems contemplated multiple preprocessors might be required in order to convert documents in many different formats to those accepted by a desired merge engine enhanced merging capabilities might require different engines and processing different output formats and keyword sets can require different postprocessors. The plan might invoke multiple components of the same type such as multiple preprocessors say to convert the formats of two different input documents to yet a third format for a merge engine that accepts neither of the input formats. After selecting the participants the broker orchestrates the execution of the merge plan. The standard interface set object attributes and types provided by the invention allow these components to be mixed and matched in any desired combination.

The architecture of merge subsystem 312600 supports the notion of a collection of merge blobs. Documents used with the invention can be explicitly typed as mentioned earlier. A single document might carry complex information having multiple types for example both content and properties . Changes to a file during a merge could produce conflicts both in the content of the merge result and in its properties. Thus a merge collection can contain both a content merge blob and a property merge blob . Complex types can be returned in the result as well as a composite of other merge data. A calling program can request reports as to differences recommendations for merging or automatic merging. The versioning architecture allows for the promotion of version deltas that is moving individual changes to a file between different versions of the file in the store. Because documents from different namespaces can participate in merge operations the architecture also manages namespace merging.

Files being merged can contain keyword expansions. It is therefore important to provide a mechanism by which keyword expansion conflicts can be masked. In addition to the inputs listed above callers can also identify a keyword domain that is appropriate for a merge input document. Broker employs this information to automatically invoke domain specific preprocessors and postprocessors . A keyword preprocessor reduces keywords to a canonical form and saves the appropriate expansion data. For example Foo sdjhd would be reduced to Foo . The keyword post processor introduces keyword values back into the data stream in a non conflicting way. This allows the result to include keyword expansion without having to involve the server.

Keyword expansion is the process by which files are augmented with special tags that contain well defined information. For example the version history of a document can be embedded in the document. As in the sample tag in the previous paragraph a tag usually begins and ends with a reserved symbol such as that marks its boundaries. A symbol or text string Foo designates the type of tag. The remainder of the tag sdjhd represents data of a type expected by the particular designator. Tags are usually processed in a store specific way and frequently include store specific data. The present versioning architecture is capable of supporting multiple stores such as within a single system. Therefore it may include support for abstracting or generalizing keyword expansion.

Although keyword expansion typically occurs in a store on a server such as or it is possible that some keywords are only known on the client computer . If block determines that this is the case the store informs the client at block that client side keyword expansion is required. Block then causes a client or to call generic keyword services as at to perform the expansion passing a domain identifier at . The service receives the call at and expands the keywords at using the type of keyword processor required by the domain parameter. The server may also specify particular keywords and optionally values for those keywords.

Enlistment manager offers these functions and has a superset of the functionality of a direct service provider . It can reside anywhere in the system it can be implemented as a component associated with a service provider indicated at or have a service provider embedded within it. One embodiment might employ a client file system whereas another might use a server location for example. Enlistment might ot might not track versions themselves.

A private store holds the enlistments. The private store can be realized in several ways. It can for example employ a local file system of a client computer. Alternatively it could form a private area in the overall version store . An enlistment manager can be constructed with a number of characteristics. It supports the ability to synchronize an enlistment to any point in time i.e. version both forward and backward. It can switch the store or branch upon which it is based to another store or branch. Enlistments are transportable. A project that is stored on a removable medium for example continues to function when moved to a different computer with access to the version store. Enlistments may support atomic transactions so that the enlistment cannot be left in an inconsistent state. For instance a get operation on multiple files or documents replaces the target files only if and when all the requested files are obtained and always rolls back the entire transaction if an error is encountered for any of the files. An enlistment manager supports the synchronization of only portions of a namespace and excludes ghosts folders or files that are not required for the enlistments. Each of above and other desirable characteristics is known in the art. For example database systems commonly support atomic transactions. Thus a programmer can construct an enlistment manager according to the invention that includes whichever of these characteristics that may be desired.

The present invention offers an extensible software development or versioning system architected as modules for performing individual development functions. Because the individual modules have an interface compatible with each other modules not in the original system can be added to provide more services or substituted for one or more of the original modules. The architecture of this system supports the performance of actions such as document merging and keyword expansion at any location in the system. Further the interfaces operate upon documents and files as objects in an object space rather than in one or more name spaces.

