---

title: Inheritance context for graphics primitives
abstract: An inheritance context is created for a graphics primitive object that is a property of a visual element. The inheritance context can be used to make some element information (e.g., information in resource dictionaries, name dictionaries, and inheritable properties that reside in the element tree containing the visual element) available to the graphics primitive object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743387&OS=07743387&RS=07743387
owner: Microsoft Corporation
number: 07743387
owner_city: Redmond
owner_country: US
publication_date: 20051018
---
In some interactive systems visual elements can be implemented in an interface. In some such systems the visual elements are organized in a tree structure i.e. an element tree . The various elements of the element tree can have properties and resources that can be inherited by other child elements of the element tree. Further the visual elements may be implemented using graphics primitives such as brushes pens transforms geometry and the like. For example a button being displayed in a user interface UI can be implemented so that it has a specified background color. However the graphics primitives are generally not linked to the element tree in a way that allows the graphics primitives to use the inheritance features of the element tree. This background information is not intended to identify problems that must be addressed by the claimed subject matter.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detail Description Section. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

According to aspects of various described embodiments implementations are provided for creating an inheritance context for a graphics primitive object that is a property of a visual element. The inheritance context can advantageously make some element information e.g. information in resource dictionaries name dictionaries and inheritable properties that reside in the element tree containing the visual element available to the graphics primitive object.

Embodiments may be implemented as a computer process a computer system including mobile handheld computing devices or as an article of manufacture such as a computer program product. The computer program product may be a computer storage medium readable by a computer system and encoding a computer program of instructions for executing a computer process. The computer program product may also be a propagated signal on a carrier readable by a computing system and encoding a computer program of instructions for executing a computer process.

Various embodiments are described more fully below with reference to the accompanying drawings which form a part hereof and which show specific exemplary embodiments for practicing various embodiments. However other embodiments may be implemented in many different forms and should not be construed as limited to the embodiments set forth herein rather these embodiments are provided so that this disclosure will be thorough and complete. Embodiments may be practiced as methods systems or devices. Accordingly embodiments may take the form of a hardware implementation an entirely software implementation or an implementation combining software and hardware aspects. The following detailed description is therefore not to be taken in a limiting sense.

The logical operations of the various embodiments are implemented 1 as a sequence of computer implemented steps running on a computing system and or 2 as interconnected machine modules within the computing system. The implementation is a matter of choice dependent on the performance requirements of the computing system implementing the embodiment. Accordingly the logical operations making up the embodiments described herein are referred to alternatively as operations steps or modules.

Embodiments are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the embodiments include but are not limited to personal computers server computers hand held or laptop devices tablet devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Embodiments may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. Embodiments may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus Accelerated Graphics Port AGP bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a tablet electronic digitizer a microphone a keyboard and pointing device commonly referred to as mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . The monitor may also be integrated with a touch screen panel or the like that can input digitized input such as handwriting into the computer system via an interface such as a touch screen interface . Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer wherein the touch screen panel essentially serves as the tablet . In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Example Layered Architecture One aspect is generally directed towards providing smooth complex animations and or media on computer systems. To this end as generally presented in a media integration layer architecture is provided. An application program control or other similar higher level program code e.g. a user interface of an operating system component accesses the media integration layer architecture via a set of application programming interfaces APIs or the like to access write or read graphical information. Note that although many of the examples described herein will refer to an application program interfacing with the APIs it is understood that other higher level program code and components e.g. a user interface of the operating system will also be able to interface with the lower level components described herein. As such any reference to such higher level program code whether referred to as an application program user interface and so on should be considered equivalent.

In one implementation the media integration layer architecture includes a high level composition and animation engine timing and animation components and a low level composition and animation engine . As used herein the terms high level and low level are similar to those used in other computing scenarios wherein in general the lower a software component relative to higher components the closer the component is to the hardware. Thus for example graphics information sent from the high level composition and animation engine may be received at the low level compositing and animation engine where the information is used to send graphics data to the graphics subsystem including the hardware.

In general the high level composition and animation engine also referred to herein as the high level compositor and animator or the high level engine or component builds a display element tree to represent a graphics scene provided by the application program while the timing and animation components provide declarative or other animation and timing control. The low level compositing and animation engine also referred to herein as the low level compositor and animator or low level engine or component composes the renderings for the scenes of multiple applications and with rendering components implements the actual rendering of graphics to the screen. Note that it is still possible to do time consuming or application specific rendering at a higher levels and pass references to a bitmap or the like to the lower layers.

The high level composition and animation engine builds the element tree structure and traverses the structure creating rendering instructions and simple animation intervals to be passed to the low level compositing and animation engine . The rendering instructions generated by the high level compositor may contain timing and animation information. The low level compositing and animation engine takes the rendering instructions and animation intervals and manages the animating rendering and composing the scene that is then provided to the graphics subsystem e.g. the graphics software and hardware . Alternatively or in addition to locally displayed output the high level composition and animation engine or one similar thereto may provide the rendering and animation instructions in an appropriate format to lower level printing code for sending fixed image data to a printer or the like and or may provide rendering instructions and simple animation intervals in an appropriate format to a lower level terminal transport server for transmission to remote machines . Note that richer information also may be passed across the network e.g. it may be desirable to have the remote machine handle mouse rollover effects locally without any network traffic.

In this implementation the media integration layer architecture thus separates graphics processing into multiple levels and each of these levels performs some intelligent graphics processing which together allows applications user interfaces and the like to output graphics with smooth animation composite the graphics with the graphics of other applications and work with video frames. The animation and or compositing may also be synchronized with audio output. For example by synchronizing audio with the frame rate at the low level component the timing of audio can essentially be exact with that of video or graphics and not dependent on the ability of task scheduled complex pre processing to keep up with the refresh rate.

In general an element is an object in the element layer that participates in the property system triggering and layout presentation system. The parser finds tags and decides if those tags help to define an element or a resource object. In the special case of a VisualBrush for example the same tags may be interpreted as elements or also interpreted as resource objects depending on the context of where those tags appear e.g. depending on whether appearing in complex property syntax or not as described in U.S. patent application Ser. No. 10 401 717.

In addition to being present inline in the markup a resource instance may be located elsewhere e.g. in the markup or in a file which can be local or on a remote network and appropriately downloaded and referenced by a name e.g. a text name reference or other suitable identifier . In this manner a scene designer can reuse an element in the element tree throughout a scene including elements described by the complex property syntax.

The parser handles markup in the complex property syntax by accessing the type converter as necessary and also by matching specified parameters to the object properties thereby handling the complexity for the scene designer. Thus the parser does not just set up the objects but also sets properties on the objects. Because the same rendering model is shared between the element level and the API level many of the objects are essentially the same. This makes parsing translation highly efficient and also allows different types of programming languages e.g. C like languages the ability to easily convert from the markup to its own syntax and vice versa. Note that as represented in another such programming language which may comprise compiled markup can add elements to the element tree or can directly interface with the visual API layer .

As also represented in the same markup may be used to program at an element level and a resource level. In general the element level gives the scene designer full programmability usage of the property system that provides inheritance e.g. style sheet like features and triggering e.g. whereby an element may have attached code to change its appearance position and so forth in response to a user input event or action . However various embodiments also provide a resource level mechanism by which scene designers can essentially shortcut the element tree and program directly to the visual API layer. For many types of static shapes images and the like where element level features are not needed this provides a more efficient and lightweight way to output the appropriate object.

For purposes of controlling animation and media output a timing tree comprising clocks is also maintained. In general the high level compositor and animator engine performs complex processing sometimes referred to as compiling that significantly simplifies the amount of processing and significantly reduces the amount of data that lower levels need to deal with to render the correct output. Note however that the amount and type of processing that is performed by the higher level may be dependent to a significant extent on the load configuration and capabilities of the lower levels. For example if high capability graphics hardware is present the higher level may do a lesser amount of processing and vice versa. The high level and low level layers are adaptive to these factors.

In general animation is accomplished by both the high level compositor and animation engine and the low level compositor and animation engine . In one implementation the high level engine traverses the scene and updates animation parameters with intervals for later interpolation and packages these simplified data structures into instructions that get passed to the lower level engine . This may be done in a synchronous and or asynchronous manner. The interval data can be considered as including the timing endpoints start and end timing data as well as the parameterized values for the rendering instruction. Note that the high level engine can perform some or all of a requested interpolation e.g. if an interpolation or other motion function is too complex for the lower level engine to handle or the lower level cannot keep up with the processing demands placed thereon the higher level engine can perform some or all of the calculations and provide the lower level with simplified data instructions tessellations and so on to accomplish the desired result.

In a typical case when the lower level does perform interpolations for each frame of animation the low level engine interpolates the parameter intervals to obtain instantaneous values and decodes the instructions into rendering commands executed by the graphics device. The graphics device composes the final scene adding any video frames that might be present in the scene. Other data also may be added such as content protected by digital rights management.

The high level engine thus traverses the scene data structures computes an interval describing each animated parameter for a period of time and passes these intervals and simplified parameterized drawing instructions to the low level engine . The parameter data includes start time end time interpolator and interpolation data. By way of example instead of erasing and redrawing an image so that it appears to move the high level compositor and animation engine can instruct the low level compositor and animation engine as to how the image should change over time e.g. starting coordinates ending coordinates the amount of time interval that the image should move between the coordinates and a motion function such as linear note that motion is not required for animation as a stationary object may be animated by changing its color property for example . The low level compositor and animation engine will interpolate to determine new positions between frames convert these into drawing instructions that the graphics device can understand and pass the commands to the graphics device. Each pass of the high level engine preferably provides sufficient data for the low level engine to perform smooth animation over several frames.

The low level e.g. fast tick engine is a separate task from the high level engine . The low level engine receives the simplified parameterized drawing instructions and parameter intervals describing the scene from the high level engine . The low level engine maintains and traverses these data structures until new ones are provided by the high level engine . The low level engine may service multiple high level engines maintaining separate data structures for each. The one to many relationship between the low level engine and high level engine allows the system to smoothly animate multiple scenes simultaneously.

The low level engine interpolates essentially instantaneous animation parameters based on the high level engine s provided intervals updates drawing instructions and renders the scene for every frame. The low level engine task runs at a high priority on the system to ensure that frames are ready for presentation such as at the graphics hardware screen refresh rate. The interpolations performed by the low level engine are thus typically limited to simple fast functions such as linear piecewise linear cubic spline and those of similar speed.

With respect to animation and media a program such as the application program specifies animation property values along with timing information referred to as clocks or clock properties to the high level component . As described below essentially any independent animation or media e.g. linear media such as video and audio as well as a storyboard that coordinates specified animations will have a clock maintained for it at the high level component. In general the author specifies timeline data that is instantiated into the clocks as appropriate to keep them synchronized.

In general animations and linear media are associated with a set of clocks which are related to each other by synchronization primitives and rules. The clocks may be hierarchically arranged e.g. the application program has a parent clock and animated objects of the application program are children which in turn may have other children. When a property of a clock is defined or modified any children of that clock are affected. For example pausing a parent clock pauses any of its child clocks and doubling the speed of a parent clock doubles the speed of any of its child clocks.

These clock properties may be modified by source events comprising interactive control events initiated by the application at run time. Thus the clocks are interactive in that each clock can be individually started paused resumed and stopped at arbitrary times by the application e.g. in response to user input. In addition new clocks can be added to the timing structure and existing clocks can be removed.

As described in aforementioned U.S. patent application Ser. No. 10 693 822 the high level timing component may generate an interval list for each clock based on a stored list of events begin pause and so forth and the associated synchronization primitives. The activation intervals are straightforward non overlapping segments that describe the time expressed by a given clock at different points in real world time.

As used herein graphics primitives are objects that support cloning such as Freezables e.g. brush transform geometry and the like . Graphics primitives are used to set properties of visual elements such as FrameworkElement of the class hierarchy defined in the programming model for a version of the Windows operating system developed by Microsoft Corporation Redmond Washington. For example a brush is a Freezable that can set the background of a button or panel by cloning the original background information and then operating on the cloned information such that the original information may be restored. Note that Freezable is a subclass of DependencyObject in the aforementioned class hierarchy which is above FrameworkElement in the class hierarchy . An example element tree with visual element objects are described below.

Further in this example button includes a graphics primitive for at least one of its properties. In accordance with this embodiment the graphics primitives include inheritance context that provides a link between the graphic primitive and its children if any and button . In one embodiment the inheritance context is provided only for unshared graphics primitives. An example is described in conjunction with below.

The inheritance context allows the graphic primitive to find button and its parent elements and the properties name dictionaries and resource dictionaries of button and its parents e.g. listbox and window . In some scenarios the graphic primitive can implement databinding with a data source such as for example a property or name dictionary. The inheritance context allows the databinding to work in both markup and code. Similarly for a dynamic resource reference in a graphics primitive the resource reference can be resolved because the inheritance context allows the graphics primitive to walk up the element tree to find the resource.

In contrast in some conventional systems a databinding on a graphics primitive would have to be done in code e.g. the databinding is explicitly given a source in order for the binding to work for inheritable properties and name dictionaries residing in the element tree. Further the dynamic resource reference would not be able to resolve because there is no mechanism by which the graphics primitive will know which element to begin walking up to find the dynamic resource. Example below illustrates this unworkable scenario.

In Example 1 a Rectangle is to be filled using a graphics primitive object LinearGradientBrush. The endpoint colors of the LinearGradientBrush are SolidColorBrush objects that each references a dynamic resource for the colors. It is intended that the rectangle will be filled with a color that linearly varies from one color to another color however because the visual element are not parent of graphic primitives in conventional systems the SolidColorBrush objects cannot find the dynamic resource library.

In this example button has a property for the background color of the button which is defined using a linearly graded brush i.e. a graphics primitive object . Linear gradient brush in turn has properties defining the endpoint colors of the linear gradient brush. In this example linear gradient brush includes as properties a red solid color brush and a blue solid color brush . Thus when displayed button will have a background that ranges from blue at one end and linearly varies to red at the other end. The colors red and blue for solid color brushes and may be stored as a dynamic resource.

Returning to Example 1 above in an embodiment using an element tree such as element tree and an appropriate graphics primitive tree similar to graphics primitive tree the markup of Example 1 would work in this embodiment because the inheritance context provides a way for the SolidColorBrush objects to walk up element tree to find the dynamic resource library. Example 2 below illustrates a part of a DependencyObject of which graphics primitives are a subclass that is useable to implement inheritance context.

As illustrated by Example 2 this embodiment of DependencyObject includes a virtual method to get the dependency context and a method to indicate that the inheritance context has changed. This embodiment of DependencyObject can a call a method to fire an event that can trigger actions in the listeners e.g. databindings and dynamic resources b call a method to let subclasses of DependencyObject e.g. Visual UIElement FrameworkElement respond to the inheritance context change and c recursively call a method to notify its DependencyProperties e.g. graphics primitives such as Freezables so that all of the DependencyProperties are notified. Each instance of a DependencyObject subclass object e.g. a Freezable object can implement an event handler to handle the events that are fired when the inheritance context changes.

Example 3 below illustrates a part of a DependencyObject that sets the inheritance context for a graphics primitive object.

As illustrated by Example 3 this embodiment of DependencyObject includes a method to set the inheritance context of a DependencyProperty e.g. a graphics primitive object . If the method is called the DependencyObject instance provides itself as the inheritance context for the DependencyProperty. For example a button i.e. a DependencyObject will provide a pointer to itself to a SolidColorBrush i.e. a DependencyProperty of the button to serve as the inheritance context. Further as illustrated in Example 3 this embodiment of DependencyObject includes a method to clear the inheritance context of a DependencyProperty.

The following example Example 4 illustrates how a graphics primitive object supports inheritance context in one embodiment.

In this embodiment when the inheritance context changes the Dependency Object already walks all Dependency Properties see Example 2 above . Thus in this embodiment the graphics primitive object does not need to include anything more to have the OnInheritanceContextChanged percolate down the graphics primitive tree.

Example Inheritance Context for a Visual Element Although inheritance context is described above for graphics primitives in some embodiments a visual element can also specify an inheritance context i.e. other than the normal inheritance from a parent visual element . In one embodiment a visual element can give precedence to normal parent inheritance and thus will only have an inheritance context when it is not in a visual tree. An Example 5 below illustrates how to determine if a visual element has an inheritance context.

As illustrated in Example 5 a method GetInheritanceContext returns the parent inheritance unless the visual element does not have a parent inheritance. If there is no parent inheritance then the method provides the inheritance context if there is one.

Example 6 below illustrates how a visual element obtains an inheritance context. As described above for graphics primitive objects the visual element may be used by multiple other visual elements. In accordance with this embodiment the inheritance context feature is blocked or ignored in a visual element if multiple other visual elements are using this visual element. If other visual elements are not using this visual element then the inheritance context can be obtained if the visual element does not have a parent.

Example 7 below illustrates how to determine whether a visual element is being used by multiple other visual elements. In this embodiment the visual element has a method HasSharedContext that can be called to determine whether that visual element is being used by multiple other visual elements.

When a visual element gets a new context it needs to notify its children of the context change. Example 8 below illustrates how in one embodiment the visual element recursively notifies each of its children.

At a block a visual element is created. In one embodiment a composition and animation engine such as high level composition and animation engine builds an element tree structure including the aforementioned visual element . For example this visual element can be an element such as a button text rectangle etc.

At a block a graphics primitive object is set as a property of the visual element. In one embodiment the aforementioned composition and animation engine can create the graphics primitive object. For example this graphic primitive object can be a single object such as a brush or a tree of graphics primitive objects such as a linear gradient brush with two children solid color brushes to define the range of colors of the linear gradient brush.

At a block it is determined whether the graphics primitive object already has an inheritance context. For example in some scenarios two visual elements may use the same graphics primitive however this embodiment does not support inheritance context for two visual elements using the same graphics primitive i.e. the graphics primitive object is shared by two or more visual elements . In one embodiment the aforementioned composition and animation engine can determine whether the graphics primitive object has an inheritance context. If the graphics primitive object does not have an inheritance context operational flow can proceed to a block . If the graphics primitive object already has an inheritance context operational flow can proceed to a block .

At block the visual element created at block is set as the inheritance context of the graphics primitive object created at block . In one embodiment the aforementioned composition and animation engine can set the visual element as the inheritance context of the graphics primitive object. For example the composition and animation engine can provide to the graphics primitive object an up pointer that points to the visual element. Once the inheritance context is set the graphics primitive object can advantageously use databindings name dictionaries and or resource dictionaries that are part of the element tree containing the visual element.

At block the inheritance context for the graphics primitive object is ignored or blocked. In some embodiments the graphics primitive object may have a property that indicates whether the graphics primitive object is being shared. For example such a property may be a Boolean property that is set when the graphics primitive object is shared. When set the inheritance context can be cleared or ignored. In one embodiment the aforementioned composition and animation engine can block or clear the inheritance context of the graphics primitive object and then place the graphics primitive object into a shared state e.g. by setting the aforementioned Boolean property .

Although operational flow is illustrated and described sequentially in a particular order in other embodiments the operations described in the blocks may be performed in different orders multiple times and or in parallel. Further one or more operations described in the blocks may be omitted or combined in some embodiments.

Further in some embodiments operational flow can also include operations not shown to detect or recognize if a graphics primitive object that was shared becomes unshared. For example a reference count or other mechanism may be maintained e.g. by the aforementioned composition and animation engine to detect when a once shared graphics primitive object becomes unshared. The inheritance context of the visual element that still uses the graphics primitive can then be reset e.g. by performing block or reinstated .

At a block an inheritance context change is detected by a graphics primitive object. For example there may have been a change to an inheritable property or a dynamic resource dictionary a name dictionary etc. associated with a higher element of the element tree containing the visual element for which the graphic primitive object is a property. In one embodiment when such a change occurs a method of the graphics primitive object may be called when such a change occurs. For example in the embodiment of Example 2 operation that causes the change also calls the method OnInheritanceContextChanged on the graphics primitive object.

At a block resources and or databindings used by the graphics primitive object are notified of the inheritance context change. In one embodiment the graphics primitive object can fire an event that notifies listeners i.e. the resources and or databindings of the inheritance context change. For example in the embodiment of Example 2 a method InheritanceContextChanged new EventArgs is called to fire the event.

At a block the graphics primitive object then validates itself using the inheritance context. In one embodiment the graphics primitive object attempts to find values of all of its properties. For values specified by a databinding name dictionary or resource dictionary the graphics primitive object can walk up the element tree starting at the visual element for which the graphics primitive object is a property. For example in the embodiment of Example 2 the graphics primitive element calls a method OnInheritanceContextChangedCore is called to validate its properties.

At a block any children of the graphics primitive object are notified of the inheritance context change. In one embodiment the graphics primitive object can walk down its tree of graphics primitive objects if it has children and notify each child graphics primitive object that the inheritance context has changed. Further when notified of this inheritance context change if unshared the child can then validate itself as in block . For example in the embodiment of Example 2 as the graphics primitive object walks down to each of its children if any for child it finds it calls the aforementioned method OnInheritanceContextChangedCore .

Operational flow allows a graphics primitive object to detect changes in its inheritance context and validate itself and all of its children.

Although operational flow is illustrated and described sequentially in a particular order in other embodiments the operations described in the blocks may be performed in different orders multiple times and or in parallel. Further one or more operations described in the blocks may be omitted or combined in some embodiments.

Reference has been made throughout this specification to one embodiment an embodiment or an example embodiment meaning that a particular described feature structure or characteristic is included in at least one embodiment. Thus usage of such phrases may refer to more than just one embodiment. Furthermore the described features structures or characteristics may be combined in any suitable manner in one or more embodiments.

One skilled in the relevant art may recognize however that embodiments may be practiced without one or more of the specific details or with other methods resources materials etc. In other instances well known structures resources or operations have not been shown or described in detail merely to avoid obscuring aspects of the embodiments.

While example embodiments and applications have been illustrated and described it is to be understood that the invention is not limited to the precise configuration and resources described above. Various modifications changes and variations apparent to those skilled in the art may be made in the arrangement operation and details of the methods and systems disclosed herein without departing from the scope of the claimed invention.

