---

title: Synchronizing file system directories
abstract: Described is a system and method that facilitates fast and reliable synchronization of computer/file system directories. A synchronization (FastSync) subsystem operates in a discovery/enumeration phase to provide a calling client with a set of the differences between directories, and then operates in an action phase to perform operations as directed by the client to synchronize the different directories. The discovery/enumeration and action phases use parallel operation and I/O (input/output) pipelining. Multiple threads are used during enumeration to enumerate each directory's children, and enqueues each sub-directory to be handled by a new thread. During the action phase, when an operation is requested, the FastSync subsystem packages up the operation, item pointer, and context information into an internal context block and queues that packet as a work item for a process thread pool to handle.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07634514&OS=07634514&RS=07634514
owner: Microsoft Corporation
number: 07634514
owner_city: Redmond
owner_country: US
publication_date: 20050509
---
The invention relates generally to computer systems and more particularly to computer files and directories.

Computer users often need to disconnect from a network and work offline such as when traveling working at home or at times when the network is down. As a result various mechanisms have been directed to caching network information on a local computer to allow the information to be accessed when the local computer is disconnected from the network. Local caching also reduces the amount of data communicated between the network servers and a client working in an offline mode. Benefits to reducing the amount of transmitted data include a reduction in the server workload a reduction in the client s perceived latency and an increase in available network bandwidth.

Working offline usually changes the state of the offline directory hierarchy relative to the server directory hierarchy. Changes to the directories in the hierarchies can come in the form of a file change such as a change of attributes or a data write or in the form of a namespace change such as the creation of a new file or directory or the deletion of a file.

Regardless of the change or changes at some point it becomes necessary to perform some process to synchronize the offline client and server directories into a synchronized state. In a synchronized state the two directory hierarchies have the same subdirectory structure containing the same filenames within those directories. Also for each file that exists in both directories the files need to contain the same data in their data streams and have the same associated attributes timestamps and other file system information.

However synchronizing the cached offline items with the server file system s items directories and files is complex relatively slow and has always suffered from problems. What is needed is a fast and reliable way to synchronize offline files.

Briefly the present invention is directed towards a multi phase system and method that facilitates the synchronization of directories and their files such as to synchronize a directory maintained in a local offline cache with another directory in a remote network file system. To this end a fast and reliable synchronization FastSync subsystem operates in a discovery enumeration phase to provide a calling client with a set of the differences and then in an action phase performs operations as directed by the client to synchronize the different directories.

In the discovery enumeration phase the FastSync subsystem determines the differences that exist between directories any including namespace differences such as a file having been deleted from one directory but not its counterpart directory or differences between the attributes and or contents of two files. In one implementation a synchronization structure such as a tree of nodes that describe the differences is returned to the client caller by the FastSync subsystem.

The synchronization tree structure is built as a subset of the directory namespace that contains nodes representing items files or directories that have changed. To save on memory usage nodes are not placed in the tree for unmodified items although simple nodes are maintained in the tree for unchanged subdirectories with changed items below them to preserve the correct hierarchical organization. Each item to synchronize contains a sync status field that describes a current state e.g. whether a file has changed from its original state on one directory or the other or both or whether it exists only in one directory because it is newly created in the directory where it exists or has been deleted from the directory from which it is missing.

The client caller analyzes the returned structure as desired and then requests that the FastSync subsystem take specified actions that are directed towards bringing the directories into a synchronized state. In the action phase the FastSync subsystem carries out synchronization primitives operations which may be combined into a more complex action as directed by the client.

In one implementation the discovery enumeration and action phases of the FastSync subsystem leverage parallel operation and I O input output pipelining including by using multiple threads during each phase. For example during enumeration each thread opens the same path under both directories and enumerates the children files and directories . The thread enqueues each sub directory to be handled by a new thread and then processes the differences within that directory by modifying the tree to include sync items for the changed elements. The FastSync subsystem also uses directory enumerations rather than file enumerations. As each enumeration discovers new directories those directories in turn are queued for enumeration by another thread. It is thus possible for a directory and its subdirectories to be processed in parallel by different threads. This maximizes CPU utilization and takes advantage of I O pipelining particularly over the network. On the network such pipelining reduces the effect of latency on the total time to synchronize.

During the action phase when an operation is requested the FastSync subsystem packages up the operation item pointer and context information into an internal context block and queues that packet as a work item for a process thread pool to handle. Note that internal queuing ensures that actions are executed in the proper order. When a thread is available to work on an operation the FastSync subsystem extracts an item from this queue and performs the work making callbacks to the caller as necessary. If the action is successful the overall process can be considered as returning the thread to the thread pool until later needed for another item. If not successful the client may allow some number of retries or the item added back to the work list e.g. by returning a failure code to the caller.

Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings in which 

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices tablet devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in local and or remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media described above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a tablet or electronic digitizer a microphone a keyboard and pointing device commonly referred to as mouse trackball or touch pad. Other input devices not shown in may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . The monitor may also be integrated with a touch screen panel or the like. Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer. In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in FIG. include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

The present invention is generally directed towards a system and method by which directories such as in a local offline cache and a remote network file system are synchronized. To this end the present invention discovers what differences exist between the directories enumerates the differences to a calling client and then takes actions as requested by the client e.g. to issue the file system related commands that are needed to reach a synchronized state. As will be understood numerous ways to implement the present invention are feasible and only some of the alternatives are described herein. For example the present invention is primarily described below with reference to a multi phase multi threaded model that performs of number of synchronization related operations in parallel. Notwithstanding other types of arrangements are feasible and the present invention is not limited to any particular examples used herein but rather may be used various ways that provide benefits and advantages in computing in general.

With respect to multi phase operation in one implementation a synchronization subsystem operates in a discovery phase to locate and enumerate differences between two directory structures to be synchronized and an action phase in which synchronization primitives operations which may be combined into a more complex action are carried out. This provides a very fast reliable mechanism for a client caller mechanism which operates in an analysis phase to leverage. As will be understood the subsystem in this implementation provides for significant parallel operation and I O input output pipelining and thus facilitates rapid synchronization whereby the subsystem is referred to herein for brevity as the FastSync subsystem .

In general in this example implementation the FastSync subsystem component enumerates the differences between directories and carries out synchronization related requests but does not make the decisions as to how to synchronize the directories. The FastSync subsystem instead reports the state of a directory in the enumeration phase and takes explicit commands from a client caller in an action phase as to what operation or operations corresponding to an action are to be taken to synchronize individual files or directories. This allows for different types of callers to interface with the FastSync subsystem such as interactive applications that need to obtain user input to synchronize or group policy processors and scripts that need to run in the background without prompting the user. One suitable client caller comprises a client side controller of a caching service described in copending U.S. patent application Ser. No. 11 032 870 filed Jan. 10 2005 assigned to the assignee of the present invention and hereby incorporated by reference. Note that in this service model the service allows an application program or synchronization manager program to have synchronization functionality without performing much of the complex synchronization analysis.

In general in this implementation the FastSync subsystem does not contain the logic for resolving out of sync conditions. One reason is that this allows different callers to synchronize in different ways. The FastSync subsystem action operations instead provide primitives such as set forth in the following example operations synchronizing two directories A and B 

The operations are high level enough that the caller does not have to worry about details but it gives the caller the option to resolve conflicts in different ways. For example a caller may sometimes but not always want to make a backup of a file before deleting it or overwriting it such behavior is possible in this system. As another example a caller may always want to make folder B look like folder A in certain circumstances no matter whether folder A has changed or not. In such an event the caller can simply select the operations that would delete or overwrite the changes in B then copy the new content from A to B.

Note that not having analysis logic in the FastSync subsystem simplifies it in some ways but makes things more complicated in other ways. A complication is that it is always necessary for the FastSync subsystem to provide up to date and correct information about the state of a file or directory e.g. by updating data structures.

Turning to the example arrangement represented therein includes the application synchronization manager the client caller sync analysis mechanism and the FastSync subsystem . In one implementation these components communicate via defined sets of interfaces.

The FastSync subsystem accesses directory information via a file system and or suitable remote interface not shown on a volume A and a volume B . Although shows a local volume and server volume which is typically a network server on a remote volume the present invention is not limited to any particular volume arrangements. Indeed the present invention is able to synchronize files on two remote volumes two local volumes and even can be adapted to synchronize two directories on the same volume. The present invention may also support mount point volumes wherein a mount point volume is essentially a volume mounted in a directory of another volume. Thus although the present invention is described with the typical examples of synchronizing a local volume or some directory based subset thereof with a remote volume these are only non limiting examples.

As represented in in the enumeration phase the FastSync subsystem evaluates two directories and which may start at the root directory of the local volume and a corresponding user namespace on a server but may be subdirectories that correspond to one other . Note that in directories are shown as circles while files are shown as squares. Further note that the enumeration phase may use multiple threads for fast operation as described below.

In general following the enumeration phase the client caller obtains from the FastSync subsystem a synchronization state data structure containing information about items to be synchronized. In the example implementation of the structure is arranged as a synchronization tree . As described below the client caller evaluates that information consults system policy and the like when necessary and directs the FastSync subsystem to perform one or more synchronization related actions primitives on those items. This is represented in by the action request being provided by the client caller to an action handling component .

To provide the synchronization tree data structure the FastSync subsystem efficiently examines each directory s state to report differences between directories to the caller. The synchronization tree is built as the subset of the directory namespace that contains files or directories that have changed. To save on memory usage unmodified files do not show up in the tree and directories that do not contain changed content or have not changed themselves are not included in the tree. Note however that directories that have not changed but have files in them that have changed are maintained as simple nodes in the tree so as to preserve the correct hierarchical organization.

As can be seen the nodes that are in the synchronization tree correspond to namespace differences or differences between files attributes and or contents . For example in nodes E and I and E s child nodes are not in both directories and thus these namespace differences are nodes in the synchronization tree along with their child nodes. The node J and its child file K are the same in each and are thus not included in the synchronization tree for purposes of efficiency. Further there are file differences in file H as represented by the shaded box in directory structure of and thus this file is included in the synchronization tree along with a simple node C as its parent.

As represented in each node in the tree other than simple nodes contains a data structure of the information for one sync item which is either a file or directory. Sync items contain a sync description which represents the original synchronized state of the sync item as well as the way or ways each item has changed since it was last in a synchronized state. For example for a file that has been modified the sync item would contain the original Last Write Time file size attributes and so forth from the synchronized state as well as the current values for those fields for the copies from both directories if a copy exists note that at least one set of values must be different from the original or it would not be out of sync .

In addition each sync item contains a sync status field that describes the state of the file. For example the sync status indicates whether the file has changed from its original state on one directory or the other or both or whether it exists only in one directory because it is newly created in the directory where it exists or has been deleted from the directory from which it is missing. The sync status is granular enough that the caller can use it as a basis for applying its state machine to select an operation or operations to perform in order to synchronize the item.

The caller uses the synchronization tree and the items therein to perform analysis such as described in the aforementioned U.S. patent application Ser. No. 11 032 870. Based on this analysis the caller then requests that the FastSync subsystem perform one or more actions directed to bringing the directories into a synchronized state.

More particularly in response to operation requests from the caller the FastSync subsystem may make the necessary calls to a client side caching driver and server volume driver e.g. redirector to perform the requested operations and other operations and report progress status back to the caller . Although not necessary to the present invention in one implementation when an operation is requested the FastSync subsystem packages up the operation item pointer and context information into an internal context block and queues that packet as a work item for a process thread pool to handle. Note that internal queuing ensures that actions are executed in the proper order. When a thread is available to work on an operation the FastSync subsystem extracts an item from this queue and performs the work making callbacks to the caller as necessary. Further note that FastSync subsystem operations are asynchronous. However because callbacks may execute at any time from one of many thread pool threads callback context has no particular thread affinity and calls to client progress and conflict handling implementations are thus serialized e.g. by the caller . The caller may also reflect the progress status back to the calling application program .

In a typical situation in which no error occurs step instead branches to step to add one or more action items to a work list note that this work list is not the same as the above described internal FastSync subsystem work item queue that the caller serializes . In general the work list represents a collection of sync items that are to be processed by the caller.

Step represents selecting an item from the work list with step representing the processing of that selected item. In one implementation the initial enqueuing of files includes walking the tree via a depth first traversal to choose the initial action for each item and for adding the items to this list comprising a revolving queue. Note that at step work items can arrive from the initial walk of the tree as well as from errors via step described below with the process essentially iterating on the queue until there are no work items left as also described below.

Thus in general processing the item determines the action that is to be requested for the item decides whether the item has an error that is unrecoverable or concludes that the item is already synchronized. If the item is one that needs to be synchronized step and represent requesting of enqueuing of that item for action by the FastSync controller .

Step repeats the selection processing and possible enqueuing steps until the work list is empty. When empty the caller operations are complete although it is possible that an item will be added back to the work list in the event of the inability of the FastSync subsystem to properly perform the requested action as described below. The synchronization is actually complete when the FastSync subsystem has successfully completed all of its processing and there is no sync item left for the caller to process.

Whenever an action is enqueued e.g. by an API call to FastSync subsystem at step the FastSync subsystem may dequeue it as soon as it has resources e.g. an available thread to do so. In general represents these operations including waiting at step for an item in the queue. In one implementation dequeued items are enqueued in another queue for consumption by another thread thereby facilitating parallel operation as described below.

In this parallel implementation the FastSync subsystem processes operations on sync items via separate threads and thus the steps below step represent the control flow after the completion successful or not of the execution of an operation as performed by separate threads. In general actions are attempted and callbacks made as represented by step . If the action is successful step the overall process can be considered as returning the thread to the thread pool until later needed for another item. If not successful the client may allow some number of retries as represented by step returning to step . If not allowed to retry the item is added back to the work list as represented in by returning from to step e.g. by returning a failure code to the caller.

The caller may use a FastSync subsystem API set to enqueue operations in which the FastSync subsystem simply adds them to a queue and returns immediately. The FastSync subsystem performs the operations using multiple threads in parallel which each take a pending operation from the queue and execute it. Once each operation is complete the FastSync subsystem notifies the caller by executing a callback provided when the operation was enqueued. The caller can then evaluate the result of the operation and attempt to retry the operation if it failed or enqueue a new operation on that file or directory.

Note that the only point where the caller gives up control of its calling thread for an appreciable amount of time is during the enumeration phase during which the FastSync subsystem does not return control until enumeration is complete successful or not although it provides frequent callbacks that allow the caller to modify the behavior of enumeration or to abort enumeration altogether. During the action phase the caller s requests to enqueue operations which are associated with Sync Items return relatively quickly since little work is done by the FastSync subsystem to add them to queue of operations to be performed.

At the end of the action phase when a the FastSync subsystem thread has finished performing its work it executes a callback provided when the operation was enqueued to return information on the result of the operation and the sync item that represents the file or directory that was operated on in the action. The callback occurs on a separate thread from the one used to enqueue the operation to the FastSync subsystem . Within the callback the caller has the option to retry the operation in which case the caller will receive another callback reporting the result of the retried operation. Otherwise even if the caller does not wish to retry the exact same operation during the completion callback it can enqueue a new operation either the same operation as before or a new operation for the same sync item later.

In this manner parallel operation and I O pipelining multiple threads for processing and I O to reduce idle time are generally maximized while total data transferred is minimized. To this end in one implementation multiple threads are used both during enumeration and action as generally represented in in which the FastSync subsystem enumerates the content of both directory trees on multiple threads and returns when all threads complete processing.

During enumeration each thread opens the same path under both directories and enumerates all the children files and directories . The thread enqueues each sub directory to be handled by a new thread and then processes the differences within that directory by modifying the tree to include sync items for the changed elements.

One other aspect of the FastSync subsystem s method of enumeration is that it does so without opening every file in the directory to be synchronized. Opens are expensive particularly over the network. In order to determine the properties of a file such as change times size and attributes by opening every file the file would have to be opened the file information queried for and the file closed. On a local system each of these three operations requires entering the operating system and on a remote file system this means at least three round trips over the network and possibly more overhead.

To avoid this expense the FastSync subsystem instead uses directory enumerations. For a directory enumeration it is only necessary to open the directory once after which each query on that handle fetches information about multiple files without actually opening them. Then it is necessary to close the directory. A primary difference is that by leveraging directory enumeration there is only one open and one close per directory instead of one for every file and directory. Further having only one query directory produces the information for many files as opposed to one query information for each file and directory using a per file method files and directories are generally equivalent in terms of operating system and round trip expense . In addition to minimizing round trip exchanges with the server this also reduces the total amount of data transferred due to the reduced overhead.

As each enumeration discovers new directories those directories in turn are queued for enumeration by another thread. Therefore it is possible for a directory and all of its subdirectories to be processed in parallel by different threads. This maximizes CPU utilization and takes advantage of I O pipelining particularly over the network. On the network such pipelining reduces the effect of latency on the total time to synchronize.

During the action phase multiple threads handle the operations enqueued by the caller with each action running and completing on a single thread that is one thread per action with multiple actions executing simultaneously.

As can be readily appreciated for reliability the system should gracefully handle interruptions and unavailability of parts of the file system e.g. due to sharing violations with the ability to retry any operation multiple times. For enumeration the enumeration phase will not fail if an individual file or directory fails to be enumerated. Instead the FastSync subsystem will report that that particular node in the sync tree was unable to be enumerated. The caller can initiate a new enumeration starting from that sub tree at a later point in time.

The action phase may contain more sophisticated failure handling logic. For example when the FastSync subsystem reports that an operation failed for a particular sync item it updates the item to reflect the new SyncState and the file s relevant information such as attributes size and change times . The caller has the option to signal the FastSync subsystem to retry the previous action immediately and receive another callback when the retried operation completes or to wait and at any point enqueue the sync item for the same operation or a new operation.

By having this flexibility it is possible for the caller to implement a rich set of possibilities for responding to the result of an operation. For example it is possible for the caller to respond to a sharing violation by waiting for some amount of time and then retrying the operation by enqueing it in hopes that the application that had the file open closed its handle s . In addition it is possible for the caller to run the item through an arbitrarily complex state machine after every failure e.g. in many cases the same state machine that was initially used to determine how to synchronize the file . In that way it is possible for the caller to run sync items through a single stateless system that determines how to synchronize a file over and over. That system may include interactively asking the user what to do referring to machine or domain policies making backup copies of files and so forth.

Moreover the present invention reduces the impact on the usability of the file system in that it recognizes that files or directories should not be locked for long periods of time. One problem with synchronizing a whole directory tree at once for the sake of efficiency and speed as opposed to synchronizing one file at a time is that it is not practical to hold a file exclusively e.g. by opening a handle that forbids write operations by other applications. However when synchronizing one file at a time it is acceptable to hold the file exclusively ask the caller what to do with it and then perform the action without releasing it. The FastSync subsystem attempts to avoid draining system resources and annoying application users by not holding every single modified file or directory from enumeration all the way through the completion of the last operation.

To this end the FastSync subsystem enumerates the directory hierarchies via directory enumeration which allows directory operations such as queries and file subdirectory creation but does not prevent writes to files. During the action phase the FastSync subsystem verifies that the file is in the same state as it was during enumeration typically the file is in the same state as during enumeration but it is possible it may have changed. If the file has changed between enumeration and action then it is possible that a different operation is appropriate from the one that was selected. In such a situation the FastSync subsystem completes the operation without touching the file or directory and reports a failure code explaining to the caller that a change has occurred. The caller has the opportunity to respond immediately to retry the operation or to cancel the operation. At a later point it is possible for the caller to submit a new action for that item. The caller can also instruct the FastSync subsystem to ignore certain aspects of the file that can change in innocuous ways.

Thus the only time the FastSync subsystem opens a file thus locking it to some degree from other file system accesses is for a short time during enumeration and then during action while an operation is being processed. Because it accepts interruptions gracefully the FastSync subsystem and its callers can handle inconsistencies between the enumeration and action phases as well. Note that with a transactional file system such as Transactional NTFS as described in U.S. Pat. No. 6 856 993 it is also possible for the FastSync subsystem to associate a transaction context with a sync item to provide the ability to roll back synchronization changes.

Although not necessary to the present invention the caller should provide callbacks for any per file or per directory processing it needs to perform during the operation of the FastSync subsystem . Although the FastSync subsystem drives enumeration and action there are instances where the caller may need to perform some processing and provide feedback to the FastSync subsystem . In those instances callbacks are used so that the FastSync subsystem can prompt the user. One example is during enumeration in which the caller may choose to synchronize only a subset of total available directories and ignore others. One example is when certain directories are actually mounted remote file systems on slow connections or when there are directories that are known to contain only read only data. The FastSync subsystem can provide callbacks to the caller so that before enumerating a directory it executes the callback to essentially ask the caller what to do. The caller can then respond to the FastSync subsystem by indicating whether it should enumerate the directory skip it or abort enumeration altogether.

Another example is during the action phase while copying a newly created sub directory when it may be important for the caller to know about every file and avoid copying certain files or directories. For example it may be important to keep certain types of files such as copyrighted content off of a certain file server or it may be important not to copy a remote file system mounted sub directory. For that reason callbacks are provided while copying a directory tree whereby the caller can choose to skip certain files or directories or cancel the copy altogether.

As can be seen from the foregoing detailed description there is provided a model for synchronization in which enumeration and action methodologies are essentially self contained and driven by a FastSync subsystem while allowing the caller to have the control it needs over the synchronization process. The synchronization process is fast and reliable as well as flexible to allow various callers the ability to obtain enumerated information and request actions. The present invention thus provides numerous benefits and advantages needed in contemporary computing.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

