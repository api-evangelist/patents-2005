---

title: Method of realising a boundary of a rotated object
abstract: A method is described for determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines. In the method, the object is rotated by an integer multiple of 90 degrees, and an outline of the rotated object is decomposed into line segments. For each scanline to be rendered, points of intersection between the line segments and the scanline are determined, and each point of intersection is rounded to an adjacent position selected from a finite set of positions on the scanline using a rule chosen according to the amount of rotation. The rounded points of intersection delimiting the discrete boundary. If the object is rotated by odd multiple of 90 degrees the method includes the steps of identifying points of intersection that satisfy a predetermined criterion; and shifting the identified points of intersection prior to rounding.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07746361&OS=07746361&RS=07746361
owner: Canon Kabushiki Kaisha
number: 07746361
owner_city: Tokyo
owner_country: JP
publication_date: 20050811
---
This application claims the right of priority under 35 U.S.C. 119 based on Australian Patent Application No 2004904745 filed 19 Aug. 2004 which is incorporated by reference herein in its entirety as if fully set forth herein.

The present invention relates to electronic image generation and in particular relates to accurately and efficiently realizing a boundary for a rotated object.

Traditionally software applications such as word processors create page based documents where each page contains graphic objects such as text lines fill regions and image data. When representing the document data on a display device or a printing device such software applications typically send commands defined in terms of the graphics interface services of a native operating system within which the software application operates.

One such operating system is Microsoft Windows which has graphics interface services typically known as the graphics device interface GDI layer. The GDI layer is generally an application programming interface API providing a rich set of graphics features to all applications. Typically a graphics rendering system renders the graphics objects received from the GDI layer generating pixels which are then sent to a target device for storage display or printing. Rendering is the process by which the graphics objects received from the GDI layer are converted to pixels by the graphics rendering system.

The graphics rendering system may at times be requested to render a page at 90 180 or 270 degrees rotation as illustrated in .

There are various reasons why a page may be rotated from the original data. A printer may be limited regarding the orientation of a printed page. If a printer is only capable of printing an A4 portrait page then a page created in A4 landscape needs to be rotated before the page can be printed. Also a user may request a specific page rotation based on his her requirements. Typically modern day printer drivers allow a user to create output formats for special purposes. Such formats include birthday cards n up pages multiple pages scaled to fit on the one page double sided pages letters cards and even books.

For example shows a rendering of the page of using 4 pages per sheet two of the renderings marked page and page being rotated by 180 degrees. Page may be folded in half along Fold and then folded again along Fold to form a card that has four upright renderings on it. The resulting card can be seen in .

In such cases original data passed by the GDI layer needs to be transformed by the graphics rendering system and then rendered according to the specific format requested by the user. Often such formats require page data to be rotated at a specific angle to produce the final output.

To rotate a page containing graphics objects each object on a page is rotated by a specified angle. The page boundary may also be rotated depending on the final output requirement. C and D show renderings of the example page of rotated 90 180 and 270 degrees respectively. It may not always be necessary to rotate a page. For example there is no use in rotating to produce when printing. However such inversion may be useful when rendering the page to a screen. There are also circumstances where the objects on the page are to be rotated but the page itself is not. An example of this is shown in where the page boundary is the same as that of page but the data is printed 2 up with each of the two renderings rotated by 90 degrees.

An object boundary is typically described by a path made up of a number of points. Since this path is described as a continuous entity using a defined point system these continuous paths must be resolved into discrete pixel values at the rendering stage. Typically paths are broken up and dealt with in monotonically increasing order. A variety of rules are available to resolve a continuous path into its equivalent discrete format. These rules are typically known as pixelization rules. A couple of well known pixelization rules are the GDI pixelization rule and the PostScript pixelization rule. The GDI pixelization rule uses the Grid Intersection Quantization rule in order to determine which pixels are activated by a path.

Representing a continuous signal i.e. a path defined as a set of points with a discrete approximation causes errors to be introduced in representing a final pixelized object. Typically there are problems representing very small objects as the paths themselves are not discrete but their final representation must be so much of the original signal is lost in the digital conversion. Also since pixelization rules typically do not take the rotation of an object into account any shift or arbitration required to resolve a path into a pixel is typically not rotation invariant. That is if a path is rendered at 90 degrees and the same path is rendered at 180 degrees then it is unlikely that the same set of pixels is turned on for each of the rendered paths.

Traditionally there are a number of ways of accurately rendering an object to be rotated. The most basic method is to render the object with no rotation to produce pixel data and then to rotate the rendered pixel data. Since the original path has been quantized the rotated version will be pixel accurate. However this method requires large amounts of memory and CPU resources for a full page and is slow if done on an object per object basis.

Another method used to produce pixel accurate rotations is to produce the pixedges of a path pixedges are the edges of each pixel and then rotate the pixedges. Since the pixedges define the exact boundary of the object to be rendered the same pixels will be filled regardless of the rotation of the objects. This method is very cumbersome since each edge defines a pixel boundary and consequently the path data for the entire set of edges defining the boundary of an object may be huge. Compared with the original points of the path the pixedge data uses more memory and typically takes more time to rotate. Rendering objects in such a manner is expensive in terms of CPU resources consumed.

An example is shown in . The object shown in has an object boundary as shown in . shows a quantized path derived from the boundary . The path can be accurately rotated since it has been quantized. However where the original path only has 7 points the quantized version has 31 points. Clearly rotating many such quantized objects would consume a large amount of CPU resources.

In some known graphic rendering systems rendering is a two stage process. In these rendering systems graphics objects are first converted into an intermediate language before the rendering process begins. This intermediate form containing all the converted graphic objects is known as a display list. In one such system the first stage of the process converts each graphic object received from the GDI layer into an intermediate edge based object graphics format such that all edges are sorted in ascending y order then ascending x order. The x and y axes correspond respectively to the scan lines and pixel locations on such scan lines in a rasterized display. The output from the first stage is typically a display list of edges and their associated fill priority z order along with other information such as whether an edge is a clipping edge or a filling edge. The output from the first stage is sometimes called a job. The job contains all the information needed by the second stage to render the page.

The second stage of the process involves a rendering module parsing the job and generating the pixels for the output device for each scanline down the page.

For renderers that use such a two stage approach in which information is stored in an intermediate form each object has to be converted to the intermediate form. However it is often the case that not all the objects stored in the display list will actually be part of the rendered output. For example the second stage of the rendering system may only be asked to render a specific part of a page or the objects that are stored in the intermediate format may actually lie on and or outside the bounds of the page. These cases represent a problem for edge based renderers because the edges of the objects that lie outside the region to be rendered still need to be tracked. Such edges that lie outside the region to be rendered need to be tracked because they may enter the region to be rendered. Edges are typically tracked scanline by scanline and thus tracking such objects can be time consuming and greatly slow the performance of the renderer.

There are a couple of methods used to deal with objects that do not lie within the region to be rendered. The first method is the simplest and simply involves tracking the edges of all objects in the display list and only rendering pixel data when the edges are within the region to be rendered. Another method is to clip all objects to the current rendering boundary. This involves tracing a path in and out of the region to be rendered and clipping any part of the path that lies outside the region to be rendered. This task is not trivial and requires precious CPU resources to trace a path and determine the points that lie outside the area to be rendered. Furthermore if another part of the page needs to be rendered a new display list has to be constructed. Also because an object boundary is represented by edges that typically use a fixed format to represent the edge position accuracy problems can arise when clipping the boundary. For example consider the line joining the two points 0 4 and 55 56 . This line crosses the x axis at about 3.72. If this line is clipped to the x axis and the accuracy of the points of the line is limited to 1 16 then 3.6875 would replace 3.72. Hence accuracy has been lost in the clipping of the line. This loss in accuracy can lead to distortion of the final rendered output of an object.

Another problem with edge based renderers lies in the speed of updating edges for the next scanline. This is because the x position of each edge needs to be updated to the next scanline according to the dx value of an edge. The updating of the edge also depends on the type of edge further increasing the complexity of updating the edges. Typically as each edge on a scanline is encountered an edge update function is called. This function takes the current position of the edge determines the real x position for the next scanline and then determines the integer position for the next scanline. Typically pages to be printed contain thousands of edges and each of these edges must be updated by calling the update function for every scanline on which the edge is active. This represents a major part of the rendering time in a two stage edge rendering system. Current methods used to update edges involve calling one update function that updates an edge according to its type. The problem with the approach is that every time an edge is updated the code must branch according to the edge type which results in a slow method.

Another method of updating edges is to have a specific update function associated with each edge using a function pointer . When an edge is to be updated the renderer can simply call the function according to the edge s function pointer. In this case the renderer only needs to set the function pointer once for each edge and not every scanline so the branching problems presented above are removed. However each of these edge functions must be called whenever an edge is updated so there are still large function call overheads ultimately restricting the rendering speed.

It is an object of the present invention to overcome or at least ameliorate one or more aspects of the prior art.

According to a first aspect of the invention there is provided a method of determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the method comprising the steps of 

According to a second aspect of the invention there is provided a method of determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the method comprising the steps of 

According to a further aspect of the invention there is provided a method of determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the method comprising the steps of 

According to a further aspect of the invention there is provided an apparatus for determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the apparatus comprising 

According to a further aspect of the invention there is provided an apparatus for determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the apparatus comprising 

According to a further aspect of the invention there is provided an apparatus for determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the apparatus comprising 

According to a further aspect of the invention there is provided a computer program product comprising machine readable program code recorded on a machine readable recording medium for controlling the operation of a data processing apparatus on which the program code executes to perform a method of determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the method comprising the steps of 

According to a further aspect of the invention there is provided a computer program product comprising machine readable program code recorded on a machine readable recording medium for controlling the operation of a data processing apparatus on which the program code executes to perform a method of determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the method comprising the steps of 

According to a further aspect of the invention there is provided a computer program product comprising machine readable program code recorded on a machine readable recording medium for controlling the operation of a data processing apparatus on which the program code executes to perform a method of determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the method comprising the steps of 

According to a further aspect of the invention there is provided a system for determining a discrete boundary for an object to be rendered into a raster pixel image having a plurality of scanlines the system comprising 

The embodiments of the present invention are also described with reference to the tables listed at the end of the detailed description and before the claims in which 

Table 1 illustrates the application of the rounding rules of the present disclosure to the line segments shown in 

Table 2 illustrates the application of the rounding rules of the present disclosure to the line segments shown in 

Table 3 illustrates the application of the rounding rules of the present disclosure to the line segments shown in and

Table 4 illustrates the application of the rounding rules of the present disclosure to the line segments shown in .

The present disclosure relates to an efficient and accurate method for the realization of a rotation invariant object boundary. Specifically rules are defined for rendering objects that have been rotated 90 180 or 270 degrees where the reference rotation is 0 degrees and the reference pixelization rule is the ceiling rounding rule.

Data is passed to the graphics rendering system from the GDI layer as a series of drawing commands or graphic objects . Typically as a minimum these drawings commands specify 

The graphics rendering system converts each graphics object into a raster equivalent. There are numerous algorithms available to achieve a final rendered display depending on system requirements and the requirements of the final output. A well known algorithm is the Painter s Algorithm where each object is rendered to a framestore or page buffer as it is received from the GDI layer . Objects with a higher z order are simply rendered to the frame buffer overwriting any previously rendered object. Compositing can be carried out by calculating pixel data for a new object and combining such pixel data with pixel data already in the frame buffer.

Another method of rendering is a two stage approach where in the first stage the graphics objects to be rendered are converted into an intermediate format known as a display list in which objects are stored in an edge based format. The second stage involves rendering the display list one scanline at a time. No matter which type of graphics rendering system is used each object must eventually be converted to pixels.

Graphics applications provide many different types of graphics objects such as bitmaps text flat colored fill regions and styled lines. A user can use these graphics objects to create a page of graphics data as desired. The graphics rendering system may at times be requested to render a page at 90 180 or 270 degrees rotation.

For applications that lack the ability to rotate pages or for graphics rendering systems that can provide rotated output or special purpose outputs that require rotation the graphics rendering system needs to carry out the rotation in order to produce the required output. In this case the graphics objects are received from the graphics application via the GDI layer as unrotated objects. The GDI layer may provide an explicit command to tell the graphics rendering system that a page should be rotated and or each individual object may have a related page transform matrix. When creating special purpose outputs the graphics rendering system may manipulate the transform matrix of objects before the objects are rendered in order to meet user requirements. The graphics rendering system uses the object page transform to rotate each object into the desired position. An object is rotated by applying the transform matrix to every point describing the boundary of the object. A boundary for the rotated object may then be realized using the methods described below.

A Fixed point number is an integer that is used to represent a fractional number. In binary format a specified number of bits is used to represent the fractional part of a number and a specified number of bits are used to represent the integer part of a number.

Rounding rules describe the way in which a point on a path is rounded to produce a resulting pixedge. shows a pixel delimited by the four points P P P and P. The pixel has four pixedges P P P P P P and P P . Typically for each scanline on which a simple object lies left and right pixedges are determined from the left and right side of the object. The left and right pixedges describe the area in which the object s pixels are to be activated on the scanline. The rounding rules consist of a y rounding rule and an x rounding rule which are used together to identify pixedges of an object.

The y rounding rule is used to determine the first and last scanline on which to calculate an x crossing. An x crossing is the point at which a segment leaves a scanline.

X rounding rules are used to round an x crossing value to an integer value to define the start of a pixedge. The type of x and y rounding rules used in the present disclosure depend on the rotation of the object they are being applied to.

The GDI pixelization rule uses the Grid Intersection Quantization rule in order to determine which pixels are activated by a path. Since this rule is cumbersome to calculate the rule can be closely approximated by the y ceiling rounding rule and the x ceiling rounding rule. Collectively these rounding rules are known as the ceiling rounding rules.

For any real number N the ceiling of N written as ceiling N is the smallest integer greater than or equal to N. Also the floor of N written as floor N is the greatest integer less than or equal to N.

A renderer may use the above pixelization rules to quantize the left and right sides of an object and thus define the area in which pixels are to be activated.

Shown in is an example object that has been pixelized by applying the ceiling rounding rules to the object boundary to produce pixel data having boundary . In the example a scanline N has the Y N line as its upper border. In the example the smallest y position is 0.6 at point 3.7 0.6 . Applying the y ceiling rounding rule the ceiling of this number is 1 so this is the first scanline at which x crossings should be calculated. The maximum y value is 8.5. Applying the y ceiling rounding rule to this yields a scanline value of 8. Therefore whenever the given path crosses any scanline between 1 and 8 inclusive an x crossing needs to be calculated. For each new scanline the boundary crosses a horizontal pixedge is created to join the vertical pixedges that were determined using the x rounding rule. Vertical pixedges and are created from applying the x ceiling rounding rule to the point at which the boundary crosses scanline 3 and scanline 2 respectively. Horizontal pixedges and show the application of the y ceiling rounding rule which define the limits of the discrete boundary of the object path .

The resulting pixedges define the boundary of the object and hence which pixels are activated. For example consider the x crossings in at the positions 2.8 2 and 2.1 3 . The x rounding rule is used to convert a real x crossing value to an integer x value. The resulting value is the starting position of a pixedge. Thus using the x ceiling rule the real x crossing at 2.8 is converted to an integer value of 3 and the real x crossing at 2.1 is also converted to an integer value of 3. Consequently the realized boundary includes the two pixedges at 1360.

The x floor rule is implemented by taking the x crossing value as the floor of the current x position i.e. floor x .

When applying the standard ceiling rounding rules to the path of a rotated object and the pixelization rules are not altered there will always be cases where the unrotated object looks different to a rotated object.

For example consider an object boundary that has been rotated 90 degrees. The rounding rules applied to this object are applied as if the axes have been swapped in the sense of the original orientation . This means the path of the original boundary will cross at different points on the axis when compared with the unrotated case. This typically introduces differences between the rotated and unrotated object pixel boundaries.

An example of this pixelization error can be seen in . shows a diamond delimited by the coordinates 6 2 10 6 6 10 and 2 6 . shows diamond which is diamond rotated by 90 degrees. Diamond has coordinates 8 2 12 6 8 10 and 4 6 . Applying the ceiling rounding rules to the diamonds and produces the rendered objects and respectively. shows the rendered object which is object of rotated by 90 degrees. To be rotation invariant object should be the same as the rendered object of . It can be clearly seen that there are some differences in the rendered objects and . The differences are the result of using the same pixelization rule for different rotations.

In some instances it may be acceptable to have slight inaccuracies in object boundaries but in other cases the inaccuracies may have undesirable results for example where two objects lie close together. This case is illustrated in . The two objects lie side by side. The results of rendering the objects using the ceiling rounding rules are shown in . The resulting rendered objects lie side by side perfectly. However when the objects are rotated by 90 degrees and then rendered with the ceiling rounding rules the resulting rendered objects overlap as shown in . This would not be a problem if the adjoining objects are opaque since the top most object paints over any previously rendered pixels. However if the adjoining objects have raster operations that require compositing of the two sets of pixels then any pixels that overlap may come out as a completely different pixel color to the original two objects . This different pixel color may contrast with the original objects and produce unacceptable output as shown for example in pixels in .

Another problem case is where the rendering leaves a gap between two objects. On low resolution devices say 600 dpi and below a one pixel gap may be highly visible especially if the contrast between the two objects and the background color is large. This problem arises where the unrotated version of rendered objects line up perfectly but a rotated version of the objects results in a shifting of one object s boundaries producing a gap. shows two objects rendered from their respective boundaries . shows the same two boundaries rotated 90 degrees and the resulting rendered objects . The rendered objects have a one pixel gap between them which is obviously unacceptable when compared to the unrotated example of . Even though the examples shown are simple it can be seen that objects with highly complex paths could produce many discrepancies between rotated and unrotated cases.

Such problem cases may arise because object boundaries having path segments that pass through a scanline on an exact x integer position produce different pixedges depending on the rotation of the object boundary. Typically there will be a number of path segments that pass through integer positions on any one page of graphics data. Hence to achieve correctly rotated page output such segments need to be handled differently.

The method of the present disclosure rotates an object by applying a transformation matrix before the object is rendered. Then upon rendering rules that are dependent on the rotation and height of individual path segments are used to render the object in order to achieve rotation invariant rendering. In applying the rules a shift factor is determined for application to part of an object s boundary to ensure that the object is rendered correctly. The following section derives the maximum shift for a segment.

A general edge tracking equation X n is derived to describe the position of a line segment at any given scanline in terms of an integer and fractional part. From this equation the allowable maximum shift that a line segment can be moved along the x axis may be defined. This derived shift is the maximum shift such that only those x crossings that occur at an x integer crossing position will be affected by the rounding rules.

This is illustrated by the arbitrary segment Sshown in . The equation of the line segment is represented as X n . Sis represented by the two points Pand P where P P. Line Shas a negative slope.

X n gives the real x crossing value for a given scanline n. X n represents the general edge tracking equation.

int to fixAB x is a function that is equivalent to multiplying x by 2 where A is the number of bits used to represent the integer part of the fixed point number A. B and B is the number of bits used to represent the fractional part of the fixed point number A. B. This function is used to convert an integer x value to the fixed point number A. B.

D Ddescribes the slope of the line segment. Since Dis 0 Ddetermines whether the slope is positive or negative.

 represents the modulo operation. This operator returns the integer remainder from an integer division calculation. Whether or not the modulo operator can return a negative number is platform compiler specific and is not important to the method of the present disclosure.

The following calculations are carried out using fixed point numbers. This is of significance because of the use of the modulo operator. Even though the modulo operator returns an integer value the result may actually represent a fractional number since the calculations are carried out with fixed point numbers.

From part N of equation 1 i.e. the fractional part of the incremental edge tracking equation the minimum fractional position that can be represented is 

For pixedge output that is invariant upon page rotation the rendering module which tracks a segment to every scanline must be able to accurately shift the line segment by an amount less than or equal to delta x in the x direction. Imposing this limit on the shift ensures that integer x crossings are eliminated without affecting the rounding rules for other x crossings.

If a value larger than delta x is used then it is possible that an x crossing that occurs for example a distance of

In the line S has been shifted by delta x to produce the line segment S S. The crossing points of S S are shown as CS and CS. If the ceiling rounding rule is applied to the line segment S S then crossings CS and CS are both rounded up to produce the pixedges PE S and PE S respectively. It can be seen that the crossing CS produces a different pixedge compared to the original crossing point C in . However the crossing point CS produces the same pixedge as crossing C. This illustrates the aim of the delta x shift which is to only affect segments that pass through a scanline at an integer x position. shows line segment S shifted by delta x plus where is an arbitrary positive number. The shifted line segment is labeled S S . In this case the line segment S has been shifted by a value greater than delta x and this has caused not only the original integer crossing C now labeled CS to produce a different pixedge but the original crossing C now labeled CS  also produces a different pixedge. This is because the crossing point C has been shifted across a scanline position and it cannot be guaranteed to produce the same pixedge as the original crossing point. Thus line segments should be shifted by delta x or less to avoid producing errant pixedges.

The rotation rules described below accurately render an object at rotations of 90 180 and 270 degrees. For rotations of 90 or 270 degrees negatively sloped line segments that have integer x crossings produce rotation variant pixedges and therefore need to be shifted off the integer value so as to produce the correct pixedge. As mentioned previously the aim of the shifting is to nudge a segment off an integer crossing value without affecting the rounding result of any original non integer x crossing. This shift combined with the rotation rules ensures that the lines can be accurately rendered.

The maximum shifting value delta x that a renderer can shift a segment is derived from the general edge tracking equation. This equation describes the real x value at any integer scanline that a segment passes through in terms of an integer and a fractional part. The position of the segment is limited to discrete values where the discrete values depend on the ability of the renderer. This limitation is not necessarily the same as that used to represent the points of the segment. For example the points of a segment may be represented in 28.4 fixed point format but the renderer may use 18.14 fixed point format for edge tracking as this provides greater accuracy in determining the position of the segment at a particular scanline.

The rotation rules assume that the reference rule i.e. the rules used for 0 degrees rotation produces a correctly rendered object. The reference rules used in the described arrangement are the ceiling rounding rules. The rules are dependent on the reference case using the ceiling rounding rules that is the rotation rounding rules will not work if the ceiling rounding rules are not used as a reference for 0 degrees rotation.

However it will be appreciated that an analogous set of rotation rules may be developed for the case where the floor rounding rules are used for unrotated objects.

The following pixelization rules are used to render an object after the object has been rotated by the specified amount.

For objects that are to be rotated 90 degrees the following rules are applied to each adjacent pair of points defining a segment in the object s path when determining pixedges. The rules are applied after the 90 degrees transformation matrix has been applied to each point within the object s path. That is the object is rotated before the pixedges are determined.

For objects that are to be rotated 180 degrees the following rules are applied to each adjacent pair of points defining a segment within the object s path when determining the pixedges. The rules are applied after the 180 degrees transformation matrix has been applied to each point within the object s path. That is the object is rotated before the pixedges are determined.

Steps A and B are the y floor rounding rule. Note that Step A can be applied object wise that is to all the segments in the object in a single step.

For objects that are to be rotated 270 degrees the following rules are applied to each adjacent pair of points defining a segment within the object s path when determining the pixedges. The rules are applied after the 270 degrees transformation matrix has been applied to each point within the object s path. That is the object is rotated before the pixedges are determined.

Step A and Step B are mutually exclusive and may be carried out in any order. If Step B is carried out first it can be applied to the original path such that all the segments are shifted in a single step. Steps B and C are collectively the y floor rounding rule.

For an A.B fixed point input space the renderer must be able to shift a segment by a delta x value of 1 2D or less.

For the sake of clarity an object s pixel space for any given scanline is the area in which pixels are rendered with the object s color or image information.

The application of the rounding rules is now discussed in further detail with reference to B A B and C.

Shown in is a diagram of four lines L L L and L. Also shown are the resulting pixedges E E E E produced by applying the ceiling rounding rules to the four lines L L L L respectively.

The following describes the determination of the edges E E E and E by applying the ceiling rounding rules that is the x ceiling rounding rule and the y ceiling rounding rule.

The line segment L starts at point 0 1 and ends at point 2 5 . Applying the y ceiling rounding rule the starting scanline is ceiling 1 1 and the ending scanline is ceiling 5 1 4. Thus the x crossing positions should be calculated at scanline 1 2 3 and 4. These crossings are indicated by the black dots at 0.0 1 0.5 2 1.0 3 and 1.5 4 shown on L. Applying the x ceiling rounding rule to the four dots on L yields the points 0 1 1 2 1 3 and 2 4 . These points make up the pixedges represented by E.

Line segment L starts at 5 1 and ends at 3 5 . Therefore according to the y ceiling rounding rule the start and end scanlines on which x crossings need to be calculated are scanline 1 2 3 and scanline 4. The x ceiling rounding rule is then applied to L at these crossing points to produce the pixedges represented by E.

Line segment L starts at 10 1 and ends at 6 3 . Therefore according to the y ceiling rounding rule the start and end scanlines on which x crossings need to be calculated are scanlines 1 and 2. The x ceiling rounding rule is applied to L at these crossing points to produce the pixedges represented by E.

Line segment L starts at 6 5 and ends at 10 7 . Therefore according to the y ceiling rounding rule the start and end scanlines on which x crossings need to be calculated are scanlines 5 and 6. The x ceiling rounding rule is applied to L at these crossing points to produce the pixedges represented by E.

Table 1 shows the application of the 0 degrees rounding rules to the line segments L L L and L and the resulting vertical pixedges produced.

Shown in are the lines from rotated 90 degrees. L L L and L represent the 90 degree rotated versions of L L L and L respectively. Also shown are shifted versions of L and L denoted L S and L S respectively which result from applying a delta x shift inline with the 90 degrees rotation rules. E E E and E represent the 90 degree rotated versions of the pixedges E E E and E from respectively. Also E LS E L E L and F LS are the pixedges that result from applying the 90 degrees rotation rules to the line segments L L L and L respectively. The nomenclature used is that Lx S is Line x rotated by 90 degrees and shifted according to the rounding rule.

The line L starts at point 7 0 and ends at point 3 2 . According to step A of the 90 degrees rotation rule since the slope of line L is negative it needs to be shifted by delta x in the x direction yielding the line L S. In step B of the 90 degrees rotation rules the y ceiling rounding rule is then applied to L S to determine the first and last scanlines on which the x crossings should be calculated. The y ceiling rounding rule is applied to the start and end positions of the path. The start position of the path is scanline 0. Applying the y ceiling rounding rule to this yields 0. The end position of the path is scanline 2 and applying the y ceiling rounding rule to this yields 1. In step C of the 90 degrees rotation rules the x floor rounding rule is applied to the point at which the path crosses scanline 0 and then scanline 1. Table 2 shows illustrates the application of the 90 degrees rotation rules to the lines L L L and L to determine the vertical pixedges produced. Shown in is E LS which are the pixedges that result from applying the 90 degrees rounding rules to L . It may be seen that E LS produces the same vertical pixedges as E .

Line segment L which starts at 3 3 and ends at 7 5 has a positive slope with DX of 4 therefore according to step A of the 90 degree rotation rules no shifting is required. In step B of the 90 degrees rotation rules the y ceiling rounding rule is used to determine the start and end scanline to determine x crossings. Step B of the 90 degrees rotation rules yields the scanline values of 3 and 4. Step C of the 90 degrees rotation rules the x floor rounding rule is then applied to scanline 3 and 4 to determine the resulting pixedges. Refer to Table 2 for the results of applying the 90 degrees rotation rules to the line L .

Line segment L which starts at 5 6 and ends at 7 10 has a positive slope of 2 therefore according to step A of the 90 degree rotation rules no shifting is required. In step B of the 90 degrees rotation rules the y ceiling rounding rule is used to determine the start and end scanline to determine x crossings. Step B of the 90 degrees rotation rules yields the minimum and maximum scanline values of 6 and 9. Step C of the 90 degrees rotation rules the x floor rounding rule is then applied to scanlines 6 7 8 and 9 to determine the resulting pixedges. Refer to Table 2 for the results of applying the 90 degrees rotation rules to the line L .

Line segment L which starts at 3 6 and ends at 1 10 has a slope of 2. According to step A of the 90 degrees rotation rules since the slope of the line segment is negative the line has to be shifted by delta x. L S represents the line segment L shifted by delta x. Applying step B of the 90 degrees rotation rule the y ceiling rounding rule to the line segment L S to determine the start and end scanlines to determine x crossings yields the minimum and maximum scanline values of 6 and 9. Step C of the 90 degrees rotation rules is then used to determine the pixedges for the line L . Refer to Table 2 for the results of applying the 90 degrees rotation rules to the line L .

The pixedges produced from the line segments L L L and L after applying the 90 degrees rotation rules are shown in as E LS E L E L and E LS respectively. The vertical pixedges which describe the boundary of the lines L L L and L are in the same position as the vertical pixedges E E E and E that were created from an unrotated object and then rotated 90 degrees.

Shown in are the lines from rotated 180 degrees. L L L and L represent the 180 degree rotated versions of L L L and L respectively. Also shown are shifted versions of L L L and L denoted L S L S L S and L S respectively which result from applying a 1 scanline vertical shift in line with the 180 degrees rotation rules. E E E and E represent the 180 degree rotated versions of the pixedges E E E and E from respectively.

The following describes an example of using the 180 degrees rotation rules to achieve a pixel accurate output consistent with the unrotated case. The line segment L starts at point 8 3 and ends at point 10 7 . According to step A of the 180 degrees rotation rules the line segment must be shifted by 1 scanlines resulting in the line segment L S. Then according to step B of the 180 degrees rotation rules the y floor rounding rule is used to determine the first and last scanlines on which x crossings should be calculated. The y floor rounding rule is applied to the start and end positions of the path L S. The start position of the path is scanline 2 and applying the y floor rounding rule produces a result of scanline 3. The end position of the path is scanline 6 and applying the y floor rounding rule to this yields scanline 6. In step C of the 180 degrees rotation rules the x floor rounding rule is applied to the point at which the path crosses scanlines 3 4 5 and then scanline 6. Table 3 shows results of applying the 180 degrees rotation rules to the lines L L L and L to determine the vertical pixedges produced. shows E LS which is the pixedges that result from applying the 180 degrees rotation rules to L . As may be seen E LS produces the same vertical pixedges as E .

Line segment L starts at 7 3 and ends at 5 7 . Applying step A of the 180 degrees rotation rules results in the line segment L S. Then applying step B of the 180 degrees rotation rules the y floor rounding rule is used to determine the start and end scanlines to determine x crossings from the line segment L S. Step B of the 180 degrees rotation rules yields the minimum and maximum scanline values of 3 and 6. Step C of the 180 degrees rotation rules the x floor rounding rule is then applied to scanlines 3 4 5 and 6 to determine the resulting pixedges. Refer to Table 3 for the results of applying the 180 degrees rotation rules to the line L .

Line segment L starts at 4 5 and ends at 0 7 . Applying step A of the 180 degrees rotation rules results in the line segment L S. Then applying step B of the 180 degrees rotation rules the y floor rounding rule is used to determine the start and end scanline to determine x crossings. Step B of the 180 degrees rotation rules yields the minimum and maximum scanline numbers of 5 and 6. Step C of the 180 degrees rotation rules the x floor rounding rule is then applied to scanlines 5 and 6 to determine the resulting pixedges. Refer to Table 3 for the results of applying the 180 degrees rotation rules to the line L .

Line segment L starts at 0 1 and ends at 4 3 . Applying step A of the 180 degrees rotation rules results in the line segment L S. Then applying step B of the 180 degrees rotation rules the y floor rounding rule is used to determine the start and end scanline to determine x crossings. Step B of the 180 degrees rotation rules yields the minimum and maximum scanline numbers of 1 and 2. Step C of the 180 degrees rotation rules the x floor rounding rule is then applied to scanlines 1 and 2 to determine the resulting pixedges. Refer to Table 3 for the results of applying the 180 degree rotation rules to the line L .

The pixedges produced from the line segments L L L and L after applying the 180 degrees rotation rules are shown in as E LS E LS E LS and E LS respectively. Again the vertical pixedges which describe the lines L L and L are in the exact same position as the vertical pixedges E E E and E that were created from an unrotated object and then rotated 180 degrees.

The following describes an example of using the 270 degrees rotation rules to achieve a pixel accurate output consistent with the unrotated case. The line segment L starts at point 5 8 and ends at point 1 10 . According to step A of the 270 degrees rotation rules line segment L must be shifted by 1 scanline. Also according to step B of the 270 degrees rotation rules since the slope of the line L is 2 4 0.5 the line L must be shifted by delta x. The resulting line is shown as line L S. In step C of the 270 degrees rotation rules the y floor rounding rule is used to determine the first and last scanlines on which the x crossings should be calculated. The y floor rounding rule is applied to the start and end positions of the path L S. The start position of the path is scanline 7 and applying the y floor rounding rule to this produces a result of scanline 8. The end position of the path is scanline 9 and applying the y floor rounding rule to this yields scanline 9. In step D of the 270 degrees rotation rules the x ceiling rounding rule is applied to the point at which the path crosses scanlines 8 and scanline 9. Table 4 shows the result of applying the 270 degrees rotation rules to the lines L L L and L to determine the vertical pixedges produced. shows E LS which is the pixedges that result from applying the 270 degrees rotation rules to L . As may be seen E LS produces the same vertical pixedges as E .

Line L starts at 1 5 and ends at 5 7 it has a slope of 2 4 0.5. Applying step A of the 270 degrees rotation rules results in the line segment L S. Since the slope of the line L is not negative according to step B of the 270 degrees rotation rules the line does not need to be shifted by delta x. So step C of the 270 degrees rotation rules is applied to the line L S to determine the start and end scanlines to determine x crossings. Step C of the 270 degrees rotation rules yields the scanlines 5 and 6. Step D of the 270 degrees rotation rules the x ceiling rounding rule is then applied to scanlines 5 and 6. Refer to Table 4 for the results of applying the 270 degrees rotation rules to the line L .

Line L starts at 1 0 and ends at 3 4 it has a slope of 4 2 2. Applying step A of the 180 degrees rotation rules results in the line segment L S. Since the slope of the line L is not negative according to step B of the 270 degrees rotation rules the line does not need to be shifted by delta x. Applying step C of the 270 degrees rotation rules the y floor rounding rule to L S produces the minimum and maximum scanline values of 0 and 3. Step D of the 270 degrees rotation rules the x ceiling rounding rule is then applied to scanlines 0 1 2 and 3 to determine the resulting pixedges. Refer to Table 4 for the results of applying the 270 degrees rotation rules to the line L .

Line L starts at 7 0 and ends at 5 4 and has a slope of 2. According to step A of the 180 degrees rotation rules the line segment L must be shifted by 1 scanlines. According to step B of the 270 degrees rotation rules the line L also needs to be shifted by delta x. The resulting shifted line is shown as L S. In step C of the 270 degrees rotation rules the y ceiling rounding rule is used to determine the start and end scanline to determine x crossings. Step C of the 270 degrees rotation rules yields the minimum and maximum scanline values of 0 and 3. Step D of the 270 degrees rotation rules the x ceiling rounding rule is then applied to scanlines 0 1 2 and 3 to determine the resulting pixedges. Refer to Table 4 for the results of applying the 270 degrees rotation rules to the line L .

The pixedges produced from the line segments L L L and L after applying the 270 degrees rotation rules are shown in as E LS E LS E LS and E LS respectively. Again the vertical pixedges which describe the lines L L L and L are in the exact same position as the vertical pixedges E E E and E that were created from an unrotated object and then rotated 270 degrees.

In a graphics rendering system it may be appropriate to use different edge types depending on the object to be drawn. For example a PostScript Edge may be used to efficiently render thin lines because every pixel that is touched by a PostScript edge is turned on whereas GDI edges can be used to efficiently define the boundary of an object. Each edge type has a different set of rules used to determine the pixels that are activated. In a page to be rendered the graphics rendering system can choose the edge type that is to be associated with a particular type of object depending on the required outcome. Therefore there can be many different types of edges in a display list of a page to be rendered. Typically the renderer updates an edge as the edge passes across the scanline. However as mentioned earlier this is very inefficient. A more practical approach is to group all edges of the same type together and then to update those edges in a batch at the end of the scanline according to their pixelization rule. The grouped edges are passed into their specific update function according to their edge type. The update function of the current edge type can then update each edge in the group using the same pixelization rule. This means that the update functions specific to each edge type are only ever called once per scanline thus saving function overhead time. Such an arrangement may greatly improve the speed at which the rendered can produce pixel data.

As discussed above not all objects in the display list will necessarily appear in the region currently being rendered. The rendering system may only be required to render a portion of a page or the objects may actually lie outside the bounds of the page. To overcome inefficiency problems that arise in tracking off the page edges to the start scanline of the region to be rendered or current scanline the present arrangement can fast track an edge to the current scanline. The display list is read in and all the edges that are active or become active on or before the scanline to be rendered are fast tracked to the current scanline. This is done by determining the intersection of each edge with the current scanline and updating the x position of the edge accordingly. This is achieved by using the linear equation of a line to find the edge position at the current scanline. Any edges that do not reach the current scanline can simply be discarded. This method avoids the need to process all scanlines before the current scanline. This greatly reduces the processor effort that is needed to start rendering from the current scanline and hence speeds up the rendering process when there are edges that start outside of the current region to be rendered.

A method of rendering graphical objects that uses the rotation invariant rounding rules is described below with reference to . The principles of the method have general applicability to the rendering of graphical objects. However for ease of explanation the steps of the method are described with reference to the rendering of graphical objects for printing on a page. It is not intended that the present invention be limited to the described arrangement. For example the method may have application to the rendering of graphical objects for display on a liquid crystal or other display device that has the characteristic that dots that comprise the displayed image are either fully present or fully absent. Such display devices are often driven by embedded computing systems having extremely constrained memory and performance.

The method is preferably practiced using a general purpose computer system such as that shown in wherein the processes of may be implemented as software such as an application program executing within the computer system . In particular the steps of the method described below are effected by instructions in the software that are carried out by the computer. The instructions may be formed as one or more code modules each for performing one or more particular tasks. The software may also be divided into two separate parts in which a first part performs the method and a second part manages a user interface between the first part and the user. The software may be stored in a computer readable medium including the storage devices described below. The software is loaded into the computer from the computer readable medium and then executed by the computer. A computer readable medium having such software or computer program recorded on it is a computer program product. The use of the computer program product in the computer preferably effects an advantageous apparatus for implementing the arrangements described herein.

The computer system comprises a computer module input devices such as a keyboard and mouse output devices including a printer and a display device . A Modulator Demodulator Modem transceiver device is used by the computer module for communicating to and from a communications network for example connectable via a telephone line or other functional medium. The modem can be used to obtain access to the Internet and other network systems such as a Local Area Network LAN or a Wide Area Network WAN .

The computer module typically includes at least one processor unit a memory unit for example formed from semiconductor random access memory RAM and read only memory ROM input output I O interfaces including a video interface and an I O interface for the keyboard and mouse and optionally a joystick not illustrated and an interface for the modem . A storage device is provided and typically includes a hard disk drive and a floppy disk drive . A magnetic tape drive not illustrated may also be used. A CD ROM drive is typically provided as a non volatile source of data. The components to of the computer module typically communicate via an interconnected bus and in a manner which results in a conventional mode of operation of the computer system known to those in the relevant art. Examples of computers on which the described arrangements can be practiced include IBM PCs and compatibles Sun Sparcstations or alike computer systems evolved therefrom.

Typically the application program is resident on the hard disk drive and read and controlled in its execution by the processor . Intermediate storage of the program and any data fetched from the network may be accomplished using the semiconductor memory possibly in concert with the hard disk drive . In some instances the application program may be supplied to the user encoded on a CD ROM or floppy disk and read via the corresponding drive or or alternatively may be read by the user from the network via the modem device . Still further the software can also be loaded into the computer system from other computer readable media. The term computer readable recording medium as used herein refers to any storage medium that participates in providing instructions and or data to the computer system for execution and or processing. Examples of storage media include floppy disks magnetic tape CD ROM a hard disk drive a ROM or integrated circuit a magneto optical disk or a computer readable card such as a PCMCIA card and the like whether or not such devices are internal or external of the computer module . Examples of computer readable transmission media that may communicate the instructions and or data include radio or infra red transmission channels as well as a network connection to another computer or networked device and the Internet or Intranets including email transmissions and information recorded on websites and the like.

The methods and can alternatively be implemented in dedicated hardware such as one or more integrated circuits performing the functions or sub functions of and . Such dedicated hardware may include graphic processors digital signal processors or one or more microprocessors and associated memories.

The steps of the method are performed on a scanline basis as a rendering system generates runs of pixel data from one edge crossing to the next and are performed on demand.

In the method an image is rendered utilizing a display list or array of graphical objects representing the image. At the final output stage or at the time of deducing pixel runs color correction and half toning of the pixel data may be carried out before being output for printing on a page.

The method is preferably implemented as an application program being resident on the hard disk drive and being read and controlled in its execution by the processor .

The method begins at step after which step is carried out. In step the processor detects a first graphical object to be rendered. At the next step the graphical object is rotated according to its transform requirements. This may be a rotation of either 90 180 270 degrees or no rotation. For objects that are rotated 180 or 270 degrees each object is also shifted by the equivalent of 1 scanline as per the rotation rules previously described. At the next step the graphical object is decomposed by the processor into a set of edges defining the object priority information for the object a raster operation for the object and a corresponding winding rule for the object. The method continues at the next step where the set of edges defining the object is added to an edge database configured within memory . At the next step if all objects of the image have been received by the processor then the method continues at the next step . Otherwise the method returns to step to process further objects.

At step the edges stored in the edge database configured within memory are sorted according to ascending y coordinate ascending x coordinate and ascending priority order ie z order . At the next step the processor selects a scanline for the image to be rendered and continues to step . In step the discrete x crossing positions for edges entering and exiting the scanline are calculated using method or depending on the rotation of the object represented by the active edges. For objects that have not been rotated the method is used to determine the x crossing positions of the edges. For 90 180 and 270 degrees rotation the methods and are used respectively.

In step when applying method or a shift by delta x that has been applied to the current segment does not affect the starting position of the next segment. A copy of the original segment is shifted so as not to affect the position of any other segment. At step if the current scanline is the first scanline to be rendered but there are one or more edges that start before this scanline then the method to fast track these edges to the current scanline can be used. This involves determining the intersection of each edge that starts before the current scanline with the current scanline. Since the starting position and the slope of the edge is known at any point the intersection can easily be determined by simple linear equations. An example of fast edge tracking is shown later.

Once the discrete edge positions have been determined in step for the current scanline the method proceeds to step . In step for each pixel run on the scanline selected at step objects having an edge entered by the scanline are activated and objects having an edge exited by the scanline are de activated. The method then proceeds to step . At step fill data for all visible objects of the current pixel run is composited together to generate data for the pixel run. Also at step the data for the current pixel run may be halftoned and or color corrected before being output for printing. At the next step if all pixel runs have been processed for the current scanline then the method continues at the next step . Otherwise the method returns to step to process further pixel runs.

At step if all scanlines have been processed for the image to be rendered then the method concludes at step . Otherwise the method returns to step where a next scanline is selected by the processor .

The method starts at step after which step is carried out. At step a segment is received from step of method . The method then proceeds to step .

At step the x ceiling rule is used to determine the x crossing point for the segment at the current scanline. The method then proceeds to step in which the x crossing is returned to step of the method .

The method starts at step after which step is carried out. At step a segment is received from step of method . The method then proceeds to step . At step if this is the first time this segment has been encountered by method the method proceeds to step otherwise the method proceeds to step .

At step if the segment has a negative slope the method proceeds to step otherwise the method proceeds to step .

At step delta x 1 2D is subtracted from the current edge x position. Since delta x is dependent on D the value of delta x is calculated to determine the maximum shift which the renderer may apply to the segment. If the renderer can shift the points by delta x or less without needing to increase the precision of the segment then the current precision is used. If the current precision cannot shift the line by delta x or less then the precision used to calculate the segment position is increased in proportion to the required precision. The segment is then shifted by delta x using the increased precision. The fixed point space in one implementation is 28.4 so delta x is equivalent to 1 16 D for the lowest precision case. The method then proceeds to step .

At step an integer x crossing for the segment is determined for the current scanline using the x floor rule. The method then proceeds to step in which the x crossing is returned to the step of the method .

The method starts at step after which step is carried out. At step a segment is received from step of method . The method then proceeds to step . At step the x floor rule is used to determine the x crossing point for the segment at the current scanline. The method then proceeds to step in which the x crossing is returned to the step of the method .

The method starts at step after which step is carried out. At step a segment is received from step of method . The method then proceeds to step . At step the method determines if this is the first time this segment has been encountered and if so the method proceeds to step . If the segment has been previously encountered the method proceeds to step . At step the segment is tested to see if it has a negative D i.e. whether the slope of the segment is negative. If the slope is negative then the method proceeds to step otherwise the method proceeds to step .

At step delta x 1 2D is added to the current edge x position. Since delta x is dependent on D the value of delta x is calculated to determine the maximum shift which the renderer may apply to the segment. If the renderer can shift the points by delta x or less without needed to increase the precision of the segment then the current precision is used. If the current precision cannot shift the line by delta x or less then the precision used to calculated the segment position is increased. The segment is then shifted by delta x using the increased precision. The fixed point space in one implementation is 28.4 so delta x is equivalent to 1 16 D for the lowest precision case. The method then proceeds to step .

At step the x ceiling rule is used to determine the x crossing point for the edge at the current scanline. The method then proceeds to step in which the x crossing is returned to step of the method .

For simplicity only the edges that are entering and exiting the scanline are shown. Also each edge that is shown is made up of one exactly one segment. Step of method determines the x position of the edges for the current scanline. Typically the position of an edge on a scanline is determined from the x position of the edge on the previous scanline and the slope of the edge using the general edge tracking equation X n . Step then uses the x crossing positions of the edges to determine the discrete position of the edge i.e. the pixedge by using either method or depending on the rotation of the original objects. In this example all the objects have been rotated by 90 degrees and so the method is called upon to determine the discrete position of the edges on scanline . Method accepts segments and since each edge in this case consists of a single segment the edge can be passed to method . Method uses the 90 degrees rounding rules to determine the discrete position of each edge on scanline . After step is carried out the discrete position of the edges has been determined for the current scanline and the method can proceed to step . Steps and are then carried out and repeated for each pixel run on the current scanline. Hence pixel runs and then are rendered sequentially to produce the rendered pixels of scanline . Pixel run is the run of pixels from the left of the page to the left edge of object . No objects are active and so the background fill is rendered. Pixel runs and extend from the left edge to the right edge of object . The fill of object is rendered in pixel run . Pixel run extends from the right edge of object to the right edge of object . Object is visible in pixel run . Finally pixel run contains the background fill from the right edge of object to the right of the page .

In many cases a page has a single rotation related to it such that all objects on the page are rotated by the same amount. For example all objects on the page may be rotated by 270 degrees. It is however feasible to relate a rotation to an edge such that individual objects may be handled differently depending on the rotation of its edges.

The aim of the method described above is to shift a segment off an integer position under certain circumstances . A point must lie exactly on an integer position to be regarded as lying on the integer value. In some systems in which the method is implemented the exact position of a segment cannot be determined. Consider the segment 0 0 3 9 which has a slope of 9 3 or 3 1. The equation for the segment is y 3 1 x and accordingly x 1 3 y. Exact integer crossings occur when y is a multiple of 3 or is 0. However a computer renderer may use a less precise slope for example 0.33. Then the x crossing position for the segment on scanline 3 would be calculated as 0.99. If a rendering system is able to track the exact position of a segment with guarantee of no overflow or loss of precision or to determine when a segment passes through an exact integer position then the alternative simplified method may be used to track and pixelise the segment. The following rules may be used if the exact position of a segment can be determined in particular if it can be determined that segment passes through a scanline at an integer position. It is no longer necessary to calculate a shifted version of entire segments but instead a shift is performed only for those crossings that pass through integer points in the circumstances described in the following rules.

If the segment has a negative slope and the current x position is an exact integer position then take floor x 1 otherwise take floor x to determine the edge position.

The method starts at step after which step is carried out. At step a segment is received from step of method . The method then proceeds to step . At step the method determines if the current segment crosses the scanline at an x integer position and has a negative slope. If so the method proceeds to step otherwise the method proceeds to step .

At step the x floor rule is used to determine an x crossing point from which one is subtracted to determine the x crossing position for the edge at the current scanline. Once the x crossing position has been determined the method then proceeds to step .

At step the x floor rule is used to determine the x crossing position for the edge at the current scanline. The method then proceeds to step in which the x crossing is returned to the step of the method .

The method starts at step after which step is carried out. At step a segment is received from step of method . The method then proceeds to step . At step the method determines if the current segment crosses the scanline at an x integer position and has a negative slope. If so the method proceeds to step otherwise the method proceeds to step .

At step the x ceiling rule is used to determine an x crossing point to which one is added to determine the x crossing position for the edge at the current scanline. Once the x crossing point has been determined the method proceeds to step . At step the x ceiling rule is used to determine the x crossing position for the edge at the current scanline. The method then proceeds to step in which the x crossing is returned to step of the method .

The aforementioned methods comprise particular control flows. There are many other variants of the method which use different control flows without departing the spirit or scope of the invention. Furthermore one or more of the steps of the methods may be performed in parallel rather than sequentially.

The foregoing describes only some embodiments of the present invention and modifications and or changes can be made thereto without departing from the scope and spirit of the invention the embodiments being illustrative and not restrictive.

The methods of the present disclosure have the advantage of minimizing the amount of work required to rotate an object. There is no need using the described methods to produce a bitmap or a discrete outline to produce an accurately rendered object that has a rotation invariant boundary.

The methods of the present disclosure determine the precision of the shift needed at render time such that different segment lengths and different resolutions can be handled at the most efficient precision.

