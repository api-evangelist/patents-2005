---

title: System and method for displaying an acceptance status
abstract: A method of parsing a markup-language document includes detecting, in a markup-language document, a start of a first data node of a first node type and identifying a first data definition associated with the first node type. The first data definition specifies defined contents of the first node type. The method further includes adding a first entry associated with the first data node to a data structure and reading, from the markup-language document, contents of the first data node. The method also includes determining a status of the first data node based on the first data definition and the contents read from the first data node and indicating the status of the first data node on a graphical user interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08996991&OS=08996991&RS=08996991
owner: Fujitsu Limited
number: 08996991
owner_city: Kawasaki-shi
owner_country: JP
publication_date: 20050211
---
This invention relates in general to data processing systems and more particularly to encoding and decoding markup language documents.

In recent years the introduction and development of eXtensible Markup Language XML and other data describing markup languages have led to a plethora of applications developed to utilize the flexibility and extensibility of XML and other such markup languages. A wide variety of systems have evolved that are capable of leveraging the advantages of extensible data describing languages including for example e commerce networks mobile communication devices personal data devices and database systems. Because many systems developed to utilize these languages face significant power and space limitations such systems benefit from techniques for processing markup language document with limited memory and computational resource requirements.

In accordance with the present invention certain disadvantages and problems associated with data processing systems have been substantially reduced or eliminated. In particular a system and method for indicating an acceptance status of a markup language data construct is provided.

In accordance with one embodiment of the present invention a method for parsing a markup language document includes detecting in a markup language document a start of a first data node of a first node type and identifying a first data definition associated with the first node type. The first data definition specifies defined contents of the first node type. The method further includes adding a first entry associated with the first data node to a data structure and reading from the markup language document contents of the first data node. The method also includes determining a status of the first data node based on the first data definition and the contents read from the first data node and indicating the status of the first data node on a graphical user interface.

In accordance with another embodiment of the invention a system for parsing a markup language document includes a memory a processor and a graphical user interface GUI . The memory is capable of storing markup language documents. The GUI is capable of displaying a status of one or more data nodes based on information received from a processor. The processor is capable of detecting in a markup language document a start of a first data node of a first node type and identifying a first data definition associated with the first node type. The first data definition specifies defined contents of the first node type. The processor is also capable of adding a first entry associated with the first data node to a data structure and reading from the markup language document contents of the first data node. The processor is also capable of determining a status of the first data node based on the first data definition and the contents read from the first data node and indicating the status of the first data node on the GUI.

Technical advantages of certain embodiments of the present invention include a robust technique for determining completeness of nodes included in markup language documents and improved flexibility for processing non standard markup language formats. Other technical advantages of certain embodiments include effective techniques for displaying information pertaining to the completeness of data nodes. Other technical advantages of the present invention will be readily apparent to one skilled in the art from the following figures descriptions and claims. Moreover while specific advantages have been enumerated above various embodiments may include all some or none of the enumerated advantages.

Generating applications generates data documents that include data structured and formatted in conformance with the XML language or any other text based markup language protocol or standard. Although the description below focuses on particular embodiments of data processing system configured to utilize data documents conforming to the XML language data processing system and or individual components of data processing system may be configured for use with data documents of any appropriate markup language including but not limited to XML Hypertext Markup Language HTML and Standard Generalized Markup Language SGML . Generating application generates pre bound data documents that include data constructs with the same or similar hierarchical structure too the data constructs included in data documents but that have been bound to a particular schema as described in greater detail below. Pre bound data documents may for example utilize numeric delimiters instead of XML style textual delimiters that identify the name or type of the construct being delimited. For the purposes of this description generating applications may generate data documents by accessing a memory of data processing system to retrieve data documents by receiving data documents from another component of data processing system or by itself creating data documents . As one example generating applications may represent web browsers that form XML purchase requests based on user input and transmits the purchase requests to receiving application . As another example generating application may represent an address book application on a desktop computer that saves contact information in data documents and then transmits data documents to a mobile phone or personal digital assistant PDA to be utilized by receiving application .

In particular embodiments generating applications may each represent a software process running on a processor or other suitable electronic computing device. As used in this description and the claims below a processor may represent general purpose computers dedicated microprocessor or other processing device capable of generating processing and or communicating electronic information. Examples of processor include application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs and any other suitable specific or general purpose processors.

In general however generating applications may each represent and or include any collection of software and or hardware appropriate to provide the described functionality. Additionally although illustrates a particular embodiment of data processing system that includes both generating applications and a particular embodiment of data processing system may include either or both generating applications . Furthermore in particular embodiments the same element of data processing system may represent both generating applications and capable of generating both data documents and pre bound documents as appropriate.

Receiving application receives data documents from document decoder or other components of data processing system and performs some task or operation with data documents . Data processing system may include a network or other suitable connectivity components to connect generating application and receiving application . As one example receiving application may represent an application running on a networked computer in data processing system that processes customer orders contained in data documents . As another example receiving application represents an application running on a mobile communication device capable of accessing contact information uploaded onto the device as data documents . Additionally in a particular embodiment generating application and receiving application may represent the same application process or group of components during different phases of operation or while performing different tasks. For example generating application may represent an application that generates and stores data documents and receiving application may represent that same application when the application subsequently retrieves data documents from memory . In general receiving application may represent or include any collection of software and or hardware appropriate to provide the described functionality. In particular embodiments receiving application represents a software process running on a computer processor.

Schema compiler compiles uncompiled schema to produce compiled schema . In a particular embodiment schema compiler generates complied schema that represents one or more arrays of primitive data. Schema compiler also provides compiled schema to generic encoder and other components of data processing system . Schema compiler may represent components modules or any other appropriate portion of generic encoder or may represent component or components physically and or logically distinct from generic encoder . In particular embodiments schema compiler represents a software process running on a computer processor.

Generic encoder binds data documents to specified data definitions and encodes data documents to create encoded documents . More specifically in particular embodiments generic encoder receives data documents from generating application and compiled schema from schema compiler . Generic encoder then binds one or more data nodes in data documents to definitions in compiled schema and encodes the bound data nodes to produce encoded documents . Generic encoder may represent or include any collection of hardware and or software suitable to provide the described functionality. Furthermore generic encoder may represent a portion of generating application or receiving application or may represent components physically and or logically distinct from either. In particular embodiments generic encoder represents a software process running on a computer processor.

Specific encoder encodes pre bound documents to create encoded documents . More specifically in particular embodiments specific encoder receives data documents that generating application has already bound to definitions in compiled schema . In such an embodiment specific encoder may not be responsible for any binding and may instead encode pre bound documents received from generating application . Specific encoder may represent or include any collection of hardware and or software suitable to provide the described functionality. Furthermore specific encoder may represent a component module or other portion of generating application or receiving application or may represent components physically and or logically distinct from either. Although and the description below describe an embodiment of data processing system that includes for purposes of illustration both generic encoder and specific encoder particular embodiments of data processing system may include one or both of generic encoder and specific encoder . In particular embodiments specific encoder represents a software process running on a computer processor.

Document decoder receives and decodes encoded documents for use by receiving application . More specifically document decoder references compiled schema to generate decoded documents from encoded documents . Decoded documents contain data nodes or other markup language data constructs that include information substantially equivalent to information included in data nodes of data documents . In a particular embodiment decoded documents may be identical to original data documents . In particular embodiments document decoder represents a software process running on a computer processor.

Memory stores data documents encoded documents decoded documents and or values and parameters utilized by elements of data processing system during operation. Memory may comprise any collection and arrangement of volatile or non volatile local or remote devices suitable for storing data such as for example random access memory RAM devices read only memory ROM devices magnetic storage devices optical storage devices or any other suitable data storage devices. The description below uses the term memory to refer to any such memory device or memory devices in data processing system coupled to data processing system or otherwise accessible by data processing system or elements of data processing system . Thus any two references to memory in this description may or may not refer to the same physical device depending on the configuration and contents of a particular embodiment of data processing system .

Although illustrates a particular embodiment of data processing system that includes a particular number of processors data processing system may in general include any suitable number of processors . Additionally although illustrates an embodiment of data processing system that includes generating application generic encoder specific encoder schema compiler receiving application and document decoder running on separate processors any two or more of these elements may represent software processes running on one or more common processors . As a result these elements may be divided among processors in any appropriate manner.

In operation schema compiler receives or accesses uncompiled schema . Schema compiler may generate uncompiled schema receive uncompiled schema from another component of data processing system retrieve uncompiled schema from memory coupled to schema compiler or acquire uncompiled schema in any other appropriate manner. Uncompiled schema includes one or more definition nodes which define the contents the structure the appropriate number of occurrences and or any other suitable characteristic referred to collectively as defined contents of data nodes defined within recognized in or supported by data processing system . In a particular embodiment data processing system is configured to process XML documents and uncompiled schema represents a document containing XML schemas. Uncompiled schema may however include data definitions of any form appropriate based on the markup language or languages supported by data processing system .

Schema compiler then compiles uncompiled schema to produce compiled schema . In compiling uncompiled schema schema compiler may reduce the size of uncompiled schema by reducing or eliminating redundant or otherwise unnecessary information that is included in uncompiled schema . Schema compiler may also perform any additional processing steps on uncompiled schema based on the characteristics and configuration of uncompiled schema schema compiler and data processing system . discussed below illustrates the contents of an example compiled schema that may be utilized in a particular embodiment of data processing system . After schema compiler has compiled uncompiled schema to produce compiled schema schema compiler may transmit or provide compiled schema to generic encoder . In particular embodiments schema compiler may provide compiled schema to generic encoder by saving compiled schema to memory accessible by both generic encoder and schema compiler .

At an appropriate time generic encoder receives one or more data documents from generating application . Using compiled schema generic encoder binds data nodes to compiled schema and encodes the bound data nodes to produce encoded documents . In binding data nodes generic encoder identifies in compiled schema a particular definition node for each data node in data document based on a node type of the relevant data node . Generic encoder then reduces or eliminates from these data nodes particular information that is redundant or unnecessary in light of the information in definition nodes . This process according to a particular embodiment is described in greater detail below with respect to .

In encoding data documents generic encoder removes restructures reorganizes replaces reformats or otherwise modifies data included in data documents to reduce the size of data documents and or reduce the computational requirements of processing data documents . For example in a particular embodiment of generic encoder generic encoder generates encoded documents that reduce the number of delimiters used in data documents and converts text elements from American Standard Code for Information Interchange ASCII format characters to Unicode Transformation Format UTF 8 byte sequences. The operation of generic encoder is illustrated in greater detail below with respect to .

Specific encoder also encodes information generated by generating application . More specifically specific encoder encodes pre bound documents generated by generating application . Pre bound documents may include one or more bound data nodes as shown in containing information substantially equivalent to data nodes generated by generating application but already bound to compiled schema . In a particular embodiment of specific encoder specific encoder generates encoded documents that reduce the number of delimiters used in pre bound documents and converts text elements from ASCII format characters to UTF 8 byte sequences. The operation of specific encoder is illustrated in greater detail below with respect to .

Document decoder receives encoded documents from generic encoder and or specific encoder and decodes encoded documents to produce decoded documents . In decoding encoded documents document decoder may restructure reorganize replace reformat rearrange or restructure data documents in any appropriate manner to convert encoded documents to a form useable by receiving application . As one example document decoder may convert bound data nodes back to the original data nodes or into data nodes of another form that include substantially similar information to that included in the original data nodes . In a particular embodiment document decoder converts bound data nodes to decoded data nodes representing XML language data constructs. The operation of document decoder is illustrated in greater detail below with respect to .

After decoding encoded documents document decoder transmits data documents to receiving application . Receiving application may then use decoded documents in any appropriate manner based on the configuration and characteristics of receiving application and data processing system . For example in a particular embodiment receiving application represents a phonebook application on a mobile communication device capable of displaying contact information received in decoded data nodes of decoded documents .

Because particular embodiments of data processing system reduce the amount of information transmitted between components of data processing system and reduce the computational resources required to process data documents such embodiments may be able to operate with limited memory processing or power resources. Moreover because of the reduced computational requirements of particular operations performed by components of data processing system particular embodiments of data processing system may also provide speed and efficiency benefits. Additionally because data processing system may include a network or other connectivity elements connecting particular components of data processing system the described techniques may also provide traffic reducing benefits in particular embodiments of data processing system .

Definition nodes may represent a schema definition or any other suitable data definition appropriate to define the contents format and or other characteristics of the associated data nodes . Additionally uncompiled schema may include one or more different types of definition nodes each to be processed by components of data processing system in distinct manner as discussed further below. For example a particular embodiment of data processing system utilizes uncompiled schema that may contain any of the schema types recognized by the XML schema standard including but not limited to schema element attribute namespace simple type complex type particle group wildcard and attribute use nodes.

Definition nodes may contain other definition nodes depending on the structure of the relevant definition node . For the purposes of this description any definition nodes contained by a particular definition node are considered child nodes or children of that particular definition node and that particular definition node is considered the parent or parent node of these children. For example in the illustrated uncompiled schema definition node includes definition nodes and and definition node includes definition nodes and . Thus definition nodes and represent child nodes of definition node . Similarly definition nodes and represent child nodes of definition node

More specifically schema compiler acquires uncompiled schema and begins parsing uncompiled schema . In the illustrated embodiment schema compiler creates a node array and a name array for each definition node in uncompiled schema . Node array and name array may each represent any appropriate form of data structure including but not limited to an array a record a stack an object or any other suitable data structure. Node array contains information stored as node entries describing the hierarchical relationship of definition nodes defined in uncompiled schema . Each node entry specifies the children of the definition node associated with that particular node entry and other additional properties of that definition node . Additionally each node entry includes a reference to a name entry in name array associated with the same definition node . Reference may represent a pointer a link or any other form of reference.

Node entry may also include any suitable additional information for describing the contents structure format and or other characteristics of the defined nodes . For example in a particular embodiment node entry may include such information as a minimum occurrence value and a maximum occurrence value . In the illustrated embodiment minimum occurrence value and a maximum occurrence value respectively represent a minimum and maximum number of times the associated node should appear within a particular instance of its parent and are generated by schema compiler from the minOccurs and maxOccurs properties of the XML schema elements associated with the relevant definition nodes . For example minimum occurrence value and maximum occurrence value for particle entry indicate that the TITLE element should appear a minimum of one time and a maximum of one time in a BOOK element conforming to compiled schema .

Name array includes a name entry for each definition node specifying a textual name for that definition node . In a particular embodiment name entry includes a textual identifier that specifies this textual name for definition node . In a particular embodiment name entry may also contain a reference back to node entry associated with that name entry . In general name entry may include any appropriate additional information.

As schema compiler parses uncompiled schema schema compiler generates a new node entry in node array for each additional definition node in uncompiled schema identified by schema compiler . Depending on the type of definition node schema compiler may also add a new name entry to name array . Schema compiler may also perform any other appropriate steps or operations to compile uncompiled schema .

For example in the illustrated embodiment which utilizes XML schema definitions schema compiler creates a node entry for each schema node in the uncompiled schema . For group nodes such as definition nodes and of schema compiler generates a particular type of node entry referred to here as a group entry in node array . Group entry includes a group identifier that specifies the group type of the relevant group definition node and one or more state delegation tables that includes a particle entry for each child of the group definition node . Each particle entry includes reference to an entry associated with an element or another group that is a child of the relevant group. For example in compiling the example uncompiled schema of schema compiler generates a state delegation table for definition node that includes pointers to node entries for children of definition node including definition nodes . Group entry may also include any further information appropriate based on the configuration and characteristics of schema compiler . For example in a particular embodiment group entry includes a size value in group entry that specifies a size of the associated state delegation table .

As noted group entry may include one or more state delegation tables . In a particular embodiment when schema compiler generates group entry for an all or a Choice group node such as definition node schema compiler generates a single state delegation table for that definition node . When schema compiler encounters a Sequence group node in uncompiled schema schema compiler generates a state delegation table for each child definition node of the Sequence group. Thus in compiling the example uncompiled schema schema compiler generates four separate state delegation tables for definition node one for each of the children definition nodes . In such a situation each state delegation table may include references to the remaining children definition nodes following each step of parsing the relevant Sequence group definition node .

For example for a Sequence group definition node defined to include an element A and element B and element C schema compiler may generate a first state delegation table with separate references to element A element B and element C a second state delegation table with references to element B and element C and a third state delegation table with a reference to element C. By contrast in this embodiment of schema compiler an All group definition node defined to include the same elements may only have a single state delegation table with a separate reference to each element A element B and element C. For element nodes attribute nodes or any other form of non group nodes that define XML objects that will contain substance when instantiated such as definition nodes and schema compiler may generate a particular type of node entry referred to here as a substance entry in node array . Substance entry includes reference to a name entry associated with the relevant element node. If the definition node associated with substance entry includes children definition nodes substance entry also includes reference to a substance entry or group entry associated with the child definition node . Substance entry may include any further information appropriate based on the configuration and characteristics of schema compiler . For example substance entry may include a substance identifier specifying a node type such as element attribute or wildcard for the substance entry .

As schema compiler parses uncompiled schema schema compiler may step through the hierarchical structure of uncompiled schema creating node entries for each definition node and then creating node entries for each child of that definition node with appropriate references to the node entries of children of the parent definition node . Where appropriate schema compiler may also generate name entries in name array for particular node entries . After completing the parsing of uncompiled schema or at any other appropriate time schema compiler may then write both node array and name array to a file representing compiled schema or may otherwise store node array and name array in memory . Additionally schema compiler may then make compiled schema available to generic encoder for use in encoding data documents as described in greater detail with respect to .

By reducing the amount of information that is retained for each definition node particular embodiments of schema compiler may generate compiled schema that is smaller than uncompiled schema but that provides information equivalent to uncompiled schema . Furthermore the structure of compiled schema may allow greater flexibility and simplicity in accessing individual elements of compiled schema as discussed further below. As a result schema compiler and the described techniques for generating compiled schema may provide several operational benefits to data processing system .

Processing component may represent schema compiler generic encoder or any other component of data processing system that process manages or utilizes compiled schema including components not included in or identified in the above discussion. As one example processing component may represent a data management module of data processing system responsible for managing compiled schema maintained on data processing system . As another example as discussed in greater detail below particular embodiments of generic encoder utilize compiled schema to bind data nodes of data documents to particular definition nodes during encoding. Thus processing component may represent a particular embodiment of schema compiler that uses the described techniques to concatenate multiple compiled schema . In general processing component may represent any collection of hardware and or software suitable to provide the described functionality and may utilize the described techniques to access information in compiled schema while performing any suitable operation involving compiled schema .

In operation processing component receives retrieves or generates compiled schema . Processing component then accesses a node entry in node array of compiled schema as shown by arrow . The accessed node entry may represent the first node entry in node array a node entry associated with a particular element of compiled schema or any other node entry of compiled schema . For the purposes of illustration this description assumes that processing component accesses the first node entry in node array referred to here as first node entry . Processing component may access first node entry by reading a first line of compiled schema by using an index or pointer obtained from another component or application or by using any other appropriate technique. Once processing component has accessed first node entry of node array processing component may in particular embodiments of data processing system utilize certain characteristics of compiled schema to access subsequent node entries in a sequential manner. More specifically processing component may determine a size of a particular node entry based on size values associated with a node type of that definition node . Processing component may then utilize the size of that definition node to access the next definition node in node array .

For example in the illustrated embodiment processing component maintains a size table in memory . Size table specifies one or more size values associated with each node type . Processing component may access this size table to determine a size for a particular node entry after determining a node type of that node entry . Although illustrates an embodiment of processing component that maintains suitable size values in size table processing component may maintain size values in any suitable manner. Moreover processing component may instead receive size values from other components of data processing system or determine size values as needed during operation. In general processing component may maintain receive generate or otherwise obtain size values in any suitable fashion.

In a particular embodiment of data processing system that supports XML node array of compiled schema may include node entries associated with schema nodes element nodes attributes nodes namespace nodes simple type nodes complex type nodes particle nodes group nodes wildcard nodes and attribute use nodes in uncompiled schema . Additionally node array may include for each group definition node one or more node entries representing state delegation tables associated with that group definition node . As noted above the size of a particular node entry is based at least in part on the type of definition node associated with that node entry .

More specifically in the illustrated embodiment of data processing system node entries associated with element nodes attribute nodes complex type nodes particle nodes and attribute use nodes have a fixed size based on the type of the associated definition node . For example node entries associated with element nodes have a fixed size of eight 8 bytes. Processing component may determine the size of a fixed size node entry by determining the specific node type associated with the fixed size node entry and then accessing stored information identifying a fixed size value for that particular node type. For example in the illustrated embodiment processing component maintains a size table in memory . Size table specifies one or more size value associated with each node type . Processing component may access this size table to determine a size for a particular node entry after determining a node type of that node entry . In general however processing component or any other data processing system may maintain any appropriate manner fixed size values indicating in any suitable form size for fixed size node types .

Additionally in this embodiment of data processing system node entries associated with schema nodes namespace nodes simple type nodes group nodes and wildcard nodes have a variable size. The variable size is based on both a fixed portion associated with that node type and a variable portion that depends on the content of the variable size node entry . More specifically the variable size is the sum of a base size value associated with that node type and one or more content dependent values. Each content dependent value represents the product of a content size value for a particular type of content for that node type and the quantity of that content that the definition node associated with the variable sized node entry possesses. The content may represent children definition nodes of that definition node or any other appropriate content that may affect the size of associated node entry .

For example node entries associated with namespace nodes in this example embodiment have a base size value and a first content size value for each element defined in the associated namespace definition node a second content size value for each attribute defined in the associated namespace definition node and a third content size value for each type defined in the associated namespace definition node . Thus if the base size value is assumed to be eight 8 bytes the first content size value is assumed to be one byte the second content size value is assumed to be one byte and the third content size value is assumed to be two 2 bytes then a node entry associated with a namespace definition node in which five elements fifteen attributes and four types have been defined will have a content size value of content size value 1 5 1 15 2 4 28 bytes. Furthermore if the base size value for namespace value is 10 bytes then the variable size for this example namespace would be 28 10 38 bytes. Thus a node entry associated with a namespace definition node formed in accordance with uncompiled schema and in which five elements fifteen attributes and four types have been defined will have a size of 38 bytes.

As a result in response to determining that a particular node entry is a variable sized node entry processing component may determine the size of that node entry by accessing size table or other appropriate information in data processing system to determine base size value and one or more content size value for the node type of the associated definition node . Processing component may then determine the quantity of one or more types of content included in node entry . After determining the quantity of content processing component may then determine one or more content dependent size values by multiplying the quantity of a particular type of content by the content size value for that type of content. Processing component may then calculate the size of the variable sized node entry by summing the base size value and the content dependent size value for each type of content contained in the node entry .

Additionally in a particular embodiment of data processing system node entries associated with group nodes such as group entries may reference one or more state delegation tables in node array as described above. In a particular embodiment of data processing system state delegation tables contain explicit size values specifying the size of the associated state delegation table in node array. Thus processing component may determine the size of a particular state delegation table in node array by accessing explicit size value stored in that state delegation table .

After determining the size of first node entry processing component may calculate an index associated with the node entry immediately following first node entry in node array . In particular processing component may use the size of first node entry as index for locating the next node entry in node array or may add the size of first node entry to index of first node entry to determine index for the next node entry . Processing component may then access the next node entry as shown by arrow . Processing component may then repeat the above process to determine the size of the next node entries calculate index for the node entries following the next node entry and access node entries as shown by arrows . As a result processing component may be able to use this technique to access each node entry of node array sequentially and may perform a particular operation to each node entry or to selected node entries within node array . For example if compiled schema is moved to a new storage location processing component may modify a pointer in each node entry of node array to reflect the new location of compiled schema .

Thus the described techniques allow processing component to access node entries sequentially in particular embodiments of data processing system . Sequential access may allow processing element to perform certain operations such as those that involve accessing each definition node of the associated uncompiled schema once with greater speed than would be possible by accessing uncompiled schema hierarchically. As a result sequential access may increase the operating speed of processing component .

Furthermore accessing node entries hierarchically may result in processing component accessing a particular node entry more than once as processing component accesses each child of the node entry in question. This may cause undesirable results if processing component repeatedly performs a particular operation on the node entry . Thus sequential access may reduce the computational complexity of performing certain tasks as sequential access may eliminate the need to determine whether processing component has already accessed a particular node entry .

Data nodes may include or be preceded by textual start delimiters . Moreover data nodes may include or be followed by textual end delimiters . Textual start delimiters and textual end delimiters may represent any text indicating a beginning or end respectively of data nodes . Textual start delimiters and textual end delimiters may represent a portion of the data node these delimiters delimit or may represent text entirely distinct from the contents of data node . In a particular embodiment textual start delimiters and textual end delimiters represent XML start and end tags respectively.

Additionally textual start delimiters and or textual end delimiters may specify a node type for their associated data nodes . In a particular embodiment textual start delimiters and textual end delimiters include textual identifier that specifies the node type of their associated data node . Generic encoder may use textual identifier of data node to identify in node array a node entry associated with that data node as described in greater detail with respect to .

Generic encoder receives data documents and encodes data nodes in these data documents . In the process generic encoder may utilize binding application to bind nodes to compiled schema . As noted above with respect to generic encoder may represent physical components within data processing system a software process running in data processing system or any other form of computational or processing resources including any suitable collection of software and or hardware.

Binding application receives compiled schema from schema compiler memory or another appropriate element of data processing system and binds data nodes of data documents associated with that compiled schema in response to binding requests received from generic encoder and or other elements of data processing system . Binding application may represent physical components within data processing system software processes running on data processing system and or any other form of computational or processing resources. In particular embodiments of data processing system binding application comprises a virtual machine that supports one or more Application Programming Interfaces APIs for interaction with other elements of data processing system . Generic encoder and or other elements of data processing system may utilize these APIs to submit binding requests to binding application and to receive binding responses from binding application as described in greater detail below. Additionally binding application and generic encoder may represent physically discrete components or separate software processes as shown or may represent a single component or process suitable to provide the functionality described for both elements.

In operation generic encoder receives data documents from generating application or otherwise accesses data documents . Generic encoder then parses data documents . As generic encoder parses data documents generic encoder may encounter textual start delimiters and textual end delimiters that identify the start and the end respectively of individual data nodes included in data documents . When generic encoder detects the beginning of a data node generic encoder may transmit a binding request identifying the data node to binding application . The binding request may identify data node by a textual identifier such as an XML tag included in the textual start delimiter . In a particular embodiment generic encoder executes the binding request using a pair of Java methods startElement and startAttribute supported by binding application . These methods accept as a parameter textual identifiers of data nodes representing XML elements and attributes and return a numeric identifier for a particular definition node associated with that textual identifier in compiled schema . For example using the example data document illustrated in when generic encoder encounters textual start delimiter of data node in generic encoder may bind data node by invoking the startElement method as follows 

Upon receiving a binding request associated with invocation of this method binding application may access node array of compiled schema to identify a node entry associated with the specified textual identifier . More specifically binding application may access node array and name array hierarchically or sequentially to find a name entry a matched name entry that includes a string that matches textual identifier . The matched name entry may include information identifying a particular node entry a matched node entry associated with the matched name entry. For example in particular embodiments each name entry includes a pointer that identifies the node entry associated with that name entry indicated by arrow in . In such an embodiment binding application may determine the matching name entry by matching textual identifier with the matched name entry and then identify the matched node entry by following the pointer included in the matched name entry.

Based on information included in the matched node entry binding application identifies a numeric identifier associated with the matched node entry. In particular embodiments node entries contain a numeric identifier field and numeric identifier represents the value of the numeric identifier field of the matched node entry. Binding application may then return numeric identifier to generic encoder . For example in response to receiving the binding request for the textual identifier in this case TITLE of node binding application transmits a response that specifies the numeric identifier in this case associated with that textual identifier.

Generic encoder then generates an encoded node that replaces textual identifier with numeric identifier associated with that data node . Generic encoder continues parsing the contents of data node and may add parsed information from data node to encoded node . If generic encoder parses textual start delimiters identifying the start of children nodes of data node generic encoder repeats this process for the children nodes.

Additionally in particular embodiments node entries in node array identify other node entries if any that are associated with children of that node entry . In such embodiments binding application may maintain state information pertaining to the parsing being completed by generic encoder . In particular binding application may maintain information identifying the node entry associated with the data node currently being parsed. In such embodiments when attempting to match textual identifiers in subsequently received binding requests to node entries in node array binding application may assume that textual identifier is associated with a child of the data node currently being processed and attempt to match textual identifier with only those node entries associated with children of the previously matched node entry .

Furthermore when generic encoder parses a textual end delimiter identifying the end of data node or any children nodes of data node generic encoder may complete binding of data node by transmitting another binding request that identifies data node by a textual identifier such as an XML tag included in the textual end delimiter . In particular embodiments generic encoder executes the binding request using another Java method endElement supported by binding application . This methods accept as a parameter textual identifiers of data nodes representing XML elements and attributes and may return a numeric identifier for a particular definition node associated with that textual identifier in compiled schema . For example using the example data document illustrated in when generic encoder encounters the textual start delimiter of data node in generic encoder may finish the binding of data node by invoking the endElement method as follows 

Using similar techniques to those described above with respect to binding requests generated using the startElement method binding application may attempt to match the textual identifier included in such a binding request with a node entry in the node array . In particular embodiments binding application may maintain state information associated with the parsing performed by generic encoder . In such embodiments binding application may when receiving a binding request using the endElement method attempt to only match textual identifier from that binding request to a particular node entry received as a result of the most recent invocation of startElement . After matching endElement to a matched node entry as described above binding application may return the numeric identifier stored in the matched node entry. Alternatively in embodiments of data processing system in which binding application maintains state information generic encoder may use the endElement method solely to accurately indicate the scope of the data node currently being processed. In such embodiments binding application may in response to invocation of the endElement update the state information to indicate that generic encoder has reached the end of the data node currently being processed and may then return a default value or no value at all.

Generic encoder may also while parsing data document data document perform any appropriate additional steps to encode data nodes . For example in particular embodiments generic encoder reduces the number of delimiters included in data documents . By making certain assumptions regarding the format of data documents and by utilizing certain inherent redundancies in standard XML formats generic encoder may further reduce the size of encoded documents . In particular embodiments generic encoder after receiving numeric identifier from binding application generates an encoded node from information in the relevant data node . In generating encoded node from data node generic encoder may replace a textual start delimiter indicating the beginning of data node with a numeric delimiter . Encoding module may determine the value of numeric delimiter based on a delimiter type associated with numeric delimiter the numeric identifier associated with data node and or predetermined delimiter values. In a particular embodiment specific encoder may access a delimiter value table stored in memory to obtain predetermined delimiter values. Delimiter value table includes a plurality of delimiter values that specific encoder uses to generate numeric delimiters . In the illustrated embodiment these delimiter values include a base delimiter value a delimiter limit value an offset value and a text delimiter value .

As one example of how generic encoder may reduce the number of delimiters in encoded nodes generic encoder may eliminate unnecessary end delimiters in encoded nodes . Because XML and other markup languages may include end delimiters in situations where the end of the associated data node can be assumed based on the content of that data node such as at the end of an XML attribute or other simple content element generic encoder may eliminate these unnecessary delimiters and further reduce the size of encoded nodes . More specifically generic encoder may determine whether based on a node type of data node to include a numeric delimiter marking the end of data node . For example encoded nodes associated with XML attributes or simple content elements may not include end delimiters. If generic encoder decides based on the node type of data node to include a delimiter marking the end of encoded node generic encoder includes a second numeric delimiter equal to base delimiter value for example 12 in this embodiment.

Generic encoder may also combine adjacent end delimiters in data documents such as those between a data node and the last child node of that data node such as textual start delimiter and textual end delimiter in . More specifically generic encoder may generate a single numeric delimiter for multiple textual end delimiters with the relevant numeric delimiter equal to base delimiter value decremented once for each additional textual end delimiter beyond the first to be consolidated into numeric delimiter . Thus when generic encoder combines two adjacent end delimiters generic encoder may replace the two textual end delimiters with a single numeric delimiter in this case 12 1 or 13. As a result the value of numeric delimiter in encoded node reflects the fact that this numeric delimiter marks the end of multiple encoded nodes .

Additionally generic encoder may also combine a textual end delimiter and an adjacent textual start delimiter such as textual end delimiter and textual start delimiter . More specifically generic encoder may consolidate a particular textual end delimiter and an adjacent textual start delimiter by generating a numeric delimiter in encoded document marking both the end of one encoded node and the beginning of the next encoded node . The value used for such a numeric delimiter in a particular embodiment represents the sum of the numeric identifier for the next encoded node and an offset value .

In a particular embodiment generic encoder may be configured so that this offset value is equal to the smallest integer value recognized by one or more components of data processing system . In the illustrated embodiment this offset value equals 2. Thus in the example generic encoder replaces textual end delimiter and textual start delimiter with a numeric delimiter with a value equal to the sum of the numeric identifier for data node and the offset value or 135 2

In addition to reducing delimiters generic encoder may encode data nodes in any other suitable manner to reduce the size of encoded documents or for any other appropriate reason. In a particular embodiment generic encoder converts all text data nodes to byte sequences such as 8 bit UTF 8 byte sequences. In general generic encoder may perform any additional encoding steps appropriate to data nodes to generate encoded nodes . After completing the encoding generic encoder generates one or more encoded document containing encoded nodes . Moreover in a particular embodiment data documents represent XML documents containing XML elements composed entirely of tags and text elements. As a result in such an embodiment encoded document may represent a series of UTF 8 byte sequences delimited by numeric delimiters . Generic encoder may then transmit encoded documents to document decoder store encoded documents in memory accessible by both components or make encoded documents available for use by document decoder in any other appropriate manner.

By replacing textual identifiers with numeric identifiers and eliminating particular delimiters generic encoder may reduce the amount of redundant information stored in data documents . As a result generic encoder may be able to further reduce the size of data documents providing additional space saving benefits. Additionally generic encoder may in particular embodiments perform certain additional encoding steps that encode data documents in any other appropriate manner.

The example embodiment of encoding module that generates this encoded document is assumed to utilize a end delimiter value of 12. Furthermore encoding module is assumed to form intermediate numeric delimiters replacing adjacent textual end delimiters and textual start delimiters by adding the smallest numeric value recognized by encoding module or 2 to numeric identifier associated with the relevant data node . As used in the expression UTF xxx is intended to represent the byte sequence generated by converting the ASCII character string xxx to UTF 8 format.

After generating pre bound document generating application transmits or provides pre bound document to specific encoder . Specific encoder encodes pre bound document to generate encoded documents . In a particular embodiment specific encoder may encode pre bound document in a manner similar to that described above for generic encoder after generic encoder has bound nodes . For example specific encoder may perform the delimiter reduction and or the UTF 8 conversion described above for generic encoder . In particular embodiments encoded documents may be similar or identical to encoded documents generated by specific encoder . More specifically in particular embodiments encoded document may include a series of byte sequences delimited by numeric delimiters as illustrated. After encoding pre bound document specific encoder generates one or more encoded documents containing encoded nodes . Specific encoder may then transmit encoded documents to document decoder store encoded documents in memory accessible by both components or make encoded documents available for use by document decoder in any other appropriate manner.

Because generating application under the described circumstances is aware of compiled schema and may be capable of limiting the duplication of certain information provided by compiled schema such as textual identifiers for names of data nodes specific encoder may be able to encode pre bound documents more quickly than generic encoder can bind and encode data nodes . As a result particular embodiments of generating application and specific encoder may provide additional speed benefits. Additionally because pre bound documents may include less information than data documents utilizing specific encoder with a suitably configured generating application may result in reduced outbound traffic from generating application .

In operation document decoder receives encoded document from one or both of specific encoder or generic encoder referred to generically here as document encoder . As noted above encoded document may represent a stream of values one or more files or data structured in any other suitable manner. In a particular embodiment document decoder receives encoded document encoded according to the encoding techniques described above. As a result encoded document may represent a series of UTF 8 byte sequences delimited by numeric delimiters as shown in . Although the description below focuses operation of document decoder with respect to encoded document of this type document decoder may be configured to utilize the described techniques on encoded documents encoded in any suitable manner.

Furthermore document decoder may receive encoded document from document encoder over a network or other connectivity elements of document processing system . Moreover document decoder may receive encoded documents directly from document encoder or through one or more intervening components. Document decoder may also receive encoded document by retrieving encoded documents from memory accessible by both document encoder and document decoder . In general document decoder may receive or obtain encoded documents from document encoder or another component of data processing system in any appropriate manner.

Document decoder begins parsing encoded document . As noted above encoded document may include encoded nodes that are separated by numeric delimiters . Thus while parsing encoded document document decoder may read a numeric delimiter from encoded document . Document decoder then determines whether numeric delimiter marks the beginning or end of one or more encoded nodes by comparing numeric delimiters to one or more predetermined delimiter values. Data documents may then based on this determination reconstruct markup data objects for transmission to receiving application or otherwise provide receiving application information describing the contents of a particular data node such as by making attributes and other contents of that data node available to receiving application through an API of document decoder . In the illustrated embodiment document decoder stores data decoded from a particular encoded node in a decode stack in memory until document decoder has finished decoding that encoded node . Document decoder then transmits a decoded data node generated from that data to receiving application .

For example document decoder may whenever document decoder encounters a numeric delimiter during parsing determine the delimiter type of that numeric delimiter by comparing numeric delimiter to one or more predetermined values. In a particular embodiment document decoder may obtain predetermined values by accessing a delimiter value table which includes a plurality of delimiter values that document decoder uses to determine a delimiter type for numeric delimiters read by document decoder . In the illustrated embodiment these delimiter values include base delimiter value delimiter limit value a reverse offset value and text delimiter value .

Document decoder may first determine whether numeric delimiter represents an end delimiter of a single encoded node . Document decoder may determine whether numeric delimiter represents an end delimiter by comparing numeric delimiter to a base delimiter value . Document decoder may obtain base delimiter value by accessing delimiter value table as shown in or may obtain base delimiter value in any other appropriate manner. In a particular embodiment document encoder is configured to encode all end delimiters marking the end of a single data node with a predetermined numeric delimiter equal to base delimiter value . In a particular example embodiment base delimiter value equals 12. Thus if numeric delimiter is equal to base delimiter value document decoder determines that numeric delimiter represents the end of a single encoded node . Document decoder may utilize this determination in any appropriate manner based on the configuration of document decoder . For example in a particular embodiment document decoder may be adding decoded data from a particular encoded node that document decoder is currently decoding to a stack of data nodes . As a result of determining that numeric delimiter represents the end of a single encoded node document decoder may pop the current data node from the top of the stack and transmit this data node to receiving application . Document decoder may then proceed with parsing the remainder of encoded document .

If the relevant numeric delimiter does not represent an end delimiter of a single node document decoder may then determine whether numeric delimiter represents an end delimiter marking the end of two or more nested encoded nodes . In a particular embodiment document encoder is configured to consolidate adjacent text delimiters marking the end of multiple nested data nodes and to replace the adjacent text delimiters by a consolidated delimiter in encoded document . This consolidated delimiter represent a value equal to base delimiter value decremented once for each data node beyond a first that are terminated by the adjacent end delimiters. Furthermore document encoder may be configured to only consolidate a specified maximum number of adjacent end delimiters. Thus in encoding nested end delimiters document encoder may decrement base delimiter value only a maximum number of times to represent adjacent end delimiters. As a result document decoder in a particular embodiment may determine that numeric delimiter represents multiple nested end delimiter by determining that numeric delimiter is less than base delimiter value but greater than or equal to a delimiter limit value with delimiter limit value equal to base delimiter value minus the maximum number of nested delimiters document encoder is configured to consolidate.

For example in a particular embodiment document encoder is configured to only consolidate a maximum of ten nested delimiters. As a result delimiter limit value equals 22. Thus in such an embodiment document decoder may determine that numeric delimiter represents a consolidated delimiter marking the end of multiple nested encoded nodes by determining that numeric delimiter is less than 12 but greater than or equal to 22. 

If document decoder determines that numeric delimiter represents marks the end of multiple encoded nodes document decoder may then utilize this determination in any appropriate manner. For example in a particular embodiment document decoder may pop the current data node from the top of the stack and transmit this data node to receiving application . Document decoder may then increment numeric delimiter and compare numeric delimiter to base delimiter value again. Document decoder may then repeat this process until numeric delimiter equals base delimiter value . Document decoder may then proceed with parsing the remainder of encoded document .

If document decoder determines that numeric delimiter does not represent the end of one or more encoded nodes document decoder may determine whether numeric delimiter represents the end of a first encoded node and the beginning of a second adjacent encoded node . In a particular embodiment document encoder is configured to encode adjacent end and start delimiters marking respectively the end of a first data node and the beginning of a second adjacent data node by replacing the adjacent end and start delimiters with an intermediate delimiter in encoded document as described above. The value used for the intermediate delimiter in a particular embodiment represents the sum of a numeric identifier for the second node and an offset value .

In the illustrated embodiment this offset value equals the smallest integer value recognized by document decoder . In such an embodiment document decoder may be configured to utilize twos complement arithmetic and thus adding the smallest integer value to any positive number will result in a negative integer value with a relatively large absolute value. Thus document decoder in such an embodiment may determine that numeric delimiter represents a consolidate delimiter marking the end of a first encoded node and the beginning of an adjacent encoded node by determining whether numeric delimiter is less than delimiter limit value .

If document decoder determines that numeric delimiter represents the end of a first encoded node and the beginning of a second adjacent encoded node document decoder may then utilize this determination in any appropriate manner. For example in a particular embodiment document decoder may pop the current data node from the top of the stack and transmit this data node to receiving application . Document decoder may then calculate a numeric delimiter for a new data node by adding a reverse offset value to numeric delimiter . In a particular embodiment reverse offset value represents the largest negative integer value recognized by document decoder . In the illustrated embodiment this reverse offset value equals 2. By adding reverse offset value to numeric delimiter document decoder may be able to retrieve the original numeric delimiter associated with the second encoded node . Document decoder may then identify a definition node associated with the original numeric delimiter in compiled schema . document decoder may then push a new data node onto the top of decode stack . Document decoder may then continue parsing encoded document repeating this process above when document decoder reads another numeric delimiter .

If document decoder instead determines that numeric delimiter is greater than base delimiter value document decoder may then determine whether numeric delimiter marks the beginning of encoded text of a mixed content data node . In a particular embodiment document encoder is configured to mark the beginning of text in mixed content nodes with a delimiter equal to a text delimiter value . In the illustrated embodiment text delimiter value equals 1. Thus in such an embodiment document decoder may determine that numeric delimiter marks the beginning of text from a mixed content data node by determining that numeric delimiter is equal to text delimiter value .

If document decoder determines that numeric delimiter marks the beginning of encoded text document decoder may utilize this determination in any appropriate manner. In a particular embodiment document decoder begins reading data from encoded document and decoding this data into characters. For example document decoder may read UTF 8 byte sequences and these byte sequences to ASCII text characters. Document decoder may also transmit these characters to receiving application or store the characters in decode stack in the data node that document decoder is currently decoding. Document decoder may then determine that document decoder has read all the data associated with this text item and returns to parsing numeric delimiter . In a particular embodiment document decoder may determine that document decoder has read all the text in this object by detecting a byte sequence of all zeros. After reading all the characters in the text item document decoder may return to parsing numeric delimiter .

Additionally if document decoder determines that numeric delimiter is greater than base delimiter value but that numeric delimiter does not equal text delimiter value document decoder may determine that numeric delimiter represents a start delimiter marking the beginning of an encoded node that does not immediately follow the termination of a previous encoded node . In a particular embodiment document encoder is configured to encode a start delimiter that does not immediately follow an end delimiter by replacing such a start delimiter with a particular numeric delimiter associated with the relevant data node as described above with respect to . Thus in a particular embodiment document decoder may determine numeric delimiter represents the beginning of an encoded node if numeric delimiter is greater than base delimiter value and does not equal text delimiter value .

If document decoder determines that numeric delimiter marks the beginning of an encoded node document decoder may utilize this determination in any appropriate manner. In a particular embodiment document decoder may identify a node entry associated with numeric delimiter in node array of compiled schema . Data documents may then identify a particular name entry name array that is associated with the identified node entry based on reference in the identified node array .

Furthermore if document decoder determines based on the identified node entry that encoded node represents a data node of a simple node type document decoder may then create a new data structure containing information from name entry such as a textual name associated with a node type of the encoded node . Data structure may represent an object a record a string an array or any other suitable collection of data. In a particular embodiment data structure includes one or more strings delimited by textual tags and represents a well formed XML data structure.

Document decoder may then transmit that data structure to receiving application or store data structure for later use. If document decoder determines based on the identified node entry that encoded node represents a data node of a complex node type document decoder may then create data structure containing information from name entry such as textual name associated with a node type of encoded node and push the data structure on decode stack . Document decoder may then return to parsing encoded document .

Document decoder may continue parsing encoded document until document decoder reaches the end of encoded document repeating the comparisons described above as appropriate. Additionally data documents may execute any additional pre processing or post processing steps prior or subsequent to decoding encoded document as described above. Moreover document decoder may also include any additional steps during the described processing as appropriate based on the characteristics of encoded document and configuration of document decoder . Once document decoder has completed parsing encoded document data documents may store decoded data nodes in memory transmit data nodes to receiving application notify receiving application that document decoder has completed decoding encoded document and or taking any other appropriate steps based on the configuration of data processing system . If alternatively document decoder has been transmitting data nodes to receiving application during decoding document decoder may terminate without any further indication to receiving application .

At step document decoder reads a second numeric delimiter from encoded document . Document decoder then determines whether second numeric delimiter marks the end of one or more encoded nodes . More specifically document decoder determines whether second numeric delimiter is equal to base delimiter value at step . If second numeric delimiter is equal to base delimiter value second numeric delimiter marks the end of a single encoded node . Thus in response to determining that second numeric delimiter equals base delimiter value document decoder may stop storing data from encoded document in the topmost data structure in decode stack and or pop the topmost data structure from decode stack at step . Document decoder may then transmit this topmost data structure to receiving application at step . The completed data structure may represent a markup language data structure or information structured in any other appropriate manner.

Because at this point document decoder is no longer parsing the contents of an encoded node document decoder may have reached the end of encoded document . Thus at step document decoder determines whether document decoder has parsed to the end of encoded document . Document decoder may determine that document decoder has reached the end of encoded document by parsing an end of file character by detecting that no more data remains to be parsed in encoded document or in any other suitable manner. If document decoder determines that document decoder has reached the end of encoded document document decoder may terminate decoding at step . If document decoder does not determine that document decoder has reached the end of encoded document document decoder continues parsing encoded document returning to step .

If second numeric delimiter is not equal to base delimiter value document decoder determines at step whether second numeric delimiter is less than base delimiter value but greater than delimiter limit value . If second numeric delimiter is less than base delimiter value but greater than delimiter limit value then second numeric delimiter marks the end of multiple encoded nodes . Thus in response to determining that second numeric delimiter is less than base delimiter value but greater than delimiter limit value document decoder may stop storing data from encoded document in the topmost data structure in decode stack and or pop the topmost data structure from decode stack at step . Document decoder may then transmit data structure to receiving application at step . Document decoder also increments second numeric delimiter at step . Document decoder then returns to step .

If second numeric delimiter is not less than base delimiter value document decoder determines at step whether second numeric delimiter is equal to text delimiter value . If second numeric delimiter is equal to text delimiter value second numeric delimiter marks the beginning of a text element. In response to determining that second numeric delimiter is equal to text delimiter value document decoder creates a new data structure on decode stack at step . At step document decoder continues parsing data following second numeric delimiter in encoded document and converts this data from an encoded format to a decoded format. Document decoder stores some or all of this decoded data in data structure at step . Document decoder continues parsing data from the encoded text element until document decoder determines at step that document decoder has reached the end of the encoded text element. Document decoder may determine document decoder has reached the end of the encoded text element by utilizing a size specified in the encoded text element by detecting a predetermined character or character pattern indicating the end of the encoded text or in any other suitable manner. After detecting the end of the encoded text element document decoder may stop storing data from encoded document in the topmost data structure in decode stack and or pop the topmost data structure from decode stack at step . Document decoder may then transmit data structure to receiving application at step . Document decoder then continues parsing encoded document returning to step .

If second numeric delimiter is less than both base delimiter value and delimiter limit value then second numeric delimiter marks the end of a first encoded node and the beginning of a second encoded node . As a result document decoder may stop storing data from encoded document in the topmost data structure in decode stack and or pop the topmost data structure from decode stack at step . Document decoder may then transmit this topmost data structure to receiving application at step .

Additionally in such a case second numeric delimiter may represent the sum of a numeric identifier associated with the second encoded node . Because the illustrated embodiment of document decoder uses twos complement computational techniques document decoder may obtain the numeric identifier by adding a reverse offset value to second numeric delimiter . Thus at step document decoder adds reverse offset value to second numeric delimiter to obtain numeric identifier . Document decoder then identifies a definition node in compiled schema associated with this numeric identifier at step . At step document decoder creates a new data structure on decode stack . Document decoder may store textual identifier from the identified definition node in data structure . At step document decoder continues parsing data following second numeric delimiter in encoded document and converts this data from an encoded format to a decoded format. Document decoder stores some or all of this decoded data in data structure at step . Document decoder then returns to step .

Although not necessarily shown by any flow in document decoder may at any appropriate time while parsing data from encoded document document decoder may determine based on any suitable criteria that document decoder has reached the end of encoded document . For example document decoder may detect an end delimiter for the bottommost data structure on decode stack . Alternatively document decoder may detect a predetermined character or pattern of characters that marks the end of encoded document . In general however document decoder may determine that document decoder has reached the end of encoded document in any suitable manner. Upon determining at step that document decoder has reached the end of encoded document document decoder may remove any remaining data structures from decode stack transmit such data structures to receiving application and or take any other appropriate steps to complete decoding of encoded document . Document decoder completes decoding at step .

Unbound documents may in general represent any documents describing data nodes defined by a data definition of data processing system such as uncompiled schema . As one example unbound documents may represent standard XML data documents that have not been encoded. Unbound documents may also represent structured data documents that are not formatted and or delimited in accordance with a markup language in a manner that would allow the hierarchy of unbound nodes to be identified based on the delimiters of that unbound document . For example particular embodiments of document decoder may receive unbound documents formatted as comma separated value CSV files that include data nodes such as the example unbound document shown in . Also shown in is an uncompiled schema defining the constructs used in unbound document and a data document that for the purposes of this description is assumed to an example data document showing how the information in unbound document might be structured in XML.

In the example unbound document includes a plurality of unbound nodes representing element instances. Additionally although not labeled in unbound document may also include a number of unbound nodes representing group nodes and or other types of unbound nodes. For example unbound document includes a group node formed by the instances of element D element E and element F that collectively make up the first instance of element C in unbound document

Although illustrates a particular example of unbound document for use with particular embodiments of document decoder in which unbound nodes are delimited by a combination of symbols and line breaks alternative embodiments of document decoder may utilize unbound documents that are delimited by any appropriate characters symbols whitespace and or other content. In general unbound nodes may be delimited according to any appropriate delimiting scheme and document decoder may utilize information in uncompiled schema or information from other sources to determine the delimiter scheme associated with a particular unbound document . In this particular example instances of element B for example unbound node implicitly start and end with new lines. Instances of element C for example unbound nodes also start and end with a new line. Instances of element D for example unbound nodes and begin with and end with . Instances of element E for example and start with and end with . Instances of element F for example and start with and end with .

GUI as described in greater detail below may be used by document decoder to display information associated with the decoding of unbound documents . GUI may represent any suitable user interface capable of generating a visual display based on information transmitted by document decoder . GUI may include any appropriate combination of hardware and or software. In the illustrated embodiment GUI represents a software process running on a processor and capable of outputting information to a computer monitor . In such an embodiment document decoder may represent a virtual machine with which GUI communicates to receive updated status information associated with the decoding of unbound document

Document state stack represents a data structure stored in memory of data processing system . As shown in document decoder includes or has access to document state stack . During parsing of unbound documents document state stack holds state entries which may contain any information appropriate for document decoder to track the current state of document decoding. Although document state stack is described as a stack document state stack may represent any form of data structure suitable for storing state entries as described below. In a particular embodiment document state stack represents a first in last out FILO stack.

In operation document decoder receives the example unbound document from a remote component of data processing system or acquires unbound document in any other appropriate manner. As noted above unbound document includes a series of text values separated by symbols and line breaks. Document decoder may use the example uncompiled schema to convert unbound document into a data document conforming to XML or another language supported by receiving application .

More specifically after acquiring unbound document document decoder begins parsing unbound document . Based on the delimiting scheme associated with unbound document document decoder identifies the start of a first data node in unbound document . For example document decoder may determine that the first character in the first line the first character after the first newline character or the first character following a particular delimiter marks the beginning of the first unbound node in unbound document . In general document decoder may depending on the format of a particular unbound document identify the beginning of the first data node in unbound document in any suitable manner. In the illustrated embodiment document decoder identifies the first character of the first line as the beginning of the first unbound node of unbound document . As a result of identifying the beginning of first unbound node of unbound document document decoder adds a first state entry to document state stack . In the illustrated embodiment document state stack represents a FILO stack and document decoder pushes first state entry onto one end referred to here as the top of document state stack .

In particular embodiments the contents of the state entry document decoder creates for a particular unbound node may depend on a node type of that node. Document decoder may determine the node type of the relevant node based on the uncompiled schema associated with unbound document . In particular embodiments document decoder may create an element state entry group state entry and or other type of state entry based on the node type of the relevant node . If the relevant unbound node represents an element node document decoder may create an element state entry in document state stack . Element state entry may include a textual identifier associated with the relevant node and a particle count that indicates whether the substance of the relevant node has been fully parsed.

If the relevant unbound node represents a group node document decoder may create a group state entry in document state stack . Group state entry may include a minimum occurrence value and a maximum occurrence value that together describe a number of children that an instance of that group must have before being considered well formed and an occurrence. Moreover if the relevant group node is defined to include multiple types of children nodes the group state entry may include multiple minimum occurrence values and a maximum occurrence values with a minimum occurrence value and a maximum occurrence value associated with each type of children nodes defined for that group node . Furthermore when document decoder identifies the beginning of another unbound node in unbound document document decoder may also determine based on uncompiled schema that the identified unbound node represents the first element in a plurality of nested group nodes document decoder may add multiple group state entries to document state stack one for each of the nested group nodes.

After pushing the state entry on document state stack document decoder continues parsing unbound document . If document decoder identifies another start delimiter or other suitable information identifying the beginning of another unbound node document decoder adds another element state entry to the document state stack . In the illustrated embodiment document decoder adds another state entry by pushing another state entry on the top of document state stack .

If document decoder identifies an end delimiter or other suitable information indicating the end of the current unbound node document decoder removes the topmost state entry from document state stack . In the illustrated embodiment document decoder removes a state entry from document state stack by popping a state entry off the top of document state stack . As a result document decoder may track the current state of document parsing by adding and removing state entries from the document state stack .

Document decoder may also take any other appropriate action as a result of determining that the end delimiter of the unbound node has been parsed. For example document decoder may write parsed data associated with the unbound node to a file in XML format. As a result document decoder may output a data document similar to data documents shown in as a result of decoding unbound document

Additionally in particular embodiments document decoder may utilize a particle count minimum occurrence value maximum occurrence value and or occurrence count associated with the relevant unbound node and or children of that unbound node to determine an acceptance status of that unbound node . The acceptance status indicates whether document decoder has completed parsing that unbound node and or whether that unbound node represents a well formed object of the relevant markup language.

For example as noted above document decoder may add a group state entry when document decoder parses a the beginning of an unbound node defined to include a group. Group state entry includes minimum occurrence value and maximum occurrence value that together describe a number of children that an instance of that group must have before being considered well formed and an occurrence count that indicates the current number of children that has been parsed for the instance. In the illustrated example the choice group included in instances of element B such as unbound node needs to contain at least one children instances of element C to be complete and should contain no more than three instances of element C. Thus when document decoder encounters an instance of element B when parsing unbound document document decoder may create a group state entry that includes a minimum occurrence value of 1 and a maximum occurrence value that is 3. 

Then as document decoder parses children nodes of this choice group document decoder may increment occurrence count each time document decoder encounters another child of the group. Document decoder may then determine an acceptance status of the group based on occurrence count and minimum occurrence value and or maximum occurrence value associated with that group. For example in a particular embodiment document decoder determines one of three possible acceptance statuses of a particular group unbound node . If occurrence count for a particular group state entry is less than minimum occurrence value for that group state entry then document decoder determines an acceptance status of IS NOT DONE for the group node associated with that group state entry . If the relevant occurrence count is greater than or equal to minimum occurrence value then document decoder determines an acceptance status ACCEPTED meaning that document decoder has found a sufficient number of children for the group node to be considered well formed but that the group node may still acceptably include more children. If occurrence count is equal to maximum occurrence value then document decoder determine an acceptance status of IS DONE indicating that the group node can not include any additional children and remain well formed. Document decoder may additionally store this acceptance status in the relevant group state entry as an acceptance status field .

Once document decoder determines that acceptance status of the topmost state entry in document state stack is IS DONE document decoder may remove that topmost state entry from document state stack . Additionally if during parsing document decoder reaches an end delimiter for the data node associated with the topmost state entry in document state stack and that topmost state entry currently has an acceptance status of ACCEPTED document decoder may determine that the unbound node associated with that state entry is complete and remove the topmost state entry from document state stack . Furthermore in particular embodiments document decoder may initiate warning or error correcting operations if an unexpected combination of acceptance status and parsing results occurs. For example if document decoder determines that an acceptance status for a particular group unbound node has reached IS DONE and then document decoder parses another child for that group unbound node document decoder may generate a warning indicating that the unbound node in question is not well formed.

As noted above shows the contents of document state stack immediately after document decoder parses the start delimiter of node . Because document decoder has now detected the maximum number of each type of child possible for instances of element C one each of elements D E and F document decoder determines that the group node associated with the instance of element C represented by node should not include any more children and the acceptance status of group state entry becomes IS DONE. By contrast document decoder has only detected one instance of element C within the instance of element B represented by node . While this total is greater than or equal to minimum occurrence value for group state entry it is also less than maximum occurrence value for group state entry . Thus document decoder has detected a sufficient number of children for the instance of element B but the instance may still hold more children in accordance with the definition in uncompiled schema . As a result the acceptance status becomes ACCEPTED. 

Additionally because document decoder has parsed content substance for the instances of element B and C associated with unbound nodes and the particle count for these two element state entries equals 1. The acceptance status of these element state entries is IS DONE as although document decoder may continue to parse the existing particles of content no additional particles of content are expected. By contrast document decoder has only parsed the start delimiter of unbound node and no content of node . As a result the particle count of the associated element state entry is and the acceptance status is IS NOT DONE as shown in .

In addition to updating document state stack document decoder may also in particular embodiments display information associated with the acceptance status of particular state entries or and or the associated nodes on GUI . In particular embodiments document decoder may indicate the acceptance status of the state entries by generating a status indicator for each state entry currently and or previously stored in document state stack and transmitting these status indicators to GUI for display on GUI . Document decoder may update or replace the status indicators displayed on GUI as the status of individual state entries changes.

Furthermore document decoder may use status indicators to indicate the acceptance status of the associated state entry in any appropriate manner. For example in particular embodiments document decoder may indicate the acceptance status of a particular state entry by generating a status indicator of a particular color for that state entry. Document decoder may then indicate changes in the acceptance status of that state entry by changing the color of the associated status indicator or by generating a new status indicator with a different color. illustrates an embodiment of data processing system in which document decoder indicates an acceptance status of IS NOT DONE with a red status indicator indicated in by the shaded status indicator associated with state entry an acceptance status of ACCEPTED with a yellow status indicator indicated in by the cross hatched status indicator associated with state entry and an acceptance status of IS DONE with a green status indicator indicated in by the unshaded status indicators and associated with state entries and respectively .

Additionally in some embodiments document decoder may utilize the acceptance status of one or more unbound nodes to determine an effective acceptance of a parent node of those unbound nodes . The effective acceptance may indicate whether the document decoder has parsed the appropriate combination of accepted children nodes for a particular unbound node and document decoder may determine the effective acceptance of a particular unbound node based on the acceptance status of its children nodes. As a result document decoder may use the effective acceptance of an unbound node to indicate the completeness of the node and all its children. While in particular embodiments the acceptance status of a particular node changes as a result of document decoder detecting the beginning of an instance of a child of that particular node the effective acceptance changes as a result of document decoder detecting a completed child of that particular node. Thus because the effective acceptance of a particular node reflects the completeness of hierarchical levels beneath that node effective acceptance may give a more accurate indicator than the acceptance status of the completeness of the node.

For example referring to the example unbound document of document decoder may determine an effective acceptance of unbound node an instance of element B based on the completeness of any required children nodes of unbound node . For example as shown in uncompiled schema indicates that instances of element B have a minimum of two instances of element C and a maximum of three instances of element C document decoder may determine an effective acceptance of the instance of element B based on the acceptance status of any children. In particular embodiments document decoder stores the effective acceptance or information describing the effective acceptance in an effective acceptance field not shown in the relevant state entry . Document decoder may then update the effective acceptance field as document decoder removes completed state entries from document state stack . Additionally document decoder may use the effective acceptance in any appropriate manner during decoding of unbound documents . As one example document decoder may display the effective acceptance of each unbound node to a user on GUI as described above with respect to the acceptance status.

Furthermore although this description focuses on the uses of acceptance status during decoding of unbound documents the described techniques may also be used by document decoder or other applications or components of data processing system to determine the completeness of other types of documents during decoding or other forms of processing. Moreover other application or components of data processing system may utilize the described techniques while processing data documents to establish the acceptance status of nodes being processed by those components. For example in a particular embodiment of data processing system generating application may utilize these techniques while validating data documents and GUI may reflect whether nodes in those data documents are well formed based on the described techniques for determining the acceptance status of these nodes .

Although the above description focuses for the purposes of illustration on an embodiment in which document decoder utilizes the described techniques for determining an acceptance states or an effective acceptance in alternative embodiments any element of data processing system may utilize these techniques. Furthermore any element may interact with GUI to provide GUI with information pertaining to acceptance status and effective acceptance. In particular embodiments of data processing system a virtual machine that functions as binding module also supports the described techniques and in addition to providing the binding functionality described above with respect to may also provides acceptance status and effective acceptance information to GUI .

As a result both acceptance status and effective acceptance may be used to provide useful information to elements of data processing system and or using during decoding or other stages of operation. Additionally in particular embodiments acceptance status and effective acceptance may facilitate the processing of documents that utilize non standard XML delimiting. As a result the described techniques may provide a number of operational benefits.

Although the present invention has been described with several embodiments a myriad of changes variations alterations transformations and modifications may be suggested to one skilled in the art and it is intended that the present invention encompass such changes variations alterations transformations and modifications as fall within the scope of the appended claims.

