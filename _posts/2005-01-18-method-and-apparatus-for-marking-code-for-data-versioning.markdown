---

title: Method and apparatus for marking code for data versioning
abstract: A method, apparatus, and computer instructions for marking data versioning for code. Responsive to receiving an application programming interface call, a first marking statement in the code and a second marking statement are inserted in the code. A portion of code between the first marking statement and the second marking statement forms a marked section of code. A change made in data in an object caused by execution of the marked portion of code is detected. The detected change is tracked in manner such that the object may be restored to a prior state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07565645&OS=07565645&RS=07565645
owner: Lenovo (Singapore) Pte Ltd.
number: 07565645
owner_city: Singapore
owner_country: SG
publication_date: 20050118
---
The present invention is related to the following patent applications entitled Method and Apparatus for Dimensional Data Versioning and Recovery Management Ser. No. 11 037 127 entitled Method and Apparatus for Data Versioning and Recovery Using Delta Content Save and Restore Management Ser. No. 11 037 157 entitled Platform Infrastructure to Provide an Operating System Based Application Programming Interface Undo Service Ser. No. 11 037 267 entitled Virtual Memory Management Infrastructure for Monitoring Deltas and Supporting Undo Versioning in a Paged Memory System Ser. No. 11 037 000 entitled Infrastructure for Device Driver to Monitor and Trigger Versioning for Resources Ser. No. 11 037 268 entitled Method and Apparatus for Managing Versioning Data in a Network Data Processing System Ser. No. 11 037 001 entitled Heap Manager and Application Programming Interface Support for Managing Versions of Objects Ser. No. 11 037 024 and entitled Object Based Access Application Programming Interface for Data Versioning Ser. No. 11 037 145 filed even date hereof assigned to the same assignee and incorporated herein by reference.

The present invention relates to an improved data processing system and in particular to a method apparatus and computer instructions for processing data. Still more particularly the present invention relates to a method apparatus and computer instructions for managing versions of objects.

Data storage components variables collections and multi dimensional collections are used throughout all computer applications. During the execution of an application the contents of these types of data storage elements will change or evolve. These changes occur due to modifications or updates to the data. These changes may be made by user input or through programmatic means. As the program logic of an application progresses situations often arise in which the program state and the content of the data storage elements need to be reset to a prior state. This state may be an arbitrary state selected by the user or programmatically by an application. Mechanisms for incrementally saving and resetting data to a prior known state are present in many applications.

Currently available mechanisms are found in applications such as word processors for resetting or rolling back to a previous state. A word processor may allow a user to undo changes to a document such as deletions insertions or formatting changes.

A significant problem with existing mechanisms is that they are prone to inefficiencies and require explicit management by the application programmer or end user. Therefore it would be advantageous to have an improved method apparatus and computer instructions for data versioning and recovery management.

The present invention provides a method apparatus and computer instructions for marking data versioning for code. Responsive to receiving an application programming interface call a first marking statement in the code and a second marking statement are inserted in the code. A portion of code between the first marking statement and the second marking statement forms a marked section of code. A change made in data in an object caused by execution of the marked portion of code is detected. The detected change is tracked in manner such that the object may be restored to a prior state.

With reference now to the figures and in particular with reference to a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. Computer is depicted which includes system unit video display terminal keyboard storage device which may include floppy drives and other types of permanent and removable storage media and mouse . Additional input devices may be included with personal computer such as for example a joystick touch pad touch screen trackball microphone and the like. Computer can be implemented using any suitable computer such as an IBM eServer computer or IntelliStation computer which are products of International Business Machines Corporation located in Armonk N.Y. Although the depicted representation shows a computer other embodiments of the present invention may be implemented in other types of data processing systems such as a network computer. Computer also preferably includes a graphical user interface GUI that may be implemented by means of systems software residing in computer readable media in operation within computer .

Referring to a block diagram of a data processing system in which the present invention may be implemented. Data processing system may be a symmetric multiprocessor SMP system including a plurality of processors and connected to system bus . Alternatively a single processor system may be employed. Also connected to system bus is memory controller cache which provides an interface to local memory . I O bridge is connected to system bus and provides an interface to I O bus . Memory controller cache and I O bridge may be integrated as depicted.

Peripheral component interconnect PCI bus bridge connected to I O bus provides an interface to PCI local bus . A number of modems may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add in connectors. Communications links to other data processing systems may be provided through modem and network adapter connected to PCI local bus through add in connectors.

Additional PCI bus bridges and provide interfaces for additional PCI local buses and from which additional modems or network adapters may be supported. In this manner data processing system allows connections to multiple network computers. A memory mapped graphics adapter and hard disk may also be connected to I O bus as depicted either directly or indirectly.

Those of ordinary skill in the art will appreciate that the hardware in may vary. For example other peripheral devices such as optical disk drives and the like also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.

With reference now to a block diagram of a JAVA virtual machine JVM is depicted in accordance with a preferred embodiment of the present invention. JVM includes class loader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. JVM also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine may be for example Java interpreter or just in time compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example the Java Native Interface JNI .

Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by JVM to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks it pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the JVM pushes a new frame onto the Java stack of the thread. When the method completes the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a JVM method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined. Native method stacks stores the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some JVM implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. A heap is an area of memory reserved for data that is created at runtime. The constant pool is located in method area in these examples. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap each of which is shared by all threads running inside the JVM such as JVM . When JVM loads a class file it parses information about a type from the binary data contained in the class file. JVM places this type of information into the method area. Each time a class instance or array is created the memory for the new object is allocated from heap . JVM includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

The present invention provides a memory management subsystem to provide for data versioning and recovery management for objects in a heap. The mechanism of the present invention saves modifications or deltas in data when objects in memory are changed. A delta in data is the difference between the data in its prior version and its current version. The different deltas may be used to restore objects to a prior state. These deltas also are referred to as delta data. In these illustrative examples the memory management subsystem may include for example memory management and heap in .

The mechanism of the present invention modifies this heap to include objects for restoring delta data. In these examples delta data represents change values or data for a particular memory object. This delta data is associated with an index. This index may take various forms such as a number or a timestamp. In particular these changes are stored in a data structure for example a linked list in a heap. The mechanism of the present invention modifies the memory management system to automatically generate this linked list in the heap of a JVM without requiring any special requests from applications or the user. Alternatively the objects may be allocated in the heap to include the delta data.

In particular these changes between the prior data and the current data in its changed form are stored in a data structure such as for example a linked list in a heap. The data structure is associated with a memory object. In the illustrative examples a memory object is associated with the versioning data structure using at least one of a pointer and an offset. The mechanism of the present invention modifies the memory management system to automatically generate this linked list in the heap of a JVM without requiring any special requests from applications or the user.

Turning now to a diagram illustrating components used in data versioning and recovery is depicted in accordance with a preferred embodiment of the present invention. Memory management process receives requests from applications such as application and application to allocate objects such as objects and . Memory management process may be implemented in a memory management component such as memory management in JVM in .

In these examples the requests from application and application take the form of application programming interface API call and API call . An API is a language and message format used by an application program to communicate with the operating system. APIs are implemented by writing function calls in the program which provide the linkage to the required subroutine for execution. If these API calls include an argument or parameter indicating that delta data should be stored for restoring prior versions of an object objects and are allocated in a manner to allow for versioning of the objects to occur. In other words changes in data in these objects are stored in a manner to allow the objects to be restored to a prior version.

In these illustrative examples this delta data is maintained using delta object linked list which is a data structure located within heap . This list is allocated by memory management process . This particular data structure contains a linked list of entries that identify delta data for various objects such as object and object .

In this example object includes object header and object data . Object includes object header and object data . Object data and object data contain the data for the object in its current state. Object header includes a pointer or offset to delta object linked list . In a similar fashion object header also includes a pointer or offset in the delta object linked list .

In allocating object and memory management process also includes an indicator or tag with object headers and . As depicted object header contains tag and object header contains tag . These indicators or tags are used to identify objects and as objects for which delta data will be stored to allow restoring these objects to a prior state.

When application changes an object such as object memory management process creates an entry within delta object linked list to store the delta data. Specifically any changed values in object are stored within delta object linked list in association with the identification of object and an index such as a numerical value or a timestamp.

This change in data may be stored every time an object is changed. Alternatively the changes may be stored only when an application changes the data through an API call that includes an additional parameter or argument that indicates that the change is to occur. An example of an API call is set version object reference object version . The object reference is the identification of the object and the object version provides an identifier. Alternatively the object version may be excluded from the call. In this case memory management process may generate a version identifier to return to the application making the call.

In this manner all changes to object are stored within delta object linked list . Thus object may be returned to any prior state desired using this data structure.

If a request is received by memory management process to restore one of the objects in the heap to a prior state the process identifies the object and an index to identify the state that is desired. An example of an API call is restore version object reference object version . The object reference is a pointer to the object that is to be restored. The object version is an index used to identify the version of the object that is to be restored.

This index may be for example a numerical value or a timestamp. If for example object is identified in the request the object header is used to find delta object linked list . The index in the request is used to identify the desired state for object . Based on the particular entry identified in delta object linked list the linked list may be traversed to make the appropriate changes to object to return that object to its original state.

In these depicted examples all of the delta data for all objects is stored within delta object linked list . The entries that apply to a particular object may be identified through an object identifier that is found within each entry of delta object linked list .

In other illustrative examples a separate linked list data structure may be used for each object. In this case the object header provides an offset to the particular linked list data structure for that object.

Turning next to a diagram illustrating components used in providing data versioning and recovery management is depicted in accordance with a preferred embodiment of the present invention. In this example the versioning data also referred to as delta data is stored within the objects.

In this illustrative example memory management process receives requests from application and application in the form of API calls and to create objects and for use by the applications. In this example object is created for use by application and object is created for use by application . Memory management process may be implemented within memory management in . In these examples objects and contain delta data that allows these objects to be restored to a prior version or state.

Objects and are located in heap . Object includes object header object data and delta object linked list . Object header includes an offset to point to the beginning of delta object linked list in this illustrative example. Object data contains the current data for object . Delta object linked list contains entries that identify all of the delta data for object . In a similar fashion object header provides an offset to the beginning of delta object linked list . Object data contains the current data for object . Delta object linked list contains all the delta data for changes made to object data . These types of objects are created when a call to allocate an object includes an additional parameter or argument that indicates that the object should be restorable to a prior state. If this additional argument or parameter is missing the object s allocated normally.

In this illustrative example memory management process automatically increases the size of object in response to a request to allocate object in which the request includes an indication that that object is to store data needed to restore object to a prior version or state. This increased size includes space needed to store the delta data.

In addition to allocating these objects in response to a specific call requesting data versioning for the objects this type of allocation for objects and may be performed automatically without requiring an application or a user to request the additional memory to store delta data. Additionally memory management process may allocate more space for object and object as the object data and the delta data increase for these objects.

In this particular illustrative embodiment these objects may be moved and copied such that the delta data automatically is moved or copied with the objects. In this manner an object may be saved and reloaded at a later time with its delta data intact. In this fashion an object may be restored to a prior state at any time without having to locate or save data objects from the heap and restore those objects separately.

Turning now to a diagram illustrating a delta object linked list is depicted in accordance with a preferred embodiment of the present invention. In the depicted example delta object linked list is an example of delta object linked list as created by memory management process in .

In these illustrative examples delta object linked list contains entries and . As shown each of these entries contains a time stamp an object reference an array index and a value. The time stamp indicates when the entry was made. The object reference is the pointer to the object for the entry. The array index identifies the location in which data has changed and the value indicates the change in the data at that location.

In this illustrative example the prior state is identified through a timestamp. If the memory management subsystem receives a request identifying a particular timestamp and object the object may be returned to that state. Entry is the most recent entry while entry is the oldest entry. Entries and are entries for one object MS . Entries and are entries for another object MS . The mechanism of the present invention traverses the linked list from the most current entry to the entry identified by the timestamp. Entries for objects other than the selected object are ignored.

This type of traversal and restoration of data is provided as one manner in which an object may be restored to a prior state. Of course any process used to return an object to a prior state using delta data may be employed in these illustrative examples.

The delta in data may be identified or calculated in a number of different ways. In these examples the delta data may be calculated using an exclusive OR XOR . In other words the value of prior data may be XOR d with the value of the current data to identify the change in the current data as compared to the prior data. The result of this function is considered the delta in the data in this example. With this delta the current data may be restored to the value of the current data. The data may be for example the values for data in all of the heaps managed by a memory management system. The delta in the data also may be calculated using Moving Picture Experts Group processes such as MPEG 2. With these processes every delta is similar to a video frame with respect to normal use in processing video data. Instead the deltas are for one or more memory segments. As with a video in which not every pixel necessarily changes from frame to frame not all of the data elements within a memory segment may change from one delta to another delta. Compression algorithms similar to MPEG2 can be employed which minimize the amount of memory required to store the necessary information or delta to restore the memory segments to prior values.

Turning next to a diagram of a delta object linked list is depicted in accordance with a preferred embodiment of the present invention. Delta object linked list is an example a list that is found in an object. In particular delta object link list may be implemented as delta object linked list in object in .

As shown delta object linked list includes entries and . Each entry includes a time stamp an array index and a value. An object reference is not included in this list as with delta object linked list in because this list is contained within the object for which changes in data delta data is stored.

Although specificy types of changes in data in which an array is used to identify where changes in data has occurred any type of system may be used to identify changes in data.

Additionally the mechanism of the present invention allows for portions of code to be marked in which objects on the marked portions are tracked for changes. This mechanism is implemented in a memory management process such as memory management process in .

In a diagram illustrating marked code is depicted in accordance with a preferred embodiment of the present invention. Code is marked using begin tag and end tag to create marked portion . Additionally begin tag and end tag define marked portion .

Any alterations or changes to objects in marked portion and marked portion are tracked in the manner described above. This type of tracking does not require calls to be made by the application to identify particular objects. With this marking mechanism the speed of execution in a data processing system is increased because only objects of interest are versioned instead of all objects when data changes during execution of code.

With reference to an example of marked code is depicted in accordance with a preferred embodiment of the present invention. Code is an example of marked portion of code such as marked portion in . Line is an example of a begin tag while line is an example of an end tag. Line and line contain instructions that alter objects.

When line is encountered during the execution of code any changes to objects are tracked. Execution of line results in the changes to object ACCT being tracked. In other words the change is stored in a data structure such as delta object linked list in . In this manner this object may be restored to a prior version or state. Execution of line results in a similar storing of data for object ACCT. When line is encountered tracking changes to objects no longer occurs when execution of line occurs incrementing the object ACCT.

The tags illustrated in may be placed in to the code using different mechanisms. For example a programmer may manually insert these tags through a user interface. Alternatively the user interface may allow a user to select a portion of a code such as a class or set of classes. In this example the user enters the name of the class and the memory management process locates and inserts tags around the class.

Turning now to a flowchart of a process for allocating objects is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a memory management process such as memory management process in .

The process begins by receiving a request to allocate an object step . In these examples the request is received from an application such as application in in the form of an API call to the JVM. In response the size of the object is identified step . Several options exist as to where in memory to place the delta object linked list. The consideration of which option to choose is based upon tradeoffs in performance and or memory usage. In a preferred performance optimized embodiment the delta object linked list is co resident in memory with the data element for which it contains delta information. In this case at object creation memory is allocated sufficient to contain both the data element and an estimated size for the delta object linked list. In these examples the estimated size being calculated primarily by the number of deltas desired to be retained. The object size for the object is increased to include the delta object linked list step .

Next an offset is calculated and stored in the object header step . This offset is used by the memory management subsystem to point to the delta object linked list. The object is then allocated and tagged step . The object is tagged by including a tag or indicator within the object. This tag or indicator is used to identify the object as one in which delta data is stored for versioning. An object reference is then returned to the requestor step . This object reference is by the requester to write or read the object.

At this point the requester may access the allocated object. In these illustrative examples step may be an optional step depending on the particular implementation. In the instance in which the delta object linked list is allocated as a separate data structure from the object this step may be skipped.

Turning now to a flowchart of a process for storing delta data is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a memory management process such as memory management process in .

The process begins by detecting an alteration of the data in the object step . This step may occur in different ways for example when the memory management process receives a request to change data in an object. When that change is processed a determination is made as to whether the object is tagged step . The tag is used to indicate whether the object is set up such that changes in data can be stored for the object. If the object is tagged an entry is created in the delta object linked list step with the process terminating thereafter. Otherwise the process terminates without storing the delta data. The linked list in step may be a combined linked list for all objects being managed. Alternatively the linked list may be one that was created within the object when the object was allocated or as a separate linked list associated with the object.

Turning now to a flowchart of a process for returning an object to an earlier state is depicted in accordance with a preferred embodiment of the present invention. In this illustrative example the process in may be implemented in a memory management process such as memory management process in or memory management process in .

The process begins by receiving a request to restore an object to an earlier state step . This request may be received from an application or a user input. Additionally the request may be received from another process such as an operating system or JVM process requiring the object to be returned to some other state. An index and an object identifier are identified from the request step . The location of the delta object linked list is identified from the object step . In step the location of the delta object linked list is identified using the offset from the object header. Thereafter the object is restored to the earlier state using the delta data in the delta object linked list using the index step with the process terminating thereafter.

Turning now to a flowchart of a process for restoring an object to an earlier state is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in is a more detailed description of step in .

The process begins by selecting a most recent unprocessed entry in the delta object linked list step . The object is then altered to include the value from the entry step . Next a determination is made as to whether an entry identified by the index has been processed step . This step determines whether the particular index such as a timestamp for the object has been processed. If this entry has been processed the object has then been returned to the desired state with the process terminating thereafter.

Otherwise the process returns to step to select the next most recent unprocessed entry in the delta object linked list. In the instance in which the linked list includes entries for other object a determination may be included to determine whether the object identifier is for the object that is being restored.

Turning now to a flowchart of a process for marking code for versioning is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a memory management process such as memory management process in .

The process begins by receiving a marking API call step . This call may be for example an API call that includes the name of a class as a parameter. Begin and end statements are inserted in to the code step . Next a determination is made as to whether an unprocessed object is present in the marked code step . If an unprocessed object is present the object is processed by creating a versioning object for the identified object step . Step allows for delta data to be stored during execution of the code. Thereafter the process returns to step to determine whether additional unprocessed objects are present. The process terminates when all of the objects in the marked code have been processed.

With reference to a flowchart of a process for tracking changes in data is depicted in accordance with a preferred embodiment of the present invention. The process illustrated in may be implemented in a memory management process such as memory management process in .

The process begins by detecting a begin statement step . Code execution is then monitored step . A determination is made as to whether an object has been altered step . If the object is altered the change is tracked step . Next a determination is then made as to whether an end statement has been encountered step . If an end statement has been encountered the process is then terminated.

Turning back to step if a determination is made that no object has been altered the process returns back to monitor code execution step . The process also returns to step if an end statement is not found.

Thus the present invention provides an improved method apparatus and computer instructions for saving delta data and restoring an object to a prior state using the delta data. This mechanism is accessed through API calls to the JVM. In these examples a data structure containing entries is used to store changes in the data and memory segments. This data structure takes the form of a linked list in these illustrative examples. Of course other types of data structures may be used such as for example a table. In the depicted examples the linked list may be a single linked list for all objects being managed by a memory management subsystem. Alternatively in another embodiment this data structure may be located as part of the object or in a separate data structure in which each data structure is associated with a particular object that is being managed by the memory management subsystem.

The present invention also allows for marking sections of code for tracking changes to objects in the marked sections. Further a user may specify a class or set of classes that are to be marked through an application in the form of a user interface.

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such as a floppy disk a hard disk drive a RAM CD ROMs DVD ROMs and transmission type media such as digital and analog communications links wired or wireless communications links using transmission forms such as for example radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

