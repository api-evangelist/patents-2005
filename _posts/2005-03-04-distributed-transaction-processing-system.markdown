---

title: Distributed transaction processing system
abstract: A distributed transaction processing system is disclosed in which a process automation application receives a transaction request from a requesting application. In response to the request, the process automation application obtains a transaction definition for the transaction requested by the requesting application. This transaction definition comprises a plurality of operation definitions, which indicate a plurality of operations constituting the requested transaction. For each of the operation definitions in the transaction definition, the process automation application produces an operation request. These operation requests are sent to one or more service applications, and one or more responses are received by the process automation application after the operations are performed by the service applications. Based on the responses, the process automation application produces a transaction response, which is sent to the requesting application. In this manner, the requested transaction is completed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07661106&OS=07661106&RS=07661106
owner: Sun Microsystems, Inc.
number: 07661106
owner_city: Santa Clara
owner_country: US
publication_date: 20050304
---
This application is a divisional of U.S. application Ser. No. 09 574 335 entitled TRANSACTION DATA STRUCTURE FOR PROCESS COMMUNICATIONS AMONG NETWORK DISTRIBUTED APPLICATIONS filed May 19 2000 issued as U.S. Pat. No. 6 971 096 the contents of which are incorporated by reference as if originally set forth herein. The present application contains subject matter that may be related to the subject matter in U.S. patent application Ser. No. 09 850 521 DISTRIBUTED TRANSACTION PROCESSING SYSTEM filed May 4 2001 now abandoned and U.S. Pat. No. 6 772 216 INTERACTION PROTOCOL FOR MANAGING CROSS COMPANY PROCESSES AMONG NETWORK DISTRIBUTED APPLICATIONS filed May 19 2000.

Business entities have long recognized that substantial productivity and marketing benefits may potentially arise from conducting commercial business activities and business processes over distributed computer networks. In order for a business to achieve the full benefits of network based commercial activity the firm s existing commerce related or business process software application systems must communicate both among each other and with the application systems of other business entities. Earlier efforts at business to business commerce activity such as those led by Electronic Data Interchange EDI applications for example focussed on high volume transaction processing for large firms. Because of incompatible application file formats and communications protocols and requirements for expensive application programming changes to existing systems EDI applications were largely viewed as being commercially practical for only the largest companies and for only a select number of applications. Moreover because of a lack of any universal data interchange formats companies were and still are often prevented from exploiting their own enterprise systems integration to reach external partner applications. As a result a business may need to spend substantial time to extract redefine and update data to serve specific collaborative needs with partners or customers. In addition smaller companies with limited information technology development budgets or with old legacy systems may still be struggling with internal business systems integration issues.

In recent years the Internet distributed computer network has developed the infrastructure and data communications protocols to connect all businesses to each other regardless of their size geographic location or position in the supply chain. The Internet is a collection of interconnected individual networks operated by government industry academia and private parties that use a set of standard data communications protocols to form a global distributed network. Networked distributed computer systems may be configured as intranets extranets or publicly available systems using Internet technologies. Internet technologies provide business entities with another opportunity to achieve substantial productivity gains and marketing benefits by conducting internal business to consumer and business to business Internet based commercial activities among employees and with customers vendors suppliers and other parties related to their business enterprises. Internet based commercial activities referred to generally in the current literature as electronic commerce e commerce or e business include but are not limited to all types of business processes that can take place in a secure manner online as well as the more traditional buying and selling of goods and services. The Internet environment holds out the promise of true collaborative data exchange and software application interoperability for business firms of all sizes.

Several standardization efforts by industry consortia and e commerce vendors are underway in an effort to achieve Internet application interoperability and seamless transaction processing that will appear transparent to users. One recent standard Extensible Markup Language XML was adopted by the World Wide Web Consortium in February 1998. In its broadest sense XML is a system for defining validating and sharing document formats on the Web providing a universal format for structured documents and data. XML is a markup language for presenting documents on the Web that relies on tags and is a meta language for defining specific subject matter domains of markup tags. XML stores the definitions of tags in files called Document Type Definitions DTDs . DTDs also referred to as dictionaries vocabularies or schemas serve as a uniform source of data definitions for specific industries or fields of knowledge making it easier to exchange data not only within an organization but also among different companies. XML is an extensible standard because users may define their own electronic document type in the form of a DTD. The simple syntax makes an XML document easy to process by machine while the tags promote human understanding of document contents. XML style sheets called XSL describe how the tagged data in an XML program should be displayed. Further information about XML and the World Wide Web Consortium also known as W3C can be found at the W3C.org Web site.

Several efforts underway to standardize transaction processing use XML. In the financial industry for example J.P. Morgan Co. Inc. and Price Waterhouse Coopers recently proposed an XML dictionary called FpML Financial products Markup Language which would standardize XML tags in areas such as fixed income derivatives and foreign currency exchange. BizTalk is an industry initiative started by Microsoft Corporation of Redmond Wash. to establish a community of standards users with the goal of driving the rapid consistent adoption of XML to enable electronic commerce and application integration. The BizTalk design emphasis is to leverage existing applications data models solutions and application infrastructure and adapt these for electronic commerce through the use of XML. The group is defining the BizTalk Framework a set of guidelines for how to publish schemas in XML and how to use XML messages to easily integrate software programs together in order to build new solutions. Additional information about the BizTalk Framework is available at the biztalk.org website.

The Internet Open Trading Protocol IOTP provides an interoperable framework for Internet commerce that is independent of the particular type of payment system used and is optimized for the case where the buyer and the merchant do not have a prior acquaintance. IOTP describes the content format and sequences of messages that pass among the participants referred to as Trading Roles in an electronic trade. IOTP defines five different types of Trading Roles Consumer Merchant Payment Handler Delivery Handler and Merchant Customer Care Provider that are the ways in which organizations can participate in a trade. The IOTP framework is centered on an IOTP Transaction that involves one or more organizations playing a Trading Role and a set of Trading Exchanges. Each Trading Exchange involves the exchange of data between Trading Roles in the form of a set of IOTP Messages. Each IOTP Message is the outermost wrapper for an XML document that is sent between Trading Roles that take part in a trade. An IOTP message is a well formed XML document that contains several components including a collection of IOTP Trading Blocks Request Exchange Response that carries the data required to carry out an IOTP Transaction. An IOTP Trading Exchange consists of the exchange between two Trading Roles of a sequence of documents consisting of three main parts the sending of a Request Block by one Trading Role the initiator to another Trading Role the recipient the optional exchange of one or more Exchange Blocks between the recipient and the initiator and the sending of a Response Block to the initiator by the Trading Role that received the Request Block. For more information regarding IOTP the reader is referred to an Internet Draft document describing Version 1.0 of the IOTP published by the Internet Engineering Task Force IETF and available at the IETF.org web site as of February 2000.

The Open Buying on the Internet OBI available at the openbuy.org website standard from the OBI Consortium aims to standardize and secure the corporate purchasing model especially the high volume low dollar transactions that account for 80 of most organizations purchasing activities. OBI s goal is to establish a common ground for what is referred to as The Trading Web where OBI standards adopters establish trading relationships with other OBI standards adopters through secured access to extranet facilities connected via the Internet forming dynamic sets of interoperable systems. OBI defines an architectural approach for e commerce systems detailed technical specifications guidelines for development record layout formats file formats communication structures and protocols compliance testing guidelines and implementation assistance. The OBI standard includes precise technical specifications for the security transport and contents of OBI Order Requests and OBI Orders. In the currently published standard contents of OBI Order Requests and OBI Orders are based on the ANSI ASC X.12 s 850 a standard for an EDI purchase order. The OBI Consortium may provide support for XML documents in the future. For a complete discussion of the OBI technical specifications consult version 2.0 of the Open Buying on the Internet standard available at the openbuy.org obi specs obiv2.html website.

RosettaNet is an initiative by a consortium of more than thirty companies in the personal computer PC industry ranging from manufacturers to resellers. Two XML data dictionaries in development will provide a common set of properties required for conducting business among Consortium members. The first is a technical properties dictionary technical specifications for all product categories and the second is a business properties dictionary which includes catalog properties partner properties i.e. attributes used to describe supply chain partner companies and business transaction properties. The goal is a common business language that will link the entire PC industry s supply chain. These dictionaries coupled with the RosettaNet Implementation Framework RNIF an exchange protocol form the basis for an e commerce dialog known as the Partner Interface Process or PIP. RosettaNet s PIPs are specialized system to system XML based dialogs that define how business processes are conducted between electronic component and information technology products manufacturers software publishers distributors resellers and corporate end users. The purpose of each PIP is to enable the development of interoperable applications by providing common business data models and documents that enable system developers to implement RosettaNet interfaces. Each PIP includes one or more XML documents based on Implementation Framework DTDs specifying one or more PIP services transactions and messages. For further information the reader is referred to the RNIF document designated as version 1.1 and published Nov. 8 1999 discussing the RNIF in detail available at More information about RosettaNet is available at the rosettanet.org website.

Private vendors such as Ariba Technologies Inc. Commerce One Inc. and Concur Technologies Inc. are using XML to simplify the process of matching up RFPs and purchase orders over the Web. The Ariba Network platform also provides a range of Internet services for buying and selling organizations including supplier directories supplier catalog and content management access to supplier content and secure transaction routing. The Ariba Network platform is built around a multi protocol architecture that allows buyers to send transactions from their Ariba buyer enablement application in one standard format. The Ariba Network platform then automatically converts the order into the suppliers preferred transaction protocol eliminating the need for a single standard for electronic commerce and giving suppliers the freedom to transact in their preferred protocol over the Internet. Ariba Network automatically routes and translates transactions between buying organizations and suppliers using many major e commerce standards including Internet Electronic Data Interchange EDI VAN based EDI Open Buying on the Internet OBI secure HTML e mail auto FAX Catalog Interchange Format CIF and a protocol known as Commerce XML cXML . cXML defines a set of XML DTDs to describe the characteristics of non production Maintenance Repair and Operations MRO goods and services. cXML serves as a meta language to enable the development of intelligent shopping agents to assist with the corporate purchasing function. cXML s request response messaging is used to exchange transaction data between parties. These messages provide support for purchase orders charge orders acknowledgements status updating shipment notifications and payment transactions.

The public and proprietary efforts underway to standardize transaction processing in the distributed network environment are largely directed to specific industry function or subject matter domains such as PC supply chain management financial payment handling or corporate purchasing. Thus it appears that the standardization effort is directed to establishing predetermined descriptions of transaction message exchanges or dialogs that are specific to and optimized for a specific subject matter or industry domain. Automated commerce solutions that define interactions in terms of fixed message exchanges forgo the flexibility and adaptability required in today s dynamic marketplaces. There will be a wide range of interactions between any two parties in the marketplace that simply do not lend themselves to easy categorization or definition and that will change over time as the business needs change and as their relationship changes.

XML and related data representation standardization efforts combined with industry based e commerce standards efforts clearly expand the reach of Internet based e business to a wider range of enterprises and are efforts in the direction of an integrated Internet e commerce environment. But these efforts alone fall short of the complete integration needed. What is needed is a transaction processing architecture that directly supports users needs in the marketplace and a uniform consistent and flexible transaction definition capability that supports a full range of transaction processing in a distributed network environment.

The present invention is premised on the observation that a distributed network marketplace must be able to provide both services and support processes to the parties users who participate in the marketplace. For example a distributor who sells items from a catalog benefits from an easy to use catalog update service from its suppliers and a manufacturer benefits from the ability to request a bid with precise terms and to receive only those responses that meet the specified terms. Automated commerce solutions should allow for flexible and adaptable definition of these types of interactions to promote and facilitate dynamic marketplaces. Thus the present invention is premised on the further observation that a comprehensive e commerce solution must provide a framework or architecture that allows for the definitions of the most complex interactions between parties to be both easily configured and easily changed by the parties as their business needs change. Such a solution should also be platform independent to support a wide variety of computing environments.

The present invention provides a transaction processing architecture for a process automation application referred to as a commerce exchange server. The transaction processing architecture is premised on a user centric view in which a transaction is a single unit of work from the perspective of the requesting application or client. The transaction may require several processing components to achieve its end result. However once the user defines those components and their process flow using a unique and novel transaction definition data structure the commerce exchange server produces the messages needed to perform the transaction and manages the message flow to and from the service applications without further intervention from the user. Thus the commerce exchange server is much more than a mere conduit for the message exchange between client and service applications.

In this transaction processing model every transaction has one and only one input document sent from a requesting client application and one and only one output transaction response document sent back to the client. However each input and output document may have multiple components or sub documents. This design precept provides distinct and significant advantages over other transaction processing solutions. First it considerably simplifies the design of the commerce exchange server by limiting the message exchange between requesting and service applications. Developing client applications becomes straightforward when the client merely issues a transaction request and gets a single response back with the output it requested. In addition the commerce exchange server takes the complexities of managing a complete transaction away from the requesting client moving the low level transaction processing logic common to all transactions to a single source.

Finally this transaction processing model supports the three most common types of application interaction models in the e commerce environment. These models are generally known as request reply publish subscribe and broadcast. In an illustrated implementation of the commerce exchange server the request reply interaction model allows two parties to exchange information in an asynchronous or non blocking fashion. In asynchronous messaging the requesting application sends a transaction request to the commerce exchange server and may continue its own processing without waiting for the transaction to be processed. An acknowledgement response is sent that contains tracking information that allows the requesting party to query the status of the transaction request. In a publish subscribe interaction model two applications interact via an intermediary party. The applications that are interested in specific information register with the intermediary party. The information generating application posts or publishes the information to the intermediary which in turn passes this to the registered parties. In this model the information requestor and the information supplier never interact directly. The broadcast model is a special case of a model known as the multicast model both of which send a message to the members of a group of parties who support the requested operation. When the group size is less than the entire membership of a domain a message is broadcast to the group when the group size equals the entire membership sending the message to the entire group is referred to as multicasting. The message sent in this type of interaction model is typically one of two types a request message resulting in a reply message returned or a notify message that simply reports information or events. Note also that in the multicast interaction model the recipient group may or may not be subscription based. The information receiver application determines this from the content of the broadcast message. The transaction model of the present invention provides support for all three interaction models.

The transaction processing architecture is further premised on the discovery of a novel transaction definition data structure. This data structure allows the user to define a transaction composed of component operations and to define the order of those operations including determining whether an operation is a broadcast operation or whether more than one operation should be performed concurrently before proceeding to a next operation. The data structure also allows the user to specify the source of input data needed to perform each operation and to place conditional logic on the execution of an operation based on results of one or more previously executed operations. The transaction definition data structure allows a transaction to be specifically customized to the business needs of the user who defines the transaction.

In an illustrated embodiment of the present invention the transaction definition data structure is an XML document that includes multiple OPERATION sections for specifying the component operations that make up the transaction. An input section referred to as a JOIN section within an OPERATION section of the XML document includes markup tags for specifying the source of input data needed. A conditional logic section referred to as a SPLIT section within an OPERATION section of the XML document includes markup tags for specifying whether a subsequent operation in the operation flow should be conditioned on the output of a previous operation.

The transaction processing architecture supports this flexible and adaptable transaction definition model. The user provides a unique transaction identifier for each transaction definition stores them in a database of definitions and then simply requests that a transaction be performed by its transaction identifier. The transaction processing architecture of the present invention defines a transaction service that performs several essential functions. The transaction service obtains the appropriate definition builds an internal transaction processing data structure and performs the transaction. In an illustrated implementation of the transaction service all transaction definitions stored in the database are loaded at start up of the commerce exchange server and the transaction service obtains the appropriate definition from memory. In an alternate implementation the transaction service may retrieve the appropriate definition directly from the database. In the illustrated embodiment described herein the internal transaction processing data structure referred to as a transaction instance is a directed acyclic graph DAG with the conditionals and mapping functions and logic to represent the definition of the transaction. The transaction service then creates and maps the XML documents with input and output variables in order to create and send the various messages needed for transaction execution. The transactions service evaluates the conditional logic and traverses through the DAG in order to execute the transaction and produces and sends an output response to the requesting application.

The commerce exchange server including the transaction processing architecture that makes use of the novel transaction definition data structure may be implemented in any type of distributed network of processor controlled machines such as for example in the Internet environment. Protocols for implementing message exchanges in the Internet environment are disclosed in the Protocol patent application referenced above.

Therefore in accordance with one aspect of the present invention there is provided an XML extensible markup language transaction definition document stored on a computer readable medium comprising a plurality of operation data portions each defining an operation. The plurality of operations collectively define a transaction. Each operation data portion when parsed by a process automation application causes the process automation application to communicate with a service application program to perform the operation. At least one operation data portion comprises a conditional logic data portion that when parsed by the process automation application causes the process automation application to condition performance of a next operation on evaluation of operation response data from performing the operation.

In another aspect of the invention at least one operation data portion included in the XML transaction definition document indicates a broadcast operation and includes a broadcast data portion. When parsed by the process automation application the broadcast data portion causes the process automation application to communicate with a plurality of service applications to cause each service application to perform the operation. In a further aspect of the invention the broadcast data portion further includes an expression data portion indicating at least one of a mathematical expression a function and a variable data item. When parsed by the process automation application the expression data portion causes the process automation application to evaluate the at least one of the mathematical expression the function and the variable data item using the operation response data to determine the success or failure outcome of the broadcast operation.

In another aspect of the present invention there is provided a transaction definition data structure stored on a computer readable medium comprising a plurality of operation data portions indicating a plurality of operations collectively defining a transaction. Each operation data portion defines an operation. Each operation data portion comprises an operation identifier uniquely identifying the operation among the plurality of operations a service application name indicating a service application for performing the operation an input data portion indicating input data used by the service operation for performing the operation and a conditional logic data portion indicating evaluation data conditioning performance of the next operation on evaluation of operation response data received from the service application performing the operation.

In another aspect of the present invention there is provided a computer implemented method for performing a transaction comprising the steps of producing a transaction instance data structure indicating a plurality of operations constituting a transaction. The transaction instance data structure indicates a linking of the plurality of operations to indicate an operation performance order. The transaction instance data structure further indicates conditioning logic data for changing the operation performance order such that the plurality of operations is capable of being performed in more than one possible order. The computer implemented method for performing a transaction further includes for each of the plurality of operations producing an operation request message indicating input data for performing an operation sending the operation request message to a service application to perform the operation using the input data receiving an operation response message from the service application indicating output data from the operation and determining a next operation to perform using the conditioning logic data and the output data of the operation response message.

In yet another aspect of the present invention there is provided a distributed transaction processing system comprising a plurality of service application programs each capable of performing an operation and a data store including a plurality of transaction definitions. Each transaction definition indicates a transaction definition name uniquely identifying the transaction definition and a plurality of operation definitions indicating a plurality of operations constituting a transaction. The distributed transaction processing system further comprises a requesting application program that produces a transaction request message indicating a transaction definition name identifying one of the plurality of transaction definitions included in the data store and a computer having a memory device for storing a process automation application. The process automation application receives the transaction request message indicating the transaction definition name from the receiving application program and uses the transaction definition name to obtain the transaction definition from the data store. The process automation application produces an operation request message for each operation definition included in the plurality of operation definitions and sends the operation request messages to at least one service application program. The at least one service application program sends an operation response message to the process automation application in response to receiving an operation request message. The process automation application produces a transaction response message using the operation response messages and sends the transaction response message to the requesting application.

The novel features that are considered characteristic of the present invention are particularly and specifically set forth in the appended claims. The invention itself however both as to its organization and method of operation together with its advantages will best be understood from the following description of an illustrated embodiment when read in connection with the accompanying drawings. In the Figures the same numbers have been used to denote the same component parts or steps.

Each application component is referred to as a commerce exchange component or CXC. As shown in there may be any number of CXCs identified to CX server . A CXC application either provides one or more services or originates a transaction request or both. A CXC application may be integrated with CX server as a built in component residing on the same machine or it may be a third party application resident on a different machine. For example service application is resident on machine and accessible to CX server via communications connection and requesting application is resident on machine and accessible to CX server via communications connection . The type of architecture model illustrated in may be variously described in the literature as an information bus model a client server model or a cooperative agent model.

CX server includes several processing services Communication service XML DOM service Transaction service and Persistence service . Communication service provides interfaces for accepting and establishing connections and sending and receiving messages through various network transport protocols. In an illustrated implementation of CX server the network transport protocol supported is TCP IP but other transport protocols may be supported as well. Communication service also provides a variety of other communications related services including notification of broken connections fragmentation and assembly of messages and connection level session management and handshaking functions.

CX server also includes an application interaction protocol processing function . CX server is a document centric process automation application exchanging messages in the form of XML documents between CXCs. These XML documents form the underlying message exchange protocol referred to as the Commerce Exchange Interaction Protocol hereafter CXIP. Standardizing the messaging format in this manner allows for the straightforward integration of third party applications as CXCs without the absolute requirement for application specific libraries. Each CXC includes two software interface components not shown for extracting transaction data from XML based message . A transportation communication module handles the syntax and semantics of the Application interaction message received from CX server over the particular communications transport mechanism e.g. TCP IP receiving a message and returning an XML document. Then an XML DOM Document Object Model module receives the XML document output produced from the transportation communication module parses the document and returns one or more DOM objects that are passed to the application logic for handling as standard program objects. The use of DOM objects is discussed in more detail below. A CXIP message is in the data representation format specified by XML which is presumed to be an 8 bit character format in the present implementation. Sending and receiving applications have the responsibility of encoding and decoding data embedded inside a CXIP message.

The present implementation of CXIP supports eight 8 message types that implement the three most common application interaction models Request Reply Publish Subscribe and Broadcast in the Internet environment. These eight message types are Request Reply Cancel Publish Notify Subscribe Unsubscribe and Acknowledge. An Acknowledge message is a special type of message used to acknowledge receipt of all of the other message types. An Acknowledge message may contain any information needed for tracking purposes such as for querying the status of a prior request or purposes of establishing an audit trail or transaction log. An application should follow the application interaction protocol by sending an Acknowledge message for each received message except for the Acknowledge message itself. Application interaction models may be implemented in either synchronous or asynchronous mode. An illustrated implementation of CX server operates in asynchronous mode also referred to as the offline or non blocking model. The Protocol patent application provides additional details about an illustrated implementation of the application interaction protocol.

The basic transport assumption in the application interaction protocol CXIP used by CX server is the guaranteed delivery of messages. As long as this requirement is satisfied the underlying transport protocol may be any standard communications protocol. As noted above the present implementation of CXIP is based on TCP IP. In this implementation CXIP messages are transmitted as TCP data between applications. A field size data item in the fixed length message header of a CXIP message indicates the length of the associated message content in byte counts so that the receiver may easily determine the end of a message without having to test for a special message termination character. CXIP may also be implemented on top of other transport mechanisms such as SMTP and FTP. Cooperating applications CXCs based on different transportation mechanisms e.g. SMTP or FTP are implemented by including a bridging mechanism in Communication service not shown for translating messages between TCP IP and SMTP and FTP message formats. To enable HTTP based interactions a MIME type may be defined such as application x cxip v10 and it is straightforward to develop a browser plug in to handle CXIP messages.

Transaction service provides interfaces for working with transaction logic tracking a transaction thread traversing transaction logic and performing transaction execution. CX server provides a virtual workspace or transaction execution space to participating registered CXC applications. A CXC submits a transaction request based on a published CX transaction document type declaration DTD . Upon receipt of a transaction CX server identifies the set of operations that comprise the transaction based on a transaction definition in data store and then executes the transaction by providing operation requests to CXCs identified as registered to perform the respective operations. Each invoked CXC performs the specified operation request s and sends back results to CX server which after completion of all operation requests returns the transaction response back to the originating CXC. A transaction definition takes the form of a directed acyclic graph. CX server with knowledge of the transaction logic from the transaction definition controls all processing decisions including which operations to perform to which CXC to forward an operation request how to process the conditions on the services which information to pass and receive and when to terminate processing.

XML DOM service provides interfaces and services for handling the XML documents that form the basis of the message exchange protocol. Services include parsing and constructing XML documents and building and accessing DOM Document Object Module object trees. The Document Object Model DOM is a platform and language neutral application programming interface API for HTML and XML documents that models these documents using objects. The DOM provides a standard set of objects for representing HTML and XML documents a standard model of how these objects can be combined and a standard interface for accessing and manipulating them. As an object model the DOM identifies the semantics of these interfaces and objects including both behavior and attributes and the relationships and collaborations among these interfaces and objects. Because of its platform and language independent format the DOM is used as an interface to proprietary data structures and APIs instead of product specific APIs in order to achieve application interoperability with less effort. Additional information regarding the DOM may be found at the w3.org DOM website.

XML DOM service may make use of any public domain XML parser. Although the XML based document messaging format is primarily used for exchanging active messages some internal data used by CX server are also represented and stored as XML documents. For example the transaction directed acyclic graph that defines the component services of a transaction is an XML document. Therefore other service components such as transaction service may use XML DOM service for translation between XML syntax and an internal data format requirement.

Persistence service provides interfaces for storing information into and retrieving information from external data stores . From the perspective of CX server or a CXC data entering into or coming from data stores are in XML document format. Persistence service has the responsibility of mapping between an XML document and the respective data store schema. In an illustrated implementation of CX server data stores include a Netscape message server a Netscape LDAP server and an Oracle database server. Support for flat files is also possible. Examples of information that are included in data stores are system parameters events and alerts and transaction definitions.

CX server executes as a single process that listens to one listener port and one administrative port for application protocol CXIP messages. The single process model distinguishes CX server from conventional application servers that follow the traditional multi process model. The single process model is critical to the implementation of conditional logic transaction processing and the complexities of event notification and process control over the CXCs. Moreover the single process model simplifies administration of the CX server by the system administrator and is more efficient in database access than a multi process model. In addition a single multi threaded process is typically more efficient than multiple single or multi threaded processes because it uses fewer system resources such as memory and disk space assuming that each thread is scheduled as having the same priority as the kernel thread. The capability of deploying a backup CX server addresses the problem of a single point of failure caused by using a single process model.

CX server supports both a single thread and multi thread model. A single threaded CX server listens to both the administrative and listener ports at the same time and processes incoming request one after another in serial fashion. Priority processing is not supported and event processing support is restricted. The single thread model does not allow for the CX server to load CXC libraries. The multi threaded CX server uses multiple threads for listening and accepting connections from the administrative port listening and accepting connections from the listener port listening and receiving messages from established connections priority processing of transactions messages and executing CXC libraries loaded as part of the process. The multi threaded model supports both serial and non serial processing of requests. Serial and non serial processing are distinguished by whether the message listening thread waits for termination of the thread that is created to process the message. Threading and serialization are determined by configuration parameters provided at startup.

In one embodiment of CX server a commerce exchange component CXC is expected to establish a persistent connection throughout the lifetime of the CXC to the CX server and to use the connection for all message exchanges. The CX server uses the connection to determine the existence of the CXC in the network. Each message received through a persistent connection is processed concurrently using an independent thread. This implementation improves message processing performance minimizes the usage of system resources and eliminates the overhead of establishing and terminating a connection for each new request.

In the illustrated implementation of CX server herein CX server supports asynchronous transaction processing. That is when an operation request is sent from CX server to a CXC the processing thread does not block for a response from the CXC and instead sets the state of the transaction and exits from the thread. When a response message is received the transaction is executed based on the state and the type of response. Support for asynchronous transaction processing achieves efficiency from the single shared connection between CX server and a CXC. Requests may be sent from the CX server simultaneously in multiple threads and the responses may be returned in any order according to how the CXC process them without waiting for the requests to be performed serially. In addition timer events may be introduced more easily thus creating an event driven processing model.

CX server also supports distributed transaction processing. A CX server in one enterprise or network may communicate with a CX server in another enterprise or network to cooperatively fulfil transaction requests. Thus one CX server that cannot fulfil a service component of a transaction request using a participating CXC in its own domain may send the operation request to another CX server not shown in that includes a participating CXC that has the capability to perform the service. This feature enables an enterprise or group of enterprises to deploy cooperating commerce exchange applications. Note also that while O shows TCP IP as the message transport protocol transportation module may be implemented on top of SMTP or FTP as well. Cooperating applications CXCs based on different transportation mechanisms may also be implemented by developing a bridge that translates messages from one protocol to another.

Preliminary to describing transaction processing and its associated data structures definitions are provided for some terminology that has specific meanings in the context of the present invention. These terms have the meanings given here throughout this disclosure rather than any meanings that may occur in other sources such as for example in documents if any that are incorporated by reference herein elsewhere in this description.

The term data or data item refers herein to physical signals that indicate or include information. Data includes data existing is any physical form and includes data this is transitory or is being stored or transmitted. For example data could exist as an electromagnetic or other transmitted signal or as a signal stored in electronic magnetic or other form. A data structure as used herein is any combination of interrelated data items. For example an XML document is a data structure. A data item indicates a thing an event or a characteristic when the item has a value that depends on the existence or occurrence or the measure of the thing event or characteristic. A first item of data indicates a second item of data when the second item of data can be obtained from the first item of data when the second item of data can be accessible using the first item of data when the second item of data can be obtained by decoding the first item of data or when the first item of data can be an identifier of the second item of data.

An operation is a single atomic process that acts upon input data to achieve a unit level function. An operation may sometimes be referred to as a service. The CX server handles an operation as a single unitary process while the scope and nature of the processing involved in an operation is defined by the service application that performs the operation. A transaction is a set of one or more operations that are to be performed in a defined order under given conditions by one or more participating service applications.

A transaction definition is a data structure that defines a type or category of valid transaction to CX server . A transaction definition includes the component operations that constitute the transaction the identity of the input data items required to perform each operation and the source of values for that data. A transaction definition also includes process flow information that indicates conditional logic if any to be applied to a component operation and the data items and format of the output results of the transaction. Note that a transaction definition may include only one transaction. A transaction database is a collection of one or more transaction definitions. Each transaction definition includes a unique identifier within a given domain referred to herein as a transaction definition name.

Every transaction definition conforms to a transaction directed acyclic graph data structure or transaction DAG. That is the transaction DAG specifies the ordered set of data items that are both required and optional for a transaction definition. A directed acyclic graph is known in the art as a set of nodes and a set of ordered pointers between the nodes that define at least one path through the graph subject to the constraint that no path starts and ends with the same node.

A transaction instance data structure or transaction instance is a specific implementation of a transaction definition that indicates the specific data to be used to perform the transaction defined by the transaction definition. Thus a transaction definition may be viewed as providing a template for producing a transaction instance when provided with specific input data on which to operate. A transaction instance has a unique identifier within a given domain referred to as a transaction ID associated with it.

In the illustrated implementation of the transaction service described below a transaction definition is specified using Extensible Markup Language or XML and so is a data object called an XML document. XML describes a class of data objects called XML documents and partially describes the behavior of computer programs that process them. XML is an application profile or restricted form of SGML the Standard Generalized Markup Language ISO 8879 . By construction XML documents are conforming SGML documents. Each XML document has both a logical and a physical structure. Physically the document is composed of units called entities. An entity may refer to other entities to cause their inclusion in the document. A document begins in a root or document entity. Logically the document is composed of declarations elements comments character references and processing instructions all of which are indicated in the document by explicit markup declarations. The logical and physical structures must nest properly as described in 4.3.2 Well Formed Parsed Entities in the World Wide Web Consortium XML specification. A software module called an XML processor is used to read XML documents and provide access to their content and structure. It is assumed that an XML processor is doing its work on behalf of another processing entity or module.

An XML document type declaration contains or points to markup declarations that provide a grammar for a class of documents. This grammar is known as a document type definition or DTD. The document type declaration can point to an external subset containing markup declarations or can contain the markup declarations directly in an internal subset or can do both. The DTD for a document consists of both subsets taken together. An XML document is valid if it has an associated DTD and if the document complies with the constraints expressed in its associated DTD. An XML document is a well formed XML document if the document taken as a whole matches the XML production labeled document meets all the constraints with respect to being well formed given in the XML specification and each of the parsed entities referenced directly or indirectly within the document is well formed. A well formed XML document may also be valid if it meets additional criteria as specified in World Wide Web Consortium Extensible Markup Language XML 1.0 W3C Recommendation 10 Feb. 1998. Additional information about XML is available at the w3.org XML website and the w3.org TR PR XML 971208 website.

A requesting or originating application submits a transaction request to transaction service . Transaction request is a data structure that indicates a request to process a transaction according to the transaction definition identified by a transaction definition name included in transaction request . A transaction is single unit of work from the perspective of the requesting application or client. In the transaction processing model of CX server every transaction has one and only one input document and one and only one output document although each input and output document may have multiple sub document components. Transaction service receives request and uses the transaction definition name to obtain the appropriate transaction definition . In the illustrated implementation of transaction service all transaction definitions included in transaction database are loaded into memory at the start up of CX server . However transaction service could also retrieve the appropriate transaction definition from among all transaction definitions included in transaction database .

Transaction service uses transaction DTD transaction definition and transaction request to produce a transaction instance data structure . The transaction instance is an internal data structure that transaction service uses to perform the requested transaction. In an illustrated embodiment of transaction service the transaction instance data structure is a directed acyclic graph. For every operation included in the transaction instance transaction service produces an operation request document . Operation request document is sent to a service application a CXC to perform the operation. schematically shows the production of operation request document using transaction definition transaction request transaction instance and transaction DTD . Transaction service uses transaction definition and transaction request to produce transaction instance which includes information about each operation in the transaction. Each operation is uniquely identified within transaction instance and includes the name of the service application that is to perform that operation. Transaction service obtains the input data needed for execution of the named operation from transaction request and provides it in operation request document according to specifications provided in transaction instance . Additional information about the content of the operation request document and how it is produced is discussed below.

Returning again to transaction service may send several operation request documents to a single service application and may send operation request documents from a single executable transaction to several service applications and . When a service application completes an operation it produces an operation response document indicating the results of the operation and sends operation response document to transaction service . Operations within a transaction instance are performed according to an order specified in transaction definition . Thus transaction service tracks the receipt of operation response documents both to determine what operation s to perform next and to determine when a transaction instance is complete. Transaction service may use operation results included in an operation response document to produce a subsequent operation request document for a subsequent operation to be executed.

When all operations of a transaction instance have been completed transaction service produces a transaction response document as shown schematically in using operation response documents and transaction instance . Transaction service obtains from transaction instance the format in which the originating requesting application expects to receive the output results of a completed transaction and prepares transaction response document using the results provided in operation response documents . Then as shown in transaction service returns transaction response document to requesting originating application .

Transaction definition of serves as a template for a specific transaction instance and is an XML document having the logical and physical structure specified by its associated transaction DTD . The general organization and major functional entities of the transaction directed acyclic graph data structure are schematically illustrated in with each functional entity shown as a named rectangular box. The identifying data entity names used in are not intended to limit the data structure in any way. The data entities are illustrated in a hierarchy to show each entity s constituent parts. An entity that may have more than one occurrence is illustrated by multiple offset boxes. Each occurrence includes all of the entities at lower levels in the hierarchy. Entities that are composed of the same data items are labeled with the same reference numbers. An entity that is required is shown with its box in solid outline while the box of an optional entity is shown with a dark dashed outline. A required entity indicates that either the data is explicitly included in the data structure or the necessary data is obtained from some other source by default. The entities that exist below an optional entity in the hierarchy are shown as being either required or optional for the case when the optional higher level entity is present in the transaction. Because an XML DTD expresses both a logical and a physical structure some of the data entities have logical processing associated with them. The entities and their processing behaviors are defined as follows. Note that the interpretation of DTD described below are defined by a specific implementation of transaction service and are not associated with the DAG data structure. For example the default behaviors that are described below when no value is provided for a tag or when an optional section is missing indicate the specific interpretation of the illustrated embodiment described herein. The interpretation of DTD described below thus reflect an illustrated embodiment of transaction service and other interpretations are also possible.

A transaction instance is composed of a set of ordered operations . In the directed acyclic graph an operation is represented by a node in the graph. Every transaction has two specific nodes or operations called the head operation and the tail operation. Operations and are shown as the head and tail operations respectively. Operation flow within a transaction always proceeds from the head operation to the tail operation. There may be one or more operations between the head and tail operations but each operation is performed only once. Note that if the operation is a broadcast operation it is still considered to be performed only once even though the operation may be sent to many service applications to be performed. There may be more than one possible path through the graph from the head operation to the tail operation and one of those possible paths is executed at runtime. Thus the path through the graph for a given transaction definition will not necessarily be the same for each transaction instance of that transaction definition because of differing run time conditions.

Each operation is defined to include five functional entities name Service application name INPUT CONDITIONAL LOGIC and OPERATION LINK S . These entities provide the information used to produce the operation request document used by a service application to perform this operation and to provide conditional logic to determine which operation s is to be performed after the completion of this operation. A unique operation name represents the operation within the context of its transaction. A service application or CXC name specifies the service application that can perform this operation. Note that the name of the operation can be determined at run time by looking up a CXC which has signed up to perform that operation.

The INPUT entity which is the only required entity provides information sufficient to prepare the operation s operation request document and . A list of expressions referred to as INPUT entity logic is used to build the input arguments for the operation request message for the operation to which this INPUT entity belongs. If the processing for the INPUT entity fails the operation will not be executed. If no INPUT entity is provided a default INPUT consolidates all of the preceding operations operation response documents into the operation request document for this operation. The ARGUMENT component provides an argument to add to the operation request document for this operation. It specifies the name and type of the argument along with a tag indicating if it is required or optional. The associated EXPRESSION component defines how to derive the value for this argument. An argument may derive its input data from another document or generate a value based on some EXPRESSION. DOCUMENT component identifies an XML document and defines how that document should be mapped to the indicated argument ARG . It defines the operation that contains the document and the relevant section s of the document to extract. Transaction DAG structure also includes runtime data in the form of OUTPUT entity which includes DOCUMENT entity for use in assembling the output response document.

An important feature of DAG structure and the reason that there may be more than one possible path through a transaction instance graph is that the execution of one or more of OPERATIONS except for operations and may be conditioned on the output of previous operations. The OPERATION LINK S component refers to explicit links between the present source operation and a destination next operation. Whenever the operation identified as the source operation completes the operation identified as the destination operation is considered for possible execution. Evaluation for execution is accomplished using the CONDITIONAL LOGIC CL entity . CL entity is used to decide which operations to consider for execution whenever the operation to which the CL entity belongs completes execution. It is comprised of a series of statements STMT that include an EXPRESSION entity which is evaluated typically using the output results of the completed operation. For each statement that evaluates to a true condition the list of operations held by that statement in the OPERATION ID entity is returned for consideration for possible execution. If there is no CL entity for an operation all operations identified as destination operations in the OPERATIONS LINK entity will be considered for possible execution.

An optional entity in transaction DAG structure is the BROADCAST entity . The presence of BROADCAST entity indicates that the operation is a broadcast operation and should be sent to more than one service application for processing. The optional subsections place success criteria on the broadcast operation to determine when to advance the operation as a whole. If RESPONSE entity is present a data value indicates that there are a minimum number of successful responses expected before this operation may be advanced. If EXPRESSION entity is present it specifies that an action should be performed and a value returned and evaluated before this operation may be advanced. An expression can be a simple value a math operation the value of a variable or the return value of a function.

In an illustrated embodiment of the present invention the transaction DAG data structure has the structure of the document type definition DTD shown in Table 1 and illustrated in and . The INPUT entity CONDITIONAL LOGIC entity and OPERATION LINK S entity of are referred to as JOIN section SPLIT section and OPLINK section respectively in Table 1 and in and .

TRANSACTION section is composed of one or more operations that are to be executed in the order specified under the conditions provided at each juncture. At the transaction level the designer must provide a NAME for the transaction that must be unique across all transactions that are defined within the domain of CX server . The name of the transaction is used for instantiating run time transactions of this type as the result of a Transaction Request Message . Optionally the user may provide a TIMEOUT value for the transaction. If specified this represents the maximum amount of time in seconds that a transaction has to complete execution once it has been started. If no value is provided or a value of zero is provided no timeout is assumed and the transaction may take as long as necessary to complete. The user defining the transaction definition may also optionally use the SAVE tag to specify whether or not to save transactions of this type to a data base of transactions also referred to as the persistence server. A value of YES for this field indicates that transactions of this type should be saved. If not specified the default turns saving ON for this transaction type.

Examples of portions of transaction definitions are provided to illustrate how the transaction DAG structure is used. Example 1 defines a transaction whose name is myTransaction whose run time instances should not be saved and can take at most 60 seconds to execute.

TRANSACTION section points to OPERATION section . Each operation must specify a NAME OPID and CXCNAME and optionally a TIMEOUT value. The name specifies the logical name of the operation and will often correspond to the service application CXC that executes it. There are two reserved names for two required operations known as CXtsHeadOp and CXtsTailOp. Every transaction must have a CXtsHeadOp and a CxtsTailOp the CXtsHeadOp is always the first operation in a transaction and the CXtsTailOp is always the last. These operations are in addition to any operations that are to be included in the transaction. The OPID is a numeric value that must be unique within the transaction definition no other operation within the transaction may have the same OPID value. The CXCNAME specifies the logical name of the CXC service application that can execute this operation. When the CXCNAME indicates a value of any CXC which has registered with CX server as being capable of executing this type of operation may be used. An operation may optionally specify a TIMEOUT value. If specified this defines the maximum amount of time an operation can take to execute. If no value is provided or a value of zero is provided no timeout is assumed and the operation can take as long as necessary to complete. Table 2 provides additional information about each of the data entities in the Transaction and Operation sections of the DAG data structure.

OPERATION section points to OPLINK section . A link between two operations is specified using an OPLINK section. Each OPLINK section includes a single SRCOPID tag and DSTOPID tag. There can be 1 n OPLINK sections per operation. The SRCOPID tag is the operation ID of the operation where the link starts and the DSTOPID tag is the operation ID of the operation where the link ends. Although not required it is good practice to have the SRCOPID match the OPID of the OPERATION section that contains the OPLINK section.

Operation links define the order of execution of the operations. When one operation completes its execution the operation links specify the set of operations that may be executed as a result. An operation is ready for execution when all other operations that have forward links to this operation have completed execution. Note that this includes operations that are considered complete for any reason including timeout failure or elimination due to split condition logic. If a split condition is specified the conditions defined by that split condition must be evaluated to determine which of the links to follow. For more details see the section below entitled Specifying conditional operation flow SPLIT logic. When defining a transaction the first set of operations that should be executed must be linked as destination operations from the CXtsHeadOp operation. The final set of operations must all have CXtsTailOp as their destination operations in their operation links. The OPID of the CXtsHeadOp conventionally has a value of zero although this is not mandatory. Table 3 provides additional information about each of the data entities in the OPLINK section of the DAG data structure.

An operation may be specified as having up to three additional optional components. The operation may be defined as a Broadcast Operation a set of Split conditions may be specified and the method of preparing the operation request document to the operation via a JOIN section may be defined. Each of these is described in more detail below.

SPLIT section is used whenever the decision about the next set of operations to execute depends upon some condition. SPLIT section provides the conditional logic on which to base the decision about the operation s to consider for execution next when the operation to which the SPLIT belongs completes execution. SPLIT section is comprised of a set of STMT sections statement which contain expressions to be evaluated. Within each STMT section is an expression section EXPR and a set of operation ID sections OPID . An expression is some condition to evaluate details about specifying an expression are provided in section g. below. The set of operation ID sections indicate those operations that should be slated for execution if the condition specified by the expression evaluates to a true value a non zero value . The operation IDs specified in the STMT sections must match one of the operation IDs in the set of operation links OPLINK for the operation containing the split condition. If there is no SPLIT section for an operation all operations identified as destination operations in the OPLINK section will be considered for possible execution. Table 4 provides additional information about each of the data entities in SPLIT section of the DAG data structure.

JOIN section is used to build the input arguments for operation request message for the operation to which this JOIN logic belongs. JOIN processing is essentially the translation of one or more documents into the operation request document. The join may be defined to map entire documents or specific sections of one or more operations into the operation request document or specific variables. The join may specify that only the input sections be mapped that only the output section be mapped or that both the input and output sections be mapped.

All operations considered for execution will have their JOIN section executed to build the operation request document. If the JOIN fails the operation will not be executed. If no JOIN is provided for a particular operation i.e. no input arguments are specified the default JOIN will consolidate the operation response documents of all of the preceding operations that belong to this transaction into the operation request document for this operation. In particular the default join maps all of the input and output variables of the previous operation s into the input and output sections of the operation request document for this operation. As previously noted default behavior is implementation specific and the Transaction DAG does not enforce this logic.

A join may be comprised of a series of argument sections ARG which specify the value to be given to one or more specific named variables in the operation request document of the operation. The ARG section consists of a series of tags defining the properties of the variable s in the operation request document and either an expression or document mapping to give the variable its value. Each variable is given a name NAME and a representation type VALTYPE along with an optional tag indicating if this variable is mandatory or optional OPTIONAL . If no OPTIONAL tag is provided or the value of the OPTIONAL tag is NO or no the variable is considered mandatory. If the OPTIONAL tag is present and its value is either YES or yes the variable is considered optional. This is used to determine how to proceed if the named variable cannot be given a value. If an optional variable is not available the join can still succeed provided that any other mandatory variables are available. If a mandatory variable is not available the join is considered to have failed and the operation cannot be executed. Failure of the operation may in turn cause the entire transaction to fail. The variables may be given values based on the evaluation of some expression EXPR or from a mapped document or specific section of a document.

When a function is to be executed a user who defines a transaction may specify the JOIN translation in one of several ways. A user may define a dynamic library DLL and an entry point the library is then loaded by CX server and executed. The output of the entry point would be a single document. A user may alternatively provide Java classes for translation purposes or may define a shell script mechanism. The shell script would get current documents as files and return the expected document in a location expected by CX server . Simple document translations may also be defined visually using a user interface mechanism for defining transactions. See Section 5.b. below for additional information about the user interface. Table 5 provides additional information about each of the data entities in JOIN section of the DAG data structure.

A broadcast operation is a special type of operation in which more than one instance of the operation is executed. The decision as to how many instances to execute is a run time decision made by CX server by sending operation requests to every CXC which has registered as capable of executing operations of this type. To specify an operation as a broadcast operation a BROADCAST section must be included. Within this BROADCAST section the two optional subsections of RESPONSE and EXPR may be provided.

If the RESPONSE section is present the MIN tag specifies the minimum number of responses required to be received before advancing past this operation. If no RESPONSE section is defined the default is that all operation requests sent on behalf of this broadcast operation must be received before the operation as a whole can be advanced.

If the EXPR section is present this indicates an expression that must be evaluated against each response received to determine if it should be counted toward the minimum. If no EXPR section is present all responses received will be counted toward the minimum if a minimum is specified . See the section Specifying an Expression for more information about expressions. Table 6 provides additional information about each of the data entities in BROADCAST section of the DAG data structure.

The EXPR section is used for split conditions for determining values for arguments in a JOIN and for defining BROADCAST advance criteria. An expression may be a simple value VALUE an operation OPERATOR a function FUNCTION or the value of a specified variable VAR . When an expression is a simple value whenever the expression is evaluated it always returns the configured value. The VALUE parameter of the EXPR section could be used to initialize some variable in an operation to a configured value. An expression may be defined as the value of a named variable using the VAR tag. Whenever the expression is evaluated the value of the named variable is returned or an error is returned if the variable could not be found. Using the VAR tag in an expression also requires the following additional information the name VARNAME of the variable the ID of the operation that contains the variable OPID the document that contains the variable OPDOCIOTYPE the section of that document that contains the variable OPDOCVARTYPE and the representation type of the value VALTYPE .

An expression may be a math operation OPERATOR applied to one or more variables. Supported math operations include the most commonly used operations such as greater than equal to less than plus minus and multiplication. All of the math operations with the exception of PLUS can only be applied to numeric values VALTYPE NUMVALUE . Note that math operations do not work on document values. An expression may also be defined to return the result of executing a named function. A function as an expression requires the name of the function FUNCNAME the path and library where the function is defined LIBNAME and the type of value returned by the function VALTYPE . When evaluated the EXPR section returns the evaluation result or an indication of an error if the expression could not be evaluated. An error occurs if the desired variable or function is not available or the expression was not correctly defined. Table 7 provides additional information about each of the data entities in EXPR section of the DAG data structure.

The general functions of transaction processing service of are illustrated in the flowchart of . These functions are described below with reference to the components shown in . CX server receives messages from requesting applications and service applications. CX server after handling message protocol functions passes these received messages to transaction service in box . CX server uses transaction service to track a transaction thread to traverse transaction logic and to perform transaction execution. Transaction service provides a set of service interfaces with conditionals and mapping of DOM objects for working with the transaction logic. The service interfaces include those shown in Table 8.

As shown in transaction service handles four types of messages it may receive transaction request messages and operation response messages and it may send operation request messages and transaction response messages .

Transaction service first determines what kind of message has been received in the query boxes and . If the message is neither one control passes to a message error handling procedure and processing control returns to CX server . If the message is a transaction request message this is a new transaction and control passes from box to box where transaction service calls the StartTransaction interface to create a new transaction instance associated with a unique identifier referred to as the transaction ID and to start transaction execution. Creating a new transaction includes calling CreateTransaction to retrieve the transaction definition that matches the transaction name in request message from transaction definition database and producing the directed acyclic graph that represents the transaction instance. Transaction service then begins traversing the transaction instance graph by obtaining a list of operations for execution in box using the SPLIT logic of the head operation. For each operation in the operation list transaction service calls GetInputMSG to create the input document s for the operation in box using the information specified in the JOIN section for the operation and produces the operation request document in box . For each operation transaction service determines the service application name of the service application that is to perform the operation using the CXCNAME tag. Then transaction service returns the operation request document s CX server for sending to their respective service applications in box and control returns to CX server .

If the incoming message is not a transaction request as determined in box transaction service queries whether it is an operation response received from a service application in box . If the message is an operation response transaction service updates the transaction state. Each operation response message contains the transaction ID the operation name and the output results produced by the service application and is stored in a data store for later access and processing. The transaction state changes every time an operation response message is received.

Transaction service then determines in box whether the operation response message is in response to a broadcast operation. A broadcast operation may involve invoking more than one service application to perform the operation. In the illustrated implementation of transaction service the criteria for advancing to a next operation node is to wait until all responses to operations associated with the node are received. To determine whether a broadcast operation is completed the RESPONSE MIN and EXPR tags are used to determine how to process operation response messages. As noted earlier if the RESPONSE section is present the MIN tag specifies the minimum number of responses required to be received before advancing past this operation. If no RESPONSE section is defined the default is that all operation requests sent on behalf of this broadcast operation must be received before the operation as a whole can be advanced. If the EXPR section is present this indicates an expression that must be evaluated against each response received to determine if it should be counted toward the minimum. If no EXPR section is present all responses received will be counted toward the minimum if a minimum has been specified. Collectively these rules may be referred to as the broadcast advance criteria. If the query in box determines that this operation response message is in response to a broadcast operation then Transaction service in box queries whether the broadcast advance criteria have been met and if so control proceeds to box to advance the transaction. If broadcast advance criteria have not been met then this operation node is not complete the transaction cannot be advanced and control is returned to CX server .

If the message is an operation response message and there is no pending broadcast operation transaction service calls AdvanceTransaction procedure in box . Transaction service then calls GetTransaction to update the transaction instance s state information and then evaluates the SPLIT logic of the operation associated with this operation response message to obtain the next list of operations from the transaction instance graph. Transaction service queries in box whether there is a next operations list available. If a next list of operations is available then CX server still has more operations to perform for this transaction and the transaction may be advanced to have the appropriate service application s perform the next operations. Transaction service ensures that none of the operations in the list of next operations has a predecessor operation that is still pending and has not yet completed. Control passes to boxes and where the next operation request message s are produced and sent out as described above.

If the query in box indicates that there is no next operations list the transaction has been completed assuming that the incoming message is not in error . This means that the operation response message just received is for an operation whose SPLIT logic or OPLINK section points to the required tail operation in the transaction instance. The tail operation node is available as the next operation in the next operation list. Control then passes to boxes and where the transaction response message is created. The JOIN logic of the tail operation node contains the transaction response document format expected by the requesting originating application. Transaction service calls GetOutputMSG to obtain the output document for the transaction produces the transaction response message using this document format identifies the requesting application and then sends the transaction response message to that application in box .

Transaction service also supports transaction timer purging logging and recovery mechanisms that are not shown in . The timer mechanism allows transaction service to discontinue processing of this transaction if operation responses are not received in a timely manner. When operation responses are not received after retries and a waiting period the transaction instance is ended i.e. removed from memory and is marked as a timeout transaction in the data store of transactions. Creating a timer for each operation if needed is accomplished during AdvanceTransaction procedure . When transactions end there is a purging mechanism to remove the transaction object from all transaction lists.

Transaction logging involves saving the transaction instance sufficient run time information and transaction state changes to enable transaction recovery if a first CX server is no longer operational and a backup CX server assumes transaction processing. The following transaction data elements are saved during transaction logging the transaction instance the transaction request message the transaction response message if any and transaction attributes including the transaction ID the transaction DAG name transaction state information the originating requesting application identifier and name. Operation information saved includes operation request messages operation response messages the operation identifier OPID operation state information and broadcast operation information e.g. number of service applications requested and number of operations pending . Executing CXCs are saved as well. Transaction recovery may be done at the individual transaction level or for all transactions started by CX server .

Table 9 provides a transaction that may be used as a template to test the interface between a service application referred to as a CXC and transaction service of CX server . Transaction definition line 

The operation definition for OPID 1 further specifies the name of the operation An cxc template op 1 and the name of the CXC designated to perform the operation. Typically the NAME and CXCNAME fields will have the same value. So for example if the CXC to be executed is named Parse the line would read 

The JOIN tag identifies how this operation should build its operation request document. In this case this type of join will map all of the variables in the data section of the transaction request document into the data section of the operation request document. For example assume the transaction request document has the following data section 

The operation request document for operation is then sent to the CXC being tested. The transaction definition line 

A service application has access to a library of interfaces referred to as the CXsdk to interact with CX server . The interfaces enable a custom built application to include the application logic for the function of the CXC. The interfaces also provide for a service application to connect to CX server to register itself as a CXC to sign up for an operation and to send and receive messages. The CXsdk library also includes the XML parsing and constructing tools. The service CXC uses one of these interfaces to extract any needed variables from the operation request document it receives from CX server . The CXC then performs the function it has been configured to do. After completing its function the CXC issues an operation response document using the CXsdk and sends that document back to CX server and to operation the tail operation in the transaction graph of the TX Template transaction.

The role of the tail operation is to build the transaction response document that is sent back to the CXC that requested the transaction providing information about the transaction that just executed. The join section for operation identifies how to build the transaction response document. In this case this type of join will map all of the variables in the data section of the operation response document from operation OPID 1. CX server then sends the transaction response document back to the requesting CXC. Finally the transaction definition lines and respectively identify the end of the transaction definition for TX Template and the end of the XML document.

A user interface application may be provided with CX server for a user to design and specify a transaction definition. A user may construct a transaction visually by selecting from among operations that are available according to their descriptions. The user interface may provide assistance to the user when specifying a unique identifier for the transaction definition. In addition the user must identify the input and output DTD s of the transaction. The user interface may operate in one of two modes. The first is simply as a data entry tool for capturing the transaction definition. The second mode of operation allows for the user interface to validate the correctness of the definition dynamically by connecting to the CX server.

Machine includes a bus or other internal communication means for communicating information and a processor coupled to bus for processing information. Machine further comprises a random access memory RAM or other volatile storage device referred to as main memory coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions by processor . Machine also comprises a read only memory ROM and or static storage device coupled to bus for storing static information and instructions for processor and a data mass storage access device such as a magnetic disk drive or optical disk drive. Data mass storage access device is coupled to bus and is typically used with a computer readable mass storage medium such as a magnetic or optical disk for storage of information and instructions. Machine may include more than one storage access device . For example machine may include both a storage access device for a non removable medium such as an internal magnetic hard disk and a mass storage access device for a removable medium such as an optical CD ROM a magnetic floppy disk a PC card or magnetic tape.

Machine may but need not include a conventional display device capable of presenting images such as a cathode ray tube or a liquid crystal display LCD device or any other device suitable for presenting images. Display device is coupled to bus through bus for displaying information to a computer user. An alphanumeric input device including alphanumeric and other keys may also be coupled to bus through bus for communicating information and command selections to processor . An additional user input device is cursor control device such as a mouse a trackball stylus electronic tablet or cursor direction keys coupled to bus through bus for communicating direction information and command selections to processor and for controlling cursor movement on display device . Another device which may optionally be coupled to bus through bus is a hard copy device which may be used for printing instructions data or other information on a medium such as paper film or similar types of media. Note that the actual manner in which the physical components of machine are connected may vary from that shown in . The manner of connection may include hardwired physical connections between some or all of the components as well as connections over wired or wireless communications facilities such as through remote or local communications networks and infrared and radio connections. Note further that not all of the components of machine shown in may be required to carry out the functions of commerce exchange server or to make use of the transaction DAG data structure of the present invention. Those of ordinary skill in the art will appreciate that various configurations of machine may be used to carry out a particular implementation of commerce exchange server or the transaction DAG data structure. For example machine may be a Workgroup Enterprise server machine manufactured by Sun Microsystems Inc. of Mountain View Calif. that includes one or more Ultra SPARC processors and that operates using the Solaris operating system.

Machine further includes communication or network interface device coupled to bus through bus for use in sending data to and receiving data from other nodes of distributed network system according to standard network protocols. This communication device may include any of a number of commercially available networking peripheral devices such as those used for coupling to an Ethernet token ring Internet or wide area network.

Processor together with an operating system operates to execute instructions e.g. program code to produce and use data. The program code and data may reside in main memory RAM in read only memory on the non removable hard disk storage accessed by storage access device or even on another processor controlled machine connected to network . The program code and data may also reside on a removable medium that is loaded or installed onto machine when needed by means of a storage access device suitable for that purpose. When program code i.e. software implementing commerce exchange server is stored in a memory device accessible to processor machine is configured to perform the functions of commerce exchange server of and in particular to process transactions having the structured format illustrated in or and . An input transaction request message such as transaction request message of is provided from communication device and is forwarded via data bus to bus for storage in main memory for later access by processor . Processor executes program instructions included in one of the above described memory components that implement operation of . During execution of the instructions processor accesses memory or to obtain or store data necessary for performing its operations. For example when machine is configured to perform operation of processor may access transaction DTD or transaction DTD and in memory in order to perform the functions of transaction service starting a new transaction instance.

Software and data structure product may be commercially available to a purchaser or user in several forms. In one typical form software and data structure product is commercially available in the form of a shrink wrap package that includes data storage medium and appropriate documentation describing the product. In that case data storage medium also referred to as a computer readable medium is a physical medium that stores one or more data structures or instruction data that is accessed by storage medium access device or its equivalent. Storage medium access device is a device that can access data stored on a data storage medium. Storage medium access device may be contained in a distinct physical device into which data storage medium is inserted into mounted on or otherwise installed into in order for the storage medium access device to access and retrieve the data stored thereon. Examples of storage medium access devices include disk drives CD ROM readers and DVD devices. A storage medium access device may be physically separate from machine or enclosed as part of a housing of machine that includes other components. Mass storage device may also be remotely located not shown as part of some other processor controlled machine such as a server on network . Mass storage device may provide instructions retrieved from medium to processor via bus causing processor when executing the instructions to process transactions in accordance with the teachings herein. Mass storage device may provide one or more data structures retrieved from medium to processor via bus for use in processing transactions in accordance with the teachings herein. If device is remotely located program instructions and data structures are provided from storage medium to processor of machine by way of communication device from network .

Software and data structure product may also be commercially or otherwise available to a user in the form of a data stream indicating instruction data for processing transactions or one or more data structures for use in processing transactions in accordance with the teachings herein. The data stream is transmitted to the user over a communications facility from a remotely located storage device. In this case article is embodied in physical form as signals stored on the remotely located storage device the user accesses the contents of data storage medium in order to purchase or otherwise obtain a copy of those contents but typically does not purchase or acquire any rights in the actual remotely located storage device. When software product is provided in the form of a data stream transmitted to the user over a communications facility from the remotely located storage device instruction data and data structures stored on data storage medium are accessible via communications device . Alternatively a data stream transmitted to the user over a communications facility from the remotely located storage device may be stored in some suitable local memory device of machine or a data storage medium locally accessible to processor using bus .

Data storage medium may also be configured with transaction service processing instruction data for performing operation . shows representative examples of the functional components of instruction data such as advance transaction instructions and start transaction instructions . The instruction data and is provided to processor for execution when transaction service processing is to be performed. For example when instructions are provided to processor and processor executes them machine is operated to perform the operations for starting or advancing a transaction processing a broadcast transaction producing operation request messages or producing a transaction response message according to operation of . Note also that when software and data structure product comprises the entire commerce exchange server application of data storage medium may include additional instruction data not shown for carrying out operations and of CX server .

While the invention has been described in conjunction with one or more specific embodiments this description is not intended to limit the invention in any way. Accordingly the invention as described herein is intended to embrace all modifications and variations that are apparent to those skilled in the art and that fall within the scope of the appended claims.

