---

title: Profile based capture component
abstract: An indexing system in a computer system may include applications, a capture processor, a queue, a search engine, and a display processor. The indexing system captures events of user interactions with the applications. Events are queued and if indexable, indexed and stored for user access through the search engine. Capture components in the capture processor can include a keyboard capture component that processes user keystrokes to determine events. A display capture component captures event data from windows associated with the applications. Display event data can be captured on a polling schedule or based on state changes of window elements. To determine target applications and window applications of interest application profiles and window profiles can be used.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07680809&OS=07680809&RS=07680809
owner: Google Inc.
number: 07680809
owner_city: Mountain View
owner_country: US
publication_date: 20050204
---
This application is a continuation in part CIP of and claims priority from U.S. application Ser. No. 10 814 773 titled Methods and Systems for Information Capture and filed on Mar. 31 2004 by Lawrence et al.

The invention generally relates to search engines. More particularly the invention relates to methods and systems for information capture.

Users generate and access a large number of articles such as emails web pages word processing documents spreadsheet documents instant messenger messages presentation documents multimedia files and the like using a client device such as a personal computer personal digital assistant mobile phone or the like. Some articles are stored on one or more storage devices coupled to accessible by or otherwise associated with the client device s . Users sometimes wish to search the storage device s for articles.

Conventional client device search applications significantly degrade the performance of the client device. For example certain conventional client device search applications typically use batch processing to index all articles which results in noticeably slower performance of the client device during the batch indexing. Additionally batch processing occurs only periodically. Therefore when a user performs a search the most recently accesses or created articles are sometimes not included in the results. Moreover if the batch indexing is scheduled for a time when the client device is not turned on it may not take place for an extended period of time. In that case the index of articles associated with the client device can become significantly outdated. Conventional client device search applications can also need to rebuild the index at each batch indexing or build new partial indexes and perform a merge operation that can use a lot of client device resources.

Conventional client device search applications also sometimes use a great deal of system resources when operational resulting in slower performance of the client device.

Additionally conventional client device search applications generally require the user to explicitly provide a search query to the search application to generate results and may be limited to examining file names or the contents of a particular application s files.

A computer based method for capturing event data from a target window of a target application in a computer system includes comparing window information with a target window profile that is associated with the target window of the target application and capturing event data from the target window upon detecting a state change of a state associated with an element in the window. Embodiments of the present invention include methods systems and computer readable media for information capture storage and indexing.

In one embodiment a method for capturing event data from a target window of a target application in a computer system additionally includes receiving window creation information from an application and determining whether the application is an instance of the target application. In one embodiment to make this determination the window creation information is compared with a target application profile which is associated with the target application.

In another embodiment a computer based method for indexing events in a computer system includes receiving captured event data from a target window. The target window is associated with a target application. The method also includes determining an event based on the target application and also based on user input. In this embodiment the method also includes determining whether to index the captured event data and storing the event.

Another aspect of the invention provides a computer based method for determining indexing events by receiving a plurality of display calls. The display calls are associated with computer applications in the computer system. The method includes processing the plurality of display calls to determine a target window. The processing is based on target window profiles. The method also includes determining an event based at least in part on data captured from the target window.

In yet another embodiment the invention provides a method that compares application related data with stored target application profiles associated with a plurality of target applications. The application related data is from applications associated with windows executing in a computer system. The method also includes subscribing to window creation events through the operating system of the computer system. Window creation request information is received from an application. The window creation request information is compared with the stored target application profiles. Then establishing hooks into processes for each target application. Window element information for each process of each target application is compared with a plurality of stored target window profiles associated with target windows of the target applications. The method also includes monitoring state changes for states associated with display elements in windows matching a target window profile. In this embodiment the method includes capturing from each matched window event data upon detecting a state change of the monitored states. The event data is captured into an event associated with each matched window. This capturing includes modifying application behavior of the matched applications based on the capture component code. The method also includes completing the events associated with the matched windows in response to closure of the matched window.

The features and advantages described in the specification are not all inclusive and in particular many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings specification and claims. Moreover it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the inventive subject matter.

The figures and the following description relate to preferred embodiments of the present invention by way of illustration only. It should be noted that from the following discussion alternative embodiments of the structures and methods disclosed herein will be readily recognized as viable alternatives that may be employed without departing from the principles of the claimed invention.

Referring now to the drawings in which like numerals indicate like elements throughout the several figures shows a diagram illustrating an exemplary environment in which one embodiment of the present invention may operate. While the environment shown in reflects one client side search engine architecture embodiment other client side or server side embodiments are possible. The system includes multiple client devices that can communicate with a server device over a network e.g. the Internet. In other embodiments other networks such as an intranet home local area network LAN or the like may be used instead. Moreover in other embodiments functions described with respect to a client or a server in a distributed network environment may take place within a single client device without a server device or a network. The implementation of these techniques as well as similar adaptations falls within the scope of this invention.

The client devices shown in each include a computer readable medium e.g. memory devices storage media and the like. In one embodiment a client device includes a random access memory RAM coupled to a processor . The processor executes computer executable program instructions stored in memory . Such processors may include a microprocessor an ASIC state machines or other processors and can be any of a number of suitable computer processors such as processors from Intel Corporation of Santa Clara Calif. and Motorola Corporation of Schaumburg Ill. Such processors include or may be in communication with media for example computer readable media which stores instructions that when executed by the processor cause the processor to perform the steps described herein. Embodiments of computer readable media include but are not limited to an electronic optical magnetic or other storage or transmission device capable of providing a processor such as the processor of client with computer readable instructions. Other examples of suitable media include but are not limited to a floppy disk CD ROM DVD magnetic disk memory chip ROM RAM an ASIC a configured processor all optical media all magnetic tape or other magnetic media or any other medium from which a computer processor can read instructions. Also various other forms of computer readable media may transmit or carry instructions to a computer including a router private or public network or other transmission device or channel both wired and wireless. The instructions may include code from any suitable computer programming language including for example C C C Visual Basic Java Python Perl and JavaScript.

Client devices can be coupled to a network or alternatively can be stand alone machines. Client devices may also include a number of external or internal devices such as a mouse a CD ROM DVD a keyboard a display device or other input or output devices. Examples of client devices are personal computers digital assistants personal digital assistants cellular phones mobile phones smart phones pagers digital tablets laptop computers Internet appliances and other processor based devices. In one embodiment the client devices may be any type of processor based platform that operates on any suitable operating system such as Microsoft Windows or Linux and that are capable of executing one or more client application programs. For example the client device can include a personal computer executing client application programs also known as client applications . The client applications can be contained in memory and can include for example a word processing application a spreadsheet application an email application an instant messenger application a presentation application an Internet browser application a calendar organizer application a video playing application an audio playing application an image display application a file management program an operating system shell and other applications capable of being executed by a client device. Client applications may also include client side applications that interact with or accesses other client or remote applications such as for example a web browser executing on the client device that interacts with a remote e mail server to access e mail .

The user can interact with the various client applications and articles associated with the client applications via various input and output devices of the client device Articles include for example word processor documents spreadsheet documents presentation documents emails instant messenger messages database entries calendar entries appointment entries task manager entries source code files and other client application program content files messages items web pages of various formats such as HTML XML XHTML Portable Document Format PDF files and media files such as image files audio files and video files or any other documents or items or groups of documents or items or information in electronic form suitable for storage access in client devices.

The user s interaction with articles the client applications and the client device creates event data that may be observed recorded analyzed or otherwise used. An event can be any occurrence possible associated with an article client application or client device such as inputting text in an article displaying an article on a display device sending an article receiving an article manipulating an input device opening an article saving an article printing an article closing an article opening a client application program closing a client application program idle time processor load disk access memory usage bringing a client application program to the foreground changing visual display details of the application such as resizing or minimizing interacting with windows associated with the client applications and any other suitable occurrence associated with an article a client application program or the client device whatsoever. Additionally event data can be generated when the client device interacts with an article independent of the user such as when receiving an email or performing a scheduled task.

In one embodiment the memory of the client device can also contain a capture processor a queue and a search engine . The client device can also contain or is in communication with a data store . The capture processor can capture events and pass them to the queue . The queue can pass the captured events to the search engine or the search engine can retrieve new events from the queue . In one embodiment the queue notifies the search engine when a new event arrives in the queue and the search engine retrieves the event or events from the queue when the search engine is ready to process the event or events . When the search engine receives an event it can be processed and can be stored in the data store . The search engine can receive an explicit query from the user or generate an implicit query and it can retrieve information from the data store in response to the query. In another embodiment the queue is located in the search engine . In still another embodiment the client device does not have a queue and the events are passed from the capture processor directly to the search engine . According to other embodiments the event data is transferred using an information exchange protocol. The information exchange protocol can include for example any suitable rule or convention facilitating data exchange and can include a communication mechanism such as for example Extensible Markup Language Remote Procedure Calling protocol XML RPC Hypertext Transfer Protocol HTTP Simple Object Access Protocol SOAP shared memory sockets local or remote procedure calling or any other suitable information exchange mechanism.

The capture processor can capture an event by identifying and extracting event data associated with an event. Examples of events include sending or receiving an instant messenger message a user viewing a web page saving a word processing document printing a spreadsheet document inputting text to compose or edit an email opening a presentation application closing an instant messenger application entering a keystroke moving the mouse hovering the mouse over a hyperlink clicking on buttons in windows selecting from menus or the like. An example of event data captured by the capture processor for an event involving the viewing of a web page by a user includes the URL of the web page the time and date the user viewed the web page and content of the web page. In addition in one embodiment additional event data can be captured from remote locations that include information related to the event or article. For example artist and other related information e.g. album director genre and the like for a movie or music file accessed by a user can be retrieved from a network database server across the network .

In one embodiment the capture processor may include multiple capture components. For example the capture processor can include a separate capture component for each client application in order to capture events associated with each application. The capture processor can also include a separate capture component to monitor and capture keystrokes input by the user and a separate capture component that can monitor and capture items such as text displayed on a display device associated with the client device The keystroke capture component and the display capture component can be used to capture events when a client application capture component is not available for a client application or in conjunction with a client application capture component. The keystroke capture component can also contain or access a keystroke database. The keystroke database can provide correlation between keystrokes and actions for applications. The keystroke capture component and the display capture component can also contain or access a history of previous keyboard or display events.

In one embodiment the capture processor can include a separate capture component that monitors overall network activity in order to capture event data associated with network activity such as the receipt of an instant messenger message. The capture processor can include a separate capture component that monitors overall client device performance data such as processor load idle time disk access the client applications in use and the amount of memory available. An individual capture component can monitor multiple client applications and multiple capture components can monitor different aspects of a single client application.

In one embodiment the capture processor through the individual capture components can monitor activity on the client device and can capture events by a generalized event definition and registration mechanism such as an event schema. Each capture component can define its own event schema or can use a predefined one. Event schemas can differ depending on the client application or activity the capture component is monitoring. Generally the event schema can describe the format for an event for example by providing fields for event data associated with the event such as time of the event and fields related to any associated article such as title as well as the content of any associated article such as document body . An event schema can describe the format for any suitable event data that relates to an event. For example an event schema for user input such as words typed or displayed to a display device can include the application used for the input the format of the text the words and other items input and the time input. An event schema for an email event received by a user can include header information such as the content from the subject to from cc and time received fields and body information. An event schema for a web page currently being viewed by a user can include the Uniform Resource Locator URL of the web page the time being viewed and the content of the web page. An event schema for a word processing document being saved by a user can include the title of the document the time saved the location of the document the format of the document the text of the document and a pointer to the location of the document.

In one embodiment the keyboard capture component may not use an event schema. Rather in this embodiment the keyboard capture component can convert keystrokes to a sequence of words and then can pass the sequence of words to another component such as the word processing capture component. The word processing capture component can use an event schema to express information sent by the keystroke capture component.

More generally an event schema can describe the state of the system around the time of the event. For example an event schema can contain a URL for a web page event associated with a previous web page that the user navigated from. In addition event schema can describe fields with more complicated structure like lists. For example an event schema can contain fields that list multiple recipients. An event schema can also contain optional fields so that an application can include additional event data if desired.

The capture processor can capture events occurring presently or real time events and can capture events that have occurred in the past or historical events . Real time events can be indexable or non indexable . In one embodiment the search engine indexes indexable real time events but does not index non indexable real time events. The search engine may determine whether to index an event based on the importance of the event. Indexable real time events can be more important events associated with an article such as viewing a web page loading or saving a file and receiving or sending an instant message IM or electronic mail email . Non indexable events can be deemed not important enough by the search engine to index and store the event such as moving the mouse or selecting a portion of text in an article. Non indexable events can be used by the search engine to update the current user state. While all real time events can relate to what the user is currently doing or the current user state indexable real time events can be indexed and stored in the data store .

Alternatively in one embodiment the search engine can index all real time events. Real time events can include for example sending or receiving an article such as an instant messenger message examining a portion of an article such as selecting a portion of text or moving a mouse over a portion of a web page changing an article such as typing a word in an email or pasting a sentence in a word processing document closing an article such as closing an instant messenger window or changing an email message being viewed loading saving opening or viewing an article such as a word processing document web page or email listening to or saving an MP3 file or other audio video file or updating the metadata of an article such as book marking a web page printing a presentation document deleting a word processing document or moving a spreadsheet document.

Historical events are similar to indexable real time events except that the event occurred before the installation of the search engine or was otherwise not captured because for example the search engine was not operational for a period of time while the client device was operational or because no capture component existed for a specific type of historical event at the time the event took place. Examples of historical events include the user s saved word processing documents media files presentation documents calendar entries and spreadsheet documents the emails in a user s inbox and the web pages bookmarked by the user. The capture processor can capture historical events by periodically crawling the memory and any associated data storage device for events not previously captured by the capture processor . The capture processor can also capture historical events by requesting certain client applications such as a web browser or an email application to retrieve articles and other associated information. For example the capture processor can request that the web browser application obtain all viewed web pages by the user or request that the email application obtain all email messages associated with the user. These articles may not currently exist in memory or on a storage device of the client device For example the email application may have to retrieve emails from a server device. In one embodiment the search engine indexes historical events.

In the embodiment shown in events captured by the capture processor are sent to the queue in the format described by an event schema. The capture processor can also send performance data to the queue . Examples of performance data include current processor load average processor load over a predetermined period of time idle time disk access the client applications in use and the amount of memory available. Performance data can also be provided by specific performance monitoring components some of which may be part of the search engine for example. The performance data in the queue can be retrieved by the search engine and the capture components of the capture processor . For example capture components can retrieve the performance data to alter how many events are sent to the queue or how detailed the events are that are sent fewer or smaller events when the system is busy or how frequently events are sent events are sent less often when the system is busy or there are too many events waiting to be processed . The search engine can use performance data to determine when it indexes various events and when and how often it issues implicit queries.

In one embodiment the queue holds events until the search engine is ready to process an event or events. Alternatively the queue uses the performance data to help determine how quickly to provide the events to the search engine . The queue can include one or more separate queues for example a user state queue and an index queue. In one embodiment the index queue can queue indexable events. Alternatively the queue can have additional queues or include a single queue. The queue can be implemented as a circular priority queue using memory mapped files. The queue can be a multiple priority queue where higher priority events are served before lower priority events and other components may be able to specify the type of events they are interested in. Generally real time events can be given higher priority than historical events and indexable events can be given higher priority than non indexable real time events. Other implementations of the queue are possible. In another embodiment the client device does not have a queue . In this embodiment events are passed directly from the capture processor to the search engine . In other embodiments events can be transferred between the capture components and the search engine using suitable information exchange mechanisms such as Extensible Markup Language Remote Procedure Calling protocol XML RPC Hypertext Transfer Protocol HTTP Simple Object Access Protocol SOAP shared memory sockets local or remote procedure calling or any other suitable information exchange mechanism.

Referring back to in one embodiment the search engine can contain an indexer a query system and a formatter . The query system can retrieve all real time events and performance data from the queue . The query system can use performance data and real time events to update the current user state and generate an implicit query. An implicit query can be an automatically generated query based on the current user state. The query system can also receive and process explicit queries from the user Performance data can also be retrieved by the search engine from the queue for use in determining the amount of activity possible by the search engine .

In the embodiment shown in indexable real time events and historical events indexable events are retrieved from the queue by the indexer . Alternatively the queue may send the indexable events to the indexer . The indexer can index the indexable events and can send them to the data store where they are stored. The data store can be any type of computer readable media and can be integrated with the client device such as a hard drive or external to the client device such as an external hard drive or on another data storage device accessed through the network . The data store can be one or more logical or physical storage areas. In one embodiment the data store can be in memory . The data store may facilitate one method or a combination of methods for storing data including without limitation arrays hash tables lists and pairs and may include compression and encryption. In the embodiment shown in the data store includes an index a database and a repository .

In the embodiment shown in when the indexer receives an event the indexer can determine from the event schema terms if any associated with the event the time of the event if available images if any associated with the event and or other information defining the event. The indexer can also determine if the event relates to other events and associate the event with related events. For example for an event concerning a web page the indexer can associate this event with other events concerning the same web page. This association information can be stored in the database in a document for each group of related events.

The indexer can send and incorporate the terms and times associated with the event in the index of the data store . The event can be sent to the database for storage and the content of the associated article and any associated images can be stored in the repository . The conversation object associated with instant messenger messages can be stored in the database .

In the embodiment shown in a user can input an explicit query into a search engine interface on the client device which is received by the search engine . In one embodiment the search engine interface on the client device includes a graphical textual display e.g. an HTML based web page. In alternative embodiments the search engine interface includes various input output modes for example a voice activated system a touch based system or the like.

The search engine can also generate an implicit query based on a current user state which can be determined by the query system from real time events. Based on the query the query system can locate relevant information in the data store and provide a result set. In one embodiment the result set includes article identifiers for articles associated with the client applications or client articles. Client articles include articles associated with the user or client device such as the user s emails word processing documents instant messenger messages previously viewed web pages and any other article or portion of an article associated with the client device or user An article identifier may be for example a Uniform Resource Locator URL a file name a link an icon a path for a local file any alphanumerical identifier or other suitable information that may identify an article. In another embodiment the result set also includes article identifiers for articles located on other systems on the network e.g. network articles located by a search engine on a server device. Network articles include articles located on systems on the network not previously viewed or otherwise referenced by the user such as web pages not previously viewed by the user

The formatter can receive the search result set from the query system of the search engine and can format the results for output to a display processor . In one embodiment the formatter can format the results in XML HTML or tab delineated text. The display processor can be contained in memory and can control the display of the result set on a display device associated with the client device The display processor may include various components. For example in one embodiment the display processor includes a Hypertext Transfer Protocol HTTP server that receives requests for information and responds by constructing and transmitting Hypertext Markup Language HTML pages. In one such embodiment the HTTP server includes a scaled down version of the Apache Web server. The display processor can be associated with a set of APIs to allow various applications to receive the results and display them in various formats. The display APIs can be implemented in various ways including for example as DLL exports COM interface VB JAVA or .NET libraries or as a web service.

Through the client devices users can communicate over the network with each other and with other systems and devices coupled to the network . As shown in a server device can be coupled to the network . In the embodiment shown in the search engine can transmit a search query included in an explicit or implicit query or both to the server device . The user can also enter a search query in a search engine interface which can be transmitted to the server device by the client device via the network . In another embodiment the query signal may instead be sent to a proxy server not shown which then transmits the query signal to server device . Other configurations are also possible.

The server device can include a server executing a search engine application program such as the Google search engine. In other embodiments the server device can include a related information server or an advertising server. Similar to the client devices the server device can include a processor coupled to a computer readable memory . Server device depicted as a single computer system may be implemented as a network of computer processors. Examples of a server device include servers mainframe computers networked computers a processor based device and similar types of systems and devices. The server processor can be any of a number of computer processors such as processors from Intel Corporation of Santa Clara Calif. and Motorola Corporation of Schaumburg Ill. In another embodiment the server device may exist on a client device. In still another embodiment there can be multiple server devices .

Memory contains the search engine application program also known as a network search engine . The search engine can locate relevant information from the network in response to a search query from a client device The search engine then can provide a result set to the client device via the network .

The result set can include one or more article identifiers. An article identifier may be for example a Uniform Resource Locator URL a file name a link an icon a path for a local file or anything else that identifies an article. In one embodiment an article identifier can include a URL associated with an article.

In one embodiment the server device or related device has previously performed a crawl of the network to locate articles such as web pages stored at other devices or systems coupled to the network and indexed the articles in memory or on another data storage device.

It should be noted that other embodiments of the present invention may include systems having a different architecture than that which is shown in . For example in some other embodiments of the present invention the client device is a stand alone device and is not coupled to a network.

Now referring to a flow diagram illustrating an exemplary embodiment of a method for capturing and processing event data associated with a client device is shown. It should be noted that various event data capturing and processing methods in accordance with embodiments of the present invention may be carried out. For example in one embodiment application data is captured based on an application program interface API associated with an application that is provided for interacting with the application. In another embodiment keystrokes associated with an application are captured and events are determined based on among other things actions associated with the keystrokes. In another embodiment display elements and related information is captured and events are determined based on at least in part the captured display information. These are some non exhaustive examples of the multiple event data capturing and processing methods in accordance with embodiments of the present invention.

In one embodiment it can be determined whether to index the event and the event can be indexed and stored if it is so determined.

In the capture processor captures an event. The capture processor can capture an event by identifying and compiling event data associated with the event upon the occurrence of the event. The capture processor may have separate capture components for each client application network monitoring performance data capture keystroke capture and display capture. For example an event can occur when a user types a predetermined number of words in a client application. The event data associated with this event can be for example the application used for the input the format of the text the words input and the time input. In one embodiment the capture component can use a generalized event definition mechanism such as an event schema that it has previously registered with the client device to capture or express the event.

In one embodiment the event can be a number of words and it can be determined that the plurality of associated actions forms a word or words. The word or words can be determined at least in part by the receipt of at least one keystroke indicating a space or a punctuation symbol. In another embodiment the event can be a number of characters and it can be determined that the plurality of associated actions form a character or characters.

In one embodiment a capture state can be updated after each keystroke is processed. In one embodiment a current user state can be updated based at least in part on the event. The event can be indexed and stored.

In one embodiment each associated action can be determined at least in part by matching the keystroke to an entry in a keystroke table and determining an action in the keystroke table associated with the entry. The action can include one of adding a character to a word deleting a character from a word inserting a character overwriting a character deleting a word deleting a paragraph selecting an item and repositioning the cursor. The keystroke table can be associated with the application or can be a generic keystroke table.

In another embodiment keystrokes associated with an application are received an event is determined based on user input and it is determined whether to index the event. User input can be one or more of a number of words determined from the keystrokes a number of characters determined from the keystrokes and a change is focus from the application to another application. Determining whether to index the event can include determining whether the event is important to the user.

In a keystroke database is provided. The keystroke database can contain for various client applications tables of keystroke commands and the respective action for each command. In one embodiment the keystroke database has a separate table for each separate client application. A generic table may be used for an application if a specific table does not exist for the particular application. In one embodiment the same table may be used for groups of applications. For example the same table may be used for applications from the same developer. For example the same table may be used for all Microsoft applications and a different table may be used for all applications from Lotus . Additionally the same table may be used for related applications such as Office applications from Microsoft or word processing applications from any developer. The keystroke tables can be created manually for each application. Alternatively the keystroke tables can be created automatically by automatically determining respective actions of each keystroke for each application.

In the keystroke capture component is called. The keystroke capture component can operate regularly or even constantly so that it monitors all keystroke activity or can be selectively called by the capture processor or other capture components when needed or at various times. In the keystroke capture component can determine the client application in focus. The application in focus is the client application currently being used by the user For example it can be the client application that the user is inputting text in. In one embodiment the application in focus is determined so that the keystroke capture component can use the keystroke table associated with the application in focus from the keystroke database. For example if the application in focus is a specific word processing application the keystroke capture component can call up the corresponding specific word processing application keystroke table.

In the event data is reset by the keystroke capture component. In one embodiment event data is complied in an event in a format defined by an event schema and the keystroke capture component can register a specific keystroke capture event schema and resetting the event includes clearing out any existing event data. A counter N can also be reset. In one embodiment the counter counts the number of words captured by the keystroke capture component. In such an embodiment when the event is reset the counter is reset to zero.

In the keystroke capture component captures a keystroke input by the user A user can input a keystroke through a variety of input devices such as a keyboard. A keystroke can include a single key input or a multiple key input and can include a text input and an editing command input. For example a keystroke can include the G key or the Shift and the G keys. A keystroke can also include the Backspace key or the Control and Backspace keys. The keystroke capture component can receive a keystroke by receiving keystroke messages through an application callback that can be invoked by the operating system. The keystroke capture component can also receive a keystroke through monitoring an input buffer such as a keyboard buffer at the operating system level. Other methods of inputting characters such as handwriting can be captured.

In the keystroke capture component processes the keystroke. In the embodiment shown the keystroke capture component processes the received keystroke by matching the keystroke to an entry in the keystroke table for the specific application in focus and determining the respective action for the keystroke. For example if the received keystroke is the SHIFT key and the G key in a specific word processing application the keystroke capture component can match the SHIFT key and the G key in the keystroke table for the specific application and determine the associated action for example the output of the letter G . If the received keystroke is the Control and Backspace keys the keystroke capture component can match these keys with the respective action in the keystroke table for the specific application and determine the associated action for example the action of deleting the word preceding the cursor. Other possible actions include moving the cursor up or down one line moving the cursor up or down one paragraph and moving the cursor to the beginning or end of a document for example. The keystroke capture component can keep track of the current position of the cursor with respect to previous characters entered. For example if the user types 5 characters hits left arrow three times types one character and hits right arrow three times the component can identify that the user went back and inserted a character in the word for applications where left arrow corresponds with moving the cursor back one character . The component can further keep track of whether each application is in insert mode so that it knows if new characters overlay any existing characters.

In another embodiment the keystroke capture component may not process the keystrokes directly. Instead the keystroke capture component may first pass keystrokes to the operating system as if the user had actively sent them to the keyboard capture component and not an application. In this way the operating system can do the work of translating keystrokes into higher level messages characters key movement etc. and can then return these messages to the keystroke capture component for further processing. Sending keystrokes to the operating system for intermediate processing instead of processing them directly may be advantageous for several reasons. For example it may avoid some of the difficulties of handling multi keystroke characters including non English character entry and it may ensure keystrokes get processed in a manner that is consistent with operating system behavior.

In the keystroke capture component adds the processed keystroke to the event data. In the embodiment shown the keystroke capture component captures event data as described by the event schema and the processed keystroke is added to the event data. For example if the processed keystroke indicates the addition of the letter G the letter G is added to the event data. If the processed keystroke indicates to delete the word preceding the cursor and a word is contained in the event data this word can be deleted. Additionally the keystroke capture component can add the processed keystroke to a capture state. The keystroke capture component can maintain the capture state containing previous keystrokes as it is determined what recent word s the user has entered. The capture state can be updated before an event is generated.

In the keystroke capture component determines if a complete word has been added to the event. A word can be a series of characters representing a spoken word abbreviation term or semantic unit. For example WORLD SERIES ASCII MR and GOOGLE can be words. The keystroke capture component can determine if a complete word has been entered by a variety of methods. In one embodiment the keystroke capture component looks for a series of characters followed by a space such as GOOGLE or certain punctuation characters such as GOOGLE to determine if a complete word has been entered. If a complete word has not been entered then the keystroke capture component goes to step . In the keystroke capture component can determine whether the application previously in focus is still in focus or if the application in focus has changed and another application is now in focus. If the application in focus has not changed the keystroke capture component returns to step and receives another keystroke. If the application in focus has changed the keystroke capture component returns to step and determines the current application in focus. If the keystroke capture component identifies an action such as moving the cursor up one line it may update the capture state to reflect the new cursor location. If the keystroke capture component does not have the capture state for that location or cannot accurately pinpoint the new location it may simply reset any partially captured word. As another example the keystroke shift left arrow may select the previous character in a particular application. The keystroke capture component can recognize this action and possible subsequent actions such as deleting the selection or pasting the selection elsewhere in the document.

If in step the keystroke capture component determines that a complete word has been received then in step the counter N is incremented by one. In step the capture processor determines if the counter N equals an integer T. The integer T can be for example a number of words. The number of words can be predetermined or can be determined based on a variety of suitable factors such as the current application in focus or other user activity. In one example T equals one so that the keystroke capture component may create an event upon the identification of each word entered by the user Alternatively T can be a number of characters. Like the number of words the number of characters can be predetermined or can be determined based on a variety of suitable factors. If in step N is found not to equal T then the keystroke capture component goes to step where the keystroke capture component determines if the application in focus has changed. If the keystroke capture component determines that N does equal T then the keystroke capture component proceeds to step . For example if N is a counter counting the number of words captured and T is set to one and GOOGLE is received then the keystroke capture component proceeds to step .

In the keystroke capture component compiles the event. In the embodiment shown the keystroke capture component compiles the event by compiling the event data associated with specific fields described by the event schema. For example the event data can include the application used for the input the format of the text the word or words input and the time input. When the keystroke capture component has compiled the event the method can continue at step as shown in .

In one embodiment an application in focus is first determined from which to capture associated display information to generate events. Events can include for example a number of words determined to be output on the display. In one embodiment a capture state can be updated after each display call is processed and a current user state can be updated based at least in part on the event.

With respect to initially a display capture component is called . The display capture component can operate regularly e.g. on a schedule or even constantly so that it monitors all display activity or can be selectively called when needed. Then the application in focus is determined . In one embodiment the application in focus is the client application currently being used. For example in a windows based operating system environment the display capture component determines which window the user is actively using.

For a first or new call the event is reset . An event may be reset for a variety of reasons such as for example the user having switched the application in focus an event having been captured and sent for processing or for a variety of other reasons. In one embodiment resetting an event includes indicating or generating a new event. The existing event data prior to the resetting is saved in a capture state and maintained until the reset. The indication of a new event triggers the sending of the existing event data in the previous event for processing. For example in one embodiment the reset function saves the previous event and sends it to the queue before initializing the new event. In one embodiment new events can be generated according to an event schema associated with an event type. The event schemas can include formatting for various data fields associated with the different types of events.

Next a display call is received . For example in one embodiment the display capture component receives a display call. A display call can be an instruction sent by the operating system to the display device associated with the client device that instructs the display device to display an item or change the display of an item on the display device. For example the display call can be to display the text Google in font Times New Roman at a display position such as position x y. This display call can for example cause the display on the screen of a computer monitor of the text Google at the position x y in the active window and in the font Times New Roman . A display call can also be for example to delete an item at a given position change the font of a word change the position of an item on the display or the like. In one embodiment display calls can also be determined by injecting code into applications or through the use of Dynamic Link Libraries DLLs to hook and intercept operating system API calls as further detailed below. In another embodiment other methods of output such as calls to a printer driver an audio driver or the like can also be captured.

After the display call is received the display call is processed to determine the event data associated with the current display. The display includes the visual information the user sees in the window or windows. In one embodiment the event data associated with the current display is captured and placed in an event format according to an event schema associated with the particular event type or application. In one embodiment the captured event data may be saved or maintained in a capture state for example by keeping an array of items that have been output to the current display. For example in one embodiment a display capture component can use the x and y coordinates of the items to determine words spaces between words and the beginning of a new line. The display call may be used by the display capture component to update the array of the current display. For example if the display call is to write the text Google in font Times New Roman at position x y previously displaying the word Goolge then the text Google in font Times New Roman is added to the display at position x y replacing the text Goolge. The updated array associated with the current display including the text Google can then be added to the event. The capture state can also be updated by replacing the previous state array Goolge with the updated array Google. Accordingly updates to the display can be reflected in the associated event for as long as the event is not complete.

Whether a complete event has occurred is next determined . In one embodiment to determine whether an event is complete a complete condition is checked. For example a complete condition can include adding a single word or a predetermined number of words to the display on the display device. Alternatively as another example a complete condition can include a particular user action on the display e.g. a mouse click on a hyperlink a button a menu item or the like. If a complete event has not yet occurred then it is determined whether the application in focus has changed. If the application in focus has not changed the next display call associated with the active window is received . Conversely if the application in focus has changed the new application in focus is again determined and the capturing process for a new event starts.

If it is determined that a complete event has occurred then the completed event is compiled . For example in one embodiment the display capture component compiles an event by providing all the event related data according to an event schema. The event data can include the application used the format of the display the time of display the content displayed the font and font size of any words displayed and any other data associated with the event that can be subsequently useful for indexing or to a user.

Now referring to a flow diagram of one embodiment of a profile based display capture method is shown. In this embodiment a display capture component can be configured to capture information associated with windows for selected applications. The application windows may be displayed in the user s view or hidden within the computer system. Some examples of selected applications for which display capture components may be configured include applications that do not provide a public API applications that encrypt or otherwise protect against data capture from its application windows or the like. The capture processor in this embodiment can include several capture components. For some of the target applications from which event data is captured a profile based capture component is used.

Accordingly in one embodiment upon initialization of the capture component process preexisting applications with associated windows are first checked in order to determine their identity. In one embodiment a target application profile is used for determining the identity of the running applications. The application profile includes identifying information associated with the target applications. The application profile may include for example a unique window class name associated with windows of a target application whether hidden or displayed a unique system path name for stored binary files associated with the target application operating system registry entries associated with the target application or the like. In one embodiment upon initialization and after the existing applications are checked notifications for subsequent window creation events are received for example by subscribing through the operating system to window creation events. For every window creation event the originating application is checked to determine if it is a selected target application.

Once a target application is identified computer code for an application specific display capture component is associated with the target application. For example in one embodiment a Windows API based hook is set to load the display capture code from a dynamic link library DLL into the target application process. In one embodiment the display capture code circumvents the encryption data capture protection features of the target application by modifying intercepting or bypassing its interactions with the operating system.

In one embodiment event data from a target application is derived from a subset of the windows associated with the target application. Accordingly the windows associated with the target applications are compared with stored window profiles. The window profiles contain information that can be used to identify. target windows including for example text to be contained in the window s title the number and type of display elements e.g. buttons pull down menus text input boxes and the like text to be displayed on display elements the location or arrangement of display elements and the like.

For example in one embodiment a text window of an instant messaging IM target application is the target window. The instant message text both that which is input and that which is received is the event data to be captured and associated with an IM event i.e. one data field in the IM event schema includes the text exchanged by the users in one session . The window profile in this example i.e. the window profile of the target window which is the IM conversation window includes the string Chatting with in the window title a Send button and a large free text input box.

For each target window in the target application the state of display elements or other target window display related variables is monitored . For example the state of handlers associated with display buttons or equivalent keyboard shortcuts e.g. the Send button or the Ctrl Enter key sequence is monitored. Upon detection of the state change of a display element e.g. a button of interest event data in the target window is captured .

In one embodiment the data capture is enabled by the display capture component code hooked into the target application process. This code intercepts operating system messages between the target application and the operating system and modifies responses to these operating system messages in order to enable the data capture. For example in a Windows based system an application configured to provide an empty string in response to every get text command e.g. WM GETTEXT is modified by the capture component code to use the default handler to provide the window display text. Thus the capture component code inserted into the target process allows the modification of application behavior for example to bypass data capture prevention measures from within the process.

The event data display capture can be repeated based on state changes and the capture state associated with an event can be updated with newly captured event data. For example for every user click on the Send button in an IM application the text associated with an instant message chat session can be captured and stored in memory in a data structure associated with an IM event for the current session. Subsequent clicks on the Send button can cause the capture of additional text exchanges in the IM session between the users. Such state based data capture beneficially provides an efficient scheme to capture display data upon user interaction with a target window. Time based polling schemes can be less efficient since they may operate even if the user does not provide any new input to the target process. Moreover state based data capture can reduce the likelihood of missing some entered data because generally after a user input some state change is required e.g. clicking on a Send button an OK button a Continue button or typing equivalent keyboard shortcuts or the like .

Referring again to the state of the target window termination is monitored . Upon termination of the target window an event can be completed . Any event data entry into the event data store can be finished and the captured event can be sent to the indexer. While the target window remains active the display capture can continue for every state change in the window.

Referring now back to once an event is captured e.g. as described with respect to the event. data processing method proceeds with step . The keystroke capture component described with respect to and the display capture component described with respect to can be used together in a capture processor in addition to other capture components to determine user activity for example what the user is viewing on a visual output device such as a display . Other capture components can include audio and video data capturing techniques e.g. voice recognition image processing and the like for audio and video events that can be included in the index.

After an event is captured it is determined whether the event is an indexable event. As explained above some real time events may not be indexed non indexable real time events . In one embodiment non indexable real time events are used to update the current user state and can be for example examining a portion of an article changing an article and closing an article. In this embodiment non indexable events are not indexed or sent for storage by the indexer . Indexable events can be indexable real time events or historical events. Keystrokes and display calls can be non indexable events such as the input of a number of words by a user or the display of a number of words on a display device. Keystrokes and display calls can also be indexable events such as for example when an entire article or portion of an article is input by a user or displayed on a display device.

If an indexable event is determined then the event can be sent for indexing e.g. to queue with an indication that it is an indexable event. In the embodiment shown in indexable real time events are sent to both a user state queue and an index queue within queue and historical events are sent to the index queue within the queue . Alternatively indexable real time events may not be sent to the user state queue to save computational time. The capture processor can send the event in a form described by an event schema to the queue .

If the event is determined to be a non indexable event then the non indexable event can be sent for further processing e.g. to a user state queue of the queue with an indication that it is not to be indexed. For example when a user is composing an email a capture component can capture a number of words input by the user in the composition of the email. A capture component can capture the input text as an event. While this event can be helpful in determining a current state of the user it may not be important enough to be indexed and sent for storage by the search engine so that the user may later retrieve this information. Alternatively in an example where a user opens a received email such an event can provide information on a current user state but it can also be indexed and sent for storage by the search engine because the user may later be interested in retrieving this email.

In one embodiment the queue holds the event until the search engine is ready to receive it. Based on the event data the event can be prioritized on the queue for handling. For example historical events can be given a lower priority for processing by the queue than real time events. In one embodiment when the indexer is ready to process another event it can retrieve one or more events from the index queue in the queue . The query system can retrieve one or more events from the user state queue of the queue when it is ready to update the user state. In another embodiment a queue is not used and events are sent directly to the search engine from the capture processor .

After indexing determinations are made and events are properly queued events are indexed and stored . In one embodiment the indexer can retrieve an event from the queue when it is ready to process the event. The indexer determines if the event is a duplicate event and if not assigns an Event ID to the event. The indexer can also associate the event with related events. For example in an embodiment as shown in using the event schema the indexer determines indexable terms associated with the event dates and times associated with the event and other data associated with the event. The indexer can associate the Event ID with the indexable terms that are contained in the index . The event can be stored in the database and the content of the event can be stored in the repository .

The environment shown reflects a client side search engine architecture embodiment. Other embodiments are possible such as a stand alone client device or a network search engine.

While particular embodiments and applications of the present invention have been illustrated and described herein it is to be understood that the invention is not limited to the precise construction and components disclosed herein and that various modifications changes and variations may be made in the arrangement operation and details of the methods and apparatuses of the present invention without departing from the spirit and scope of the invention as it is defined in the appended claims.

