---

title: Virtual type interpretation, interaction and detection
abstract: Interpretation of virtual types in a software development, debugging, or monitoring environment. Display and modification of variables having virtual types. Detection of virtual types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07434205&OS=07434205&RS=07434205
owner: 
number: 07434205
owner_city: 
owner_country: 
publication_date: 20050218
---
This application claims the benefit of provisional application Ser. No. 60 546 450 entitled Virtual Type Interpretation Interaction and Detection filed Feb. 19 2004 and which is hereby fully incorporated by reference.

Submitted as part of this disclosure are three compact discs each containing the files listed in one of the Appendices A B and C. Each compact disc is submitted in duplicate. The material on these compact discs is hereby fully incorporated by reference.

For years hardware and software design tools including software development kits emulators debuggers and other tools have incorporated various tools and features for improving the efficiency of the operation design test and development process. Often modern tools include various debugging features including watch or memory windows to inspect and or modify variables and memory locations within a target software application. While modern tools make the design test and emulation of hardware and software more efficient than ever before various enhancements improvements and or efficiencies may be desirable. This disclosure describes various implementations of methods and or systems relating to the interpretation of interaction with and or detection of virtual types as well as relating to other inventions disclosed herein.

In one embodiment the invention relates to a method of interpreting the value of a variable having a raw or native type and a virtual type wherein the method comprises the act of interpreting the value of the variable in a format that is consistent with its virtual type. In another embodiment the invention relates to a system for interacting with a variable having a raw or native type. In another embodiment the invention relates to a method of detecting the virtual type of a variable. Other embodiments features and uses of the systems methods and subject matter disclosed herein may be understood by reference to the full extent of this disclosure including the following detailed description the claims the appendices and the several drawings herein.

This application relates to a variety of inventions as disclosed herein and should be read and interpreted with the understanding that various inventions are disclosed herein by describing illustrating or otherwise disclosing specific implementations of those inventions. Thus any features procedures methods systems brief descriptions of the drawings or other aspects described or illustrated herein are not intended to limit the scope of any claimed invention in a manner not specifically required by the issued claims of this patent.

In addition the following disclosure should be read and interpreted as providing an adequate disclosure and written description for any single feature procedure method system or other aspect of any of the disclosed subject matter whether or not such single feature procedure method system or other aspect has been described as being implemented separately. Similarly the following disclosure should be read and interpreted as providing an adequate disclosure and written description for any partial implementation of the methods systems and or apparatuses disclosed herein whether or not such partial implementations have been specifically described or illustrated. None of the features procedures methods systems or other aspects of these specific implementations are an essential or required aspect or element of any claimed invention unless explicitly required by the claim directed to that invention. No claim should be read to include subject matter described in this detailed description unless that claim explicitly recites such subject matter. For example although this disclosure describes embodiments relating to the interaction with and or detection of virtual types in a software development environment it should be understood that implementation in a software development environment is not an essential element or required aspect of any claimed invention unless explicitly required by the claim directed to that invention. Further any other methods techniques contexts or subject matter disclosed herein are not essential elements or required aspects of any claimed invention unless explicitly required by the claim directed to that invention.

Further the following disclosure should be read and interpreted with the understanding that any feature procedure method system aspect invention or combination thereof that is described and or illustrated in this disclosure may be combined with any other feature procedure method system or other aspect described and or illustrated in this disclosure even if such a combination is not shown or specifically described. This disclosure should be interpreted as providing an adequate disclosure and written description of any claim directed to such combinations.

In the embodiment shown in the target application runs on a separate target hardware platform that employs a specific microprocessor. The target application may in other embodiments run on the host computer itself see the dotted line representation of the target application in the box . In still other embodiments it may run on a device simulator see dotted line representation of the target application in the box or elsewhere.

The debugging tool is connected to the target hardware over an interface which allows communication between the host computer and the target hardware . The debugging tool reads the target executable file and symbol table and in some cases it downloads the target application to the target hardware and launches it. The debugging tool may use the source files when setting break points and single stepping through the target application . Although the debugging tool is shown separated from the build tools in in some embodiments the debugging tool and the build tools are integrated.

One popular development environment is Microsoft s Visual C Studio. Another software development environment is Texas Instruments Code Composer Studio which uses a scan based emulator as its primary debugging tool and which is connected to the target hardware over a JTAG interface. Another such debugging tool is Applied Signal Processing s Live Data Exchange which communicates with the target device over a serial link. In general Microsoft s development tools run the target application on the host computer itself. Others such as Texas Instruments Code Composer Studio described in U.S. Pat. No. 6 493 868 which is hereby fully incorporated herein by reference help debug target code that is intended to run on a specialized microprocessor such as a Digital Signal Processor. In the case of debugging code for a specialized microprocessor the debugging tool normally runs on a host computer and either simulates the instruction set of the specialized microprocessor or is physically connected to target hardware using the specialized microprocessor.

In some situations it is desirable for a particular variable having a raw or native variable type such as an int char long or other type to function as the basis for one or more other types. These other types which are based on the raw type may be called virtual types. When a variable has one or multiple virtual types it may be interpreted differently depending on its virtual type and have a value that is a function of the virtual type associated with the variable.

The development and debugging of computer software is one situation in which a variable s virtual type may have some significance. Most modern development and debugging tools allow a user to inspect and modify variables and memory locations within a target software application. Often a debugging tool is provided with a watch or memory window to permit inspection and or modification of variables and memory locations within a target software application.

In the variable alpha is displayed in the interpreted value window as having a value of 17 when it is interpreted as a Virtual Type 1. As shown in that same variable Alpha is interpreted as having a value of 352 when interpreted as a Virtual Type 2. Note that the data stored in the memory location associated with the variable Alpha which is a 16 bit quantity has not changed. It has the same raw hexadecimal value in both and . The difference between these two Figures is that the variable is interpreted differently in and based on the change to the selected virtual type.

In and the user can also change the raw value of the variable in window which causes 1 the memory location associated with the variable Beta to be changed accordingly and 2 the interpreted value displayed in window to be updated based on the selected virtual type.

The user may also change the interpreted value of Beta in window which causes the memory location associated with the Beta variable to be changed accordingly once the translation from virtual type to raw type is performed. For example if the interpreted value in window were changed in to the value 11 the memory location associated with the Beta variable would change to 00010001 since that quantity has a binary coded decimal value of 11 and the selected virtual type in is binary coded decimal. 

A common technique in developing fixed point algorithms is to use Q arithmetic where the Q type of a variable defines the number of implied fractional binary bits within the 16 bit or 32 bit or other bit quantity fixed point raw representation of a value. A Q15 virtual type number has 15 implied fractional bits. A Q8 virtual type number has 8 implied fractional bits. To convert between the raw value and the represented value of a Qval number we use the following formulas interpreted value raw value 2 raw value interpreted value 2

For example to represent the value 3.5 as a Q6 number in 16 bits the raw value is 3.5 26 224 0x00E0 hex .

In the variable Delta can be interpreted according to a variety of Q type virtual types. In the variable Delta has a 16 bit quantity 0x00E0 shown in hex format stored at the memory location it represents see and it is interpreted as Q6 virtual type which means that it uses 6 bits for the fractional portion of its value. Its interpreted value is 3.5 since 0x00E0 224 integer or decimal and 224 2. In the virtual type associated with variable Delta is changed to a Q4 type which means that its interpreted value is 224 2 see in .

Although are described in connection with particular examples of virtual types other virtual types taking different forms may be applicable in some embodiments. For example some embodiments of the inventions disclosed herein may be applicable to packed vs unpacked strings e.g. characters encoded as one byte or two bytes radians vs. Hz virtual types a radian variable is sometimes hard to understand without the conversion to HZ ASCII vs. decimal virtual types e.g. a value may be an ASCII string of numbers only and virtual types involving quantities with encryption or check sum and parity bits e.g. a 16 bit interpreted or real world value may be stored in a 32 bit word with the upper 16 bits including encryption or check sum information .

Once the virtual type for a particular variable is known the proper interpreted value typically can be readily determined usually through some type of formula. In the case of Q types for example the pertinent formulas have been described above. However if the virtual type for a variable is not known it may be difficult to properly display its value in a form that is readily understandable to the user.

For example in the window illustrates a watch or edit window in a development or debugging environment where the virtual type for the Q type variable Delta is not known. In the case of the debugging environment associated with window only sees that the variable Delta is of type int and it does not know that the variable Delta is a virtual Q type. It therefore assumes that the Delta variable is to be interpreted as an integer and displays its value as simply which is the integer value of 0x00E0 see window in . This may not be a very useful way to display the data for the user of the debugging tool associated with window since the value often will have little meaning to the user because it is not the value that the Delta variable is intended to represent. Instead the value the variable represents may be quite different the value is actually 3.5 if Delta is a Q6 variable . To translate the value to its proper interpreted value the user is left to determine its virtual type i.e. its Q type and the user must also do the math e.g. 224 2 6 3.5 to determine the properly interpreted value of the variable. The converse is also true. If the user wants to change the value of the Delta variable in to 12.78 and thereby modify the memory associated with the Delta variable the user may have to 1 first calculate the Q6 raw value equivalent of 12.78 raw value 12.78 2A6 817.9200 818 and then 2 enter the value 818 in window .

The process of determining a virtual type in for a variable therefore can be in some cases useful or important. Yet in many situations the virtual type of a variable is not readily apparent. For a Q type the native or raw type is typically int 16 bit or long 32 bit . Normally software development environments or even debugging tools cannot readily determine based on a conventional processing of the project source files whether a particular int or long variable should be interpreted as an integer or whether it should be interpreted in another way such as a Q type virtual type. Typically the development environment views Q types and integers as the same. Therefore a debugging environment may have difficulty displaying the proper interpreted value for a particular variable if it is unable to ascertain if a particular variable has a virtual type associated with it.

If the user has not specified a virtual type for the variable the variable s name is evaluated to determine whether it has a naming convention that suggests a particular virtual type . If it does the variable is associated with the virtual type indicated by the naming convention and interpreted accordingly . If no naming convention is detected the variable is interpreted according to the default virtual type associated with the raw variable . For a variable that has a raw type of int this may simply mean interpreting the variable as an integer but other default interpretations or virtual types could also be used e.g. binary coded decimal or Q8 . The user or developer may then continue to be monitored to determine whether the user is associating though input or otherwise a virtual type with the variable. In some embodiments later actions by the user may override earlier virtual type determinations.

The operations performed by the processor may be carried out at any time. For example in some embodiments the processor may act as a preprocessor that scans various project files when a project is loaded and attempts to determine the virtual types associated with one or more variables in the project. In other embodiments the processor may also operate periodically or upon certain events occurring during a given development emulation or debugging session. The processor may also operate only as needed in some embodiments attempting to determine a virtual type for some variables only when needed or on demand. In other embodiments the processor may operate in other ways or in a combination of ways and it need not be limited to only those techniques or methods of operation specifically described.

In the debugging tool is shown interacting with a number of files and and other logic and is shown separate from the build tools . In other embodiments some or all of the functionality of the debugging tool may be integrated into the build tools so that a combined build tool debugging object is interacting with the files and logic shown in . In general any particular module shown in or elsewhere may be integrated into one or more other modules as appropriate and it should be understood that the present disclosure encompasses such combinations and integrated modules.

In general any information or logic in that may be employed to enable the virtual type processor to effectively discern whether and what type of virtual type may be associated with a given variable may be used by the virtual type processor . In some situations other information or logic may usefully employed and is contemplated within the scope of some embodiments of the invention.

In some embodiments the determination at in of whether a raw type is susceptible to interpretation as a virtual type may be optional or it may be applied prior to determining whether the variable declaration uses a defined virtual type .

The virtual type processor of thus provides an additional way in which a variable s virtual type can be determined. is a flow chart illustrating the operation of determining a virtual type associated with a variable in in another embodiment. This embodiment involves determining whether the virtual type processor has associated a virtual type with the variable see in . Determining a variable s virtual type may simply involve accessing the information generated by the virtual type processor. Accessing this information may involve loading the virtual type symbol table generated by the virtual type processor or accessing this information from any other location where that information may be stored. Such information may be stored in memory or in another file such as the symbol table shown in or in a workspace file.

If the virtual type processor has associated a virtual type with the variable then the variable is interpreted according to the virtual type determined by the virtual type processor see . Otherwise the variable is interpreted according to its raw type see . In other embodiments where the variable has not been associated with a virtual type by the processor one or more the procedures undertaken in may be carried out instead of interpreting the variable as a raw type as in in . Normally determining the virtual type of a variable from the information generated by the processor may be the preferred method since it requires little or no input from the user.

In operation the enhanced debugging tool is used to inspect and or modify variables and memory locations of various Q types contained within the target software application . The tool provides methods for determining tracking viewing and modifying variables of various Q types in an intuitive and user friendly manner. Source files specify the functionality of the target application and are processed by a set of build tools creating the target application executable file . The enhanced debugging tool can initiate or be called from the standard build tools over a tools interface or certain aspects of the functionality of can be incorporated within the standard build tools . The executable file typically contains within it a symbol table which lists the name raw type and size of all the variables defined by source files . The debugging tool scans the set of source files looking for key words which will determine a variable name and associated Q type. This association is saved by the tool for later use perhaps in the symbol table or in a separate file not shown . The debugging tool is connected to the target application over an interface which allows communication between the enhanced debugging tool and the target application . This communication allows the debugging tool to inspect display and modify specific variables and memory locations within the target application.

In some embodiments the debugging tool of is capable of automatically detecting a variable s Q type. The Q type of the variable can be determined in a number of ways. For example the Q type of variables can be determined by reading the Q type associated with each variable from a Q type object file which has a list of variable names in the target application and their associated Q type. Another method involves extracting the Q type from the variable name by looking certain naming conventions such as variables containing the string fragment q anywhere in the name. Another method involves receiving input from the user that indicates the Q type for one or more variables. In this last approach the Q type could be manually entered by the user through for example the use of a dropdown or edit field.

In embodiments employing the use of a Q object file various methods for creating and maintaining such an object file may be employed. For example in some embodiments a compile time Q type preprocessor scans all target application project files to identify the virtual Q types of all variables and creates the Q object file. Derived or virtual typedef qualifiers may be used to declare each variable such as q15 myvariable. 

In other embodiments a user interface tool may be used to load an existing Q object file or the symbol table from the target executable file thereby listing target application variable names providing the user with the opportunity to enter change the associated Q type for each variable. In such an embodiment the Q object file may be automatically updated as the user makes changes.

Also in some embodiments as the user manually enters variable names or a new Q type for a specific variable name in the target application during a debugging session or the like the associated Q object file is automatically updated. If necessary the variable name may also be added to the object file and the new associated Q type updated and stored.

Logic for performing a Build All Operation creates a global Q object file which contains information about all Q type variables within the target application . Logic for performing a Merge Operation combines the information from several Q object files into one Q object file . A Q typedef qualifier list is a list of the typedef qualifiers to associate with each possible Q type. These are the typedef qualifiers that the virtual type preprocessor will search for within the source files. There is a one Q type to many typedef qualifier string mapping. The Project File List contains a list of projects and source files used to create the target application.

The Smart Edit Gui is a graphical user interface object that allows viewing and modifying of a single variable or expression of any Q type. The Smart Watch Gui is a graphical user interface object that allows viewing and modifying of several variables and or expression of various Q types within the same window view.

The embodiment of may provide some aspects of enhanced Q type support or some aspects of a Q Smart debugging tool which uses Q Sense and Q Edit technology. Q Sense Technology is the base technology that automatically detects either through variable names or other means the Q type of a target variable. Q Edit Technology is the base technology that automatically converts fixed point Q type values to their floating point equivalent for display purposes and automatically converts floating point user entries to their fixed point Q type equivalent so that users can searnlessly view and change Q type variables entirely within the floating point domain.

In some situations current debug tools show the value of Q type variables and memory locations based on the variable s raw or native type int long etc. and are not very user friendly when it comes to viewing and modifying Q type variables. Some debugging tools provide rudimentary support for Q types but may require running clumsy script files to display the value and a second script file to modify the value. These support tools often do not allow an easy way for the user to view and modify Q type variables of various Q type from within the same window view. They also may require the user to know and keep track of the Q types himself or herself. In addition they may also fail to properly check the range of the new values that are entered which can result writing erroneous data to the variable or memory location.

In some situations embodiments based on the block diagram of allow users to easily view the floating point equivalent of fixed point Q type variables and allow users to enter values as floating point relieving the user of the task of manually doing the Q type conversion. Furthermore the environment in the embodiment of may automatically determine and keep track of the Q type associated with the variables defined within the target application which may relieve the user of this task as well. In some embodiments the development environment in is flexible enough to work with existing target source files working with whatever variable naming conventions and type definitions the user may have defined so as not to require the developer to rewrite source code in order to start using the tool. In many situations the embodiment of provides a more natural and intuitive use of the debugging tools and lets the user quickly inspect and change values allowing the developer to concentrate on development.

The Q type watch edit tool in provides the user with the ability to view and or modify variables or expressions running in the target application . In this ability is provided through the Smart Edit Gui and Smart Watch Gui tools. Still referring to FIG. the Q type watch edit tool may load the standard symbol table from the target executable object file to get the raw types and names of all the variables within the target application information in the symbol table may be available through other means or the symbol table may be loaded by another component of the system . The Q type watch edit tool can also optionally load a Q type object file at startup. If such an object file is not loaded the tool will typically create an empty Q type object file. In some embodiments the tool will load a Q type object file created by the Q compiler or from a previous watch edit session. In either case the Q type object file referred to as the session Q type object file is typically updated as the user adds new expressions or variables and when the user manually assigns the Q type to be associated with a variable or expression. In this way the tool maintains and tracks the list of variable names and Q type associations so that the next time the tool is used the user does not have to manually enter the Q type again.

In operation the window allows a user to view and change a particular variable in the floating point domain. Logic associated with the window automatically determines the Q type of the variable and converts between its raw or native type and the floating point equivalent. In the variable name field the user can either enter or select a variable name or enter an expression . When a variable name is entered for example q12 K the data in the memory location associated with that variable is read from the target application and displayed in a the value field using the display format selected by a set of display format buttons and . An expression is typically a valid C expression e.g. q12 K 2.5 which the tool will evaluate and whose end result is displayed in the value edit display field . A variable name is by definition a simple C expression so the tool may always be considered to be evaluating an expression. In when the decimal radio button is selected the integer or raw value of the variable is displayed. When the float radio button is selected the interpreted value having a factional component is displayed where this interpreted value is based on the current virtual type Q type of the variable.

Some embodiments of the window may provide additional functionality. For example scalar variables and expressions may be allowed in the name edit field . Arrays and structures could be displayed using an expanded display field or they could be displayed as a . in the value field . As variables and expressions are added they may get added to the dropdown list and stored perhaps in a session workspace file. New expressions are also stored perhaps in a session object or Q object file. A default Q value may be set by the user using clicking on the title bar or right clicking on the Qval select dropdown . This default Q value may be used by the ExtractQvalFromnName function as described in . When the Q value of a particular variable or expression is changed the new variable name and Q association may be saved into the session workspace and session Q object file. The window may automatically refresh the value field when the associated target debugger halts i.e. hits a break point . In addition auto complete functionality may be used with an auto suggest dropdown list for the variable name entry based on symbol table information. As the user starts to enter a variable name a search is undertaken for existing variable names that match the typed text allowing the user to quickly and conveniently find the desired variable.

Also in some embodiments logic associated with the window may allow the window s state to be saved recalled into from a session workspace file. The saved information associated with the window s state may include one or more of the following 1 the session variable name and Q value association 2 the number of window or Q Smart Edit window instances open 3 the current variable name selection for each instance and 4 the variable name dropdown list entries for each instance.

Once the Qval is assigned the assigned Q value is updated in the Q value edit box see in . The expression is evaluated and or a value is read from the target application returning a raw value result . A display value is calculated based on the raw value and the Q value according to the following relation display val raw value 2AQval where the A symbol means raised to the power i.e. 2 3 8. See . Once the display value is calculated the value edit display field is updated based on the selected display format or see . The raw value display field is also updated to the show raw value in hex format.

In some embodiments the variable name dropdown edit list box in itself maintains a list of expressions and variable names entered by the user. The content of the list box in may be stored to a session workspace file in .

At the watch edit tool is using whatever means are available to receive the raw value result of the variable or expression of within the target application over the interface See . In most cases it will be calling a specific API to a standard debugging tool or ActiveX control to get the value of either an expression a specific memory location or a specific variable.

In some embodiments logic associated with window implements the pseudo code of . In the OnNewFloatValueEntered function performs three main tasks 1 converts floating point entry into an equivalent raw value with saturation protection note that the A symbol means raised to the power 2 writes that new raw value to the variable on the target application and 3 updates the value display field to reflect the accuracy of the Q type representation of the desired new value.

Lines to within the OnNewFloatValueEntered function provide saturation protection of the entered value see in . In other words if the user tries to enter a value that is too large in either the positive or negative direction to be properly represented by a variable of the given Q type the function assigns the largest possible value or most negative value for negative entries to the variable. For example with a 16 bit integer it will saturate the raw value at either 0x7fff or 0x8000. The operation GetNumBitsofNativeType looks in a symbol table to get the size in bits of the raw type of the variable that is to be modified. For example suppose the Q type is 15 and the raw type is a 16 bit signed integer. The largest values that can be represented are 1 1.0. If the user enters the value of 1.2 the function will saturate the value to 1.0 which is a raw value of 0x8000 .

At line the function WriteValueToTarget uses available means to write a raw value to a specific memory location typically on the target hardware over an interface. In most cases the software will call a specific API to a standard debugging tool or ActiveX control to write the value a specific memory location or variable name. The MemAddress function retrieves the address of the variable that is to be modified from the standard symbol table.

In some embodiments prior to executing the OnNewFloatValueEntered the Q Smart Edit Gui detects the format of the entered value and only executes the floating point to Q type conversion for floating point entries. For other entry formats such as decimal or hexadecimal the entered value is assumed to be the raw value itself and the entered value is written directly to the target application. For example if the user enters the value 3000 then logic associated with window writes the raw value of 3000 to the target and then updates the value display and raw value display fields.

In whenever the user changes the Q value field the associated Q value for the variable or expression is updated within the session Q object file the display value is recalculated accordingly and the value display field is updated.

A variable name expression edit field is used to display the name of the variable or expression to view and or modify. A value edit display field shows the current value of the variable or expression in the selected display format and also allows the user to enter new values for the variable. The float display format and decimal display format operate in in a manner similar to that in . A Q type dropdown edit box allows the user to manually select the Q type for the selected rows of the watch window. A Q type select edit display field shows the Q type of the variable or expression in a particular row and allows user to manually change the Q type of the variable being displayed in that row. A display format select button brings up a display format pop up menu to set the display format of the selected rows. A display format field shows the current display format for a given row. A raw or native type display field displays the raw or native type of the variable or expression of a given row. The display format pop up menu selects the display format of the value edit display field for a particular row or selected set of rows. The raw value display field shows the raw or native value of the variable in hexadecimal format. The tab sheet selector selects which tab or sheet to bring to the front of the view.

In the embodiment shown in left clicking the display format field after a row is selected brings up a display format pop up menu . Clicking on Radix push button brings up the display format pop up menu and can be used to set the display format for all selected rows. The value edit display field shows the interpreted value of the variable in the format set by the display format Radix and also shows the raw hex value in parenthesis and or grey . The field may alternatively show the raw value in its own column. Tree node functionality may be used particularly in field to expand and collapse arrays and structures. When a new variable or expression is entered in the variable name field the Q type select edit display field is automatically set based on logic that attempts to determine the Q type for the entered variable or expression such as in any manner described in this disclosure. Double clicking on the Q type edit display field allows the user to change the Q type manually. Single clicking on the Q Type button brings up the Q type dropdown edit box . This manually sets the Q type of all selected rows. The user double clicks the variable name edit field to add change a new variable or expression. A new expression is typically added to a blank row which is normally available by scrolling to the end or bottom of the list shown in . A double click on the value within the value edit display field allows user to edit change the value assigned to the associated variable. The window of may also employ auto complete functionality with an auto suggest dropdown list on variable names using a symbol table as a base.

When the Q value of a particular variable or expression is manually changed the association between the variable name and the new Q value is saved into the session Q object file. As variables and valid expressions are added they get added to the session workspace file in . New valid expressions are added to the Auto Complete list and added to the session Q object file. The window of may also automatically refresh the value field when the associated target debugger halts i.e. hits a break point . The current state of the window may also be saved recalled into the session workspace file see .

In some embodiments each row of the Q Smart Watch Window shown in has much of the functionality or replicates the functionality of the window described in connection with . The operations described in connection with including entering new variables or expressions changing the variable value and or manually changing the Q type may also apply to the Q Smart Watch Window.

Referring to the Q type compiler tool creates Q type object files including a merged Q type object file that the watch edit tool can load at startup to thereby obtain an initial variable name to Q type association. The Q type compiler tool can in some embodiments create Q object files and perform a number of operations involving Q object files. For example it may load an existing Q object file and allow the user to modify the Q type associated with the variables within the Q object file. It may also load the symbol table from the target object file and allow the user to manually assign the Q type of symbols within the symbol table. It may also use the Q type preprocessor to scan a source file to identify the Q types of all variables declared within that source file. The compiler tool may also use the Q type preprocessor to scan all target application project source files to identify the Q types of all target application variables. The compiler tool may also be capable of loading and merging individual Q type object files. Depending on the implementation the compiler tool may be capable of performing any or all of such operations.

In some embodiments the Q type compiler automatically creates the global Q type object file for the user. One method of creating the global Q object file is to use the Q type preprocessor to scan all project files. In the project file list provides the list of all project source files used to create the target application . The Q type preprocessor uses the Q typedef qualifier list to identify source code Q type qualifiers to associate with a given Q type. Q type qualifiers are type definitions or structure definitions or enums that associate a virtual Q type with a raw type as shown in the C code fragment used by Applied Signal Processing in . In the case of C the qualifiers may be the names of typedefs structures or class definitions to associate with a Q type. Similar techniques may be used for other development languages including Java BASIC C as well as others .

The Q type compiler lets the user maintain and assign his or her own virtual type Q type qualifiers and their associated Q type value so that the user doesn t have to use any particular naming convention or Q type qualifiers. This may make the Q type preprocessor more flexible with existing code and other programming styles and conventions. For example a software developer may have used typedef int q15 to define the virtual type for 16 bit q15 type values. The Q type compiler lets that developer also associate the string int q15 with the Q type value of 15. This association can be maintained within the Q typedef qualifier list.

The Q typedef qualifier list can operate as a list of all the typedef strings to associate with a given Q type. A portion of an example Q typedef qualifier list is shown in and is also represented in the window of . The first value in each line is the Q value followed by all the typedef qualifiers to associate with that Q value. See the Q typedef qualifier list of .

In some programming approaches a define macro is used to define a default or global Q value for certain variable types. For example Texas Instruments IQMath support Ubrary uses a define GLOBAL Q macro to define the default Q to assign to variables using the  iq typedef. 

The Q type preprocessor and compile tool may be configured to support such an approach. For example the Q type preprocessor may permit defines within the source code to determine a default Q value to assign to variable declarations that are of a generic Q type. Within the Q typedef qualifier list a define keyword macro string is identified and followed by the typedefs to associate with that keyword. When these typedefs are encountered the Q type value last defined by the keyword macro is assigned to the variable of this type. These virtual types may be called compile time dynamic virtual types because they allow source code to change the virtual type or Q type associated with variable types.

This method may be best explained with an example. Suppose we have the Q typedef qualifier list of and the C code fragment shown in . After the Q type preprocessor scans the code fragment of the variable name and Q type association shown in is added to the Q object file. Note that in the Q type preprocessor correctly identifies and remembers the proper Q type of the variable g var3 whose associated default Q value macro was changed midstream within the file. This may be considered an advantage over TI s use of the global Q variable approach as disclosed in the IQ math users guide . Also note that the q14 by name variable was assigned the Q value of 14 based on its name even though it was not declared with a Q typedef qualifier.

In an alternate embodiment the Q type preprocessor may process individual project source files to generate individual Q object files for each source file. The resulting individual Q object files may then be merged to create a merged Q object file. The merge operation builds a merged or accumulative Q type symbol table by adding the symbols from each file to the merged Q type symbol table providing that the symbol does not already exist in the merged symbol table. This approach may not require re scanning all project source files each time the build all operation is executed only those source files that have changed since the last build of the global symbol table.

Referring to note that in some embodiments the typedef qualifier list is scanned the qualifier list may be different for different projects early in the process. Thereafter each source file is opened and the lines of the file are scanned . If a generic Qval define macro is found the Q value to be assigned to variables declared using type definitions associated with that define macro is updated . When a variable declaration is found the name of that variable is assigned to the field NameStr of the Var structure . If the declaration is a virtual Q type based on the Q typedef qualifier list its Qval is assigned based on the Q value specified in the Q typedef qualifier list . Otherwise if the native or raw type of the variable is an integer the Qvalue for the variable is determined by the process or it could be assigned to a default value. In either case the Q type associated with the variable is stored in a symbol table . If the native or raw type is a structure each element of the structure is processed in a similar manner. After each line of each source file is processed the symbol table is stored in a file .

In some embodiments a Q type compiler operation such as that illustrated in is called automatically by the standard build tools after each source file is compiled and then the global build merge operation is called after the standard tools build the .out or other target executable file so that global symbol table is built seamlessly without any extra steps required by the user. The build all merge operation can also be executed as a separate step through a menu option or toolbar button. Alternatively the build all operation can be called by the tools as a separate step before or after the standard build process.

In a variation of this approach the merge and build all operations are also available as part of the watch edit tool and global Q type object files are created from the individual Q type object files that were created by individual calls to the Q type preprocessor.

In some embodiments the Q object files and of contain at least two symbol table sections a dynamic section and a static section . See the embodiment shown in . The static section is the section created by the Q type compiler tool. The dynamic section contains a list of any new variable names or expressions that were manually added to the session Q object file through the use of the watch edit tool when the user either entered a variable name that was not found in the static section or when the user used the watch edit tool to manually override the Q value assigned to a variable by the auto Q sense operation. The Auto Q Sense operation see an example in will first scan for variables and expressions within the dynamic section and then the static section allowing changes initiated during watch edit sessions to be remembered. The build all and merge operations of the Q type compiler will keep the dynamic section in tact only removing entries from the dynamic section if they match that same entry in the static section in both variable name and Q type. In this manner the tool remembers and tracks previous manual Q type overrides and expressions even after rebuilding the global Q type object file.

In some embodiments each symbol table entry may have a number of fields including a field for storing the name of the variable and another for storing the Qvalue associated with that variable. See the structure illustrated in .

In some embodiments it may be preferable to integrate the Q type object and or symbol table files and or portions thereof in with other files or objects within the Q type support environment. For example the Q object files may be integrated with or within the symbol table generated by the build tools or with within one of the other files generated by the build tools . Also in some embodiments some or all of the aspects of the debugging tool may be integrated into the build tools so that the build tools partially or fully incorporate the functionality of the debugging tool . For example the Texas Instruments Code Composer Studio could be modified to incorporate some or all of the functionality disclosed in this application.

A File dropdown menu provides various options for creating loading and saving Q object file and symbol tables and provides access to the build all operation. An Options dropdown menu allows the user to set the default Q type to assign variables during the build all operation. A View dropdown menu allows the user to toggle between Object File View and Typedef Qualifier View . The build all push button initiates the build all operation.

The Q type compiler editor shown in allows users to create view modify and save a Q type object file. Once a Q type object file is loaded the user can inspect modify the variable name and Q value assignment. The File New menu option sets a new Q type object file name to be saved. The File Open menu option opens an existing Q type object file or session workspace The File Save menu option saves the current file. The File Load out File menu option loads a COFF .out file symbol table only extracts the Q value from the variable name while assigning default Q value to names without a q substring and updates the table display area. The File Load Q object File menu option loads an existing Q type object file and updates the table display area. The contents of the loaded file can be optionally merged or added to the Q type object file which is already opened. The File Load Q workspace option loads the state of a previous Q type compile session. The File Compile Build option all initiates the build all operation such as in the manner previously described and loads the resulting Q type object file into the workspace.

The Options Set Default Q type menu option chooses the Q type to be assigned when a variable is declared without using a Q typedef qualifier or when the variable does not contain the q substring. The View Q type Object File menu option sets the view to Q object File view in which the contents of the object File variable name Q type and raw type are shown in the table display area as shown in . The View Q Typedef Qualifiers menu option sets the view to Q Typedef Qualifier View in which the current Q typedef qualifier list is shown in the table display area as shown in .

In the view shown in the Q type compiler window allows the user to view or modify and save the current typedef qualifier to Q value associations that the Q type preprocessor uses when scanning source files and building a Q type object file. The Q value fields show the Q value that will be assigned to a variable declared using the typedef qualifier in the associated row. The Q typedef qualifiers are strings separated by commas or spaces. These are the strings that match the typedefs found within the users source code when he or she declares variables of a virtual Q type. See . For example given the Q typedef qualifier list of when the Q type preprocessor finds a line such as q10 myVariable within a source file it will assign the symbol myVariable a Q value of 10. Note that in this embodiment the variable name need not have q10 substring within it. The Q typedef qualifier list can be saved to a file associated with a particular project and file list.

In the Q type support environment is shown operating in connection with Texas Instrunents Code Composer Studio environment. Texas Instruments Code Composer Studio CCS supports an ActiveX interface which allows other Windows client applications to get access to the emulation environment and target application data. Texas Instruments Code Composer Studio also supports an open architecture which allows third parties to create plug ins which can expand the functionality of CCS. The client applications are launched separately normally like any windows program. The plug ins are generally launched from the CCS environment and appear as if they are part of the program. 

In addition the ActiveX interface may allow the tools or to load target symbol table information from an executable object file provide target symbol table information such as raw types structure definitions enums size of structures etc and provide the communication link to the target application so that the Q Smart edit watch tool can read and write variable and memory locations on the target application. The debugging tool or may use the interface or to evaluate C expressions and retrieve raw variable values from the target application as well as other functions.

The ActiveX interface may provide options for modifying the environment s user interface which could include the capability of providing menu items and toolbar pushbuttons within the environment e.g. CCS environment that open and or execute components of the debugging tool or such as the Q type compiler Q Smart Edit and Q Smart Watch windows.

The Appendices contain listings of source files and executables for building and demonstrating one or more embodiments

Appendix A SmartWatchGui directory is a list of files including the source files of a program that operates as an ActiveX plug in to Texas Instruments Code Composer Studio development environment. The ActiveX object must be registered using regsvr32 Qsmartwa.ocx prior to running CCS Studio. The plug in was created in Visual C v6.0 using Texas Instruments Plug in Software Development Kit Version 2.2.

Appendix B CPreeCon directory is a list of files including the source files and executable for a command line executable version of the Q type Preprocessor. Its project space can be loaded using Microsoft Visual C Version 6.0.

Appendix C QExample directory contains an example DSP target application that contains variables of several Q types. The example was developed with Texas Instruments Code Composer Studio version 2.21. CCS was configured with the C55xx Simulator board type device driver Revision 03.05.09. The project space is QsenseExample.pjt and the workspace is IQExample.wks.

It should be understood that the various techniques and features that have been described or otherwise disclosed herein can be implemented separately combined with other techniques and features or used in conjunction with each other. In other words it is intended that the various techniques and features described in connection with implementations illustrated in the drawings described or illustrated in the subject matter incorporated by reference or otherwise disclosed can be used alone or can be combined with other techniques and or features even if such techniques and or features are not shown being used as such.

 1 Code Composer Studio Software Developer s Kit User s Guide Texas Instruments literature number SPRU320 

 3 IQ Math Library A Virtual Floating Point Engine Module User s Guide C28x Foundation Software Texas Instruments version 1.4.1 June 2002 

Although embodiments have been principally described in the context of a software development and or debugging environment some embodiments of the present invention need not be limited to such a situation. The present invention may be applicable in other contexts including the full range of hardware and software design test and emulation contexts and in the context of logic analyzers software simulators and monitoring devices or software and may also be applicable in other situations as well. Similarly some aspects of the present invention have been described in connection with the C programming language but it should be understood that some or all aspects of various inventions disclosed herein may apply to other languages including BASIC Java C and C as well as other languages.

Generally although the inventions disclosed herein have been shown and described with respect to specific embodiments and or implementations various changes and modifications even if not shown or specifically described herein may be applicable and are deemed to lie within the spirit and scope of this disclosure. Any specific features or aspects of the embodiments or implementations described or illustrated herein however are not intended to limit the scope of any claimed invention in a manner not specifically and explicitly required by the claim directed to that invention.

