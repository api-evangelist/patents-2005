---

title: Method and apparatus for mapping structured query language schema to application specific business objects in an integrated application environment
abstract: A method, an apparatus and computer instructions are provided for mapping structured query language (SQL) schema to application specific business objects in an integration application environment. A SQL business object application specific information (BO ASI) builder is added to the business object application specific information (BO ASI) resolver. When a SQL markup language schema is parsed by a schema resolver, meta business objects (BOs) are generated with schema annotations, and the BO ASI resolver locates the SQL BO ASI builder that is able to handle the meta BOs. The SQL BO ADI builder then fills the ASI fields of the meta BOs and returned to a BO writer, which writes out application specific business objects understandable by the integration server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08458201&OS=08458201&RS=08458201
owner: International Business Machines Corporation
number: 08458201
owner_city: Armonk
owner_country: US
publication_date: 20050408
---
The present invention is related to the following application entitled Using Schemas to Generate Application Specific Business Objects for Use in an Integration Broker Ser. No. 11 102 025 filed on Jul. Apr. 8 2005.

The present invention relates to an improved network data processing system. In particular the present invention relates to an integrated application environment in a network data processing system. Still more particular the present invention relates to mapping structured query language schema to application specific business objects in an integrated application environment.

In an integrated application environment an integration server integrates different types of applications and shares business objects among these applications. An exemplary type of application is a structured query language SQL compliant application. Typically SQL compliant applications are specific database applications such as Oracle a product available from Oracle Corporation.

When integrating SQL compliant applications into an integration broker the SQL table structures need to be accessible such that artifacts may be generated to abstract table structures. One way is to directly access the database with a JDBC compliant driver. By using the JDBC compliant driver JDBC ODA can generate the artifacts. With the increasing popularity of extensible markup language XML table structures may be expressed in XML schemas where a physical database connection is no longer needed. To generate artifacts from XML schemas two major approaches have been taken.

One approach is by using an extensible markup language XML object discovery agent ODA . XML ODA reads XML schemas and document type definitions DTDs for each table in the database and generates business objects when the database tables are not known or not readily available. After business objects are generated the user has to manually edit all the application specific information ASI fields of the business objects to match the database application adapter expected information for example table name column table etc. Application specific information fields provides mapping of business object fields to corresponding field in the application specific data structure of the database application. This approach requires a fair amount of manual efforts to correct the ASI fields in the generated business objects.

A second approach is by using a database adapter ODA such as a JDBC ODA to directly draw definitions of database tables and relationship and generate business objects from these definitions when the database tables are known. Possible edits may be required to match deviations between the generated business objects and the XML schemas. In this approach a database connection is necessary in order to access the database for creating the business objects.

While these approaches attempt to alleviate some problems of integrating XML schemas significant manual efforts are required to fine tune the business objects in order to meet the database applications expected information. In addition these approaches fail to accommodate the variety of XML schemas annotated with relationships to the database tables and columns. Furthermore there is no existing mechanism that accommodates database application version or vendor changes.

Therefore it would be advantageous to have an improved method apparatus and computer instructions for mapping SQL schema to application specific business objects to be understood by integration broker such that SQL schemas may be imported into the integration server regardless of the variety of schema annotations or database application version and vendor changes.

The present invention provides a method an apparatus and computer instructions for mapping structured query language schema to application specific business objects in an integration application environment. The present invention detects a structured query language schema and generates a set of meta business objects from the schema which includes metadata of the schema.

From a set of registered business object application specific builders the present invention identifies a business object application specific information builder for the set of meta business objects and populates a set of application specific information fields for the set of meta business objects based on the metadata of the schema.

With reference now to the figures depicts a pictorial representation of a network of data processing systems in which the present invention may be implemented. Network data processing system is a network of computers in which the present invention may be implemented. Network data processing system contains network which is the medium used to provide communications links between various devices and computers connected together within network data processing system . Network may include connections such as wire wireless communication links or fiber optic cables.

In the depicted example server is connected to network along with storage unit . In addition clients and are connected to network . These clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients . Clients and are clients to server . Network data processing system may include additional servers clients and other devices not shown. In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial government educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for the present invention.

Referring to a block diagram of a data processing system that may be implemented as a server such as server in is depicted in accordance with an illustrative embodiment of the present invention. Data processing system may be a symmetric multiprocessor SMP system including a plurality of processors and connected to system bus . Alternatively a single processor system may be employed. Also connected to system bus is memory controller cache which provides an interface to local memory . I O Bus Bridge is connected to system bus and provides an interface to I O bus . Memory controller cache and I O Bus Bridge may be integrated as depicted.

Peripheral component interconnect PCI bus bridge connected to I O bus provides an interface to PCI local bus . A number of modems may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add in connectors. Communications links to clients in may be provided through modem and network adapter connected to PCI local bus through add in connectors.

Additional PCI bus bridges and provide interfaces for additional PCI local buses and from which additional modems or network adapters may be supported. In this manner data processing system allows connections to multiple network computers. Memory mapped graphics adapter and hard disk may also be connected to I O bus as depicted either directly or indirectly.

Those of ordinary skill in the art will appreciate that the hardware depicted in may vary. For example other peripheral devices such as optical disk drives and the like also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.

The data processing system depicted in may be for example an IBM eServer pSeries system a product of International Business Machines Corporation in Armonk N.Y. running the Advanced Interactive Executive AIX operating system or LINUX operating system.

With reference now to a block diagram illustrating a data processing system is depicted in which the present invention may be implemented. Data processing system is an example of a client computer. Data processing system employs a peripheral component interconnect PCI local bus architecture. Although the depicted example employs a PCI bus other bus architectures such as Accelerated Graphics Port AGP and Industry Standard Architecture ISA may be used. Processor and main memory are connected to PCI local bus through PCI Bridge . PCI Bridge also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus may be made through direct component interconnection or through add in boards. In the depicted example local area network LAN adapter small computer system interface SCSI host bus adapter and expansion bus interface are connected to PCI local bus by direct component connection. In contrast audio adapter graphics adapter and audio video adapter are connected to PCI local bus by add in boards inserted into expansion slots. Expansion bus interface provides a connection for a keyboard and mouse adapter modem and additional memory . SCSI host bus adapter provides a connection for hard disk drive tape drive and CD ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add in connectors.

An operating system runs on processor and is used to coordinate and provide control of various components within data processing system in . The operating system may be a commercially available operating system such as Windows XP which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provide calls to the operating system from Java programs or applications executing on data processing system . Java is a trademark of Sun Microsystems Inc. Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash read only memory ROM equivalent nonvolatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the present invention may be applied to a multiprocessor data processing system.

As another example data processing system may be a stand alone system configured to be bootable without relying on some type of network communication interfaces. As a further example data processing system may be a personal digital assistant PDA device which is configured with ROM and or flash ROM in order to provide non volatile memory for storing operating system files and or user generated data.

The depicted example in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system also may be a kiosk or a Web appliance.

As described in related patent application entitled Using Schemas to Generate Application Specific Business Objects for Use in an Integration Broker incorporated by reference above when a source application wants to communicate with a destination application in an integrated application environment adapters are used to transform data in the source format to the destination format. Specifically an adapter of the source application may convert proprietary data or application specific business objects to generic business objects understood by the integrated environment. Business objects are containers that hold fields of any type.

Business object fields may include a field type a field name and a field ASI. Field name indicates the name of the field such as street. Field type indicates a type of the field for example a string an integer or a long. Field ASI is typically empty if the business object is a generic business object or it may hold information for its matching application adapter. A user may also include comments for each field to indicate status such as whether the field is a foreign key a key a default value or whether the field may be null or not. An instance of the business object definition holds instance values that conform to the type defined in the business object definition.

Upon receiving the generic business objects an adapter of the destination application may convert the generic business objects back to application specific business objects for the destination application. In this way collaboration may be achieved between the source and destination applications since adapters normalize their underlying application.

Turning now to a diagram illustrating an integrated application environment is depicted in accordance with an illustrative embodiment of the present invention. As depicted in integration application environment includes integration server . Integration server may be implemented as data processing system in .

Integration server includes integration broker which provides services for transfer of data in application specific business objects among applications and . Applications and are clients for integration broker and maintain data in application specific data structures and respectively. Application specific data structures and may reside in vendor specific databases such as storage and or tied to an application that may not have storage attached.

When a source application such as application receives a new customer address adapter reads the customer with the new customer address and transforms it into an application specific business object. Adapter then sends the application specific business object to integration broker . Integration broker includes a map that maps the application specific business object into a generic business object which represents relevant parts of the customer field in a normalized way.

The generic business object does not have any application specific information fields and is used in generic collaborations while the application specific business object looks structurally the same as the generic business object but with ASI fields initialized to work with adapter . Adapter transforms application specific business objects to a format understood by application . Examples of formats include XML database SQL queries IDOC BAPI for SAP simple output text files or direct connection to a third party vendor application programming interface.

A collaboration mechanism within integration broker that provides synchronization between the source adapter and the target adapter accepts the generic business object and sends an update request to target adapter of target application .

Before returning the object to target adapter integration broker maps the generic object into the target application specific business object. Once the application specific business object is received by target adapter target adapter sends the updated address information in the target application s format to target application .

While in this illustrative embodiment three adapters are provided to transfer data between data structures any number of additional adapters may be provided to transfer data between additional data structures without departing the spirit and scope of the present invention. In addition adapters may be implemented as a standalone adapter or tied to a target application that may not have a storage device attached. An example of a standalone adapter is a source adapter which reads temperature from a measuring device. An example of an adapter tied to a target application is a front end that is tied to some other application.

Turning now to a diagram illustrating a generic framework for reading markup language schemas to form business objects is depicted in accordance with an illustrative embodiment of the present invention. As depicted in in integration broker application markup language schemas and may be provided to define the structure and formats of application specific data structures such as data structures and in .

Schemas and are parsed by schema resolver to generate base structures for application specific business objects and . These base structures are known as meta business objects BOs . Meta BOs hold information for the application specific business objects as well as references to the original source schemas and . Schemas and are then interpreted by business object ASI resolver to populate application specific information ASI fields of the application specific business objects and . ASI fields provide information necessary to configure the target application. For example in case of a target database application ASI fields may include the database name table names and column names.

If BO ASI resolver is able to populate the ASI fields BO ASI resolver populates the ASI fields and passes the application specific business objects and to business object writer . BO writer writes out the business objects with ASI fields. BO ASI resolver may also be extended to plug in additional specific ASI builders that are able to interpret a particular form of schema definition. More detail regarding the extension of BO ASI builder is discussed in .

The present invention provides a method an apparatus and computer instructions for mapping SQL XML schema to application specific business objects in an integrated application environment. In an illustrative embodiment the present invention extends the functionality of the business object application specific information BO ASI resolver to plug in an additional business object application specific information BO ASI builder for SQL annotated schema.

When a SQL XML schema is provided to a schema resolver the schema resolver parses the SQL XML schema and generates meta business objects BOs based on metadata of the schema. Meta BOs are object representations of the schema format. The meta BOs include all annotations commons names rules and other hierarchical information of the schema. The metadata of the schema includes annotations elements and attributes that represent database table names and database columns.

The schema resolver may accommodate any relational database schema format and may import any database table structures of any database vendors as long as the table structures are described by XML schemas. In addition the pluggable nature of the schema resolver allows any format annotating the XML schema to relate to a particular database table structure. More detail regarding possible SQL annotation formats for XML schema is discussed in . Once the meta BOs are generated the BO ASI resolver locates registered BO ASI builders that are able to interpret particular forms of schema definitions and determines if a SQL BO ASI builder is present to handle the meta BOs.

In order to determine which of the registered BO ASI builders is capable of handling the meta BOs the application type and version of the provided SQL XML schema are analyzed by the BO ASI resolver to determine if a registered BO ASI builder is able to interpret a given set of meta BOs with their annotated schema. The application type and version may be based on the target namespace of the schema additional namespaces for adding schema type extensions schema information document annotations etc. A classification of a given schema may be quickly determined using one of the above characteristics. However in cases where none of the above characteristics are available the BO ASI resolver may ask the registered BO ASI builder to perform an in depth analysis of the schema structure in order to recognize patterns that would fit a particular form of schema definition.

Once the BO ASI resolver locates a SQL BO ASI builder to handle the meta BOs the SQL BO ASI builder reads the meta BOs and analyzes schema annotations documentation and specific schema types in order to build ASI fields for the particular schema. Since meta BOs expose the schema structure the schema structure may be used to fine tune and populate the application specific information of BOs. Thus the SQL BO ASI builder examines the particular schema and generates an intermediate representation of dependencies of the meta BOs including all the information necessary to create ASI fields of BOs. The SQL BO ASI builder then populates the ASI fields for the meta BOs that can be understood by SQL compliant application adapters. More detail regarding meta BO ASI fields is discussed in .

Once the ASI fields are populated the SQL BO ASI builder sends the meta BOs to BO writer which generates application specific business objects used by the integration broker. The application specific business objects only include database information such as database name table names and column names and not schema information.

Turning now to a diagram for a generic framework for reading markup language schemas with added SQL ASI builder is depicted in accordance with an illustrative embodiment of the present invention. As depicted in integration broker is similar to integration broker in except that SQL BO ASI builder is added to communication with BO ASI resolver .

When BO ASI resolver receives SQL XML schema from schema resolver BO ASI resolver locates SQL BO ASI builder from its registered BO ASI builders since SQL BO ASI builder is able to handle the meta BOs generated from SQL BO ASI schema . It is noted that since SQL BO ASI builder is pluggable in nature different types of schemas and annotation formats from different vendors may also be accommodated by integration broker . Thus if future changes of the database application lead to a change in SQL XML schema a new BO SQL ASI builder may be added to the BO ASI resolver to distinguish between different database versions and different vendors.

Turning now to a diagram illustrating an exemplary database table definition is depicted in accordance with a preferred embodiment of the present invention. In this illustrative example data table definition includes person table contact table and address table .

Person table has column FIRST NAME representing a person s first name column LAST NAME representing a person s last name and column DOB representing a person s date of birth.

Contact table has column type which describes a type of contact such as cell phone home phone or email address. Contact table also includes detail which describes the content of the contact type for example the actual phone number website or email address.

Address table includes street street NR house NR town zip state province and country . These columns together describe address information. Both contact table and address table have their own foreign key such as Person ID and . In addition each table has its own primary key such as ID and .

Turning now to a diagram illustrating an exemplary XML schema format for representing database table definition such as database table definition in using XML elements and attribute naming is depicted in accordance with an illustrative embodiment of the present invention. As depicted in schema includes three complex type elements PERSON CONTACT and ADDRESS .

PERSON CONTACT and ADDRESS are used to describe person table contact table and address table in respectively. PERSON is represented by a complex type element PERSON T which translates to a business object. In this example PERSON T includes four simple type elements ID FIRST NAME LAST NAME and DOB . These elements describe columns FIRST NAME LAST NAME and DOB in respectively.

In addition to simple type elements one may use complex type elements or element references to define foreign keys to other fields in other tables. For example complex type element CONTACT T includes complex reference PERSON ID which describes foreign key PERSON ID in .

In addition to using complex type elements or element references schema referential constraints may be used to define primary keys and fields. For example key may be used to define primary key ID of person table and keyref may be used to define foreign key PERSON ID of address table . Thus with schema SQL ASI builder may populate both business object field names and ASI fields with matching element names. It is also noted that rather than using XML elements for simple types to define column names XML attributes may be used. In addition ID or IDREF may be used instead of schema keys and foreign keys.

Turning now to a diagram illustrating an exemplary XML schema format for representing database table definition such as database table definition in using XML complex type and simple type naming is depicted in accordance with an illustrative embodiment of the present invention. As depicted in instead of using XML element or attribute name to refer to table names and columns complex type and simple type names are used to refer to database names. XML element and attribute names are now used for building business objects.

In this illustrative example schema includes simple type element ID TYPE and DETAIL . These elements describe ID TYPE and DETAIL in . CONTACT is a complex type element used to describe contact table in .

It is possible that the naming of business objects might vary from given element names in order to observe possible naming conventions. Typically application business object name has the application name prepended to the business object name. For example element DB Contact has DB prepended to the business object name to define a database application.

Turning now to a diagram illustrating an exemplary XML schema format for representing database table definition such as database table definition in using schema target namespace naming is depicted in accordance with an illustrative embodiment of the present invention. As depicted in schema is used to hold definition for one database table only. The target namespace holds part of or directly the database table name. For example the target namespace of schema holds the database table name PERSON which describes person table in .

The column names may be described using any of the naming methods in and foreign references may be handled through importing schema definitions.

Turning now to a diagram illustrating an exemplary XML schema format for representing database table definition such as database table definition in using schema extension types is depicted in accordance with an illustrative embodiment of the present invention. As depicted in schema declares database specific schema extensions to handle table and column names.

For example xyz column extension is used to describe database table columns ID FIRST NAME LAST NAME and DOB . It is noted that schema extension may also introduce a database type hint or override that allows disambiguating type information if the schema simple types cannot clearly map to the database types.

Turning now to a diagram illustrating an exemplary XML schema format for representing database table definition such as database table definition in using schema appinfo annotation is depicted in accordance with an illustrative embodiment of the present invention. As depicted in database table and column names may be conveyed using schema appinfo annotation. For example schema uses appinfo column to describe database table column ID .

Turning now to a diagram illustrating an exemplary XML schema format for representing database table definition such as database table definition in using schema comment annotation is depicted in accordance with an illustrative embodiment of the present invention. As depicted in comments are used to pass meta information of the database definition.

For example schema includes comment col ID which is used to pass column name ID with a given syntax. Similarly comment col FIRST NAME is used to pass column name FIRST NAME. Comment

Turning now to a diagram illustrating an exemplary application specific business object configured by the SQL ASI builder is depicted in accordance with an illustrative embodiment of the present invention. As depicted in SQL ASI builder configures meta BOs such that it may represent database table definitions and in .

In this illustrative example business object is configured to represent person table in . Business object includes business object level ASI fields such as tn PERSON and fields such as cn ID cn FIRST NAME cn LAST NAME and cn DOB . Business object also includes business object name DB Person and business object field names such as id first last and dob . Similarly business object is configured to represent contact table in and business object is configured to represent address table in .

Turning now to a flowchart of an exemplary process of mapping SQL XML schema to application specific business objects is depicted in accordance with an illustrative embodiment of the present invention. As depicted in the process begins when an operation to generate application specific business object from a SQL XML schema is invoked step .

Next the schema resolver parses the SQL XML schema to generate meta business objects BOs holding references to source XML schema step . The BO ASI resolver then receives the schema and locates a SQL BO ASI builder that is able to handle the meta BOs step . Once a SQL BO ASI builder is located the builder analyzes the schema annotation and fills the ASI fields for the meta BOs step . The ASI fields are understandable by SQL compliant application adapter.

The SQL BO ASI builder then returns the filled meta BOs to the BO ASI resolver step and the BO ASI resolver sends the meta BOs to the BO writer in order to write out business objects with application specific information that is understandable by the integration broker s SQL adapter for example the JDBC adapter step . Thus the process terminates thereafter.

Thus the present invention provides an improved mapping system to map SQL XML schema annotations to application specific business objects. The functionality of the BO ASI resolver is extended to locate a SQL BO ASI builder from a plurality of registered BO ASI builders that is able to handle a particular type of schema definition. In addition the SQL BO ASI builder that is located may fill in ASI fields for the meta BOs. In this way SQL XML schema may be automatically imported in the integration server and a variety of schema types may be accommodated regardless of database versions and vendors.

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such a floppy disc a hard disk drive a RAM and CD ROMs and transmission type media such as digital and analog communications links.

The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

