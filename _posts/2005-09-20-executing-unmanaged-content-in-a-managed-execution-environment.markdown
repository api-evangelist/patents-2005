---

title: Executing unmanaged content in a managed execution environment
abstract: A legacy application program contains unmanaged code. Application definitions for common unmanaged applications are established. An application definition includes a manifest that describes the unmanaged code and an execution wrapper that projects the unmanaged code as a managed assembly to the execution environment. An application definition can also specify other modifications to the unmanaged code, such as modifications to cause the unmanaged code to call managed application programming interfaces (APIs). The application definition is utilized to transform the unmanaged code into a managed assembly. The manifest and wrapper are added to the managed assembly and the unmanaged code is maintained as a resource. The managed execution environment uses the manifest to compute a permissions set for the unmanaged code, and the wrapper invokes the unmanaged code. The unmanaged code uses the managed APIs, and the managed execution environment can therefore manage execution of the code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07752242&OS=07752242&RS=07752242
owner: Symantec Corporation
number: 07752242
owner_city: Cupertino
owner_country: US
publication_date: 20050920
---
This invention pertains in general to computer security and in particular to executing legacy computer programs within new security paradigms.

Computer security has become increasingly important in recent times. Server computers that store confidential data such as credit card numbers or medical records must be protected from attempts by malicious attackers to obtain the data. Likewise other computers such as home computers must be protected from malicious software such as viruses worms spyware Trojan horse programs and other similar threats that an end user is likely to encounter when connected to the Internet. Modern operating systems such as Unix Linux and MICROSOFT WINDOWS XP incorporate security paradigms that are intended to protect the computers from malicious behaviors.

Until recently computer security paradigms relied on the concept of transitive security to protect the computer. A end user having a defined role is assigned a set of permissions by the operating system. All code executed by that user has the same set of permissions as the end user. Transitive security can be problematic if an end user having broad permissions executes malicious software because the malicious software will also have broad permissions.

Newer operating systems support paradigms that specify the permissions based at least in part on the code itself. Microsoft s new operating systems for example provide a feature called .NET Security. .NET Security is based on three aspects 1 managed code 2 role based security and 3 evidence based security. Managed code is supervised by the operating system as it is executed to ensure that it does not perform any operations that exceed the scope of its permissions. Role based security means that the code has permissions defined in part by the role of the end user that executes the code. Under evidence based security the permissions of the code are determined in part by the trustworthiness of the end user and or code itself.

Code must be specially written to take advantage of the features of .NET Security. The operating systems execute legacy code not written for .NET Security in a native mode that relies on role based transitive security. There is a large base of legacy code and it is likely that much of the code will never be revised to utilize .NET Security. As a result computers supporting .NET Security will likely execute a large amount of legacy code under a transitive security paradigm with the attendant security risks. Therefore there is a need in the art for a way to allow legacy code to take advantage of the security provided by .NET Security and other similar environments.

The above need is met by adapting the legacy unmanaged code to execute in a managed execution environment such as MICROSOFT s Common Language Runtime CLR . Application definitions for common and or popular legacy applications are established by a security software vendor. An application definition includes a manifest describing the unmanaged code and an execution wrapper that invokes the unmanaged code within the managed execution environment. An application definition can also specify modifications to the unmanaged code such as modifications to cause the unmanaged code to call managed application programming interfaces APIs instead of legacy unmanaged APIs.

A transformation module executing on a computer system analyzes the unmanaged code and selects a corresponding application definition. The transformation module uses the application definition to transform the unmanaged code into a managed assembly. The manifest and wrapper are added to the managed assembly and the unmanaged code is maintained as a resource either within the same file or in an auxiliary file. In addition the transformation module makes the modifications to the unmanaged code specified by the application definition to cause the unmanaged code to use managed APIs.

When the managed execution environment receives the managed assembly it computes a permissions set for it from the manifest and a security policy. The wrapper is executed within a domain having the permissions set which in turn invokes the unmanaged code. The unmanaged code uses the managed APIs thereby allowing the managed execution environment to manage execution of the code.

The figures depict an embodiment of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.

As is known in the art the computer system is adapted to execute computer program modules. As used herein the term module refers to computer program logic for providing the specified functionality. A module can be implemented in hardware firmware and or software. A module is typically stored on the storage device loaded into the memory and executed by the processor .

The assembly includes a manifest that contains a collection of metadata describing how the other elements in the assembly relate to each other. The metadata in the manifest specify the assembly s version and security requirements and information needed to define the scope of the assembly and resolve references to resources and classes. To this end the manifest can describe entry points of code a hash of the assembly or other data useful for integrity checking dependent assemblies etc. In one embodiment the manifest is encoded in an extensible markup language XML document.

The assembly also includes type metadata that describe the data types that are used in the assembly. Further the assembly includes intermediate language IL code such as Microsoft Intermediate Language MSIL code. Typically the IL code is emitted by a compiler based on source code written in a standard programming language such as C . The assembly may contain resources that are used by the IL code .

The compiler module in the security paradigm produces managed code for the computer system from the IL code in the assembly . The compiler module can be a just in time compiler that produces the managed code at runtime. The managed code contains instructions in the native format of the computer system i.e. of the processor and includes functionality for performing tasks such as traps and garbage collection exception handling type safety array bounds and indexing checking etc.

The CLR is a managed execution environment. In one embodiment the CLR is provided by a Windows based operating system from MICROSOFT CORPORATION as part of .NET security but in other embodiments the CLR is provided by LINUX UNIX or other operating systems. The CLR receives the manifest from the assembly and a defined runtime security policy . The CLR uses the manifest and the security policy to compute the effective permissions set for the managed code produced by the compiler module . The CLR loads the managed code into a domain having the computed permissions and executes the code within that domain. During execution the managed code will typically make calls to application program interfaces APIs provided by the CLR . These APIs can include managed APIs such as the WinFX APIs provided by some MICROSOFT operating systems and legacy APIs that are not designed for use with managed code. As used herein the term CLR refers to any common language runtime infrastructure having the characteristics described herein and does not necessarily refer to a particular implementation.

A transformation module executing on the computer system analyzes the unmanaged code pairs it with an appropriate manifest and transforms it into a managed assembly that can execute within the CLR . The transformation module also alters the unmanaged code if necessary to make it better execute within the CLR . Depending upon the embodiment the alterations can include changing the IAT of the unmanaged code s PE file to call managed code APIs instead of the legacy unmanaged APIs and setting attributes of the PE file to mark it as managed code. The alterations can also include adding a managed code wrapper around the unmanaged code. The wrapper directs execution to the entry point of the unmanaged code when it is executed in the CLR .

In one embodiment the transformation module is provided by a security software vendor. The transformation module can be for example a standalone program incorporated into a security suite or other software package or incorporated into the operating system as a shell extension or other component. In one embodiment the transformation module executes whenever the computer system is active and monitors all code executed by the computer system . When the transformation module detects that the operating system has been asked to execute unmanaged code the transformation module intercepts the request and performs its functions before the code is executed. In other embodiments the transformation module operates at other times. For example the transformation module can scan the storage device a priori to identify unmanaged code and create corresponding managed assemblies.

The transformation module includes a data storage module holding application definitions for use in creating managed assemblies from unmanaged code . Generally each application definition stores information describing how to transform a specific unmanaged application program i.e. the unmanaged code into a managed assembly optimized for execution in the CLR . In one embodiment the application definitions are developed by a security software vendor and provided to the transformation module . For example the security software vendor can analyze the characteristics of popular and or common unmanaged application programs and develop an application definition tailored for creating an optimized managed assembly for that application. The security software vendor distributes the application definitions to the transformation modules of computer systems by having the transformation modules or other modules on the computer systems download the definitions from a server on a network read the definitions from a computer readable medium and or obtain the definitions via another distribution technique. In one embodiment the data storage module also stores one or more default application definitions for use with unmanaged code for which it lacks specific application definitions.

In one embodiment an application definition within the storage module includes an assembly manifest tailored to the specific unmanaged code to which the application definition pertains. Further one embodiment of the application definition stores a managed code wrapper for use with the unmanaged code. The wrapper is a virtual execution wrapper that projects the unmanaged code as a managed assembly to the CLR . In one embodiment the wrapper contains a managed code function written in the IL that invokes the unmanaged code. Depending upon the embodiment and or unmanaged code the wrapper can describe specific methods for invoking the unmanaged code such as specific entry points command line arguments and or environment variables. Likewise the wrapper can use a generic method to call a default entry point of the unmanaged code.

In one embodiment an application definition also stores code modification data that describe modifications to make to the unmanaged code in order to optimally execute it within the CLR . The described modifications can include modifications to the IAT of the PE file containing the unmanaged code that convert legacy API function calls to equivalent managed API functions calls.

A data generation module generates application definitions and or additional data for existing application definitions stored in the data storage module . In one embodiment the data generation module provides a wizard or other user interface UI that queries an end user of the computer system for information about the unmanaged code . The wizard uses the end user s answers to the queries to create an application definition for the unmanaged code and or to supplement the information contained in an existing application definition.

For example if no application definition exists for some unmanaged code the wizard can ask the end user questions designed to identify from where the unmanaged code was downloaded whether the code needs access to the network or a printer whether the end user trusts the vendor that provided the code etc. The data generation module uses the answers to these questions to supplement the manifest wrapper and or other information contained in a default application definition and thereby creates an application definition tailored to the particular unmanaged code . In one embodiment the wizard or other UI provided by the data generation module also allows the end user to opt out of managed execution for the unmanaged code .

A data selection module selects an application definition from the data storage module to utilize with the unmanaged code in order to produce a managed assembly for execution within the CLR . The data selection module identifies the application definition that is best suited to the unmanaged code . In one embodiment the data selection module analyzes the unmanaged code s PE file and identifies the application program that it contains. For example the data selection module may determine that the unmanaged code contains a particular word processing program based on characteristics of the PE file such as its name size creation date version information checksum and or other data maintained within it. Once this identification is performed the data selection module selects the corresponding application definition from the data storage module or a default definition and associates it with the unmanaged code .

A code modification module creates the managed assembly from the unmanaged code and the application definition identified by the data selection module . In one embodiment the code modification module creates a new PE file containing the managed assembly . This new PE file contains the manifest from the identified application definition and may also contain the wrapper if it is used for invoking the unmanaged code . In one embodiment the code modification module incorporates the original unmanaged code into the new PE file as a resource. In another embodiment the unmanaged code is maintained in a separate auxiliary file.

In addition the code modification module makes any code modifications described by the code modification data in the application definition . In one embodiment the code modification module alters the IAT of the unmanaged code to call the managed APIs instead of the unmanaged APIs. This alteration ensures that all operations regarded as protected by the CLR like file write operations in critical system folders are executed via managed extensions. Other embodiments make other and or different modifications.

In one embodiment application definitions are established for unmanaged code on the computer system . The application definitions can be established for example by downloading definitions specific to particular unmanaged application programs from a server on the Internet or another network by providing an end user with a UI that prompts for information about the code and or by establishing a default application definition. Generally each application definition includes a manifest an execution wrapper and modification data describing how to modify the unmanaged code for the CLR . Some application definitions may lack one or more of these components.

At some point the transformation module is activated in order to transform specific unmanaged code into a managed assembly . This activation can occur for example when the operating system is asked to execute the unmanaged code when the transformation module scans the storage device on the computer system to look for unmanaged code or when the end user specifically directs the transformation module to act on the unmanaged code. The transformation module selects an application definition for the unmanaged code . In one embodiment the transformation module examines the PE file containing the unmanaged code and identifies an application definition corresponding to the code. If no corresponding definition is found a default application definition is selected and or a UI is provided to the end user to gather information utilized to create an application definition.

The transformation module modifies the unmanaged code to produce a corresponding managed assembly . In one embodiment the transformation module creates a new managed assembly that includes the manifest and execution wrapper from the application definition. The transformation module modifies the unmanaged code by altering its IAT to call managed APIs instead of unmanaged APIs and or makes other modifications to the code as specified by the application definition . The modified unmanaged code is stored as a resource of the managed assembly and or as an auxiliary file. In another embodiment the transformation module does not include a wrapper in the managed assembly .

The managed assembly is executed in the CLR . As part of this execution the CLR computes the effective permissions set based upon the manifest the security policy the role of the end user and or other information and creates a domain having the computed permissions. In addition the compiler module compiles the wrapper into managed code for the computer system . The CLR loads the managed code into a domain having the computed permissions and executes the code within that domain. This execution invokes the unmanaged code . When the unmanaged code makes an API call the call is redirected to the equivalent managed API function due to the modifications to the code s IAT. The CLR checks the effective permissions set to determine whether the domain permits the API function. If the permission demand made by the API call exceeds the effective permissions set the CLR raises a security exception. This security exception can result in termination of the unmanaged code a prompt to the end user to seek permission to continue executing the code or another action depending upon the configuration of the CLR . Thus the transformation module allows unmanaged code to execute within the CLR and take advantage of the security paradigm provided therein.

The above description is included to illustrate the operation of the preferred embodiments and is not meant to limit the scope of the invention. Those of skill in the art will recognize that when the description refers to an embodiment or another embodiment it may be referring to the same and or different embodiments. The scope of the invention is to be limited only by the following claims. From the above discussion many variations will be apparent to one skilled in the relevant art that would yet be encompassed by the spirit and scope of the invention.

