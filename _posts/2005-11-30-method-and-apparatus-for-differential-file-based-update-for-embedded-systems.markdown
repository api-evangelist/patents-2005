---

title: Method and apparatus for differential file based update for embedded systems
abstract: A system is provided including a host processing system and a remote management module coupled to it. The host processing system is configured to receive an update package. The remote management module is configured to determine one or more modified files from the update package and update its current embedded system by replacing, with the one or more modified files, only those files associated with the current embedded system that correspond to the one or more modified files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08554748&OS=08554748&RS=08554748
owner: NetApp, Inc.
number: 08554748
owner_city: Sunnyvale
owner_country: US
publication_date: 20051130
---
At least one embodiment of the present invention pertains to remote management of a processing system and more particularly to a method and apparatus for differential file based update for embedded systems.

In many types of computer networks it is desirable to be able to perform certain management related functions on a processing system from a remote location. For example a business enterprise may operate a large computer network that includes numerous client and server processing systems hereinafter clients and servers respectively . With such a network it may be desirable to allow a network administrator to perform or control various functions on the clients and or servers from a remote console via the network.

Some existing computer systems allow management related functions to be performed remotely via a network. In one approach a device known as a service processor is incorporated into a processing system to enable remote management of the processing system referred to as the host processing system via a network. The service processor is often in the form of a dedicated circuit card separate from the other elements of the host processing system. The service processor normally has a network interface that connects to the network and a separate internal interface that connects to one or more components of the processing system. The service processor typically includes control circuitry e.g. a microprocessor or microcontroller which is programmed or otherwise configured to respond to commands received from a remote administrative console via the network and to perform at least some of the management functions mentioned above.

A service processor that is capable of controlling its host processing system remotely may be referred to as a remote management module RMM . An RMM may be implemented as an add in card and may provide console port capabilities over a local area network LAN or wide area network WAN connection and CLI functions to allow remote management of the host processing system.

An RMM may run an embedded operating system such as Linux inside a microprocessor. An embedded system is a special purpose computer system which is completely encapsulated by the device it controls. An embedded operating system is an operating system for embedded systems. An RMM may store the RMM software in its non volatile memory e.g. a FLASH chip. Software that has been stored onto non volatile memory may be referred to as firmware. When a new version of the RMM software becomes available the current RMM software may be updated with the new version.

In some existing systems the firmware of the RMM is updated through a serial link between the host and the RMM. Once the update firmware reaches the RMM it is burnt onto the RMM s FLASH chip. The methods currently used for file transfer over a serial link and for burning software onto a FLASH chip may result in unacceptably slow updates because the serial interface is slow and a FLASH chip is slow electronically.

Two bottlenecks in the RMM update process are therefore the slow serial interface between the host and RMM and the FLASH chip being slow electronically.

A system and method are provided for differential file based update for embedded systems. The system includes a host processing system and a remote management module coupled to it. The host processing system is configured to receive an update package. The remote management module is configured to determine one or more modified files from the update package and update its current embedded system by replacing with the one or more modified files only those files associated with the current embedded system that correspond to the one or more modified files.

Other aspects of the invention will be apparent from the accompanying figures and from the detailed description that follows.

As described in detail below the technique introduced herein addresses problems associated with transferring RMM software updates via a communications link and storing the updated software onto electronically slow non volatile memory. The communications link may be for example a serial link or an Ethernet or wireless network link. In one embodiment of the present invention a layer of granularity is added by using a differential file based approach where only the files that have changed between versions are being updated.

In one embodiment of the present invention when an update package for an RMM for a storage system becomes available an administrator of the storage system may issue a command to the storage system to retrieve the update package and to replace the current RMM software with the updated software. In one embodiment of the invention the storage OS in the storage system may obtain the update package from for example an update web site configured to provide update packages. An update package may comprise a boot loader a kernel and a file system. Next the storage OS rather than sending the whole update package to the RMM over the serial link sends to the RMM metadata associated with the update package. In one embodiment metadata comprises checksums for the files in the update package. The metadata allows the RMM to determine which files from the update package have been changed added or deleted as compared to the software currently running on the RMM. The RMM then receives from the storage OS only those files that have been changed or added and updates the software stored in RMM s non volatile memory e.g. FLASH memory with the received files as described in further detail below. Thus only the new and updated files are being transmitted over the serial link between the storage software and the RMM. Also only the files corresponding to the changed files and any new files are being burned onto the FLASH memory. This approach may result in increased update speed and faster flash updates.

It will be noted that a differential file based approach may be used for upgrading the RMM software downgrading the RMM software or otherwise updating the RMM software.

In one embodiment the present invention may be implemented in the context of a storage oriented network i.e. a network that includes one or more storage servers that store and retrieve data on behalf of one or more clients. Such a network may be used for example to provide multiple users with access to shared data or to backup mission critical data. An example of such a network is illustrated in .

In a storage server is coupled locally to a storage subsystem which includes a set of mass storage devices and to one or more clients through a network such as a LAN or WAN. The storage server operates on behalf of the clients to store and manage shared files or other units of data e.g. blocks in the set of mass storage devices. Each of the clients may be for example a conventional personal computer PC workstation or the like. The storage subsystem is managed by the storage server . The storage server receives and responds to various read and write requests from the clients directed to data stored in or to be stored in the storage subsystem . The mass storage devices in the storage subsystem may be for example conventional magnetic disks optical disks such as CD ROM or DVD based storage magneto optical MO storage or any other type of non volatile storage devices suitable for storing large quantities of data. The mass storage devices may be organized into one or more volumes of Redundant Array of Inexpensive Disks RAID .

Also shown in is an administrative console coupled to the storage server . The storage server in this configuration includes a serial port and appropriate software to allow direct communication between the storage server and the administrative console through a transmission line. This configuration enables a network administrator to perform at least some of the types of management functions mentioned above on the storage server .

A storage server can have a service processor coupled to it which enables remote management of the processing system via a network . Alternatively a service processor may be an internal component of the storage server. The storage server can be managed through a network from a remote administrative console in addition to being capable of being managed through the direct serial interface. It will be noted that although the processing system to be remotely managed illustrated in is a storage server the technique introduced herein can also be applied to essentially any other type of network connected processing system such as standard personal computers PCs workstations servers other than storage servers etc. The storage server may be for example a file server and more particularly may be a network attached storage NAS appliance. Alternatively the storage server may be a server that provides clients with access to individual data blocks as may be the case in a storage area network SAN . Alternatively the storage server may be a device that provides clients with access to data at both the file level and the block level.

The storage server includes one or more processors and memory which may be coupled to each other through a chipset. A chipset may include for example a conventional Northbridge Southbridge combination. The processor represents the central processing unit CPU of the storage server and may be for example one or more programmable general purpose or special purpose microprocessors or digital signal processors DSPs microcontrollers application specific integrated circuits ASICs programmable logic devices PLDs or a combination of such devices. The memory includes a system memory such as random access memory RAM to store processor data and instructions and an embedded system storage device . The embedded system storage device is preferably a non volatile memory device suitable for storing code required to transition the storage server from a standby or off state to an operational state in which application or operating system programs can run. The embedded system storage device includes a set of instructions that are executed immediately after the system is booted as well as the kernel the file system system logs and environmental variables.

The storage server may also include one or more internal mass storage devices a console serial interface a network adapter and a storage adapter which are coupled to the processor . The storage server may further include redundant power supplies . The internal mass storage devices may include any conventional medium for storing large volumes of data in a non volatile manner such as one or more magnetic or optical based disks. The serial interface allows a direct serial connection with a local administrative console such as console in and may be for example an RS 232 port. The storage adapter allows the storage server to access the storage subsystem and may be for example a Fibre Channel adapter or a SCSI adapter. The network adapter provides the storage server with the ability to communicate with remote devices such as the clients over network and may be for example an Ethernet adapter.

In the RMM is coupled to the host processing system via a dedicated hardware link . The hardware link may be for example a serial port connection a parallel port connection or an inter IC IIC or IC bus.

The processor is the CPU of the RMM and may be for example one or more programmable general purpose or special purpose microprocessors DSPs microcontrollers ASICs PLDs or a combination of such devices. The processor inputs and outputs various control signals and data to and from the host processing system . In at least one embodiment the processor is a conventional programmable general purpose microprocessor which runs software from local memory on the RMM e.g. FLASH and or RAM .

Updates to the RMM software may be delivered directly to the RMM via the network adapter . Alternatively the update package may first be delivered to the RMM s host and then the necessary files may be transmitted to the RMM via the serial interface . The necessary files may then be stored onto the FLASH .

At a high level the software of the RMM has two layers namely an operating system kernel the kernel and an application layer that runs on top of the kernel. The root file system constitutes application binaries daemon processes and configuration information. In certain embodiments the kernel is a Linux based kernel. The kernel in one embodiment may include a network interface to control network communications with a remote processing system and a storage server interface to control communications with the other components of the storage server . The network interface may include a protocol stack. The protocol stack in turn may include a sockets layer a Secure Shell SSH layer an IP TCP UDP layer a secure sockets layer SSL and an Ethernet driver layer. The storage server interface may include a serial driver through which the RMM can communicate with the operating system of the storage server and an IIC control module through which the RMM can communicate with other components of the storage server over an IIC bus.

The RMM application layer in one embodiment includes a packet layer that cooperates with the associated serial driver. The application layer root FS may also include a command line interface CLI to allow an authorized user to control functions of the RMM an application programming interface API to allow an authorized remote application to make calls to the RMM software an event monitoring module to request event data from the host and an event management module to receive event information from the event monitoring module.

The primary partition comprises a boot loader to load the operating system an operating system kernel e.g. a Linux based kernel a root FS and its logs and environmental variables . The root FS in one embodiment is the Journaling FLASH File System version 2 JFFS2 . JFFS2 is a log structured file system for use in FLASH memory devices.

The backup partition also comprises a boot loader an operating system kernel a root file system root FS and environmental variables . In one embodiment the backup partition may allow a certain amount of spare storage space .

The boot loader and the kernel in one embodiment each comprise a single file. The root FS on the other hand may comprise a plurality of files. Some of the files associated with the updated version of the RMM software may comprise files that are the same as the corresponding files in the current RMM software while other files associated with the updated version of the RMM software may comprise an updated version of the corresponding files in the current RMM software.

The host and the RMM each include a packet layer reference numerals and respectively that cooperates with an associated serial driver reference numerals and respectively . In order to facilitate updates of the RMM software the host may implement a firmware update FUD control component and an associated FUD data component .

As described above the host may obtain an update package from an update website and store it in its memory until a firmware update component of the RMM determines which files from the update package are different from the files comprising the current RMM software. The data associated with the RMM updates is communicated to the RMM utilizing a reliable file transfer protocol RFTP . RFTP reference numerals and on the host side and on the RMM side respectively may be designed to address issues associated with transferring large files.

On the RMM side components that are utilized to update the RMM software in addition to the packet layer the serial driver and the RFTP comprise a firmware update component for handling updates received via a serial port FUD SP . When update related data such as metadata or modified files from the update package are transmitted to the RMM via the serial link the data is communicated via the packet layer utilizing the FUD SP and the RFTP . Once the files that were determined by the FUD SP to be different from the current RMM software are received by the RMM from the host these files are stored by a FUD install engine onto a FLASH chip in order to update the current RMM software.

In one illustrative embodiment an update package may be obtained by the RMM directly without the use of the host via a network driver . When the RMM receives the update package it stores the package in memory and then processes update related data to determine what files have changed in the update package as compared to the current RMM software. This processing may be performed by a network based FUD component . Once the network based FUD determines the files that have been changed added or deleted as compared to the current RMM software the changed and newly added files are accessed by the FUD install engine and stored onto a FLASH chip in order to replace the corresponding files of the current RMM software.

As mentioned above reliable transfer of files associated with RMM update software may be accomplished by utilizing a reliable ftp RFTP . The overall design of the RFTP may be divided into two parts sending a file or symbolic link a special type of file that refers to another file by its pathname from the host to the RMM and receiving a file from the RMM at the host .

Reliable transfer of data from the host to the RMM may be accomplished in one embodiment by providing a reliable sender component on the host side a host reliable sender and an associated reliable receive component on the RMM side an RMM reliable receiver .

The host reliable sender may comprise two threads P P which are started when the host boots up. P sends out the data from the host to the RMM in the form of packets. P picks up all the replies sent by the RMM such as an acknowledgement for a packet ACK a negative acknowledgement NACK an acknowledgement for the control message CTRL ACK and an acknowledgement for the last data message LAST ACK . P then sends the replies to P. In one embodiment utilizing two threads may improve speed of the data transfer by designating a separate thread for receiving replies from the RMM .

In operation according to one illustrative embodiment P waits for a trigger message from the client. A client as used in the discussion pertaining to RFTP is caller of an API that requests files to be sent or received using RFTP. When the client requests that a file is sent to the RMM a trigger message is sent to P. P initially sends a control message with file transfer details to RMM and waits for a CTRL ACK. P receives the CTRL ACK and passes it on to P. P then starts sending out file data. RMM sends out ACK NACK messages which are picked up by P and sent to P. If P receives a NACK message from P P starts retransmitting the packets starting with the missing packet. In case the RMM doesn t send ACK NACK for a predetermined timeout interval P aborts the transaction and communicates to the client FAIL information with an error number indicating the cause of failure.

On the RMM side once the entire file is received checksums are verified to make sure the entire file was received correctly. The LAST ACK is then sent with the checksum indicating success failure. After the LAST ACK is received and if checksum was verified P communicates PASS information to the client. Otherwise P sends FAIL information to the client. P returns to the initial state and waits for a trigger event initiated by a client.

The RMM reliable receiver in one embodiment is a daemon e.g. a daemon named file receive which is started when RMM boots up. File receive daemon continuously reads messages from its message queue. If it gets a control message it first checks if space is available in the file system for the requested file. If there is not sufficient space file receive replies with CTRL ACK failure and aborts transaction. If space is available in the file system for the requested file it responds with a CTRL ACK success and waits for data messages.

When file receive receives a data message it writes the data into the destination file which may be specified by the host in the initial control message. In one embodiment file receive sends an ACK for every tenth packet it receives. If file receive receives a packet out of sequence it sends a NACK for the last successfully received packet. If the correct packet is not received for a predetermined timeout interval after a NACK is sent file receive resends the NACK message to the host . If two NACK timeouts are received file receive aborts this transaction cleans up the file and waits for the next control message.

When file receive receives the last packet in the file it computes and verifies the checksum associated with the file. It sends a LAST ACK for the last packet with checksum success failure information. On checksum failure file receive cleans up the file. If data packets are not received for a predetermined timeout interval file receive aborts the current transaction cleans up the file and waits for the next control message.

The symbolic link information for the entire package is maintained in a metadata file. The RMM reliable receiver in one embodiment may be utilized to transmit this symbolic link information. When the file receive daemon receives the metadata file with symbolic link information file receive creates new and modified symbolic links in the destination directory associated with the control packet. In one embodiment a symbolic link is created with default permissions and user group information. Permissions and user group information may be modified e.g. by the firmware update mechanism running a post install script.

Reliable transfer of data from the RMM to the host may be accomplished in one embodiment by providing a reliable receiver component on the host side a host reliable receiver and an associated reliable sender component on the RMM side an RMM reliable sender .

The reliable receiver component on the host in one embodiment is a thread named RMM receive file which is started during the host boot up. When a client calls a function responsible for receiving a file from the RMM a trigger message is sent to RMM receive file thread. RMM receive file sends this control request to RMM and waits for CTRL ACK which contains details about the file on the RMM . If RMM receive file does not receive CTRL ACK for a predetermined timeout interval RMM receive file tries to resend the control request. The transaction is aborted if RMM receive file does not receive CTRL ACK for a predetermined timeout interval twice in a row.

RMM receive file waits for data packets copies the received data packets into a file specified by client and sends an ACK to the RMM . If the ACK doesn t reach RMM RMM receive file may resend the data. Once all data has been received at the host RMM receive file verifies checksum for the file and reports success or failure to the client. If RMM receive file doesn t receive any data packets in two consecutive timeout intervals RMM receive file aborts transaction and waits for a trigger event from client.

The reliable sender component on the RMM in one embodiment is a daemon e.g. named send file which is started during boot up of the RMM . Send file waits for control message from the host . Once send file receives the control message it determines whether the requested file exists and if the requested file exists sends file information back to the host in the CTRL ACK. If the requested file does not exist send file sends an error message to the host in the CTRL ACK. If the requested file exists send file starts sending the file one data packet at a time and waits for ACK. If it does not receive an ACK for a predetermined timeout interval send file resends the data packet. The transaction is aborted if send file does not receive an ACK for a predetermined timeout interval twice in a row.

Once send file receives ACKs for all data packets in the requested file it stops the timer and continues waiting for the next control message. In one embodiment if send file receives a new request from the host while it is sending data packets send file aborts the previous transaction and starts this new transaction.

Referring to the method begins with processing logic receiving a request to update a remote management module such as RMM block . The request may be received at the host or at the RMM . If the request is received at the host the update package is also received at the host responsive to the request block . The host stores the received update package in memory block .

At block the RMM determines which files in the update package are different from the corresponding files associated with the software currently running on the RMM . In one embodiment the host sends to the RMM metadata comprising checksums for the files in the update package. The RMM utilizes this metadata to determine which files in the update package have been changed added or deleted as compared to the current RMM software.

It will be noted that the update package may comprise symbolic links which may also change between different versions of the RMM software. Furthermore some files in the update package may have changed inode information permissions and or ownership. Thus metadata that is used by the RMM to determine which files from the update package should be stored in the RMM s non volatile memory includes information associated with file permissions file ownership other file inode information as well as symbolic link information.

After the RMM determines which files from the update package should be stored in the non volatile memory of the RMM the RMM communicates this information to the host and receives the needed files from the host block . The RMM then stores the received files in its non volatile memory such as the FLASH chip block .

In one embodiment the RMM first copies the current software from the primary partition of the FLASH chip to the backup partition of the FLASH chip . The RMM then may test if the RMM can boot successfully from the newly copied backup partition . If the test is successful the RMM may then update the software stored on the primary partition of the FLASH chip with the files from the update package received from the host . Thus when some but not all files from the update package are determined as changed between the current RMM software version and the updated RMM software version the amount of data that needs to be communicated via the serial link from the host to the RMM may be reduced. Furthermore the amount of data that needs to be burned onto the FLASH chip of the RMM may also be reduced.

Thus a method and apparatus for a method and apparatus for differential file based update for embedded systems have been described. Although the present invention has been described with reference to specific exemplary embodiments it will be recognized that the invention is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense.

Some portions of the foregoing detailed descriptions are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as processing or computing or calculating or determining or displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but is not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions and each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description above. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable medium includes read only memory ROM random access memory RAM magnetic disk storage media optical storage media FLASH memory devices electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc.

Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description it is to be understood that any particular embodiment shown and described by way of illustration is in no way intended to be considered limiting. Therefore references to details of various embodiments are not intended to limit the scope of the claims which in themselves recite only those features regarded as essential to the invention.

