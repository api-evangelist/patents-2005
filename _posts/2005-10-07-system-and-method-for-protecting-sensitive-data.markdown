---

title: System and method for protecting sensitive data
abstract: A method, system and article of manufacture for protecting sensitive data in databases and, more particularly, for managing access to sensitive data in a database. One embodiment comprises receiving a query against the data in the database comprising at least (i) a result field specification, and (ii) a sorting instruction. The method further comprises retrieving a result set from the database, and filtering the retrieved result set on the basis of predefined filtering rules to remove selected data from a selected result field of at least one data record included with the retrieved result set. The filtered result set is sorted according to the sorting instruction to produce the sorted result set, whereby the sorting is done independently of the removed selected data so that the sorted result set places the at least one data record at a position which is non-indicative of a value of the removed selected data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07752215&OS=07752215&RS=07752215
owner: International Business Machines Corporation
number: 07752215
owner_city: Armonk
owner_country: US
publication_date: 20051007
---
This application is related to the following commonly owned applications U.S. patent application Ser. No. 10 083 075 now U.S. Pat. No. 6 996 558 filed Feb. 26 2002 entitled APPLICATION PORTABILITY AND EXTENSIBILITY THROUGH DATABASE SCHEMA AND QUERY ABSTRACTION U.S. patent application Ser. No. 10 284 944 now U.S. Pat. No. 6 928 554 filed Oct. 31 2002 entitled METHOD OF QUERY RETURN DATA ANALYSIS FOR EARLY WARNING INDICATORS OF POSSIBLE SECURITY EXPOSURES and U.S. patent application Ser. No. 10 264 243 filed Oct. 3 2002 entitled INTELLIGENT USE OF USER DATA TO PRE EMPTIVELY PREVENT EXECUTION OF A QUERY VIOLATING ACCESS CONTROLS which are hereby incorporated herein in their entirety.

The present invention generally relates to data processing and more particularly to protecting sensitive data in underlying databases.

Databases are computerized information storage and retrieval systems. A relational database management system is a computer database management system DBMS that uses relational techniques for storing and retrieving data. The most prevalent type of database is the relational database a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways.

Regardless of the particular architecture in a DBMS a requesting entity e.g. an application or the operating system demands access to a specified database by issuing a database access request. Such requests may include for instance simple catalog lookup requests or transactions and combinations of transactions that operate to read change and add specified records in the database. These requests are made using high level query languages such as the Structured Query Language SQL . Illustratively SQL is used to make interactive queries for getting information from and updating a database such as International Business Machines IBM DB2 Microsoft s SQL Server and database products from Oracle Sybase and Computer Associates. The term query denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language that lets programmers and programs select insert update find out the location of data and so forth.

One significant issue in the context of databases is security. Databases often contain confidential or otherwise sensitive data which requires some degree of security to be protected from inappropriate and unauthorized access. For example medical records contained in a medical data warehouse are generally considered highly personal and confidential. As such access to medical records is typically restricted using various security mechanisms.

One of the mechanisms used to restrict access to data is the application of an output formatter. In general an output formatter is a kind of filter that operates to selectively remove data from a result set. For example an output formatter may be configured to remove a particular column from the result set. Alternatively the output formatter may be configured to remove a value from selected cells in the result set.

Regarding the latter configuration there may be several reasons for wanting to remove the values of selected cells from a given result set. For example consider a researcher querying data in a medical data warehouse of a medical institution having sensitive data with respect to patients of the institution. The sensitive data might include HIV test results. While a column level filter could be applied for the HIV Test field this may prevent the researcher from performing his her study. Accordingly a more granular value level filtering technique is required. For example the basis for restriction may be the celebrity status of a given individual. Thus while the researcher may be given access to HIV test results of the non celebrity general public his her access to celebrity test results may be restricted because of the high degree of liability facing the institution should such information inadvertently be leaked. Accordingly for a query that includes HIV Test as a result field a given result set my appear as follows 

Assume that Joe Jane and Alex are non celebrity individuals and that Paula Superstar and Joe Celebrity are well known celebrity figures recognizable by the researcher. Accordingly the output formatter has removed the actual value for the cells in the HIV Test fields for Paula Superstar and Joe Celebrity and replaced it with null values. In the result set above the patients are arranged according to their patient ID. Therefore the researcher can make no conclusion about the actual value of the HIV Tests for Paula Superstar and Joe Celebrity. However if the researcher runs the same query again but adds a command to sort the results based on the HIV Test field and to further sort based on the alphabetical order of the names the arrangement of the results may be as follows 

Now the researcher can conclude that the HIV test value for Joe Celebrity is positive and that the HIV test value for Paula Superstar is negative. This conclusion is based on the observation that Paula Superstar s record occurs before Alex s record and that Joe Celebrity s record occurs after Alex s record and Alex s HIV test value is positive.

Therefore there is a need for improved security mechanisms for protecting sensitive data from inappropriate and unauthorized access.

The present invention generally is directed to a method system and article of manufacture for protecting sensitive data in databases and more particularly for restricting access to sensitive data in an underlying database.

One embodiment provides a computer implemented method of managing access to sensitive data in a database. The method comprises receiving a query against the data in the database. The query comprises at least i a result field specification including one or more result fields characterizing which fields are to be returned in a result set for the query and ii a sorting instruction to sort the result set on the basis of a selected result field to produce a sorted result set. The method further comprises retrieving the result set from the database and filtering the retrieved result set on the basis of predefined filtering rules to remove selected data from the selected result field of at least one data record included with the retrieved result set. The filtered result set is sorted according to the sorting instruction to produce the sorted result set whereby the sorting is done independently of the removed selected data so that the sorted result set places the at least one data record at a position which is non indicative of a value of the removed selected data.

Another embodiment provides a computer readable medium containing a program which when executed by a processor performs operations for managing access to sensitive data in a database. The operations comprise receiving a query against the data in the database. The query comprises at least i a result field specification including one or more result fields characterizing which fields are to be returned in a result set for the query and ii a sorting instruction to sort the result set on the basis of a selected result field to produce a sorted result set. The operations further comprise retrieving the result set from the database and filtering the retrieved result set on the basis of predefined filtering rules to remove selected data from the selected result field of at least one data record included with the retrieved result set. The filtered result set is sorted according to the sorting instruction to produce the sorted result set whereby the sorting is done independently of the removed selected data so that the sorted result set places the at least one data record at a position which is non indicative of a value of the removed selected data.

The present invention is generally directed to a method system and article of manufacture for protecting sensitive data in databases and more particularly for restricting access to sensitive data in an underlying database which is accessed using a query. In general a query is issued by a requesting entity such as a user against an underlying database and includes a result field specification having at least one result field. The at least one result field characterizes the data that is to be returned in a result set for the query after execution of the query against the database. If the database contains sensitive data which is accessed by the query the result set may include some or all of the sensitive data. If the result set includes some or all of the sensitive data the sensitive data is protected by filtering the result set on the basis of predefined filtering rules to remove the sensitive data from the result set.

In one embodiment the query includes a sorting instruction to sort the result set on the basis of a selected result field to produce a sorted result set. If the result set has been filtered the filtered result set is sorted on the basis of the sorting instruction. However as explained above the filtered result set may still reveal information about the sensitive data which has been removed from the result set. More specifically the information can be revealed because of a sorted position of one or more corresponding data records from which the sensitive data has been removed in the sorted result set. Therefore in order to make this information unavailable in the sorted result set the filtered result set is sorted according to the sorting instruction independently of the removed sensitive data. In the context of the invention sorting the filtered result set independently of the removed sensitive data means that the one or more corresponding data records are placed at a position in the sorted result set which is non indicative of a value of the removed sensitive data. Accordingly the sorted position of the one or more data records from which the sensitive data has been removed cannot reveal any information about the sensitive data.

In the following reference is made to embodiments of the invention. However it should be understood that the invention is not limited to specific described embodiments. Instead any combination of the following features and elements whether related to different embodiments or not is contemplated to implement and practice the invention. Furthermore in various embodiments the invention provides numerous advantages over the prior art. However although embodiments of the invention may achieve advantages over other possible solutions and or over the prior art whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus the following aspects features embodiments and advantages are merely illustrative and unless explicitly present are not considered elements or limitations of the appended claims.

One embodiment of the invention is implemented as a program product for use with a computer system such as for example computer system shown in and described below. The program s of the program product defines functions of the embodiments including the methods described herein and can be contained on a variety of computer readable media. Illustrative computer readable media include but are not limited to i information permanently stored on non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive ii alterable information stored on writable storage media e.g. floppy disks within a diskette drive or hard disk drive or iii information conveyed to a computer by a communications medium such as through a computer or telephone network including wireless communications. The latter embodiment specifically includes information to from the Internet and other networks. Such computer readable media when carrying computer readable instructions that direct the functions of the present invention represent embodiments of the present invention.

In general the routines executed to implement the embodiments of the invention may be part of an operating system or a specific application component program module object or sequence of instructions. The software of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine readable format and hence executable instructions. Also programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular nomenclature that follows is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

In any case it is understood that is merely one configuration for a computer system. Embodiments of the invention can apply to any comparable configuration regardless of whether the computer is a complicated multi user apparatus a single user workstation or a network appliance that does not have non volatile storage of its own.

The computer could include a number of operators and peripheral systems as shown for example by a mass storage interface operably connected to a storage device by a video interface operably connected to a display and by a network interface operably connected to the plurality of networked devices which may be representative of the Internet via a suitable network. Although storage is shown as a single unit it could be any combination of fixed and or removable storage devices such as fixed disc drives floppy disc drives tape drives removable memory cards or optical storage. The display may be any video output device for outputting viewable information.

Computer is shown comprising at least one processor which obtains instructions and data via a bus from a main memory . The processor could be any processor adapted to support the methods of the invention. In particular the computer processor is selected to support the features of the present invention. Illustratively the processor is a PowerPC processor available from International Business Machines Corporation of Armonk N.Y.

The main memory is any memory sufficiently large to hold the necessary programs and data structures. Main memory could be one or a combination of memory devices including Random Access Memory nonvolatile or backup memory e.g. programmable or Flash memories read only memories etc. . In addition memory may be considered to include memory physically located elsewhere in the computer system for example any storage capacity used as virtual memory or stored on a mass storage device e.g. direct access storage device or on another computer coupled to the computer via bus . Thus main memory and storage device could be part of one virtual address space spanning multiple primary and secondary storage devices.

Referring now to a relational view of software components in one embodiment is illustrated. The software components illustratively include a user interface a database one or more applications only one application is illustrated for simplicity a query execution unit and an abstract model interface .

According to one aspect the application and more generally any requesting entity including at the highest level users issues queries against data in the database . In general the queries issued by the application are defined according to an application query specification and may be predefined i.e. hard coded as part of the application or generated in response to input e.g. user input . The application query specification s is further described below with reference to .

Illustratively the queries issued by the application are created by users using the user interface which can be any suitable user interface configured to create submit queries. According to one aspect the user interface is a graphical user interface. However it should be noted that the user interface is only shown by way of example any suitable requesting entity may create and submit queries against the database e.g. the application an operating system or an end user . Accordingly all such implementations are broadly contemplated.

In one embodiment the requesting entity accesses a suitable database connectivity tool such as a Web application an Open DataBase Connectivity ODBC driver a Java DataBase Connectivity JDBC driver or a Java Application Programming Interface Java API for creation of a query. A Web application is an application that is accessible by a Web browser and that provides some function beyond static display of information for instance by allowing the requesting entity to query the database . An ODBC driver is a driver that provides a set of standard application programming interfaces to perform database functions such as connecting to the database performing dynamic SQL functions and committing or rolling back database transactions. A JDBC driver is a program included with a database management system to support JDBC standard access between the database and Java applications. A Java API is a Java based interface that allows an application program e.g. the requesting entity the ODBC or the JDBC that is written in a high level language to use specific data or functions of an operating system or another program e.g. the application .

Accordingly the queries issued by the application can be in physical form such as SQL and or XML queries which are consistent with the physical representation of the data for execution against the database . Alternatively the queries issued by the application are composed using the abstract model interface . Such queries are referred to herein as abstract queries . The abstract model interface is further described below with reference to . The abstract queries are transformed into a form consistent with the physical representation of the data for execution against the database . In the illustrated example an abstract query is created on the basis of logical fields defined by a data abstraction model . By way of example the abstract query is translated by a runtime component into a concrete i.e. executable query which is executed against the data of the database to determine a result set for the abstract query . Illustratively the abstract query includes a sorting instruction configured to sort the result set on the basis of a selected result field included therewith.

The database is shown as a single database having the data for simplicity. However a given query can be executed against multiple databases which can be distributed relative to one another. Moreover one or more databases can be distributed to one or more networked devices e.g. networked devices of . The database is representative of any collection of data regardless of the particular physical representation of the data. A physical representation of data defines an organizational schema of the data. By way of illustration the database may be organized according to a relational schema accessible by SQL queries or according to an XML schema accessible by XML queries . However the invention is not limited to a particular schema and contemplates extension to schemas presently unknown. As used herein the term schema generically refers to a particular arrangement of the data .

In one embodiment the data in the database includes sensitive data which requires some degree of security to be protected from inappropriate and unauthorized access. For example the sensitive data may consist of medical records which are considered highly personal and confidential. In order to protect the sensitive data a suitable processing of the abstract query and the result set is performed by the query execution unit . The processing of the abstract query can be performed prior to translation of the abstract query into a concrete query. Alternatively the concrete query can be processed prior to execution against the database i.e. prior to determining the result set . The result set is processed prior to output thereof to the requesting entity.

In one embodiment the abstract query is rewritten by a query rewriter in order to remove the sorting instruction therefrom. Thereby a rewritten query is generated. The rewritten query is executed by a query engine against the data in the database to obtain the result set . The result set is then processed by the output formatter .

The output formatter determines whether the result set contains some or all of the sensitive data . It should be noted that any suitable technique for determining whether the result set contains some or all of the sensitive data is broadly contemplated. Furthermore it should be noted that the output formatter is only described by way of example and that any data processor which is configured for a suitable post query data processing is broadly contemplated. If the result set includes at least a portion of the sensitive data the output formatter performs suitable operations to protect the at least one portion of the sensitive data as described below.

In one embodiment the result set is filtered by a result set filter having predefined filtering rules to remove the at least one portion of the sensitive data from the result set . By way of example the predefined filtering rules are configured to remove values of corresponding cells from one or more selected data records having the at least one portion of the sensitive data from the result set . Accordingly by filtering the result set a temporary result is generated.

The temporary result is stored in the database and sorted according to the sorting instruction independently of the removed sensitive data whereby a sorted result set is generated. According to one embodiment the sorting is done by the output formatter although the sorting may be done by a different component. More specifically the one or more selected data records are placed at a position in the sorted result set which is non indicative of a value of the removed sensitive data in the corresponding cells. Accordingly the position of the one or more selected data records in the sorted result set cannot reveal any information about the removed sensitive data whereby the removed sensitive data is protected. The sorted result set is then output to the application .

It should be noted that the query execution unit is illustrated having the output formatter and the query engine . Furthermore the query rewriter the result set filter and the temporary result are illustratively shown as part of the output formatter . However it should be noted that the output formatter is merely described by way of example to illustrate a component which is suitable to implement aspects of the invention. The output formatter should not be understood as an essential component of the invention and the functions of the output formatter can be implemented by any suitable data processor appropriately configured. Furthermore other implementations which are suitable to perform methods of the present invention are also possible. For instance in one embodiment the query rewriter is implemented as a separate software component included with the query execution unit . In another embodiment the temporary result is stored in the database . All such implementations are broadly contemplated.

Interaction and operation of the query execution unit for processing of the abstract query and the result set is described in more detail below with reference to . Operation of the abstract model interface for creation of abstract queries and transformation of abstract queries into concrete queries and execution of the concrete queries is described below with reference to .

As was noted above the logical fields specified by the application query specification and used to compose the abstract query are defined by the data abstraction model . In general the data abstraction model exposes information as a set of logical fields that may be used within a query e.g. the abstract query issued by the application to specify criteria for data selection and specify the form of result data returned from a query operation. The logical fields are defined independently of the underlying data representation being used in a corresponding database e.g. database of thereby allowing queries to be formed that are loosely coupled to the underlying data representation.

In one embodiment illustrated in the data abstraction model comprises a plurality of field specifications and five shown by way of example collectively referred to as the field specifications also referred to hereinafter as field definitions . Specifically a field specification is provided for each logical field available for composition of an abstract query. Each field specification may contain one or more attributes. Illustratively the field specifications include a logical field name attribute collectively field name and an associated access method attribute collectively access methods . Each attribute may have a value. For example logical field name attribute has the value Patient ID and access method attribute has the value Simple . Furthermore each attribute may include one or more associated abstract properties. Each abstract property describes a characteristic of a data structure and has an associated value. In the context of the invention a data structure refers to a part of the underlying physical representation that is defined by one or more physical entities of the data corresponding to the logical field. In particular an abstract property may represent data location metadata abstractly describing a location of a physical data entity corresponding to the data structure like a name of a database table or a name of a column in a database table. Illustratively the access method attribute includes data location metadata Table and Column . Furthermore data location metadata Table has the value HIV Tests and data location metadata Column has the value PID . Accordingly assuming an underlying relational database schema in the present example the values of data location metadata Table and Column point to a table HIV Tests having a column PID .

In one embodiment groups i.e. two or more of logical fields may be part of categories. Accordingly the data abstraction model includes a plurality of category specifications and two shown by way of example collectively referred to as the category specifications. In one embodiment a category specification is provided for each logical grouping of two or more logical fields. For example logical fields and are part of the category specifications and respectively. A category specification is also referred to herein simply as a category . The categories are distinguished according to a category name e.g. category names and collectively category name s . In the present illustration the logical fields are part of the Name and Address category and logical fields are part of the Birth and Age category.

The access methods generally associate i.e. map the logical field names to data in the database e.g. database of . As illustrated in the access methods associate the logical field names to a particular physical data representation . . . in the database. By way of illustration two data representations are shown an XML data representation and a relational data representation . However the physical data representation indicates that any other data representation known or unknown is contemplated. In one embodiment a single data abstraction model contains field specifications with associated access methods for two or more physical data representations . In an alternative embodiment a different single data abstraction model is provided for each separate physical data representation .

Any number of access methods is contemplated depending upon the number of different types of logical fields to be supported. In one embodiment access methods for simple fields filtered fields and composed fields are provided. The field specifications and exemplify simple field access methods and respectively. Simple fields are mapped directly to a particular entity in the underlying physical representation e.g. a field mapped to a given database table and column . By way of illustration as described above the simple field access method shown in maps the logical field name Patient ID to a column named PID in a table named HIV Tests . The field specification exemplifies a filtered field access method . Filtered fields identify an associated physical entity and provide filters used to define a particular subset of items within the physical representation. An example is provided in in which the filtered field access method maps the logical field name AnyTownLastName to a physical entity in a column named Name in a table named HIV Tests and defines a filter for individuals in the city of Anytown . Another example of a filtered field is a New York ZIP code field that maps to the physical representation of ZIP codes and restricts the data only to those ZIP codes defined for the state of New York. The field specification exemplifies a composed field access method . Composed access methods compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way information which does not exist in the underlying physical data representation may be computed. In the example illustrated in the composed field access method maps the logical field name AgeInDecades to AgeInYears 10 . Another example is a sales tax field that is composed by multiplying a sales price field by a sales tax rate.

It is contemplated that the formats for any given data type e.g. dates decimal numbers etc. of the underlying data may vary. Accordingly in one embodiment the field specifications include a type attribute which reflects the format of the underlying data. However in another embodiment the data format of the field specifications is different from the associated underlying physical data in which case a conversion of the underlying physical data into the format of the logical field is required.

By way of example the field specifications of the data abstraction model shown in are representative of logical fields mapped to data represented in the relational data representation shown in . However other instances of the data abstraction model map logical fields to other physical representations such as XML.

An illustrative abstract query corresponding to the abstract query shown in is shown in Table I below. By way of illustration the illustrative abstract query is defined using XML. However any other language may be used to advantage.

Illustratively the abstract query shown in Table I includes a selection specification lines containing selection criteria and a results specification lines . In one embodiment a selection criterion consists of a field name for a logical field a comparison operator 

An illustrative data abstraction model DAM corresponding to the data abstraction model shown in is shown in Table II below. By way of illustration the illustrative Data Abstraction Model is defined using XML. However any other language may be used to advantage.

By way of example note that lines correspond to the first field specification of the DAM shown in and lines correspond to the second field specification .

As was noted above the abstract query of Table I can be transformed into a concrete query for query execution. An exemplary method for transforming an abstract query into a concrete query is described below with reference to .

Referring now to an illustrative runtime method exemplifying one embodiment of the operation of the runtime component of is shown. The method is entered at step when the runtime component receives as input an abstract query such as the abstract query shown in Table I . At step the runtime component reads and parses the abstract query and locates individual selection criteria and desired result fields. At step the runtime component enters a loop defined by steps and for processing each query selection criteria statement present in the abstract query thereby building a data selection portion of a concrete query. In one embodiment a selection criterion consists of a field name for a logical field a comparison operator 

After building the data selection portion of the concrete query the runtime component identifies the information to be returned as a result of query execution. As described above in one embodiment the abstract query defines a list of result fields i.e. a list of logical fields that are to be returned as a result of query execution referred to herein as a result specification. A result specification in the abstract query may consist of a field name and formatting options such as sorting criteria. Accordingly the method enters a loop at step defined by steps and to add result field definitions to the concrete query being generated. At step the runtime component looks up a result field name from the result specification of the abstract query in the data abstraction model and then retrieves a result field definition from the data abstraction model to identify the physical location of data to be returned for the current logical result field. The runtime component then builds at step a concrete query contribution of the concrete query that identifies physical location of data to be returned for the logical result field. At step the concrete query contribution is then added to the concrete query statement. Once each of the result specifications in the abstract query has been processed the concrete query is executed at step .

One embodiment of a method for building a concrete query contribution for a logical field according to steps and is described with reference to . At step the method queries whether the access method associated with the current logical field is a simple access method. If so the concrete query contribution is built step based on physical data location information and processing then continues according to method described above. Otherwise processing continues to step to query whether the access method associated with the current logical field is a filtered access method. If so the concrete query contribution is built step based on physical data location information for a given data structure s . At step the concrete query contribution is extended with additional logic filter selection used to subset data associated with the given data structure s . Processing then continues according to method described above.

If the access method is not a filtered access method processing proceeds from step to step where the method queries whether the access method is a composed access method. If the access method is a composed access method the physical data location for each sub field reference in the composed field expression is located and retrieved at step . At step the physical field location information of the composed field expression is substituted for the logical field references of the composed field expression whereby the concrete query contribution is generated. Processing then continues according to method described above.

If the access method is not a composed access method processing proceeds from step to step . Step is representative of any other access method types contemplated as embodiments of the present invention. However it should be understood that embodiments are contemplated in which less than all the available access methods are implemented. For example in a particular embodiment only simple access methods are used. In another embodiment only simple access methods and filtered access methods are used.

Referring now to one embodiment of a method for managing execution of a query against data in a database e.g. data of database of in order to protect sensitive data e.g. sensitive data of in the database is illustrated. In one embodiment at least part of the steps of the method are performed by the query execution unit of . Furthermore at least several steps of the method can be performed on the basis of user input received via the user interface of . Method starts at step .

At step a query is received from a requesting entity e.g. application of or a user . By way of example the following steps of the method are described with reference to an abstract query e.g. abstract query of . However it should be noted that the invention is not limited to abstract queries and that any other query types are broadly contemplated.

Assume now that the query is created by a user using the user interface of and issued against a database having a table HIV Tests defining the data of . An exemplary HIV Tests table is shown in Table III below.

As can be seen from Table III the HIV Tests table illustratively contains name age gender and HIV test result information about each patient. The HIV tests table further includes a PID column having values that uniquely identify each patient. Assume now that the HIV test results of Paula Superstar line and Joe Celebrity line represent sensitive data which requires some degree of security to be protected from inappropriate and unauthorized access.

Assume further that the abstract query illustrated in Table IV below is issued by the user against the HIV Tests table of Table III. For simplicity the exemplary abstract query of Table IV is illustrated in natural language. Persons skilled in the art will readily recognize corresponding XML representations such as used to describe the exemplary abstract query of Table I. However it should be noted that implementation of the exemplary abstract query is not limited to a particular machine readable language and that an implementation in any machine readable language known or unknown is broadly contemplated.

It should be noted that the abstract query of Table IV is configured to identify from the HIV Tests table of Table III a list of patients which are older than 40 years AgeInYears 40 in line . The patients should be identified in a corresponding result set by their associated patient identifiers and names Patient ID and Name in line . Furthermore for each patient a corresponding HIV test result HIV Test in line is requested. The Patient ID Name and HIV Test fields define result fields and the AgelnYears field defines a condition field of the abstract query all of which relate to corresponding logical fields in an underlying data abstraction model e.g. data abstraction model of . By way of example the result field Patient ID line of Table IV relates to the Patient ID field in line of the exemplary data abstraction model of Table II. Furthermore it should be noted that a corresponding result set obtained in response to execution of the exemplary query of Table IV should be sorted on the basis of values that are retrieved for the HIV Test result field lines .

At step it is determined whether the abstract query includes a sorting instruction e.g. sorting instruction of . If the abstract query includes a sorting instruction the method proceeds at step . Otherwise the method proceeds at step .

At step it is determined whether the sorting instruction is applied to a result field which has sensitive data. By way of example it is determined whether the logical field which corresponds to the result field of the sorting instruction has a sensitivity flag. However it should be noted that any suitable technique for determining whether the sorting instruction is applied to a result field having sensitive data is broadly contemplated. If the sorting instruction is applied to a result field having sensitive data the method proceeds at step . Otherwise the method proceeds at step .

At step suitable operations are performed to protect the sensitive data in the database. Method then exits at step .

At step the received abstract query is executed against the underlying database whereby a corresponding result set is generated. The corresponding result set is output to the user at step . Method then exits at step .

However it should be noted that the corresponding result set obtained at step can be analyzed prior to step in order to determine whether sensitive data is included therewith. If so the result set can be filtered prior to step in order to protect the sensitive data e.g. by removing the sensitive data from the corresponding result set prior to outputting the result set to the user.

Referring now to an exemplary method of processing an abstract query e.g. abstract query of having a sorting instruction e.g. sorting instruction of and a corresponding result set is illustrated. In one embodiment method is performed to protect sensitive data e.g. sensitive data of in an underlying database e.g. database of . According to one aspect method is entered from step of . At least a portion of the steps of method is performed using the query execution unit of .

Method starts at step where the abstract query is rewritten to remove the sorting instruction therefrom. Accordingly a rewritten query e.g. rewritten query of without sorting instruction is obtained. An exemplary rewritten query which is obtained from the exemplary abstract query of Table IV is illustrated in Table V below.

It should be noted that the exemplary rewritten query of Table V corresponds to the exemplary abstract query of Table IV from which the sorting instruction lines of Table IV vas been removed.

At step the rewritten query is executed against the underlying database to obtain an initial result set e.g. result set of . In the given example the exemplary rewritten query of Table V is executed against the exemplary HIV Tests table of Table III. Thereby the initial result set illustrated in Table VI below is obtained. The exemplary initial result set is ordered in descending order of the patient identifiers.

As can be seen from line of Table VI the initial result set includes the value Negative for the HIV test result of Paula Superstar . Furthermore according to line of Table VI the initial result set includes the value Positive for the HIV test result of Joe Celebrity . As was noted above the HIV test results of Paula Superstar and Joe Celebrity represent sensitive data.

To protect the sensitive data included with lines and of Table VI the initial result set is filtered at step on the basis of predefined filtering rules. In one embodiment the predefined filtering rules are configured to remove the sensitive data from the initial result set. Removing the sensitive data from the initial result set includes identifying each data record from the initial result set which has sensitive data and replacing each sensitive data value with a null value. Accordingly the filtered result set illustrated in Table VII below is obtained.

As can be seen from lines and of Table VII the data records associated with the patient identifiers 2 and 9 have been identified as data records having sensitive data in the HIV Test field. Accordingly the actual values for the HIV test results of Paula Superstar and Joe Celebrity in lines and have been replaced with the value null .

At step the filtered result set is joined to the initial result set. Accordingly the joined result set illustrated in Table VIII below is obtained.

As can be seen from Table VIII the fields of the filtered result set have been added to the initial result set by changing the field names so that each field has a unique field name in the joined result set. More specifically the name of the Patient ID field of the filtered result set has been changed to Patient ID2 the name of the Name field has been changed to Name2 and the name of the HIV Test field has been changed to HIV Test2 .

At step the joined result set is sorted according to the sorting instruction which instructs to sort the result set on the basis of the HIV test field lines of Table IV . However after the sorting the data records having the filtered sensitive data i.e. the data records in lines and of Table VIII should be placed at a position which is non indicative of the values of the removed sensitive data. Accordingly in one embodiment the sorting is performed on the filtered HIV Test field i.e. the HIV Test2 field. To this end the sorting instruction is rewritten as shown in Table IX below.

Sorting the joined result set according to the rewritten sorting instruction produces a sorted joined result set. In the given example sorting the joined result set of Table VIII according to the rewritten sorting instruction of Table IX produces the sorted joined result set illustrated in Table X below.

As can be seen from Table X the data records in lines having Negative or Positive values in the HIV Test2 field are placed on top of the sorted joined result set. The data records in lines which have a null value in the HIV Test2 field are placed at the bottom of the sorted joined result set. The order of the data records at the top and the bottom of the sorted joined result field is respectively determined in descending order of the patient identifiers for simplicity.

However it should be noted that alternative implementations for steps and are possible. For instance instead of joining the initial result set and the filtered result set to the joined result set and sorting the joined result set according to the rewritten sorting instruction the filtered result set can be sorted according to the initial sorting instruction. All such implementations are broadly contemplated.

At step a sorted filtered result set e.g. sorted result set of is generated and subsequently output to the user. In one embodiment the sorted filtered result set is determined by selecting only the result fields of the sorted joined result set which belong to the filtered result set. In another embodiment all result fields which belong to the initial result set are selected from the sorted joined result set and refiltered according to step to determine the sorted filtered result set. Processing then continues at step of method .

In the given example the sorted filtered result set illustrated in Table XI below is obtained and output to the user.

As can be seen from Table XI the sorted position of the data records of Paula Superstar and Joe Celebrity in lines and does not allow any conclusion about their actual HIV test result value.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

