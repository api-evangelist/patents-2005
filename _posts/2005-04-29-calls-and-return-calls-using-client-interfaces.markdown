---

title: Calls and return calls using client interfaces
abstract: A method and system for executing calls and return calls using client interfaces for packages. In one embodiment, a service at a service package is called using a client interface at a client package. The return call is then made on object using the client interface at the client package as performed by the service at the service package.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07587705&OS=07587705&RS=07587705
owner: SAP (AG)
number: 07587705
owner_city: Walldorf
owner_country: DE
publication_date: 20050429
---
Embodiments of the invention generally relate to the field of data processing systems and more particularly to a system and method for executing calls and return calls using client interfaces for packages.

As application development projects grow larger packages are becoming both increasingly important and cumbersome. For example when changes are made to currently existing Advanced Business Application Programming ABAP software the implication of such changes are difficult to foresee which often causes problems in the future. Having an improved package can make the software s blueprint visible which can make the changes to the software foreseeable and better protected against malicious changes.

The package is viewed as a capsule whose content is hidden to the outside. Any interaction with the package s content is accomplished through the development objects that are exposed via an interface of the respective package . Furthermore the package determines transport properties of development object contained in it such as whether the object can be exported from the system or whether it can be exported and what are the target systems using the assignment to a transport layer .

Referring now to it illustrates nesting of multiple packages . As illustrated a package e.g. subpackage is nested into another package e.g. superpackage . When nesting the subpackage is visible only within its superpackage . This package nesting for example allows for structuring of packages by placing the development objects needed only for a certain part of the implementation into a separate subpackage . The superpackage not only exposes its own development objects via its interface but also exposes the objects of its subpackage through the subpackage s interface and its own interface . Those development objects of the subpackage that are not exposed at the superpackage s interface are invisible outside the superpackage and can only be used from within the superpackage .

Although the conventional package mechanism provides increasing flexibility for better structuring of software and represents an essential tool for ensuring and tracking decoupling of software further improvements to the existing package mechanism are needed. For example the conventional package mechanism lacks new strategies with regard to handling generation of objects interfacing and enhancements to software. These limitations are further exasperated when different interfaces modules components and or services are used across the development project.

A method and system for executing calls and return calls using client interfaces for packages. In one embodiment a service at a service package is called using a client interface at a client package. The return call is then made on object using the client interface at the client package as performed by the service at the service package.

Described below is a system and method for executing calls and return calls using client interfaces for packages. Throughout the description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.

In the following description numerous specific details such as logic implementations opcodes resource partitioning resource sharing and resource duplication implementations types and interrelationships of system components and logic partitioning integration choices may be set forth in order to provide a more thorough understanding of various embodiments of the present invention. It will be appreciated however to one skilled in the art that the embodiments of the present invention may be practiced without such specific details based on the disclosure provided. In other instances control structures gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate functionality without undue experimentation.

Various embodiments of the present invention will be described below. The various embodiments may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor or a machine or logic circuits programmed with the instructions to perform the various embodiments. Alternatively the various embodiments may be performed by a combination of hardware and software.

Various embodiments of the present invention may be provided as a computer program product which may include a machine readable medium having stored thereon instructions which may be used to program a computer or other electronic devices to perform a process according to various embodiments of the present invention. The machine readable medium may include but is not limited to floppy diskette optical disk compact disk read only memory CD ROM Digital Video Disk ROM DVD ROM magneto optical disk read only memory ROM random access memory RAM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM magnetic or optical card flash memory or another type of media machine readable medium suitable for storing electronic instructions. Moreover various embodiments of the present invention may also be downloaded as a computer program product wherein the program may be transferred from a remote computer to a requesting computer by way of data signals embodied in a carrier wave or other propagation medium via a communication link e.g. a modem or network connection .

Frequently the subroutine does not see the third program or no appropriate usage permission exits. To avoid recurring terminations the subroutine also known as the package element is assigned the check scope attribute. This switch has three settings such as 1 static and dynamic usage e.g. calls is checked 2 static usage is checked while dynamic is not and 3 static and dynamic usage is not checked. Other exceptions are system and special programs. These programs use a large number of development objects from various packages without appropriate visibilities or usage permissions being available. A practical example is the translation tool. The tool dynamically reads text and documentation in the original language from various tables e.g. for data elements messages and screens and dynamically inserts these texts into the table in the target language.

In the illustrated embodiment using the dependency control list package P allows the use of interface V at package P . Also using the dependency control list at package P the function module F can be called . Package P may also have a dependency control list which inherits the dependency control list at package P i.e. the dependency control list implicitly having the same entries as those of the dependency control list without adding its own . The dependency log of package P is updated whenever the program e.g. reports classes etc. that contains the call function statement to invoke function module F is inserted back into the running system after having been modified.

A dependency control list represents a list of external visible interfaces. Further objects contained in the interfaces listed in these dependency control lists can be used by objects of the superpackage and its subpackages . A dependency control list may be represented through an inclusion list and an exclusion list where both of these lists external visible interfaces and external visible interface lists can be included. The entries in both lists may depend on the following 1 to the content of the reference package without a subpackage 2 to the content of the reference package and the subpackage and to the content of the subpackage without the content of the reference package . For example a package may allow a specific subpackage to access a specific interface etc. which means the dependency control list allows not only to specify which interfaces can be used but also who can use them. It is however contemplated that more than two packages may be employed which could lead to several additional possible combinations than the three list here.

The dependency control lists are used in controlling access to certain interfaces. For example 1 in a relevant inclusion list there may not be an entry valid for the client package such as package P available for the respective interfaces in which case the use of the interfaces by the client package may not occur 2 in a relevant exclusion list a valid active entry for the client package may exist for the respective interfaces in which case the use of the interface may not occur and 3 in a relevant exclusion list a valid non active entry for the client package exists for the respective interface which allows the use of the interfaces . In one embodiment the use of the interface is defined by the dependency control lists and allowed within the framework of the limitations as set forth in the dependency control lists . For clarification the term non active entries refers to entries serving for backward compatibility and migration of existing coding such as expressing non approval of a particular interface anymore but that the uses of that interface have not yet been removed from the coding. In other words it is documented that the use is deprecated but the affected coding continues to work. The term active entries refers to real exclusion entries.

In other words the package including a superpackage not shown through its dependency control lists do not have the control function to determine for which services the client interface is to be created. Further using this technique editors are prevented from having to be included in the dependency lists such as the editors that are used for processing the respective package content but are not used directly from the service package . Conversely the direct use e.g. through calling a function module or a method of an interface that exposes the access object may be subject to control through the respective dependency control lists. In other words the weakening of the normally expected usability of an object in favor of just visibility as prerequisite to set up client interfaces is justified as it is undesirable in the case when a special editor e.g. refactoring tools normal editor with certain special features necessary for a particular development project needs to be used editing a package s content. In this case the edited content does not depend on the editor that is it can be executed even if the editor is not available in the system because making an interface usable by adding an entry to a dependency control list normally implies declaring a dependency which does not exist in this special case however which would not be adequate.

The client interface through a switch can be limited in its effect to the package that defined it. In one embodiment the client interface is valid for a package and through inheritance for each of its subpackages not shown which means the access permissions declared in the client interface are granted not only by the original package but also by its subpackages. For subpackages just those access permissions are inherited that also make sense for the subpackages which means the access permissions related to internal objects of the declaring package would not take effect for the subpackages. However generic permissions e.g. generation editing access to any object of a certain type may take effect. Further the original client interface is linked copied and or propagated where changes on the original client interface immediately take effect on all copies to the subpackages. Those parts of the superpackage s dependency control list are inherited by the subpackage that are valid in the subpackage s context as well.

There are ways in which a subpackage can protect itself against editing. For example having granted access permissions declared in a client interface not only by the original package but also by its subpackages is one way certain subpackages can exclude themselves from being edited. If more objects are to be added to the objects already defined in the superpackage they can re use the content of the client interface of the superpackage by entering a special pseudo entry in the interface. Otherwise the settings of the superpackage are replaced.

In the illustrated embodiment the client package exposes its object using its client interface . The client interface is created using the corresponding access object exposed by the service package . The objects at the service package can access the objects at the client package exposed via the client interface using dynamic techniques. For example a unique access object is assigned to each service that needs to execute return calls to the clients. A client package of the service then creates a client interface at the client package for that access object . Using the client interface the client package can then expose the required objects e.g. FORMs global variables etc. dynamically for this particular service associated with the access object .

In one embodiment any services at the service package that needs to access objects of its clients exposes an access object in a suitable interface e.g. in the interface the use of which necessitates for it to access the client for its clients. One or more packages can be assigned to an access object . These packages contain the implementation of the respective service e.g. implementation packages . An implementation package can be assigned to no more than a single access object .

The client interface consists of a list of objects that are to be exposed for the service concerned and further includes those objects that are exposed via package interfaces. In other words anything that can potentially be exposed through package interfaces can potentially be exposed through client interfaces so the set of objects that can potentially be exposed through client interfaces at least contains those objects that can potentially be exposed packages interfaces. The actual package interfaces however may contain objects that are exposed at any actual client interface and the actual client interface may contain objects that are not exposed at any actual package interface. In the client interface local objects of a program belonging to the client package can also be exposed if they are marked as program external objects however the marking itself does not expose the objects but it simply enables that these objects may be accessed from other programs which includes programs of the same package so that the client interface comes into play in cases when access is necessary across package boundaries. Examples of such objects include global variables local classes and structure types. The client interface is also used to expose the following function modules of a function group classes of the client package and any types from other packages that can be used by the client package . Furthermore the client interface can expose other objects or types of objects from the client package e.g. including dynamically created types of the package if these objects at some point in time are related their original package.

In one embodiment the client interface the access object of the service implemented is exposed. By including the access object into the client interface the service can in turn pass on the usage rights to a second service. For example if service exposes the access object in a client service to service service can also access those objects that were exposed in the client interface to service .

The illustrated client package is regarded as a superpackage having a number of subpackages which include direct subpackages P and P and indirect subpackages P and P . The direct subpackages are regarded as sibling packages to each other as they share the same superpackage . The indirect subpackages are also siblings to each other as they share the same superpackage which makes them indirect as they are indirect subpackages of the superpackage . Each of the subpackages contains its own content .

In one embodiment the client package uses the client interface to expose the access object i.e. referring to the access object . The service that the client desires is then identified. The access object is referred to when naming the client interface . The client interface is used by the client package to expose its content having objects such as program having FORM . However the client interface may not be used for declaring the client s dependency on the service and that the client interface can be setup even when dependency lists forbid it. The client package also uses the dependency declaration to access the service package via the package interface . Using the client interface at the client package various objects can be exposed such as FORMs objects that are generally exposed using a package interface program local DATA and other program local objects. Each client package can have one client interface dedicated for a given service which means one client interface is provided for one service .

To assign the client interface to the service the access object is used to first identify the service and then assign the client interface to that service. To accomplish this a unique access object may be assigned to each service that can be used or is needed to execute return calls to the client package . The client package of the service may then set up the client interface for that access object . At the client interface the client package then exposes the necessary objects e.g. FORMs global variables etc. for this particular service .

In the illustrated embodiment the client package exposes its content object program FORM via the client interface which is set up for the access object exposed by the service package . The service function F which is exposed by the service package at the package interface is then called by the client package . Using dynamic techniques the service can now return call and dynamically access the object exposed via the client interface at the client package .

The service includes a function that the client package can call . The service also includes a quantity of objects called service entry points which are within the service package and are published using the package interface . It is contemplated that some services may include objects of their sold to party such as the ALV calls back the client package if the user has triggered certain actions through the list generated by the ALV. Such implementation actions are provided by the client package . Further those objects that are needed by a service are generally not exposed using normal package interfaces and the service does not know its clients and is not dependent on them. To appropriately check uses of objects belonging to the client package through a service the onus of proof is reversed and the client package expose its objects needed by the service using the client interface . The client interface maybe used in cases 1 in which the service calls back the client package through FORMs function modules or constructors static methods and the like from ABAP Objects classes and 2 in which the service needs the type of a data object that the client package has passed to it through a generically typed parameter. For example the ALV requires the needed type of a table that is provided for output by the client package . Furthermore the non object based return calls or callbacks to objects e.g. FORMs DATA objects etc. may be needed for having compatibility with coding from the pre ABAP Objects era these callback may be registered during installation or customization. The client interface may also be used by the client package to declare its callback targets for various service packages as the client package typically knows both the service package and its callback targets.

A call is executed on the service at processing block . The objects that call the service are not necessarily exposed at the client interface. Just those objects of the service that are called back by the service are to be exposed through the client interface. A return call is executed on the content at the client package by the service at the service package using the client interface at the client package at processing block . At processing block the content at the client package is dynamically accessed by the service at the service package using the client interface at the client package. It is to be noted that executing a return call call back is not a different step from dynamically accessing the content of the client interface. A callback is regarded a special form of dynamically accessing content of the client interface. Dynamically accessing refers to using some objects where it is decided shortly before the actual access which objects are to be used or in which way they are to be used. Referring to in the main program it is known which service FM the program uses so it can be written down during development. This is static access. On function module FM the callback target is not written down because there might be any number of clients that may have different and changing callback targets. The main program passes the actual callback target to the service which makes it known just a short time before the callback actually takes place. Another client that calls the service a short time later sets another target so that the same call function statement in function module FM calls a different function module. This is dynamic access. ABAP is capable of various kinds of dynamic accesses such as it is possible to deal with data structures whose exact type structure e.g. number fields of the structure name of the nth field whether the structure stores a number or some text etc. is known not during development but shortly before accessing the structure.

The architectures and methodologies discussed above may be implemented with various types of computing systems such as an application server that includes a J2EE server that supports Enterprise Java Bean EJB components and EJB containers at the business layer and or Servlets and Java Server Pages JSP at the presentation layer . Of course other embodiments may be implemented in the context of various different software platforms including by way of example Microsoft.NET Windows NT Microsoft Transaction Server MTS ABAP platforms developed by SAP AG and comparable platforms.

The memory can include a shared memory area that is accessible by multiple operating system processes executing at the server . An example of a suitable server to be implemented using the client server system may include J2EE compatible servers such as the Web Application Server developed by SAP AG of Walldorf Germany or the WebSphere Application Server developed by International Business Machines Corp. IBM of Armonk N.Y.

Client systems are used to execute multiple applications or application interfaces. Each instance of an application or an application interface can constitute a user session. Each user session can generate one or more requests to be processed by the server . The requests may include instructions or code to be executed on a runtime system e.g. the VM on the server . A VM is an abstract machine that can include an instruction set a set of registers a stack a heap and a method area like a real machine or processor. A VM essentially acts as an interface between program code and the actual processor or hardware platform on which the program code is to be executed. The program code includes instructions from the VM instruction set that manipulates the resources of the VM .

A hard drive or other storage device may be used by the system for storing information and instructions. The storage device may include a magnetic disk or optical disc and its corresponding drive flash memory or other nonvolatile memory or other memory device. Such elements may be combined together or may be separate components. The system may include a read only memory ROM or other static storage device for storing static information and instructions for the processors through .

A keyboard or other input device may be coupled to the bus for communicating information or command selections to the processors through . The input device may include a keyboard a keypad a touch screen and stylus a voice activated system or other input device or combinations of such devices. The computer may further include a mouse or other cursor control device which may be a mouse a trackball or cursor direction keys to communicate direction information and command selections to the processors and to control cursor movement on a display device. The system may include a computer display device such as a cathode ray tube CRT liquid crystal display LCD or other display technology to display information to a user. In some environments the display device may be a touch screen that is also utilized as at least a part of an input device. In some environments the computer display device may be or may include an auditory device such as a speaker for providing auditory information.

A communication device may also be coupled to the bus . The communication device may include a modem a transceiver a wireless modem or other interface device. The system may be linked to a network or to other device using via an interface which may include links to the Internet a local area network or another environment. The system may comprise a server that connects to multiple devices. In one embodiment the system comprises a Java compatible server that is connected to user devices and to external resources.

While the machine readable medium is illustrated in an exemplary embodiment to be a single medium the term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine of the system and that causes the machine to perform any one or more of the methodologies of the present invention. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic media and carrier wave signals.

An article of manufacture may be used to store program code. An article of manufacture that stores program code may be embodied as but is not limited to one or more memories e.g. one or more flash memories random access memories static dynamic or other optical disks CD ROMs DVD ROMs EPROMs EEPROMs magnetic or optical cards or other type of machine readable media suitable for storing electronic instructions. Program code may also be downloaded from a remote computer e.g. a server to a requesting computer e.g. a client by way of data signals embodied in a propagation medium e.g. via a communication link e.g. a network connection .

Furthermore it is appreciated that a lesser or more equipped computer system than the example described above may be desirable for certain implementations. Therefore the configuration of system may vary from implementation to implementation depending upon numerous factors such as price constraints performance requirements technological improvements and or other circumstances.

It is noted that processes taught by the discussion above can be practiced within various software environments such as for example object oriented and non object oriented programming environments Java based environments such as a J2EE environment or environments defined by other releases of the Java standard or other environments e.g. a .NET environment a Windows NT environment each provided by Microsoft Corporation .

It should be noted that while the embodiments described herein may be performed under the control of a programmed processor such as processors through in alternative embodiments the embodiments may be fully or partially implemented by any programmable or hardcoded logic such as field programmable gate arrays FPGAs TTL logic or application specific integrated circuits ASICs . Additionally the embodiments of the present invention may be performed by any combination of programmed general purpose computer components and or custom hardware components. Therefore nothing disclosed herein should be construed as limiting the various embodiments of the present invention to a particular embodiment wherein the recited embodiments may be performed by a specific combination of hardware components.

It should be appreciated that reference throughout this specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore it is emphasized and should be appreciated that two or more references to an embodiment or one embodiment or an alternative embodiment in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined as suitable in one or more embodiments of the invention.

Similarly it should be appreciated that in the foregoing description of exemplary embodiments of the invention various features of the invention are sometimes grouped together in a single embodiment figure or description thereof for the purpose of streamlining the disclosure aiding in the understanding of one or more of the various inventive aspects. This method of disclosure however is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather as the following claims reflect inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus the claims following the detailed description are hereby expressly incorporated into this detailed description with each claim standing on its own as a separate embodiment of this invention.

While certain exemplary embodiments have been described and shown in the accompanying drawings it is to be understood that such embodiments are merely illustrative of and not restrictive and that the embodiments of the present invention are not to be limited to specific constructions and arrangements shown and described since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure.

