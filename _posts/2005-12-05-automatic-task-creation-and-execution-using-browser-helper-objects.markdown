---

title: Automatic task creation and execution using browser helper objects
abstract: A task system and method are provided. The system provides an automated approach for task creation, maintenance and/or execution. The system includes a browser that receives search results and at least one task associated with a query from a search engine. The system further includes a browser helper object that binds to the browser at runtime. The browser helper object provides information associated with a user's action with respect to the search results and/or at least one task. The information can be employed as feedback to update model(s) (e.g., query classification model(s) and/or slot-filling model(s)) of a semantic reasoning component that retrieves task based, at least in part, upon user query(ies).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07933914&OS=07933914&RS=07933914
owner: Microsoft Corporation
number: 07933914
owner_city: Redmond
owner_country: US
publication_date: 20051205
---
This application is related to co pending U.S. patent application Ser. No. 11 270 407 filed Nov. 9 2005 and entitled ADAPTIVE TASK FRAMEWORK co pending U.S. patent application Ser. No. 11 270 393 filed Nov. 9 2005 and entitled ADAPTIVE TASK FRAMEWORK and co pending U.S. patent application Ser. No. 11 290 076 filed Nov. 30 2005 and entitled ADAPTIVE SEMANTIC REASONING ENGINE . The entirety of the aforementioned applications is hereby incorporated by reference.

Human languages are rich and complicated including huge vocabularies with complex grammar and contextual meaning. Machine interpretation of human language even in a very limited way is an extremely complex task and continues to be the subject of extensive research. Providing users with the ability to communicate their desires to an automated system without requiring users to learn a machine specific language or grammar would decrease learning costs and greatly improve system usability. However users become quickly frustrated when automated systems and machines are unable to interpret user input correctly resulting in unexpected results.

Natural language input can be useful for a wide variety of applications including virtually every software application with which humans are intended to interact. Typically during natural language processing the natural language input is separated into tokens and mapped to one or more actions provided by the software application. Each application can have a unique set of actions. Consequently it can be both time consuming and repetitive for software developers to draft code to interpret natural language input and map the input to the appropriate action for each application.

The Internet in particular has provided users with a mechanism for obtaining information regarding any suitable subject matter. For example various websites are dedicated to posting text images and video relating to world national and or local news. A user with knowledge of a Uniform Resource Locator URL associated with one of such websites can simply enter the URL into a web browser to be provided with the website and access content thereon. Another conventional manner of locating desired information from the Internet is through utilization of a search engine. For instance a user can enter a word or series of words into a search field and thereafter initiate the search engine e.g. through depression of a button one or more keystrokes voice commands . . . . The search engine then utilizes search algorithms to locate websites related to the word or series of words entered by the user into the search field and the user can then select one of the websites returned by the search engine to review content therein.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

A task system and method are provided. Task s are useful in modeling actions user s perform for example on the web. Examples of tasks include buying plane tickets purchasing books reserving cars buying stocks checking accounts or checking the weather in a particular city. Task s can be executed on a variety of websites and individual user s can have individual preferences as to which site best matches their needs.

The system provides an automated approach for task creation maintenance and or execution. Furthermore by distributing the processes of task creation maintenance and or execution to end user s the entire task system can improve without the guidance of a central authority.

The system includes a browser that receives search results and task s associated with a query from a search engine. The system further includes a browser helper object that binds to the browser at runtime. The browser helper object provides information e.g. to the search engine associated with a user s action with respect to the search results and or at least one task.

The system automatically generates and or executes task s using Browser Helper Object s BHOs . BHOs are objects that bind to the browser at runtime and behave as if they were part of the browser. The web browser is an application program that is capable of displaying a web page e.g. Internet Explorer .

Thus the BHO is a piece of code that effectively becomes part of the browser through the extensibility of the browser. BHOs are capable of accessing an object model corresponding to a schema of the source code e.g. HTML that is created when a web page is loaded. Additionally BHOs can insert value s into form s e.g. HTML form s . BHOs are further capable of communicating with other component s .

In one example the browser and the browser helper object s communicate directly with a semantic reasoning component. In another example the browser and or browser helper object s communicate with a search engine that in turn communicates with the semantic reasoning component. In a client server environment the semantic reasoning component can be a component of a task server. In a distributed processing environment at least a portion of the semantic reasoning component can be resident on a user s computer system.

When a website is loaded the BHO can walk an object model representation of the source code e.g. HTML and determine for example that there are INPUT box es for item s such as Going to and Leaving from fields and or that there are SELECT box e s for the time of day containing elements such as Morning Noon Evening and Anytime . The BHO can insert a value into one or more of the input selection box es .

The BHO can communicate with the search engine to facilitate various function s . For example based on information received from the BHO the search engine can log an original query entered to the browser. The search engine can further log website s within a time window that the user has visited and entered information contained in the original query.

The BHO can receive a uniform resource locator URL containing semantic information and fill in value s on a form associated with the URL. For example the query flight from Boston to Seattle can return a link to a website with some parameters such as tcy Boston and fcy Seattle. The BHO can interpret this information and fill in information value s based at least in part upon the original query. The BHO can further store a query entered into a search page so that it can be used for logging purposes. Finally the BHO can further appropriately display results received from the search engine.

The BHO can provide information regarding a URL selected by a user. This information can be employed by the semantic reasoning component to update information retrieval and or query classification model s . The BHO can provide information regarding a website manually navigated to be a user. This information can be employed by the semantic reasoning engine to create new task s . Finally if information from the query is included in a form filled in by a user the BHO can provide information regarding a form filled by the user. Slot filling model s of the semantic reasoning component can be updated based on this information.

To the accomplishment of the foregoing and related ends certain illustrative aspects are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the claimed subject matter may be employed and the claimed subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features of the claimed subject matter may become apparent from the following detailed description when considered in conjunction with the drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

As used in this application the terms component handler model system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal . Computer components can be stored for example on computer readable media including but not limited to an ASIC application specific integrated circuit CD compact disc DVD digital video disk ROM read only memory floppy disk hard disk EEPROM electrically erasable programmable read only memory and memory stick in accordance with the claimed subject matter.

Referring to a task system is illustrated. As noted previously task s are useful in modeling actions user s perform for example on the web. Examples of tasks include buying plane tickets purchasing books reserving cars buying stocks checking accounts or checking the weather in a particular city. Task s can be executed on a variety of websites and individual user s can have individual preferences as to which site best matches their needs.

The process of creating a comprehensive task list can be daunting. The sheer number of sites that exist covering a wide range of services can be prohibitive to employ a manual method for creating tasks and maintaining them. The system provides an automated approach for task creation maintenance and or execution. Furthermore by distributing the processes of task creation maintenance and or execution to end user s the entire task system can improve without the guidance of a central authority.

The system automatically generates task s and or executes them using Browser Helper Object s BHOs . BHOs are objects that bind to a browser at runtime and behave as if they were part of the browser . The BHO provides information associated with a user s action with respect to search results and or task s as discussed below. The web browser is an application program that is capable of displaying a web page e.g. Internet Explorer .

The BHO is a piece of code that effectively becomes part of the browser through the extensibility of the browser . BHOs are capable of accessing an object model corresponding to a schema of the source code e.g. HTML that is created when a web page is loaded. Additionally BHOs can insert value s into form s e.g. HTML form s . BHOs are further capable of communicating with other component s as discussed below.

In one example the browser and the browser helper object s communicate directly with a semantic reasoning component . In another example as illustrated in the browser and or browser helper object s communicate with a search engine that in turn communicates with the semantic reasoning component .

In a client server environment the semantic reasoning component can be a component of a task server not shown . In a distributed processing environment at least a portion of the semantic reasoning component can be resident on a user s computer system not shown .

When a website is loaded the BHO can walk an object model representation of the source code e.g. HTML and determine for example that there are INPUT box es for item s such as Going to and Leaving from fields and or that there are SELECT box e s for the time of day containing elements such as Morning Noon Evening and Anytime . The BHO can insert a value into one or more of the input selection box es . For example the BHO can insert a value of Boston into an INPUT box named tcy if the BHO is notified that Value tcy Boston .

The BHO can communicate with the search engine to facilitate various function s . For example based on information received from the BHO the search engine can log an original query entered to the browser e.g. flight to Boston from Seattle . The search engine can further log website s within a time window that the user has visited and entered Boston or Seattle as values in the web form e.g. Site Expedia.com . Based upon information received from the BHO the search engine can also log value s on the form e.g. tcy Boston fcy Seattle . In one example the information provided to search engine by the BHO does not contain any information which is constituted as personally identifiable.

The BHO can receive a uniform resource locator URL containing semantic information and fill in value s on a form associated with the URL. For example the query flight from Boston to Seattle can return a link to a website with some parameters such as tcy Boston and fcy Seattle. The BHO can interpret this information and fill in information value s based at least in part upon the original query. The BHO can further store a query entered into a search page so that it can be used for logging purposes. Finally the BHO can further appropriately display results received from the search engine .

The semantic reasoning component is responsible for providing search results for queries. A first step returns a list of potential tasks using a combination of Information Retrieval IR and Query Classification QC applications. This step can return a list of likely tasks such as Expedia.com Travelocity.com Orbitz.com etc. A second step takes the query and potential task Expedia.com and attempts to fill in parameter value s in the task such as determining that the variable tcy should have the value Boston .

The semantic reasoning component can further log data returned from BHOs . For example the semantic reasoning component can log the task selected by the user for a model employed by the QC application QC model . Additionally the semantic reasoning component can log site s the user goes to and enters information contained in the original query. The semantic reasoning component can log value s entered on the web page e.g. according to privacy laws and policy .

Additionally the semantic reasoning component can create new task s based at least in part upon information provided by the BHOs . For example when a user manually visits a new site after entering a search query the data can be provided by the BHO to the semantic reasoning component e.g. via the search engine that logs the data. If the site has not been seen before a new task can be created.

The semantic reasoning component can include a QC model employed for task retrieval and or a slot filling model as discussed below . One or both of these models can be updated periodically to reflect user feedback.

The semantic reasoning component provides the search engine with a standardized method for interpreting natural language input. Additionally the semantic reasoning component can provide application developer s with a standard manner of defining the tasks the search engine is capable of performing. A task as used herein describes and defines a fundamental unit of action relevant to user. The semantic reasoning component enables the search engine to define and manage tasks. Task s may be defined using extended markup language XML databases text files or in any other suitable manner.

The search engine can receive any manner of natural language input e.g. handwritten text tablet input speech and typed text . The search engine can process the natural language input to generate a query for processing by the semantic reasoning component e.g. a simple string of text characters . The semantic reasoning component selects one or more tasks based at least in part upon the query. The semantic reasoning component can provide the task along with associated metadata and slot information to describe an action to the search engine .

Referring to an exemplary task is illustrated. The task can be generated by the semantic reasoning component in response to a user s query. For example the task can include a name that identifies the task e.g. a task for booking airline flights may be named BookFlight . The task can also include a title for example that can be displayed to users. Additionally the task can include a description that briefly describes the task . The description can be displayed to users either to allow the users to select the appropriate task or confirm that the appropriate task has been selected. For example the name title and description can be implemented using alphanumeric text strings.

The task can include an entity component . The entity component can include one or more named entities. A named entity as used herein is a token that is known to have a specific meaning. The named entity can be task specific or can be utilized with multiple tasks. The task can include a named entity NE recognizer component . The NE recognizer component can include one or more recognizers capable of matching tokens or portions of the natural language input to the entities included in the entity component . The NE recognizers are capable of recognizing tokens corresponding to the named entities contained within the entities component . These tokens have a specific task meaning. Recognizers may be general or may be specific to a certain category of tokens. For example a city recognizer may include a list of names e.g. Seattle Boston . Similarly a date recognizer may be capable of recognizing and interpreting dates such as Jun. 14 2005. The software developer may define certain recognizers when specifying a task.

The task can also include a keyword component . The keyword component can include one or more keywords. Keywords can be used to select a task from a set of tasks. For example the BookFlight task keyword component can include keywords such as Book Flight airline and the like. The keywords can be determine by the software developer or automatically generated by the semantic reasoning component . In addition the semantic reasoning component can add additional keywords to the keyword component based upon natural language input user actions and or user feedback. Furthermore the keywords may be weighted such that the presence of certain keywords in the query is more likely to surface certain tasks. Such weight can also be used to rank or order a selected group of tasks.

The task can also include a slot component that specifies or defines slots for information required for the task. The slot component can provide a mechanism for defining parameters used by the task. For example a task that books airline flights may include slots for the arrival city the departure city the flight date and time. The slot component can include any integer number of slots from zero to N. Typically information from the natural language input is used to fill the slots.

Turning next to an exemplary slot is illustrated. A slot can include a slot name that identifies the slot . For example the BookFlight task discussed above can include slots named DestinationCity ArrivalCity and Date. The slot can also include a slot type . Slot type indicates the type of the value of the slot data. Types can include integers real numbers textual strings and enumerated types e.g. type City can include a list of city names .

The slot can also include an annotation component . The annotation component can include one or more annotations. Annotations are tokens that mark or indicate the significance of other tokens. The annotation component identifies an annotation token and uses that information to interpret other tokens within the natural language input. For example the token from when contained within a natural language input string that maps to a BookFlight task indicates that the token that follows is likely to contain the name of the departure city. Annotations may appear either before or after the relevant token. For example the token departure city when contained within a natural language input string that maps to a BookFlight task indicates that the token that precedes it is likely to contain the name of the departure city. Consequently the phrase leaving from Boston and Boston departure city can both be interpreted to fill the departure city slot with the value Boston. Annotations which appear before the token are called pre indicators while annotations which follow the relevant token are called post indicators. The annotation component can recognize task system defined annotations as well as task specific annotations.

Next referring to an exemplary task framework is illustrated. The framework can include a task component that includes one or more tasks as described previously. The framework can be a component of the semantic reasoning component .

Tasks can be generated by one or more applications or tasks can be generated automatically by the task framework . In addition the task framework may update or modify tasks generated by application s . The task component can be a flat file a database or any other structure suitable for containing the data for one or more tasks.

The task framework can include a task retrieval component . The task retrieval component uses the query to select one or more tasks from the collection of tasks contained within the task component . The task retrieval component may determine the appropriate task to be retrieved from the task component based upon keywords in the query. The collection of tasks in the task component can be indexed based upon the task keywords. The tokens contained within the query can be used to select an appropriate task or set of tasks. The application can also include additional information with the query. For example the application could pass user context information to the framework to be used in the selection of the appropriate task. The task retrieval component can use a variety of methodologies to select appropriate tasks. The task retrieval component can be trained to improve performance based upon user actions and responses to the selected tasks.

In addition the task framework can include a slot filling component . The slot filling component can be responsible for providing the best matching of the list of tokens from the natural language input or query with the task parameters. Typically a slot filling component can receive a list of tokens and one or more tasks. The slot filling component can generate one or more possible mappings of the tokens to the slots of the task. The slot filling component can generate a score or rank for each of the possible mappings of tokens to task slots. The slot filling component can use a mathematical model algorithm or function to calculate a score or rank for mappings. The slot filling component can utilize a heuristic function a hidden Markov model a Na ve Bayes based model Maximum Entropy Minimum Divergence Models MEMD blending strategies linear discriminative models or any combination thereof to calculate a score for a mapping of tokens to a task.

The slot filling component can include a method responsible for taking the natural language input culture information a list of tokens a list of named entities a task and a predetermined maximum number of desired solutions. Culture information can include information such as the writing system and formatting utilized by the relevant culture. Named entities identify tokens with a specific meaning to the slot filling system e.g. Boston . The slot filling component can produce a list of up to the maximum number of requested semantic solutions with a semantic solution representing a mapping of tokens to slots that can be used by the search engine .

Optionally the task framework can also include a logging component . Tasks can pass information or feedback to the task framework after completion of the task or during task processing. The logging component stores the feedback information. This information can be used to train the task framework and improve system performance. The feedback from tasks can include user actions. The task framework can include a defined intent interface to facilitate feedback.

In addition the task framework or the slot filling component can include one or more GlobalRecognizers that provide the ability to recognize tokens that have special meaning to the task system in general. For example the token Boston has special meaning as the city of Boston Mass. The GlobalRecognizers property provides a set of recognizer components that identify special tokens making them available throughout the entire system and across multiple tasks. For example there may be several tasks that utilize city date or number entities. Entities are a mechanism for providing type information. For example the city entity includes a set of annotations e.g. city place and town . Occurrences of the annotations within the list of tokens indicate the likelihood of a city entity. GlobalRecognizers allows such entities or special tokens to be defined once rather than for each individual task.

In summary keywords are terms that might be used to surface a task. Slots are parameter values that may or may not be filled by the user Query. Slots are uniquely specified by their Name and Type.

Additionally preIndicators are words that might disambiguate slots by occurring before a value to Boston would prefer the Arrival City slot over the Departure City slot even though Boston maps to CITY and can be a value for either slot. PostIndicators are words that might disambiguate slots by occurring before a value from Boston would prefer the Departure City slot over the Arrival City slot even though Boston maps to CITY and can be a value for either slot. Consider the example of Table 1 

Additionally as discussed previously the semantic reasoning component can employ user feedback to learn from user behavior such that if users start entering queries such as departing Boston for Seattle to mean Departure City Boston and Arrival City Seattle . The semantic reasoning component will automatically learn the pattern departing for without needing to explicitly add new Pre or Post indicators to the task definition.

Returning to from a user s perspective using the browser the user visits a search site associated with the search engine and enters a query flights from Boston to Seattle . A set of search results and a set of task results are returned from the search engine . Referring briefly to an exemplary user interface is illustrated. The user interface includes a search results area and a task results area .

Referring back to if the user sees the result the user desires the user can click on the link and be brought to the site associated with the link. The BHO and or the search engine can provide a notification of the click through to the semantic reasoning component for example to update the task retrieval query classifier model. If there are parameter value s recognized in the query the parameter value s can be automatically be filled in by the BHO as illustrated in the exemplary user interface of . In this example the BHO has filled in the input box associated with Departing from with boston and the input box associated with Going to with seattle based on the original query input of flight from boston to seattle .

Continuing with if the user does not see a result the user likes the user can manually navigate to a website. This may be a lengthy process such as navigating to a particular website and then to a particular page of the website e.g. travel page . With respect to the travel example once a user has arrived on a destination page the user complete the form by entering values of Boston and Seattle into the appropriate elements on the form. The user then hits the submit button e.g. go search and the like causing a post event .

If there exists information entered into the form that was contained in the original query the BHO can send the information back to the semantic reasoning component e.g. in accordance with the privacy laws and policies . For example if the user has typed Boston into a field named originCity then the query URL of the website the field name and field value can be sent back to the semantic reasoning component .

If the URL is not contained in the database of tasks the semantic reasoning component can create a new task. The URL can be normalized to prevent millions of tasks from being created where the web pages are effectively the same but each individual URL may be unique due to cookies and or other information supplied randomly. Thereafter the object model e.g. HTML object model can be walked and a task created containing for example 

Additionally the model s for slot filling can be updated accordingly. For example a new parameter can be created if it doesn t already exist. Further the model s for slot filling can learn a pattern such as from X will put X in the originCity field.

Next referring to a task extractor is illustrated. The task extractor can automatically extract task s from given seed website s e.g. from BHOs . For example the task extractor can be a component of the semantic reasoning component and receive information regarding seed website s from BHOs .

For purposes of explanation task s can be limited to form enabled task s that is task s that have a form as their input parameter s . The output of the task extractor is task object s that can be stored in a task store e.g. to be utilized by the semantic reasoning component .

Since task object s generally require field s of keyword s and a description of the task a significant function of the task extractor is discovering semantic information about the task e.g. the functionality of the task for end user s . Additionally the task extractor can discover a description user s would type in when they want to perform this task. In one example this functionality can be obtained by obtaining information from the form e.g. HTML form and its context. In another example a query probing technique can be employed.

Given the seed website which is identified as containing common task s beforehand a crawler can first crawl the web page s under this seed website and write them into a data store . Also the crawler can record linkage between different web pages in another table for the reason that the links to and from a web page may induce some semantic information for tasks on the web page.

Next a form filter and optionally a schema probe can employ the web page information stored in the data store . The form filter can extract form s e.g. HTML form s from raw text e.g. HTML raw text . Furthermore optionally the form filter can filter out form s having the same functionality and or pointing to the same action which is often the case for web pages under the same website. A simple example for this situation is that there would be many pages having a particular search engine s form but it is desirable to only have a single task object in the task store .

The form filter passes filtered form s to the parser which then extracts structured information of the form s including action URI universal resource identifier method input type etc. Moreover the default value for INPUT in HTML form s may provide information about the slot entity.

Next a context semantic extractor captures semantic information other than that in HTML tags. Both slot level information as well as task level information can be captured. For example with respect to word s that appear immediately in front of an INPUT element are highly likely to bring in slot level information for the INPUT element. On the other hand the TITLE of the web page and or words immediately before or after the form may provide task level information. However in one example it is likely that simply extracting information in certain contextual positions does not yield acceptable performance. In this case substantially all the data on the web page can be employed as a richer context which at the same time brings in a quantity of unwanted noise. A weighted importance model for data on the same web page can be introduced to address this noise filtering relevant information extraction issue. Importance can depend for example on the distance from the Form or the IDF of that word etc.

The optional schema probe can provide information about the entities for slots. The schema probe can automatically generate query and obtain feedback and or more description information about slot entities.

For each form a task generator can collect the task information from the parser the context semantic extractor and optionally the schema probe to create a task object. Thereafter the task generator can store the generated task object in the task store .

It is to be appreciated that the system the browser the browser help object s the semantic reasoning component the system the search engine the task extractor the task store the crawler the data store the form filter the schema probe the parser the context semantic extractor and or the task object generator can be computer components as that term is defined herein.

Turning briefly to methodologies that may be implemented in accordance with the claimed subject matter are illustrated. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may in accordance with the claimed subject matter occur in different orders and or concurrently with other blocks from that shown and described herein. Moreover not all illustrated blocks may be required to implement the methodologies.

The claimed subject matter may be described in the general context of computer executable instructions such as program modules executed by one or more components. Generally program modules include routines programs objects data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Referring to a method facilitating a user query session is illustrated. At a query e.g. natural language query is submitted to a search engine. At search results and at least one task are received from the search engine responsive to the query. At a determination is made as to whether the user has selected a URL from the search results and or task s received from the search engine. If the determination at is YES at a browser helper object e.g. BHO provides information regarding the selected URL for example to the search engine and or a semantic reasoning component. At the browser helper object performs form filling on a form associated with the selected URL based at least in part upon the original query and processing continues at .

If the determination at is NO at the user manually navigates to a website. At the browser helper object provides information regarding the website e.g. URL to the search engine and or semantic reasoning component.

At the user enters information into a form associated with the website. At the user submits the information. At if any information from the original query is included in the form the browser helper object provided information regarding the form filled by the user for example to the search engine and or semantic reasoning component.

Turning to a search engine method is illustrated. at a query e.g. natural language query is received from a user. At the query is provided to a semantic reasoning component. At task results are received from the semantic reasoning component. At search results responsive to the user s query are obtained.

At the search results and at least one task are provided to the user. At click through information is obtained from a browser helper object. At the click through information is provided to the semantic reasoning component.

At information regarding a user web action is received from the browser helper object. At the user web action is logged. Finally at information regarding the user web action is provided to the semantic reasoning component.

Next referring to a semantic reasoning component method is illustrated. At a query is received from a search engine. At task s are retrieved based at least in part upon the query. At parameter s are provided with most likely value s . At the search engine is provided with the task results.

At click through information is received for example from the search engine and or a browser helper object. At model s that perform task retrieval are updated based at least in part upon the click through information.

At information regarding a user s web action is received for example from the search engine and or a browser helper object. At model s that find best parameter value given the query are updated based at least in part upon the user web action.

In order to provide additional context for various aspects of the claimed subject matter and the following discussion are intended to provide a brief general description of a suitable operating environment . While the claimed subject matter is described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices those skilled in the art will recognize that the claimed subject matter can also be implemented in combination with other program modules and or as a combination of hardware and software. Generally however program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular data types. The operating environment is only one example of a suitable operating environment and is not intended to suggest any limitation as to the scope of use or functionality of the claimed subject matter. Other well known computer systems environments and or configurations that may be suitable for use with the claimed subject matter include but are not limited to personal computers hand held or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include the above systems or devices and the like.

With reference to an exemplary environment includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to an 8 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable nonremovable volatile nonvolatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the claimed subject matter can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes examples of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the claimed subject matter are possible. Accordingly the claimed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

