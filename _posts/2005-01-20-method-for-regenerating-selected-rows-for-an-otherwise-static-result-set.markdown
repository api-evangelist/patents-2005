---

title: Method for regenerating selected rows for an otherwise static result set
abstract: Methods for updating query results are provided. In one embodiment, a stored query is modified to retrieve a selected subset of rows from stored query results without retrieving a remaining portion of the stored results. The modified query is executed, updated results are obtained from the modified query, and the updated results are displayed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747640&OS=07747640&RS=07747640
owner: International Business Machines Corporation
number: 07747640
owner_city: Armonk
owner_country: US
publication_date: 20050120
---
Databases are computerized information storage and retrieval systems. A relational database management system is a computer database management system DBMS that uses relational techniques for storing and retrieving data. The most prevalent type of database is the relational database a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways.

Regardless of the particular architecture in a DBMS a requesting entity e.g. an application or the operating system demands access to a specified database by issuing a database access request. Such requests may include for instance simple catalog lookup requests or transactions and combinations of transactions that operate to read change and add specified records in the database. These requests are made using high level query languages such as the Structured Query Language SQL . Illustratively SQL is used to make interactive queries for getting information from and updating a database such as International Business Machines IBM DB2 Microsoft s SQL Server and database products from Oracle Sybase and Computer Associates. The term query denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language that lets programmers and programs select insert update find out the location of data and so forth.

Information in a database may be constantly changing. For instance in a database that stores medical records new records may be added old records may be deleted and existing records may be updated with new information such as test results. A user executing queries against the database may wish to remain up to date with respect to the latest information in the database. For instance the user may wish to remain up to date because the user may be conducting ongoing research using the database. One method for keeping the user up to date with respect to information in the database is to allow the user to store queries which the user has executed against the database. The user may run a query once to obtain an initial set of results and the user may decide to store the query. Later the user may run the stored query again to obtain a new set of results. The user may also wish to store the results of the initial query execution for later reference analysis or comparison with subsequent results. The results stored by the user may be stored in a table consisting of several rows and columns of data.

In some cases the user may wish to obtain updated results but the user may not want to update the entire table of stored results. For instance the user may only be interested in updating certain rows in the stored results because those rows contain information such as test results which the user is tracking. For instance the user may wish to update results only with respect to a certain patient that the user is interested in. Where the results contain several rows for a single patient representing different test dates for instance the user may only wish to update results for those test dates. In other cases the user may also wish to have outdated rows removed and to be informed of any new rows which have been added. If the user wants to update those desired rows the user may have to rerun the stored query and update the entire table.

Rerunning the stored query may be costly. For instance the stored query may be executed against a database with many tables and many records. The stored query may require many comparisons and calculations to be performed as well. When the user only wishes to see updated results for certain rows in the stored results the user would prefer not to have to run the stored query and update the entire set of results because of the associated execution costs. Accordingly what is needed is a method for updating results wherein the user only wishes to update a selection of the rows in the results.

The present invention generally provides methods for updating query results. One embodiment provides a method for updating query results. The method generally provides for receiving results for an executed query wherein the results contain two or more rows storing the query and the results and receiving a request to update a selected subset of the two or more rows in the stored results the subset being less than all of the two or more rows. The stored query is retrieved from storage and in response to the request the retrieved query is modified to retrieve the selected subset of rows without retrieving a remaining portion of the two or more rows. The modified query is executed updated results are obtained from the modified query and the updated results are displayed.

Another embodiment provides a computer implemented method for updating query results. The method generally provides for receiving results for an executed query wherein the results contain two or more rows and wherein each row contains a data value in a restricting data field. The query and the results are stored. The method further provides for receiving a request to update a selected subset of two or more rows in the stored results the subset being less than all of the two or more rows and retrieving the stored query from storage. In response to the request the retrieved query is modified to retrieve the selected subset of rows without retrieving a remaining portion of the two or more rows wherein modifying the retrieved query comprises inserting a first query condition into the retrieved query wherein the first query condition contains the respective data value in the restricting data field for the selected subset of rows. The modified query is executed updated results are obtained from the modified query and the updated results are displayed.

Yet another embodiment provides a method of programmatically providing a user interface for updating query results. The method generally includes providing graphical user interface content which defines a graphical user interface. The graphical user interface generally includes a listing of two or more results rows the results rows obtained from a query and a graphical selection element for each of the two or more results rows which may be used to select each of the two or more results rows individually. The method further provides for receiving a request to update one or more selected rows from the two or more results rows wherein the graphical selection element for each of the two or more results rows is used to individually select the one or more selected rows and modifying the query to retrieve the one or more selected rows without retrieving a remaining portion of the two or more results rows. For at least those of the one or more selected rows having updated values the modified results are displayed the modified results being returned as results of the executed modified query.

The present invention generally provides methods for updating query results. Embodiments generally provide for receiving results for an executed query wherein the results contain two or more rows storing the query and the results and receiving a request to update a selected subset of the two or more rows in the stored results the subset being less than all of the two or more rows. The stored query is retrieved from storage and in response to the request the retrieved query is modified to retrieve the selected subset of rows without retrieving a remaining portion of the two or more rows. The modified query is executed updated results are obtained from the modified query and the updated results are displayed.

In the following reference is made to embodiments of the invention. However it should be understood that the invention is not limited to specific described embodiments. Instead any combination of the following features and elements whether related to different embodiments or not is contemplated to implement and practice the invention. Furthermore in various embodiments the invention provides numerous advantages over the prior art. However although embodiments of the invention may achieve advantages over other possible solutions and or over the prior art whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus the following aspects features embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim s . Likewise reference to the invention shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim s .

While embodiments below are described with reference to a system utilizing abstract queries and data abstraction other embodiments of the invention are contemplated in which the queries being executed by the user are executed against a database which does not utilize abstract queries and data abstraction.

One embodiment of the invention is implemented as a program product for use with a computer system such as for example the computer system shown in and described below. The program s of the program product defines functions of the embodiments including the methods described herein and can be contained on a variety of signal bearing media. Illustrative signal bearing media include but are not limited to i information permanently stored on non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive ii alterable information stored on writable storage media e.g. floppy disks within a diskette drive or hard disk drive or iii information conveyed to a computer by a communications medium such as through a computer or telephone network including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal bearing media when carrying computer readable instructions that direct the functions of the present invention represent embodiments of the present invention.

In general the routines executed to implement the embodiments of the invention may be part of an operating system or a specific application component program module object or sequence of instructions. The software of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine readable format and hence executable instructions. Also programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular nomenclature that follows is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

The client computer includes a Central Processing Unit CPU connected via a bus to a memory storage an input device an output device and a network interface device . The input device can be any device to give input to the client computer . For example a keyboard keypad light pen touch screen track ball or speech recognition unit audio video player and the like could be used. The output device can be any device to give output to the user e.g. any conventional display screen. Although shown separately from the input device the output device and input device could be combined. For example a display screen with an integrated touch screen a display with an integrated keyboard or a speech recognition unit combined with a text speech converter could be used.

The network interface device may be any entry exit device configured to allow network communications between the client computer and the server computer via the network . For example the network interface device may be a network adapter or other network interface card NIC .

Storage is preferably a Direct Access Storage Device DASD . Although it is shown as a single unit it could be a combination of fixed and or removable storage devices such as fixed disc drives floppy disc drives tape drives removable memory cards or optical storage. The memory and storage could be part of one virtual address space spanning multiple primary and secondary storage devices.

The memory is preferably a random access memory sufficiently large to hold the necessary programming and data structures of the invention. While the memory is shown as a single entity it should be understood that the memory may in fact comprise a plurality of modules and that the memory may exist at multiple levels from high speed registers and caches to lower speed but larger DRAM chips.

Illustratively the memory contains an operating system . Illustrative operating systems which may be used to advantage include Linux and Microsoft s Windows . More generally any operating system supporting the functions disclosed herein may be used.

The memory is also shown containing a browser program that when executed on CPU provides support for navigating between the various servers and locating network addresses at one or more of the servers . In one embodiment the browser program includes a web based Graphical User Interface GUI which allows the user to display Hyper Text Markup Language HTML information. More generally however the browser program may be any GUI based program capable of rendering the information transmitted from the server computer .

The server computer may be physically arranged in a manner similar to the client computer . Accordingly the server computer is shown generally comprising a CPU a memory and a storage device coupled to one another by a bus . Memory may be a random access memory sufficiently large to hold the necessary programming and data structures that are located on the server computer .

The server computer is generally under the control of an operating system shown residing in memory . Examples of the operating system include IBM OS 400 UNIX Microsoft Windows and the like. More generally any operating system capable of supporting the functions described herein may be used.

The memory further includes one or more applications an abstract query interface and a rule application manager . The applications the abstract query interface and the rule application manager are software products having a plurality of instructions that are resident at various times in various memory and storage devices in the computer system . When read and executed by one or more processors in the server the applications the abstract query interface and the rule application manager cause the computer system to perform the steps necessary to execute steps or elements embodying the various aspects of the invention. The applications and more generally any requesting entity including the operating system and at the highest level users issue queries against a database e.g. databases . . . collectively referred to as database s . Illustratively the databases are shown as part of a database management system DBMS in storage . The databases are representative of any collection of data regardless of the particular physical representation. By way of illustration the databases may be organized according to a relational schema accessible by SQL queries or according to an XML schema accessible by XML queries . However the invention is not limited to a particular schema and contemplates extension to schemas presently unknown. As used herein the term schema generically refers to a particular arrangement of data.

The memory may also include a result updater according to one embodiment of the invention. The result updater may be used to store and update results according to one embodiment of the invention. The operation of the result updater is described below in greater detail.

In one embodiment the queries issued by the applications are defined according to an application query specification included with each application . The queries issued by the applications may be predefined i.e. hard coded as part of the applications or may be generated in response to input e.g. user input . In either case the queries referred to herein as abstract queries are composed using logical fields defined by the abstract query interface . In particular the logical fields used in the abstract queries are defined by a data repository abstraction component of the abstract query interface . The abstract queries are executed by a runtime component which first transforms the abstract queries into a form consistent with the physical representation of the data contained in the DBMS e.g. by translating abstract queries into concrete queries. The rule application manager implements a rule application mechanism for restricting queryable data to a subset of all available data contained in the DBMS . In one embodiment the rule application manager restricts the queryable data by redefining a query that is executed against the database in order to execute the redefined query against the queryable data. Alternatively the rule application manager restricts the queryable data using a condition retrieved from storage when executing a received query. Still alternatively the rule application manager restricts the queryable data by modifying the data repository abstraction component. The application query specification the abstract query interface and the rule application manager are further described with reference to .

In one embodiment elements of a query are specified by a user through a graphical user interface GUI . The content of the GUIs is generated by the application s . In a particular embodiment the GUI content is hypertext markup language HTML content which may be rendered on the client computer systems with the browser program . Accordingly the memory includes a Hypertext Transfer Protocol HTTP server process e.g. a web server adapted to service requests from the client computer . For example the process may respond to requests to access a database s which illustratively resides on the server . Incoming client requests for data from a database invoke an application . When executed by the processor the application causes the server computer to perform the steps or elements embodying the various aspects of the invention including accessing the database s . In one embodiment the application comprises a plurality of servlets configured to build GUI elements which are then rendered by the browser program .

The logical fields specified by the application query specification and used to compose the abstract query are defined by the data repository abstraction component . In general the data repository abstraction component exposes information as a set of logical fields that may be used within a query e.g. the abstract query issued by the application to specify criteria for data selection and specify the form of result data returned from a query operation. The logical fields are defined independently of the underlying data representation being used in the DBMS thereby allowing queries to be formed that are loosely coupled to the underlying data representation.

In general the data repository abstraction component exposes information as a set of logical fields that may be used within a query e.g. the abstract query issued by the application to specify criteria for data selection and specify the form of result data returned from a query operation. The logical fields are defined independently of the underlying data representation being used in the database thereby allowing queries to be formed that are loosely coupled to the underlying data representation.

In one embodiment the data repository abstraction component comprises a plurality of field specifications and five shown by way of example collectively referred to as the field specifications . Specifically a field specification is provided for each logical field available for composition of an abstract query. Each field specification contains a logical field name collectively field name and an associated access method collectively access method . The access methods associate i.e. map the logical field names to a particular physical data representation . . . in the database e.g. database . By way of illustration two data representations are shown an XML data representation and a relational data representation . However the physical data representation indicates that any other data representation known or unknown is contemplated. In one embodiment a single data repository abstraction component contains field specifications with associated access methods for two or more physical data representations . In an alternative embodiment a different single data repository abstraction component is provided for each separate physical data representation .

Any number of access methods is contemplated depending upon the number of different types of logical fields to be supported. In one embodiment access methods for simple fields filtered fields and composed fields are provided. The field specifications and exemplify simple field access methods and respectively. Simple fields are mapped directly to a particular entity in the underlying physical data representation e.g. a field mapped to a given database table and column . By way of illustration the simple field access method shown in maps the logical field name FirstName to a column named f name in a table named contact . The field specification exemplifies a filtered field access method . Filtered fields identify an associated physical entity and provide filters used to define a particular subset of items within the physical data representation. An example is provided in in which the filtered field access method maps the logical field name AnyTownLastName to a physical entity in a column named I name in a table named contact and defines a filter for individuals in the city of Anytown . Another example of a filtered field is a New York ZIP code field that maps to the physical representation of ZIP codes and restricts the data only to those ZIP codes defined for the state of New York. The field specification exemplifies a composed field access method . Composed access methods compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way information which does not exist in the underlying data representation may be computed. In the example illustrated in the composed field access method maps the logical field name AgeInDecades to AgeInYears 10 . Another example is a sales tax field that is composed by multiplying a sales price field by a sales tax rate.

It is contemplated that the formats for any given data type e.g. dates decimal numbers etc. of the underlying data may vary. Accordingly in one embodiment the field specifications include a type attribute which reflects the format of the underlying data. However in another embodiment the data format of the field specifications is different from the associated underlying physical data in which case a conversion of the underlying physical data into the format of the logical field is required.

By way of example the field specifications of the data repository abstraction component shown in are representative of logical fields mapped to data represented in the relational data representation . However other instances of the data repository abstraction component map logical fields to other physical data representations such as XML.

An illustrative abstract query corresponding to the abstract query shown in is shown in TABLE I below. By way of illustration the illustrative abstract query is defined using XML. However any other language may be used to advantage.

Illustratively the abstract query shown in TABLE I includes a selection specification lines 005 014 containing selection criteria and a results specification lines 015 019 . In one embodiment a selection criterion consists of a field name for a logical field a comparison operator 

An illustrative Data Repository Abstraction is shown in TABLE II below. By way of illustration the illustrative Data Repository Abstraction is defined using XML. However any other language may be used to advantage.

After building the data selection portion of the concrete query the runtime component identifies the information to be returned as a result of query execution. As described above in one embodiment the abstract query defines a list of abstract fields that are to be returned as a result of query execution referred to herein as a result specification. A result specification in the abstract query may consist of a field name and sort criteria. Accordingly the method enters a loop at step defined by steps and to add result field definitions to the concrete query being generated. At step the runtime component looks up a result field name from the result specification of the abstract query in the data repository abstraction and then retrieves a Result Field Definition from the data repository abstraction to identify the physical location of data to be returned for the current logical result field. The runtime component then builds as step a Concrete Query Contribution of the concrete query that identifies physical location of data to be returned for the logical result field. At step Concrete Query Contribution is then added to the Concrete Query Statement. Once each of the result specifications in the abstract query has been processed the query is executed at step .

One embodiment of a method for building a Concrete Query Contribution for a logical field according to steps and is described with reference to . At step the method queries whether the access method associated with the current logical field is a simple access method. If so the Concrete Query Contribution is built step based on physical data location information and processing then continues according to method described above. Otherwise processing continues to step to query whether the access method associated with the current logical field is a filtered access method. If so the Concrete Query Contribution is built step based on physical data location information for some physical data entity. At step the Concrete Query Contribution is extended with additional logic filter selection used to subset data associated with the physical data entity. Processing then continues according to method described above.

If the access method is not a filtered access method processing proceeds from step to step where the method queries whether the access method is a composed access method. If the access method is a composed access method the physical data location for each sub field reference in the composed field expression is located and retrieved at step . At step the physical field location information of the composed field expression is substituted for the logical field references of the composed field expression whereby the Concrete Query Contribution is generated. Processing then continues according to method described above.

If the access method is not a composed access method processing proceeds from step to step . Step is representative of any other access methods types contemplated as embodiments of the present invention. However it should be understood that embodiments are contemplated in which less then all the available access methods are implemented. For example in a particular embodiment only simple access methods are used. In another embodiment only simple access methods and filtered access methods are used.

As described above it may be necessary to perform a data conversion if a logical field specifies a data format different from the underlying physical data. In one embodiment an initial conversion is performed for each respective access method when building a Concrete Query Contribution for a logical field according to the method . For example the conversion may be performed as part of or immediately following the steps and . A subsequent conversion from the format of the physical data to the format of the logical field is performed after the query is executed at step . Of course if the format of the logical field definition is the same as the underlying physical data no conversion is necessary.

As described above a user executing queries in a database system may wish to store the results of a query and later update a selected subset of rows contained in the results. The user may not wish to update the results by rerunning the original query because rerunning the original query would update the entire set of results. Rerunning the original query may also take time and be computationally expensive. Embodiments of the invention allow the user to update the selected subset of rows without rerunning the original query by executing a modified query which retrieves the selected subset of rows without retrieving the remaining portion of the results.

After receiving a user s abstract query transforming the abstract query into a concrete query and executing the query as described above with respect to the process for saving and updating query results may be initiated. depicts a process for saving and updating query results according to one embodiment of the invention. According to one embodiment of the invention the process may be performed by the result updater . In other embodiments the process may be performed by other components such as the runtime component or by any other application located on the server or the client computer .

In order to better understand the process for saving and updating query results consider the following exemplary database tables and exemplary query.

The database being searched may contain two tables. The first table called Table1 and shown in TABLE III above may have columns containing various patient information such as a patient ID the patient s last name the patient s first name and the patient s birth date. The second table called Table2 and shown in TABLE IV above may have data about each patient s test results. The second table contains the patient ID the patient s test result the test type and the test date.

The exemplary query displayed in TABLE V consists of three parts. The first part the SELECT clause selects values which will be displayed as columns in the results. The SELECT clause in the exemplary query selects four columns to be displayed the Patient ID from Table1 the last name of the patient from Table1 the test type from Table2 and the test results from Table2. The second clause in the exemplary query the WHERE clause limits the data which will be selected by the SELECT clause. In the WHERE clause data from the SELECT clause is limited to rows where the Patient ID is the same in Table1 and Table2 Table1.Patient ID Table2.Patient ID and where the value in the test results column of Table2 is greater than 40 Table2.Test Results 40 . The third clause the ORDER BY clause specifies how the results should be ordered in this case by the Patient ID number in ascending order. Thus the exemplary query has the effect of displaying the Patient ID the last name the test type and the test results for patients whose test results are greater than 40. The results of the exemplary query are shown in TABLE VI below.

The process for storing and updating results may begin at step and continue to step where the results from the execution of the query shown in Table VI are received. The results may be received in a file data structure as a stream of data or by any means known to those skilled in the art. At step the received results may be stored. The results may be stored so the user may later view the results and use them to select which rows the user would like to update described below . The results of the query may be stored on the storage device according to one embodiment of the invention. In other embodiments the results may be stored on a storage server or in the storage on the client computer .

After storing the query results at step identifier values for each row in the stored results may also be stored at step . Identifier values are values which are used to identify rows in the stored results. Identifier values are typically stored in the same database and in some cases in the same tables as the data which is being queried. The identifier values may include primary keys foreign keys indexes unique indexes or any other identifier values known to those skilled in the art. The identifier values may also be marked as identifier values within the database marked as an attribute of a logical field in a data repository abstraction described above or the identifier values may be implicitly marked or used as identifier values inside the programs and components which use them such as the runtime component .

In one embodiment of the invention the identifier values may be identified retrieved and stored separately from the received results. According to other embodiments of the invention the identifier values may be identified retrieved and stored simultaneously with the results or as a part of the results themselves. With respect to the exemplary query and results the identifier values are the values in the Patient ID column and are thus received as part of the results. The values in the Patient ID column are recognizable as identifier values in the underlying database tables because the Patient ID column is labeled as a primary key column in the underlying database table Table1 . The identifier values may be identified as such by parsing the query to determine which tables in the database are being searched in this case Table1 and Table2 . The attributes of the columns in the tables being searched may then be analyzed to determine which column contains the identifier values here Table1 contains the column Patient ID which has the primary key attribute and thus contains the identifier values . In other embodiments of the invention the identifier values may not be determined until they are actually used to identify the rows in the stored results described below .

While the identifier values may be used to identify rows in the stored results the identifier values may not be unique for each row. In other words a given identifier value may identify two or more rows in a given set of results. For instance as shown in Table VI the retrieved rows contain test results and the identifier value for each row is a patient ID for the patient undergoing the test. However because a patient may take different tests or because a patient may take the same test on different dates the results may contain several rows of test results for the same patient each of which is identified by the same patient ID. Thus with respect to TABLE VI the identifier value for patient 456 appears twice because the patient Bill Smith was tested on two different dates Aug. 30 2004 and Sep. 9 2004 both of which resulted in a test value above 40. Use of the identifier value in updating the results is described below in greater detail.

After storing the identifier values for each row of the stored results the query may be stored at step . The query may be stored so that it may be later modified and executed to update the results upon receiving an update request. In some embodiments of the invention the user may also be allowed to retrieve the stored query modify the stored query and or re execute the stored query.

After the results identifier values and query have been stored the stored results may be retrieved and displayed at step . depicts a graphical user interface for displaying the stored results according to one embodiment of the invention. The graphical user interface may contain a table with rows and columns of results. The table may also provide the identifier value for each row in a column as well as graphical selection elements for selecting one or more of the rows to be updated. The graphical user interface may also contain a graphical element for initiating requests to update the results.

According to one embodiment of the invention the results may be immediately displayed to the user after the results have been stored. According to another embodiment of the invention the results may be stored until the user later requests to view the results. In other embodiments of the invention the user may be provided with other options regarding the results such as the ability to download the results from the server computer the ability to delete unwanted results or other options for manipulating stored results generally known to those skilled in the art.

After retrieving and displaying the stored results a request to update a selected subset of the rows in the stored results may be received at step . The request may be made by any requesting entity such as a user or computer program. According to one embodiment of the invention the subset of rows may be selected by the user using the graphical selection elements provided in the graphical user interface for displaying the results. For instance as depicted in the user may have selected rows and to be updated by clicking on the graphical selection elements . According to another embodiment the subset of rows may selected by allowing the user to enter the identifier values for the rows to be selected. The request to update the rows may be initiated by activating the graphical element for initiating update requests. According to another embodiment of the invention the request may be made by keyboard input such as a keyboard shortcut. The subset of rows may also be selected and the request may also be initiated by other means known to those skilled in the art according to other embodiments of the invention.

After the request to update the query has been received the stored query may be retrieved at step and the identifier values for the selected rows may be loaded at step . The stored query and the identifier values are retrieved in order to create a modified query which will update the selected rows without having to run the original query and update the entire set of results. At step the query may be modified to retrieve the selected subset of rows using the respective identifier value for each of the selected rows. The process for modifying the stored query is depicted in .

After modifying the query at step the loop iterating across each selected row may continue at step . Accordingly the next selected row evaluated by the loop will be row . At step the identifier value for that row patient ID equal to 900 may be retrieved and at step a limiting condition with the identifier value may be inserted into the query. Because the user wishes to update more than one row rows and the limiting condition may be inserted as an alternative disjunctively with respect to the other limiting conditions. Accordingly the modification to the WHERE clause may become Table1.Patient ID 465 OR Table1.Patient ID 900 after the second iteration of the loop.

After the third iteration of the loop the identifier for the next selected row Patient ID equal to 905 for row will also be added as a limitation and joined disjunctively to the other limiting conditions in the modified query resulting in Table1.Patient ID 465 OR Table1.Patient ID 900 OR Table1.Patient ID 905 . Thus when the query is executed the query will only select data containing one of the identifier values contained in the selected rows causing the query to retrieve updated results for each of the selected rows. Furthermore because the query contains a very limited condition in the WHERE clause the condition selecting the identifier values the database engine executing the modified query may optimize the execution of the modified query by causing the limiting condition to be applied first when the query is executed. Accordingly when the remaining conditions in the modified query such as the Table2.Test Results 40 condition are executed the remaining conditions will be executed against a more limited selection of rows only those with the patient IDs of 465 900 or 905 as compared to the original query which may have been executed against all of the patient IDs causing the modified query to retrieve and update the selected rows much more quickly and selectively than could be accomplished with the original query.

After the loop has iterated across each selected row the loop may finish and the process of updating the results may continue from step . The final result of the modification process is shown in TABLE VIII.

After the process of modifying the query finishes the query may be executed at step . At step the results from the execution of the modified query may be obtained. The obtained results may depend on any changes which have taken place in the underlying database. Consider for example the changed test result table shown in TABLE IX. Changed values are marked by asterisks 

Numerous changes in the underlying table may have taken place. For instance some rows may have been added some rows may have been deleted and some rows may have been replaced with updated test results. After the modified query depicted in TABLE VII is executed at step against the changed results shown in TABLE IX the results obtained at step will appear as in TABLE X.

With respect to the results depicted in TABLE X only rows containing results which meet each condition of the modified query are returned. Accordingly only rows containing at least one of the identifier values Patient ID 456 900 or 905 from the selected subset of rows will be selected. If the values in the changed rows do not contain data meeting the original requirements of the query the rows will not be selected. Furthermore even though new rows may be added to the underlying table which meet the conditions of the original query such as the new row for patient with Test Type A and a test result over 40 depicted in TABLE IX if the new rows do not contain the identifier value for one of the selected rows the new rows will not be included in the returned results.

After the updated results from the modified query are returned at step the updated results may be merged with the stored results at step . depicts a process for merging updated results according to one embodiment of the invention. The process may begin at step and continue to step where the selected rows are removed from the stored results. The rows may be removed from the stored results in order to place the new updated rows in the spaces where the removed rows were described below .

After the selected rows are removed the rows with duplicate identifier values i.e. the same identifier values as the selected rows may also be removed at step . Thus as depicted in row with a patient ID of is selected. Because the modified query may also retrieve an updated version of row which has a duplicate identifier value Patient ID is also 456 row must be deleted from the results in order to make a space for the updated version of the row if any. In another embodiment of the invention rows with duplicate identifier values may not be deleted unless an updated version of the row is actually available. In yet other embodiments of the invention the selected rows and rows with duplicate values may be removed just after a request to update selected rows is received in order to make space for the updated results. The stored results after removal of the selected rows and the rows with duplicate identifier values may appear as shown in TABLE XI.

At step the number of removed rows may be recorded. The number of removed rows may be recorded in order to inform the user of the changes which have been made to the stored results. After recording the number of removed rows the new rows from the results of the modified query may be placed in the empty rows in the stored results at step . If there are fewer updated rows returned by the modified query than empty rows in the stored results some rows in the stored results may remain empty until the rows are sorted described below . There may be fewer updated rows returned by the modified query because the original rows have been deleted since the original query was executed or because the original rows in the underlying table after being modified or updated by other processes or users in the system no longer satisfy the conditions of the modified query. Accordingly with respect to the changed exemplary test result table shown in TABLE IX the Type B test value for Patient ID 456 has been changed to 38 for a new test performed on Nov. 11 2004. While the modified query does allow rows with a Patient ID of 456 to be selected the modified query restricts those rows to test values of greater than 40. Thus the Test B results for patient 456 do not satisfy the modified query and the row is not returned in the modified query results. If there are more updated rows returned by the modified query than empty rows in the stored results the additional rows may be inserted at the end of the stored results at step . After the updated rows from the modified query results have been inserted into the stored results the merged results may appear as shown in TABLE XII.

After the updated rows have been inserted the ORDER BY clause of the modified query may be applied to the merged results at step . For the modified query shown in Table VII the ORDER BY clause specifies that the results be sorted by the Patient ID value in ascending order. When the ORDER BY clause is applied to the merged results any blank rows will be placed at the end of the merged results and effectively deleted. The results of applying the ORDER BY clause are depicted in TABLE XIII.

After the updated rows and the stored results have been merged and ordered a determination may be made of whether the number of rows has changed or whether the order of the rows has changed. To determine if the number of rows has changed the number of removed rows may be compared to the number of inserted rows. To determine if the order of the merged results has changed the merged results may be compared with the original stored results. If the number of rows has changed or the order has changed a warning may be displayed to the user at step . The warning may be a textual message displayed along with the results a pop up box highlighting or italicizing of the changed rows or any other warning known to those skilled in the art.

After the process of merging the results is finished the process of saving and updating the results may continue after step . At step the merged results may be displayed. The merged results may be displayed in a graphical user interface such as the graphical user interface depicted in according to one embodiment. The changed values may be italicized as shown in . According to other embodiments of the invention the changed values may be highlighted or displayed next to the original stored values for comparison. After the merged results have been displayed the process of updating the results may terminate at step .

Other embodiments of the invention are also contemplated which provide different variations of the above process of storing and updating query results. For instance one embodiment may provide that selected rows are not be deleted from the stored results where the row has been deleted from the underlying table in the database. As an alternative such rows may remain in the merged results but the row may be marked with a notification message which explains that the underlying data contained in the row has been deleted.

In some cases a user may wish to update rows in a more selective manner. For instance the user may wish identify rows to be updated based on more specific criteria than identifier values for each row especially where a given identifier value identifies more rows in the query results than the user wishes to update. Thus with respect to the query results depicted in the graphical user interface in if the user selects row to be updated using the above method for updating query results may cause both rows and to be updated because both rows are identified by the same identifier value Patient ID equal to 456 . In some cases the user may wish to update all of the data regarding patient 456. In other cases the user may only wish to update the selected row.

To allow the user to be more selective in updating rows the user may be provided with modified queries which utilize restricting fields. Restricting fields as the name implies restrict modified queries so that only updated rows containing both the identifier value and the value in the restricting field are returned. Values in restricting fields may be referred to as restricting values. As an example of the use of restricting fields if the user uses the graphical user interface to select row to be updated and if the Test Type column is designated as a restricting field the modified query will only update rows with a matching identifier value Patient ID equal to 456 and a matching restricting value in the restricting field Test Type equal to Type A where Type A is the restricting value . According to one embodiment of the invention the user may be allowed to specify which columns in the query results should be used as restricting fields. According to another embodiment of the invention the restricting fields may be defined as an attribute of a logical field in a data repository abstraction described above .

The process for storing and updating stored results utilizing restricting fields is similar to the process depicted in for storing and updating results where restricting fields are not used. According to one embodiment the process for updating results using restricting fields may only differ with respect to modifying the stored query and merging the updated results both of which are described below . Thus the process may begin by storing the query query results and identifier values for the results. After the query information is stored the process may retrieve and display the results and a request to update a selected subset of rows in the stored results may be received. Upon receiving a request to update selected rows the stored query and identifier values may be retrieved and the query may be modified using identifier values and restricting fields to retrieve the selected rows.

After modifying the query at step the loop iterating across each selected row may continue at step . Accordingly the next selected row evaluated by the loop will be row . At step the identifier value for that row Patient ID equal to 900 may be retrieved and at step and a limiting condition with the identifier value and restricting value may be inserted into the query at step . Because the user wishes to update more than one row rows and the limiting condition may be inserted as an alternative disjunctively with respect to the other limiting conditions. Accordingly the modification to the WHERE clause may become Table1.Patient ID 456 AND Table2.Test Type Type A OR Table1.Patient ID 900 AND Table2.Test Type Type B after the second iteration of the loop. Thus when the query is executed the query will only select data containing at least one of the identifier values contained in the selected rows along with the restricting value from the same row causing the query to retrieve updated results for each of the selected rows.

After the loop has iterated across each selected row the loop may finish and the process of updating the results may continue from step . The final result of the query modification process is shown in TABLE XV.

After the process of modifying the query finishes the query may be executed and the results from the execution of the modified query may be obtained. As before the obtained results may depend on any changes which have taken place in the underlying database. For instance after the modified query depicted in TABLE XV is executed against the changed results shown in TABLE IX the results obtained from the modified query will appear as in TABLE XVI.

With respect to the results depicted in TABLE XVI only rows containing results which meet each condition of the modified query are returned. Accordingly only rows containing at least one combination of identifier values and restricting values 456 and Type A or 900 and Type B from the selected subset of rows were selected.

After the updated results from the modified query are returned the updated results may be merged with the stored results. depicts a process for merging updated results with stored results containing restricting fields according to one embodiment of the invention. The process may begin at step and continue to step where the selected rows are removed from the stored results. The rows may be removed from the stored results in order to place the new updated results in the spaces where the old rows were removed described below .

After the selected rows are removed the rows containing both the duplicate identifier values the same identifier values as the selected rows and the duplicate values in restricting fields may be removed at step . The duplicate values may be removed in case more than one row in the stored results and in the updated results match the conditions imposed by a selected row for instance if two rows contained both Patient ID 456 and Test Type Type A . Before where restricting fields were not used see description above with respect to the removal of duplicative rows resulted in removed rows which were not selected. Specifically with respect to row with an identifier value of 456 and Test Type of Type A was removed as well as row which also had an identifier value of 456 but a Test Type of Type B. The extra rows were removed because the only limiting condition used by the modified query was the identifier value 456 and the identifier value was not unique for each row rows and both contain the identifier value of 456 .

Where restricting fields are used the modified query and the merging process are more selective as to how the results are updated. Accordingly where row is selected to be updated the merging process only removes row identifier value of 456 and restricting value of Test Type Type A but row is not removed because the identifier value Patient ID 456 and restricting value Test Type Type B do not match both the identifier and restricting values from the selected row.

The modified results after removal of the selected rows rows and and after removal of the rows with duplicated identifier values and restricting values none of the rows for the exemplary results shown in Table VI may appear as shown in TABLE XI.

At step the number of removed rows may be recorded. The number of removed rows may be recorded in order to inform the user of the changes which have been made to the stored results. After recording the number of removed rows the new rows from the results of the modified query may be placed in the empty rows in the stored results at step . As described above if there are fewer updated rows returned by the modified query than empty rows in the stored results some rows in the stored results may remain empty until the rows are sorted. If there are more updated rows returned by the modified query than empty rows in the stored results the additional rows may be inserted at the end of the stored results at step . After the updated rows have been inserted the ORDER BY clause of the modified query may be applied to the merged results at step . After the updated rows from the modified query results have been inserted into the stored results and the ORDER BY clause has been applied the merged results may appear as shown in TABLE XII.

After the updated rows and the stored results have been merged and ordered a determination may be made of whether the number of rows has changed or whether the order of the rows has changed. If the number of rows has changed or the order has changed a warning may be displayed to the user at step . After the process of merging the results is finished the process of saving and updating the results may continue at step . As before the merged results may be displayed and the process of updating the results may then terminate.

While embodiments are described above with respect to usage of a single restricting field other embodiments are contemplated in which multiple restricting fields are utilized. Accordingly multiple restricting fields as well as identifier values may be used to more specifically select and update rows from stored query results.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

