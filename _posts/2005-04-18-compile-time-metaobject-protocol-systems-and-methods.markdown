---

title: Compile time meta-object protocol systems and methods
abstract: The subject invention pertains to a compilation system and meta-object protocol to facilitate interaction with objects of various types including but not limited to XML documents. More specifically, a delineator or dot operator can be extended to hide idiosyncratic details of interacting with objects. Code details can be generated by a compiler behind the scenes. This enables a programmer to achieve the same results while writing much simpler and intuitive code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07665073&OS=07665073&RS=07665073
owner: Microsoft Corporation
number: 07665073
owner_city: Redmond
owner_country: US
publication_date: 20050418
---
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The subject invention relates generally to computers and more particularly toward compilers and computer programming languages.

Programming languages continue to evolve to facilitate specification by programmers as well as efficient execution. In the early days of computer languages low level machine code was prevalent. With machine code a computer program or instructions comprising a computer program were written with machine languages or assembly languages and executed by the hardware e.g. microprocessor . These languages provided a means to efficiently control computing hardware but were very difficult for programmers to understand and develop sophisticated logic. Subsequently languages were introduced that provided various layers of abstraction. Accordingly programmers could write programs at a higher level with a higher level source language which could then be converted via a compiler or interpreter to the lower level machine language understood by the hardware. Further advances in programming have provided additional layers of abstraction to allow more advanced programming logic to be specified much quicker then ever before. However these advances do not come without a processing cost.

Compilers and or interpreters bear the burden of translating high level logic into executable machine code. In general a compilers and or interpreters are components that receive a program specified in a source programming language e.g. C C Visual Basic Java . . . and covert the logic provided thereby to machine language that is executable by a hardware device. However the conversion need not be done verbatim. In fact conventional compilers and or interpreters analyze the source code and generate very efficient code. For example programmers write code that sets forth a logical flow of operations that is intuitive and easy for humans to understand but is often inefficient for a computer to execute. Compilers and or interpreters can identify inefficiencies and improve program performance at the hardware level by eliminating unnecessary operations and or rearranging the execution of instructions but still achieving the intended results. In this manner programmers can create robust and efficient software programs.

Extensible Markup Language XML has become quite a popular programming language. XML is a markup language that provides a format for describing structured data. Similar to HTML Hyper Text Markup Language XML is a tag based language that defines a strict tree structure or hierarchy. XML is a derivative of Standard Generalized Markup Language SGML that provides a format for describing and exchanging structured data in an open text based format. Unlike HTML which is a display oriented language XML is a general purpose language for representing structured data without including information pertaining to how it is to be displayed. XML consists of elements and attributes among other things.

XML elements are structural constructs that consist of a start tag an end or close tag and the information or content that is contained between the tags. A start tag is formatted as and an end tag is formatted as . In an XML document start and end tags can be nested within other start and end tags. All elements that occur within a particular element must have their start and end tags occur before the end tag of that particular element. This defines a strict tree like hierarchical structure. Each element forms a node in this tree and potentially has child or branch nodes. The child nodes represent any XML elements that occur between the start and end tags of the parent node.

XML can accommodate an infinite number of database schemas. Within each schema a dictionary of element names is defined. The dictionary of element names defined by a schema is referred to as a namespace. Within an XML document element names are qualified by namespace identifiers. When qualified by a namespace identifier a tag name appears in the form namespace tagname . This model enables the same element name to appear in multiple schemas or namespaces and for instances of these duplicate element names to appear in the same XML document without colliding. Start tags can declare an arbitrary number of attributes which declare property values associated with the element being declared. Attributes are declared within the start tag using the form where an attributethrough attributeare declarations of an arbitrary number of tag attributes. Each attribute declaration is of the form attributeName attributeValue where each attribute is identified by a unique name followed by an character followed by the value of the attribute.

To facilitate such interaction with XML documents via high level object oriented programming languages for instance an XML Application Program Interface API can be employed. An XML API provides a set of rules or a protocol to enable communication between an XML document and client application. There are a number of different types. For example there are push APIs like SAX Simple API for XML where an API parser serializes a document and pushes the parsed data to a client application. Another type of XML API is a tree based API such as DOM Document Object Model . With this type of API an XML document is parsed and an object model comprising a tree or hierarchy of nodes for XML elements attributes etc is constructed and housed in memory. Methods can then be directed at the object model for retrieving modifying and adding data to the document. There are also query based APIs. With these XML documents are searched and data is returned in accordance with the search utilizing XPath XML Path Language for example. XPath is a language that locates and addresses information in an XML document by navigating through its elements and attributes. XPath queries are specified in terms of paths and expressions. In essence XPath is incorporated into a programming application e.g. C Java Visual Basic . . . just like SQL Structured Query Language . A user can query a database from within an application by specifying SQL queries. A database management system will receive these queries and return the results. Likewise an XPath query can be specified within an application and an XPath engine will process the query against an XML document and return requested information.

Conventional APIs for processing XML are notoriously difficult to use. They provide a document object model over data in the XML document utilizing types such as XmlNode and XPathNavigator. To navigate a typical XML document object model a user has to deal with several classes whose interaction is often complex and counter intuitive. For example the System.Xml.XPath namespace contains a variety of classes that allow users to load an XML document to navigate toward specific nodes using XPath queries represented by plain strings and then imperatively iterate through these nodes to pick out values that a user is ultimately interested in retrieving. The iterator iterates over a collection of navigators each navigator has the Select method that returns an iterator over the new set of navigators that points to the nodes that were selected.

The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the subject invention concerns systems and methods to facilitate simple and intuitive programming. More specifically compilation systems and methods are provided that support overloading a delimiter operator such as the dot operator to hide programmatic details from programmers. These details can be determined and automatically generated and injected under the covers by a compiler. According to a specific aspect of the subject invention access to XML documents is made easier by the systems and methods provided herein. However the subject invention is not so limited.

According to an aspect of the subject invention a compilation system is provided comprising a receiver component for receiving a delimited programmatic expression a type detection component to determine a type associated with the expression and a generation component that generates a translated expression. The translated expression can comprise at least a portion that includes a generic method call initially not bound to a specific implementation. For example if a programmatic expression is delimited by a dot operator a generic method Dot can be generated. Later a specific implementation can be bound to the generic method for example based on the expression type. Hence based on the type of the object or thing that is to be accessed there is a special protocol or meta object protocol that is executed that provides some additional work behind the scenes that is invisible to a programmer.

According to an aspect of the invention a programmer need only specify an expression or qualified identifier comprising related elements delimited by some object or character. The subject systems and methods can automatically generate the proper code for example based on the type of the object being accessed. Therefore access to XML documents can be specified the same way access to class members is specified in typical object oriented programming languages. Upon compilation the appropriate protocols will be executed to facilitate the specified data access.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the invention may be practiced all of which are intended to be covered by the present invention. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.

The present invention is now described with reference to the annexed drawings wherein like numerals refer to like or corresponding elements throughout. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed. Rather the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention.

As used in this application the terms component and system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an instance an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs.

Artificial intelligence based systems e.g. explicitly and or implicitly trained classifiers can be employed in connection with performing inference and or probabilistic determinations and or statistical based determinations as in accordance with one or more aspects of the subject invention as described hereinafter. As used herein the term inference refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems e.g. support vector machines neural networks expert systems Bayesian belief networks fuzzy logic data fusion engines . . . can be employed in connection with performing automatic and or inferred action in connection with the subject invention.

Furthermore the subject invention may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed invention. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the subject invention.

Turning initially to a compilation system is illustrated in accordance with an aspect of the subject invention. Compilation system can include receiver component type detection component and generation component . Receiver component can receive and or retrieve expressions or qualified identifiers. According to an aspect of the invention such expressions can be delimited programmatic expressions. In particular the programmatic expression can be a member access expression of the form Member Access Expression Receiver Expression Delimiter Message Identifier. For example such expressions can correspond to X.Y. X Y X. Y X.Y.Z and the like where there are at least two elements e.g. X Y . . . separated by a delimiter e.g. dot . series of dots . . . exclamation point pound sign . . . . Furthermore it should be appreciated that the message identifier can take on any of a myriad of forms including but not limited to a identifier pr b attribute c An Attribute d prefix name e prefix name f prefix name or any combination thereof. Receiver component is communicatively coupled to type detection component and generation component . Type detection component can determine the type associated with an element in the received programmatic expression. In particular the type detection component can determine type from the element preceding the delimiter or the first element. Such an element can correspond to an object or class defining the object. The type determination can be made by analyzing the declared element and its return type and or checking a type declaration preceding the specified element as is often specified. The determine type can then be communicated to the generation component from the type detection component . Accordingly the generation component can receive among other things type information as well as the programmatic elements themselves.

Generation component can generate or produce translated expressions. Programmatic expressions are often simplified or abbreviated to facilitate straightforward and intuitive programming. Behind the scenes a compiler or interpreter component s can translate the expression into its proper format. In essence an abstraction of the actual implementation is provided for specification by programmers to increase programming efficiency and eloquence. Generation component provides similar functionality here. In the simple instance where there are two elements separated by a delimiter such as a dot. The analysis component can analyze the second element relative to the first. A determination can be made as to whether the second element represents or is a member of the type of the first element. For example a determination can be made concerning whether the second element is a property or field of the first element type. If it is then a translated expression can be generated that incorporates standard or normal methods for the delimiter such as get and set methods. For example if an expression is C.age where C is of type Customer and age is a property of the type or class Customer the translated expression C.get age can be generated. However if the second element is not a member or direct member of the type of the first element then the generation component can generate a generic method call as the translated expression. For example the generic method call can for an expression X.Y could be X.Dot Y . This generic method call does not specify a particular translation. In accordance with an aspect of the invention the generic method call increases the flexibility associated with the expression as it is not bound to any particular implementation initially. The generic method implementation later can be tied to an implementation based on the type of the first element for instance. Stated differently the delimiter operator or in the example above the dot operator can be overloaded to hide an interpretive layer or provide an additional layer of abstraction.

It should be appreciated that compilation system can correspond to or implement a compile time meta object protocol. For instance generation component can initially produce a generic expression or method call based on the received expression. The generic method call can be generated by a compiler initially upon analyzing a received expression. As provided supra the translated expression can include the generic expression such as X.Dot Y for example. The binding component binds or ties the generic expression to a particular implementation. In particular the binding component can bind the generic expression or more specifically the generic method call to the type provided by the type detection component . For example if the type is an XML object type the generation component would be bound to specify XML code that replaces the generic method in the translated expression. For example X.Dot Y could be replaced with X.Current.SelectChildren Y . In other words the generation component can produce a translated expression in accordance with a type specific implementation of the generic method call in this example the Dot method. This indirection or generality provided by the system of the subject invention enables compiler extensibility. For every different data form or type the compilation thereof can be different rather than hard coded or tied to a specific implementation.

Turning to a compilation interaction system is illustrated in accordance with an aspect of the subject invention. System includes a type component and a compilation component . Type component and compilation component are communicatively coupled. For example the components may communicate via data packets transmitted there between. A type component defines an object and can include among other things one or more methods and associated implementations. Accordingly the type component can correspond to a programmatic class as specified in an object oriented programming language. The compilation component inter alia can generate a generic method call associated with translating all or part of an expression being compiled. For example the generic method call can be the dot as previously discussed e.g. X.Dot Y . The generic method call is very flexible as the implementation of that method is not bound to anything specific. The type component can provide a specific implementation of the generic method for its particular type and objects of that type. For example it can include a Dot method implementation. In order to obtain the implementation for its generic method and generate a translated expression the compilation component must first locate a specific type component and subsequently negotiate therewith. In essence the compilation component communicates and informs the type component that it has a particular generic method and possibly some arguments that are associated with the type component . The type component can then inform the compilation component how to implement the method. In a conventional language translation system the implementation is hard coded. Therefore if a user specifies C.age it is always translated to C.get age for example. This is not very flexible or extensible. Here the compilation component calls a generic method and the type component provides some complex logic that the compiler does not know about and yet it still the compilation component produces the desired behavior.

As will be appreciated by those artisans of ordinary skill in this field various portions of the disclosed system may include or consist of artificial intelligence or knowledge based components. For example the generation component of and may use a neural network to facilitate generation of translation expressions. Furthermore the subject invention can employ classifiers that are explicitly trained for example using generic training data as well as implicitly trained such as by observing user behavior or receiving extrinsic information. For example SVM s are configured using a learning or training phase within a classifier constructor and feature selection module. Thus the classifier s can be used to automatically perform a number of functions.

According to a particular aspect of the invention such a system as described above can be utilized to facilitate access to XML data and documents. Existing application programming interfaces APIs for processing XML are notoriously difficult to use. They provide a document object model over the data in the XML document using types such as XmlNode and XPathNavigator. To navigate a typical XML document object model a user has to deal with several classes whose interaction is often complex and counter intuitive. For instance the System.Xml.XPath namespace contains a variety of classes that allow users to load an XML document to navigate towards specific nodes using XPath queries represented by plain strings and then imperatively iterate through these nodes to pick out the values with which a user is ultimately interested. The iterator iterates over a collection of navigators that points to the nodes that were selected.

Consider the complexity in the following example where two documents that contain books are joined based on their title and the output includes a list of the books and their prices in each document. A user can then navigate the list by creating navigator objects on the document and the calling the Select . . . method to create iterators that in turn contain navigators on the selected nodes etc.

The developer writing this code needs to be intimately familiar with the interaction between the various classes as provide above. In addition the developer needs to understand the subtle semantics of the XPath query language write many imperative statements to explicitly navigate through a tree hierarchy and retrieve the appropriate values. Further yet the developer needs to understand the additional layer of interpretation of using various methods such as Select and SelectChildren . In contrast to navigate standard object models or classes programmers can directly use the more traditional object.name operator to access children of objects rather than calling object.SelectChildren name .

One way to allow for a more direct navigation of XML documents using ordinary member access is to deserialize an XML document into a corresponding object graph where roughly each XML element is represented by a class that contains field or property members of each child element of that particular element. However there are several downsides to this approach. First of all this requires that the schema of the document in question be known at program construction time which is often not the case. Even when the document schema is available the XML and object schema languages differ very significantly and in many cases it is not possible to create a faithful mapping between XML schema and a set of object oriented classes. Furthermore deserialization invariably leads to loss of fidelity of the XML document meaning that round tripping a document by first deserializing it into an object and then serializing back into XML does not result with which you started.

According to an aspect of the subject invention a delimiter operator such as the dot operator can be overloaded to hide the interpretive layer of having to call Select and SelectChildren for example allowing a user to directly access members on a receiver of type XML. A compiler can generate the required code to the appropriate member selection methods under the covers. This provides the same results as above by writing much simpler and intuitive code. Consider the following code snippet the same functionality as the previous code snippet. The new code is bold faced.

In this example once the DynamicXPathDocument is created the top level elements now seem to appear as regular properties of the bibDoc object. Selecting bibDoc.book.bib returns a collection of DynamicXpathNavigator objects that point to applicable child nodes or an attribute with that property name. This collection itself can have a property that represents the child nodes of each navigator in that collection. Once this collection is cast to a string implicitly or explicitly the current navigator value is returned.

The conventional compilation of the dot . operator is employed to search in the receiver type left side of the dot for the member that matches the specified member right side of dot . However in accordance with an aspect of the invention this technique is modified to add behavior for when this conventional search fails. However a variation of this scheme can be to always insert the non standard behavior.

If the XML API class does not have a direct member that matches the member after the dot a compiler system can insert instead a generic method call to the Dot or alternatively DotAttribute. These methods return the applicable XML nodes by calling applicable methods so that the expressions that use the dot operator are composable. To illustrate such composability consider the following code fragment 

DynamicXPathDocument bibDoc new DynamicXPathDocument bibLocation foreach DynamicXPathNavigator book in bibDoc.bib.book 

Here the bibDoc does not have a member called bib thus a generic Dot method can be inserted that specifies bib as an argument as follows 

The return type for the Dot method is DynamicXPathNavigator on DynamicXPath Document and such type does not have a book member. Hence another call can be inserted to the Dot method. As a result the expression bibDoc.bib.book is translated into the expression bibDoc.Dot bib .Dot book as shown in the following code snippet Foreach DynamicXPathNavigator book in bibDoc.Dot bib .Dot book 

It should also be appreciated that programmers as well as generation component and and compilation component may have to compensate for particular identifiers differently. As discussed previously an expression like books.price can be specified. However identifiers need not be specified as single word strings. For example an identifier could correspond to an XML tag . Uses of dashes or minus signs are legal in XML. However if a user specified books.large print books this could be problematic. For example a language such as C could interpret this arithmetically as books.large minus print minus books which would likely generate an error. Accordingly the subject invention contemplates use of additional delimiters to eliminate such confusion for example books. large print books books. or books.large print books could be employed.

Furthermore various delimiters can map to various XPath axes e.g. child descendant ancestor parent attribute namespace . . . . For instance a series of two dots . . . can map to descendents while a series of three dots . . . could map to ancestors and the like.

In view of the exemplary systems described supra methodologies that may be implemented in accordance with the present invention will be better appreciated with reference to the flow charts of . While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the present invention is not limited by the order of the blocks as some blocks may in accordance with the present invention occur in different orders and or concurrently with other blocks from what is depicted and described herein. Moreover not all illustrated blocks may be required to implement the methodology in accordance with the present invention.

Additionally it should be further appreciated that the methodologies disclosed hereinafter and throughout this specification are capable of being stored on an article of manufacture to facilitate transporting and transferring such methodologies to computers. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media.

Turning to a compilation method is illustrated in accordance with an aspect of the subject invention. At a delimited expression qualified identifier or member access expression is received. For example the expression could be X.Y. In such an example X represents an object and Y represents an associated element or element associated with the object in some manner. At a translated expression is generated. Initially the translated expression may include a generic method call not bound to any particular implementation. The generic method call specifies that there is some relationship between the object and the associated element. By way of example the produced generic method call can correspond to a dot method where the associated element is an argument thereto such as Dot Y . Thus the translated expression corresponds to X.Dot Y and the generic dot method can be bound to a particular implementation based at least in part upon the type of the object X at a later time e.g. compile time .

Turning to a compilation methodology is illustrated in accordance with an aspect of the subject invention. Methodology begins with similar actions as methodology of . At a delimited programmatic expression is received. The programmatic expression can include at least two elements separated by at least one delimiter. The first element to the left of the delimiter can correspond to an object while the element s to the left of the delimiter can be elements associated with the object At the type of the element to the left of the delimiter is determined. At a determination is made as to whether the element to the right of the delimiter is a member of the type of the element to the left of the delimiter. For example an item can be a member of a type if it corresponds to a field or property among other things of the type or class implementing the type. If the element is a member of the type than at a direct getter method is specified for the expression. For example the expression can be transformed from X.Y to X.get Y . This would be a standard implementation for the dot operator. However if the element is not a member of the type of the element to the left of the delimiter then at a determination is made as to whether the right element is an attribute. This can be determine for example by identifying whether the element or the delimiter includes a symbol such as . If the element to the right of the delimiter is an attribute than a generic method can be generated for the element which indicates that it is an attribute such as DotAttribute Y . Accordingly an original expression of X.Y can be transformed to X.DotAttribute Y for example. If at it is determined that the element is not an attribute then at a generic method call can be generated such as Dot Y . An original expression of X.Y can in this instance be transformed to X.Dot Y .

It should be appreciated that methodology is merely exemplary. A similar methodology can be employed for other particular elements including but not limited to selection of descendants. For example a delimiter that includes three dots . . . can indicate that a descendant method call should be selected for the translated expression.

As mentioned previously the subject invention contemplates employment with respect to XML. The following code sample shows how a portion of methodology can be implemented for instance in a compiler in accordance with an aspect of the subject invention. In the subject example a method VisitQualifiedIdentifier returns the expression that represents the member QualifiedIdentifier of a specific class. If the expression is null meaning the member was not found then the following method GetDynamicProperty can be called.

Furthermore it should be noted that in XML there is a notion of namespaces for example . What this means is that all names are prefixed with a specified namespace. For example a user could specify a namespace in a qualified identifier or programmatic expression such as book.x price. The systems and methods of the subject invention can see that colon and determine that they need to lookup the namespace. When a generic method call is generated the namespace can be provided as the second argument for example books.Dot price http . . . .

The following sections provide examples of how generic method calls such as Dot can be implemented using the System.Xml.XPath classes namely XPathDocument XPathNavigator and XPathNodeIterator.

The first class created is XPathNavigatorCollection as provided herein as Appendix A. This class is the return type for every Dot method. It returns a collection of DynamicXPathNavigator which is a wrapper around XPathNavigator. Each navigator points to a specific Xml node. It should be noted that the DotAttribute is not implemented in this class since an Xml attribute cannot have child nodes.

The next class is the DynamicXPathDocument class which is a wrapper for the XPathDocument class. This class is initialized by passing the URL Uniform Resource Location for the XML document similar to the XPathDoucment class. Furthermore the Dot and DotAttribute methods are implemented herein. For example 

Finally the last class is DynamicXPathNavigator. This class is a wrapper for the XPathNavigator class which points to a specific XML node.

These three classes in combination with specialized compiler support for overloading member access on these types provide a way to overload the . operator in an XML API and translate the member selection into a search for the applicable XML node that matches the identifier name. This provides a much more natural and straightforward means and mechanism to read and maintain code.

Compiler can accept as input a file having source code associated with processing of a sequence of elements. The source code may include code defining a collection of elements and methods for traversing such elements. Compiler may process source code in conjunction with one or more components for analyzing constructs and generating or injecting code.

A front end component reads and performs lexical analysis upon the source code. In essence the front end component reads and translates a sequence of characters e.g. alphanumeric in the source code into syntactic elements or tokens indicating constants identifiers operator symbols keywords and punctuation among other things.

Converter component parses the tokens into an intermediate representation. For instance the converter component can check syntax and group tokens into expressions or other syntactic structures which in turn coalesce into statement trees. Conceptually these trees form a parse tree . Furthermore and as appropriate the converter module can place entries into a symbol table that lists symbol names and type information used in the source code along with related characteristics.

A state can be employed to track the progress of the compiler in processing the received or retrieved source code and forming the parse tree . For example different state values indicate that the compiler is at the start of a class definition or functions has just declared a class member or has completed an expression. As the compiler progresses it continually updates the state . The compiler may partially or fully expose the state to an outside entity which can then provide input to the compiler .

Based upon constructs or other signals in the source code or if the opportunity is otherwise recognized the converter component or another component can inject code corresponding to dot methods among other things. Rules coded into the converter component or other component indicates what must be done to implement the desired functionality and identify locations where the code is to be injected or where other operations are to be carried out. Injected code typically includes added statements metadata or other elements at one or more locations but this term can also include changing deleting or otherwise modifying existing source code. Injected code can be stored as one or more templates or in some other form. In addition it should be appreciated that symbol table manipulations and parse tree transformations can take place.

Based on the symbol table and the parse tree a back end component can translate the intermediate representation into output code. The back end component converts the intermediate representation into instructions executable in or by a target processor into memory allocations for variables and so forth. The output code can be executable by a real processor but the invention also contemplates output code that is executable by a virtual processor.

Furthermore the front end component and the back end component can perform additional functions such as code optimization and can perform the described operations as a single phase or in multiple phases. Various other aspects of the components of compiler are conventional in nature and can be substituted with components performing equivalent functions. Additionally at various during processing of the source code an error checker component can check for errors such as errors in lexical structure syntax errors and even semantic errors. Upon detection error checker component can halt compilation and generate a message indicative of the error.

In order to provide a context for the various aspects of the invention as well as the following discussion are intended to provide a brief general description of a suitable computing environment in which the various aspects of the present invention may be implemented. While the invention has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices microprocessor based or programmable consumer electronics and the like. The illustrated aspects of the invention may also be practiced in distributed computing environments where task are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects of the invention includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like displays e.g. flat panel and CRT speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems power modems and DSL modems ISDN adapters and Ethernet cards.

One possible communication between a client and a server may be in the form of a data packet transmitted between two or more computer processes. The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

What has been described above includes examples of the present invention. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly the present invention is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has and having are used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

