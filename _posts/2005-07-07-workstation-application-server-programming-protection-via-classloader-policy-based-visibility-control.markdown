---

title: Workstation application server programming protection via classloader policy based visibility control
abstract: Provided is a method for providing Java modularity class loader protection by controlling the visibility of WebSphere, service provider, library and utility code interfaces. Interface access authorization is checked once, during module and class loading to effectively protect vulnerable programming interfaces, eliminating permission checking during execution. Code in a WebSphere Application server (WAS) computing environment is categorized into a finite number of sets in which one permission type is assigned to each set and the code in each set runs at the same privilege zone. Each set exposes programming interfaces to provide functional service and code in a particular set can only access code in the same or a lower security zone set. Also provided is a technique for explicitly providing to specific modules in lower security zones access to modules or designated interfaces of modules in higher security zones.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08447975&OS=08447975&RS=08447975
owner: International Business Machines Corporation
number: 08447975
owner_city: Armonk
owner_country: US
publication_date: 20050707
---
The present invention relates generally to computer security and more specifically to improving performance without compromising security protection mechanisms.

With the advent of the Internet sometimes referred to as the web businesses and consumers have multiple means of communication not previously available including but not limited to business to business B2B and business to consumer B2C links. As businesses seek to take advantage of the web some companies have provided specific applications called e business applications that work in that particular environment. In addition companies such as International Business Machines Corporation IBM of Armonk N.Y. have developed products that facilitate the deployment integration execution and management of e business applications. One such IBM product is WebSphere which encompasses tools for developing e business applications and middleware for running web based applications. One part of WebSphere is a WebSphere Application Server WAS which is a run time component of the WebSphere family of products. Basically WAS is a Java process with a Java Virtual Machine JVM .

Currently WAS uses a Java2 security model to ensure the integrity of applications and the WebSphere runtime environment. There are two closely related problems with the Java2 security in WAS. First Java2 imposes a significant runtime performance penalty and second the process for defining precise security permissions is cumbersome. For example permission checking associated with these two issues imposes a twenty two percent 22 performance overhead running a version of Trade3 benchmark Jave2 Platform Enterprise Edition J2EE application.

The Java Versioning and Modularity working group have proposed a modular approach to enhance WAS versioning and release to release compatibility management. The basic approach is to group Java archives JARs into modules with explicitly defined interfaces among modules. Each module exposes public interfaces with an explicit EXPORT definition. Each module also declares dependencies on other modules with an explicit IMPORT definition. This modular approach is in conformity with the OSGi Specifications.

Java2 security employs permission checking to enforce the access control policy. Under the standard Java2 implementation permission checking is performed every time an interface is accessed during runtime. This is the primary source of the performance penalties of the standard Java2 security. The J2EE runtime environment default Java2 security policy allows J2EE applications a very limited set of permissions to ensure runtime integrity. When a J2EE application is deployed to a WAS runtime environment an information technology IT administrator is prompted to take necessary actions if that application requires additional permissions. To determine whether additional permissions can be granted to the application requires that IT administrators have a good understanding of the implications of granting particular permissions to the application.

What is needed is a method of security protection that does not have an inverse impact on performance i.e. does not impose the typical Java2 runtime performance penalty and does not require a user to set a wide variety of permission settings for every class or module.

Provided is a method for providing Java modularity class loader protection by controlling the visibility of WebSphere service provider library and utility code interfaces. Interface access authorization is checked once during class loading to effectively protect vulnerable programming interfaces. Unlike typical Java protection which executes permission checking every time an interface is accessed the disclosed method does not impose runtime performance penalties.

The claimed subject matter applies and extends the Java Modularity work using a new approach to ensure runtime integrity with less performance overhead and ease the policy management burden on IT administrators. The claimed subject matter is not a replacement of Java2 security model. It is a complimentary technology designed to protect programming interfaces.

In the claimed subject matter the code in the WAS computing environment is categorized into a finite number of sets and the code in each set runs at the same privilege level. Instead of using the standard Java2 fine grained permission types which are very hard to manage the number of permission types is reduced by assigning one permission type to each set.

The code in an exemplary WAS computing environment described below is categorized into four sets or zones trusted service provider privileged and standard with decreasing level of privilege. Each set typically exposes programming interfaces to provide functional service. A method in a particular programming interface that manipulates sensitive data is considered to be a security sensitive method that needs to be protected. The typical way to protect a sensitive method using Java2 Security is to require users of that method i.e. other code or modules to have appropriate permissions and for the method to perform permission checking every time the method is executed. In this manner only authorized code can access the protected method.

As explained above a server runtime environment supports security zones each zone with a corresponding privilege level. In the described embodiment different zones include a trusted code or zone a service provider utility library SP zone a privileged zone and a standard or application zone. Applications are typically assigned to either the privileged zone or by default to the standard zone. In the following example an Operating System OS and a Java Virtual Machine JVM are not defined as zones but rather are the platform on which the claimed subject matter is implemented. In another embodiment the OS and JVM may be defined as zones with the OS as the highest security zone and the JVM as the next highest security zone.

In the described embodiment the trusted zone is the highest zone which gives code in the trusted zone access to any code or modules in the trusted or any other zone provided that the accessed code has visibility to the trusted zone code as far as class loader is concerned. Note that programming interface protection is closely related to class loader policy. An interface can be accessed if both the security policy allows such access and the class is visible according to the class loader policy. The SP zone is the next highest which implies that code in the SP zone by default has access to any SP zone code or modules and any code or modules in lower security zones. SP zone modules are able to access trusted zone modules only when explicitly provided access. In a similar fashion modules in the privileged zone the next highest zone by default have access to any privileged zone code or modules and any code or modules in lower security zones. Privileged zone modules are able to access trusted zone and SP zone modules only when explicitly provided access. Modules in the standard zone by default only have access to other modules in the standard zone. Standard zone modules are able to access trusted zone SP zone and privileged zone modules only when explicitly provided access.

Also provided is a technique for explicitly providing to specific modules in lower security zones access to modules or designated interfaces of modules in higher security zones.

Although described with particular reference to a Java runtime environment the claimed subject matter can be implemented in any server architecture in which interface security is an issue. Those with skill in the computing arts will recognize that the disclosed embodiments have relevance to a wide variety of computing environments in addition to those described below. In addition the methods of the disclosed invention can be implemented in software hardware or a combination of software and hardware. The hardware portion can be implemented using specialized logic the software portion can be stored in a memory and executed by a suitable instruction execution system such as a microprocessor personal computer PC or mainframe.

In the context of this document a memory or recording medium can be any means that contains stores communicates propagates or transports the program and or data for use by or in conjunction with an instruction execution system apparatus or device. Memory and recording medium can be but are not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device. Memory an recording medium also includes but is not limited to for example the following a portable computer diskette a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or flash memory and a portable compact disk read only memory or another suitable medium upon which a program and or data may be stored.

One embodiment in accordance with the claimed subject is directed to a programmed method for providing Java modularity class loader protection by controlling the visibility of WebSphere service provider library and utility code interfaces. The term programmed method as used herein is defined to mean one or more process steps that are presently performed or alternatively one or more process steps that are enabled to be performed at a future point in time. The term programmed method anticipates three alternative forms. First a programmed method comprises presently performed process steps. Second a programmed method comprises a computer readable medium embodying computer instructions which when executed by a computer performs one or more process steps. Finally a programmed method comprises a computer system that has been programmed by software hardware firmware or any combination thereof to perform one or more process steps. It is to be understood that the term programmed method is not to be construed as simultaneously having more than one alternative form but rather is to be construed in the truest sense of an alternative form wherein at any given point in time only one of the plurality of alternative forms is present.

Turning now to the figures is a block diagram of an exemplary computing system architecture that incorporates the claimed subject matter. A central processing unit CPU is coupled to a monitor a keyboard and a mouse which together facilitate human interaction with computing system . Attached to CPU is a data storage component which may either be incorporated into CPU i.e. an internal device or attached externally to CPU by means of various commonly available connection devices such as but not limited to a universal serial bus USB port not shown . Data storage is illustrated containing a policy file which is described in more detail below in conjunction with .

CPU is connected to the Internet which is also connected to a server computer . Although in this example CPU and server are communicatively coupled via the Internet they could also be coupled through any number of communication mediums such as but not limited to a local area network LAN not shown .

Executing in conjunction with OS is a Java Virtual Machine JVM . Java is a high level programming language published by Sun Microsystems Inc. of Santa Clara Calif. JVM is a runtime engine that executes Java code. In the following examples the claimed subject matter is described in relation to Java code the Java Runtime Environment JVE and JVM although those with skill in the programming arts should appreciate that the claimed subject matter is applicable to a wide variety of computing environments.

According to the claimed subject matter run time environment is compartmentalized into security sets or zones. In this example the security zones include a trusted zone a service provider utility library SP zone a privileged zone and a standard zone . The closer a particular zone is to OS and JVM the higher the security level. In other words trusted zone is a higher security level than SP zone SP zone is a higher security level than privileged zone and privileged zone is a higher security level than standard zone . In addition the relationships among the zones and is transitive i.e. trusted zone is a higher security level than privileged zone and standard zone in addition to SP zone . In this example standard zone lies outside of OS JVM and all security zones and . In other words standard zone is the lowest security level and serves as a default security level for any code or module that has not been designated to be within any other zone or .

A higher security level implies that the corresponding logic needs a higher degree of protection from both inadvertent access and deliberate attempts to compromise the integrity of the particular level or zone. Of course although not defined in the following example as security zones OS and JVM also require high levels of security. In an alternative embodiment OS and JVM could be defined as security zones in which case OS may be the highest security zone and JVM the second highest.

In model modules in higher zones may access any module in the same or lower zones. For example any module in trusted zone can access interfaces to modules in trusted zone SP zone privileged zone and standard zone . Modules in SP zone can access interfaces of other modules in SP zone privileged zone and standard zone but requires specific authorization to access any interfaces of modules in trusted zone . Any module of privileged zone is able to access interfaces for other modules in privileged zone and standard zone but requires specific authorization to access any interfaces of modules in trusted zone and SP zone . Any module in standard zone is able to access interfaces for other modules in standard zone but requires specific authorization to access any interfaces of modules in trusted zone SP zone and privileged zone .

Illustrated within zones and are exemplary code modules. A first module or mod  and a second module or mod  are within trusted zone . A third module or mod  is within SP zone a fourth module or mod  is within privileged zone and a fifth module or mod  is within standard zone .

Authorized code in standard zone such as mod  is able to access particular programming modules within trusted zone such as mod  by means of an exemplary application programming interface API provided by a particular corresponding module of trusted zone for that purpose. Typically runtime environment would include multiple APIs service provider programming interfaces SPIs and component programming interfaces CPIs but for the sake of simplicity only illustrates a few representative APIs SPIs and CPIs.

Another type of possible interfaces is an internal interface not shown . An internal interface is typically employed entirely within a particular module although there may be some circumstances when an internal interface is exposed to other modules both within the same security zone and outside of that zone.

Also shown are an API for providing to modules in standard zone access to particular corresponding module in SP zone an API for providing to standard zone modules access to a particular corresponding module of trusted zone and an API for providing to modules of standard zone access to a particular corresponding module of SP zone . In other words specific APIs are visible to designated modules of standard zone and privileged zone to provide access to specific modules in SP zone and trusted zone . A particular API that is exported to a specific zone is automatically exported to zones with privileged level higher than the specific zone. For example the J2EE programming interface is exported to the standard zone. Code in the privileged zone automatically has access to the J2EE programming interface because privileges zone is at a higher security level than standard zone.

Modules of SP zone such as mod  are able to access particular modules of trusted zone such as mod  and mod  via service SPIs such as a SPI . Modules within the same security zone are able to access each other by means of component programming interfaces CPIs such as a CPI a CPI and a CPI . For example mod  is able to access mod  by means of CPI provided by mod  . Mod  is able to access mod  by means of CPI provided by mod  . Similarly mod  is accessed by other modules not shown within SP zone via a CPI . A CPI is useful for defining internal programming interfaces. Modules can expose internal programming interface to other modules in the same zone by declaring those programming interfaces as CPIs.

According to one embodiment of the claimed subject matter exporting and importing programming interfaces to and from an anchor module is one way to declare the target zone for a module. Examples of anchor modules are a SP anchor module corresponding to SP zone and a trusted anchor module corresponding to trusted zone . By declaring import from and export to CPIs of trusted zone anchor module mod  and mod  are installed into trusted zone . Consequently mod  and mod  can access CPIs of each other. In mod  by default is not allowed access to mod  and or mod  CPIs within trusted zone because mod  imports from and exports to the SP anchor .

Mod  mod  and any other programming modules not shown of trusted code access other modules of trusted code via corresponding CPIs without a need to access via trusted anchor . In other words anchors such as SP anchor and trusted anchor provide CPI access to authorized modules within their own security zones and respectively. Techniques for authorizing modules to access specific APIs SPIs and CPIs is described in more detail below in conjunction with .

In the described embodiment a logical module is created at each privilege level as an anchor point as a way to define the privilege level. For example trusted anchor is created at the trusted zone or privilege level . Any module that declares in an IMPORT command the CPI interface of trusted anchor and is also declared in the EXPORT command of trusted anchor implicitly belongs to trusted privilege level . Similarly SP anchor is created to anchor the service provider privilege level. Any module that declares in an IMPORT command the CPI interface of SP anchor implicitly belongs to SP level provided that the module is declared in an EXPORT command of SP anchor . This approach alleviates the need to create a trusted tag to indicate the privilege level of a module. The IMPORT command is described in more detail below in conjunction with .

Each API interface in exported to a specific zone. An API exported to SP zone by default can only be accessed by modules in SP zone and trusted zone . APIs export to privileged zone can be accessed by modules in privileged zone as well as by modules in SP zone and trusted zone . APIs exported to standard zone can be accessed by modules in all four zones and . Modules in a less privileged zone can access APIs exported to a higher privileges zone provided that explicit export policy is defined to allow such an access. Modules in SP zone can access the API and SPI interfaces exported to SP zone by modules in trust zone but not the trusted zone CPI interfaces. Modules in privileged zone typically can access the API interfaces exported to privileged zone by modules in trusted zone and SP zone but not the SPI and CPI interfaces of modules in trusted zone and SP zone .

Through the module export policy a class loader can enforce access control to WAS functions once at module loading and at class loading time. This capability should compare very favorably in terms of performance to the Java2 permission checking which is typically enforced at method invocation time for every invocation.

During a Group Export I Fs block the developer determines the modules and their respective zones that will require access to the APIs CPIs and internal interfaces defined during block . APIs SPIs and CPIs are declared as part of a particular group by means of the EXPORT command. The claimed subject matter provides a mechanism for including as part of the EXPORT command the capability of defining the particular category to which each interface belongs i.e. API SPI or CPI. By default any interface not specifically declared as an API SPI or CPI is assumed to be an interface to a method that is strictly for the internal use of the module.

Additionally a module can use named EXPORT to expose particular interfaces to selected modules. In other words legacy applications and legacy service provider code may have accessed programming interfaces that were not meant for them to use. When WAS enforces the disclosed modular based access control the default interface export policy will no longer allow the legacy code and applications to access those interface. The named EXPORT mechanism allows a module at a higher privileged level to expose specific API SPI and CPI interfaces to the named module at a lower privileged level. Named EXPORT can avoid the problem of expose sensitive interfaces to all modules at a lower privileged level. For example the developer while creating mod1 during block may determine that mod  will need to access CPI which is defined during block which corresponds to mod  . In this example a rule may be added to the module that contains the specified CPI to expose the CPI to mod  in privileged zone . Information created during block may be depending upon the particular implementation either stored internally in the module or saved in policy file . By using named EXPORT a component can also be designed to have multiple modules at different privilege levels.

During a Define Import I Fs block the module defined during block declares dependencies upon other modules or in other words specifies using an IMPORT command other modules interfaces that will be necessary to access during execution or the module. Whether or not a particular interface actually exists or a particular module is authorized to access a declared interface is determined at installation time which is described in more detail below in conjunction with .

Create Module process may fail during module installation if a new module declares one or more interfaces in the new modules IMPORT policy that are not declared in the EXPORT policy or policies of the module or modules that the new module is dependant upon and the IT administrator has decided not to change the other module or modules EXPORT policy. Note that this mechanism provide better protection to the interfaces in that interface access control is determined both by the IMPORT policy of a requesting module as well as by the EXPORT policy of the target module.

In summary the EXPORT policy defines interfaces a module wants to expose to other modules. The IMPORT policy defines the interfaces of other modules a module need to use. A module is allowed to access an interface of another module when it specifies the external in its own IMPORT policy and the other module defines it in its EXPORT policy. The EXPORT policy can be implicit via the API SPI and CPI grouping rules of privileged levels or explicit via the named EXPORT policy.

Finally in an End Create Module block process is complete. The described approach improves system usability. A new application must declare IMPORTs in its modules. When the application is deployed into an environment such as WebSphere Application Server the deployment tool can inform the administrator which privilege level the application would need to be placed at. The concept of the four privilege levels are very easy to be understood compared to the list of granted permissions in a standard WAS.policy file.

During a More Modules block process determines whether or not there are additional modules that need to be installed in runtime system . If so process returns to Get Module block gets the next unprocessed module and processing continues as described above. If not control proceeds to a Resolve I Fs block . As mentioned above a typical runtime system such as runtime system would include many modules.

During Resolve I Fs block process checks the information relating to each module s EXPORT I Fs against each modules IMPORT I Fs to determine whether or not 1 each declared I F actually exists and 2 each IMPORT interface is associated with a module that either has the authority to access the interface of has been named in conjunction with a Named EXPORT designation. During an I F Conflicts block process determines whether or not all interface declarations were resolved during block . If so process proceeds to an Establish Anchors block during which process generates trusted anchor and SP anchor and stores information relating to trusted anchor and SP anchor in policy file . Control then proceeds to an End Install Modules block in which process is complete.

If during block process determines that interface conflict exist then control proceeds to a Resolve Conflicts block during which the conflicts are resolved. An exemplary process corresponding to block is described below in conjunction with . Typically a system administrator would use a graphical user interface GUI to either change or add interface definitions or add modules to runtime system to resolve the conflicts. Of course any resolution might create other resolution issues requiring process to make several iterations through blocks and . Process then returns to Resolve I Fs block and processing continues as described above. Further this description does not address procedures for the situation in which there is no apparent resolution with respect to the interfaces. In that case process may be aborted until a solution is developed. When a module specifies in its IMPORT policy an interface of a module at a higher privileged level and that interface was not defined by the EXPORT policy of the other module the IT administrator will be notified. The IT administrator can resolve this conflict by defining a named EXPORT policy to expose the specified interface to the first module.

During a Register Exports block process transmits to appropriate anchors such as SP anchor and trusted anchor information in the modules and policy file loaded during block . This information includes data about interfaces that are available as the result of the loading of any particular module and the specific zones or modules that are able to access those interfaces. During a Check Imports block process cross references interfaces listed in IMPORT declarations against the interfaces registered during block as the result of EXPORT declarations and policy file . In other words if a particular module declares a particular interface in an IMPORT command process needs to check that both the module corresponding to the interface is loaded but that the requesting module is authorized to access the interface either because of the requesting module s zone or because of a named EXPORT command.

During an I Fs Confirmed block process determines whether or not all interfaces declared during block are resolved with respect to I Fs declared during block . Typically all I F resolution issues would have been resolved during Resolve I Fs block I F conflicts block and Resolve conflict block of process . The actions taken during process represent one additional pre runtime check that enable the claimed subject matter to detect and if desired integrate legacy applications. If during block process determines that all I F issues are not resolved then process proceeds to a Throw Exception block during which process takes whatever action the developer programmed the system. In one embodiment to take under the transmitted message takes the form of a graphical user interface GUI not shown that is displayed on monitor that enables the notified user to take corrective action.

This specification does not specify the type of action that may be taken or how process is notified of any action. A typical action may be to generate an audit record to log the error condition and the failure of the class loading. Alternatively a system administrator notified during block has elected to invoke a Modify Policy process see .

If during block process determines that all I Fs are confirmed control proceeds to an End Module Load block in which process is complete. Note that checking whether an interface can be accessed by a class and module is handled during module loading and class loading time rather than at runtime. In other words there is no additional permission checking at class execution time and hence improved access. According to the claimed subject matter unauthorized I F requests are blocked by simply not providing the requested Import information. In effect a targeted export I F is invisible to an unauthorized import I F. Typically a request to access such an import interface would result in an exception being thrown during runtime. I Fs handled in this manner do not need to execute permission checking during runtime because inappropriate I F request are impossible to execute. This feature improves runtime performance.

Process starts in a Begin Modify Access block and control proceeds immediately to an Identify Imports block . During block process identifies problematic access requests discovered during Check Imports block of Module Load process described above in conjunction with . As explained above a problematic I Fs discovered during block can be the result of a particular module that declares a particular interface in an IMPORT command but either the module corresponding to the interface is not loaded or the requesting module is not authorized to access the interface. Another potential source of a problematic access request is the result of a scan process that pairs module access requests from legacy applications to EXPORT declarations of modules that conform to the provided security system.

During a Select Import block during which process selects one of the problematic access request for resolution. During an Identify Issue block process determines whether the access request corresponds to an existing I F declared in an EXPORT command described above in conjunction with or a non existent I F. During a Policy Issue block the user determines whether or not the issue identified during block is something that can be addressed by modify the I F policy as articulated in police file . If so during a Modify Policy block process make the necessary adjustments to policy file .

Adjustments can be changes such as but not limited to redefining the categories of a particular I F. In other words if module in SP zone cannot access a particular CPI I F in trusted zone then the user employing the GUI and process may reclassify the particular I F as an SPI thus enabling the SP zone module permission to access the I F. Of course a reclassification of an I F from CPI to SPI would also enable any module in SP zone to access the I F and this may not be the intention of the user. The GUI provides the user with various options. Another viable option may be to create a Named EXPORT that enables the particular CPI to be accessed by the specific SP zone module and only the specific module within SP zone . In this scenario the named export is declared in policy file rather than in the target module and implemented via trusted anchor . Those with skill in the art should appreciate that a named EXPORT policy can be stored in places other than policy file .

If during block the user determines that the issue identified during block requires a module change or addition rather than a policy file modification process proceeds to a Modify Add Modules block . During block the GUI and process enables the user to manipulate EXPORT commands of target modules or to incorporate an additional module in runtime system to resolve the identified issue. Once the issue has been addressed process proceeds to Modify Policy block described above during which any necessary modification in policy file are performed.

During a More Imports block process determines whether or not all the import issues identified during block have been addressed. If not process returns to Select Imports block during which the next unresolved import issue is selected and processing continues as described above. If during block process determines that all import issues have been resolved then control proceeds to a Store Policy File block during which process stores modified policy file in data storage . Once policy file is updated process proceeds to a Refresh Runtime block which corresponds to Install Modules process described above in conjunction with . Of course it may also be necessary to also execute Module Load process again as well. In an alternative embodiment only modules that need to be modified are reinstalled and reloaded. Finally during an End Modify Access block process is complete.

While the invention has been shown and described with reference to particular embodiments thereof it will be understood by those skilled in the art that the foregoing and other changes in form and detail may be made therein without departing from the spirit and scope of the invention including but not limited to additional less or modified elements and or additional less or modified blocks performed in the same or a different order.

