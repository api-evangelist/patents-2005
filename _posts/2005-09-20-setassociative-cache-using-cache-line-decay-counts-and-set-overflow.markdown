---

title: Set-associative cache using cache line decay counts and set overflow
abstract: Embodiments of a method for reducing conflict misses in a set-associative cache by mapping each memory address to a primary set and at least one overflow set are described. If a conflict miss occurs within the primary set, a cache line from the primary set is selected for replacement. However, rather than removing the selected cache line from the cache completely, the selected cache line may instead be relocated to the overflow set. The selected cache line replaces a cache line in the overflow set, if it is determined that the selected cache line from the primary set has an estimated age that is more recent than an estimated age for any cache line in the overflow set. Embodiments of the method incorporate various techniques for estimating the age of cache lines, and, particularly, for estimating the relative time since any given cache line was last accessed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07395373&OS=07395373&RS=07395373
owner: International Business Machines Corporation
number: 07395373
owner_city: Armonk
owner_country: US
publication_date: 20050920
---
The invention was made with Government support under Contract No. NBCH3039004 awarded by DARPA PERCS II. The Government has certain rights in this invention.

The invention relates to a set associative cache memory system and more particularly to a set associative cache memory system in which each memory address is mapped to both a primary set and at least one other set.

Most computer processing systems generally consist of several levels of memory including at least one relatively small capacity high speed memory storage mechanism referred to as a cache memory. The cache memory may be located in either a section of the main memory or a separate memory storage device. There are several types of cache organization direct mapped associative and set associative. Direct mapped caches are characterized by a one to one mapping from system address to cache address. Associative mapped caches are characterized by mapping from any system address to any cache address. Set associative caches are characterized by a one to many mapping from system address to a set address but not to a particular line within the set. For example in a four way set associative cache the data corresponding to the system can be found in one of four lines in a set within the cache. There is a direct mapping from system address to set address. However a tag e.g. a subset of the upper system address bits must be compared e.g. by a comparator with the tags for each of the four lines of the set to determine which line contains the data.

Some of the main determining factors in computer system processor performance are cache hit ratios. Specifically it is desirable to obtain as high a cache hit ratio as possible subject to constraints such as minimal access latency and chip area. Cache misses can be categorized as conflict misses capacity misses and coherency misses. Conflict misses are an effect arising from set associative cache designs in which cache accesses from one process or thread by chance happen to map to the same set as other cache accesses from the same or other processes or threads causing an excessive number of misses to that set. Typically there are a number of hot sets which dominate the overall number of cache misses. Here a hot set is used as a generic term to refer to one of the sets in a set associative cache for which there is an excessive number of conflict misses as compared to a typical set.

Various methods and systems for reducing conflict misses in set associative cache memories are known. One method is to increase the associativity of the set associative cache and in fact there is a trend in recent computer system designs for increased associativity for the system caches. However there are limits to which associativity can be increased in set associative cache design. For example in order to access the cache directory in a K way associative cache K tags are simultaneously read from K tag directories and simultaneously compared using K comparators to the tag of the address being accessed. As K increases there is an increase in power requirements and power density. Additionally the degree to which K can be increased is limited by wiring area chip area and timing constraints.

Another method disclosed in U.S. Pat. No. 5 465 342 to Stephen J. Walsh issued Nov. 7 1995 for Dynamically Adaptive Set Associativity for Cache Memories incorporated herein by reference incorporates the use of microcaches that are dynamically assigned to sets that are identified as hot. There are a number of disadvantages to this and other conceptually similar approaches. Primarily they require additional hardware complexity for counting misses for each set and for selecting those sets that have excessive miss counts as compared to typical sets.

Another method disclosed in The V Way Cache Demand Based Associativity via Global Replacement by Qureshi Thompson and Pratt University of Texas at Austin technical report TR HPS 2004 003 October 2004 incorporated herein by reference provides a system that reduces conflict misses by using a cache directory containing twice as many entries as the number of cache lines holding data. However such a cache directory introduces extra chip area cost. A level of indirection is also introduced between the cache directory entries and cache lines via forward and reverse pointers which may cause additional latency for every cache access.

Therefore it would be advantageous to provide a set associative cache memory with reduced conflict misses without increasing the associativity of the cache without increasing the number of entries in the cache directory without introducing levels of indirection between the cache directory and the cache and without introducing additional latency for the most frequently accessed cache data. Specifically it would be advantageous to provide a method that addresses the issue of conflict misses in set associative cache memory by mapping a primary set address and at least one overflow secondary set address by selecting a least recently used LRU line from within a set if a conflict miss occurs by sending the selected line to an overflow set and by replacing a line in the overflow set with the selected line if the selected line is more recent.

In view of the foregoing embodiments of the invention provide a computer implemented method for reducing conflict misses in a set associative cache by mapping each memory address to a primary set within the cache and one or more overflow sets within the cache. If a conflict miss occurs within the primary set a cache line from the primary set is selected for replacement. However rather than removing the selected cache line from the cache completely the selected cache line may instead be relocated to the overflow set mapped for the particular memory address. The selected cache line replaces a cache line in the overflow set if it is determined that the selected cache line from the primary set has an estimated age that is more recent than an estimated age for any cache line in the overflow set. For example the selected cache line will replace the least recently used cache line in the overflow set if that least recently used line is older.

More particularly embodiments of the invention provide a computer implemented method for reducing conflict misses within a set associative cache of a computer system. The method includes an initialization process. During the initialization processes logical fields are established for each set comprising a plurality of lines in a cache directory within the set associative memory. For each line in the set the logical fields can include but are not limited to corresponding valid bits age bits tags and state bits. For each set the logical fields can also include but are not limited to a first type flag to indicate that a line from this set has been relocated to an overflow set a second type flag to indicate that a line from another set has overflowed into i.e. been relocated into this set an optional first set index to identify a set number to which a line from this set has been relocated and an optional second set index to identify a set number from which a line overflowed into this set.

The age bits can be used to register the age of each line within a set e.g. the age bits can be used to register a relative length of time since the line was last accessed . For example all age bits for a particular line can be reset to 0 when that line is accessed. Then the age bits can be incremented over time by associating a decay counter with each cache line in the set associative memory to register the estimated age that cache line. Alternatively each line can have the same number of multiple age bits e.g. a first age bit a second age bit and a third age bit . Each of the age bits can be associated with a corresponding counter. For example each first age bit can be associated with a first counter each second age bit with a second counter etc. Each counter can be in communication with a clock signal. Then the age bits e.g. first second and third age bits for each line can be incremented at different rates based upon communications to the corresponding counters from a clock signal. For example frequency dividers can be positioned between each counter and a single clock signal to vary the rates at which a clock signal is received by each counter. As each counter is incremented its corresponding age bits for the different lines are set.

Also during the initialization processes each memory address e.g. of a main memory of the computer system is mapped to a primary set e.g. a first set and at least one overflow set e.g. a second set . This mapping can be implemented using a variety of techniques. For example each memory address can be mapped to a second address of the second set within the set associative memory as a function of a first address of the first set e.g. the over flow set number O s can be S nsets 2 offset MOD nsets where S is the primary set number nsets is the total number of sets and the offset is a predetermined constant value. Alternatively the memory address can be mapped to the second address of the second set by applying a bit inverting technique where the set associative memory comprises n sets and each of the n sets is addressed by n bits and where a notation e.g. x is used to indicate inverting a value of a given bit e.g. bit x within given set.

Once the logical fields are established and the memory addresses are mapped then if conflict misses occur in a first set replaced lines can be relocated to the mapped second set instead of being lost i.e. removed from the set associative cache . Thus if data is input into a cache line of a set and a conflict miss occurs then a cache line i.e. a selected cache line within the set is selected for replacement based on predetermined replacement policies. These replacement policies can include but are not limited to selecting the least recently used LRU line based upon a comparison of the age bits of each line within the set.

Generally if a conflict miss occurs a determination can be made as to whether the selected cache line is an original line i.e. received directly from another memory within the computer or an overflow line i.e. relocated to the first set from another set within the set associative cache . If the selected cache line is an original line or if multiple overflow sets are mapped the selected cache line can be forwarded to the appropriate overflow set e.g. the second set . Then the age bits of the selected cache line from the first set can be compared to the age bits of each line in the second set and a determination can also be made as to which of the cache lines from the second set was least recently accessed. If the selected cache line from the first set is estimated to be newer e.g. estimated to be more recently accessed than any one of the cache lines in the second set the selected cache line will replace the oldest e.g. estimated to be least recently accessed cache line of the second set. Once such an overflow replacement has occurred the second set will be flagged e.g with a second type flag to indicate that it contains a cache line received as overflow from another set. Additionally the first set will be flagged e.g. with a first type flag to indicate that a cache line was relocated from the first set to another set. However if the selected cache line is already an overflow line and only one second set i.e. overflow set has been addressed a determination will be made as to whether the first set currently contains any other overflow lines and if not a second type flag will be cleared from the first set.

To access a cache line e.g. the selected cache line from the set associative memory an initial determination is made as to whether the first set is flagged with a first type flag to indicate that a cache line has been relocated from the first set to another set. If there is no first flag then the cache directory is simply accessed to locate the selected cache line. If the first set is flagged with a first type flag then the cache directory is accessed a first time to determine if the selected cache line is still located in the first set e.g. if the selected cache line or a different cache line was previously relocated . If the selected cache line is not located in the first set a determination is made as to whether the second set is still flagged with a second type flag indicating that it contains a cache that was relocated to the second set from another set. If the second set has a second type flag the cache directory is accessed a second time to determine if the selected cache line is still located in the second set. Alternatively if the first set is flagged the cache directory can be accessed and a determination can simultaneously be made as to whether the selected cache line is located in either the first directory or the second directory.

These and other aspects and objects of the present invention will be better appreciated and understood when considered in conjunction with the following description and the accompanying drawings. It should be understood however that the following description while indicating preferred embodiments of the present invention and numerous specific details thereof is given by way of illustration and not of limitation. Many changes and modifications may be made within the scope of the present invention without departing from the spirit thereof and the invention includes all such modifications.

The present invention and the various features and advantageous details thereof are explained more fully with reference to the non limiting embodiments that are illustrated in the accompanying drawings and detailed in the following description. It should be noted that the features illustrated in the drawings are not necessarily drawn to scale. Descriptions of well known components and processing techniques are omitted so as to not unnecessarily obscure the present invention. The examples used herein are intended merely to facilitate an understanding of ways in which the invention may be practiced and to further enable those of skill in the art to practice the invention. Accordingly the examples should not be construed as limiting the scope of the invention.

In view of the foregoing disclosed herein are embodiments of a method that addresses the issue of conflict misses in set associative cache memory by mapping a primary set address and at least one overflow secondary set address by selecting a least recently used LRU line from within a set if a conflict miss occurs by sending the selected line to an overflow set and by replacing a line in the overflow set with the selected line if the selected line is more recent. Specifically disclosed is a method for reducing conflict misses in a set associative cache by mapping each memory address to a primary set within the cache and one or more overflow sets within the cache. If a conflict miss occurs within the primary set a cache line from the primary set is selected for replacement. However rather than removing the selected cache line from the cache completely the selected cache line may instead be relocated to the overflow set mapped for the particular memory address. The selected cache line replaces a cache line in the overflow set if it is determined that the selected cache line from the primary set has an estimated age that is more recent than an estimated age for any cache line in the overflow set. Additionally the various embodiments of the method incorporate different techniques for estimating the age of cache lines and particularly for estimating the relative time since any given cache line was last accessed. Each of the below described embodiments of the method reduce conflict misses in a set associative cache without increasing the associativity of the cache without increasing the number of entries in the cache directory and without introducing levels of indirection between the cache directory and the cache.

More particularly referring to the flow diagram of embodiments of the method of the invention for reducing conflict misses within a set associative cache of a computer system comprise an initialization process during which a cache directory for the set associative cache is established. Specifically logical fields for each set within a cache directory process see are established. For each line within the set the logical fields can include but are not limited to corresponding valid bits age bits tags and state bits . The state bits may for example contain bits representing line states such as modified exclusive shared etc. The age bits can be used to register the age of each line w in a set e.g. the age bits can be used to register a relative length of time since the line was last accessed process . When a line is accessed all age bits for the particular line can be reset to 0 . Then the age bits for each line can be incremented over time so that they can be compared to age bits of other lines in order to estimate the most recently accessed or least recently accessed lines.

Additionally for each set the logical fields can also include but are not limited to a first type flag e.g. OV flag to indicate that at least one line from this set has been relocated to an overflow set a second type flag e.g. OI flag to indicate that a cache line from another set has overflowed into i.e. been relocated into and is still contained within this set an optional first set index e.g. OTI index to identify a set number to which a line from this set has been relocated and an optional second set index e.g. OFI to identify a set number from which a line has overflowed into this set. The exemplary logic fields described above and illustrated in represent an approach to the method in which any possible primary to overflow set mapping can be configured at system initialization time see discussion below regarding address mapping . It should be noted that the optional OTI and OFI fields may be read only fields or they may be writeable fields which are set at system initialization. In the latter case any possible primary to overflow set mapping may be utilized by setting these two fields for every set appropriately. Alternatively if the primary to overflow set mapping is computed by hardware based functional units then these fields may be omitted from the logical structure of the cache directory.

Those skilled in the art will recognize that to register the age of each line at process of a number of alternative methods may be implemented. For example decay counters could be used rather than age bits to provide estimates of cache line age. More specifically the age bits can be incremented by associating a decay counter with each cache line in the set associative memory to register the estimated age of each cache line. A similar technique was recently proposed for power reduction in cache design by means of the use of power gating so as to reduce leakage power for old cache lines that is cache lines for which an estimated cache line age has exceeded a threshold e.g. see Cache Decay Exploiting Generational Behavior to Reduce Cache Leakage Power by Kaxiras Hu and Martonosi published in the Proceedings of the 28th Annual International Symposium on Computer Architecture ISCA incorporated herein by reference . However decay counters which are in essence small registers may represent a non trivial increase in the hardware complexity of the cache.

Alternatively the age bits in the cache directory could be used in a fashion similar to decay counters in which the age bits are interpreted as a counter. In this case cache line aging would involve cyclically reading the age bits incrementing this value and then writing it back. More specifically to register the age of each line at process of each cache line e.g. etc. can have the same number of multiple age bits e.g. three age bits as illustrated a first age bit a second age bit and a third age bit see . Each of the age bits can be associated with a corresponding counter. For example each first age bit can be associated with a first counter each second age bit with a second counter and each third age bit with a third counter . Each counter can be in communication with a clock signal . Then the age bits e.g. first second and third age bits for each line can be incremented at different rates based upon communications to the corresponding counters from the clock signal . For example frequency dividers can be positioned between corresponding counters respectively and a single clock signal to vary the rates at which a clock signal is received by each counter. As each counter is incremented its corresponding age bits for the different lines are set. More particularly the clock signal can be reduced in frequency by the three dividers and . Each successive divider reduces the clock frequency by a greater amount e.g. FREQ FREQ FREQ etc. . For example the divisor value FREQ of divider could be the divisor value FREQ of divider could be and the divisor value FREQ of divider could be . The divided clock signals passed to the counters from dividers and are used to control incrementing of the three counters . Additionally each counter can be configured to reset to 0 when it exceeds the number of cache lines in the cache. For example if the number of cache lines is a power of 2 such as this is achieved trivially by implementing the counter with log base 2 of the number of cache lines that is 10 bits for example if there were 1024 cache lines. On each counter increment an age bit is set for the cache line in the cache directory as determined by the counter value age bit for the cache line with an index as determined by COUNTER A age bit for the cache line with an index as determined by COUNTER B and age bit for the cache line with an index as determined by COUNTER C . When a cache line is accessed all age bits are reset to zero see line . In this fashion the age bits provide an estimate of cache line age that is time since the cache line was last accessed and due to the doubling of the division frequencies for example a large age range can be spanned. In more detail cache lines with age bits are estimated to be most recent followed by cache lines with age bits followed by cache lines with age bits x followed by cache lines with age bits xx where x indicates either 0 or 1 of which the latter are estimated to be the least recent. Line age in the embodiments of the invention can be described interchangeably and respectively in terms of older or newer least recently used or most recently use least recently accessed or most recently accessed or similar terms. Line age may also be described interchangeably and respectively in more precise terms such as estimated to be least recently used or estimated to be the most recently used estimated to be the least recently accessed or estimated to be the most recently accessed etc.

In addition to establishing logical fields in the cache directory at process of and registering cache line ages at process of during the initialization process each memory address e.g. of a main memory of the computer system is mapped to a first set i.e. a primary and at least one second set i.e. at least one overflow set at process of . This mapping can be implemented using a variety of techniques. For example referring to in combination each memory address can be mapped to a primary set using prior art mapping methods and then also mapped to an overflow set within the set associative memory as a function of the primary set number e.g. the overflow set number O s can be equal to S nsets 2 offset MOD nsets where S is the primary set number nsets is the total number of sets and the offset is a predetermined constant value . Alternatively the memory address can be mapped to the overflow set by applying a bit inverting technique where the set associative memory comprises n sets and each of the n sets is addressed by n bits and where a notation e.g. x is used to indicate inverting a value of a given bit e.g. bit x within given set.

More particularly illustrates an exemplary 4 way set associative cache and specifically how each memory address e.g. ADDR ADDR etc. is mapped into two sets a first set i.e. a primary set and a second set i.e. an overflow set within the cache . For example a first memory address is mapped to a primary set at set number and to an overflow set at set number . Similarly a second memory address is mapped to its primary set at set number and to its overflow set at set number . The mapping of a memory address to its primary set e.g. or may take place using mechanisms as in a conventional set associative cache e.g. by using a subset of the address bits or by using a hardware computed hash value determined by the address bits in order to determine the set number e.g. set numbers or . The remaining address bits excluding the low order bits as determined by the cache line size are referred to as the tag of the line and serve to uniquely identify a cache line e.g. cache lines A D within a set e.g. sets etc. . As mentioned above each first primary set is associated with a second overflow set . As compared to a conventional set associative cache sufficient tag bits are required in order to determine whether a cache line is stored in its first primary set or in its second overflow set e.g. see and related discussion above regarding logical fields for cache directory .

Conversely if the OTI and OFI entries are not used in the cache directory as illustrated in a simpler mapping technique such as a bit flipping technique may be used to reduce the hardware requirements. For example assume for the purpose of this example that there are 256 sets so that a set number can be represented with 8 bits s s s s s s s s. In this example s and s determine which of the remaining bits to flip as follows where the notation x is used to indicate flipping inverting the value of bit x 

Additionally it is contemplated that embodiments of the method of the invention may incorporate the use of more than one overflow set. While designs using multiple overflow sets are possible those skilled in the art will recognize that in practice the number of overflow sets should be small for implementation and performance reasons. Assuming the primary set to overflow set mapping has a large cycle length i.e. the number of times the mapping when successively applied returns to the primary set which could range from two for paired sets up to the number of sets in the cache as shown in for example successive overflow sets could be generated by applying this mapping repeatedly to the primary set and then to successive overflow sets. In the case that secondary and tertiary overflow sets are allowed the overflow state of the primary set could be represented for example as follows a 00 no overflow lines in either secondary or tertiary overflow set b 10 one or more overflow lines in secondary overflow set only c 01 one or more overflow lines in tertiary overflow set only d 11 one or more overflow lines in both the secondary and tertiary overflow sets.

Once the initialization process is complete i.e. once the logical fields are established at process of and the memory addresses are mapped at process of then if conflict misses occur in a first set i.e. a primary set at process of the line replaced as a result of the conflict miss can be relocated to the mapped second set i.e. the mapped overflow set as opposed to being lost i.e. removed from the set associative cache . Specifically if data is input into a set and a conflict miss occurs at process then a cache line i.e. selected cache line within the set is selected for replacement at process of based on predetermined replacement policies. These predetermined replacement policies can include but are not limited to selecting the least recently used LRU line based upon a comparison of the age bits of each line within the set.

Specifically once a conflict miss occurs a determination can be made as to whether the selected cache line is an original line i.e. received directly from another memory within the computer or an overflow line i.e. a line that was relocated to the first set from another set within the set associative cache . If the selected cache line is an original line and or if multiple overflow sets are mapped the selected cache line can be forwarded to the appropriate second set i.e. the appropriate overflow set . Then the age bits of the selected cache line from the primary set can be compared to the age bits of each line in the overflow set and a determination can also be made as to which of the cache lines from the overflow set was least recently accessed . If the selected cache line from the primary set or the previous overflow set is estimated to be newer e.g. estimated to be more recently accessed than any one of the cache lines in the overflow set then the selected cache line will replace the oldest e.g. estimated to be least recently accessed cache line of the overflow set . Additionally once such an overflow replacement has occurred the overflow set will be flagged e.g with a second type OI flag to indicate that it contains a cache line received as an overflow line from another set. Additionally the primary set or the previous overflow set if multiple overflow sets are mapped will be flagged e.g. with a first type OV flag to indicate that a cache line was previously relocated. However if the selected cache line is already an overflow line and only one second set i.e. only one overflow set was mapped a determination will be made as to whether the primary set currently contains any other overflow lines and if not a second type OI flag will be cleared from the first set.

Referring to the flow diagram of because a given cache line may be located in the first set i.e. the primary set or the second set i.e. the overflow set or may have been removed from the cache all together in order to access a particular cache line e.g. the selected cache line from the set associative memory as efficiently as possible an initial determination should be made as to whether the primary set is flagged with a first type OV flag to indicate that at least one of the cache line in the set has been relocated from the primary set to an overflow set at process . If there is no first type flag then the cache directory is simply accessed as in a conventional cache to locate the selected cache line within the primary set at process . If the primary set or one of multiple overflow sets is flagged with a first type OV flag then the cache directory is accessed to determine if the selected cache line is still located in the primary set e.g. if the selected cache line or a different cache line was previously relocated at process . If the selected cache line is not located in the primary set a determination is made as to whether the overflow set is still flagged with a second type O flag indicating that it contains a line that was relocated to the overflow set from a primary set or from previous overflow set at process . If the overflow set does not have a second type OI type flag then the selected line is no longer located in the cache . If the overflow set has a second type O flag the cache directory is accessed to determine if the selected cache line is still located in the overflow set at process . If so the selected line may be accessed from the overflow set and if not and no other overflow sets are mapped then the line is no longer located in the cache .

Those skilled in the art will recognize that various hardware configurations may be used to implement the method. For example once it is determined at process that an OV flag is present on the first set i.e. the primary set process may be accomplished in a step by step fashion in which the cache directory is accessed a first time to determine if the line is in the primary set and a second time if necessary to determine if the line is in the second set i.e. an overflow set .

Alternatively if the primary set is flagged the cache directory can be accessed once and a determination can be made simultaneously as to whether the selected cache line is located in either the first directory or the second directory . This technique takes into consideration that for the step by step cache access process there is a small performance penalty when a cache line is found in the overflow set because two cache directory accesses are required. Therefore assuming there is logic available to fetch and compare K tags and perform all tag compares in parallel where K is the associativity given the appropriate cache directory design both the primary set and overflow set could be examined in parallel if the overflow flag for the primary set is on. Similarly for secondary tertiary etc. overflow sets the overflow state of the primary set would indicate which sets to examine either sequentially or in parallel or by some combination of sequential parallel. Here as compared to a conventional cache design with an associativity of 2K for example there should be significant savings in power since it is expected that in many cases the overflow flag will be off there may also be improved performance due to the avoidance of hot sets and a resulting increase in the cache hit ratio.

Therefore disclosed above are embodiments of a method for reducing conflict misses in a set associative cache by mapping each memory address to a primary set and at least one overflow set within the cache. If a conflict miss occurs within the primary set a cache line from the primary set is selected for replacement. However rather than removing the selected cache line from the cache completely the selected cache line may instead be relocated to the overflow set mapped for the particular memory address. The selected cache line replaces a cache line in the overflow set if it is determined that the selected cache line from the primary set has an estimated age that is more recent than an estimated age for any cache line in the overflow set. Embodiments of the method incorporate various techniques for estimating the age of cache lines and particularly for estimating the relative time since any given cache line was last accessed. These embodiments of the method of the invention as described above reduce conflict misses in a set associative cache without increasing the associativity of the cache without increasing the number of entries in the cache directory and without introducing levels of indirection between the cache directory and the cache. While the invention has been described in terms of embodiments those skilled in the art will recognize that the invention can be practiced with modification within the spirit and scope of the appended claims.

