---

title: Enforcing native access control to indexed documents
abstract: Techniques are provided for processing a search request. One or more indexed levels of access control list information are stored in a search index for each document identified in the search index. An interim result set is generated by matching the one or more indexed levels of access control list information associated with each said document to one or more security groups associated with the search request. A final result set is generated from the interim result set by performing impersonation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08417693&OS=08417693&RS=08417693
owner: International Business Machines Corporation
number: 08417693
owner_city: Armonk
owner_country: US
publication_date: 20050714
---
An enterprise may be described as any organization e.g. business government entity charity etc. that uses computers. The information found in an enterprise may exist in many shapes and forms. The information may be distributed throughout the enterprise and managed by various software programs depending on the task at hand. For example enterprise users may use a SQL application to tap into relational databases or a document management application to access documents pertinent to their work.

Controlling access to sensitive information contained within these repositories is typically enforced by the managing software programs. The extent to which the information is secured may vary from system to system with each enforcing its own security policies and requirements. For example file systems generally control read write and execute operations on files and associate security groups with the allowed operations. A security group may include a single user or multiple users. However file systems do not control access to individual elements within a file. Once the user is permitted to open a file the user has access to all of its contents. In contrast to a file system security model a relational database management system may control access to individual columns of data in a table of a database and a document management program may enforce security policies to limit access to documents within a specified period of time.

An enterprise search engine may be described as being capable of retrieving relevant documents of the enterprise in response to a query a form of a search request . The diversity in security models for the different types of enterprise content is problematic for enterprise search engines. A goal of an enterprise search engine is to provide quick and relevant responses to inquiries for documents that users are authorized to see. In order to meet the performance and relevance requirements most enterprise search engines build a search index that represents the content to be searched. Rather than searching the original content the user is actually submitting queries to the index which is like searching a card catalog in a library.

The search index includes documents that are extracted from various backend repositories. A repository may be described as a data source. Backend repositories may be described as contributing data sources to the search index. The documents contained in these backend repositories are extracted with a crawler that has security credentials of sufficient authority to access all of the documents for that repository. Normally the user identification userId presented to the crawler is a super user that has access to most if not all of the documents in the repository. Consequently the initial document access rights of an enterprise search index represent the access rights of this super user.

Different enterprise search engines use different approaches to restrict an individual user s access rights. One approach is for the enterprise search engine to provide its own security model. The administrator of the enterprise search engine defines individual access rights to the cataloged documents. This approach has several drawbacks. First this approach attempts to employ a common security model that will satisfy all of the security requirements of the contributing backend repositories. As previously demonstrated this may not be practical or possible as the different types of repositories and access controls increases. Typically the end result is a least common denominator effect for security causing a number of documents to loose some if not all of their native security controls. Second this approach requires the administrator to redefine controlled access to documents that have already been defined in the originating repositories which is a duplicative task. Lastly the approach implies that the administrator has enterprise wide knowledge of the access controls for all enterprise content which is an unlikely situation.

It is therefore highly desirable for the search engine to honor the access rights of the documents as defined by the native access controls of the backend repository. Native access control refers to the access control implemented at the repository from which the document was retrieved. Typically a native access control list ACL is associated with each document and is used to enforce access control to that document. In many cases the native ACL includes security tokens representing security groups and or individual users who have access to a document. Native ACLs may also exist at higher levels than the document within the backend repository. For example documents may be organized into folders which themselves may have defined ACLs i.e. folder level ACLs . The folders in turn may be organized into logical file cabinets which again can have their own defined access controls i.e. file cabinet level ACLs . There are generally two approaches for a search engine to honor these native ACLs. One approach is to copy the native ACLs into the search index. The other approach is to leave the native ACLs in the backend repository and to have the search engine request document access authority from the repository through impersonation.

The ACL approach is to automatically copy the document s native ACLs as defined by the backend repository into the search index of the enterprise search engine. Although this approach reduces the burden on the administrator to redefine a document s ACL the approach has several shortcomings. If the native ACLs are to retain their original security model then the enterprise search engine would be re implementing the corresponding security mechanisms used by the backend to enforce those ACLs. This may be a daunting task. Alternatively the search engine could try to transform these ACLs into a single common model so that a single security filtering mechanism may be used. A true normalized model may not be achievable. The term normalized may be described as causing to conform to a standard or making consistent. If a normalized model is achievable the result would be a security model representing the least common denominator of all the contributing repositories.

The impersonation approach does not maintain any security information in the search index at all. In response to a query a result set is generated from the index. Then before the result set is presented to the user the enterprise search engine removes those documents the user is not allowed to see by consulting in real time with the document s originating backend repositories. The enterprise search engine would in a sense be impersonating the end user when interacting with the native repository. Through impersonation the enterprise search engine would be asking the native repository if the user may have access to one or more documents that were previously crawled and extracted from that repository. With this approach document access is controlled by the native security mechanisms of the originating repository however complex that may be. Also the filtering is done in real time thus reflecting the latest native ACL changes for any given document.

While the impersonation approach does meet the requirement to honor the document s original access rights the approach has some shortcomings. First the approach requires connectivity to the all of the backend repositories that have contributed to the index. If a particular backend repository is not available then the disposition of a document in a result set may not be determined. That is if the backend is not available then the document probably cannot be viewed. Under this condition the document would automatically be removed from the result set.

The impersonation approach however may take some time. Search indexes are optimized for speed and generally can be searched in sub second response times. With the impersonation approach time is added to communicate with each backend repository to determine whether documents should be included in the final result set that is returned to the user. The more differentiated the result set the greater the number of communications. The problem is compounded when a user is denied access to the majority of the results. For example assume that a query generated 1000 interim results ranked by relevance by submitting a query against the index. Further assume that the user did not have access to the first 900 results as dictated by the backend repositories. Then over 900 impersonations would have been performed by the enterprise search engine before the result set is populated with the remaining 100 results.

Thus there is a need in the art for more efficient enforcement of native access control to indexed documents.

Provided are a method article of manufacture and system for processing a search request. One or more indexed levels of access control list information are stored in a search index for each document identified in the search index. An interim result set is generated by matching the one or more indexed levels of access control list information associated with each said document to one or more security groups associated with the search request. A final result set is generated from the interim result set by performing impersonation.

In the following description reference is made to the accompanying drawings which form a part hereof and which illustrate several embodiments. It is understood that other embodiments may be utilized and structural and operational changes may be made without departing from the scope of embodiments of the invention.

A web server is coupled to the client computer and to an enterprise search server . The web server includes system memory which may be implemented in volatile and or non volatile devices. At least an identity manager i.e. computer program is stored in the system memory for execution by a processor e.g. a Central Processing Unit CPU not shown . The web server is also coupled to a data store that contains user profiles .

An enterprise search server is coupled to the web server and to multiple backend servers . . . . The ellipses indicate that any number of backend servers may be coupled to the enterprise search server . The enterprise search server includes system memory which may be implemented in volatile and or non volatile devices. At least an enterprise search engine i.e. computer program is stored in the system memory for execution by a processor e.g. a Central Processing Unit CPU not shown . The enterprise search server is also coupled to a data store that contains a search index .

One or more backend servers . . . each include system memory . . . which may be implemented in volatile and or non volatile devices. One or more server applications . . . i.e. computer programs are stored in each respective system memory . . . for execution by a processor e.g. a Central Processing Unit CPU not shown . Each backend server . . . is coupled to a data store that contains documents . . . respectively.

In alternative embodiments the computer programs may be implemented as hardware software or a combination of hardware and software.

The client computer web server enterprise search server and backend servers . . . may comprise any computing device known in the art such as a server mainframe workstation personal computer hand held computer laptop telephony device network appliance etc.

The client computer web server enterprise search server and backend servers . . . may be coupled via a network such as for example a Storage Area Network SAN a Local Area Network LAN Wide Area Network WAN the Internet an Intranet etc.

Each data store may comprise an array of storage devices such as Direct Access Storage Devices DASDs Just a Bunch of Disks JBOD Redundant Array of Independent Disks RAID virtualization device etc.

The security models at the document level may vary considerably thwarting any effort to arrive at a common model. But the probability of arriving at a normalized model improves as higher levels of access control list information is considered. For example many document management systems provide access control at the collection or database level. Other document management systems additionally provide access control at the server or system level through a login authentication process. During crawling the enterprise search engine selects certain levels of access control list information from the backend server . . . that has a similar semantic for different types of repositories i.e. a kind of least common denominator set of access control list information . While the higher levels of access control list information does not control access to the individual documents the information may be used to predict the probability of successful impersonation access to documents. For example it may be predicted that if a search user has access to a document s database then the user most likely will have access to the documents in the database.

The higher levels of access control list information is obtained during the document extraction process when the search index is being built or refreshed. The higher levels of access control list information that is retrieved is mapped to one or more indexed levels represented in the search index . In certain embodiments the number of indexed levels in the search index is determined by the intersection of the higher levels of access control list information supported by all contributing backend servers . . . . The normalized high level access control list information at each indexed level in the search index is used by the enterprise search engine to rapidly produce an interim result set of documents that a search user has a high probability to access. It is this interim result set that the enterprise search engine post filters through impersonation.

In certain embodiments impersonation involves programmatically establishing a session with the backend server . . . using the security credentials of the search user. Once the backend server . . . authenticates the impersonated user the enterprise search engine consequently presents to the backend server a list of documents that the end user is potentially authorized to see. The backend server responds to the search engine with indications of denied or granted access to each document.

In certain embodiments once the user has been authenticated by a host system i.e. the user has entered a valid userId and password during logon to the web server and before the user issues a search request e.g. a query to the enterprise search engine the identity manager is activated. The identity manager is responsible for generating the user s security context which includes the one or more security groups of which the user is a member and which is used for impersonating the user and for pre filtering indexed documents based on one or more security groups of which the user is a member. The user s security context contains the user s security credentials to each of the backend repository security domains as well as the user s associated one or more security groups in those security domains. A security domain may be described as including one or more backend servers . . . that store a collection of documents managed by an enterprise software system. In certain embodiments a security domain may be made up of more than one repository of a same type and the user is prompted for credentials for the security domain rather than for each individual repository in the security domain since the credentials would be the same. In certain embodiments the security context is a formatted XML string.

In block the identity manager prompts for and receives user security credentials for one or more security domains that each include one or more backend repositories. In particular the user submits user security credentials to access documents contained in the data stores at the backend servers . . . to the identity manager . A user may have different identities i.e. different login data for each of the backend servers . . . and associated security domains. For example a user may submit a userId and password for each security domain in which the user wants searches executed against indexed documents from those security domains. In block the identity manager stores the user security credentials for one or more backend repositories in a user profile . In certain embodiments for each supplied security credential the identity manager attempts to log in to the backend repository to obtain the user s one or more security groups for that security domain. If the log in fails then it is assumed that the user s security credentials have changed e.g. password expired and the user is prompted to reenter the correct security credentials. Otherwise the user s one or more security groups are returned by the backend repository and stored in the user s profile. At any time the user may choose to ignore a recommended update to the user profile but this results in those documents affected by the change being excluded from a search.

In block the identity manager attempts to log in to a next one of the one or more backend repositories with the user security credentials stored in the user profile starting with a first backend repository from among the one or more backend repositories. In block the identity manager determines whether the log in was successful. If so processing continues to block otherwise processing continues to block . If the log in was not successful it is likely that the user s security credentials have changed.

In block the identity manager extracts one or more security groups for which the user is a member from the backend repository and in block the identity manager stores the extracted one or more security groups for the backend repository in the user profile. In block the identity manager determines whether all of the backend repositories for which the user provided user security credentials have been accessed. If so processing continues to block otherwise processing loops back to block .

In block the identity manager generates a security context using the user profile . In block the identity manager makes the security context available to the client application which in turn appends the security context to each search request forwarded to the enterprise search engine .

In certain embodiments the identity manager uses a Lightweight Directory Access Protocol LDAP user registry to store user profiles. The identity manager stores the multiple user security credentials for a user underneath the user s existing person entry in the LDAP user registry. The location and structure of the LDAP user registry is provided to the identity manager via for example a user interface provided by embodiments. When LDAP is used the user initially logs into the web server by providing a userId and password as registered in LDAP. The identity manager uses the received userId to locate a user record in LDAP or to add user security credentials to a user record in LDAP.

A collection may be made up of documents that were crawled from many different types of backend repositories. For example a collection could contain documents that were crawled from a file system and several databases. The identity manager differentiates between different types and prompts for the security credentials needed to access these separate security domains.

In certain embodiments by default each credential is enabled for search and thus requires the user to provide a corresponding user name and password. If the user has forgotten a user name and or password to a particular domain the user can choose to disable the domain from search i.e. uncheck the enable search indicator box . This prevents any secured documents in those domains from being searched and returned in a result set.

In block the enterprise search engine generates a final result set based on impersonation for the documents in the interim result set. In particular the enterprise search engine requests the backend server . . . to check access to a document through impersonation. Impersonation involves establishing a session with the backend server . . . using the security credentials of the search user. The backend server . . . may believe it is interacting directly with the user and may consequently respond with data the end user is authorized to access. However the backend server . . . is communicating with the enterprise search engine impersonating the user.

To impersonate a user the enterprise search engine obtains the security credentials of the user from the user s security context accompanying the search request. The security context includes the user s login information for each backend server . . . . Just as the user would be asked to provide identification to the original backend server . . . in order to perform a search and access documents the enterprise search engine provides the same security credentials for any documents contained in the search index that require authorization. In certain embodiments the identity manager retrieves the security context for the user when the user establishes a session with the enterprise search engine . The security context may then be used repeatedly on subsequent searches by the user. In certain embodiments all security credentials for that user are supplied on each individual search because it is not known in advance which backend servers . . . may be impersonated.

In block the enterprise search engine provides the final result set to a user and enables the user to select documents that may then be provided by backend servers . . .

Thus embodiments provide a technique that responds to a search request with those documents a search user is permitted to see as defined by the native access controls of the documents that are indexed. Embodiments combine the storage of higher levels of access control list information in the search index along with the real time consultation of the originating backend servers . . . to determine which documents a user may access. The storage of higher levels of access control list information in the search index enables good search performance and with impersonation the host software of a document s originating backend server . . . becomes the final arbiter as to whether or not the user is allowed access to that particular document. Thus techniques enforce native access control list information.

The document extraction process is commonly referred to as crawling and is performed by a crawler . The crawler retrieves the actual content of the document as well as any meta data about the document e.g. author date created etc. . This information is parsed and indexed by the enterprise search engine . Typically the search index contains a highly compressed cross reference of all the words in the document.

In particular the crawler connects to a backend system with security credentials of sufficient authority to access and extract all of the documents for that repository. Normally the userId presented to the backend system by the crawler is a super user identification that has access to most if not all of the documents in the repository. Extracted along with the documents is the repository s higher level e.g. server and database level access control list information. The access control list information identifies those users and or groups of users that are allowed access to documents in the repository. This information is associated with each document and stored in the search index for use by the enterprise search engine .

The crawler retrieves document information from database A and database A by accessing backend server A . The crawler also retrieves document information from database B and database B by accessing backend server B . A programmatic technique for retrieving the one or more security groups allowed access to this server is available to the crawler . The crawler associates the access control list information with each of the crawled documents.

In the example of the indexed levels are server and database levels and the native levels of access control list information extracted are server and database level information. Not all backend servers may use the terminology of server and database level and not all backend servers support both levels. If at least one level of access control list information is supported by the backend server the crawler maps the level to the appropriate indexed level stored in the search index . For example many enterprise backend servers provide a user login to the system and this may be approximated as server level access. As another example the normalized database level is used for those backend servers that further organize their documents into logical collections that may be assigned discrete access control. For example a document management system may restrict which groups of users have access to which collections under its control. This kind of access control list information may then be mapped to the indexed level associated with the database level in the search index .

If only one native level of access control list information may be extracted from a backend server the crawler may map that native level to both the indexed levels of server and database. Then the search user s user identifier or one or more security groups of which the user is a member is checked against both indexed levels during the processing of a query.

Document content extracted by the crawler is parsed tokenized and ingested by the indexer to construct the search index . The search index represents the corpus of documents that may be searched and may be optimized for speed and accuracy. The search index is built and periodically refreshed from synthesized document content that is extracted from backend servers i.e. enterprise repositories . Stored in the search index along with each document are the multiple levels of access control list information. Since the search index is comprised of documents crawled from many different kinds of backend repositories the search index may contain access control list information from different security domains.

When a user at a user computing device issues a query to the enterprise search engine the enterprise search engine allows the user to receive a list of references to documents that match the user s search criteria. In particular a user issues a query to the enterprise search engine from the user computing device . The enterprise search engine receives a security context along with the query. In particular associated with each query submitted to the enterprise search engine is a complete set of user security credentials that the user may have. The multiple identities that a user may have are solicited by the identity manager and stored into a user registry .

The enterprise search engine uses the search index to produce pre filtered results. Then the enterprise search engine generates an interim result set from the pre filtered result set by matching one or more indexed levels associated with each document to one or more security levels associated with the user who issued the search request. The enterprise search engine generates a final result set based on impersonation for the documents in the interim result set.

Although the crawler the indexer and the enterprise search engine are illustrated as separate components these may be combined to form one component.

The user s security credentials for the backend servers may not be the same. A security credential may consist of a user identifier userId representing the user a password used to authenticate the user and the user s security group list i.e. the list of one or more security groups of which the user is a member . Unless both backend servers share a common user registry any portion of the security credential may vary among different backend servers . For example user John Smith may be a member of the Administrator security group as defined in backend server but user John Smith may only be a member of the Staff security group as defined by backend server . Even if John Smith were a member of a security group named the same in both backend servers the actual membership between the two security groups could differ. For example John Smith is a member of the Staff security group as managed by backend server but is not a member of the Staff security group managed by backend server . In certain embodiments the enterprise search engine maintains this distinction by appending the security domain name to each access control list entry in the search index .

Table A illustrates native levels of access control list information for documents DA and DA at the backend servers 

In Table A document DA is from backend server A which is in security domain SEC and includes original access control list information that indicates that users with security levels Staff and Sales may access the document. Document DB is from backend server B which is in security domain and includes original access control list information that indicates that users with security levels Staff and Manager may access the document.

In Table B for each document two indexed levels of information are stored server level and database level. For each indexed level for each document information is stored in the search index to indicate the security level of access a user needs to access the document. For example to access document DA a user needs belong to the Sales security group in order to pass levels one and two of access control stored in the index. For document DB a user needs to belong to the Staff security group in order to pass access levels one and two stored in the index.

When a user first establishes a session with the enterprise search system an aggregate of all security credentials for that user is compiled. This set of security credentials represents all of the security domains contained in the search index and is used by the enterprise search engine for generating the interim result set and post filtering with impersonation.

When a user submits a query to the enterprise search engine the query is accompanied by the user s set of security credentials. Table C illustrates user security credentials for backend servers .

For example in Table C in security domain SEC the user identifier is JohnSmith the password is X7fh567 and the security groups of which the user is a member are Staff and Personnel. Also in security domain SEC the user identifier is JSmith the password is EBDCA001 and the security groups of which the user is a member are Staff and Finance. These security groups are matched by the enterprise search engine against the indexed levels in the search index .

The enterprise search engine uses the security groups of which a user is a member security group membership in Table C as additional criteria that is to be met when selecting documents that match the user s search criteria. The security groups listed in the user s security credential set may be appended with their respective security domains so as to eliminate conflicts in similar security group names across backend servers. In certain embodiments for a particular document if at least one security group in the augmented user s security group list matches at list one security group in each of the levels of access control stored in the index access is allowed to the document.

In certain embodiments one level of the indexed levels may be a subset of another one of the indexed levels. For example in Table D the database level access control list information may be a proper subset of the server level access control list information and may be used to further restrict which security groups have access to that particular database. Also it is possible to have an intersection between two sets of access control list information as demonstrated by document DA . Notice that the security group Mgr SEC shows up in the database level access control list information and not the server s access control list information. The administrator of this server probably removed the Mgr SEC security group from the server access control list information effectively denying access to that server to Managers but did not bother to update each and every database under this server. Also note for document DB that a security group named AllGroups SEC exists at the server level access control list information. The token AllGroups SEC is an identifier of a security group and is treated like any of the other access control list information entries. That is in certain embodiments the token is not interpreted literally. So a user that desires access to that server has to belong to a security group named AllGroups .

In this example the set of documents of Table D is filtered based on the following Boolean expression 1 of the user s one or more security groups obtained from Table C and results in the documents of Table E Server Level ACL Contains Staff SEC01 OR Personnel SEC01 OR Staff SEC02 OR Finance SEC02 AND Database Level ACL Contains Staff SEC01 OR Personnel SEC01 OR Staff SEC02 OR Finance SEC02 1 

The interim result set of Table E represents those documents that matched the user s query in this example and that the user has access to as calculated by the enterprise search engine at the server and database levels. However it is still possible that the user is not allowed to see either of these documents as reflected in their originating source systems. The enterprise search engine impersonates the user and consults with each document s backend database to determine whether that document should be included in a final result set.

Each of the documents in Table E originated from different security domains which require separate impersonations to determine access. The enterprise search engine uses the security domain of the document to look up the appropriate security credentials to be used for impersonation in Table C.

Embodiments provide several enhancements to improve performance of impersonization. For example the search index is comprised of documents crawled from many different kinds of enterprise backend repositories. Consequently a result set may contain documents from any one of these backend repositories. When a final result set contains documents originating from different backend repositories then multi tasking capabilities of an operating system are employed to perform concurrent execution of the impersonations with each different kind of backend server . . . . Conversely when a final result set contains multiple documents from the same backend server . . . then these documents are presented together through the same impersonation process to the backend server . . . . This allows the session establishment and authentication processes to be performed once for this group of documents.

Also performance is improved by minimizing the number of impersonations that are performed. As previously mentioned an inordinate number of impersonations may be made when a user is denied access to the majority of the documents in the result set. Embodiments reduce the number of failed impersonations i.e. impersonations that result in access to one or more documents being denied through the storage of indexed levels of access control list information i.e. a normalized set of the native access control list information for each backend server . . . in the search index . The higher levels of access control list information may be used to generate the interim result set and impersonation is performed on the interim result set. That is by matching the user s security levels with the indexed levels e.g. the server and database levels associated with each document in the interim result set the documents already have an improved chance of passing the impersonation test.

Embodiments further reduce the number of impersonations that are made by utilizing the page size of the final result set. Typically a search application presents a response to a query as a sequence of pages. The first page presents typically the top most relevant results and the user may select e.g. click on a hyperlink a document in the final result set to view the actual document. Subsequent pages ordered by decreasing relevance are not normally shown but these may be requested by the user e.g. by clicking on a desired page number that is displayed with the final result set s first page . Thus in certain embodiments when a page is capable if displaying m results the enterprise search engine performs enough impersonations to display those m results. In order to accomplish this it may be necessary for the enterprise search engine to maintain a separate offset into the interim result set representing the last successful impersonation that completed a page. It may be insufficient to use the page number requested by the search application to calculate where in the interim result set to start the post filtering.

For example assume the page size is set to display ten results. Further assume that thirteen impersonations were performed to fill the first page of ten results i.e. because three results were filtered out due to denied access . When the next page of the final results set is requested the enterprise search engine starts impersonating at document rather than document .

Additionally the enterprise search engine may validate a sufficient amount of the interim results to display the requested page with a predefined number of results. For example if the interim result set contained many results then the impersonation and check access steps may be a lengthy process. Again this performance penalty may be substantially improved by validating enough results to complete the requested page e.g. validating enough results by impersonation to display ten results .

Assume that the interim result set contained over a hundred results that satisfied the user s original query but that the page size is set to a predefined number of results of ten e.g. by the client application . A best case scenario would result in ten impersonations to fill a page that displays ten results. Additional impersonations are performed to replace those documents that failed the impersonation test but the probability of this is expected to be low and is predicated on the fact that if the user has access to the indexed levels e.g. server and database levels associated with a document then the user has a high probability of being authorized to view the document.

Moreover rather than reissue the same search for subsequent page requests the enterprise search engine may cache the interim result set and extract the requested page from the cached results. Caching of the result set improves performance and is optional.

The described operations may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof. The term article of manufacture as used herein refers to code or logic implemented in a medium where such medium may comprise hardware logic e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. or a computer readable medium such as magnetic storage medium e.g. hard disk drives floppy disks tape etc. optical storage CD ROMs optical disks etc. volatile and non volatile memory devices e.g. EEPROMs ROMs PROMs RAMs DRAMs SRAMs firmware programmable logic etc. . Code in the computer readable medium is accessed and executed by a processor. The medium in which the code or logic is encoded may also comprise transmission signals propagating through space or a transmission media such as an optical fiber copper wire etc. The transmission signal in which the code or logic is encoded may further comprise a wireless signal satellite transmission radio waves infrared signals Bluetooth etc. The transmission signal in which the code or logic is encoded is capable of being transmitted by a transmitting station and received by a receiving station where the code or logic encoded in the transmission signal may be decoded and stored in hardware or a computer readable medium at the receiving and transmitting stations or devices. Additionally the article of manufacture may comprise a combination of hardware and software components in which the code is embodied processed and executed. Of course those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention and that the article of manufacture may comprise any information bearing medium known in the art.

The term logic may include by way of example software or hardware and or combinations of software and hardware.

Although some examples herein may have referred to a security group being associated with a user in alternative embodiments a security group may be associated with for example a computer program. The computer program may then issue a search request having associated one or more security groups that are used to generate an interim result set.

The logic of and describes specific operations occurring in a particular order. In alternative embodiments certain of the logic operations may be performed in a different order modified or removed. Moreover operations may be added to the above described logic and still conform to the described embodiments. Further operations described herein may occur sequentially or certain operations may be processed in parallel or operations described as performed by a single process may be performed by distributed processes.

The illustrated logic of and may be implemented in software hardware programmable and non programmable gate array logic or in some combination of hardware software or gate array logic.

The computer architecture may comprise any computing device known in the art such as a mainframe server personal computer workstation laptop handheld computer telephony device network appliance virtualization device storage controller etc. Any processor and operating system known in the art may be used.

The foregoing description of embodiments has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the embodiments be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the embodiments. Since many embodiments may be made without departing from the spirit and scope of the invention the embodiments reside in the claims hereinafter appended or any subsequently filed claims and their equivalents.

