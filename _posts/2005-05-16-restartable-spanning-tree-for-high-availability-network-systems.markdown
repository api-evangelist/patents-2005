---

title: Restartable spanning tree for high availability network systems
abstract: A method and apparatus for continuing the operation of a spanning tree protocol at a network device despite crashes or failures at that device is disclosed. The network device includes a plurality of line cards having ports for receiving and forwarding messages and a plurality of supervisor cards for processing at least some of those messages. Upon start-up, one of the supervisor cards is designated the active supervisor, while all other supervisor cards are designated standby supervisors. The active supervisor runs the spanning tree protocol (STP). The active supervisor informs the standby supervisors of the states of ports set by the STP. When a crash or failure occurs at the active supervisor, one of the standby supervisors is immediately designated to be the new active supervisor, and the new active supervisor uses the states of ports set by the original STP.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07599284&OS=07599284&RS=07599284
owner: Cisco Technology, Inc.
number: 07599284
owner_city: San Jose
owner_country: US
publication_date: 20050516
---
This application is a Continuation of application Ser. No. 09 644 377 filed Aug. 23 2000 now issued as U.S. Pat. No. 6 898 189 on May 24 2005 

U.S. patent application Ser. No. 09 208 175 entitled VALUE ADDED FEATURES FOR THE SPANNING TREE PROTOCOL filed Dec. 9 1998 now issued as U.S. Pat. No. 6 628 624 on Sep. 30 2003 and

U.S. patent application Ser. No. 09 283 111 entitled METHOD AND APPARATUS FOR PROVIDING FAST SPANNING TREE RE STARTS filed Mar. 31 1999 now issued as U.S. Pat. No. 6 801 506 on Oct. 5 2004.

The present invention relates generally to computer networks and more specifically to a method and apparatus for quickly resuming the forwarding of network messages despite failures.

A computer network typically comprises a plurality of interconnected entities. An entity may consist of any device such as a computer or end station that sources i.e. transmits or sinks i.e. receives data frames. A common type of computer network is a local area network LAN which typically refers to a privately owned network within a single building or campus. LANs typically employ a data communication protocol LAN standard such as Ethernet FDDI or token ring that defines the functions performed by the data link and physical layers of a communications architecture i.e. a protocol stack . In many instances several LANs may be interconnected by point to point links microwave transceivers satellite hook ups etc. to form a wide area network WAN or intranet that may span an entire country or continent.

One or more intermediate network devices are often used to couple LANs together and allow the corresponding entities to exchange information. For example a bridge may be used to provide a bridging function between two or more LANs. Alternatively a switch may be utilized to provide a switching function for transferring information between a plurality of LANs or end stations. Typically the bridge or switch is a computer and includes a plurality of ports that couple the device to the LANs or end stations. Ports used to couple switches to each other are generally referred to as a trunk ports whereas ports used to couple a switch to LANs or end stations are generally referred to as access ports. The switching function includes receiving data from a sending entity at a source port and transferring that data to at least one destination port for warding to the receiving entity.

Switches and bridges typically learn which destination port to use in order to reach a particular entity by noting on which source port the last message originating from that entity was received. This information is then stored by the bridge in a block of memory referred to as a filtering database. Thereafter when a message addressed to a given entity is received on a source port the bridge looks up the entity in its filtering database and identifies the appropriate destination port to reach that entity. If no destination port is identified in the filtering database the bridge floods the message out all ports except the port on which the message was received. Messages addressed to broadcast or multicast addresses are also flooded.

Additionally most computer networks are either partially or fully meshed. That is they include redundant communications paths so that a failure of any given link or device does not isolate any portion of the network. The existence of redundant links however may cause the formation of circuitous paths or loops within the network. Loops are highly undesirable because data frames may traverse the loops indefinitely. Furthermore because switches and bridges replicate i.e. flood frames whose destination port is unknown or which are directed to broadcast or multicast addresses the existence of loops may cause a proliferation of data frames that effectively overwhelms the network.

To avoid the formation of loops most bridges and switches execute a spanning tree algorithm which allows them to calculate an active network topology that is loop free i.e. a tree and yet connects every pair of LANs within the network i.e. the tree is spanning . The Institute of Electrical and Electronics Engineers IEEE has promulgated a standard the 802.1D standard that defines a spanning tree protocol to be executed by 802.1D compatible devices. In general by executing the IEEE spanning tree protocol bridges elect a single bridge within the bridged network to be the root bridge. Since each bridge has a unique numerical identifier bridge ID the root is typically the bridge with the lowest bridge ID. In addition for each LAN coupled to more than one bridge only one the designated bridge is elected to forward frames to and from the respective LAN. The designated bridge is typically the one closest to the root. Each bridge also selects one port its root port which gives the lowest cost path to the root. The root ports and designated bridge ports are selected for inclusion in the active topology and are placed in a forwarding state so that data frames may be forwarded to and from these ports and thus onto the corresponding paths or links of the network. Ports not included within the active topology are placed in a blocking state. When a port is in the blocking state data frames will not be forwarded to or received from the port. A network administrator may also exclude a port from the spanning tree by placing it in a disabled state.

To obtain the information necessary to run the spanning tree protocol bridges exchange special messages called configuration bridge protocol data unit BPDU messages. is a block diagram of a conventional BPDU message . The BPDU message includes a message header compatible with the Media Access Control MAC layer of the respective LAN standard. The message header comprises a destination address DA field a source address SA field and a Service Access Point SAP field among others. The DA field carries a unique bridge multicast destination address assigned to the spanning tree protocol. Appended to header is a BPDU message area that also contains a number of fields including a Topology Change Acknowledgement TCA flag a Topology Change TC flag a root identifier ROOT ID field a root path cost field a bridge identifier BRIDGE ID field a port identifier PORT ID field a message age MSG AGE field a maximum age MAX AGE field a hello time field and a forward delay FWD DELAY field among others. The root identifier field typically contains the identifier of the bridge assumed to be the root and the bridge identifier field contains the identifier of the bridge sourcing i.e. sending the BPDU . The root path cost field contains a value representing the cost to reach the assumed root from the port on which the BPDU is sent and the port identifier field contains the port number of the port on which the BPDU is sent.

Upon start up each bridge initially assumes itself to be the root and transmits BPDU messages accordingly. Upon receipt of a BPDU message from a neighboring device its contents are examined and compared with similar information e.g. assumed root and lowest root path cost stored by the receiving bridge in non recoverable memory. If the information from the received BPDU is better than the stored information the bridge adopts the better information and uses it in the BPDUs that it sends adding the cost associated with the receiving port to the root path cost from its ports other than the port on which the better information was received. Although BPDU messages are not forwarded by bridges the identifier of the root is eventually propagated to and adopted by all bridges as described above allowing them to select their root port and any designated port s .

In order to adapt the active topology to failures the root periodically e.g. every hello time transmits BPDU messages. The hello time utilized by the root is also carried in the hello time field of its BPDU messages. The default hello time is 2 seconds. In response to receiving BPDUs on their root ports bridges transmit their own BPDUs from their designated ports if any. Thus every two seconds BPDUs are propagated throughout the bridged network confirming the active topology. As shown in BPDU messages stored by the bridges also include a message age field which corresponds to the time since the root instigated the generation of this BPDU information. That is BPDU messages from the root have their message age field set to 0 . Thus every hello time BPDU messages with a message age of 0 are propagated to and stored by the bridges.

After storing these BPDU messages bridges proceed to increment the message age value every second. When the next BPDU message is received the bridge examines the contents of the message age field to determine whether it is smaller than the message age of its stored BPDU message. Assuming the received BPDU message originated from the root and thus has a message age of 0 the received BPDU message is considered to be better than the stored BPDU information whose message age has presumably been incremented to 2 seconds and in response the bridge proceeds to re calculate the root root path cost and root port based upon the received BPDU information. The bridge also stores this received BPDU message and proceeds to increment its message age timer. If the message age of a stored BPDU message reaches a maximum age value as specified in the MAX AGE field the corresponding BPDU information is considered to be stale and is discarded by the bridge.

Normally each bridge replaces its stored BPDU information every hello time thereby preventing it from being discarded and maintaining the current active topology. If a bridge stops receiving BPDU messages on a given port indicating a possible link or device failure it will continue to increment the respective message age value until it reaches the maximum age threshold. The bridge will then discard the stored BPDU information and proceed to re calculate the root root path cost and root port by transmitting BPDU messages utilizing the next best information it has. The maximum age value used within the bridged network is typically set by the root which enters the appropriate value in the maximum age field of its transmitted BPDU messages. Neighboring bridges similarly load this value in their BPDU messages thereby propagating the selected value throughout the network. The default maximum age value under the IEEE standard is twenty seconds.

As BPDU information is updated and or timed out and the active topology is re calculated ports may transition from the blocking state to the forwarding state and vice versa. That is as a result of new BPDU information a previously blocked port may learn that it should be in the forwarding state e.g. it is now the root port or a designated port . Rather than transition directly from the blocking state to the forwarding state ports typically transition through two intermediate states a listening state and a learning state. In the listening state a port waits for information indicating that it should return to the blocking state. If by the end of a preset time no such information is received the port transitions to the learning state. In the learning state a port still blocks the receiving and forwarding of frames but received frames are examined and the corresponding location information is stored in the filtering database as described above. At the end of a second preset time the port transitions from the learning state to the forwarding state thereby allowing frames to be forwarded to and from the port. The time spent in each of the listening and the learning states is referred to as the forwarding delay and is entered by the root in the FWD DELAY field .

As ports transition between the blocked and forwarding states entities may appear to move from one port to another. To prevent bridges from distributing messages based upon incorrect address information bridges quickly age out and discard the old information in their filtering databases. More specifically upon detection of a change in the active topology a bridge periodically transmits a Topology Change Notification Protocol Data Unit TCN PDU frame on its root port. The format of the TCN PDU frame is well known see IEEE 802.1D standard and thus will not be described herein. A bridge receiving a TCN PDU sends a TCN PDU of its own from its root port and sets the TCA flag in BPDUs that it sends on the port from which the TCN PDU was received thereby acknowledging receipt of the TCN PDU. By having each bridge send TCN PDUs from its root port the TCN PDU is effectively propagated hop by hop from the original bridge up to the root. The root confirms receipt of the TCN PDU by setting the TC flag in the BPDUs that it subsequently transmits for a period of time. Other bridges receiving these BPDUs note that the TC flag has been set by the root thereby alerting them to the change in the active topology. In response bridges significantly reduce the aging time associated with their filtering databases which as described above contain destination information corresponding to the entities within the bridged network. Specifically bridges replace the default aging time of 5 minutes with the forwarding delay time which by default is fifteen seconds. Information contained in the filtering databases is thus quickly discarded.

Although the spanning tree protocol is able to maintain a loop free topology despite network changes and failures re calculation of the active topology can be a time consuming and processor intensive task. For example re calculation of the spanning tree following an intermediate device crash or failure can take approximately thirty seconds. In particular a crash or failure typically wipes out the BPDU information stored by a bridge. Upon re start the bridge assumes itself to be the root places all of its ports in the blocking and or listening states and proceeds to transmit BPDU messages accordingly. It thus takes at least thirty seconds for a bridge to recover from a crash or failure e.g. fifteen seconds in the listening state and another fifteen seconds in the learning state . During this time message delivery is often delayed as ports transition between states because ports in the listening and learning states do not forward or receive messages. Such delays can have serious consequences on time sensitive traffic flows such as voice or video traffic streams.

Furthermore short duration failures or crashes of the spanning tree protocol at a given bridge is not an infrequent problem. For example failures or crashes can occur due to power fluctuations glitches in the running of the spanning tree protocol software modules glitches running other bridge processes that cause the spanning tree process to fail etc. Even if a bridge or just the spanning tree process is only down for a few seconds and thus no change in port states may be warranted re calculation of the spanning still requires on the order of thirty seconds. Accordingly significant time is wasted recalculating the spanning tree following re starts even though no change in network topology has occurred and the ports are ultimately returned to their original states.

It is also known to segregate a computer network into a series of logical network segments. U.S. Pat. No. 5 394 402 issued Feb. 28 1995 the 402 patent for example discloses an arrangement for associating any port of a switch with any particular segregated network group. Specifically according to the 402 patent any number of physical ports of a particular switch may be associated with any number of groups within the switch by using a virtual local area network VLAN arrangement that virtually associates the port with a particular VLAN designation. More specifically the 402 patent discloses a switch or hub that associates VLAN designations with its ports and further associates those VLAN designations with messages transmitted from any of the ports to which the VLAN designation has been assigned.

The VLAN designation for each port is stored in a memory portion of the switch such that every time a message is received on a given access port the VLAN designation for that port is associated with the message. Association is accomplished by a flow processing element which looks up the VLAN designation in the memory portion based on the particular access port at which the message was received. In many cases it may be desirable to interconnect a plurality of these switches in order to extend the VLAN associations of ports in the network. The 402 patent in fact states that an objective of its VLAN arrangement is to allow all ports and entities of the network having the same VLAN designation to exchange messages by associating a VLAN designation with each message. Thus those entities having the same VLAN designation function as if they are all part of the same LAN. Message exchanges between parts of the network having different VLAN designations are specifically prevented in order to preserve the boundaries of each VLAN segment or domain. For convenience each VLAN designation is often associated with a different color such as red blue green etc.

In addition to the 402 patent the Institute of Electrical and Electronics Engineers IEEE has promulgated the 802.1Q standard for Virtual Bridged Local Area Networks. The 802.1Q standard among other things defines a specific VLAN tagged message format.

To provide redundancy it is also known to install at least two bridge processing cards in an intermediate network device. The Catalyst 5500 and 6000 series of network devices from Cisco Systems Inc. of San Jose Calif. for example include two bridge processing cards. Each of these cards moreover includes facilities for running the spanning tree protocol including processing and memory components. If a crash or failure occurs on the currently active processing card the back up card takes over and begins running the spanning tree protocol. The back up card however starts calculating the spanning tree protocol as if the device were just activated. That is the back up card transitions all ports to the blocking state and begins transmitting BPDU messages assuming it is the root. Accordingly it typically takes on the order of 30 seconds or more for the device to begin forwarding messages again. As indicated above such delays can seriously affect audio video and other types of network traffic.

Briefly the invention relates to a method and apparatus for continuing the operation of a spanning tree protocol at a network device despite crashes or failures at that device. According to the invention the network device includes a plurality of line cards having ports for receiving and forwarding network messages and a plurality of supervisor cards for processing at least some of those messages. Each supervisor card includes a spanning tree protocol STP engine a run time memory and a non volatile memory. The non volatile memory at each supervisor card is preferably configured with STP related information. The STP engines are also in communication with the line cards so as to obtain bridge protocol data unit messages BPDUs that are received by the network device and to provide the line cards with BPDUs for forwarding. Upon start up of the network device one of the supervisor cards is designated the active supervisor and all other supervisor cards are designated standby supervisors. The STP engine on the active supervisor generates all BPDUs forwarded by the network device and processes all of the BPDUs that are received by the device. The active STP engine also identifies the root of the bridged network and directs the ports of the device to transition among a plurality of STP states e.g. blocking listening forwarding etc. in accordance with the spanning tree protocol. The identity of the root device and the port state information is stored by the active supervisor in its run time memory.

The active STP engine also informs the standby supervisors of any changes in port states and this port state information is stored at the run time memories of the standby supervisors. In the preferred embodiment however the standby supervisors are not informed of the identity of the root. When a crash or failure occurs at the active supervisor one of the standby supervisors is immediately designated to be the new active supervisor and the corresponding STP engine is initialized. The newly active STP engine reviews the port state information in its run time memory and queries the line cards to determine whether that port state information is still valid. The STP engine adopts the port state information that is valid discards any suspect port state information and resumes STP operation for the switch. In addition the newly active STP engine generates BPDUs assuming that it is the root by utilizing the STP related information from its non volatile memory. These BPDUs are then passed to the line cards for forwarding. To the extent neighboring intermediate devices respond with BPDUs of their own the newly active STP engine can quickly determine what device is the correct root by examining these received BPDUs. The switchover from the STP engine at the failed supervisor to the STP engine at the newly active supervisor is thus accomplished before the other intermediate devices within the network are forced to re calculate the spanning tree thereby avoiding significant network disruption.

As shown network includes a plurality of redundant communication paths. The existence of such redundant paths prevents portions of the network from becoming isolated should any constituent link or intermediate network device fail. Such redundancy however also results in the creation of loops which as described above are highly undesirable. To avoid the creation of loops switches preferably execute a spanning tree protocol. Switches also include a high availability spanning tree feature as described herein so as to improve network performance in the face of crashes and failures.

It should be understood that the bridged network of is meant for illustrative purposes only and that the present invention will operate with other network designs having possibly far more complex topologies.

High speed message bus is preferably a switching matrix employed to control the transfer of data among the various cards plugged into the switch . The UDlink of each card basically interfaces between the local bus and the message bus . Inputs to the various LTL memories may be received over the respective local buses which are driven by the corresponding UDlinks. Switch also includes a common bus that similarly interconnects the line cards and supervisor cards .

Each supervisor card further includes a network management processor NMP that may be configured to run a plurality of protocols or other applications implemented at switch . For example each NMP can run a spanning tree protocol STP as illustrated by STP engines . Each STP engine in turn may include a plurality of state machines which are generally designated and respectively. As described herein the state machines are used to transition the ports P of switch among a plurality of spanning tree states. The NMPs at each supervisor are further configured to run an event manager and a failure detection module . Each supervisor also includes both a run time memory such as a random access memory RAM and a non volatile memory such as a non volatile RAM. The NMPs are in communicating relationship with the corresponding memories and in order to store and retrieve information therefrom. Each NMP is also coupled to high speed bus and common so that information may be exchanged between the NMPs and the line cards .

STP engines event managers and failure detection modules may each comprise programmed or programmable program instructions or processing elements such as software programs modules or libraries pertaining to the methods described herein and executable by the respective NMPs or by other processors. These program instructions may be stored at memories . Other computer readable media may also be used to store the program instructions for execution. STP engines event managers and failure detection modules may also be implemented in hardware through a plurality of registers and combinational logic configured to produce sequential logic circuits and cooperating state machines. Those skilled in the art will also recognize that various combinations of hardware and software components may also be utilized to implement the present invention.

Suitable intermediate network device platforms for use with the present invention include the commercially available Catalyst 6000 series of switches from Cisco Systems Inc. of San Jose Calif.

Prior to its activation switch is preferably configured with default spanning tree parameters which it is to use if it is elected to be the root of the bridged network . More specifically a network administrator working either locally or remotely from switch sets the spanning tree parameters specified by the IEEE 802.1D Bridge Standard e.g. bridge priority root path costs hello time maximum age time forward delay time etc. This information is preferably stored by switch at its non volatile memories . In accordance with the present invention the forward delay time is preferably set to ten seconds or more to facilitate the switchover from an active supervisor card to a standby supervisor card following a failure or crash.

FIGS. and are flow diagrams of the preferred methods for achieving the high availability spanning tree feature of the present invention. As indicated at block upon activation or start up of switch each supervisor preferably initializes or creates a plurality of data structures in its respective run time memories for use in running the spanning tree protocol. In the illustrative embodiment each STP engine establishes a virtual local area network VLAN table not shown that has an entry for each possible VLAN designation that is established within network . For example if network has 100 VLAN designations numbered through then the VLAN tables will have 100 entries. Each entry of the VLAN tables moreover contains at least three items of information 1 an index identifying the ports P of switch that are associated with the respective VLAN designation 2 a pointer to a bridge data structure and 3 a pointer to a linked list of port data structures that correspond to the ports P that are associated with the respective VLAN designation. Details of the bridge and port data structures are described below in connection with .

Next the two supervisors elect or designate one of them to be the active supervisor as indicated at block . Supervisors may employ any suitable criteria for use in electing one of them to be the active supervisor such as electing the supervisor card that is inserted into the lowest or highest slot number. Each supervisor moreover may include some mechanism such as an elector not shown to perform the designation. Suppose for example that supervisor is elected to be the active supervisor. All other supervisors at switch i.e. supervisor are designated standby supervisors . Upon being designated the active supervisor the STP engine at the active supervisor preferably synchronizes the default spanning tree parameter values at the standby supervisors with its default spanning tree parameter values as indicated at block . That is in case the STP information between the active and standbys differs STP engine sends a copy of the spanning tree parameter values from its non volatile memory to STP engine at standby supervisor . The standby STP engine utilizes this information to update the spanning tree parameters in its non volatile memory .

The STP engine on the active supervisor but not the standby STP engine is then initialized and run as indicated at block . That is standby STP engines i.e. STP engine remain dormant or in a sleeping mode. The active STP engine proceeds to compute a spanning tree for each VLAN designation in the bridged network . More specifically STP engine assumes that it i.e. switch is the root of the bridged network for all VLANs generates tagged BPDU messages and passes these tagged BPDUs to the line cards so that they may be forwarded from all non disabled ports P of the switch . To generate the BPDU messages STP engine retrieves the spanning tree parameter values from non volatile memory . These values are then loaded into the appropriate fields of the BPDU messages. To the extent the active supervisor has its own non disabled ports BPDU messages are similarly transmitted from them. In addition STP engine in cooperation with its constituent state machines transitions all of the non disabled ports P of switch to the blocking state.

Neighboring switches e.g. switches and receive the BPDU messages generated and sent by switch . In response they may reply to switch with BPDU messages of their own. BPDU messages received at switch are captured by the line cards and passed to the active STP engine via high speed bus . Their contents are examined and compared with the best spanning tree values currently known to STP engine in order to compute or identify the root the root port and any designated ports for each VLAN designation. These values are then loaded into the respective spanning tree data structures i.e. the bridge and port data structures as also indicated by block .

The bridge data structure further includes a maximum age time field a hello time field and a forward delay time field which preferably contain corresponding time parameters specified by the root device e.g. switch for the respective VLAN designation. A bridge identifier ID field contains the numeric identifier for device . A bridge maximum age time field a bridge hello time field and a bridge forward delay time field preferably contain the corresponding spanning tree time parameters that are to be implemented by device should it become the root for the respective VLAN designation. The contents of fields may be obtained by the STP engine from non volatile memory which was previously configured with this information by the network administrator.

The bridge data structure also includes information related to spanning tree topology changes. More specifically bridge data structure preferably includes a Topology Change Detected Flag field that contains a flag asserted by STP engine if it detects a change in the active topology for the spanning tree associated with the respective VLAN designation. A Topology Change flag field is asserted if STP engine is to assert the TCN flag in BPDU messages sourced by STP engine . A Topology Change Time field contains the amount of time for which the STP engine if elected to be the root for this VLAN designation asserts the TCN flag in BPDU messages following receipt of a TCN PDU message. One or more spanning tree statistics fields e.g. field may also be included for storing statistical information on the running of the corresponding spanning tree.

Bridge data structure also contains a port database array pointer field which contains a pointer to a location in run time memory at which a port database array for the respective VLAN designation is stored. The port database array is described in more detail below.

The port data structure may also contain a port next state field a configuration BPDU in Process field and a HA Recovery Pending field . The port next state field is used to carry a new port state pending acknowledgement from the respective line card. During this time the port state field continues to carry the prior port state. Once an acknowledgement is received the port state field is updated with the new port state. The configuration BPDU in Process field is used as a locking mechanism to prevent the contents of the port data structure from being processed more than once during any given processing cycle. The HA Recovery Pending field is described below. Port data structure may also include one or more fields for storing statistical data such as port statistics field . A port data structure pointer field contains a pointer to the next port data structure in the corresponding linked list.

Based on the identity of the root root port and designated ports the active STP engine through its constituent state machines transitions the states of ports P among the spanning tree states e.g. blocking listening learning and forwarding . This port state information along with other information concerning the spanning tree topology e.g. the state of a port whether a port is in the topology or not etc. is passed to the standby supervisor as indicated at block .

In the illustrative embodiment an event based communication architecture is used to pass information including changes in port states from the active supervisor to the standby supervisor . More specifically the active supervisor issues events and the standby supervisor receives and processes these events in order to keep certain fields of the port data structures at the standby supervisor in synchronization with the port data structures at the active supervisor . Should a failure occur at the active supervisor the standby supervisor can then use the information from its port data structures among other information to resume operation of the spanning tree protocol with minimal disruption to the bridged network .

Basically the active supervisor utilizes one of three different events to notify the standby supervisor of information relating to the computation of the spanning tree topology. These events include 

As described below these events are passed from the active event manager to the standby event manager and the standby supervisor responds by taking a particular action. For ease of explanation these actions are described as being implemented by the standby STP engine . However since the standby STP engine is preferably in a dormant or sleeping mode those skilled in the art will recognize that the described actions can be implemented by other processes that are currently running on the standby supervisor .

In accordance with this event based communication scheme the standby supervisor first registers to receive events from the active supervisor . In particular the event manager on the standby supervisor may have a static table not shown configured so that the standby supervisor receives all events generated by the active supervisor . The standby may then process received events which are of interest to it and discard all others. The STP engine at the active supervisor moreover may issue an Application Programming Interface API system call such as eventRegister to event manager . The STP engine may insert as one of the arguments to the eventRegister API a callback or handle identifying itself. It may use additional arguments to specify the specific events or the general type of events for which it wants to be notified.

As part of its computation of the spanning tree protocol the active STP engine typically determines that a given port P of switch should be transitioned to a new spanning tree port state. The active supervisor not only directs the affected port to change its state it also notifies the standby STP engine of this change in port state through the PORT CHANGE STATE event.

After generating the sequence number the event manager next creates a PORT CHANGE STATE event which may also be returned to the STP engine . The PORT CHANGE STATE event contains the identity of the line card the port number the VLAN designation the new state and the sequence number associated with this port state change. Since the event manager at the standby supervisor is configured to receive all events generated by the active event manager the active event manager notifies it of the PORT CHANGE STATE event . For example the active event manager may generate and send an eventBegin message to the standby event manager via the common bus . The eventBegin message may include the type of event e.g. PORT CHANGE STATE the identity of the line card the port number the VLAN designation the new state and the sequence number associated with this port state change. The standby event manager in turn notifies the standby STP engine of the eventBegin message as indicated at . The standby event manager also creates a corresponding PORT CHANGE STATE event based on the eventBegin message from the active event manager and stores the respective sequence number.

The active STP engine then directs line card to transition port P from learning to forwarding. In particular the active STP engine may issue a SET PORT STATE command message to the line card via common bus as indicated at . The SET PORT STATE command message identifies the port whose state is being changed the corresponding VLAN designation and the new state i.e. forwarding . The SET PORT STATE command message also contains the unique sequence number e.g. 1 associated with this particular port state change. Next the active STP engine updates the corresponding field of the respective port data structure at run time memory with the new port state e.g. forwarding as indicated at . That is the active STP engine changes the contents of the port state field of the corresponding port data structure from learning to forwarding.

Upon learning of the PORT CHANGE STATE event the standby STP engine similarly updates its copy of the port data structure as indicated at block . That is the standby STP engine changes the contents of the port state field of the corresponding port data structure from learning to forwarding. In the preferred embodiment the standby STP engine does not change any other fields of the corresponding port data structure .

After updating the port data structure the active STP engine issues an eventComplete API call to the event manager signaling that it has performed all of the actions associated with the respective event. In response the active event manager clears the PORT CHANGE STATE event as indicated at and sends an eventComplete message to the standby event manager . In response to the eventComplete message the standby event manager clears the PORT CHANGE STATE event as indicated at . The standby event manager also sends an eventComplete message to the standby STP engine notifying it that the PORT CHANGE STATE event has been completed.

Upon receiving the SET PORT STATE command message line card stores the new port state in its respective LTL memory and the corresponding sequence number e.g. 1 preferably in a dynamic memory at the line card .

This process of issuing PORT CHANGE STATE events and up dating the port data structures on both the active and standby supervisors is repeated as the ports P at switch are transitioned among the spanning tree port states by the active STP engine . Suppose for example that the state of a port P on line card is changed. The active STP engine asks the active event manager to create a new PORT CHANGE STATE event. This new PORT CHANGE STATE event moreover is preferably assigned sequence number 2 . That is the sequence numbers are preferably incremented or decremented by the active event manager . In response to the corresponding SET PORT STATE command message line card will store sequence number 2 . When the next PORT CHANGE STATE event is generated the active event manager will return sequence number 3 . Suppose this third PORT CHANGE STATE affects a port P on line card . Upon receiving the corresponding SET PORT STATE command message with sequence number 3 line card replaces its previously stored sequence number 1 with the new sequence number 3 . That is each line card preferably stores only the last sequence number that it has received from the active STP engine . Thus at this point in time the sequence number stored at line card is 2 while the sequence number stored at line card is 3 .

Once the active topology or topologies have been established within computer network messages may be forwarded by the switches . As messages are received by switch the EARL at the active supervisor as well as the EARL at the standby supervisor stores address information regarding the network entities of network in its respective forwarding table .

After issuing the newEvent call and learning of the ADD DELETE PORT event the active STP engine issues an eventComplete API call to the active event manager and takes the appropriate action. In particular if the port is being added the active supervisor creates a new port data structure for the port and adds this new data structure to the linked list of port data structures for the entry of the VLAN table corresponding to the identified VLAN designation i.e. green as indicated at . If the port is being deleted the active STP engine removes the corresponding port data structure from the corresponding linked list as indicated at . At the standby supervisor the standby STP engine takes a similar action in response to the ADD DELETE PORT event . That is the standby STP engine either creates a new port data structure and adds it to the linked list of port data structures for the green VLAN as indicated at or removes the corresponding port data structure from the corresponding linked list as indicated at .

In response to the eventComplete API call the active event manager clears the corresponding ADD DELETE PORT event as indicated at and sends an eventComplete message to the standby event manager . The standby event manager in turn clears the corresponding ADD DELETE PORT event as indicated at and notifies the standby STP engine by sending it an eventComplete message .

It should be understood that the active STP engine may alternatively issue the eventComplete API call after taking the appropriate action of blocks .

The active STP engine next issues an eventComplete API call to the active event manager and carries out the corresponding action. More specifically the active STP engine removes the affected port data structure from the linked list for the old VLAN designation i.e. red and inserts the port data structure into the linked list for the new VLAN designation i.e. blue as indicated at . The standby supervisor takes similar action upon receiving the eventBegin message and the MOVE PORT TO VLAN event as indicated at .

In response to the eventComplete call the active event manager clears the MOVE PORT TO VLAN event as indicated at and sends an eventComplete message to the standby event manager . The standby event manager in turn clears the event as indicated at and sends an eventComplete message to the standby STP engine .

As shown above sequence numbers are not generated for or utilized by the ADD DELETE PORT or the MOVE PORT. TO VLAN events. The active event manager preferably generates sequence numbers only in response to PORT CHANGE STATE events. Furthermore the active supervisor does not notify the standby supervisor of the election of a particular bridge as the root or of the election of a particular port as a designated port for a given LAN. As far as spanning tree information is concerned the standby supervisor is only informed of changes in port states.

If a failure occurs at the active supervisor the standby supervisor preferably continues operation of the spanning tree protocol with little or no disruption to the bridged network . are a flow diagram of the preferred steps taken by switch during a switchover of supervisor cards. First the active supervisor crashes or fails and that crash or failure is detected by the failure detection modules e.g. module at the standby supervisors e.g. supervisor as indicated at block . If there are multiple standby supervisors one of them is elected to be the newly active supervisor as indicated at block . The STP engine at the standby supervisor is then activated as indicated at block . As described above the standby STP engine partially initialized the data structures it needs to run the spanning tree protocol i.e. the VLAN table the bridge data structures and the port data structures . Accordingly the standby STP engine need not initialize any data structures at this point. The standby STP engine does however perform a consistency check with the line cards to see whether its understanding of the spanning tree state of the ports P at switch agrees with the line cards .

In particular the standby STP engine queries each line card to retrieve the last sequence number stored at each the line card as indicated at step . The standby STP engine then compares the retrieved sequence numbers to the last sequence number stored by standby STP engine . More specifically the standby STP engine determines whether any of the sequence numbers from the line cards is greater than its sequence number as indicated at decision block . Suppose for example that the last sequence number provided to the standby STP engine before the active supervisor crashed was sequence number 21 . If the sequence number stored at each of the line cards is less than or equal to this sequence number i.e. 21 then the standby STP engine knows that the spanning tree port state information stored at the line cards is consistent with the spanning tree port state information stored in the port data structures at the standby s run time memory . If however a line card such as line card returns a sequence number e.g. 22 that is greater than the sequence number at the standby STP engine then the STP engine concludes that at least one port state change message sent to this line card was not received by the standby STP engine . Since the standby STP engine cannot recover this port state change it preferably responds by directing the respective line card i.e. line card to transition all of its ports P to the blocking spanning tree port state as indicated by Yes arrow leading to block .

Following the consistency check and the transition of those ports that failed the consistency check to blocking the standby STP engine next proceeds to determine whether there are any open events at the standby event manager as indicated by No arrow and line which both lead to decision block . In particular the standby STP engine queries the standby event manager to see if any PORT CHANGE STATE events have been opened typically as a result of the eventBegin messages but not cleared before the active supervisor crashed or failed. In other words the standby STP engine looks for any PORT CHANGE STATE events for which no eventComplete messages were received by the standby supervisor . If so the standby STP engine retrieves the still open PORT CHANGE STATE event from the standby event manager updates the port state field and asserts the High Availability HA Recovery Pending field for this port data structure for the respective port data structure in its run time memory as indicated at block . The standby STP engine asserts the HA Recovery Pending field basically as a reminder to the standby STP engine that it must instruct the corresponding line card to update the spanning tree state of the subject port P.

After updating the port state fields and setting the respective HA Recovery Pending fields for all open PORT CHANGE STATE events or determining that there are no open PORT CHANGE STATE events the standby STP engine loads i.e. fills in fields of the bridge data structures and fields of the port data structures in its run time memory as indicated by No arrow and line which both lead to block . The standby supervisor loads these fields assuming that it i.e. switch is the root for each VLAN designation in the bridged network . In other words the standby STP engine retrieves the spanning tree parameter information from its non volatile memory and uses this information to load the respective fields of the bridge and port data structures . For example in the root bridge ID field of the bridge data structures and in the designated bridge ID field of the port data structures the standby STP engine loads its own i.e. the switch s numeric identifier. In addition for those ports P that are in a transitory spanning tree state e.g. listening or learning the standby STP engine resets or re initializes the forward delay timers associated with these ports P as indicated at block .

Upon loading the fields of the bridge and port data structures the standby STP engine begins generating BPDU messages for transmission from the ports P of switch and processing any BPDU messages that are received by switch from neighboring switches as indicated at block . In particular the standby STP engine generates tagged BPDU messages based on the information its bridge and port data structures . In other words the fields of these BPDU messages are loaded as though switch is the root of the bridged network for all VLAN designations. For example the root ID field of all BPDU messages generated and forwarded by the standby STP engine contains the numeric bridge ID for switch and the message age field maximum age field hello time field and forward delay field all contain the corresponding default parameters stored at its non volatile memory .

Significantly the standby STP engine asserts the TC flag field of all BPDU messages that it initially generates and sends from the ports P of switch . In response to receiving BPDU messages from switch the neighboring devices e.g. switches and reply with BPDU messages of their own assuming these neighboring devices know of better BPDU information than that contained in the messages from switch . Suppose for example that the bridged network supports the red blue and green VLAN designations and that switch is the root for the red VLAN designation and that switch is the root for the blue and green VLAN designations. In other words switch is not a root for any of the VLAN designations of the bridged network . In this case switch is likely to receive BPDU messages from its neighbors.

The standby STP engine in a conventional manner processes these received BPDU messages. In particular the standby STP engine determines whether the received BPDU messages contain better spanning tree information than that currently known by it. If so the standby STP engine adopts this better information and stops sending BPDU messages from the ports on which this better information was received. The standby STP engine also loads the corresponding bridge and port data structures with the better spanning tree information. For example upon receiving BPDU messages from switch the standby STP engine will load the bridge ID for switch in the root bridge ID field for the corresponding bridge data structure .

For those VLAN designations for which switch is not the root of the bridged network the standby STP engine generates and begins sending Topology Change Notification protocol data unit TCN PDU messages from the respective root port for each such VLAN designation as indicated at block . As mentioned above with conventional operation of the spanning tree protocol a bridge only transmits TCN PDU messages in response to a change in the active topology. With the present invention however switch is configured so as to transmit TCN PDU messages whenever a failover occurs and the standby STP engine learns that it is not the root for at least one VLAN designation. This is preferably done in case switch was responding to a topology change at the time of the crash or failure. It is also preferably done in case a topology change occurred during the transition from the active supervisor to the standby supervisor since the assertion of the TC flag field in the BPDUs sourced by switch as described above is ignored by the neighboring devices. Thus switch must transmit TCN PDU messages in order to cause the other switches in the bridged network to shorten their filtering database timers.

These TCN PDU messages are propagated hop by hop to the root in a conventional manner. The root then responds by asserting the TC flag field in all subsequent BPDU messages sourced by the root. Upon receiving a BPDU message that originated from the root and has its TC flag field asserted a switch lowers the timer s associated with the addresses in its filtering database to the forward delay time in field of the BPDU message. Accordingly the switches quickly age out their address information. Switch stops transmitting TCN PDU messages as soon as it receives from the upstream switch a BPDU message whose TCA flag field is asserted thereby confirming receipt of the TCN PDU message from switch .

If switch is the root for a VLAN designation there is no need to send TCN PDU messages because the standby STP engine already asserted the TC flag field in the BPDU messages that it sourced for this VLAN designation as described above. Accordingly the neighboring switches have already lowered the age out time associated with their filtering databases for this VLAN designation in response to receiving these BPDU messages.

By sending out BPDU messages as soon as its ready to do so and thus triggering its neighboring devices to respond with their own BPDU messages the standby STP engine can quickly determine which bridge is the root for each VLAN designation in the bridged network .

In addition to generating and sending BPDU messages processing received BPDU messages and generating and sending TCN PDU messages as necessary the standby STP engine also scans the port data structures looking for data structures whose HA Recovery Pending field is asserted. As described above the standby STP engine asserted this field as part of the failover procedure whenever it found an open PORT CHANGE STATE event. For every port data structure whose HA Recovery Pending field is asserted the standby STP engine sends a SET PORT STATE command message to the corresponding line card to change the state of the port to the state specified in the port state field of the respective port data structure as indicated at block .

When the line card receives this SET PORT STATE message it changes the state of the port to the state specified in the message. Even if the line card had received a SET PORT STATE command message from the active supervisor before it failed and thus already changed the port s state the re sending of this message by the standby supervisor is harmless. The standby STP engine preferably utilizes a sequence number that is larger than the largest sequence number of which it is aware in such command messages e.g. STP engine may increment by 1 the sequence number stored in its memory .

As shown only open PORT CHANGE STATE events are acted upon by the standby supervisor . Any open ADD DELETE PORT and or MOVE PORT TO VLAN events are simply ignored by the standby supervisor . These two events may be safely ignored because the standby supervisor already took the specified action. That is the standby supervisor takes the specified action for these two events in response to the corresponding eventBegin messages as described above. Thus no further action needs to be taken in response to a crash or failure at the active supervisor after it has issued the newEvent call for these two events. Unlike the ADD DELETE PORT and the MOVE PORT TO VLAN events the standby supervisor does not take the specified action for PORT CHANGE STATE events until it receives the eventBegin message and or is notified of the PORT CHANGE STATE event . Thus if a crash or failure occurs before the active supervisor is able to issue the eventComplete call the standby supervisor has no way of knowing how far along the active supervisor got before it crashed or failed e.g. whether or not the active supervisor sent the SET PORT STATE command message to the line card .

The standby STP engine preferably delays the transmission of SET PORT STATE command messages as described above because of the time it typically takes to send command messages and receive acknowledgements across the common bus . Rather than spend time sending such messages to the line cards immediately following the failover the standby supervisor generates sends and processes BPDUs messages to prevent the other switches from detecting a failure and causing the entire active topology to be re computed. Those skilled in the art will recognize that if switch includes a low latency message channel from the supervisors to the line cards then there may be no need to delay the transmission of the SET PORT STATE command messages. In this case the addition of the HA Recovery Pending field to the port data structures may also be unnecessary.

While the standby STP engine is loading its bridge and port data structures with the information from its non volatile memory and sending and processing BPDU messages the line cards and the standby supervisor to the extent it has its own ports P rely on the spanning tree states of their ports P as stored in their LTL memories for purposes of forwarding messages within the bridged network . More specifically suppose line card passes the consistency check and that ports P and P at line card are both associated with the green VLAN designation and are both in the forwarding state. Since the line card passed the consistency check the standby STP engine does not instruct it to change the spanning tree states of its ports P despite the crash of the active supervisor . In other words even though the standby STP engine does not know which bridge is the root for the green VLAN designation and assumes at least initially that it is the root it does not transition the states of ports P and P to blocking or listening as in the prior art systems. Thus ports P and P continue to accept messages from and forward messages to the bridged network while the standby STP engine determines who is the actual root for the green VLAN bridged network. The EARL at the standby supervisor moreover which continued to learn and store address information while supervisor was running can forward messages from the appropriate ports P. Accordingly despite a failure or crash at the active supervisor and a transition of spanning tree operation to the standby supervisor time sensitive traffic flows such as voice and or video suffer little if any disruptions.

The present invention is also able to support the hot swapping of supervisor cards. The term hot swapping refers to the replacement of components in this case supervisor cards without having to shut down and restart the affected equipment in this case the switch. To facilitate hot swapping and the re starting of failed or crashed supervisor cards such as card each supervisor card initializes a port database array data structure for each VLAN designation at its run time memory .

To conserve memory storage space the cells of each port database array are only 2 bits wide. A code is used to associate the contents of each cell with a corresponding spanning tree port state. For example 00 may correspond to the port P not existing in the spanning tree database 01 may correspond to the port P being disabled 10 to the port being in any of the blocking listening or learning spanning tree port states and 11 may correspond to the port being in the forwarding state. As the active STP engine transitions the ports P of the switch among the various spanning tree states it updates the corresponding cells for these ports in the port database arrays with the appropriate two bit code in addition to updating the port state fields of the corresponding port data structures . The standby supervisor also updates the corresponding cells of its port data base arrays and the port state fields of its port data structures .

Suppose for example that the standby supervisor fails and is hot swapped with a new standby supervisor. Upon installation of the new standby supervisor which will also be referred to by designation number for simplicity the active supervisor first sends the standby all of the VLAN information for the network. That is the active supervisor informs the standby of all of the VLAN designations currently implemented within the bridged network . In response the standby supervisor initializes a VLAN table as described above. Next the active supervisor synchronizes its port database arrays to the new standby supervisor . That is the active supervisor informs the standby supervisor of the particular contents of the port database arrays at the active supervisor .

The standby supervisor then uses this information to fill in the cells of its arrays . Based on the contents of its port database arrays the standby supervisor then initializes the appropriate bridge and port data structures and loads the port state fields of the port data structures . That is if ports P and P at line card are associated with the green VLAN and are in the forwarding state as reflected by the information in the corresponding port database array the standby supervisor adds port data structures for these two ports P and P to the linked list of port data structures for the green VLAN designation entry of its VLAN table. The standby supervisor also sets the corresponding port state fields to reflect that these two ports are in the forwarding state for this VLAN designation.

As shown the standby supervisor can create the appropriate bridge and port data structures on is own based on the contents of the port database arrays from the active . This conserves significant messaging bandwidth processor resources and time at the active supervisor .

It should be understood that the STP engines and their consistent state machines may be configured to transition the ports P of switch among additional and or other spanning tree port state besides blocking listening learning and forwarding. For example they may be further configured to transition the ports P among the Forgetting Forwards and Forwarder states as described in IEEE draft standard 802.1w D1 Jul. 2 1999 as well.

The foregoing description has been directed to specific embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. For example other communication architectures or paradigms besides event based architectures such as primitives commit protocols etc. may be employed by the active and standby supervisor cards to exchange information relating to the spanning tree protocol. In another embodiment the bridged network may not support virtual LANs. In this case the supervisors would not initialize or maintain a VLAN table and would have a single bridge data structure and one port data structure per port P at the switch . The events and API calls moreover would not need to include the identity of the corresponding VLAN designation. Therefore it is an object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

