---

title: Query rebinding for high-availability database systems
abstract: Embodiments of the invention allow for managing execution of queries with respect to different data sources. The different data sources are logically represented by data abstraction models. One embodiment comprises receiving a first abstract query against physical data in a first data source. The first abstract query has result fields configured to return requested data from the first data source. In response it is detected whether the first data source is available. If the first data source is unavailable, a second abstract query against physical data in a second data source containing a portion of the requested data is created on the basis of the first abstract query. The second abstract query has result fields configured to return the portion of the requested data from the second data source. The second abstract query is executed against the second data source to obtain the portion of the requested data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07668807&OS=07668807&RS=07668807
owner: International Business Machines Corporation
number: 07668807
owner_city: Armonk
owner_country: US
publication_date: 20050224
---
This application is related to the following commonly owned applications U.S. patent application Ser. No. 10 083 075 filed Feb. 26 2002 entitled APPLICATION PORTABILITY AND EXTENSIBILITY THROUGH DATABASE SCHEMA AND QUERY ABSTRACTION U.S. patent application Ser. No. 11 016 201 filed on Dec. 17 2004 entitled TRANSFORMATION OF A PHYSICAL QUERY INTO AN ABSTRACT QUERY U.S. patent application Ser. No. 10 955 467 filed on Sep. 30 2004 entitled METADATA MANAGEMENT FOR A DATA ABSTRACTION MODEL all of which are hereby incorporated herein in their entireties.

The present invention generally relates to query processing and more particularly to managing execution of queries with respect to different data sources.

The creation of increasingly powerful computer systems and a continuously improved information technology IT infrastructure contribute to a progressive automation of key tasks and processes in today s businesses. As a result business processes such as shipping procurement and staffing are transformed so as to be conducted electronically. Such electronically conducted business processes are referred to as electronic business e business . A generally accepted widely used form of e business is electronic commerce e commerce . E commerce permits transactions for a variety of goods and services to be conducted electronically.

However while use and development of e business proliferate unplanned downtimes of computer systems in companies cause losses of thousands of dollars or more per hour to these companies. Accordingly prevention of unplanned downtime of computer systems becomes a key challenge in today s business world.

To help alleviate the problem of unplanned downtime many companies employ strategies termed High Availability HA . A popular HA strategy is to mirror an original computer system i.e. to make an exact duplicate of the computer system. Thus when unplanned downtime of the original computer system occurs the duplicate or mirror system is able to pick up any tasks that could not be completed by the original computer system before the downtime occurred.

However mirroring a complete computer system is relatively expensive. More specifically mirroring an original computer system generally requires another set of appropriate hardware middleware and software licenses. Accordingly the expenses for creating a mirror system for the original computer system could equal the cost of the original computer system. In other words mirroring the original computer system could easily involve expenses of hundreds of thousands of dollars or more for a given company. Furthermore if the original computer system includes a database s which is frequently updated or otherwise modified each such change must essentially be replicated in real time to the mirror system so that the mirror system continuously represents an exact copy of the original computer system. This requires intensive and costly maintenance of the mirror system.

The present invention is generally directed to a method system and article of manufacture for query processing and more particularly for managing execution of queries with respect to different data sources.

One embodiment provides a computer implemented method for managing execution of queries querying physical data logically represented by a data abstraction model. The method comprises receiving a first abstract query against physical data in a first data source. The first abstract query has one or more result fields configured to return requested data from the first data source each result field having a corresponding logical field specification of a first data abstraction model. Each corresponding logical field specification describes an access method for accessing physical data in the first data source. In response to receiving the first abstract query and determining that the first abstract query is configured for retrieving data from the first data source it is detected whether the first data source is available. If the first data source is unavailable a second abstract query against physical data in a second data source containing at least a portion of the requested data is created on the basis of the first abstract query. The second abstract query has one or more result fields configured to return at least the portion of the requested data from the second data source. Each result field of the second abstract query has a corresponding logical field specification of a second data abstraction model abstractly describing the second data source wherein each corresponding logical field specification describes an access method for accessing physical data in the second data source. The second abstract query is executed against the second data source to obtain at least the portion of the requested data.

Another embodiment provides a computer implemented method for managing execution of queries querying physical data logically represented by a data abstraction model comprising receiving a first abstract query against queryable data in a data warehouse. The first abstract query has one or more result fields configured to return requested data from the data warehouse each result field having a corresponding logical field specification of a first data abstraction model. Each corresponding logical field specification describes an access method for accessing physical data in the data warehouse. In response to receiving the first abstract query and determining that the first abstract query is configured for retrieving data from the data warehouse it is detected whether the data warehouse is available. If the data warehouse is unavailable a second abstract query against physical data in an operational data store containing all the queryable data of the data warehouse is created on the basis of the first abstract query. The data warehouse and the operational data store use differently structured data structures. The second abstract query has one or more result fields configured to return the requested data from the operational data store. Each result field of the second abstract query has a corresponding logical field specification of a second data abstraction model abstractly describing the operational data store wherein each corresponding logical field specification describes an access method for accessing physical data in the operational data store. The second abstract query is executed against the operational data store to obtain the requested data.

Another embodiment provides a computer readable medium containing a program which when executed by a processor performs operations for managing execution of queries querying physical data logically represented by a data abstraction model. The operations comprise receiving a first abstract query against physical data in a first data source the first abstract query having one or more result fields configured to return requested data from the first data source. Each result field has a corresponding logical field specification of a first data abstraction model wherein each corresponding logical field specification describes an access method for accessing physical data in the first data source. The operations further comprise in response to receiving the first abstract query and determining that the first abstract query is configured for retrieving data from the first data source detecting whether the first data source is available. If the first data source is unavailable a second abstract query against physical data in a second data source containing at least a portion of the requested data is created on the basis of the first abstract query. The second abstract query has one or more result fields configured to return at least the portion of the requested data from the second data source. Each result field of the second abstract query has a corresponding logical field specification of a second data abstraction model abstractly describing the second data source wherein each corresponding logical field specification describes an access method for accessing physical data in the second data source. The second abstract query is executed against the second data source to obtain at least the portion of the requested data.

Still another embodiment provides a system comprising a first data source having physical data a second data source having physical data including at least some of the physical data contained in the first data source and a query builder component for managing execution of queries querying physical data logically represented by a data abstraction model. The query builder component is configured to i receive a first abstract query against the physical data in the first data source the first abstract query having one or more result fields configured to return requested data from the first data source each result field having a corresponding logical field specification of a first data abstraction model wherein each corresponding logical field specification describes an access method for accessing physical data in the first data source ii detect in response to receiving the first abstract query and determining that the first abstract query is configured for retrieving data from the first data source whether the first data source is available and iii if the first data source is unavailable a create on the basis of the first abstract query a second abstract query against the physical data in the second data source containing at least a portion of the requested data the second abstract query having one or more result fields configured to return at least the portion of the requested data from the second data source each result field of the second abstract query having a corresponding logical field specification of a second data abstraction model abstractly describing the second data source wherein each corresponding logical field specification describes an access method for accessing physical data in the second data source and b execute the second abstract query against the second data source to obtain at least the portion of the requested data.

The present invention describes techniques that are suitable to provide high availability database systems. Embodiments of the present invention leverage the availability of redundant data and a corresponding data abstraction model s to provide such high availability database systems.

By way of example assume that an original computer system contains a data warehouse. A data warehouse is a summary and restructuring of a subset of information contained in an operational data store in a schema which is highly optimized for queries involving many rows and aggregation functions. Accordingly the data warehouse only contains a valuable fraction of the information included in the operational data store. Assume further that the operational data store is hosted on another computer system. Operational data stores are generally structured for tasks like order entry and retrieval which involve very few rows and many insert and update operations. As the operational data store contains all information contained in the data warehouse and is stored on a different computer system the operational data store could be used as mirror of the data warehouse. Accordingly the data warehouse and the operational data store could be used to define a high availability database system.

However one difficulty in using the operational data store as mirror of the data warehouse results from the radically different ways in which operational data stores and data warehouses generally structure data contained therein. Accordingly a query issued against the data warehouse can not readily be executed against the operational data store. Instead a specific query needs to be created against the data warehouse and another specific query against the operational data store in order to obtain an identical query result. This drawback currently prevents operational data stores of being used as mirrors for corresponding data warehouses.

More generally it is difficult to use a given data source containing all information of another data source as mirror of that other data source if both data sources are not structured identically i.e. if the given data source and the other data source have similar physical data but dissimilar data structures. For instance physical data that is contained in a particular column of a particular table of the given data source can be contained in a different column of an identical or another table in the other data source. By way of example consider patient identifiers that are contained in a column ID of a PATIENT table in the given data source. The same patient identifiers may be contained in a column PATIENT ID of a table DEMOGRAPHIC of the other data source. Thus a query structured to be run against the given data source cannot be arbitrarily redirected and run against the other data source because the respective tables are structured differently.

Embodiments of the present invention address these difficulties with the provision of a data abstraction model s that abstractly describes physical data contained in various disparate data sources. According to one aspect the physical data in the multiple data sources is accessed using one or more data abstraction models which abstractly describe the physical data. A data abstraction model defines a logical representation of the physical data. Using a data abstraction model abstract queries against the physical data can be constructed without regard for the makeup of the physical data. The data abstraction model is adapted for facilitating transformation of the abstract queries into a form consistent with a physical representation of the physical data. The concepts of data abstraction models and abstract queries are described in detail in the commonly owned co pending application Ser. No. 10 083 075 hereinafter referred to as the 075 application entitled APPLICATION PORTABILITY AND EXTENSIBILITY THROUGH DATABASE SCHEMA AND QUERY ABSTRACTION filed Feb. 26 2002 herein incorporated by reference in its entirety. Using a data abstraction model s according to the framework of the 075 application execution of queries querying physical data in various disparate data sources that is logically represented by a data abstraction model s can be managed to provide a high availability database system.

The present invention generally is directed to a method system and article of manufacture for query processing and more particularly for managing execution of queries querying physical data logically represented by a data abstraction model. According to one aspect a data abstraction model defines a plurality of logical fields each having a corresponding logical field specification. Each logical field specification may include a field name and access information for mapping the logical field to one or more physical entities of physical data. Accordingly a given logical field defines an abstract representation of a specific set of the physical data and the access information can be used to access a field of the physical data which contains the specific set of the physical data.

In one embodiment execution of abstract queries is managed where the queries query physical data which is logically represented by a data abstraction model. The physical data is contained in a first data source and at least a portion of the physical data is contained in a second data source the first and second data sources having dissimilar data structures. In the context of the present invention dissimilar data structures include for instance different database schemas different database tables and database tables having different columns. A first data abstraction model abstractly describes the physical data in the first data source and a second data abstraction model abstractly describes the physical data in the second data source. Alternatively the physical data in both data sources can be abstractly described by a single data abstraction model having a distinct section for each data source. More generally embodiments of the invention are not limited to any particular number of data sources and data abstraction models.

In response to receiving an abstract query and determining that the abstract query is configured for retrieving data from the first data source an availability monitor determines the status of the first data source in order to determine whether the first data source is available. If the first data source is unavailable a query rebinding component may rewrite the abstract query for execution against the second data source. In other words the query rebinding component is configured to transform the abstract query which is consistent with the first data abstraction model into a rebound abstract query which is consistent with the second data abstraction model. Transforming the abstract query into the rebound abstract query is performed using predefined mappings between the first and second data abstraction models. Such mappings can be stored in a suitable mapping file as a persistent data object.

According to aspects of the invention rewriting the abstract query into the rebound abstract query can be made dependent on respective instructions. For instance if the availability monitor detects that the first data source is unavailable a requesting entity issuing the abstract query can be notified that the first data source is unavailable. Furthermore the requesting entity can be requested to grant permission for use of the second data source wherein the abstract query is only rewritten if the permission is granted.

It should be noted that embodiments of the present invention can be explained below by way of example with reference to particular data abstraction models such as a data abstraction model according to the framework of the 075 application. However other embodiments can be implemented using other types of logical models which abstractly describe physical data. Accordingly the present invention is not limited to a particular data abstraction model including data abstraction models according to the framework of the 075 application and various different logical models of physical data which abstractly describe the physical data are broadly contemplated.

In the following reference is made to embodiments of the invention. However it should be understood that the invention is not limited to specific described embodiments. Instead any combination of the following features and elements whether related to different embodiments or not is contemplated to implement and practice the invention. Furthermore in various embodiments the invention provides numerous advantages over the prior art. However although embodiments of the invention may achieve advantages over other possible solutions and or over the prior art whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus the following aspects features embodiments and advantages are merely illustrative and unless explicitly present are not considered elements or limitations of the appended claims.

One embodiment of the invention is implemented as a program product for use with a computer system such as for example computer system shown in and described below. The program s of the program product defines functions of the embodiments including the methods described herein and can be contained on a variety of signal bearing media. Illustrative signal bearing media include but are not limited to i information permanently stored on non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive ii alterable information stored on writable storage media e.g. floppy disks within a diskette drive or hard disk drive or iii information conveyed to a computer by a communications medium such as through a computer or telephone network including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal bearing media when carrying computer readable instructions that direct the functions of the present invention represent embodiments of the present invention.

In general the routines executed to implement the embodiments of the invention may be part of an operating system or a specific application component program module object or sequence of instructions. The software of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine readable format and hence executable instructions. Also programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However it should be appreciated that any particular nomenclature that follows is used merely for convenience and thus the invention should not be limited to use solely in any specific application identified and or implied by such nomenclature.

Referring now to a computing environment is shown. In general the distributed environment includes computer system and a plurality of networked devices . The computer system may represent any type of computer computer system or other programmable electronic device including a client computer a server computer a portable computer an embedded controller a PC based server a minicomputer a midrange computer a mainframe computer and other computers adapted to support the methods apparatus and article of manufacture of the invention. In one embodiment the computer system is an eServer computer available from International Business Machines of Armonk N.Y.

Illustratively the computer system comprises a networked system. However the computer system may also comprise a standalone device. In any case it is understood that is merely one configuration for a computer system. Embodiments of the invention can apply to any comparable configuration regardless of whether the computer system is a complicated multi user apparatus a single user workstation or a network appliance that does not have non volatile storage of its own.

The embodiments of the present invention may also be practiced in distributed computing environments in which tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices. In this regard the computer system and or one or more of the networked devices may be thin clients which perform little or no processing.

The computer system could include a number of operators and peripheral systems as shown for example by a mass storage interface operably connected to a direct access storage device by a video interface operably connected to a display and by a network interface operably connected to the plurality of networked devices . The display may be any video output device for outputting viewable information.

Computer system is shown comprising at least one processor which obtains instructions and data via a bus from a main memory . The processor could be any processor adapted to support the methods of the invention. The main memory is any memory sufficiently large to hold the necessary programs and data structures. Main memory could be one or a combination of memory devices including Random Access Memory nonvolatile or backup memory e.g. programmable or Flash memories read only memories etc. . In addition memory may be considered to include memory physically located elsewhere in the computer system for example any storage capacity used as virtual memory or stored on a mass storage device e.g. direct access storage device or on another computer coupled to the computer system via bus .

The memory is shown configured with an operating system . The operating system is the software used for managing the operation of the computer system . Examples of the operating system include IBM OS 400 UNIX Microsoft Windows and the like.

The memory further includes one or more applications and an abstract model interface to a plurality of data abstraction models . The applications the abstract model interface and the data abstraction models are software products comprising a plurality of instructions that are resident at various times in various memory and storage devices in the computer system . When read and executed by one or more processors in the computer system the applications the abstract model interface and the data abstraction models cause the computer system to perform the steps necessary to execute steps or elements embodying the various aspects of the invention.

The applications and more generally any requesting entity including the operating system are configured to issue queries against a database . Illustratively the database is shown as part of a database management system DBMS in storage . Although only one database is shown for simplicity the DBMS may include multiple databases. Further the databases may be distributed relative to one another. Moreover one or more databases can be distributed to one or more of the networked devices . Illustratively a networked device is shown having a DBMS which includes a database . Although only a single database is shown with the DBMS for simplicity the DBMS may include multiple databases. Further the databases of the DBMS may be distributed relative to one another. All such different implementations are broadly contemplated.

The databases and are representative of any collection of data regardless of the particular physical representation of the data. A physical representation of data defines an organizational schema of the data. By way of illustration the databases and may be organized according to a relational schema accessible by SQL queries or according to an XML schema accessible by XML queries . However the invention is not limited to a particular schema and contemplates extension to schemas presently unknown. As used herein the term schema generically refers to a particular arrangement of data.

In one embodiment the database includes a data warehouse and the database includes an operational data store. The operational data store includes at least a portion of the physical data contained in the data warehouse. According to one aspect the data warehouse contains queryable data which is derived from physical data in the operational data store. Accordingly the queryable data in the data warehouse includes a subset of the physical data in the operational data store. In addition to the subset of data from the operational data store the data warehouse may include other data.

The queries issued by the applications are defined according to an application query specification included with each application . The queries issued by the applications may be predefined i.e. hard coded as part of the applications or may be generated in response to input e.g. user input . In either case the queries referred to herein as abstract queries can be composed using logical fields defined by one of a plurality of data abstraction models . In one embodiment each of the data abstraction models defines a multiplicity of logical fields. A logical field defines an abstract view of data whether as an individual data item or a data structure in the form of for example a database table. Abstract queries are executed against the database by a query builder component which first transforms the abstract queries into concrete queries having a form consistent with the physical representation of the data contained in the database . Operation of the query builder component for transformation of abstract queries into concrete queries and execution of the concrete queries is described below with reference to .

In one embodiment the query builder component is further configured to support creation of abstract queries. More specifically the query builder component is configured to formulate an abstract query for execution against a given data source e.g. database . The query builder component may further rewrite the abstract query in order to allow execution of the rewritten abstract query against another data source e.g. database as will be described in more detail below. Operation of the query builder component for rewriting abstract queries is further described below with reference to .

As was noted above the logical fields specified by the application query specification and used to compose the abstract query are defined by the data abstraction model . In general the data abstraction model exposes information as a set of logical fields that may be used within a query e.g. the abstract query issued by the application to specify criteria for data selection and specify the form of result data returned from a query operation. The logical fields are defined independently of the underlying data representation being used in a corresponding database e.g. database of thereby allowing queries to be formed that are loosely coupled to the underlying data representation.

In one embodiment illustrated in the data abstraction model comprises a plurality of field specifications and five shown by way of example collectively referred to as the field specifications also referred to hereinafter as field definitions . Specifically a field specification is provided for each logical field available for composition of an abstract query. Each field specification may contain one or more attributes. Illustratively the field specifications include a logical field name attribute collectively field name and an associated access method attribute collectively access methods . Each attribute may have a value. For example logical field name attribute has the value FirstName and access method attribute has the value Simple . Furthermore each attribute may include one or more associated abstract properties. Each abstract property describes a characteristic of a data structure and has an associated value. In the context of the invention a data structure refers to a part of the underlying physical representation that is defined by one or more physical entities of the data corresponding to the logical field. In particular an abstract property may represent data location metadata abstractly describing a location of a physical data entity corresponding to the data structure like a name of a database table or a name of a column in a database table. Illustratively the access method attribute includes data location metadata Table and Column . Furthermore data location metadata Table has the value contact and data location metadata Column has the value f name . Accordingly assuming an underlying relational database schema in the present example the values of data location metadata Table and Column point to a table contact having a column f name .

In one embodiment groups i.e. two or more of logical fields may be part of categories. Accordingly the data abstraction model includes a plurality of category specifications and two shown by way of example collectively referred to as the category specifications. In one embodiment a category specification is provided for each logical grouping of two or more logical fields. For example logical fields and are part of the category specifications and respectively. A category specification is also referred to herein simply as a category . The categories are distinguished according to a category name e.g. category names and collectively category name s . In the present illustration the logical fields are part of the Name and Address category and logical fields are part of the Birth and Age category.

The access methods generally associate i.e. map the logical field names to data in the database e.g. database of . As illustrated in the access methods associate the logical field names to a particular physical data representation . . . in the database. By way of illustration two data representations are shown an XML data representation and a relational data representation . However the physical data representation indicates that any other data representation known or unknown is contemplated. In one embodiment a single data abstraction model contains field specifications with associated access methods for two or more physical data representations . In an alternative embodiment a different single data abstraction model is provided for each separate physical data representation .

Any number of access methods is contemplated depending upon the number of different types of logical fields to be supported. In one embodiment access methods for simple fields filtered fields and composed fields are provided. The field specifications and exemplify simple field access methods and respectively. Simple fields are mapped directly to a particular entity in the underlying physical representation e.g. a field mapped to a given database table and column . By way of illustration as described above the simple field access method shown in maps the logical field name FirstName to a column named f name in a table named contact . The field specification exemplifies a filtered field access method . Filtered fields identify an associated physical entity and provide filters used to define a particular subset of items within the physical representation. An example is provided in in which the filtered field access method maps the logical field name AnyTownLastName to a physical entity in a column named l name in a table named contact and defines a filter for individuals in the city of Anytown . Another example of a filtered field is a New York ZIP code field that maps to the physical representation of ZIP codes and restricts the data only to those ZIP codes defined for the state of New York. The field specification exemplifies a composed field access method . Composed access methods compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way information which does not exist in the underlying physical data representation may be computed. In the example illustrated in the composed field access method maps the logical field name AgeInDecades to AgeInYears 10 . Another example is a sales tax field that is composed by multiplying a sales price field by a sales tax rate.

It is contemplated that the formats for any given data type e.g. dates decimal numbers etc. of the underlying data may vary. Accordingly in one embodiment the field specifications include a type attribute which reflects the format of the underlying data. However in another embodiment the data format of the field specifications is different from the associated underlying physical data in which case a conversion of the underlying physical data into the format of the logical field is required.

By way of example the field specifications of the data abstraction model shown in are representative of logical fields mapped to data represented in the relational data representation shown in . However other instances of the data abstraction model map logical fields to other physical representations such as XML.

An illustrative abstract query corresponding to the abstract query shown in is shown in Table I below. By way of illustration the illustrative abstract query is defined using XML. However any other language may be used to advantage.

Illustratively the abstract query shown in Table I includes a selection specification lines 004 008 containing selection criteria and a results specification lines 009 013 . In one embodiment a selection criterion consists of a field name for a logical field a comparison operator 

An illustrative data abstraction model DAM corresponding to the data abstraction model shown in is shown in Table II below. By way of illustration the illustrative Data Abstraction Model is defined using XML. However any other language may be used to advantage.

By way of example note that lines 004 008 correspond to the first field specification of the DAM shown in and lines 009 013 correspond to the second field specification .

As was noted above the abstract query of Table I can be transformed into a concrete query for query execution. An exemplary method for transforming an abstract query into a concrete query is described below with reference to .

Referring now to an illustrative runtime method exemplifying one embodiment of the operation of the query builder component of is shown. The method is entered at step when the query builder component receives as input an abstract query such as the abstract query shown in Table I . At step the query builder component reads and parses the abstract query and locates individual selection criteria and desired result fields. At step the query builder component enters a loop defined by steps and for processing each query selection criteria statement present in the abstract query thereby building a data selection portion of a concrete query. In one embodiment a selection criterion consists of a field name for a logical field a comparison operator 

After building the data selection portion of the concrete query the query builder component identifies the information to be returned as a result of query execution. As described above in one embodiment the abstract query defines a list of result fields i.e. a list of logical fields that are to be returned as a result of query execution referred to herein as a result specification. A result specification in the abstract query may consist of a field name and sort criteria. Accordingly the method enters a loop at step defined by steps and to add result field definitions to the concrete query being generated. At step the query builder component looks up a result field name from the result specification of the abstract query in the data abstraction model and then retrieves a result field definition from the data abstraction model to identify the physical location of data to be returned for the current logical result field. The query builder component then builds at step a concrete query contribution of the concrete query that identifies physical location of data to be returned for the logical result field. At step the concrete query contribution is then added to the concrete query statement. Once each of the result specifications in the abstract query has been processed the concrete query is executed at step .

One embodiment of a method for building a concrete query contribution for a logical field according to steps and is described with reference to . At step the method queries whether the access method associated with the current logical field is a simple access method. If so the concrete query contribution is built step based on physical data location information and processing then continues according to method described above. Otherwise processing continues to step to query whether the access method associated with the current logical field is a filtered access method. If so the concrete query contribution is built step based on physical data location information for a given data structure s . At step the concrete query contribution is extended with additional logic filter selection used to subset data associated with the given data structure s . Processing then continues according to method described above.

If the access method is not a filtered access method processing proceeds from step to step where the method queries whether the access method is a composed access method. If the access method is a composed access method the physical data location for each sub field reference in the composed field expression is located and retrieved at step . At step the physical field location information of the composed field expression is substituted for the logical field references of the composed field expression whereby the concrete query contribution is generated. Processing then continues according to method described above.

If the access method is not a composed access method processing proceeds from step to step . Step is representative of any other access method types contemplated as embodiments of the present invention. However it should be understood that embodiments are contemplated in which less then all the available access methods are implemented. For example in a particular embodiment only simple access methods are used. In another embodiment only simple access methods and filtered access methods are used.

Referring now to a relational view of components implementing one aspect of the invention is illustrated. The components illustratively include a requesting entity e.g. application s of a plurality of database connectivity tools and a query builder component e.g. query builder component of and data sources and e.g. databases and of .

The query builder component includes a plurality of elements which implement constituent functions of the query builder component . Illustratively these elements include data abstraction models and e.g. data abstraction models of a runtime component an availability monitor and a query rebinding component . However it should be noted that one or more of these elements can also be implemented as separate components. For instance the data abstraction models and can be implemented as separate software components as shown in .

By way of example each of the data abstraction models and is associated with a corresponding data source of the data sources and . More specifically the data abstraction model DAM 1 abstractly describes the data source DATA SOURCE 1 the data abstraction model DAM 2 abstractly describes the data source DATA SOURCE 2 and the data abstraction model DAM N abstractly describes the data source DATA SOURCE N . Alternatively as was noted above all or at least a portion of the data sources can be abstractly described by a common data abstraction model. In this case the common data abstraction model can be divided into a plurality of sections where each section abstractly describes e.g. in the form of field names and access methods an associated data source.

The requesting entity can be any entity which is suitable to issue queries against the data sources and including suitable applications e.g. applications of an operating system e.g. operating system of and at the highest level users. Illustratively the requesting entity issues a query against the data source DATA SOURCE 1 as illustrated by dashed arrow . To this end the requesting entity accesses one of the database connectivity tools or for creation of the query . Illustratively the database connectivity tools and include a Web application an Open DataBase Connectivity ODBC driver a Java DataBase Connectivity JDBC driver and a Java Application Programming Interface Java API . The Web application is an application that is accessible by a Web browser and that provides some function beyond static display of information for instance by allowing the requesting entity to query the data source . The ODBC driver is a driver that provides a set of standard application programming interfaces to perform database functions such as connecting to the data source performing dynamic SQL functions and committing or rolling back database transactions. The JDBC driver is a program included with a database management system e.g. DBMS of to support JDBC standard access between the data source and Java applications. The Java API is a Java based interface that allows an application program e.g. the requesting entity the ODBC or the JDBC that is written in a high level language to use specific data or functions of an operating system e.g. operating system of or another program e.g. the query builder component .

In one embodiment the query is received by the query builder component in an abstract form. For instance the query is received through the ODBC the JDBC or the Java API and references logical fields which are defined by the data abstraction model which abstractly defines the physical data in the data source DATA SOURCE 1 i.e. the data abstraction model DAM 1 . In this case the query can be in an SQL like form where the logical fields are referenced using SQL but without including other conventional SQL grammar such as join logic. In another embodiment the query builder component receives the query in physical form and transforms this query into an abstract query e.g. abstract query of . In this case the query is a physical query such as an SQL query which is transformed into the abstract form. This transformation can be performed using embodiments described in U.S. patent application Ser. No. 11 016 201 filed on Dec. 17 2004 entitled TRANSFORMATION OF A PHYSICAL QUERY INTO AN ABSTRACT QUERY .

However it should be noted that in one embodiment the requesting entity can directly access the query builder component to compose the abstract query. Furthermore the query can already be an existing abstract query which is for instance retrieved from storage.

As was noted above in the given example the query is issued against the data source DATA SOURCE 1 and thus refers to the logical fields which are defined by the data abstraction model DAM 1 . By way of example assume that the data source DATA SOURCE 1 defines a data warehouse that contains information about customer orders which have been received by a given company. An exemplary data source having three database tables is illustrated in Table III below. For simplicity the exemplary database tables are represented in a shorthand format. Further for brevity only parts that are relevant for the following explanations are shown.

It should be noted that the exemplary data source illustrated in Table III includes three database tables i a BuyerInfo table lines 001 004 containing information about customers ii an OrderInfo table lines 005 008 containing information used to identify orders and iii an OrderItems table lines 009 012 containing information about ordered items. Each of these three database tables illustratively includes three columns. More specifically the BuyerInfo table includes an ID column line 002 an Address column line 003 and a Name column line 004 . The OrderInfo table includes an ID column line 006 an OrderDate column line 007 and a BuyerID column line 008 . The OrderItems table includes an ID column line 010 a Description column line 011 and an OrderID column line 012 .

As was noted above the data source DATA SOURCE 1 is abstractly described by the data abstraction model DAM 1 . Table IV below illustrates a possible structure of the data abstraction model DAM 1 . For simplicity elements of the data abstraction model are represented in a shorthand format. Persons skilled in the art will readily recognize corresponding XML representations. Further for brevity only parts that are relevant for the following explanations are shown. It is noted that this manner of presentation applies to other tables described below as well.

As can be seen from lines 001 005 and 008 the exemplary data abstraction model includes three categories shown on the far left hand side i.e. Buyer Order and Order Items . Each category includes logical fields each prefixed by which are illustratively associated with an access method. By way of example the Buyer category includes a logical field Buyer ID line 002 which is associated as illustrated by an arrow with an access method which links the Buyer ID field to the ID column of the BUYERINFO table in the exemplary data source of Table III BUYERINFO.ID in line 002 .

Assume now that the abstract query illustrated in Table V below is issued against the data source DATA SOURCE 1 of Table III. For simplicity the exemplary abstract query of Table V is illustrated in natural language. Persons skilled in the art will readily recognize corresponding XML representations such as used to describe the exemplary abstract query of Table I. However it should be noted that implementation of the exemplary abstract query is not limited to a particular machine readable language and that an implementation in any machine readable language known or unknown is broadly contemplated.

It should be noted that the abstract query of Table V is configured to identify from the data source DATA SOURCE 1 a list of order identifiers Order ID in line 002 and corresponding customer names Name in line 002 for all customer orders which have been received by the given company between September 2004 Order Date August 2004 in line 004 and October 2004 Order Date

In response to creating receiving the exemplary abstract query of Table V the query builder component determines whether the abstract query is configured for retrieving data from the data source DATA SOURCE 1 . If so the availability monitor determines the status of the data source DATA SOURCE 1 . Dependent on the status of the data source DATA SOURCE 1 the query rebinding component may rewrite the abstract query for execution against another data source if the other data source contains at least a portion of the physical data contained in the data source DATA SOURCE 1 .

Assume now that the data source DATA SOURCE 2 defines an operational data store which contains all information about customer orders which is available by the data warehouse defining the data source DATA SOURCE 1 . An exemplary data source representing the data source DATA SOURCE 2 having a single database table is illustrated in Table VI below by way of example. For simplicity the exemplary database table is represented in a shorthand format. Further for brevity only parts that are relevant for the following explanations are shown.

It should be noted that the exemplary data source illustrated in Table VI includes a single EntryInfo database table lines 001 008 containing i information about customers lines 002 004 ii information used to identify orders lines 005 006 and information about ordered items lines 007 008 . Specifically the EntryInfo database table includes seven columns. More specifically the EntryInfo table includes an ID column line 002 an Address column line 003 a Name column line 004 an OrderID column line 005 an OrderDate column line 006 an ItemID column line 007 and a Description column line 008 . In the given example the ID column line 002 corresponds to the ID column in line 002 of Table III the Address column line 003 corresponds to the Address column in line 003 of Table III the Name column line 004 corresponds to the Name column in line 004 of Table III the OrderID column line 005 corresponds to the ID column in line 006 of Table III the OrderDate column line 006 corresponds to the Date column in line 007 of Table III the ItemID column line 007 corresponds to the ID column in line 010 of Table II and the Description column line 008 corresponds to the Description column in line 011 of Table III.

As was noted above the data source DATA SOURCE 2 is abstractly described by the data abstraction model DAM 2 . As an example of the data abstraction model DAM 2 the exemplary data abstraction model DAM2 shown in Table VII below is illustrated. For simplicity elements of the data abstraction model are represented in a shorthand format. Persons skilled in the art will readily recognize corresponding XML representations. Further for brevity only parts that are relevant for the following explanations are shown.

As can be seen from lines 001 005 and 008 the exemplary data abstraction model includes three categories i.e. Buyer Order and Order Items . Furthermore each category includes logical fields which are illustratively associated with an access method. By way of example the Buyer category includes a logical field Customer Identifier line 002 which is associated as illustrated by an arrow with an access method which links the Customer Identfier field to the BUYERID column of the ENTRYINFO table in the exemplary data source of Table VI ENTRYINFO.BUYERID in line 002 .

In order to enable execution of the abstract query against the data source DATA SOURCE 2 the abstract query of Table V must be modified since the abstract query was originally written to retrieve data from data source DATA SOURCE 1 of Table II and since data source DATA SOURCE 1 and data source DATA SOURCE 2 are structured differently. Therefore the abstract query must be modified with respect to the data abstraction model DAM 2 which abstractly describes the data source DATA SOURCE 2 .

Illustratively the abstract query is rewritten into a rebound abstract query . In other words the query rebinding component transforms the abstract query which is consistent with the data abstraction model DAM 1 into the rebound abstract query which is consistent with the data abstraction model DAM 2 . The rebound abstract query can be transformed into a concrete query by the runtime component and executed against the data source DATA SOURCE 2 . In one embodiment rewriting transforming the abstract query into the rebound abstract query includes creating the rebound abstract query on the basis of the abstract query. An exemplary method for creation of a rebound abstract query on the basis of an original abstract query is described in more detail below with reference to .

Referring now to an exemplary method for managing execution of an abstract query e.g. abstract query of is illustrated. In one embodiment at least a portion of the steps of method is performed using a suitable query builder component e.g. query builder component of . Method starts at step .

At step an abstract query against physical data in a first data source e.g. data source of is received from a requesting entity e.g. requesting entity of . By default configuration the abstract query is configured to obtain requested data from the first data source. Furthermore the abstract query is specified using logical fields of a first data abstraction model e.g. data abstraction model of which abstractly describes the physical data in the first data source.

It should be noted that receiving the abstract query includes receiving a query in an SQL like abstract form or a non abstract query e.g. query of and transforming the non abstract query into the abstract query as described above with reference to . Furthermore receiving the abstract query includes in one embodiment determining that the abstract query is issued against the first data source.

At step it is determined whether the first data source is available. This determination can be performed using a suitable availability monitor e.g. availability monitor of . However it should be noted that any suitable technique for determining the status of the first data source known or unknown is broadly contemplated.

If the first data source is available the abstract query is transformed into a concrete query and executed against the first data source at step . Transforming the abstract query into the concrete query can be performed using a suitable runtime component e.g. runtime component of according to the exemplary methods which are described above with reference to . Processing then continues at step as described below.

If however the first data source is unavailable the abstract query is rebound against a second data abstraction model abstractly describing physical data in a second data source e.g. data source of having similar information as the first data source at step . More specifically if the first data source is unavailable a determination can be performed at step in order to determine whether any available data source contains at least a portion of the physical data contained in the first data source and or at least a portion of the requested data. This determination can be performed using any suitable known or unknown technique including by way of example look up tables. Accordingly any suitable technique is broadly contemplated.

Assume now that the first data source defines the data warehouse of Table III and that the second data source defines the operational data store of Table VI which contains all queryable data contained in the data warehouse. Accordingly it can be determined at step that the second data source contains the physical data of the first data source and thus the abstract query can be rebound to the second data source. An exemplary method for rebinding the abstract query to the second data source is described in more detail below with reference to . A corresponding rebound abstract query is accordingly specified using logical fields of a second data abstraction model e.g. data abstraction model of which abstractly describes the physical data in the second data source.

At step the rebound abstract query e.g. rebound abstract query of is transformed into a concrete query and executed against the second data source to obtain a corresponding query result. Transforming the rebound abstract query into the concrete query can be performed using a suitable runtime component e.g. runtime component of according to the exemplary methods which are described above with reference to .

Referring now to an exemplary method for creation of a rebound abstract query e.g. rebound abstract query of on the basis of an original abstract query e.g. abstract query of is illustrated. According to one aspect method is entered from step of method of . At least a portion of the steps of method is performed using a suitable query builder component e.g. query builder component of .

Method starts at step where the requesting entity is notified that the first data source is unavailable and that the abstract query needs to be rebound against the second data source to obtain at least a portion of the requested data. However it should be noted that step is merely optional. Instead the query builder component can be configured to rebind the abstract query automatically against the second data source if the first data source is unavailable. In this case method starts at step as described below.

In one embodiment notifying the requesting entity includes prompting the requesting entity to indicate whether the abstract query should be rebound against the second data source and or to grant permission for use of the second data source. According to one aspect the notification may include some disclaimer information indicating that the rebound abstract query may require a longer execution time so as not to affect the performance of the second data source. The disclaimer information may further indicate that the information returned from the second data source can be slightly different from the information that is obtainable from the first data source as the second data source may have more information than the first data source so that the rebound abstract query may return more results. Furthermore in one embodiment notifying the requesting entity includes prompting the requesting entity to select one of a plurality of data sources against which the abstract query should be rebound.

If the requesting entity indicates that the abstract query should not be rebound and or denies permission for use of the second data source the abstract query is not rebound against the second data source. In this case rebinding the abstract query according to method can be terminated and a corresponding notification can be issued to the requesting entity. In one embodiment if the rebinding is terminated processing immediately returns to step of method where method exits.

If the rebinding of the abstract query is requested by the requesting entity or if the rebinding is performed automatically predefined mappings between the first and second data abstraction models are retrieved or generated. According to one aspect such mappings are provided with the query rebinding component. However the mappings can alternatively be stored as a persistent data object in storage e.g. as a suitable mapping file. In one embodiment the mappings are generated using a metaDAM. Generally a metaDAM defines relationships between corresponding fields in two or more DAMs. For example a metaDAM may specify that Logical  of DAM corresponds to Logical Field  of DAM where Logical Field  may be Buyer ID and Logical Field  may be Customer Identifier. In other words the metaDAM contains mappings between counterpart fields in different DAMs. Accordingly the metaDAM can be accessed to identify corresponding fields between two or more DAMs. In one embodiment this identification can be performed at runtime so that only identification is done only with respect to fields contained in a given query being processed. Alternatively a mapping file can be created prior to runtime that contains all mappings between two or more DAMs. The mapping file is then accessed at runtime for a given query being processed. Embodiments of metaDAMs that may be used to advantage are described in U.S. patent application Ser. No. 10 955 467 filed on Sep. 30 2004 entitled METADATA MANAGEMENT FOR A DATA ABSTRACTION MODEL . All such different implementations are broadly contemplated.

In the given example the mapping file includes mappings between the exemplary data abstraction model DAM1 shown in Table IV and the exemplary data abstraction model DAM2 shown in Table VII. An exemplary mapping file including the mappings of the given example is illustrated in Table VIII below. For simplicity elements of the mapping file are represented in a shorthand format. Specifically for brevity only parts that are relevant for the following explanations are shown.

As can be seen from Table VIII the exemplary mapping file maps each logical field of the exemplary data abstraction model DAM1 of Table IV to a corresponding logical field of the exemplary data abstraction model DAM2 of Table VII. By way of example it can be seen from line 001 that the exemplary mapping file maps the Buyer ID field of the exemplary data abstraction model DAM1 line 002 of Table IV to the Customer Identifier field of the exemplary data abstraction model DAM2 line 002 of Table VII .

However it should be noted that the exemplary mapping file of Table VIII is merely illustrated by way of example and that other implementations are contemplated. Specifically the granularity of mappings can be adapted as required. For instance the mapping illustrated in line 001 of Table VIII may be defined as Buyer Buyer ID substring Buyer Customer Identifier 1 20 . In this case only a substring consisting of characters 1 to 20 of the identifier defined by the logical field Customer Identifier maps to the identifier as defined by the logical field Buyer ID .

At step a loop consisting of steps and is entered for each result field and each condition field which is referred to in the abstract query. For simplicity the loop only refers to and is only explained by way of example with respect to result fields. More specifically at step the loop is entered for a first result field of the abstract query. Assume now that in the given example the loop is initially entered for the result field Order ID line 002 of Table V which is defined by the exemplary data abstraction model of Table IV.

At step a matching logical field of the exemplary data abstraction model of Table VIII is identified from the mapping file i.e. the exemplary mapping file of Table VIII. In the given example the matching logical field for the Order ID field is the Order Number field of the exemplary data abstraction model of Table VII line 004 of Table VIII . At step a result field corresponding to the matching logical field i.e. the Order Number field is added to the rebound abstract query.

When the loop consisting of steps and has been performed for each result field and each condition field processing continues at step . At step the rebound abstract query is created using the added result and condition fields. In the given example the exemplary rebound abstract query illustrated in Table IX below is obtained. For simplicity the exemplary rebound abstract query of Table IX is illustrated in natural language. Persons skilled in the art will readily recognize corresponding XML representations such as used to describe the exemplary abstract query of Table I. However it should be noted that implementation of the exemplary abstract query is not limited to a particular machine readable language and that an implementation in any machine readable language known or unknown is broadly contemplated.

By way of example it should be noted that the result field Name in line 002 of the abstract query of Table V has been rebound to the logical field Customer Name line 002 of the exemplary data abstraction model of Table VII according to line 002 of the exemplary mapping file of Table VIII. Furthermore it should be noted that according to lines 004 005 the condition field Order Date of the abstract query of Table V has been rebound to the logical field Order Date line 007 of the exemplary data abstraction model of Table VII according to line 005 of the exemplary mapping file of Table VIII.

It should be noted that any reference herein to particular values definitions programming languages and examples is merely for purposes of illustration. Accordingly the invention is not limited by any particular illustrations and examples. Furthermore while the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof and the scope thereof is determined by the claims that follow.

