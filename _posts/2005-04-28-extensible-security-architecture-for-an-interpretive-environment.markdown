---

title: Extensible security architecture for an interpretive environment
abstract: The Techniques and Mechanisms Described Herein are Directed to an Extensible security architecture that provides a security mechanism for minimizing security problems within interpretive environments. The extensible security architecture comprises a script engine configured to process a script and a security manager configured to monitor the processing of the script based on a security policy. The security manager determines whether to open an assembly associated with a command within the script, whether to process the command, whether to allow certain input to the command, and the like. The security policy may be implemented by overriding one or more methods of a base security class that are called when processing the script. The input may be an object passed via an object-based pipeline.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07631341&OS=07631341&RS=07631341
owner: Microsoft Corporation
number: 07631341
owner_city: Redmond
owner_country: US
publication_date: 20050428
---
This document generally relates to interpretive environments and more particularly to security mechanisms for interpretive environments.

Interpretive environments also commonly referred to as shells allow system administrators to automate tasks through the use of scripts. Shell scripting languages are used to write the scripts. Because many of the scripting languages and shells date back to before the Internet boom they were not designed for warding off attacks by malicious individuals seeking to exploit vulnerabilities within the scripts and or within the shell. These attacks include overrunning buffers inserting unexpected text code in the input to the script inserting unexpected code for execution and the like.

In order to provide a more secure interpretive environment in the new Internet era several different approaches have been developed. For instance in one approach certain commands within the shell have been disabled when used within a script. However by doing so the portability of the shell script is affected. In another approach special purpose code is added into different commands of the shell. This special purpose code then performs additional security checking. However this approach is very time consuming and may potentially overlook certain commands thereby leaving potential vulnerabilities exposed. In addition as new security issues arise e.g. authorization checks validating signatures the time consuming approach for adding new special purpose code and or modifying that code must be undertaken again.

Thus a more versatile solution is needed for minimizing security problems within interpretive environments.

The techniques and mechanisms described herein are directed to an extensible security architecture that provides a security mechanism for minimizing security problems within interpretive environments. The extensible security architecture comprises a script engine configured to process a script and a security manager configured to monitor the processing of the script based on a security policy. The security manager determines whether to open an assembly associated with a command within the script whether to process the command and whether to allow certain input to the command. The security policy may be implemented by overriding one or more methods of a base security class that are called when processing the script. The input may be an object passed via an object based pipeline.

Briefly the present extensible security architecture provides a security mechanism for minimizing security problems within interpretive environments. The extensible security architecture can be customized to accommodate new security features and to accommodate different operating environments. These and other advantages will become clear after reading the following detailed description.

The various embodiments of the present extensible security architecture may be implemented in different computer environments. The computer environment shown in is only one example of a computer environment and is not intended to suggest any limitation as to the scope of use or functionality of the computer and network architectures. Neither should the computer environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the example computer environment.

With reference to one exemplary system for implementing the security architecture includes a computing device such as computing device . In a very basic configuration computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device system memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. System memory typically includes an operating system one or more program modules and may include program data . This basic configuration is illustrated in by those components within dashed line . For the present security architecture the operating system includes a component based framework that supports components including properties and events objects inheritance polymorphism reflection and provides an object oriented component based application programming interface API such as the .NET Framework manufactured by Microsoft Corporation Redmond Wash. The operating system also includes an administrative tool framework that interacts with the component based framework .

Computing device may have additional features or functionality. For example computing device may also include additional data storage devices removable and or non removable such as for example magnetic disks optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media may include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Thus computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included. These devices are well known in the art and need not be discussed at length here.

Computing device may also contain communication connections that allow the device to communicate with other computing devices such as over a network. Communication connection s is one example of communication media. Communication media may typically be embodied by computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.

Various modules and techniques may be described herein in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures etc. for performing particular tasks or implement particular abstract data types. These program modules and the like may be executed as native code or may be downloaded and executed such as in a virtual machine or other just in time compilation execution environment. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

The salient components of the exemplary administrative tool framework include a shell a core engine and cmdlets . Each of these components may be one or more software modules implemented within the operating system illustrated in or as one or more program modules illustrated in or some combination of the two.

Cmdlets represent any available command to the administrative tool framework. The available commands may by management commands that query or manipulate configuration information associated with the computing device non management commands that group sort filter and perform other processing on input output information or the like. Cmdlets correspond to commands in traditional administrative environments. However cmdlets are quite different than these traditional commands. For example cmdlets are typically smaller in size than their counterpart commands because the cmdlets can utilize common functions provided by the administrative tool framework such as parsing data validation error reporting and the like. Because such common functions can be implemented once and tested once the use of cmdlets throughout the administrative tool framework allows the incremental development and test costs associated with application specific functions to be quite low compared to traditional environments. Cmdlets may run in the same processes within the administrative tool framework. This allows cmdlets to exchange live objects between each other. This ability to exchange live objects allows the cmdlets to directly invoke methods on these objects.

Shell is a host program that exposes automation features to users via a command line and or scripting language. The shell uses a set of interfaces made available by a host to embed the administrative tool environment. The shell manages interactions between a user and other components within the administrative tool framework.

The core engine includes a parser a script engine a pipeline processor a loader a session manager and the present security manager . The parser provides mechanisms for receiving input requests from various host programs e.g. shell and mapping the input requests to uniform cmdlet objects that are used throughout the administrative tool framework. In addition the parser may perform data processing based on the input received.

The script engine provides mechanisms and services to tie multiple cmdlets together using a script. A script is an aggregation of command lines that share session state under strict rules of inheritance. The multiple command lines within the script may be executed either synchronously or asynchronously based on the syntax provided in the input request. The script engine has the ability to process control structures such as loops and conditional clauses and to process variables within the script. The script engine also manages session state and gives cmdlets access to session data based on a policy not shown .

The session manager supplies session and state information to other components within the administrative tool framework . The state information managed by the session manager may be accessed by any cmdlet host or core engine via programming interfaces. These programming interfaces allow for the creation modification and deletion of state information.

The loader is configured to load each cmdlet in memory in order for the pipeline processor to execute the cmdlet. The pipeline processor includes a cmdlet processor and a cmdlet manager . The cmdlet processor dispatches individual cmdlets. If the cmdlet requires execution on a remote or a set of remote machines the cmdlet processor coordinates the execution with a remoting cmdlet. The cmdlet manager handles the execution of aggregations of cmdlets. The cmdlet manager the cmdlet processor and the script engine communicate with each other in order to perform the processing on the input received from the host program e.g. shell . The communication may be recursive in nature. For example if the shell provides a script the script may invoke the cmdlet manager to execute a cmdlet which itself may be a script. The script may then be executed by the script engine .

The present security manager authorizes which actions are allowed within the administrative tool environment based on a security policy. This authorization may be at a session level an assembly level a cmdlet level and or an object level for objects passed via the pipeline. Briefly illustrated in and described in conjunction therewith the security manager is implemented in a manner that allows different domains to each define a security policy for determining which actions can be performed. Thus the other components of the administrative tool environment e.g. shell script engine parser loader and pipeline processor do not need to change when additional security controls are desired.

The ShouldCreateSession API determines whether the core engine is allowed to run or not. Thus even though the core engine may be loaded the security manager may determine that it will not run. The following is an exemplary syntax for the ShouldCreateSession API 

The first parameter user specifies the user context that is requesting the creation of a runspace. ShouldCreateSession API returns a value of true or false depending on whether the runspace creation is allowed or disallowed respectively. The ShouldCreateSession API sets a second parameter reason if the runspace creation is not allowed. The term runspace refers to an abstraction that allows the execution of pipelines in a well controlled manner without requiring the hosting environment to understand the underlying execution of cmdlets. The runspace provides a set of interfaces so that the hosting environment does not need access to the inner workings of the command execution.

ShouldLoad API determines whether a particular assembly associated with the desired cmdlet should load or not. The following is an exemplary syntax for the ShouldLoad API 

The first parameter specifies a full path to the assembly and or the assembly strong name. ShouldLoad API returns a value of true or false depending on whether the specified assembly can be loaded or can not be loaded respectively. The hostUI parameter may be used if it is necessary to prompt a user for authorization decision.

ShouldRun API determines whether access to the desired cmdlet should be allowed and whether a script should be allowed to run. The following is an exemplary syntax for ShouldRun API 

ShouldProcessObject API determines whether to pass a specific object to a running cmdlet. The core engine calls ShouldProcessObject API before an object is placed in the input pipe of a cmdlet and when a cmdlet calls ShouldProcess. The following is an exemplary syntax for ShouldProcessObject API 

ShouldInvokeMethod API determines whether a method should be invoked on an object. The core engine calls ShouldInvokeMethod API before dispatching a method call on an object from a running script. The following is an exemplary syntax for ShouldInvokeMethod API 

Each of these APIs may be a virtual method that needs to be implemented by a derived class in order for the security manager to function properly. In one embodiment a default security class may be provided. The default security class may be derived from the base security class to provide a set of corresponding default APIs e.g. ShouldCreateSession default API ShouldLoad default API ShouldRun default API ShouldProcessObject default API and ShouldInvokeMethod default API . The default security class then enforces a standard security policy for any application. The default APIs may be implemented to allow everything. By doing so the core engine is able to run without enforcing any security policy if a customized security policy is not available.

However different applications may have different security policies. For example Application A may have CustomizedSecurityA policy. CustomizedSecurityA policy is a class that may inherit from the default security class shown in or may derive directly from the base security class . When deriving from default security class Customized Security A class may override one or more of the default APIs for any security policy that differs with the security policy for the default security class . As shown Customized security policy A has its own implementation of ShouldLoad API ShouldRun API and ShouldProcessObject API . If CustomizedSecurityA policy derives directly from the base security class each of the APIs may be overridden in accordance with the associated security policy as explained above for the default security class .

As one can see the present security architecture is extensible and can easily incorporate additional security policies without impacting the other components. This allows each application to define its own security policy and implement it through the use of the present security architecture.

In overview the above line gets each process beginning with the letter a and pipelines that process to the stop process cmdlet which stops the process.

Security processing begins at block where a command is obtained. For the above example block will obtain the command get process . Processing continues at block .

At block an assembly associated with the command is identified. As one may already know each assembly may have one or more commands identified within it. Continuing with the example the assembly is identified as ProcessCmds.dll . Processing continues at decision block .

At decision block a determination is made whether the assembly has been previously loaded for a different command within the assembly. If the assembly has not been previously loaded processing continues at block . Otherwise processing continues at block .

At block a check is performed on the assembly to determine whether the assembly can be loaded. The core engine calls ShouldLoad API to perform this check. The derived ShouldLoad API makes this determination based on the specified full path to the assembly and or the assembly strong name. If the current security policy is set to be signed for example the derived ShouldLoad API performs signature verification to determine whether to allow loading the assembly. Another policy may check whether the specified path is in the list of paths in the administrative tool s command path. Processing continues at decision block .

At decision block if the check in block failed processing ends. Otherwise the assembly is loaded and processing continues at block .

At block a check is performed on the obtained command. The core engine calls the ShouldRun API to perform this check. As mentioned above there may be several variations for implementing the ShouldRun API. For example some security managers may have a security policy that requires checking security on commands coming from a host. If the commands coming from a host call other commands the other commands may be directly allowed without doing any security checking. This and other variations for the ShouldRun API are envisioned. Processing continues at decision block .

At decision block a determination is made whether the check in block failed. If block failed processing ends. Otherwise the command is allowed to begin running and emitting object. Processing continues at decision block .

At decision block a determination is made whether the command is receiving objects emitted from other objects. Continuing with the above example because the get process command is the first command in the pipeline get process is not receiving any objects emitted from other objects. Therefore processing continues to decision block .

At block a determination is made whether there is another command. If there is another command processing loops back to block and proceeds as described above. Otherwise processing ends.

Continuing with our example there is another command. At block the command stop process is obtained. At block the same assembly ProcessCmds.Dll is identified. Therefore processing continues at block as described above. The command stop process is allowed to run. Processing continues at decision block .

This time because the stop process command is receiving objects emitted from other objects processing continues at decision block . At decision block a check is performed on the input. The ShouldProcessObject API is called for each object being passed to the stop process command. For this example the security policy has been implemented so that any object that has a named property equal to ace.exe cannot be operated upon by the stop process command. Thus in our example if the get process command emitted a.exe a1.exe a2.exe and ace.exe. All but ace.exe will be allowed to be processed. The processing with ace.exe will fail. Processing continues to decision block and proceeds as described above.

Thus one will note that the ShouldLoad API gets called once the ShouldRun API gets called once for each command that is obtained from the assembly and ShouldProcessObject API gets called for each object being passed to a command. It is important to note that each application can implemented its own security policy by overriding the desired security API. The actual implementation for the security policy may be as simplistic or as complex as needed. Thus the present security architecture provides extensibility and can easily adapt to changes and advances in security processing.

Reference has been made throughout this specification to one embodiment an embodiment or an example embodiment meaning that a particular described feature structure or characteristic is included in at least one embodiment of the present invention. Thus usage of such phrases may refer to more than just one embodiment. Furthermore the described features structures or characteristics may be combined in any suitable manner in one or more embodiments.

One skilled in the relevant art may recognize however that the invention may be practiced without one or more of the specific details or with other methods resources materials etc. In other instances well known structures resources or operations have not been shown or described in detail merely to avoid obscuring aspects of the invention.

While example embodiments and applications have been illustrated and described it is to be understood that the invention is not limited to the precise configuration and resources described above. Various modifications changes and variations apparent to those skilled in the art may be made in the arrangement operation and details of the methods and systems of the present invention disclosed herein without departing from the scope of the claimed invention.

