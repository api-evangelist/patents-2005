---

title: Device memory management during electronic file updating
abstract: In performing memory management, an upgrade client of a host device identifies and reserves memory blocks large enough to accommodate new software components by performing sequential searches of first and second memory areas. The new software components are updated versions of components of original software files. When the new component size exceeds that of available blocks of the first and second memory areas, the upgrade client rewrites the first memory area to eliminate unused memory blocks, reapportions the first and second memory areas, writes the new component to the second memory area, and updates a vector table. To access host device software components, the upgrade client receives a function call from the main program of the host device including identification information of corresponding software files, reads a start address of the corresponding software files from the vector table, and generates a call for the corresponding software files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07779055&OS=07779055&RS=07779055
owner: Innopath Software, Inc.
number: 07779055
owner_city: Sunnyvale
owner_country: US
publication_date: 20050722
---
This application is a continuation of application Ser. No. 10 298 458 filed Nov. 18 2002 now U.S. Pat. No. 7 007 049. This application is related to the application titled BYTE LEVEL FILE DIFFERENCING AND UPDATING ALGORITHMS application Ser. No. 10 146 545 filed May 13 2002 the application titled UPDATING ELECTRONIC FILES USING BYTE LEVEL FILE DIFFERENCING AND UPDATING ALGORITHMS application Ser. No. 10 261 153 filed Sep. 30 2002 the application titled UPGRADING OF ELECTRONIC FILES INCLUDING AUTOMATIC RECOVERY FROM FAILURES AND ERRORS OCCURRING DURING THE UPGRADE application Ser. No. 10 292 245 now U.S. Pat. No. 6 836 657 filed Nov. 12 2002 the application titled GENERATING DIFFERENCE FILES USING MODULE INFORMATION OF EMBEDDED SOFTWARE COMPONENTS application Ser. No. 10 298 393 filed Nov. 18 2002 the application titled CONTROLLING UPDATES OF ELECTRONIC FILES application Ser. No. 10 298 863 filed Nov. 18 2002 the application titled SCHEDULING UPDATES OF ELECTRONIC FILES application Ser. No. 10 298 862 filed Nov. 18 2002 and the application titled MANAGING ELECTRONIC FILE UPDATES ON CLIENT DEVICES application Ser. No. 10 298 896 filed Nov. 18 2002.

Software that runs on a Central Processing Unit CPU in order to fulfill certain functionality of the host device often changes over time. The changes may result from the need to correct software bugs adapt to evolving technologies or add new features to the host device. In particular embedded software in mobile wireless devices like cellular telephones often includes more bugs than other portable devices or processing systems and generally requires more frequent updates to add new features to the device.

Software includes one or more files which can be in the form of American Standard Code for Information Interchange ASCII plain text files or binary code. Software files can be divided into smaller units that are often referred to as components or modules. In the current art a UNIX platform or Personal Computer PC includes multiple software components and each of the software components is managed and updated independently through a file system supported by a corresponding Operating System OS . Information used to update software files or software components hosted on UNIX platforms or PCs can be transferred through the Internet or loaded from a secondary storage medium such as a floppy disk a compact disk read only memory CD ROM or a compact flash card.

In contrast in most mobile wireless devices a real time OS RTOS is typically used in which all software components are linked as a single large file. Further no file system support is typically provided in these mobile wireless devices. In addition the single large file needs to be preloaded or embedded into the device using a slow communication link like a radio infrared or serial link.

Obstacles to the update of large files via slow communication links include the time of delivering the updated file to the device. In cases where a difference file is transferred to the device hosting the files targeted for update revision this time includes both the communication time to transfer the difference file and the time used by the receiving device to process the difference file and update revise the targeted files referred to herein as the host device processing time. While use of a delta file to transfer updated software file or software component information significantly reduces the communication time as described in the Related Applications reduction of the host device processing time is dictated at least in part by the host device architecture.

The host device can be any of a number of processor based devices including cellular telephones and other mobile communication devices personal digital assistants PDAs and personal computers. Using cellular telephones as an example the typical cellular telephone architecture includes flash read only memory ROM referred to herein as flash ROM or flash memory and an RTOS. Both the flash memory and the RTOS potentially introduce obstacles to the goal of reducing the host device processing time.

The problem that arises with respect to the flash memory in reducing the host device processing time involves the manner with which writes are performed to flash memory. Flash memory is allocated in units which are often referred to as blocks sectors or segments each of which includes numerous bytes. A write or rewrite to the typical flash memory requires erasing and writing or rewriting an entire unit meaning that single bits or bytes can not be written or rewritten . Therefore the update or revision of a byte stored in flash memory requires erasing and rewriting the entire unit in which the byte is stored. Thus the time required to update or revise files stored in flash memory is typically greater than that required to update or revise files stored in other types of storage or memory in which single bytes can be written or rewritten .

The problem that arises with respect to the RTOS in reducing the host device processing time involves the manner in which host device software programs are organized and managed. The RTOS of typical cellular telephones does not support file management and dynamic address resolution for function calls at runtime. Therefore all embedded software components or programs of the cellular telephone are linked into a single large host program and a function within the host program is called from any part of the host program directly through a precompiled start address of the function. Thus in contrast to a typical computer OS in which file management and dynamic address resolution for function calls are supported the typical cellular telephone RTOS does not have the capability to manage multiple software components as separate files and support the function calls from one of the software components to another via runtime calling address resolution. Consequently the host program of a system including an RTOS manages a single large program and uses static addressing to directly access functions of the program.

This typical device architecture can lead to a problem when updating and revising software components because when the revision or update results in changes in host program size there is a resultant change in the start addresses of the software components that follow the updated revised software component in the host program. This change in the start address of a software component results in a need to update the corresponding calling addresses in the host program and the instruction data addresses within the software component. This can be expensive in terms of processing time. Thus host device processing time associated with embedded software updates revisions is due in large part to the inefficient rewriting of data to flash memory and the fact that a small change to embedded software at the source code level can result in a large change to the embedded software at the binary code level.

In the drawings the same reference numbers identify identical or substantially similar elements or acts. To easily identify the discussion of any particular element or act the most significant digit or digits in a reference number refer to the Figure number in which that element is first introduced e.g. element is first introduced and discussed with respect to .

Unless described otherwise below the construction and operation of the various blocks and structures shown in the Figures are of conventional design. As a result such blocks need not be described in further detail herein because they will be understood by those skilled in the relevant art. Such further detail is omitted for brevity and so as not to obscure the detailed description of the invention. Any modifications necessary to the Figures can be readily made by one skilled in the relevant art based on the detailed description provided herein.

A memory management system and method are described in detail herein. In performing memory management an upgrade client of a host device identifies and reserves memory blocks large enough to accommodate new software components by performing sequential searches of first and second memory areas. The new software components are updated or upgraded versions of components of original software files. When the new component size is equal to or smaller than the size of a corresponding component of the original electronic file the update client allocates an original memory block of a first memory area into which to write the received component. The original memory block includes the corresponding component of the original electronic file.

When the new component size exceeds the size of the corresponding component of the original electronic file the upgrade client searches unused portions of the first memory area for a memory block large enough to store the received component. The upgrade client reserves a memory block of the appropriate size if one is located in the first memory area otherwise the upgrade client searches the second memory area. The upgrade client reserves a memory block of the appropriate size if one is located in the second memory area.

When however the new component size exceeds that of available blocks of the first and second memory areas the upgrade client rewrites the first memory area to eliminate unused memory blocks. Following rewriting of the first memory area the upgrade client reapportions the first and second memory areas by sequentially rewriting software components of the second memory area to the unused portion of the first memory area where component size and available blocks of the first memory area permit. Subsequently the upgrade client re designates the remaining unused portion of the first memory area as part of the second memory area. Following the reapportionment the upgrade client writes the new component to the second memory area and updates a vector table.

With regard to accessing host device software components the upgrade client receives a function call from the main program of the host device where the function call includes identification information of corresponding software files. The upgrade client uses the identification information to access the vector table and read a start address of the corresponding software files from the vector table. Using the start address from the vector table along with the identification information the upgrade client generates a call to the corresponding software files.

With reference to a first computer system and a second computer system communicate via a communication path . These computer systems and include any collection of computing devices operating together as is known in the art. The computer systems and also include components within a larger computer system. The communication path includes any medium by which files are communicated or transferred between the computer systems and . Therefore this path includes wireless connections wired connections and hybrid wireless wired connections. The communication path also includes couplings or connections to networks including local area networks LANs metropolitan area networks MANs wide area networks WANs proprietary networks interoffice or backend networks and the Internet. Furthermore the communication path includes removable fixed mediums like floppy disks hard disk drives and CD ROM disks as well as flash RAM Universal Serial Bus USB connections RS 232 connections telephone lines buses and electronic mail messages.

The first communication system receives an original or old version and a new version of an electronic file. The new file is generally an updated or revised version of the original file but is not so limited. The electronic files and include software files including dynamic link library files shared object files embedded software components EBSCs firmware files executable files data files including hex data files system configuration files and files including personal use data but are not so limited. Since any type of file can be regarded as a byte stream hereafter a file can be described as a byte stream.

The file differencing algorithm receives the new file compares it to the original file and calculates the byte level differences between the compared files as described below. The file differencing algorithm may also pre process the original and the new files to reduce the sizes of the files prior to the calculation of the file differences. The file differencing algorithm generates a difference file referred to herein as a delta file during the comparison.

Contents of the delta file provide an efficient representation of the byte level differences between the new and the original files. The delta file includes meta data along with actual data of replacement and or insertion operations that represent the differences between the new or current version of the associated file and previous versions of the file as described below. The file differencing algorithm provides any differences between the original and the new files in the delta file using a minimum number of bytes and a pre defined format or protocol thereby providing a delta file optimized in space.

The delta file is transferred or transmitted to another computer system via the communication path . Prior to transfer the delta file may be compressed using compression techniques known in the art but is not so limited. The file updating algorithm hosted on the receiving computer system uses the delta file along with the hosted original file to generate or create a copy of the new file . This copy of the new file is then used to update the original file hosted on the client device that is targeted for revision or updating. Upon completion of this update process the original file now stored on the second computer system is identical to the new file received in the first computer system.

The differences between an original file and a new file are typically smaller than the new file leading to significant storage and transmission savings if the differences are transmitted and stored instead of the entire new byte stream. This is particularly important for mobile electronic devices hosting programs that are updated via connections that typically can be slow and expensive for example wireless or cellular connections.

The upgrade system prevents device recalls by supporting the provision of new and revised software files to mobile client devices via various mechanisms of the service provider s wireless infrastructure. These systems function by receiving new and revised software from a software distributor and generating a delta file from the new software using the file differencing algorithm. The delta file is transferred to the client device via the infrastructure of a service provider. The upgrade client including the file updating algorithm of the receiving or client device uses the delta file to update the targeted software hosted on the client device.

The upgrade system enables different life cycles between device software and hardware. This upgrade system therefore supports up to date device functionality in view of the fact that critical software components such as Java Connected Limited Device Configuration CLDC libraries Moving Pictures Experts Group 1 MPEG 1 Layer III MP3 drivers communication software and browser applications evolve faster than the host device hardware and are consequently updated with greater frequency than mobile device manufacturers deliver a new generation of devices. The upgrade system is described in further detail below.

With reference to the upgrade system maintains embedded software components on client devices via a wireless connection with the device thereby enabling wireless carriers to continuously provide the latest data services to all users. The upgrade system includes but is not limited to a new software component distributor or software component distributor service provider upgrade components and an upgrade client hosted on the client device . The service provider upgrade components include an upgrade server coupled among a software component certification server and an upgrade manager .

The software component distributor of an embodiment provides a web based user interface by which software providers package and release new embedded device software components such as an improved MP3 driver an upgraded Java 2 Platform Micro Edition J2ME Mobile Information Device Profile MIDP library or a feature added address book application. Functions of the software component distributor include registering device information and submitting device information to the software component certification server. Also the software component distributor receives new and original EBSCs and calculates byte level file differences therefrom using the file differencing algorithm registers and packages embedded software and submits embedded software packages to the software component certification server. The new software following release is provided to the service provider upgrade components via a wired wireless or hybrid wired wireless network coupling or connection but is not so limited.

The software component distributor of an embodiment is hosted on processing systems of the client device manufacturers. In an alternative embodiment the software component distributor is hosted on processing systems of a software provider. In another alternative embodiment the software component distributor is hosted on processing systems of the communication service provider for example the upgrade components .

The service provider upgrade components are coupled among the software component distributor the client devices and the existing components of the service provider s infrastructure including the existing gateway and communication infrastructure billing server logging server and authentication server . The software component certification server provides an interface to device manufacturers and thus receives new device information on embedded software packages from device manufacturers. The software component certification server also receives software component submission requests from the software component distributor provides notification of approval decline of new software packages to submitting upgrade servers provides disk management for submitted and approved software packages and repackages and distributes approved software packages to upgrade servers. Furthermore the software component certification server provides carrier grade security control over potential intrusion and data tampering during the software component submission process.

The upgrade manager functioning as an interface among the software component certification server and the upgrade server provides a web based user interface by which wireless carrier system administrators verify and approve an embedded device software component upgrade. Also the upgrade manager configures software and data packaging for optimal device management schedules remote change notifications and controls the update policy monitor system. Moreover the upgrade manager provides integration with the systems of the existing infrastructure or back end systems billing user database authentication web portal thereby providing the workflow to determine authentication access controls and their integration into the existing billing and logging servers.

The upgrade server provides capabilities including authenticating connecting and communicating with mobile devices to perform embedded software component upgrades. Communication with client devices can occur via wireless connections wired connections hybrid wired wireless connections and other network connections with the client device as appropriate to the corresponding service provider. In addition the upgrade server supports existing billing data collection and logging services of the service provider.

As an example of communications among the upgrade server and client devices when a delta file is available for transfer to a client device from the upgrade server the server sends a user notification to notify the client device user that there are software components available for updating. The user notification can take the form of a text message via a Short Message Service SMS push protocol Hypertext Transfer Protocol HTTP or Wireless Application Protocol WAP but is not so limited. Upon receiving confirmation from the handset users the upgrade server uses the original handset data communication protocol to send the delta file to the requesting handset.

In response to receipt of the confirmation from the handset the upgrade server authenticates and authorizes the user and or requesting device and verifies prerequisite capabilities and limitations of the requesting device. Following authentication the upgrade server as the manager of client device configuration data identifies the current versions of embedded software components of the requesting device identifies and transfers appropriate delta files to the requesting device logs the status of the upgrade transaction and reports the results to the upgrade manager . An embodiment of the upgrade server includes automatic failure recovery mechanisms. In addition the upgrade server activates deactivates the software upgrade service over the air and notifies remote users of software changes.

With reference to the upgrade client is embedded in the device memory of the client devices but is not so limited. The upgrade client stores and maintains configuration data of the host device and provides for the maintenance and upgrading of embedded device software components using the file updating algorithm . The upgrade client supports a simple user interface and is incorporated into mobile device software. Upon execution the upgrade client automatically detects the remote change of any embedded software components notifies users of an embedded software component upgrade and upgrades a software component based on the carriers and or users control as appropriate for a particular service provider. The upgrade client also includes an automatic failure recovery mechanism.

The client device determines the status of numerous device parameters prior to participating in an update procedure. This is done in order to pre qualify the device for the update procedure or verify that the condition of the client device is such that the update procedure can be completed once begun. The client device pre qualification includes determining if the client device is in a cradle or charging mode if the client device is connected to a serial cable if the state of battery charge is sufficient to perform the updating process if the Received Signal Strength Indication RSSI or signal strength is sufficient for the data transfer and if the targeted EBSC is currently in use.

The upgrade system of an embodiment supports numerous types of software file or component updates via delta file. The file types for which updates are supported include executable files byte stream files and data files but are not so limited. The executable files or image files include software files used in the client device to execute tasks for example the operating system OS hardware device drivers and K Virtual Machine KVM files. The byte stream files include files used by other executable files for example icon files logo files and MP3 files. Data files include files containing personal use data and handset reference data for example the calibration configuration files the Protocol Independent Multicast PIM files and system configuration files.

Upon receipt of a delta file or alternatively a new EBSC the upgrade client controls the revising and updating of files including embedded software embedded software components EBSCs and EBSC groups. The upgrade client uses numerous methods to update EBSCs depending on the file type to be updated and the resources allocated by the client device manufacturer to support these updates. These update methods include but are not limited to the following as described in detail in the Related Applications updating the operating system OS communication protocol and other critical software components using reserved ROM updating the OS communication protocol and other critical components using reserved RAM updating the communication protocol in the absence of reserved ROM or RAM and single line updates of non critical EBSCs.

The update methods of an embodiment include non critical component updates and critical component updates. These categories are based on the usage of the software components of the client device targeted for update and are described further below.

Non critical components include embedded software components EBSCs that are easily recovered over the air following a failure during the update process. Examples of non critical components include browsers and KVM files but are not so limited. is a flow diagram of a non critical component update under an embodiment. When updating with a delta file the client device receives the delta file from an upgrade server via a network connection at block . The delta file upon receipt in the client device is written into a designated area of device memory at block for example RAM and or ROM storage. The upgrade client of the client device then generates a copy of the new file or EBSC from the original file or EBSC using the delta file at block . The copy of the new file is written into reserved RAM or ROM as appropriate at block . At block the copy of the new file is subsequently written from reserved memory into the memory locations that contain the original file or EBSC.

Critical components include software components used in the update procedure or the EBSCs critical to device operation. Further critical components include EBSCs that are not easily recovered over the air following a failure during the update process. Examples of critical components include the operating system files protocol stacks the upgrade client files communication libraries and display or LCD driver files but are not so limited. The update procedure differs slightly between these two categories.

Upon receipt of the delta file generally the original files or EBSCs targeted for updating are copied from the flash ROM of the client device into a memory area designated for use during the update process at block for example RAM and or ROM storage as appropriate. The client device allocates this designated memory area for use in storing the updating software components. The delta file is also written into the memory area designated for use during the update process at block .

The upgrade client of the client device then uses the hosted copy of the original file along with the delta file to generate a copy of the new file at block . The copy of the new file is written into a pre specified memory area of the client device for example reserved memory of the client device at block . This process is repeated as necessary.

Following generation the copy of the new file is written from reserved memory into the original memory locations containing the original file at block . When the size of the new file is the same as or smaller than that of the original file the new file is written into the memory locations of the original file thereby replacing the original file.

As described above revision of files involves the writing of new and updated EBSCs to memory locations of the host device. Often the new EBSC will not be exactly the same size or have exactly the same start address as the original EBSC it replaces. The upgrade client of an embodiment provides device memory management options including static addressing and dynamic addressing of upgradeable EBSCs to accommodate writing of the new EBSC regardless of the EBSC size or start address.

The static addressing of upgradeable EBSCs generally provides for changing the size of the EBSC or EBSC group during updates using reserved memory areas while the start address remains unchanged. Therefore when using static addressing the entire embedded software EEBS file is rewritten if the start address of an EBSC or EBSC group requires changing but the embodiment is not so limited.

The dynamic addressing of upgradeable EBSCs while allowing for more advanced memory management generally supports modification of both the start addresses and sizes of EBSCs and EBSC groups during each update. The upgrade client of an embodiment supports dynamic addressing using interactions among a set of application program or programming interfaces APIs and at least one data table. As such dynamic addressing increases the efficiency of ROM utilization and device memory map design while supporting faster update processing with a lower probability of update failures. Static and dynamic addressing are described in further detail below.

The static addressing of an embodiment includes two alternatives one of which includes a reserve memory allocation for each upgradeable EBSC and one of which includes a reserve memory allocation for particular groups of EBSCs. The reserve memory allocations modify the memory allocation for each EBSC or EBSC group to accommodate software updates. Therefore there will be additional ROM reserved to accommodate future growth of the software but the additional memory is not limited to ROM.

Continuing with this example the upgradeable EBSCs are identified as EBSC EBSC and EBSC and reserved memory areas and are provided for each of these upgradeable EBSCs respectively. Each reserved memory area and is of a size determined by the device manufacturer. Future upgrades and revisions to the upgradeable EBSCs use the corresponding reserved memory area when the upgrade revision causes the size of the upgraded EBSC to exceed the size of the original EBSC as described above.

The device manufacturer groups the upgradeable EBSCs using at least one of a number of factors. For example EBSCs with similar update frequencies may form a group. Also EBSCs with similar probabilities of being updated revised can form a group. Furthermore EBSCs of related or interworking functions may form a group. The following groupings are made for purposes of this example EBSCs and form EBSC group EBSCs and form group EBSCs and form group and EBSCs and form group .

Following grouping the device manufacturer provides a reserve memory area corresponding to each updateable EBSC group. While the reserve memory areas are shown as co located with the corresponding EBSC groups they may be located anywhere in device memory. While non upgradeable EBSCs are also placed in one or more groups no reserved area is provided in the interest of minimizing the amount of reserved memory but the embodiment is not so limited.

In this example the upgradeable EBSC groups are identified as EBSC Group and EBSC Group and reserved memory areas G and G are provided for each of these upgradeable EBSC groups respectively. Each reserved memory area G and G is of a size determined by the device manufacturer. Future upgrades and revisions to the upgradeable EBSC groups use the corresponding reserved memory area when the upgrade revision causes the size of the upgraded EBSC group to exceed the size of the original EBSC group.

The rewriting of the EBSCs or EBSC groups described above can result in changes in the starting addresses of the subroutines within the file that includes the rewritten EBSC or EBSC group. Any changes in subroutine starting addresses result in changes to the corresponding call addresses by which other subroutines of the host device access the rewritten subroutines. Therefore in an embodiment the upgrade client supports upgrading of the call addresses corresponding to any rewritten EBSCs or EBSC groups. This call address upgrade includes rewriting any blocks in the host device memory that include call addresses corresponding to subroutines in rewritten EBSCs or EBSC groups. As these call address changes typically involve only a few bytes upgrading only the blocks including the call addresses is found to be more efficient than updating the EBSCs containing the call addresses but the embodiment is not so limited.

The boot code area stores the device booting sequence code. The embedded software area stores embedded software of the client device. The embedded software includes for example software of the browser K Virtual Machine KVM communication library real time OS graphics driver and upgrade client but the embodiment is not so limited. The memory allocation for each upgradeable EBSC or EBSC group is modified to accommodate software updates as described above. Therefore there will be additional ROM reserved to accommodate future growth of the software. The additional reserved ROM is approximately 5 20 of the size of the initial version of the corresponding EBSC or EBSC group but is not so limited.

The EBSC working memory area stores new versions of an EBSC or EBSC group temporarily after they are generated by the upgrade client and before the new versions are written to the memory locations of the embedded software area currently occupied by the original versions of the EBSC or EBSC group. The estimated size of the working area is at least the size of the largest of all EBSCs or EBSC groups that use this memory area including critical and non critical components.

The upgrade client device parameter area stores client device configuration data and parameters specific to the upgrade client. The estimated size of this area corresponds to the number of upgradeable EBSCs related to device configuration hosted on the client device but is not so limited.

Components of the software component distributor receive source code of the new EBSCs and compile the new EBSC source code. The compiling couples the resulting EBSC object code to the linkers and which as part of the registration of the new EBSC generate a new hex file text or binary file from the new EBSC object code. The new hex file corresponds to the new EBSC.

In supporting static addressing the software component distributor or service provider modifies the original map file to insert additional memory for each upgradeable EBSC. In an embodiment linker generates the modified map file . When EBSC grouping is used the original map file is modified to group EBSCs and insert additional memory for each upgradeable EBSC group. This modification of the map file includes editing the link files using linker to insert the empty file or group together with the corresponding object files.

A vector generating tool generates a vector table file from the modified map file . The vector table file is downloaded into the reserved ROM area for upgrade client device parameters in the client device . With reference to the upgrade client maintains the vector table which generally remains unchanged unless the entire embedded software EEBS is rewritten. The linker also uses the modified map file to generate the new hex or binary file . Further the linker specifies or generates a list of hex file map file path pair associations. The hex file is downloaded into the embedded software area of the client device but may be downloaded into other areas of the client device memory in alternative embodiments.

While the static addressing described above reduces the host device processing times and enables updating of critical software components it does not accommodate all upgrades and revisions. In addition the use of static addressing necessitates rewriting of the entire device memory when a rewrite of any EBSC will exceed the size of the corresponding reserved memory area. Consequently embodiments use dynamic addressing as an alternative to static addressing.

Dynamic addressing allows for electronic file updates and revisions in which the size of the new file version exceeds that of the original file version. In supporting dynamic addressing the upgrade client of an embodiment effectively manages the device memory during both the file update process and the function call process in which the main program calls functions including updated EBSCs.

In performing memory management using dynamic addressing the upgrade client identifies and reserves memory blocks large enough to accommodate new software components by performing sequential searches of host device memory areas including at least one first and second memory area. When the new component size exceeds that of available blocks of the searched memory areas the upgrade client rewrites a first memory area to eliminate unused memory blocks reapportions the first and second memory areas writes the new component to the second memory area and updates a vector table as described below.

To access software components in a host device using dynamic addressing the upgrade client receives a function call from the main program of the host device including identification information of corresponding software files reads a start address of the corresponding software files from the vector table and generates a call for the corresponding software files. As such when a first EBSC calls a second EBSC the upgrade client changes the function calling sequence so that instead of calling the second EBSC directly using a static address the first EBSC calls an API of the upgrade client using a static address. The called API converts the received call to a call to the second EBSC using the corresponding static address and arguments of the runtime vector table.

The boot code area stores the device booting sequence code. The embedded software area stores embedded software of the client device. The embedded software includes for example software of the browser KVM communication library real time OS graphics driver and the upgrade client but is not so limited.

The EBSC update area stores new versions of embedded software components. The estimated size of this area will vary among devices. Generally however the EBSC update area will be approximately 10 20 of the size of the embedded software area .

The upgrade client device parameter area stores client device configuration data and parameters specific to the upgrade client. The estimated size of the upgrade client device parameter area corresponds to the number of upgradeable EBSCs related to device configuration hosted on the client device but is not so limited.

The device memory management area stores memory parameters a vector table and a garbage entry table but is not so limited. The estimated size of this area corresponds to the number of upgradeable EBSCs related to device memory management hosted on the client device.

The memory parameters of the device memory management area include the ROM number start address and size of the reserved ROM area for device memory management and the start address and size of the next available memory in the reserved ROM area for device memory management . The memory parameters also include the size of the vector table and the garbage entry table and the number of valid entries in the garbage entry table. The vector table includes the EBSC identification ROM number start address and size of the upgradeable EBSCs. The garbage entry table includes the ROM number start address and size of all garbage entries.

The function address conversion API generates calls from the host device main program for EBSCs associated with particular host device functions as described above with reference to . The main program of the host device calls an EBSC associated with a particular function by directly calling the function address conversion API . The direct call of the API is made instead of a direct call of the EBSC. At the time of the call the function address conversion API receives information from the main program that includes function identification information and the arguments to the function.

In response to the call the function address conversion API accesses the vector table . The vector table includes an entry for each function available to the main program along with the corresponding start address of the function in the device memory . The function address conversion API reads the start address of the function requested by the main program from the vector table and using the start address information along with the information of the called EBSC received from the main program generates a call for the actual function along with all the received arguments.

The upgrade client of an embodiment uses the API for reservation of a new version of an EBSC referred to herein as the reservation API to locate and reserve areas in memory to accommodate new versions of EBSCs or EBSC groups. With reference to the reservation API when called by the upgrade client receives identification information for the new EBSC version information that includes the file size of this new version. The file size of the new EBSC version is the size of the area that is to be reserved in the device ROM to store the new EBSC version. The reservation API locates an appropriate area in memory and returns the start address of the requested reservation area upon successfully reserving the memory area. is a flow diagram for reserving memory areas to accommodate new versions of an EBSC using the reservation API under an embodiment.

In allocating a memory block of the requested size the reservation API applies a set of rules as follows but alternative embodiments may apply different rules to effect equivalent results. is a flow diagram for locating memory blocks to accommodate new versions of an EBSC using the rules of the reservation API under an embodiment. Upon receiving information as to the size of the new EBSC at block the reservation API determines whether the size of the new EBSC exceeds that of the original EBSC at block . When the size of the new EBSC is equal to or less than the size of the corresponding original EBSC the reservation API allocates the memory block currently occupied by the corresponding original EBSC to receive the new EBSC at block . Otherwise the reservation API tries to locate a memory block having the requested size from the available memory in the reserved memory area.

In continuing the search the reservation API searches the reserved memory area of the client device for a memory block having the requested size at block . If an appropriately sized block is found in the reserved memory area the reservation API allocates the memory block to receive the new EBSC at block . If an appropriately sized memory block is not available in the reserved memory area the reservation API accesses the garbage table at block . The reservation API uses information of the garbage table to search the unused memory areas of the main program at block in an attempt to locate a memory block of the requested size among the unused areas corresponding to the entries in the garbage table . The unused areas of an embodiment referred to herein as garbage areas include unused areas of the main program but the embodiment is not so limited. If an appropriately sized memory block is found in the unused memory areas the reservation API allocates the block to receive the new EBSC at block .

The reservation API of an embodiment initiates a process referred to herein as garbage collection at block if it cannot locate an appropriately sized memory block. Also the reservation API initiates garbage collection when all entries of the garbage table are occupied. In an embodiment the API for garbage collection referred to herein as the garbage collection API is called by the reservation API but is not so limited. The API for garbage collection generally receives no argument and cleans up all garbage in the reserved areas for EBSCs and for EBSC update but is not so limited.

As described above the reservation API initiates garbage collection if it cannot find enough memory for the requested reservation size or if the garbage entry table becomes full. is a flow diagram of garbage collection under an embodiment. In initiating garbage collection the reservation API calls the garbage collection API . When called the garbage collection API reads the garbage table entries at block and causes the embedded software area of the device memory to be rewritten so as to sequentially pack the EBSCs of the memory up in memory at block . Alternative embodiments may pack the EBSCs down in the main memory but the embodiment is not so limited. This packing operation removes the unused areas in the embedded software area.

Following this packing operation the garbage collection API evaluates the size of each EBSC stored in the reserved memory area at block and compares the size against any unused memory blocks remaining in the main program of the embedded software area following its rewriting. This evaluation determines if the amount of unused memory remaining following the rewriting of the embedded software area can accommodate any EBSCs of the reserved memory area so that where possible EBSCs can be moved out of the reserved memory area and into the embedded software area of the device memory. The EBSCs of the reserved memory area are evaluated sequentially but the embodiment is not so limited. The EBSCs are rewritten from the reserved memory area to the embedded software area where EBSC size permits at block . As the EBSCs are rewritten in one embodiment they are stored sequentially in the embedded software area following the packed EBSCs.

The evaluation of the EBSCs stored in the reserved memory area continues until all EBSCs have been moved to the embedded software area or until a determination is made that there is no remaining area in the embedded software area large enough to accommodate the EBSCs of the reserved memory area. Any EBSCs that can not be accommodated in the embedded software area remain in the reserved memory area but the embodiment is not so limited.

Upon completion of the packing and moving operations the garbage collection API reapportions the host device memory by redesignating any unused memory blocks of the host device main memory as reserved memory area at block . Further the reserved memory area pointer is reset to maintain the start address of available memory in the reserved memory area at block . Additionally at block the garbage table is rewritten to reflect the status of the unused memory area. The upgrade client also updates the vector table following the writing of a new version of an EBSC to any memory area other than the memory area occupied by the original version of the same EBSC.

An example of upgrading and garbage collection operations follows with reference to and . is a block diagram of an example host device memory before and after upgrading operations of the reservation API under an embodiment. is a block diagram of the host device memory following upgrading and garbage collection operations under an embodiment.

This example begins with receipt of information on a new version of EBSC by the reservation API. Upon receipt of the file size of the new version of EBSC a determination is made as to whether the size of this new version is equal to or less than the size of the original EBSC. In this example the original version of EBSC contains 400 bytes while the new version of EBSC contains 380 bytes. Therefore the reservation API allocates the area currently occupied by the original version of EBSC to receive the new version of EBSC .

The example continues with receipt of information for a new version of EBSC by the reservation API. Upon receipt of the file size of the new version of EBSC a determination is made as to whether the size of this new version is equal to or less than the size of the original EBSC. In this example the original version of EBSC contains 300 bytes while the new version of EBSC contains 360 bytes. As the size of the new version is larger than that of the original version the reservation API attempts to locate a memory block having the requested size from the available memory in the reserved memory area . In this example memory is available in the reserved memory area so the reservation API allocates an area in the reserved memory to receive the new version of EBSC . Furthermore the reservation API allocates the area currently occupied by the original version of EBSC as unused area .

Next the reservation API receives information on a new version of EBSC . The original version of EBSC contains 550 bytes while the new version of EBSC contains 560 bytes. As the size of the new version is larger than that of the original version the reservation API attempts to locate a memory block having the requested size from the available memory in the reserved memory area . In this example memory is available in the reserved memory area so the reservation API allocates the next available area in the reserved memory to receive the new version of EBSC . Furthermore the reservation API allocates the area currently occupied by the original version of EBSC as unused area .

As the example continues the reservation API receives information on a new version of EBSC . While the original version of EBSC includes 330 bytes the new version of EBSC contains 360 bytes. The reservation API determines that an appropriately sized area is not available in the reserved memory area and accesses the garbage table . The garbage table is used in an attempt to locate a memory block of the requested size among the garbage areas identified using the entries in the garbage table . In this example an unused area of an appropriate size is identified and the reservation API allocates the unused area to receive the new version of EBSC .

As described above the reservation API initiates garbage collection if it cannot find enough memory for the requested reservation size or if the garbage entry table becomes full. For this example it is assumed that the next new EBSC version received following allocation in the reserved memory area for the new version of EBSC results in initiation of garbage collection. The garbage collection of an embodiment packs the EBSCs up in the host device memory resulting in a new host device memory configuration in which the EBSC order is EBSC EBSC EBSC EBSC EBSC EBSC EBSC and EBSC . The garbage collection routine of an alternative embodiment packs the EBSCs down in the host device memory.

Components of the software component distributor receive source code of the new EBSCs and compile the new EBSC source code. The compiling couples the resulting EBSC object code to the linkers and which as part of the registration of the new EBSC generate a new hex file text or binary file from the new EBSC object code. The new hex file corresponds to the new EBSC.

In supporting dynamic addressing the software component distributor uses the compiler and linker to generate a map file . This map file is used by a vector generating tool to generate a corresponding initial vector table of EBSCs. The vector table is subsequently provided to the linker and the linker generates the hex text or binary file using the initial vector table . The hex text or binary file is downloaded into the embedded software area of the client device but alternative embodiments may write the hex file to other memory areas of the client device . Components of the DMM library of the upgrade client maintain the vector table and as such support dynamic addressing of EBSCs. The DMM library overlaps with the vector table stored in the area reserved for upgrade client device parameters .

Aspects of the invention may be implemented as functionality programmed into any of a variety of circuitry including programmable logic devices PLDs such as field programmable gate arrays FPGAs programmable array logic PAL devices electrically programmable logic and memory devices and standard cell based devices as well as application specific integrated circuits ASICs . Some other possibilities for implementing aspects of the invention include microcontrollers with memory such as electronically erasable programmable read only memory EEPROM embedded microprocessors firmware software etc. Furthermore aspects of the invention may be embodied in microprocessors having software based circuit emulation discrete logic sequential and combinatorial custom devices fuzzy neural logic quantum devices and hybrids of any of the above device types. Of course the underlying device technologies may be provided in a variety of component types e.g. metal oxide semiconductor field effect transistor MOSFET technologies like complementary metal oxide semiconductor CMOS bipolar technologies like emitter coupled logic ECL polymer technologies e.g. silicon conjugated polymer and metal conjugated polymer metal structures mixed analog and digital etc.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense as opposed to an exclusive or exhaustive sense that is to say in a sense of including but not limited to. Words using the singular or plural number also include the plural or singular number respectively. Additionally the words herein hereunder and words of similar import when used in this application shall refer to this application as a whole and not to any particular portions of this application.

The above description of illustrated embodiments of the invention is not intended to be exhaustive or to limit the invention to the precise form disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. The teachings of the invention provided herein can be applied to other processing and communication systems not only for the cellular telephone system described above.

The elements and acts of the various embodiments described above can be combined to provide further embodiments. These and other changes can be made to the invention in light of the above detailed description.

All of the above references and United States patents and patent applications are incorporated herein by reference. Aspects of the invention can be modified if necessary to employ the systems functions and concepts of the various patents and applications described above to provide yet further embodiments of the invention.

In general in the following claims the terms used should not be construed to limit the invention to the specific embodiments disclosed in the specification and the claims but should be construed to include all processing systems that operate under the claims to provide a method for file differencing. Accordingly the invention is not limited by the disclosure but instead the scope of the invention is to be determined entirely by the claims.

While certain aspects of the invention are presented below in certain claim forms the inventors contemplate the various aspects of the invention in any number of claim forms. For example while only one aspect of the invention is recited as embodied in a computer readable medium other aspects may likewise be embodied in a computer readable medium. Accordingly the inventors reserve the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the invention.

