---

title: System and method for managing hard lock state information in a distributed storage system environment
abstract: A system and method manages lock state information in a distributed file system. A meta-data volume includes a lock state database which is a comprehensive source for lock state information about a striped volume set in the system. A plurality of data volumes includes local lock caches which contain information about locks. Lock state messaging between the meta-data volume and the data volumes is used to assign locks and to update local lock caches. The meta-data volume is configured to assigned permissive areas in the data containers accessed by clients in order to efficiently manage the lock state information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07587558&OS=07587558&RS=07587558
owner: NetApp, Inc.
number: 07587558
owner_city: Sunnyvale
owner_country: US
publication_date: 20051101
---
The present invention relates to a distributed cluster computer environment and more particularly to managing lock information in such an environment.

A storage system typically comprises one or more storage devices into which information may be entered and from which information may be obtained as desired. The storage system includes a storage operating system that functionally organizes the system by inter alia invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including but not limited to a network attached storage environment a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array wherein the term disk commonly describes a self contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive HDD or direct access storage device DASD .

The storage operating system of the storage system may implement a high level module such as a file system to logically organize the information stored on volumes as a hierarchical structure of data containers such as files and logical units. For example each on disk file may be implemented as set of data structures i.e. disk blocks configured to store information such as the actual data for the file. These data blocks are organized within a volume block number vbn space that is maintained by the file system. The file system may also assign each data block in the file a corresponding file offset or file block number fbn . The file system typically assigns sequences of fbns on a per file basis whereas vbns are assigned over a larger volume address space. The file system organizes the data blocks within the vbn space as a logical volume each logical volume may be although is not necessarily associated with its own file system.

A known type of file system is a write anywhere file system that does not overwrite data on disks. If a data block is retrieved read from disk into a memory of the storage system and dirtied i.e. updated or modified with new data the data block is thereafter stored written to a new location on disk to optimize write performance. A write anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations particularly for sequential read operations directed to the disks. An example of a write anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout WAFL file system available from Network Appliance Inc. Sunnyvale Calif.

The storage system may be further configured to operate according to a client server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model the client may comprise an application such as a database application executing on a computer that connects to the storage system over a computer network such as a point to point link shared local area network LAN wide area network WAN or virtual private network VPN implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file based and block based protocol messages in the form of packets to the system over the network.

A plurality of storage systems may be interconnected to provide a storage system environment configured to service many clients. Each storage system may be configured to service one or more volumes wherein each volume stores one or more data containers. Yet often a large number of data access requests issued by the clients may be directed to a small number of data containers serviced by a particular storage system of the environment. A solution to such a problem is to distribute the volumes serviced by the particular storage system among all of the storage systems of the environment. This in turn distributes the data access requests along with the processing resources needed to service such requests among all of the storage systems thereby reducing the individual processing load on each storage system. However a noted disadvantage arises when only a single data container such as a file is heavily accessed by clients of the storage system environment. As a result the storage system attempting to service the requests directed to that data container may exceed its processing resources and become overburdened with a concomitant degradation of speed and performance.

One technique for overcoming the disadvantages of having a single data container that is heavily utilized is to stripe the data container across a plurality of volumes configured as a striped volume set SVS where each volume is serviced by a different storage system thereby distributing the load for the single data container among a plurality of storage systems. A technique for data container striping is described in the above incorporated U.S. patent application Ser. No. 11 119 278 of Kazar et al. entitled STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER. In such an environment a SVS comprises one or more data volumes DV and a meta data volume MDV . Each DV and the MDV is typically served by a separate node of the distributed storage system environment. In the environment described in the above incorporated U.S. Patent Application the node may comprise a network element N module and a disk element D module that includes a file system. As used herein a D module serving hosting a DV is referred to as a DV node while a D module hosting the MDV for a SVS is referred to as a MDV node. 

Most file access protocols include locking capabilities. A lock is a mechanism that enables a client or system administrator to prevent access to a shared resource. An entity later attempting to access this shared resource will be notified of the exclusive lock which prevents others from accessing the resource. The types of locks can vary for example in some instances there may be a write lock placed on a resource by the owner yet other entities may be able to obtain read access to the resource. The type of lock and or the absence of a lock over a particular data container such as a file or portion thereof are referred to herein as a lock state. 

Various challenges arise with respect to managing lock state information regarding a distributed storage system. The volume of lock state information can be potentially large and subject to constant change as information is updated and edited.

Known techniques for managing lock state information include an approach in which lock state information is distributed directly to end clients. In this case clients and or end users utilize specific lock state management software applications and special protocols that allow the users to create edit and manage lock state information.

Another approach stores lock state information in a central repository for the entire system however this centralized approach can result in a bottleneck for file access in a large distributed system. Thus a need arises to decentralize yet control lock state information while maintaining the ability to rapidly update this information on the distributed storage system without requiring users to run specialized software programs.

The present invention overcomes the disadvantages of the prior art by providing a technique for managing lock state information in a distributed storage system architecture comprising two or more volumes distributed across a plurality of nodes interconnected as a cluster. The volumes are organized as one or more striped volume sets SVS and configured to store content of data containers such as files and logical units served by the cluster in response to multi protocol data access requests issued by clients. Each node of the cluster includes i a storage server adapted to service a volume of a SVS and ii a multi protocol engine adapted to redirect the data access requests to any storage server of the cluster. Notably the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster.

According to the invention a lock manager is configured to efficiently manage the lock state information including granting revoking and releasing of various types of locks on data containers or ranges of data containers stored on the SVS. Illustratively the lock manager functions inter alia to manage lock state information including hard lock state information. As used herein hard locks are client requested locks which are mandatory and cannot be ignored by other clients. Such locks are also known to those skilled in the art as mandatory locks. These are in contrast to advisory locks or soft locks which let the owner of the lock watch a portion or particular range of a file or data container for conflicting activity.

In the distributed storage system each SVS comprises a meta data volume MDV configured to store a canonical copy of meta data including access control lists and directories associated with all data containers stored on the SVS and one or more data volumes DV configured to store at least data content of those containers. Notably the MDV the MDV node also functions as the authoritative source for all lock state information for all data containers on the SVS. To that end the lock manager configures and maintains a lock state database on the MDV that contains the lock state information for the SVS. Client requests for access to particular data containers or portions of data containers are directed to and processed by the MDV node and the resulting lock state information is provided to the DVs DV nodes for storage on local lock caches on the DV nodes.

In accordance with a further aspect of the invention novel lock state command messages are provided to convey lock state information between the MDV node and the individual DV nodes. For example when a DV node receives a data container access request from a client it will check its own local lock cache. If that local lock cache does not contain relevant lock state information for the pending request the DV node sends a command query in accordance with a lock state message to the MDV node and the MDV node responds with appropriate lock state information regarding conflicting locks if any. The MDV node maintains a record of lock state information that it has sent to each DV node so that the MDV node can subsequently update the appropriate DV node regarding lock states that have been purged or changed for example. The DV nodes can then allow or deny access requests accordingly.

In accordance with another aspect of the invention the lock states are further managed using designations called permissive areas that are used to propagate implicit lock state information from the MDV node to the DV nodes. A permissive area as used herein is a lock similar to a client requested lock but the permissive area lock is established by the MDV node in order to fulfill a request for a DV node. Moreover permissive areas are revoked automatically when a new client requested lock would conflict with the permissive area. As with a client requested lock a permissive area could span either an entire data container or simply a portion of one. If a predefined length is not available due to other existing locks then the amount of the data container that is available is assigned. If a sufficient amount is not available the request is denied.

The clients may be general purpose computers configured to interact with the node in accordance with a client server model of information delivery. That is each client may request the services of the node and the node may return the results of the services requested by the client by exchanging packets over the network . The client may issue packets including file based access protocols such as the Common Internet File System CIFS protocol or Network File System NFS protocol over the Transmission Control Protocol Internet Protocol TCP IP when accessing information in the form of files and directories. Alternatively the client may issue packets including block based access protocols such as the Small Computer Systems Interface SCSI protocol encapsulated over TCP IP iSCSI and SCSI encapsulated over Fibre Channel FCP when accessing information in the form of blocks.

Each node is illustratively embodied as a dual processor storage system executing a storage operating system that preferably implements a high level module such as a file system to logically organize the information as a hierarchical structure of named data containers such as directories files and special types of files called virtual disks hereinafter generally blocks on the disks. However it will be apparent to those of ordinary skill in the art that the node may alternatively comprise a single or more than two processor system. Illustratively one processor executes the functions of the N module on the node while the other processor executes the functions of the D module .

The memory illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may in turn comprise processing elements and or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system portions of which is typically resident in memory and executed by the processing elements functionally organizes the node by inter alia invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means including various computer readable media may be used for storing and executing program instructions pertaining to the invention described herein.

The network adapter comprises a plurality of ports adapted to couple the node to one or more clients over point to point links wide area networks virtual private networks implemented over a public network Internet or a shared local area network. The network adapter thus may comprise the mechanical electrical and signaling circuitry needed to connect the node to the network. Illustratively the computer network may be embodied as an Ethernet network or a Fibre Channel FC network. Each client may communicate with the node over network by exchanging discrete frames or packets of data according to pre defined protocols such as TCP IP.

The storage adapter cooperates with the storage operating system executing on the node to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape optical DVD magnetic tape bubble memory electronic random access memory micro electro mechanical and any other similar media adapted to store information including data and parity information. However as illustratively described herein the information is preferably stored on the disks of array . The storage adapter comprises a plurality of ports having input output I O interface circuitry that couples to the disks over an I O interconnect arrangement such as a conventional high performance FC link topology.

Storage of information on each array is preferably implemented as one or more storage volumes that comprise a collection of physical storage disks cooperating to define an overall logical arrangement of volume block number vbn space on the volume s . Each logical volume is generally although not necessarily associated with its own file system. The disks within a logical volume file system are typically organized as one or more groups wherein each group may be operated as a Redundant Array of Independent or Inexpensive Disks RAID . Most RAID implementations such as a RAID 4 level implementation enhance the reliability integrity of data storage through the redundant writing of data stripes across a given number of physical disks in the RAID group and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID 4 level implementation although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.

To facilitate access to the disks the storage operating system implements a write anywhere file system that cooperates with one or more virtualization modules to virtualize the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each on disk file may be implemented as set of disk blocks configured to store information such as data whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module s allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers luns .

In the illustrative embodiment the storage operating system is preferably the NetApp Data ONTAP operating system available from Network Appliance Inc. Sunnyvale Calif. that implements a Write Anywhere File Layout WAFL file system. However it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such where the term ONTAP is employed it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.

In addition the storage operating system includes a series of software layers organized to form a storage server that provides data paths for accessing information stored on the disks of the node . To that end the storage server includes a file system module in cooperating relation with a volume striping module VSM a RAID system module and a disk driver system module . The RAID system manages the storage and retrieval of information to and from the volumes disks in accordance with I O operations while the disk driver system implements a disk access protocol such as e.g. the SCSI protocol. The VSM illustratively implements a striped volume set SVS . As described further herein the VSM cooperates with the file system to enable storage server to service a volume of the SVS. In particular the VSM implements a Locate function to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster.

The file system implements a virtualization system of the storage operating system through the interaction with one or more virtualization modules illustratively embodied as e.g. a virtual disk vdisk module not shown and a SCSI target module . The vdisk module enables access by administrative interfaces such as a user interface of a management framework not shown in response to a user system administrator issuing commands to the node . The SCSI target module is generally disposed between the FC and iSCSI drivers and the file system to provide a translation layer of the virtualization system between the block lun space and the file system space where luns are represented as blocks.

The file system is illustratively a message based system that provides logical volume management capabilities for use in access to the information stored on the storage devices such as disks. That is in addition to providing file system semantics the file system provides functions normally associated with a volume manager. These functions include i aggregation of the disks ii aggregation of storage bandwidth of the disks and iii reliability guarantees such as mirroring and or parity RAID . The file system illustratively implements the WAFL file system hereinafter generally the write anywhere file system having an on disk format representation that is block based using e.g. 4 kilobyte KB blocks and using index nodes inodes to identify files and file attributes such as creation time access permissions size and block location . The file system uses files to store meta data describing the layout of its file system these meta data files include among others an inode file. A file handle i.e. an identifier that includes an inode number is used to retrieve an inode from disk.

Broadly stated all inodes of the write anywhere file system are organized into the inode file. A file system fs info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume file system has an fsinfo block that is preferably stored at a fixed location within e.g. a RAID group. The inode of the inode file may directly reference point to data blocks of the inode file or may reference indirect blocks of the inode file that in turn reference data blocks of the inode file. Within each data block of the inode file are embedded inodes each of which may reference indirect blocks that in turn reference data blocks of a file.

As described further herein the file system includes a lock manager process that is configured to efficiently manage lock state information including granting revoking and releasing of various types of locks on data containers such as files stored on the SVS. For example in response to a file access operation that includes a request for a lock of a particular type the lock manager decides whether to grant refuse to grant or wait for the appropriate time to grant that lock. To that end the lock manager coordinates share open requests which provide for locks on an entire file and range locks that cover a specific byte range within a file. Both share open locks and range locks are established upon request of the client who then becomes the owner of the lock. Illustratively the locks may be removed only by the lock owner. More specifically the lock manager functions inter alia to manage lock state information including hard lock state information. As used herein hard locks are client requested locks which are mandatory and cannot be ignored by other clients and as noted can only be removed by the lock owner. Such locks are also known to those skilled in the art as mandatory locks. These are in contrast to advisory locks or soft locks which let the owner of the lock watch a portion or particular range of a file or data container for conflicting activity.

Operationally a data access request directed to a data container such as a file is issued from a client and forwarded as a packet over the computer network to the node where it is received at the network adapter . A network driver of layer or layer processes the packet and if appropriate passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write anywhere file system . The lock manager examines the lock state information to determine whether there is an existing lock on the file that could prevent execution of the operation associated with the access request.

If it is determined that execution of the operation is allowed the file system generates additional operations to load retrieve the requested data from disk if it is not resident in core i.e. in memory . If the information is not in memory the file system indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system the logical vbn is mapped to a disk identifier and disk block number disk dbn and sent to an appropriate driver e.g. SCSI of the disk driver system . The disk driver accesses the dbn from the specified disk and loads the requested data block s in memory for processing by the node. Upon completion of the request the node and operating system returns a reply to the client over the network .

It should be noted that the software path through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is in an alternate embodiment of the invention a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array FPGA or an application specific integrated circuit ASIC . This type of hardware implementation increases the performance of the storage service provided by node in response to a request issued by client . Moreover in another alternate embodiment of the invention the processing elements of adapters may be configured to offload some or all of the packet processing and storage access operations respectively from processor to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes architectures and procedures described herein can be implemented in hardware firmware or software.

As used herein the term storage operating system generally refers to the computer executable code operable on a computer to perform a storage function that manages data access and may in the case of a node implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel an application program operating over a general purpose operating system such as UNIX or Windows XP or as a general purpose operating system with configurable functionality which is configured for storage applications as described herein.

In addition it will be understood to those skilled in the art that the invention described herein may apply to any type of special purpose e.g. file server filer or storage serving appliance or general purpose computer including a standalone computer or portion thereof embodied as or including a storage system. Moreover the teachings of this invention can be adapted to a variety of storage system architectures including but not limited to a network attached storage environment and a storage area network and disk assembly directly attached to a client or host computer. The term storage system should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system the teachings of the present invention may be utilized with any suitable file system including a write in place file system.

In the illustrative embodiment the storage server is embodied as D module of the storage operating system to service one or more volumes of array . In addition the multi protocol engine is embodied as N module to i perform protocol termination with respect to a client issuing incoming data access request packets over the network as well as ii redirect those data access requests to any storage server of the cluster . Moreover the N module and D module cooperate to provide a highly scalable distributed storage system architecture of the cluster . To that end each module includes a cluster fabric CF interface module adapted to implement intra cluster communication among the modules as well as D module to D module communications for data container striping operations for example.

The protocol layers e.g. the NFS CIFS layers and the iSCSI FC layers of the N module function as protocol servers that translate file based and block based data access requests from clients into CF protocol messages used for communication with the D module . That is the N module servers convert the incoming data access requests into file system primitive operations commands that are embedded within CF messages by the CF interface module for transmission to the D modules of the cluster . Notably the CF interface modules cooperate to provide a single file system image across all D modules in the cluster . Thus any network port of an N module that receives a client request can access any data container within the single file system image located on any D module of the cluster.

Further to the illustrative embodiment the N module and D module are implemented as separately scheduled processes of storage operating system however in an alternate embodiment the modules may be implemented as pieces of code within a single operating system process. Communication between an N module and D module is thus illustratively effected through the use of message passing between the N module and D module although in the case of remote communication between an N module and D module of different nodes such message passing occurs over the cluster switching fabric . A known message passing mechanism provided by the storage operating system to transfer information between N modules and D modules processes is the Inter Process Communication IPC mechanism. The protocol used with the IPC mechanism is illustratively a generic file and or block based agnostic CF protocol that comprises a collection of methods functions constituting a CF application programming interface API . Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance Inc. The SpinFS protocol is described in the above referenced U.S. Patent Application Publication No. US 2002 0116593.

The CF interface module implements the CF protocol for communicating file system command messages including novel lock state command messages described herein among the modules of cluster . Communication is illustratively effected by the D module exposing the CF API to which an N module or another D module issues calls. To that end the CF interface module is organized as a CF encoder and CF decoder. The CF encoder of e.g. CF interface on N module encapsulates a CF message as i a local procedure call LPC when communicating a file system command to a D module residing on the same node or ii a remote procedure call RPC when communicating the command to a D module residing on a remote node of the cluster . In either case the CF decoder of CF interface on D module de encapsulates the CF message and processes the file system command.

A data container e.g. a file is accessed in the file system using a data container handle. is a schematic block diagram illustrating the format of a data container handle including a SVS ID field an inode number field a unique ifier field a striped flag field and a striping epoch number field . The SVS ID field contains a global identifier within the cluster of the SVS within which the data container resides. The inode number field contains an inode number of an inode within an inode file pertaining to the data container. The unique ifier field contains a monotonically increasing number that uniquely identifies the data container handle . The unique ifier is particularly useful in the case where an inode number has been deleted reused and reassigned to a new data container. The unique ifier distinguishes that reused inode number in a particular data container from a potentially previous use of those fields. The striped flag field is illustratively a Boolean value that identifies whether the data container is striped or not. The striping epoch number field indicates the appropriate striping technique for use with this data container for embodiments where the SVS utilizes differing striping techniques for different data containers. Further details about an illustrative file system organization can be found in commonly owned U.S. patent application Ser. No. 11 119 278 filed on Apr. 29 2005 of Kazar et al. for a STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER which is incorporated by reference herein in its entirety.

The present invention is directed to a technique for managing lock state information in a distributed storage system architecture comprising two or more volumes distributed across a plurality of nodes of cluster . As noted the volumes are organized as one or more striped volume sets SVS and configured to store content of data containers such as files and luns served by the cluster in response to multi protocol data access requests issued by clients. Each node may include a D module adapted to service a volume of the SVS. As more particularly illustrated in the SVS comprises a meta data volume MDV and one or more data volumes DV DV and DV . The MDV is configured to store a canonical or definitive copy of certain metadata including access control lists ACLS and directories associated with all data containers e.g. files stored on the SVS whereas each DV is configured to store at least data contents of those files. The MDV and the DV cooperate with a container attributes volume CAV to provide a multi tier caching and distribution architecture described in commonly owned U.S. patent application Ser. No. 11 119 277 filed on Apr. 29 2005 of Kazar et al. entitled SYSTEM AND METHOD FOR MULTI TIERED METADATA CACHING AND DISTRIBUTION IN A CLUSTERED ENVIRONMENT which is incorporated herein by reference in its entirety. As used herein a D module serving hosting a DV is referred to herein as a DV node while a D module hosting the MDV in a SVS is referred to as an MDV node. 

Assume that two large files File A and File B span both stripes exactly once in each DV node and such that DV node serves hosts the first 50 bytes offset for each file and DV node hosts the next 50 bytes offset for each file. The lock state database in the MDV node maintains all of the lock state information for the ranges embodied in Files A and B from offset to offset .

The specific lock state information that is maintained for each file is schematically illustrated in the lock state data structure of . The lock state data structure contains a lock state field that in turn includes an owner identification ID field that stores an owner ID or a unique identifier of the client that is allowed to access the file. An access type field stores an indication of the type of lock which is either a read lock or a write lock. In addition an access range field is provided that indicates the range of the file locked by the lock type.

Referring again to assume further that a client C sends a request to the N module to obtain exclusive write access for ranges 10 40 of File A stored on the SVS. The N module directs this request to the MDV node as the authoritative source of lock state information for that SVS. The MDV node places an exclusive lock on bytes of the File A for C in its lock state database . Assume now that a client C subsequently requests write access to byte of File A. The request is forwarded to the DV node which checks its local lock cache for lock state information pertaining to the file range. If lock state cache is empty with respect to the file range then in accordance with the invention the absence of information in the cache causes the DV node to query the MDV node to determine the current lock state information with respect to byte of File A.

The MDV node searches the authoritative lock state database and responds with an indication as to whether there is a lock on the particular byte requested. If there is one or more locks the MDV node also responds with the set of locks that is relevant to that particular request. Illustratively the MDV node responds to the DV node that a client has a write lock on bytes . Note that communication between the MDV and DV nodes is effected using lock state commands embedded in the CF protocol messaging described previously.

In an illustrative embodiment of the present invention the DV nodes are notified of the lock state information by the MDV node on a request by request need to know basis due to the large amount of lock state information which could be accumulated for the data containers stored on the SVS. However it may be preferable in other embodiments of the invention to provide more lock state information for local storage on the lock cache of each DV node. Notably the MDV node also keeps track of which DV nodes have been notified of lock state information. Accordingly with respect to future requests the MDV node has a record of lock state information which has already been provided to the DV nodes on an individual basis.

The procedure described above is summarized in the flowchart of . The procedure starts at step and continues to steps where a lock state database is established in the MDV node as a definitive lock state information source for the SVS. In step an N module receives a request for exclusive access to a range of a file from a client. The N module directs this request for exclusivity to the MDV node . Assuming there is no conflict i.e. no existing lock to the requested file range in step the MDV node enters the lock state information for the affected byte range in its lock state database . Subsequently when a data access request arrives at a particular DV node via the N module that DV node checks its local lock cache for information about any lock state that exists for the affected range step . At step a determination is made as to whether the lock cache is empty. The absence of information in the lock state cache causes the procedure to continue to step whereby the MDV node is queried for lock state information about that particular file or byte range. In step the MDV node checks the lock state database and responds to the DV node with an indication as to whether the operation is allowed and with any relevant lock state information about byte ranges involved in the request. In step the MDV node marks its records that the requesting DV node has been notified of particular locks. The DV node then updates its local lock cache accordingly as shown in step . If the local lock cache of the affected DV node does contain lock state information at step then the procedure continues to step where the DV node checks its local lock cache information indicating whether the operation is allowed or should be rejected. The client is notified accordingly and thereafter the procedure ends at step .

During subsequent operation of the system a particular client may determine that it no longer requires exclusivity with respect to a particular file or byte range. Thus in accordance with the invention the procedure is followed which is illustrated in . The procedure starts at step and continues to step where an N module receives a notification from a client that it no longer requires exclusivity on a particular byte range. In step the N module notifies the MDV node of this development. In step the MDV node thereafter checks its records to determine which DV nodes had been supplied with lock state information and sends a lock state command e.g. a LOCK PURGE message to each affected DV node to purge its local lock cache with respect to that byte range. In step the relevant DV nodes purge their lock state caches to remove the lock on that particular byte range and in step each DV node sends an acknowledgement to the MDV node that the lock has been purged. In step the MDV node updates its lock state database to remove the particular lock which had existed on that byte range. In step the MDV node updates its records that each DV node has been notified thereof and has received an acknowledgement of the removal of the locks i.e. the lock purge. The procedure ends at step .

As noted an unpopulated region in the local lock cache of a DV node for a particular file s lock state implies a complete lack of information. As set forth in the procedure of encountering an unpopulated region of the local cache necessitates a request to the MDV node for an authoritative response about whether an access request is permitted or denied. In the MDV lock state database on the other hand an unpopulated region in a file s lock state implies that all data access operations are permitted within that region. As such since unpopulated regions in the MDV s lock state database are implicit statements of lock states this information must be propagated to interested DV nodes in some manner.

In accordance with the invention a permissive area is provided to propagate such implicit lock state information to the DV nodes. Permissive areas PAs are real locks but with a unique property that they are dynamically generated by the MDV node when a DV node requests lock state for an unpopulated region of the MDVs lock state database . PAs are treated as other locks on the MDV node in that information is retained by the MDV node about which DV nodes have cached the PAs. The PAs are invalidated from such caching DV nodes when the PAs are destroyed. A permissive area is typically destroyed when a request is directed from a client to the MDV node for a hard or soft lock on a file that overlaps conflicts with the PA. From the perspective of DV nodes PAs are illustratively indistinguishable from a normal range lock that permits a client to perform data access requests within that range of a data container file .

In accordance with a further aspect of the invention the full byte range of a file can be partitioned into a number of distinct ranges referred to herein as preferred permissive areas PPAs . Each PPA can be designated to be of a predetermined range that is illustratively selected as a realistic configuration choice for an application. For example the PPA may be assigned a length equal to a percentage of the total file size or a fixed length block size e.g. 8K bytes for example. Wherever possible the MDV node generates PAs that correspond to exactly one of the preferred PA ranges. Limiting the length of PAs to the preferred range improves efficiency in that it avoids having a large number of smaller PAs that are designated and maintained by the MDV node.

In response to requests for data access activity that spans multiple preferred PAs the MDV node returns multiple PAs instead of one large PA that spans the entire data access range. This mechanism increases the potential reuse of any given PA. When a preferred PA is unavailable due to the existence of overlapping hard or soft lock ranges the largest possible PA within the PPAs range that satisfies the access request is assigned and returned by the MDV node such that the access ranges do not overlap. To reduce the number of outstanding PPAs that might not be utilized the MDV node may choose to utilize a least recently used LRU aging scheme that allows only a fixed number of PAs to be outstanding at any one time. In such a case the MDV node issues illustratively a LOCK PURGE message for old PAs as new ones are formed.

The following examples illustrate lock state interaction between DV nodes and the MDV node in a simplified system. illustrates an initial configuration in which MDV node has an empty lock state database indicating the absence of a lock for a file in question. DV node is responsible for client data access requests directed to the first half of the file and DV node is responsible for such access requests directed to the second half of the file. In DV node the lock cache is empty and thus contains no lock state information. Similarly lock cache of DV node is also empty with no lock state information contained therein.

Similarly when DV node receives the request it consults its local lock cache and finds an absence of information. DV node thus sends an ACCESS REQUEST message regarding the received read request to the MDV node. The MDV node receives the ACCESS REQUEST messages from the DV and DV nodes and checks its authoritative lock state database . Since no locks are present that conflict with either request the MDV node responds that both operations can proceed. Before responding however and in accordance with the invention the MDV node first creates PAs that span the empty space examined by the node. In the illustrative example it has been predetermined that the length of a PA shall be one half of the file s length.

The DV and DV nodes then update their lock caches and and allow the pending access operations to complete. More specifically in response to the client write request and read request the DV node completes the client write request and the DV node completes the client read request respectively.

In addition a second client requests read access to a byte range controlled by the DV node. The DV node thus sends an ACCESS REQUEST message to the MDV node . Yet since the second client has requested access to a range of the file protected by the earlier implemented write range lock WL the MDV node returns an ACCESS REQUEST ACK w WL message to indicate to DV node that the client access is invalid. Thus to summarize DV node has a client read request which succeeds as denoted by . DV node has a client read request as denoted by that has failed due to the earlier designated write range lock WL.

If instead the MDV node determines that there are no conflicting locks then the procedure continues to step in which the MDV node further checks whether there are supporting locks that allow requested operation. If there are such supporting locks then the procedure continues to step in which the MDV node sends an ACCESS REQUEST ACK message with supporting lock information. The DV node then completes the requested operation in step .

If there are no supporting locks and in fact there are no locks at all the procedure continues to step in which the MDV assigns a permissive area of the full predetermined amount which may be a specific range or a smaller range such as one half or one quarter of the file length for example. A sufficient available range is designated as the permissive area. The permissive area so designated is then identified in an ACCESS REQUEST ACK message sent by the MDV as in step . In step the DV then completes the client request. The procedure ends at step .

If at the decision step the MDV node finds that there are no conflicting locks then the procedure continues to step in which the MDV determines whether there is a permissive area already designated for the requested range. If there is not a permissive area the MDV node allows the write lock in step . If there is a permissive area already designated then the procedure continues to step in which the MDV node sends a LOCK PURGE message notifying the affected DV node s of the elimination of the permissive area. The affected DV node then acknowledges the lock purge message with a LOCK PURGE ACK message in step . Then in step the MDV node eliminates any permissive area which had been previously designated in that range. The MDV node thereafter updates its records to indicate that the DV has been notified of the lock purge step . The write lock is then allowed at the MDV node in step and the procedure ends at step .

It should be understood that the CF protocol messaging for managing lock state information illustratively described herein may be written modified or expanded upon or written in a different software language or in a code with different semantics or of a different format while remaining within the scope of the present invention.

In sum the present invention described herein provides an efficient and reliable technique for managing lock state information including hard lock state information in a distributed storage system environment without requiring specialized software on the client. The foregoing description has been directed to particular embodiments of this invention. It will be apparent however that other variations and modifications may be made to the described embodiments with the attainment of some or all of their advantages. Specifically it should be noted that the principles of the present invention may be implemented in non distributed file systems. Furthermore while this description has been written in terms of N and D modules the teachings of the present invention are equally suitable to systems where the functionality of the N and D modules are implemented in a single system. Alternately the functions of the N and D modules may be distributed among any number of separate systems wherein each system performs one or more of the functions. Additionally the procedures processes and or modules described herein may be implemented in hardware software embodied as a computer readable medium having program instructions firmware or a combination thereof. Therefore it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention.

