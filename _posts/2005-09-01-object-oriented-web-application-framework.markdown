---

title: Object oriented web application framework
abstract: A framework for implementing web-based applications using standard object-oriented programming techniques. The framework may be implemented by computer-executable components executable by a Web browser is provided. The components include a resource creation method for creating resource objects, a page interpreter creating instances of objects based on bindings defined in a web-page, and a lifecycle management component for managing instances of the objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07849437&OS=07849437&RS=07849437
owner: Microsoft Corporation
number: 07849437
owner_city: Redmond
owner_country: US
publication_date: 20050901
---
The user experience on the World Wide Web has evolved from viewing static pages of information to interaction with web based applications. Most users experience the web through a Web Browser application such as Internet Explorer Opera Netscape or Firefox. Web browsers essentially provide a forms based environment originally designed to display text and presentation information to the application developer. Techniques for manipulating browsers now include richer tools and HTML enhancements including client side scripting environments such as JavaScript Cascading Style Sheets CSS and animation plug ins such as Macromedia Flash.

Web based applications now provide users various types of functionality. When building Web applications it is difficult to create maintainable component based cross browser applications. Scripting allows developers to add increased interaction information processing and control in Web based content.

Current technology fails to address well understood architectural approaches for defining and implementing associations between different behaviors on the page and fails to enable reuse of behaviors in the web application design process. Generally functions are enabled using downloadable java applications or JavaScript nested within the webpage. JavaScript is placed throughout the page in a manner which is not managed centrally. Most Web applications have scripts and behavior randomly placed throughout the page. For example scripts may be in the head section in line or attached directly to an element. There is no common approach to managing the dependencies between handlers and scripts. This can lead to performance or timing issues such as when a user clicks a button and the script is not yet available. As a result resource management to support scripts and web application becomes a problem.

Another issue for developers is managing the constraints of a client side application. Web applications are potentially downloaded via a constrained connection to a server. As applications become more interactive the size of code and data increases slowing the download process. There is typically a conflict between providing an enriched client interactivity in a web document while maintaining client performance. Therefore developers seek to remove bottlenecks associated with adding behaviors. Perceived performance is correlated to rendering speed or how fast the first screen of content displays.

Adding to the resource management problem is the fact that some web applications are evolving to be in an unbounded manner. For example a typical custom home page can contain anywhere from one to many different components where the component set is potentially limitless. These pages can be very expensive in their ability to download and render. Therefore as the set of components grow there needs to be an infrastructure that can properly delegate and manage the deployment of necessary resources and an approach that provides the fastest response to the user.

A framework for implementing web based applications using standard object oriented programming techniques is provided. The framework may be implemented by a script file interpreted by a browser. The framework allows a page developer to create web pages and application using a component based pattern. The architecture extends the separation of document presentation from the document structure to include document behaviors.

In one embodiment a computer readable medium having computer executable components executable by a Web browser is provided. The components include a resource creation method for creating resource objects a page interpreter creating instances of objects based on bindings defined in a web page and a lifecycle management component for managing instances of the objects.

In an alternative embodiment a method of providing a web based application from a server to a client is provided. The method includes the steps of storing a plurality of resources on the server providing a resource control framework interpretable by a Web browser to a browser on a client and providing ones of said resources to the resource control manager on the client device responsive to the browser interpreting bound resources in a document.

In another embodiment a method of creating a web page rendered on a computer is provided. The method may include defining a call to a management framework executable by a web browser defining at least one resource object accessible by the framework and creating bindings to the resource object in the web page.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

A method and framework for developing web applications is disclosed. The method and framework enables developers to create applications and pages by binding behaviors to page elements behaviors and unbounded client applications can be more easily designed and result in optimized application performance.

A binding pattern is defined that associates JavaScript classes to elements on a page. Additionally a registration process allows bindings to register for other bindings on the page which allows a dynamic and loose association of bindings on a particular page. This method and framework enables a layered approach to resource reusability since all interactive sites can be built over the same set of core framework services. In addition additional UI paradigms and gestures can be built on top of the core services. These can be designed to be shared or can be specific to a site implementation.

The framework implements a unique component based pattern heretofore unknown in Web based development or highly interactive and dynamic cross browser web sites. The framework architecture extends the separation of document presentation from the document structure to include document behaviors.

In one implementation the framework is implemented by allowing users to build objects in a browser environment and bind the objects to a page. The framework is implemented by one or more core files which in one embodiment are JavaScript files downloaded from an application server. There provide client level libraries that perform a number of functions including object registration destruction and management. It is noted that the implementation of the core files as JavaScript is suitable for current Web browser as currently Web Browsers typically only understand JavaScript. However the principles of the present invention need not be limited to JavaScript nor need each of the objects be limited to JavaScript.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

To develop page using the framework each module is defined as a JavaScript object which is then bound to the page definition and managed by the Framework. As such the resources required by the module or other component or element can be managed and reused by the Framework and developers to create documents using an object based design.

It will be further recognized that while the framework will be described herein as implemented with respect to JavaScript and a browser as the interpreting application the principles of the framework are not limited thereto. The framework could be implemented in any interpreted language.

Returning to application server also includes script objects style sheets and common images used in the pages which may be downloaded as discussed below when any page is parsed and interpreted by browser . The framework may include a resource download controller which manages the deployment and instantiation of the scripts. The framework can load scripts asynchronously and in parallel leading to better performance on faster connections. Framework scripts style sheets and common images are shared across the network from a single source thereby increasing the overall actual and perceived performance to the user. The more the user visits the application server the faster the network runs as there is a continually increasing probability that prerequisite files are cached. The only extra downloads will be the task specific files to the properties.

In essence the framework enables a shared domain for hosting these shared resources. Rather than having to implement one off scripts for shareable content a developer is able to leverage the implementation of any individual property and inject the content into a page. This injected content uses a shared HTML semantic to ensure that it is rendered properly by each properties theme.

The client device includes for example a web browsing application which may interpret the scripting language that the framework is implemented in. Upon loading a page implementing the framework core libraries and script objects used by the browser to render pages under the Framework are downloaded to the client device memory .

At step the developer will define the page header and body of the web page. In this definition the developer will install a call to the framework core file or files. As discussed below the core library file script and any broadly applicable library extensions are the only scripts that need be included on a web page. All other scripts are managed and downloaded via the binding mechanisms discussed below.

As an example the a core set of scripts Framework Compat.JS and FrameworkCore.js are defined in the page as follows 

In this example the FrameworkCore.js script may be that which is used with a particular browser such as Internal Explorer browser while the FrameworkCompat.js file provides compatibility with other browsers.

In the numerous binding definitions set forth herein a choice between the files may be made by including an If statement in the binding of the form 

The XML Framework namespace should only be used by binding declarations and may be specified on the HTML element. A key tenet of the library is a prescribed JavaScript pattern for namespace scoping of client code. In JavaScript the fact that everything is an object can be leveraged to simulate namespaces. Namespaces can span a single file or be defined across multiple files. The Framework libraries all share the Framework namespace. Only core shared functionality should be defined within this namespace. All functionality built on this library should be defined using a separate namespace.

Next at step the developer creates objects for use with the page or selects from pre defined objects created by others. Bindings are a cross browser component model for attaching different behaviors to existing and custom elements.

Bindings can be declared declaratively or programmatically within the structure of a document. Bindings can be declared as a group or individually.

Initial bindings on a page are typically established using a binding element. An example framework is 

A binding is implemented by a JavaScript class referred to herein as a binding implementation. As noted in the commented lines of the above example standard object oriented design concepts of inheritance public and private variables and functions and a constructor and destructor function are supported in a binding definition. A binding can also define its supported argument parameter and event list. These concepts are described and illustrated further below.

In one embodiment all bindings inherit from a base class Frameworks.Bindings.Base. Inheritance is implemented by specifying class inheritance on the type of the derived class Demo.HelloWorld.registerClass Demo.HelloWorld Framework.Bindings. Base . Next the first line of the class calls an initializeBase method. This call instantiates and propagates the base classes methods onto the current instance.

Bindings once defined can then be associated to elements on the page by the developer. At step the developer inserts bindings in the body of the page. Each declared binding can create an instance of the object bound as discussed below. The binding class can be associated with 0 to many elements on a web page. Each association creates an instance of the binding implementation. As discussed below associations can be created either declaratively or programmatically.

Example 3 illustrates how a developer at step creates and associate element s with the HelloWorld class. In this example all DIV elements are bound with the class name hello to the HelloWorld binding implementation 

The binding resources define the binding implementation. A binding implementation can consist of zero 0 to many scripts and zero 0 to many style sheets. If no script external resource is specified it must be included directly within the web page. The binding resources are created using a binding References tag.

In one embodiment the framework is optimized to manage and properly download each resource only once. A binding will not be instantiated until all the specified resources have been deployed. Since scripts are downloading after the page loads scripts should not include any inline execution that depends on another file e.g. call a function in another file while the script is parsed or writes any contents into the page.

The framework causes the browser to avoid executing any script until after the initial parsing of the page. To ensure this pattern is followed the framework binding object scripts should be included immediately prior to the page s closing HTML element. In addition the last script on the page Framework.Runtime.init calls the initialization of the library.

Once the bindings are declared in the page the page can be published and available for distribution at step .

At a later point in time when a user requests the page the page is loaded at step . In the Browser the page is parsed and a binding instance is created for each element in the listed binding declarations. Step is further detailed in . The page is then rendered at step . When the page is unloaded or navigated away from instantiated binding s dispose method is called notifying the binding to destroy and clean up its references.

Before discussing the operation of the browser on a page designed to operate using the framework specific features of the bindings and methods supported by the framework will be described.

As noted above bindings can have their class and instance level defaults defined declaratively. All default values specified declaratively are string based values. The same binding type may be used with different definitions and parameters by creating different variations of the same binding declarations.

Class level default parameters are specified using a tag in the below example the tag is Framework defaults . Class level definitions include the default parameters for all created instances of the binding definition. In the following example different variations of the binding editor control are bound to different selectors 

In addition to class level parameters instance specific defaults may be specified at the element level. These defaults will override any parameters specified at the class level. Specifying instance level defaults requires first defining the namespace used for instance level defaults on the binding declaration using the namespace attribute on the Framework binding tag. In addition the namespace is then used as a prefix for all attributes on the element being bound. This eliminates ambiguity in binding specific properties.

All parameters specifiable by an instance must be defined on the binding class as a Params property. For example 

Also as noted above the framework also provides encapsulation and scoping. JavaScript closures provide encapsulation of a binding implementation as illustrated in the example below. The below example creates a ticking clock binding which can be instantiated to display any number of ticking clocks on a web page 

The Bindings instances are created in the following example which also illustrates styling using CSS 

The variables in the above example have a scope since each instance of the binding is a new instance of the binding implementation there is a separate lexical scope for each instance. Each execution of the timer runs the UpdateTime function in the lexical scope of the object instance. Therefore the defined variables are scoped and available for use. The destroy function is called when the binding is removed from an element. In this example this occurs when the page is unloaded. Lastly each clock can have a style declaration associated with it.

The default arguments are passed into the binding constructor as the second argument. This argument is an associative array of values. If a default value is not specified for a property it will return null. It can also be determined if a different default class level value was specified. This is accomplished by looking at the default property of the attribute. If this property is not null a default class level value was specified that was overridden by the instance.

Bindings can expose events and broadcast messages. Bindings can also attach to other bindings events or register for message broadcast. The difference between a binding event and a broadcast is a binding event is associated with a specific binding instance. Therefore to receive the event must be explicitly attached to the binding instance. On the other hand a message broadcast is not associated with a specific instance and can be listened for without regard to the binding source.

Bindings can expose events methods and properties. All events supported by a binding must be defined on the binding class. This is accomplished via a special enumeration Events. For example 

To expose events on a binding one creates an Events enumeration on the class. This enumeration specifies all public events. To fire an event for binding calls a fire method. This method takes two arguments the event name and an object representing any payload carried with the event fire eventName data . The event object is the first argument past to all event handlers. The event object has at least three properties srcBinding eventName and Package. The Package represents the data past by the event initiator.

To assist in defining properly scoped style definitions to a binding bindings automatically or manually apply a class structure consistent with a binding type to the bound element. In a binding intiialize constructor one can call a this.ApplyClass method. This method will append javascript types including any derived from to the bound element s class attribute. For example if one were to bind a class Start.WeatherModule to the DIV element . . . after calling this.ApplyClass the class name on this element will be extended to . . . . All javascript types will be appended with the . characters converted to   on the class attribute of the element. Now one can easily create properly scoped styles as follows 

The DIV tags within the binding will be absolutely positioned at the specified position. If the binding is detached from the element the class names if generated automatically or using the ApplyClass method will be automatically removed from the element.

As an example of how a binding can expose events methods and properties a list binding is set for the below. This example illustrates how Framework allows different bindings to communicate with each other 

In this example the semantics of a ListItem are separated from the List class. This separation allows the ListItem to be treated as an independent type. Each list item has behavior semantics separate from the underlying HTML structure. The binding is applied two differently shaped sections of HTML.

Most of the time bindings are created asynchronously. To simplify wiring of sub bindings where external script sources are not specified the attachElementBindingSync and attachSelectorBindingSync methods are provided in the Framework return the binding or array of bindings respectively. If a callback discussed below is also specified it will get called.

Bindings can also be established from within scripts. This is most often done to create bindings scoped within another binding as in the list example set forth above . The arguments used to establish a binding programmatically are similar to the attributes used by the link element.

Bindings can be attached via a CSS Selector and the Framework may provide an Application Programming Interface API to allow attaching the binding using a selector in a manner similar to using a link element. For example 

The bindingType can be specified as either a string value or an actual javascript class. Generally one defines the binding type as a string unless it is known that the binding type already exists. Optional binding resources such as style sheets and scripts are supplied as an array.

Bindings attached programmatically via a selector can specify a root element p elRoot to apply the selector against. The selector is then validated against the sub tree below the specified root element. If a root element is not specified the entire document is scanned for matching elements. A selector method returns an array of bindings when no external sources are specified. If any external script sources are specified the return value is an empty array and a reference to the attached bindings may be obtained via a callback the binding is instantiated asynchronously . In all cases if a callback is specified it will be called when the binding is created.

The Framework supports encapsulation and the binding scope is useful when creating a hierarchy of bindings. All bindings have a scope whether the global scope or encapsulated within another binding. Scope is useful when creating a hierarchy of bindings. If scope is not specified the binding is registered in the global scope. Scoping enables an object hierarchy of bindings to be established and defines the bindings visibility for registrations see below .

In one case one can attach a binding directly to an element. An element can be anything in the page definition Directly attaching a binding takes a single element to which the binding is attached and an optional scope. The rest of the arguments work the same as the AttachSelectorBinding method previously described.

As noted above illustrates step in the process of page loading and rendering. Initially at step a web page is parsed by a browser. As noted above to implement the framework the binding framework reference is included in the document . At step the browser will determine whether the Framework libraries have been already downloaded and if not will download the Framework core files at . This may include downloading one or more core functionality files and one or more compatibility files as discussed herein.

Next at step the binding declarations listed in the document will be parsed by the browser. A first FOR loop at begins such that for each declaration in the page an binding declaration object is created at step and the object is added to a global list of binding declarations maintained by the framework. Next at step the elements for the declaration are determined using the declaration s ElementQuery. Next a binding instance is created at for each element in the list. Steps and are also performed for any new binding declaration defined.

Bindings are automatically established when the framework is initialized. While not precluded there is no automatic revalidation if the document structure changes. If an element is added removed or changed and bindings need to reflect such changes one will typically manually revalidate the elements. There are a number of methods available for this process. A Bindings.revalidateBinding method will review all existing bindings specified with a CSS selector within a scope and validate that the selector still applies to the element. Note that any bindings attached directly to the element not using a CSS selector are not removed. A Bindings.extendBinding method reviews all selector based bindings and adds any new bindings that match the element within the specified scope. A Framework.Bindings.removeBindings method removes all bindings attached to an element. This method may be called before deleting a node from the document tree that may contain a binding. This ensures that any references are properly cleaned up.

Sub bindings are created as children of an existing binding using the aforementioned scope. This is done by directly calling an Attach Binding methods. However if access to another binding on the web page is required it may be requested via the registration mechanism.

Registration is the process of requesting a notification when an instance of a specific or any binding type is created. Two methods are provided for registering for bindings one for bindings within the current page and another for registering for bindings that exist in another window. The registerFor method is for requesting access to each instance of other binding types that may exist on a page. The class name is specified as a string and its definition does not need to exist at the time of the call. Once a binding instance of the specified type is created a notification will be provided via an onregister notification or the optional specified callback Step below . An optional argument p elRoot specifies whether to only look for bindings that are a descendant element of a specific element or to look for the binding instance anywhere within your scope.

A registerForlnWindow method enables cross window accessing of bindings. This method is similar to the registerFor method but allows one to specify a window object that specifies the window used to look for the binding instances.

You can register for all bindings within a scope by specifying as the binding type. In addition when you register for a binding s class you are notified for all binding instances that match that class and any binding instances that derive from that class. Therefore registering for Framework.Bindings.Base is analogous to registering for since all bindings are derived from that base class.

When a binding matches the registration your specified callback is executed. The callback received two arguments. For example 

All bindings are associated with a specific element. An onbinding or onunbinding event occurs if another binding is attached or removed from your bound element. This event receives a reference to the newly instantiated binding.

Returning to a second FOR loop occurs for registered callbacks and notifications. At step for each registered callback in the same scope as the binding instance determination of whether the target type matched the type of the new instance is made at step . If so a callback is fired at . If not the callback is registered to the global callback list at . Note that when a new binding instance may register for notification of the existence of another binding type at . When this occurs the registration is added into the list of registered call backs at step and at step for each binding instance in the calling binding scope steps and are performed.

A dispose is provided so that developers can remove references to other objects bindings or events. One must make such dereferences so not to receive events or other notifications when their binding is no longer active.

Dispose is called when a binding is detached from an element or the page unloads. The Boolean argument is true when the binding is being destroyed because the page is unloading. In this event you should remove any synched events and clear any object references you may have made. Failure to do so can cause random results.

The framework also supports Application level bindings. An Application level binding is a non UI binding that is used to manage the interactions on a web page. An application binding is defined by not specifying any selector. Since all bindings ultimately are associated with an element application level bindings are attached to the HTML element.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

