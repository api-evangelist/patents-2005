---

title: Object oriented communication between isolates
abstract: A computer-implemented method and computer-readable medium for providing object-oriented communication between isolates is described. A request is received from a requesting Xlet for a remote reference to an exported object in a first isolate, the exported object having been exported by an exporting Xlet. A plurality of object registries are searched for the remote reference, each of the object registries being in a respective isolate. The remote reference is retrieved from one of the object registries and the remote reference is forwarded to the requesting Xlet.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08046773&OS=08046773&RS=08046773
owner: Oracle America, Inc.
number: 08046773
owner_city: Redwood City
owner_country: US
publication_date: 20051026
---
This Application is related to commonly assigned U.S. patent application entitled Object Oriented Communication Between Isolates which has Ser. No. 11 259 996 and was filed on the same day as this Application.

Computer systems for connected devices such as cell phones personal data assistants PDAs and set top boxes for televisions are becoming more flexible. Newer systems allow software to be downloaded and executed. The downloaded software may not be entirely trustworthy and yet may share resources with existing trusted software. Various techniques have been proposed and implemented to therefore restrict the access of untrusted software to prevent it from disrupting the operation of the system. However the purpose of these systems is at odds with another goal of allowing software components to communicate with one another.

One known mechanism for allowing software components to communicate with one another is the Remote Procedure Call RPC . This mechanism allows a computer program running on one host to cause code to be executed on another host and return the results to the first program. Typically RPC protocols are used to implement a client server model of distributed computing.

Various editions of the JAVA Platform provide a mechanism known as Remote Method Invocation RMI for performing an RPC to communicate between objects. In RMI the methods of remote JAVA objects can be invoked from another Java virtual machine possibly on a different host. As depicted in RMI essentially allows communication between JAVA Virtual Machine JVM A and JVM B . JVM A and JVM B may be running on the same physical machine or may be running on different machines and connected over a local area network LAN or an Internet Protocol IP network connection or other communication medium. The application program interface API that implements RMI handles the details of the communication between virtual machines.

Because RMI includes all the necessary components and security measures for communicating between different machines over different protocols RMI is complex and can be unwieldy for small devices as RMI provides many features that are simply not needed in most connected devices. Therefore the RMI API is not included in the Personal Basis Profile PBP for JAVA 2 Platform Micro Edition J2ME .

The conventional model for JAVA applications assumes that only one application is executing in a given virtual machine and this application is in complete control of its lifecycle which can include killing the virtual machine it is running in. To accommodate the limited processing and memory resources available in the typical connected device and yet allow multiple programs to run concurrently the JAVA Community Process JCP has proposed the use of a programming model referred to as Xlets.

Xlets are similar to applets which can be run by an Internet web browser or servelets which can be run by a web server in that a plurality of Xlets can run at the same time in a single JVM and their lifecycle can be controlled by another program. In the case of applets the other program is generally a web browser. Running multiple programs in a single instance of a JVM can improve overall system performance and scalability by sharing some of the virtual machine s internal data structures. Xlets may be managed by a stand alone application manager.

Since a plurality of Xlets may be operated by a single JVM a mechanism was deemed necessary to protect sets of Xlets that may be harmed by a malicious downloaded Xlet. Thus the concept of a Logical Virtual Machine LVM was developed. The LVM is a resource context structure that provides a mechanism for referencing the code from one or more programs that share the same resource or object. Associating related threads with a particular LVM allows the related threads to be terminated together when they start to misbehave e.g. by causing a denial of service attack.

However protecting Xlets by separating them into different LVMs meant placing them out of communication with each other which is undesirable. Therefore some mechanism was required to permit Xlets to communicate to each other from between different LVMs or more generically resource domains. U.S. Pat. No. 6 829 772 issued Dec. 7 2004 and hereby incorporated by reference presents a method now referred to as Inter Xlet Communication IXC that allows Xlets to communicate with each other from different LVMs. It should be noted that when that patent was filed the term Xlet had yet to be coined and so Xlets are referred to therein by the term applets which was used generically.

The IXC API is now part of the J2ME PBP. represents IXC between two Xlets Xlet A and Xlet B which each reside in different LVMs. However this IXC implementation is limited to what is referred to as a single process multi virtual machine MVM paradigm. In this paradigm each LVM is executed in a single process JVM and shares a common address space. The IXC implementation not shown takes advantage of the common address space for sharing instances between each LVM.

An isolation context for executing Xlets is now termed isolate. In one realization of isolate each isolate runs in its own process and therefore has its own address space. This may be referred to as the multiple process MVM paradigm. The JAVA Application Isolate API is defined in JAVA Specification Request 121 JSR 121 which is incorporated herein by reference. Because the previous mechanism for IXC relied on a common address space among Xlets it is not structurally possible to implement in this new paradigm.

Thus a new IXC mechanism is needed that will provide required security measures to prevent denial of service attack while at the same time permit RPCs between Xlets located in different isolates on a common JVM. The new mechanism should also provide reliable garbage collection and efficient type checking. Furthermore the IXC implementation should be optimized for an isolate implementation wherein isolates exist on the same machine but in separate address spaces.

Broadly speaking the present invention fills these needs by providing a method and machine readable media providing object oriented communication between isolates.

It should be appreciated that the present invention can be implemented in numerous ways including as a process an apparatus a system a device or a method. Several inventive embodiments of the present invention are described below.

In one embodiment a computer implemented method for object oriented communication between isolates is provided. A request is received from a requesting Xlet for a remote reference to an exported object in a first isolate the exported object having been exported by an exporting Xlet. A plurality of object registries are searched for the remote reference each of the object registries being in a respective isolate. The remote reference is retrieved from one of the object registries and the remote reference is forwarded to the requesting Xlet.

In another embodiment a computer readable medium having program instructions for object oriented communication between isolates is provided. The computer readable medium includes program instructions for requesting a remote reference to an exported object in a first isolate from a requesting Xlet the exported object having been exported by an exporting Xlet searching a plurality of object registries for the remote reference each of the object registries being in a respective isolate retrieving the remote reference from one of the object registries and forwarding the remote reference to the requesting Xlet.

In yet another embodiment a method for providing object oriented communication between isolates is provided. In this method an exported object and a remote reference corresponding to the exported object are entered in an exported isolate registry wherein the entering is performed by a first Xlet in a first isolate and the exported isolate registry is located in the first isolate. A request for the remote reference is sent from a second Xlet in a second isolate to a registry proxy. The exported isolate registry is searched for the remote reference. The remote reference is retrieved from the exported isolate registry and passing the remote reference to the second Xlet and a stub object is instantiated for the second Xlet wherein the stub object provides an interface for the exported object and the stub object passes calls to the exported object.

The advantages of the present invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the invention.

In the following description numerous specific details are set forth in order to provide a thorough understanding of the present invention. However it will be apparent to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known process operations and implementation details have not been described in detail in order to avoid unnecessarily obscuring the invention.

This invention relates to object oriented communication between isolates. An isolate is a protected domain within a computer system that protects one or more threads from being adversely affected by other potentially malicious threads operating on the system. In the JAVA Specification Request 121 JSR 121 which is incorporated herein by reference an isolate is described as a construct midway between threads and JAVA Virtual Machines JVMs . More specifically an isolate in the context of the JAVA personal basis profile is an instance of the Isolate class which encapsulates an application or component and provides the means to start and stop an isolated computation. For example isolates can be used to initiate concurrent execution. Like JVMs they cause execution of a main method of a given class to proceed within its own system level context independently of any other JAVA programs that may be running. Thus isolates differ from threads by guaranteeing lack of interference due to sharing statics or per application run time objects such as the Abstract Window Toolkit thread and shutdown hooks and they differ from JVMs by providing an Application Programming Interface API to create start terminate monitor and communicate with these independent activities. Isolates may operate transparently to the application operating within them. For the purpose of this disclosure the term isolate may be simply used to identify a protected domain in a virtual machine that runs in its own process and therefore has its own address space.

Object oriented communication refers to communication between software objects. A software object is a software construct comprising executable code and data which is held in variables. The data is protected within the object and can be accessed using methods provided by the object. The methods can be invoked by other objects to carry out a procedure. The methods can be interfaces provided by the object to the variables or they can carry out operations on behalf of the calling object. In this way object methods are similar to functions or subroutines in procedural languages. Communication between objects occurs by one object sending a message to a second object to invoke a method in the second object. Any result from the method is then returned to the invoking object.

It will be noted that while various embodiments of the invention mention in particular JVM and the JAVA programming language the invention may be ported to other object oriented programming languages and other virtual machines. It is therefore should not be construed as being limited to JAVA . Furthermore the term Xlet is intended to refer to a type of object oriented application that can share a protected domain or virtual machine with other applications and whose lifecycles may be managed by an external program such as an application manager. The term Xlet as used herein is generic and includes applets and servelets as well as other analogous programming models.

Memory may comprise a single block of randomly accessible memory RAM which may be volatile such that it cannot retain information when power is disconnected. Alternatively memory may comprise segmented or multi layer memory including volatile RAM non volatile RAM such as FLASH memory and or non volatile mass storage. Memory may furthermore include read only memory ROM for storing the device s basic input output system BIOS operating system components and or various software applications and utilities. Memory may be fixed within device or may be removable. For example memory may include removable storage devices such as that sold under the trademarks COMPACTFLASH MEMORY STICK and SD CARD . If memory includes removable memory new software may be added to memory using an outside system such as a computer or network. The new software may then be executed on processor to provide device with additional functionality.

User interface may comprise various elements for providing output to a user and input from a user. For example on the output side user interface may comprise a small liquid crystal display LCD for a portable device and a speaker or a high resolution display for a computer workstation. For a set top box the user interface may include a video and audio outputs that could overlay application information on top of a video and audio signal. On the input side user interface may include a keypad touchscreen a full sized keyboard a remote control voice activation and or any number of other user inputs that provide user interactivity.

In one embodiment device includes input output system which provides communication to the outside world. Specifically device may be continuously or occasionally connected to outside system which may be a network computer system or other device. In particular outside system could comprise a local area network LAN a wide area network WAN such as the Internet or a remote computer or interface device. Network or outside system is capable of downloading executable software to device .

In operation JVM is loaded into or already resides in memory and is executed in processor . JVM provides a virtual machine for executing JAVA bytecode which also resides in memory . The JAVA bytecode is interpreted or just in time JIT compiled using JVM to provide functionality to device . Device may for example include JAVA software for downloading other JAVA software and cause the other software to be executed. In one embodiment JVM includes an application manager for loading starting and ending Xlets which provide functionality to the device.

To make OBJ C available and accessible to other Xlets Xlet A sends a message containing a remote reference to object registry . Xlet A maintains the infrastructure so it can answer requests on OBJ C that it just exported. The registry is provided in an expected location or is otherwise made available to all Xlets operating on the system. In one embodiment the registry is itself a remote object exported by application manager which exists in a different process. In this case the remote reference to registry is defined as a constant by the JVM API. The remote reference sent by Xlet A to object registry contains a name of the object a remote reference to the object and a description of the object. The description can include details of the interface or just a unique identifier of these details such as a hash code. Object registry maintains a registry table which is located somewhere on the system. The registry table is contains a list of names and associated remote object references. The registry table therefore binds the name of each exported object to a reference to the exported object.

In one embodiment the remote reference includes 4 data elements an exporting Xlet identifier an exporting Xlet endpoint identifier an exported object identifier and an interface descriptor. The Xlet identifier may be a name of the exporting Xlet. The Xlet endpoint identifier may be a port number or other representation of an address using whatever communication process is implemented. The port number for example may identify the location of the exporting JVM instance which can then forward calls to the exported object by the Xlet identifier and exported object identifier. The exported object identifier may be a name of the exported object. The interface descriptor may include for example a list of interface names and for each interface name a list of codes based on a method name parameter type s for the method and return type for the method. The codes may be for example hash codes which are fixed length codes representative of variable length inputs. Instead of hash codes the entire method name and types may be provided. In another embodiment the remote reference does not include an interface descriptor and instead includes an interface identifier which can be used to access an interface descriptor which is separately registered by the registry. The provision of this information allows importing Xlets to compare details of the expected interface with the actual interface thereby ensuring a match prior to communicating with remote object. This comparison is be referred to herein as type checking. This avoids having to transmit the full type information every time a remote reference is transmitted in serialized form.

When Xlet B wishes to access OBJ C it sends a message to object registry requesting an instance of OBJ C. Registry accesses registry table and matches the request with the bound remote reference.

When Xlet B imports the remote reference it goes through a process of stub generation to generate stub object . Stub generation is performed on the fly by the IXC API which is part of the JVM. From the standpoint of Xlet B an instance of a remote object is requested from and is provided by object registry . In reality however stub object is only a shell of the original exported object and operates as a proxy to that object. As far as Xlet B is aware however it has a full instance of the remote object and can treat stub object as such. However instead of processing calls internally stub object forwards calls to the original exported object and passes the result from remote exported object to Xlet B .

In one embodiment a stub class is generated dynamically for each object type that is imported and instantiated for each imported object to refer to the original exported object. Thus if multiple objects are imported having the same type the stub class for that object type generated once and then an instance of the stub is instantiated each time an object of that type is imported. Additional details as to the mechanics of stub generation is provided in U.S. Pat. No. 6 829 772 issued to William F. Foote et al. U.S. Pat. No. 5 999 988 issued to Pelegri Llopart et al. and U.S. Pat. No. 6 938 263 issued to Wollrath et al. all of which are incorporated herein by reference in their entirety. In general terms the remote interface classes are loadable on both the importing and the exporting side. This means that the interface classes are on the classpath just like a normal class. When an interface class is loaded the system can introspect the class and find its details i.e. the methods parameter lists and return types. It can then generate the stub class. The mechanism for this sort of introspection is called reflection in JAVA Thus the remote reference includes the names of the remote interfaces since from the interface names you can load the interface classes and from there extract all the information you need to reproduce the interface in the stub class.

When Xlet B imports a remote object thereby generating a new stub it generates a brand new class name on the fly instantiates it and makes it refer to the remote exported object. Stub object implements the interface defined by the object descriptor. Those skilled in the art will recognize that stub generation is a process that is well known in previous IXC implementations as well as various RMI implementations.

The IXC API ensures that stub object forwards method requests to the exported object along some data path which can be implementation specific. For example data path may be a low level inter process communication IPC mechanism provided by the operating system and hardware layers. The remote reference defines an endpoint which is analogous to an address of that remote object. In this way object registry is likewise accessed by its endpoint . In one embodiment endpoints are abstracted to a class that can be implemented on top of different transfer mechanisms i.e. different IPC mechanisms. In another embodiment the endpoints are closely bound to the operating system e.g. using port numbers.

In one embodiment remote reference sent from Xlet A to registry is an object that contains sufficient information regarding the exported object such that the exported object can be contacted. In one embodiment the remote reference object travels from the exporting Xlet to the registry and from the registry to the importing Xlet using JAVA object serialization which is mechanism provided by the JVM to convert an object into a series of numbers e.g. a byte array for transmission between isolates or JVM instances. In another embodiment the object descriptor object travels using a custom coded procedure utilizing a lower level command structure. Persons skilled in the art will understand the various mechanisms available for converting an object into data and transmitting that data between virtual machine VM instances.

The remote reference has sufficient information to enable an Xlet in a different isolate to contact the exported object. By binding the name of the exported object to the remote reference an Xlet in a different isolate can retrieve the remote reference by providing the name of the exported object that the Xlet wants to access as illustrated by the following operations. From another Xlet s perspective the exported object is a remote object.

In operations through Xlet B imports the remote object. In operation Xlet B sends a request to the registry for a remote reference to the remote object exported by Xlet A. In operation the registry sends the remote reference in response to Xlet B s request. In operation Xlet B type checks the remote reference by comparing a type descriptor in the remote reference to the expected interface type thereby ensuring that Xlet B s notion of the type of the remote exported object which Xlet B retains internally is consistent with the actual type of the remote exported object. If the types do not match an error is generated. If the types match then Xlet B generates a stub object corresponding to the type of the remote object. As mentioned earlier the stub object is a proxy to the actual remote object and merely implements the interface of the remote object and forwards calls to and returns results from the remote object.

In operation Xlet B invokes a method in the local stub object which is forwarded by the stub object to the remote object. Any results are returned to the stub object which then passes them back to Xlet B. The procedure then ends as indicated by ending block

There are various security concerns that are raised when Xlets are permitted to communicate with each other. One concern mentioned in the Background section above is the possibility of a denial of service DOS attack. A system is vulnerable to a DOS attack by malicious code when it can be so tied up in servicing requests by the malicious or malignant program that it cannot service legitimate requests from other programs. This can overload the system and prevent normal operation. In the IXC implementation described above with reference to one concern is that a malicious Xlet could make numerous requests to export numerous objects causing the object registry to fill up thus prohibiting other Xlets from utilizing the object registry.

In one embodiment such a DOS attack is prevented by limiting the number of bindings available in the registry from any particular Xlet. In this scheme the registry maintains a count of the number objects exported for each exporting Xlet. If any Xlet reaches its maximum allowed number of exported objects then any additional requests are denied.

As illustrated by the potential problem of a malicious Xlet overloading the object registry with bogus binding requests is eliminated by limiting a number of a available bindings for each Xlet. An example limit might be 50 or 100 bindings per Xlet. This number may vary depending on resource limitations and or other considerations specific to the particular implementation. The binding limit may be a constant value for each Xlet or there may be some authentication mechanism whereby known trusted Xlets that require additional bindings can exceed the limit. It is also possible to limit the number of bindings for each isolate rather than for each Xlet.

When an exporting Xlet dies the exported objects cease to be available for processing requests from other Xlets. It therefore becomes important to update the registry table to reflect the loss of the exported objects attached to the dead Xlet. It is also helpful to notify Xlets that have imported objects from the dead Xlet to be informed that the remote object is no longer available so that any corresponding stub objects can be destroyed. This operation allows memory resources to be reallocated to other processes that require it and is often referred to garbage collection. In the Xlet programming model the lifecycle of individual Xlets may controlled by the application manager which remains aware of the state of the various Xlets on the system. By maintaining a list of Xlets and objects that those Xlets have imported the registry can provide the application manager with the information it needs to inform Xlets that have imported objects that have died of the death of the corresponding remote objects.

In operation the object registry responds to the message by removing the bindings of any objects exported by the dead Xlet. The objects exported by the dead Xlet are referred to herein as dead objects. In addition to removing any bindings to dead objects the object registry sends a message to all the Xlets that imported any of the dead objects.

In operation the importing Xlets respond to the message from the object registry by destroying stub objects corresponding to the dead objects. The procedure then ends as indicated by ending block . The object registry therefore maintains a list of Xlets for each bound object that have imported the bound object. When the bound object dies it can notify all the Xlets that have imported the bound object and remove the binding thereby freeing up resources such as memory resources for other applications.

As described above present various aspects of an exemplary implementation of IXC that relies on a central object registry. To prevent DOS attacks on the registry each Xlet may be limited by the object registry to a selected maximum number of exported object bindings. In an alternative embodiment the registry is distributed so that each isolate maintains a registry for objects exported from that isolate.

For Xlet B to import OBJ C it first contacts registry proxy to request a remote reference what Xlet B will perceive as an instance of the remote object OBJ C. In one embodiment the registry proxy is implemented using a set of specialized commands. In another embodiment the registry proxy is a remote object provided by application manager and is contacted by IXC from other Xlets including Xlet B. In this case Xlet B therefore must import the registry proxy object prior to contacting it to obtain import OBJ C. To ensure that Xlets can find the registry proxy object the remote reference to the registry proxy is a constant value provided by the JVM. In either embodiment Xlet B sends a message to registry proxy requesting that it retrieve a remote reference to OBJ C. To fulfill this request registry proxy refers to a list of isolates in isolate table maintained by application manager and polls each exported isolate registry in each isolate to find out if the particular object being sought is in that isolate. In one embodiment this search of the isolates may be optimized using a consistent naming scheme. For example each isolate may attach a unique prefix to the names of exported objects allowing the registry proxy to first search in the isolates having a prefix in common with the remote object being sought.

To prevent Xlets from exporting objects during a search which could lead to unexpected results the registry obtains an exclusive lock. When the registry proxy controls the lock individual Xlets are prevented from modifying the exported isolate registries. When Xlet A exports object OBJ C it first obtains the exclusive lock or to ensure the registry proxy does not have possession of it. Once the registry proxy finds the searched remote reference bound to the OBJ C it retrieves the reference from the exported isolate registry passes it to Xlet B to complete the transaction with Xlet B and releases the exclusive lock. If the type checking matches as described above Xlet B proceeds to generate stub object which provides the interface for remote object OBJ C and passes calls to OBJ C .

Although the distributed registry model requires the additional steps of polling the various isolates this is acceptable in an environment where each isolate exists on the same machine. This is unlike RMI protocols where registry may not be located on the same machine as the remote objects which would make a search of a distributed registry prohibitively long. Since the IXC model is limited to providing communication between Xlets on the same physical machine the delay associated with the search would be minimal and provide the added advantage of no arbitrary limits on the number of exported objects a particular Xlet can have.

The distributed registry model also potentially simplifies garbage collection. In the typical case there will only be one Xlet for each isolate. When that Xlet dies the isolate shuts down and the exported isolate registry disappears with the isolate. Thus no additional steps are required to remove the registry entries when an Xlet dies in this circumstance. In cases where there is more than one Xlet in an isolate when the Xlet dies gracefully it calls a procedure to shut itself off and that will include a call to the exported isolate registry to remove any entries relating to the Xlet being shut down. If an Xlet locks up e.g. goes into an infinite loop and gobbles up resources the entire isolate is shut down including other Xlets operating in that isolate. This removes the exported isolate registry as well.

As for notifying Xlets in other isolates that have imported objects from a dead or dying Xlet there are two approaches. The first approach is a proactive approach similar to the method discussed above with reference to wherein the application manager notifies each Xlet that has imported objects from the dead or dying Xlet that the remote objects no longer exist prompting the corresponding stub objects to be destroyed. This notification could be a broadcast message to all Xlets or targeted to only those Xlets that have imported objects from the dead or dying Xlet. In another embodiment in what may be termed a reactive approach to garbage collection of defunct imported objects the importing Xlets are not notified of the deaths of the remote object until the Xlet attempts to contact the remote object.

If the remote object no longer exists either because the Xlet shut down or the isolate shut down then the stub object receives an error indicating that the remote object was not found in operation . This error could be passed by the low level IPC mechanism implemented by the IXC API. Alternatively it could be generated in response to a time out error. When the stub object receives this error it passes it to Xlet B and dies in operation . The stub object may terminate itself or be terminated by the Xlet when the Xlet receives the error from the stub object. The procedure then ends as indicated by ending block .

Because both Xlets are on the same machine communication between Xlets is reliable. The IXC protocol is therefore designed to leverage this reliability by providing a simple yet robust IXC infrastructure that satisfies the need for communication between Xlets without compromising the security fostered by the protected domain provided by the isolates.

With the above embodiments in mind it should be understood that the invention can employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing.

Any of the operations described herein that form part of the invention are useful machine operations. The invention also relates to a device or an apparatus for performing these operations. The apparatus can be specially constructed for the required purpose or the apparatus can be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular various general purpose machines can be used with computer programs written in accordance with the teachings herein or it may be more convenient to construct a more specialized apparatus to perform the required operations.

The invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which can be thereafter be read by a computer system. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs magnetic tapes and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

