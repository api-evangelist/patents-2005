---

title: Method and apparatus for efficient management of XML documents
abstract: A storage manager represents XML-compliant documents as a collection of objects in memory, allowing the storage manager to manipulate the document, or parts of the document, with a consistent interface and to provide for features that are not available in conventional XML documents, such as element attributes with types other than text and documents that contain binary rather than text information. The XML-compliant document may be associated with a schema document which defines the arrangement of the document elements and attributes. The schema data associated with a document can contain a mapping between document elements and program code to be associated with each element. The storage manager further has methods for retrieving the code from the element tag. The retrieved code can then be invoked using attributes and content from the associated element and the element then acts like a conventional object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07721194&OS=07721194&RS=07721194
owner: Groove Networks, Inc.
number: 07721194
owner_city: Beverly
owner_country: US
publication_date: 20050318
---
This application is a division of U.S. patent application Ser. No. 09 588 195 entitled Method and Apparatus for Efficient Management of XML Documents filed Jun. 6 2002 by Raymond E. Ozzie Kenneth G. Moore Ransom L. Richardson and Edward J. Fischer

This invention relates to storage and retrieval of information and in particular to storage and retrieval of information encoded in Extended Markup Language XML .

Modern computing systems are capable of storing retrieving and managing large amounts of data. However while computers are fast and efficient at handling numeric data they are less efficient at manipulating text data and are especially poor at interpreting human readable text data. Generally present day computers are unable to understand subtle context information that is necessary to understand and recognize pieces of information that comprise a human readable text document. Consequently although they can detect predefined text orderings or pieces such as words in an undifferentiated text document they cannot easily locate a particular piece of information where the word or words defining the information have specific meanings. For example human readers have no difficulty in differentiating the word will in the sentence The attorney will read the text of Mark s will. but a computer may have great difficulty in distinguishing the two uses and locating only the second such use.

Therefore schemes have been developed in order to assist a computer in interpreting text documents by appropriately coding the document. Many of these schemes identify selected portions of a text document by adding into the document information called markup tags which differentiates different document parts in such a way that a computer can reliably recognize the information. Such schemes are generally called markup languages.

One of these languages is called SGML Standard Generalized Markup Language and is an internationally agreed upon standard for information representation. This language standard grew out of development work on generic coding and mark up languages which was carried out in the early 1970s. Various lines of research merged into a subcommittee of the International Standards Organization called the subcommittee on Text Description and Processing Languages. This subcommittee produced the SGML standard in 1986.

SGML itself is not a mark up language in that it does not define mark up tags nor does it provide a markup template for a particular type of document. Instead SGML denotes a way of describing and developing generalized descriptive markup schemes. These schemes are generalized because the markup is not oriented towards a specific application and descriptive because the markup describes what the text represents instead of how it should be displayed. SGML is very flexible in that markup schemes written in conformance with the standard allow users to define their own formats for documents and to handle large and complex documents and to manage large information repositories.

Recently another development has changed the general situation. The extraordinary growth of the Internet and particularly the World Wide Web has been driven by the ability it gives authors or content providers to easily and cheaply distribute electronic documents to an international audience. SGML contains many optional features that are not needed for Web based applications and has proven to have a cost benefit ratio unattractive to current vendors of Web browsers. Consequently it is not generally used. Instead most documents on the Web are stored and transmitted in a markup language called the Hypertext Markup Language or HTML.

HTML is a simple markup language based on SGML and it is well suited for hypertext multimedia and the display of small and reasonably simple documents that are commonly transmitted on the Web. It uses a small fixed set of markup tags to describe document portions. The small number of fixed tags simplifies document construction and makes it much easier to build applications. However since the tags are fixed HTML is not extensible and has very limited structure and validation capabilities. As electronic Web documents have become larger and more complex it has become increasingly clear that HTML does not have the capabilities needed for large scale commercial publishing.

In order to address the requirements of such large scale commercial publishing and to enable the newly emerging technology of distributed document processing an industry group called the World Wide Web Consortium has developed another markup language called the Extensible Markup Language XML for applications that require capabilities beyond those provided by HTML. Like HTML XML is a simplified subset of SGML specially designed for Web applications and is easier to learn use and implement than full SGML. Unlike HTML XML retains SGML advantages of extensibility structure and validation but XML restricts the use of SGML constructs to ensure that defaults are available when access to certain components of the document is not currently possible over the Internet. XML also defines how Internet Uniform Resource Locators can be used to identify component parts of XML documents.

An XML document is composed of a series of entities or objects. Each entity can contain one or more logical elements and each element can have certain attributes or properties that describe the way in which it is to be processed. XML provides a formal syntax for describing the relationships between the entities elements and attributes that make up an XML document. This syntax tells the computer how to recognize the component parts of each document.

XML uses paired markup tags to identify document components. In particular the start and end of each logical element is clearly identified by entry of a start tag before the element and an end tag after the element. For example the tags and could be used to identify the recipient element of a document in the following manner 

The form and composition of markup tags can be defined by users but are often defined by a trade association or similar body in order to provide interoperability between users. In order to operate with a predefined set of tags users need to know how the markup tags are delimited from normal text and the relationship between the various elements. For example in XML systems elements and their attributes are entered between matched pairs of angle brackets . . . while entity references start with an ampersand and end with a semicolon . . . . Because XML tag sets are based on the logical structure of the document they are easy to read and understand.

Since different documents have different parts or components it is not practical to predefine tags for all elements of all documents. Instead documents can be classified into types which have certain elements. A document type definition DTD indicates which elements to expect in a document type and indicates whether each element found in the document is not allowed allowed and required or allowed but not required. By defining the role of each document element in a DTD it is possible to check that each element occurs in a valid place within the document. For example an XML DTD allows a check to be made that a third level heading is not entered without the existence of a second level heading. Such a hierarchical check cannot be made with HTML. The DTD for a document is typically inserted into the document header and each element is marked with an identifier such as .

However unlike SGML XML does not require the presence of a DTD. If no DTD is available for a document either because all or part of the DTD is not accessible over the Internet or because the document author failed to create the DTD an XML system can assign a default definition for undeclared elements in the document.

XML provides a coding scheme that is flexible enough to describe nearly any logical text structure such as letters reports memos databases or dictionaries. However XML does not specify how an XML compliant data structure is to be stored and displayed much less efficiently stored and displayed. Consequently there is a need for a storage mechanism that can efficiently manipulate and store XML compliant documents.

In accordance with one embodiment of the invention an in memory storage manager represents XML compliant documents as a collection of objects in memory. The collection of objects allows the storage manager to manipulate the document or parts of the document with a consistent interface and to provide for features that are not available in conventional XML documents such as element attributes with types other than text and documents that contain binary rather than text information. In addition in the storage manager the XML compliant document is associated with a schema document which is also an XML document that defines the arrangement of the document elements and attributes. The storage manager can operate with conventional storage services to persist the XML compliant document. Storage containers contain pieces of the document that can be quickly located by the storage manager.

In accordance with another embodiment the storage manager also has predefined methods that allow it to access and manipulate elements and attributes of the document content in a consistent manner. For example the schema data can be accessed and manipulated with the same methods used to access and manipulate the document content.

In accordance with yet another embodiment the schema data associated with a document can contain a mapping between document elements and program code to be associated with each element. The storage manager further has methods for retrieving the code from the element tag. The retrieved code can then be invoked using attributes and content from the associated element and the element then acts like a conventional object.

In all embodiments the storage manager provides dynamic real time data access to clients by multiple processes in multiple contexts. Synchronization among multiple processes accessing the same document is coordinated with event driven queues and locks. The objects that are used to represent the document are constructed from common code found locally in each process. In addition the data in the objects is also stored in memory local to each process. The local memories are synchronized by means of a distributed memory system that continually equates the data copies of the same element in different processes.

In still another embodiment client specified collections are managed by a separate collection manager. The collection manager maintains a data structure called a waffle that represents the XML data structures in tabular form. A record set engine that is driven by user commands propagates a set of updates for a collection to the collection manager. Based on those updates the collection manager updates index structures and may notify waffle users via the notification system. The waffle user may also navigate within the collection using cursors.

The client computer includes a central processing unit CPU which may include a conventional microprocessor random access memory RAM for temporary storage of information and read only memory ROM for permanent storage of information. A memory controller is provided for controlling system RAM . A bus controller is provided for controlling bus and an interrupt controller is used for receiving and processing various interrupt signals from the other system components.

Mass storage may be provided by diskette CD ROM or hard disk . Data and software may be exchanged with client computer via removable media such as diskette and CD ROM . Diskette is insertable into diskette drive which is connected to bus by controller . Similarly CD ROM can be inserted into CD ROM drive which is connected to bus by controller . Finally the hard disk is part of a fixed disk drive which is connected to bus by controller .

User input to the client computer may be provided by a number of devices. For example a keyboard and a mouse may be connected to bus by keyboard and mouse controller . An audio transducer which may act as both a microphone and a speaker is connected to bus by audio controller . It should be obvious to those reasonably skilled in the art that other input devices such as a pen and or tablet and a microphone for voice input may be connected to client computer through bus and an appropriate controller. DMA controller is provided for performing direct memory access to system RAM . A visual display is generated by a video controller which controls video display .

Client computer also includes a network adapter that allows the client computer to be interconnected to a network via a bus . The network which may be a local area network LAN a wide area network WAN or the Internet may utilize general purpose communication lines that interconnect multiple network devices.

Client computer system generally is controlled and coordinated by operating system software such as the WINDOWS NT operating system available from Microsoft Corp. Redmond Wash. . Among other computer system control functions the operating system controls allocation of system resources and performs tasks such as process scheduling memory management networking and I O services.

As illustrated in more detail in the storage manager resides in RAM equivalent to RAM in and provides an interface between an application program which uses XML documents and and the persistent storage in which the documents and are stored. The application can interact with storage manager by means of a consistent application programming interface irregardless of the type of persistent storage used to store the objects. Internally the storage manager represents each document as a hierarchical series of objects and respectively. The storage manager can store the documents and in persistent storage as schematically illustrated by arrow using a variety of file systems such as directory based file services object stores and relational file systems.

The inventive system operates with conventional XML files. A complete XML file normally consists of three components that are defined by specific markup tags. The first two components are optional the last component is required and the components are defined as follows 

If all three components are present and the document instance conforms to the document model defined in the DTD the document is said to be valid. If only the last component is present and no formal document model is present but each element is properly nested within its parent elements and each attribute is specified as an attribute name followed by a value indicator and a quoted string document instance is said to be well formed. The inventive system can work with and generate well formed XML documents.

Within the storage manager XML documents are represented by means of data storage partitions which are collectively referred to by the name Groove Document to distinguish the representation from conventional XML documents. Each Groove document can be described by a DTD that formally identifies the relationships between the various elements that form the document. These DTDs follow the standard XML format. In addition each Groove document has a definition or schema that describes the pattern of elements and attributes in the body of the document. XML version 1.0 does not support schemas. Therefore in order to associate a Groove schema document with an XML data document a special XML processing instruction containing a URI reference to the schema is inserted in the data document. This processing instruction has the form 

Some elements do not have or require content and act as placeholders that indicate where a certain process is to take place. A special form of tag is used in XML to indicate empty elements that do not have any contents and therefore have no end tag. For example a element is typically an empty element that acts as a placeholder for an image embedded in a line of text and would have the following declaration within a DTD 

Where elements can have variable forms or need to be linked together they can be given suitable attributes to specify the properties to be applied to them. These attributes are specified in a list. For example it might be decided that the element could include a Location and Size attributes. A suitable attribute list declaration for such an attribute would be as follows 

This tells the computer that the element includes a required Location entity and may include a Size attribute. The keyword IMPLIED indicates that it is permissible to omit the attribute in some instances of the element.

XML also permits custom definition statements similar to the DEFINE statements used with some compilers. Commonly used definitions can be declared within the DTD as entities. A typical entity definition could take the form 

which defines a file location for the binary document BinDoc3487. Once such a declaration has been made in the DTD users can use a reference in place of the full value. For example the element described previously could be specified as . An advantage of using this technique is that should the defined value change at a later time only the entity declaration in the DTD will need to be updated as the entity reference will automatically use the contents of the current declaration.

Within the storage manager each document part is identified by a Uniform Resource Identifier URI which conforms to a standard format such as specified in RFC . URIs can be absolute or relative but relative URIs must be used only within the context of a base absolute URI. When the document is stored in persistent storage its parts may be identified by a different STORAGEURI that is assigned and managed by the particular file system in use.

In accordance with the principles of the invention within each document part in the storage manager internal memory is represented by a collection of objects. For example separate elements in the XML document are represented as element objects in the storage manager. This results in a structure that is illustrated in . In an illustrative XML document is represented as a collection of objects in storage manager . In particular the XML document contains the conventional XML processing statement which identifies the XML version encoding and file references as discussed above. Document also contains an XML processing statement which identifies a schema document in storage manager which is associated with the document . The illustrative XML document also contains a set of hierarchical elements including ElementA which contains some text ElementA contains ElementB which has no text associated with it. ElementB also contains ElementC which in turn contains two elements. Specifically ElementC contains ElementD that has an attribute ID with a value foo and ElementE .

In the storage manager the elements ElementA ElementE are represented as element objects arranged in a hierarchy. In particular ElementA is represented by ElementA object . Each element object contains the text and attributes included in the corresponding XML element. Therefore element object contains the text . Similarly ElementB is represented by element object and elements ElementC ElementD and ElementE are represented by objects and respectively. Element object which represents element ElementD also includes the attribute ID that is included in the corresponding element. Each element object references its child element objects by means of database pointers indicated by arrows between the objects into order to arrange the element objects into a hierarchy. There may also be attribute indices such as index that indexes the ID attribute in element object .

The representation of the XML document by means of an object collection allows the storage manager to manipulate its internal representation of the document with a consistent interface that is discussed in detail below. The storage manager can also provide features that are not available in conventional XML documents such as collection services that are available via a collection manager that is also discussed in detail below.

As described above Groove documents that contain XML data may have a definition or schema document that describes the pattern of elements and attributes in the body of the document. The schema document is stored in a distinct XML document identified by a URI. The schema document has a standard XML DTD definition called the meta schema which is shown below 

Each of the elements in the schema defines information used by the storage manager while processing the document. The Registry section forms an XML representation of a two column table that maps XML element tags to Windows ProgIDs. In the Common Object Model COM developed by Microsoft Corporation a ProgID is a text name for an object that in the COM system is bound to or associated with a section of program code. The mapping between a given ProgID and the program code which is stored in a library is specified in a definition area such as the Windows registry. 

This arrangement is shown in that illustrates an XML document and its related schema document . Both of these documents are resident in the storage manager and would actually be represented by objects as shown in . However in the documents have been represented in conventional XML format for clarity. shows the storage manager operational in a Windows environment that uses objects constructed in accordance with the Common Object Model COM developed by the Microsoft Corporation Redmond Wash. however the same principles apply in other operating system environments.

XML document includes the normal XML processing statement that identifies the XML version encoding and file references. A schema XML processing statement references the schema document which schema document is associated with document and has the name urn groove.net sample.xml defined by name statement . It also includes a root element which defines a name doc.xml and the g XML namespace which is defined as urn groove.net 

Document has three other elements including element defined by tag urn groove.net AAA element defined by tag urn groove.net BBB and element defined by tag urn groove.net NoCode . Element is a simple element that has no corresponding bound code and no corresponding tag to ProgID mapping in the schema document .

Within the registry section defined by tag the schema document has two element to COM ProgID mappings defined. One mapping is defined for elements with the tag urn groove.net AAA and one for elements with the tag urn groove.net BBB. The bound code is accessed when the client application invokes a method OpenBoundCode . The syntax for this invocation is given in Table 15 below and the steps involved are illustrated in . Invoking the OpenBoundCode method on a simple element such as element generates an exception. The process of retrieving the bound code starts in step and proceeds to step in which the OpenBoundCode is invoked. Invoking the OpenBoundCode method on an element with the element tag urn groove.net AAA causes the storage manager to consult the registry element in the schema document with the element tag as set forth in step . From section the storage manager retrieves the ProgID Groove.Command as indicated in step . In step the storage manager calls the COM manager in instructs it to create an object with this ProgID. In a conventional well known manner in step the COM manager translates the ProgID to a CSLID using a key in the Windows Registry . In step the COM manager uses the CSLID to find a dynamically loadable library DLL file in the code database that has the code for the object. Finally in step the COM manager creates the object and returns an interface pointer for the object to the storage manager which in turn returns the pointer to the client application . The routine then finishes in step . The client application can then use the pointer to invoke methods in the code that use attributes and content in the associated element. The element then behaves like any other COM object. A similar process occurs if the OpenBoundCode method is invoked on elements with the tag urn groove.net BBB. 

The AttrGroup section defines non XML characteristics for attributes. An attribute s data type can be defined as some type other than text and the attribute may be indexed to facilitate fast retrieval of the elements that containing it.

The ElementDecl section provides a form of element definition similar to the DTD declaration but allows for extended attribute characteristics and the definition of non containment element references.

The following example shows the sample portions of a schema document for an XML document that defines a telespace that is previously described.

In this example there are two entries in the Tag to ProgID mapping table. The first maps the tag g Command which using XML namespace expansion is urn groove.net.schema.1 Command to the ProgID Groove.Command. In the section defining attributes the ID attribute is indexed the data type of the NKey attribute is binary and so on.

This schema data is represented by element objects and can be accessed and manipulated by the same storage manager element and attribute interface methods used to manipulate documents as described in detail below. In particular the information that describes a document can be manipulated using the same interfaces that are used for manipulating the document content.

In accordance with another aspect of the invention sub documents can be associated with a primary document. Any document may be a sub document of a given document. If a document contains a sub document reference to another document then the referenced document is a sub document. If two documents contain sub document references to each other then each document is a sub document of the other document. Each sub document is referenced from the primary document with conventional XML XLink language which is described in detail at website www.w3.org TR xlink. Links may also establish a relationship between an all text XML document and a binary sub document. Binary documents do not have links to any kind of sub document. If the link is to a document fragment a subdocument relationship is established with the document that contains the fragment. The relationship of documents and sub documents is illustrated in .

For example main document contains links which include a link represented by arrow to document and a link represented by arrow to a binary document . Documents and are thus sub documents of document . Document in turn contains links which include a link represented by arrow to document with content . Document is a sub document of document . Document contains binary content and therefore cannot have links to sub documents.

Sub document links follow the standard definition for simple links. An exemplary element definition of a link is as follows 

It is also possible to establish a sub document relationship without using the above definition by adding to a document an XML link which has an xml link attribute with a value simple and a href attribute. Such a link will establish a sub document relationship to the document identified by a URI value in the href attribute.

Given the relationships from a document to its sub documents it is possible to make a copy of an arbitrary set of documents and sub documents. Within a single storage service it may be possible to directly perform such a copy. To cross storage services or to send multiple documents to another machine the entire hierarchy of such documents must be describable in a serialized fashion. The inventive Storage Manager serializes multiple documents to a text representation conforming to the specification of MIME Encapsulation of Aggregate documents such as HTML MHTML which is described in detail at website ftp.isi.edu in notes rfc2557.txt.

The following data stream fragment is an example of a document and a referenced sub document as they would appear in an MHTML character stream. In the example SP means one space is present and CRLF represents a carriage return line feed ASCII character pair. All other characters are transmitted literally. The MIME version header has the normal MIME version and the Groove protocol version is in a RFC822 comment. The comment is just the word Groove followed by an integer. The boundary separator string is unique so a system that parsed the MIME and then each body part will work correctly. The serialized XML text is illustrated in UTF 8 format but it could also be transmitted in WBXML format. The XML document has a XML prefix which includes the version and character encoding. The binary document is encoded in base64.

Unlike most XML processors such as document editors or Internet browsers the storage manager provides for concurrent document operations. Documents may be concurrently searched elements may be concurrently created deleted updated or moved. Copies of element hierarchies may be moved from one document to another. In most XML processors all of the updates to a document are driven by a single user who is usually controlling a single thread within a single process on a single computer.

The storage manager maintains XML document integrity among many users updating the same document using multiple threads in multiple processes. In a preferred embodiment all of the updates occur on a single computer but using other different conventional inter processor communication mechanisms other operational embodiments are possible. shows the basic structure of the storage manager and illustrates how it isolates application programs from cross process communication issues. For example two separate processes and may be operating concurrently in the same computer or in different computers. Process is a home process as described below while process is another process designated as Process N. Within process a multi threaded client application program is operating and within process a multi threaded client application program is operating.

Each application program and interfaces with a storage manager designated as and respectively. In process the storage manager comprises a storage manager interface layer which is used by application program to control and interface with the storage manager. It comprises the database document element and schema objects that are actually manipulated by the application. The API exported by this layer is discussed in detail below. The storage manager also includes distributed virtual object DVO database methods DVO methods for fundamental data types DVO common system methods and distributed shared memory . Similarly the storage manager operating in process includes transaction layer DVO database methods DVO methods for fundamental data types DVO common system methods and distributed shared memory .

The two processes and communicate via a conventional message passing protocol or inter process communication IPC system . For processes that run in a single computer such a system can be implemented in the Windows operating system by means of shared memory buffers. If the processes are running in separate computers another message passing protocol such as TCP IP can be used. Other conventional messaging or communications systems can also be used without modifying the operation of the invention. However as is shown in application programs and do not directly interact with the message passing system . Instead the application programs and interact with storage managers and respectively and storage managers and interact with the message passing system via a distributed shared memory DSM system of which DSM systems and are a part.

A number of well known DSM systems exist and are suitable for use with the invention. In accordance with a preferred embodiment the DSM system used with the storage manager is called a C Region Library CRL system. The CRL system is an all software distributed shared memory system intended for use on message passing multi computers and distributed systems. A CRL system and code for implementing such as system is described in detail in an article entitled CRL High Performance All Software Distributed Memory System K. L. Johnson M. F. Kaashoek and D. A. Wallach ACM December 1995 and CRL version 1.0 User Documentation K. L. Johnson J. Adler and S. K. Gupta MIT Laboratory for Computer Science Cambridge Mass. 02139 August 1995. Both articles are available at web address www.pdos.lcs.mit.edu crl.

Parallel applications built on top of the CRL such as the storage manager share data through memory regions. Each region is an arbitrarily sized contiguous area of memory. Regions of shared memory are created mapped in other processes unmapped and destroyed by various functions of the DSM system. The DSM system used in the present invention provides a super set of the functions that are used in the CRL DSM system. Users of memory regions synchronize their access by declaring to the DSM when they need to read from or write to a region and then after using a region declaring the read or write complete. The effects of write operations are not propagated to other processes sharing the region until those processes declare their need for it. In addition to the basic shared memory and synchronization operations DSM provides error handling and reliability with transactions. The full interface to inventive DSM is shown in Table 1.

Each storage manager and comprises a DSM node that uses one or more DSM regions not shown in located in the address space of the corresponding process . These regions contain DVO objects and classes that can be used to represent documents elements and schema of the XML data that is managed by the storage manager. Portions of documents usually elements and index sections are wholly contained within a region. Although the DSM system provides a conceptually uniform node space for sharing regions there are issues that result in the need to single out a specific node or process to perform special tasks.

Consequently within the DSM synchronization protocol a single node is identified as a home node for each region. Within the many processes running the storage manager on a single computer one process called the home process is the process that performs all disk I O operations. To reduce the amount of data movement between processes the home process is the home node for all regions. Other implementations are possible in which any node may be the home for any region and any process may perform disk I O. However for personal computers with a single disk drive allowing multiple processes to perform disk I O introduces the need for I O synchronization while not alleviating the main performance bottleneck which is the single disk.

In accordance with the DSM operation if a process has the most recent copy of a region then it can read and write into the region. Otherwise the process must request the most recent copy from the home process before it can read and write in the region. Each DSM system interfaces with the message passing system via an interface layer called an internode communication layer which isolates the DVM system from the underlying transport mechanism. It contains methods that send messages to a broadcast group and manipulate addresses for the corresponding process and the home process.

The inventive storage manager uses shared objects as the basis for XML objects. Many systems exist for sharing objects across processes and computers. One such object sharing model is based on the use of the shared memory facilities provided by an operating system. One of the biggest drawbacks of such a shared memory model is unreliability due to memory write failures that impact the integrity of other processes. For example if one process is in the process of updating the state of an object and the process fails before setting the object to a known good state other processes will either see the object in an invalid state or may blocked indefinitely waiting for the failed process to release its synchronization locks. The shared memory model also suffers from the locality constraints of shared memory in a tightly coupled multi computer it provides no way to share objects over a network.

Another model that provides distributed object sharing and remote method invocation is the basis for the distributed object management facilities in Java or the Object Management Group s CORBA system. Although providing the ability to share objects over a computer network clients of such systems need to be aware of whether an object is local or remote objects are not location independent. Performance is another drawback of this approach. All operations on an object need to be transmitted to the object server since the server contains the only copy of the object state and serves as the synchronization point for that data.

In order to overcome these drawbacks the inventive storage manager uses a distributed virtual object DVO system to provide the primitive data types that XML object types are built upon. The DVO system also provides its callers with the illusion that all data is reliably contained in one process on a single computer node even though the data may be in multiple processes on many computers or may truly be just in one process on a single computer node.

The DVO object sharing model is shown in . All processes on all computers that are sharing an object have the same method code. For example process and process in have copies of the same object. Thus each of processes and has a copy of the same method code and in the respective process address space. The volatile data state for an object is stored in DSM regions. Thus the object data for the object copy in process is stored in region in the address space of process . Similarly the object data for the object copy in process is stored in region in the address space of process . Object methods synchronize their access to the object s data by using the DSM synchronization functions that synchronize the regions as illustrated by arrow . In this manner DVO objects are location independent failures are contained within a single process and multiple changes to a local object do not require data movement across the inter node transport.

The DVO system provides basic objects that may be used as building blocks to manage XML documents for the storage manager and is divided into three functional pieces. The DVO database contains objects that handle the DVO local context in each process and the shared tables that contain information about open databases and documents contained within those databases. In DVO databases are conceptual storage containers and may channel objects that are ultimately stored in any kind of storage service . DVO documents are associated with XML or binary documents which are visible to a client of the storage manager. DVO documents are also used to contain the indices and metadata associated with a collection.

DVO types is a set of object classes that can be used within DVO documents to implement higher level data model constructs. DVO types range from simple data containment objects through complex scalable index structures. Each DVO type is implemented with two classes one is a non shared class that uses memory pointers in object references and the other is a shared class that uses logical addresses called database pointers for object references. The shared class has two sub forms one is the representation of the object in a shared DSM region and the other is the representation of the object stored on disk in an object store database. The DVO system provides methods to transfer objects between their shared and non shared implementations.

The DVO system objects isolate the upper levels of DVO from physical storage and process locality issues. The DVO system objects use DSM for invoking and handling requests to and from the home process. Requests include operations such as opening closing and deleting a database finding documents in a database and opening closing deleting and writing database documents. The DVO system in the master process can also retrieve DVO objects from a storage service . A storage service such as service is a utility program that stores and retrieves information from a persistent medium and is responsible for the physical integrity of a container database or file. It ensures that all updates are durable and that all internal data structures e.g. redirection tables space allocation maps are always consistent on disk. Other processes such as process cannot access the storage service directly but can access the system indirectly via its DSM regions .

The storage manager can operate with different types of physical storage systems including container or object stores stream file systems and ZIP files. In order to achieve atomic commits the object store storage service can be implemented using page oriented input output operations and a ping pong shadow page table.

Individual storage manager methods are atomic. Multiple storage manager operations even operations on different documents may be grouped into transactions. Transactions not only protect XML data integrity but they also improve performance because they enable the storage manager to reduce the number of region lock operations and reduce the amount of data movement over the message passing system.

The storage manager supports both read write and read only transactions built on DSM synchronization primitives described in the DSM documentation referenced above which primitives insure consistency in multiple processes or computers. Read write transactions provide for the atomicity and consistency of a set of database read and write operations. Each region that is changed as part of a transaction will be kept in a locked state until the transaction is committed or aborted. This prevents operations that are not part of the transaction from seeing the changes. Further each transaction stores a before image of the regions it modifies so that if the transaction is aborted as a result of an explicit API call or an exception the effects of the transaction can be undone. Depending on the performance requirements an alternative implementation would write undo information rather than storing the full before image. A read only transaction uses the same interface as a read write transaction. A read only transaction ensures that multiple read operations are consistent. Like other transactions it uses DSM functions to keep all read regions in a read state until it is finished.

In addition checkpoints can be used to ensure that changes are persistent and provide durability for storage manager operations. A checkpoint may be performed at any time. Checkpoints are used in conjunction with data recovery logging. All operations write redo information to a sequential recovery log file when they are committed. When the checkpoint is committed the recovery log file will be flushed to persistent storage and will ensure that the operations can be recovered. Since transactions do not write redo information until they are committed if a checkpoint operation is commenced in the middle of a transaction the transaction operations will not be flushed.

Transactions are scoped to a thread and a database. Once a transaction is started on a thread for a particular database that transaction will be automatically used for all subsequent storage manager operations on that database and thread. An extension of conventional operating system threads is used so that transactions correctly handle calls that need to be marshaled to other threads for example a user interface thread using the Groove system s simple marshaler. Storage manager calls made on a thread and database that doesn t have a transaction started will cause the storage manager to create a default transaction that will be committed just before the call ends. Alternatively starting a new transaction on a thread and database that already has an existing transaction in progress will cause the new transaction to automatically nest in the existing transaction. Nested transactions provide the ability to roll back the system within the outer transaction. In particular inner nested transactions are not finally committed until the outermost transaction is committed. For example if a nested transaction is committed but the containing transaction is later aborted the nested transaction will be aborted.

In a preferred embodiment of the invention the storage manager is implemented in an object oriented environment. Accordingly both the storage manager itself and all of the document components such as documents elements entities etc. are implemented as objects. These objects their interface the underlying structure and the API used to interface with the storage manager are illustrated in . The API is described in more detail in connection with . Referring to the storage manager provides shared access to documents via the document manipulation API but in order to enable a full programming model for client applications additional communication and synchronization operations are provided within the context of a document. For example the storage manager provides queued element operations which enable one process to send an element to another process via the Queue API . Elements can be sent by value a copy of the whole element or by reference to the element. Synchronization operations are also provided to allow one or more threads to wait for an element to be enqueued to a given queue. The storage manager also provides RPC style element communication and synchronization via the RPC API .

Other client components may need to be aware of when documents are created in or deleted from storage manager. Accordingly the storage manager provides an interface to an interest based notification system for those client components via notification API . The notification system provides notifications to client components that have registered an interest when a document is created or deleted.

Document data is represented by a collection of objects including database objects document objects element objects and schema objects . The objects can be directly manipulated by means of the document manipulation API .

The document related objects are actually implemented by the distributed virtual object system that was discussed in detail above. The distributed virtual object system can also be manipulated by element queue and RPC objects under control of the queue and RPC API .

The distributed virtual object system communicates with the distributed shared memory via interface and communicates with the logging operations via interface . Similarly the distributed virtual object system can interact with the storage services via interface .

The following is a description of the interfaces for each of the objects used to implement a preferred embodiment of the inventive storage manager. These object are designed in accordance with the Common Object Model COM promulgated by Microsoft Corporation Redmond Wash. and can be manipulated in memory as COM objects. However COM is just one object model and one set of interface methodologies. The invention could also be implemented using other styles of interface and object models including but not limited to the Java and CORBA object models.

Another interface IGrooveStorageURISyntax is used by a client of a storage manager that needs to perform operations on parts of standard names which are in the form of Uniform Resource Identifiers URIs . Table 4 includes the methods for the IGrooveStorageURISyntax interface.

Another interface IGrooveRPCServerCallback is used by a client of a storage manager that needs to handle remote procedure calls RPCs on elements within XML documents. RPC server callbacks are a sub class of the util base class described below that is all of the methods of IGrooveElementUtilBase also apply to IGrooveRPCServerCallback. Table 6 defines the methods used in the storage manager RPC server callback interface.

Table 8 illustrates the methods for an interface IGrooveCrossProcessSemaphore for a client of a storage manager that needs to synchronize access among processes.

Table 9 illustrates an interface IGrooveTransaction for a client of a storage manager that needs to group operations within a database. Transactions are a sub class of cross process semaphores that is all of the methods for IGrooveCrossProcessSemaphore also apply to IGrooveTransaction. The storage manager transaction interface includes the following methods 

Table 11 illustrates an interface IGrooveXMLDocument for a client of a storage manager that needs to manage XML documents within a database. XML documents are a sub class of documents that is all of the methods for IGrooveDocument also apply to IGrooveXMLDocument. The storage manager XML document interface includes the following methods 

Table 12 illustrates the methods for an interface IGrooveBinaryDocument for a client of a storage manager that needs to manage binary documents within a database. Binary documents are a sub class of documents that is all of the methods for IGrooveDocument also apply to IGrooveBinaryDocument.

Table 13 illustrates an interface IGrooveLocator for a client of a storage manager that needs to search for elements using locator queries as defined in a specification called XSLT. Details of the XSLT specification can be found at web address www.w3.org TR xslt. The storage manager locator interface includes the following methods 

Table 14 illustrates an interface IGrooveTransform for a client of a storage manager that needs to perform XML document transformations as defined in XSLT. The storage manager transform interface includes the following methods 

Table 15 illustrates an interface IGrooveElement which allows a client of a storage manager to manipulate elements within XML documents. The storage manager element interface includes the following methods 

Table 16 illustrates the methods for an interface IGrooveReadOnlyElement for a client of a storage manager that needs to manipulate read only elements within XML documents. Read only elements are a sub class of elements that is all of the methods for IGrooveElement also apply to IGrooveReadOnlyElement.

Table 17 illustrates an interface IGrooveElementReference for a client of a storage manager that needs to manipulate element references within XML documents. The storage manager element reference interface includes the following methods 

An interface IGrooveElementUtilBase for use within the storage manager s other interfaces is shown in Table 18. The IGrooveElementUtilBase is not an interface for commonly used objects but is intended to serve as the base class for other sub classes shown in that do have commonly used objects. All of the util interfaces are associated with an element. The storage manager element util base interface includes the following methods 

Table 19 illustrates an interface IGrooveBoundCode for a client of a storage manager that needs to handle executable code associated with elements within XML documents. The storage manager bound code interface includes the following methods 

Table 21 illustrates an interface IGrooveElementReferenceQueue for a client of a storage manager that needs to manipulate queues on element references within XML documents. Element reference queues are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveElementReferenceQueue. The storage manager element reference queue interface includes the following methods 

Table 22 illustrates an interface IGrooveMultiReaderElementQueueReader for a client of a storage manager that needs to remove elements from multi reader queues on elements within XML documents. Multi reader element queues are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveMultiReaderElementQueueReader. The storage manager multi reader element queue reader interface includes the following methods 

Table 23 illustrates an interface IGrooveMultiReaderElementQueueWriter for a client of a storage manager that needs to add elements to multi reader queues on elements within XML documents. Multi reader element queues are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveMultiReaderElementQueueWriter. The storage manager multi reader element queue writer interface includes the following methods 

Table 24 illustrates an interface IGrooveMultiReaderElementReferenceQueueWriter for a client of a storage manager that needs to add element references to multi reader queues on elements within XML documents. Multi reader element reference queues are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveMultiReaderElementReferenceQueueWriter. The storage manager multi reader element reference queue writer interface includes the following methods 

Table 25 illustrates an interface IGrooveMultiReaderElementReferenceQueueReader for a client of a storage manager that needs to remove element references from multi reader queues on elements within XML documents. Multi reader element reference queues are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveMultiReaderElementReferenceQueueReader. The storage manager multi reader element reference queue reader interface includes the following methods 

Table 26 illustrates an interface IGrooveRPCClient for a client of a storage manager that needs to perform remote procedure calls RPCS on elements within XML documents. RPC clients are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveRPCClient. The storage manager RPC client interface includes the following methods 

An interface IGrooveRPCServerThread for a client of a storage manager that needs to handle remote procedure calls RPCs on elements within XML documents is shown in Table 27. RPC server threads are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveRPCServerThread. The storage manager RPC server callback interface has no methods of its own only those inherited from IGrooveElementUtilBase. It is provided as a distinct interface for type checking.

Table 28 illustrates an interface IGrooveRPCServer for a client of a storage manager that needs to handle remote procedure calls RPCs on elements within XML documents. RPC servers are a sub class of the util base class that is all of the methods for IGrooveElementUtilBase also apply to IGrooveRPCServer. The storage manager RPC server interface includes the following methods 

The following tables illustrate allowed values for the enumerated data types listed in the above interfaces. In particular Table 29 illustrates allowed values for the GrooveSerializeType enumerated data type.

The fundamental data model of the storage manager is XML. XML is a semi structured hierarchical hyper linked data model. Many real world problems are not well represented with such complex structures and are better represented in tabular form. For example spreadsheets and relational databases provide simple tabular interfaces. In accordance with one aspect of the invention in order to simplify the representation XML structures are mapped to a tabular display generally called a waffle . The waffle represents a collection of data. This mapping is performed by the collection manager a component of the storage manager.

Collections are defined by a collection descriptor which is an XML document type description. Like a document schema the collection descriptor is a special kind of document that is stored apart from the collection data itself. There are many sources of collection data but the primary source of collection data is a software routine called a record set engine. Driven by user commands the record set engine propagates a set of updates for a collection to the collection manager. Based on those updates the collection manager updates index structures and may notify waffle users via the notification system. When a waffle user needs updated or new collection data the waffle user will call the collection manager to return a new result array containing the updated data. The waffle user may also navigate within the collection using cursors.

Every Collection has a name that is used to reference the collection. The Start attribute specifies how to find the root of the collection. A collection with a record root is just a set of records whereas a collection that starts with an index is navigated through the index and then the set of records. An index may be a concordance or full text. The optional Location attribute is a relative URL that identifies where in the root to actually begin.

A Level defines the contents of part of the output hierarchy. A level consists of the columns in the level the ordering or grouping of records in the level and definitions of sub levels. A level is associated with records in the source record stream through the Mapping attribute. If the mapping is Direct a level represents a single source record type. If the mapping is Flatten the level contains a source record type and all descendants of that record. The Flatten mapping may only be specified on the only or lowest level in the collection. The Links attribute specifies how records with link attributes should handled. If links are Traversed the record will be output as a distinct level. If links are Embedded the child record of the source record will appear as though it is part of the source record.

A Column defines the mapping between a source field and the output array column. The Source attribute is a XSLT path expression in the source records. The Result attribute is a name of the field in the result array. The MultiValue and MultiValueSeparator attributes define how multi valued source values are returned in the result.

Every collection must have at least one defined order. The order can be sorted collation or multi level grouping with aggregate functions.

The SortColumn element defines the collation characteristics within a SortDescription. The Source attribute defines the name of the output column to be sorted. The Order must be either Ascending or Descending. The Strength and Decomposition values are input parameters that have the same meaning as defined in Unicode.

The two kinds of grouping are by unique values and by units. When a collection is grouped by unique values all records with the same GroupColumn values will be together in the same group breaks between groups will occur at the change of GroupColumn values. When a collection is grouped by units all records with the same GroupColumn values resolved to the value of GroupUnits will be together in the same group. For example if GroupUnits is Days all records for a given day will be in the same group. If AtGroupBreak is specified a synthetic row will be returned that contains the result of the aggregate function at each value or unit break value.

The Interval identifies the two fields in each record that define a range. The datatypes of the Start and End columns must be either numeric or datetime.

The following example shows a collection descriptor document for a simple document discussion record view with six collation orders 

The following example shows a collection descriptor for a calendar view. Note the similarity to the prior example but with a small change to the sort description the collection is ordered by ranges of date intervals.

As is the basic storage manager the collection manager is implemented in an object oriented environment. Accordingly both the collection manager itself and all of the collection components including collections waffles cursors result arrays and the record set engine are implemented as objects. These objects their interface the underlying structure and the API used to interface with the collection manager are illustrated in . The API is described in more detail in connection with . Referring to the collection manager provides shared access to collections via the collection manipulation API but in order to enable a full programming model for client applications additional communication and synchronization operations are provided within the context of a collection. For example a user can control a record set engine by means of the engine API . Under control of commands in the engine API the record set engine propagates a set of updates for a collection to the distributed virtual object system that is discussed above. Based on those updates the distributed virtual object system updates index and other structures.

Other client components may need to be aware of changes within components such as waffles managed by the collection manager. Accordingly the collection manager provides an interface to an interest based notification system for those client components. The notification system provides notifications to client component listeners who have registered an interest when values within objects that represent a collection change.

Collection data is represented by a set of objects including collection objects record objects waffle objects cursor objects and result array objects . The objects can be directly manipulated by means of the collection manipulation API . The collection related objects are actually implemented by the distributed virtual object system that was discussed in detail above.

Table 37 illustrates an interface IGrooveCollectionManager for a collection manager that encapsulates the basic framework for the major operations performed on a collection. The collection manager interface includes the following methods 

Table 38 illustrates an interface IGrooveCollection for a collection that encapsulates the basic framework for the major operations performed on a collection. The collection interface includes the following methods 

Table 39 illustrates an interface IGrooveCollectionListener for a client of a collection manager that wishes to be notified whenever significant events happen within the collection. Significant events may occur at any time and include updating addition deletion reparenting or a change in ordinal position of a collection element. The collection manager listener interface includes the following methods 

Table 40 illustrates an interface IGrooveCollectionCursor for a client of a collection manager that wants to move a cursor within the collection. A collection may have one or more cursors active at any time. The collection manager cursor interface includes the following methods 

The following tables illustrate allowed values for the enumerated data types listed in the above interfaces. In particular Table 41 illustrates allowed values for the GrooveCollationOrder enumerated data type 

A software implementation of the above described embodiment may comprise a series of computer instructions either fixed on a tangible medium such as a computer readable media e.g. a diskette a CD ROM a ROM memory or a fixed disk or transmissible to a computer system via a modem or other interface device over a medium. The medium can be either a tangible medium including but not limited to optical or analog communications lines or may be implemented with wireless techniques including but not limited to microwave infrared or other transmission techniques. It may also be the Internet. The series of computer instructions embodies all or part of the functionality previously described herein with respect to the invention. Those skilled in the art will appreciate that such computer instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further such instructions may be stored using any memory technology present or future including but not limited to semiconductor magnetic optical or other memory devices or transmitted using any communications technology present or future including but not limited to optical infrared microwave or other transmission technologies. It is contemplated that such a computer program product may be distributed as a removable media with accompanying printed or electronic documentation e.g. shrink wrapped software pre loaded with a computer system e.g. on system ROM or fixed disk or distributed from a server or electronic bulletin board over a network e.g. the Internet or World Wide Web.

Although an exemplary embodiment of the invention has been disclosed it will be apparent to those skilled in the art that various changes and modifications can be made which will achieve some of the advantages of the invention without departing from the spirit and scope of the invention. For example it will be obvious to those reasonably skilled in the art that although the description was directed to a particular hardware system and operating system other hardware and operating system software could be used in the same manner as that described. Other aspects such as the specific instructions utilized to achieve a particular function as well as other modifications to the inventive concept are intended to be covered by the appended claims.

