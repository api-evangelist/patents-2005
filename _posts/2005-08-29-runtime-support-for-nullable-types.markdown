---

title: Runtime support for nullable types
abstract: The subject disclosure pertains to systems and methods for supporting null capabilities for general purpose programming languages. Low level, runtime support for a nullable type is provided to ensure consistency and coherency. An execution component restricts support of the nullable type to programming language types that lack a null capability. The execution component may also provide support for conversion between the nullable type and a reference type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07627594&OS=07627594&RS=07627594
owner: Microsoft Corporation
number: 07627594
owner_city: Redmond
owner_country: US
publication_date: 20050829
---
This application is related to co pending U.S. application Ser. No. 10 935 247 entitled GENERAL PROGRAMMING LANGUAGE SUPPORT FOR NULLABLE TYPES filed on Sep. 7 2004. The entirety of the aforementioned application is incorporated herein by reference.

As programming approaches and foundations have evolved application programming interfaces APIs and programming schemas have been developed to standardize and unify programming methodologies that were previously multi variant and relatively incompatible. Modem programming therefore often involves employing APIs and schemas in conjunction with reusable libraries. Unfortunately this evolution has inadvertently created many inefficient programming artifacts that are actually spread and perpetuated by these standardizations programming constructs. For example one resulting software programming artifact is a duality between reference types and value types.

Reference types are variables that are stored on a heap and referenced by a pointer stored on the stack. Value types are variables that are stored directly on the stack. Consequently variables that are represented as reference types can be uninitialized termed null but variables that are represented as value types cannot be established in an uninitialized condition without risking indeterminate or even catastrophic results. This nullification issue can present problems in a myriad of situations including data base accessing.

Support for nullability across all types including value types is essential when interacting with null supported languages such as database languages e.g. SQL . A database language may use a null value to indicate that the actual data value is unknown or missing. By providing null support within a general purpose programming language null supported languages and programming languages may be integrated e.g. code in the C programming language may read write or interpret nullable fields in a database language .

General purpose programming languages have historically provided little or no null support. Many approaches exist for handling nulls and value types without direct language support but all have shortcomings. For example one approach is to use a special value such as 1 for integers to indicate null but this only works when an unused value can be identified. Another approach is to maintain Boolean null indicators in separate fields or variables but this does not work well for parameters and return values. A third approach is to use a set of user defined nullable types but this only works for a closed set of types.

Certain general purpose programming languages supply a nullable type e.g. C 2.0 to provide for nullability across all types including value types. A nullable type may be implemented using a multi element structure containing a Boolean null indicator and an element which contains the value of the instance of the nullable type when the instance of the nullable type does not represent null. Although the nullable type provides a method for setting a value type to null the structure used to implement the nullable type is itself an instance of a value type. Use of a structure that is inherently an instance of a value type to represent an instance of a reference type leads to inconsistent and counterintuitive results under certain circumstances.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

Briefly described the provided subject matter concerns null support for general purpose programming language types. Typically support is provided using a nullable type including an underlying value and an indicator value. The indicator value indicates whether the value of the instance of the nullable type represents a null. In one aspect of the subject matter disclosed herein low level runtime support for the nullable type is provided. This low level support increases coherency.

The disclosed subject matter provides for the conversion between the nullable type which is a value type and reference type. An instance of the nullable type is unwrapped to allow access to the elements of the instance of the nullable type. The elements the underlying value and the indicator value are used to create an instance of a reference type.

Support of nullable at the runtime level eliminates seeming inconsistencies. Elimination of these inconsistencies increases programming language predictability and usability for software developers. In addition the provision of support for the nullable type at a low level allows for use of the nullable type in multiple programming language environments.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.

The various aspects of the subject matter are now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

As used in this application the terms component and system are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs. In addition while the examples provided utilize the C programming language numerous alternative programming languages may be used e.g. C C C Pascal Python Ruby Visual Basic Java and so forth .

As used herein the terms to infer or inference refer generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources.

Referring initially to a system provides a nullable type support for programming languages in accordance with an aspect of the claimed subject matter. The system includes one or more data structures that can be declared in the context of a programming language such as C C C Pascal Python Ruby Visual Basic Java and so forth. The data structures generally consist of an underlying type such as an integer float Boolean and so forth that can be declared to be a nullable type by associating a type modifier with the underlying type. For instance a symbol such as can be employed as a type modifier to indicate to a compiler component that the underlying type is to be considered a nullable type. It is to be appreciated that various other symbols can be employed as the type modifier. Alternatively an underlying type may be declared a nullable type by associating the word nullable with the underlying type e.g. Nullable . The expressions T and nullable where T is a programming language type may be used interchangeably herein. Upon declaration and compilation implementation code e.g. executable intermediate language . . . can be generated via the compiler component including nullable and non nullable types if desired by the software developer.

Referring now to an instance of a nullable type may be set to any value available for the underlying type and the null value. A nullable type may include an underlying value containing the value of the underlying type and an indicator value . The indicator value signals when the value of the instance of the nullable type is null. An instance of the nullable type may be implemented by automatically creating a multi element structure including an element for the underlying value and a Boolean element for the indicator value representing whether or not the underlying value is null e.g. flag indicating null or non null value for the underlying type . If the Boolean element is declared false for example the underlying type is considered null whereas if the Boolean element is true for example the value contained in the underlying value is considered the value of the instance of the nullable type.

Generally nullable types are constructed using the type modifier or other symbol . For example int is a nullable form of the predefined type int. A nullable type s underlying type should be a non nullable value type. Consider the following exemplary declaration of the nullable type 

The exemplary nullable type also includes a public constructor that takes a single argument of type T. The constructor initializes an instance of a nullable type. For a non null instance of T the value property is set to the value of T and the hasValue property is set to true. The constructor for the nullable type should not permit nesting of nullable types. The value property should not be set to null.

In general a non nullable value type may be implicitly converted to a nullable form of that value type. Furthermore an implicit conversion can exist from the null literal to any nullable type. For example 

The type specified before the modifier or within the for a nullable type is referred to as the underlying type of the nullable type. The underlying type of a nullable type can be any non nullable value type. Typically the underlying value cannot be a reference type or a nullable type. For example int and double are valid nullable types but string and int are generally not. A nullable type can represent all values of its underlying type plus an additional null value. The syntax T is shorthand for System.Nullable and the two forms can be used interchangeably.

The term wrapping as used herein denotes the process of packaging a value of type T in an instance of a type of the form nullable. Conceptually a value x of type T is wrapped to type T by evaluating the expression new T x . The term unwrapping denotes the process of obtaining the value of type T contained in an instance of a type of the form nullable. Conceptually a value x of type T is unwrapped to type T by evaluating the expression x.value. Attempting to unwrap a null instance may cause an exception to be thrown.

Certain programming languages provide a bridge or method for conversion between value types and reference types. For example C provides the boxing and unboxing instructions to convert between value types and reference types. A boxing conversion allows any value type to be implicitly converted to a reference type. Boxing an instance of a value type converts the value type instance to an instance of the object class type the object class type is the ultimate base class of all other types in C . Although the following examples are presented using C any subject matter disclosed is not limited to the C programming language. Consider the following C code 

Unfortunately boxing and unboxing of nullable type variables may cause inconsistencies. Although the nullable type provides a null value the nullable type is in fact a value type variable. As illustrated above the nullable type may be implemented as a multi element structure. Therefore when the nullable type nullable is boxed the resulting reference type is not a null reference. Because the compiler treats the nullable as a structure boxing the nullable structure results in a non null reference to the boxed nullable. This causes inconsistencies when the nullable contains a null value. Consider the following exemplary C code 

As illustrated in the example above for a value x of a type T the chain of implicit conversions from type T to type nullable to type object results in a different value than a conversion directly from type T to type object. This result leads to incoherence. Now consider the following C code 

In addition the nullable of type T does not typically implement the interfaces of the underlying type T. In general an interface defines a set of properties methods and events but does not provide implementation. In particular in C an interface type is a partial specification of a type. All classes that inherit from the interface type must implement the methods contained in the interface type. For example 

The conventional implementation of the nullable type also allows nesting of nullables. In general the nullable type should be utilized only with underlying types that are not capable of expressing nullability themselves. Generally taking the nullable of a reference type may be prevented by adding a constraint to the T on the nullable declaration. However this constraint would not prevent a software developer from creating nested nullable types e.g. nullable because nullable is itself a structure and therefore a value type variable.

The low level nullable type support should recognize structures capable of representing the null value. Recognition of structures which support the null value would allow a runtime distinction between nullable types and other structures. Once the nullable type may be differentiated from other structures including programmer defined structures the nesting of nullable types may be prevented. Alternatively the compiler may not allow structures to be converted into nullable types. The execution may include a special verifier rule that interprets the struct constraint as cannot represent null identifying the variable as a struct but not a nullable type.

Referring now to the runtime environment may be modified to properly convert between a nullable type and a reference type e.g. box and unbox the nullable type . In particular in one aspect the runtime compiler component JIT may be modified to provide the specialized box and unbox instructions. illustrates a boxing instruction that recognizes and unwraps a nullable type for example nullable. Nullable is mapped it to a null pointer if the value of nullable is null or to a boxed unwrapped T if the value of nullable is not null. Beginning at the box instruction is received. At it is determined whether the variable to be boxed is a nullable type. If the variable is not a nullable type the processing continues with the conventional boxing instruction at . If the variable is a nullable type at it is determined whether the value of the nullable is null. If yes the box instruction will return a null pointer at . If no the box instruction will unwrap the nullable and box the instance of type T contained within the nullable. Thus boxing a non null nullable results in a boxed T. This boxing operation may be thought of as lossy. The result of boxing a nullable stores no information to indicate that it was originally a nullable rather than a T. The boxed representation of a nullable is either a null reference or a reference to a boxed. Consequently there is no dynamic type nullable and the heap never holds a nullable. When the nullable is boxed it is unwrapped and the underlying value is stored on the heap rather than the nullable.

In one aspect of the disclosed subject matter a true static boxed may still exist in the runtime. The execution engine may allocate and manage static fields on the managed heap. The static fields should be fully self describing and therefore boxed. To avoid losing type information a true boxed is maintained and the unbox operation will succeed in unboxing the boxed into a nullable.

To summarize with these modifications to the box and unbox instructions it would be effectively impossible to have a boxed nullable. After all when nullable is boxed only type T is stored in the object type or box. Therefore a type T would have only one boxed form. In addition a null value of type nullable would always map onto a null reference. For a non null of type nullable the value element is unwrapped and then boxed resulting in boxed . A boxed instance of T could be unboxed either as a T which would throw an exception if boxed T was equal to null or as a nullable which would map a null reference to a null value . The modifications of the box and unbox instructions would eliminate the confusion around boxed T and boxed nullable.

In addition the modification of the box and unbox instructions would make nullable appear to implement T s interfaces when it is boxed. As discussed above the modified boxing instruction effectively unwraps the nullable. Accordingly boxed nullable is equivalent to boxed T and therefore has access to any interfaces of type T. However it is important that all of the interfaces implemented by nullable be implemented by type T. If type T does not have all of the interfaces then when a nullable is unwrapped and boxed as a type T some of the interface implementations may be lost. One possible method for ensuring that T implements all of the interfaces of nullable is to constrain T. Consider the following exemplary C code using generic constraints 

To prevent the interface problems discussed above the nullable may be implemented without interfaces. The default comparers and equitable comparers within the runtime environment e.g. CLR may be altered to recognize nullables. Consider the following exemplary code 

Additional modifications to the runtime environment may be required to support full nullable functionality. The runtime environment may need to provide instructions that allow inspection of the nullable type at runtime. For example runtime instructions that test for assignment compatibility of an object with a type token T e.g. the isinst instruction of the JIT provided by CLR may need to be updated. The isinst instruction must have intrinsic knowledge of the nullable type to perform type checking. The isinst should leave a reference to the object on the stack to indicate success. Otherwise a null reference is left on the stack. When the isinst instruction is successful unboxing is not performed. The code will perform an unbox into a nullable slot if necessary.

The modified runtime instruction to test for type compatibility may be utilized by general purpose programming language operators. For example the C operators is and as utilize the isinst operation. Accordingly the is and as operators may be extended to handle any type that permits nullability e.g. reference types and nullable types .

The is operator is used to dynamically check if the runtime type of an expression is compatible with a given type. The result of an is operation e is T where e is an expression and T is a type is a Boolean that indicates whether the expression may be converted to the type T by a reference conversion a boxing conversion or an unboxing conversion. The is operation may need to be modified such that the expressions e is T evaluates to True when e is T or a non null T and False otherwise. In addition the expression e is T should evaluate to True when e is T or a non null T and should be False otherwise.

The as operator is used to explicitly convert a value to a given reference type using a reference conversion or a boxing conversion. If the conversion is not possible the resulting value is null. In an operation of the form e as T e must be an expression and T must be a reference type. To fully support the nullable type the as instruction may need to be modified such that for the operation e as T T must be a reference type or a nullable type.

In addition the runtime environment may provide a mechanism for reifying class information at runtime. As used herein reifying runtime values allows developers to view and manipulate runtime values. For example the .NET framework includes Reflection. Reflection is provided through a set of base classes in the System.Reflection namespace and allows developers to view and manipulate values in the CLR using an object model. Reflection may be used to programmatically call methods inspect objects and determine the available methods and members of certain objects. Because Reflection views and manipulates data types it requires information regarding available types including the nullable type. Although this has been discussed particularly with the .Net and Reflection any such mechanism should have the ability to handle the nullable type.

The set of Reflection APIs provided to the programmers uses a series of function calls fcalls RuntimeMethodHandle. InvokeMethodFast  ConstructorInvoke and  SerializationInvoke e.g. Type.InvokeMember MethodInfo.Invoke ConstructorInfo.Invoke etc. . These core fcalls may need to be modified to implement the correct semantics for unwrapping nullable types to deliver arguments to methods that expect real nullable values. Given a boxed argument which is of type boxed or null the fcall must successfully bind to parameters of type nullable. The Reflection APIs accept object types as input accordingly there is no way to get the raw nullable through to the implementation and fcalls. This creates two separate problems i deciding whether the provided arguments correctly match a method s parameters and ii performing conversions from null or type T to a nullable when dispatching to a method that takes a nullable as an argument. For example if you have a method handle for an overload void foo int x the code which invokes foo may pass x inside an object array. The act of creating the array will box the argument resulting in either a boxed int or a null. The reflection code must know to either wrap or unwrap the argument before delivering it to foo . Consider the following exemplary code 

In addition any serializers or deserializers provided by the software development framework may need to be updated to provide deep understanding of the nullable type. Serialization is the process of taking an object and converting it into a format in which it can be transmitted across a network and saved to a storage location. Accordingly any serializers in the runtime environment may need to have deep knowledge of nullable. The representation of a boxed nullable may confuse a serializer e.g. when the serializer would like to serialize the raw nullable structure containing the Boolean hasValue and value .

Referring now to for each programming language that includes the nullable type certain applications may need to be modified to fully support the nullable type. An integrated development environment IDE is a set of programs or applications run from a single user interface to provide a set of tools for software development. For example an IDE often includes a text editor component compiler component debugger component and designer component which are all activated and function from a common user interface. A designer component may facilitate the design and coding of a graphical user interface. The IDE including but not limited to the compiler component and debugger component may be modified to support the low level understanding of the nullable type. For example existing debuggers may not understand that the new physical representation of a nullable is either a boxed or a null reference.

The subject matter disclosed herein may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. The term article of manufacture or alternatively computer program product as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick . Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Referring to methodologies relating to supporting nullable types are illustrated. While for purposes of simplicity of explanation the methodologies are shown and described as a series of acts it is to be understood and appreciated that the methodologies are not limited by the order of acts as some acts may in accordance with these methodologies occur in different orders and or concurrently with other acts from that shown and described herein. For example those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events such as in a state diagram. Moreover not all illustrated acts may be required to implement the following methodologies.

In order to provide a context for the various aspects of the disclosed subject matter as well as the following discussion are intended to provide a brief general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer executable instructions of a computer program that runs on a computer and or computers those skilled in the art will recognize that the claimed subject matter also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multiprocessor computer systems mini computing devices mainframe computers as well as personal computers hand held computing devices e.g. personal digital assistant PDA phone watch . . . microprocessor based or programmable consumer or industrial electronics and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the subject matter can be practiced on stand alone computers. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary environment for implementing various aspects disclosed herein includes a computer e.g. desktop laptop server hand held programmable consumer or industrial electronics . . . . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available microprocessors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the claimed subject matter can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like displays e.g. flat panel and CRT speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection s . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems power modems and DSL modems ISDN adapters and Ethernet cards or components.

What has been described above includes examples of aspects of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the disclosed subject matter are possible. Accordingly the disclosed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the terms includes has or having are used in either the detailed description or the claims such terms are intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

