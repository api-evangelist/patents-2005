---

title: Effectively and efficiently supporting XML sequence type and XQuery sequence natively in a SQL system
abstract: Techniques for effectively and efficiently supporting XML sequence type and XQuery sequence natively in a SQL system are described. According to one aspect, SQL functions that correctly handle XML sequences are provided. Thus, XML sequences are handled effectively. According to another aspect, rules for simplifying an abstract syntax tree (AST) that represents one or more such SQL functions are provided. For each such SQL function that is represented in an AST that represents a SQL query, one or more rules that are relevant to that SQL function are determined. Relevant rules are applied to the representation of the SQL function within the AST. Through the application of the rules to the representations of the SQL functions within the AST, the AST is modified in a manner that simplifies the AST prior to the evaluation of the AST at query execution time. Thus, XML sequences are handled efficiently.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08463801&OS=08463801&RS=08463801
owner: Oracle International Corporation
number: 08463801
owner_city: Redwood Shores
owner_country: US
publication_date: 20050404
---
This application is related to U.S. patent application Ser. No. 10 948 523 entitled EFFICIENT EVALUATION OF QUERIES USING TRANSLATION by Zhen Hua Liu et al. filed on Sep. 22 2004 the entire contents of which are incorporated by reference for all purposes as if originally set forth herein.

This application is related to U.S. patent application Ser. No. 10 259 278 entitled MECHANISM FOR MAPPING XML SCHEMAS TO OBJECT RELATIONAL DATABASE SYSTEMS by Ravi Murthy et al. filed on Sep. 27 2002 the entire contents of which are incorporated by reference for all purposes as if originally set forth herein.

This application is related to U.S. patent application Ser. No. 10 428 878 entitled TECHNIQUES FOR REWRITING XML QUERIES DIRECTED TO RELATIONAL DATABASE CONSTRUCTS by Anand Manikutty et al. filed on May 1 2003 the entire contents of which are incorporated by reference for all purposes as if originally set forth herein.

This application is related to U.S. patent application Ser. No. 10 428 443 entitled TECHNIQUES FOR RETAINING HIERARCHICAL INFORMATION IN MAPPING BETWEEN XML DOCUMENTS AND RELATIONAL DATA by Ravi Murthy et al. filed on May 1 2003 the entire contents of which are incorporated by reference for all purposes as if originally set forth herein.

This application is related to U.S. patent application Ser. No. 09 949 020 entitled METHOD AND APPARATUS FOR XML VISUALIZATION OF A RELATIONAL DATABASE AND UNIVERSAL RESOURCE IDENTIFIERS TO DATABASE DATA AND METADATA by Muralidhar Krishnaprasad et al. filed on Sep. 6 2001 the entire contents of which are incorporated by reference for all purposes as if originally set forth herein.

This application is related to U.S. patent application Ser. No. 09 948 949 filed together herewith entitled APPARATUS AND METHOD FOR MAPPING RELATIONAL DATA AND METADATA TO XML by Muralidhar Krishnaprasad et al. filed on Sep. 6 2001 the entire contents of which are incorporated by reference for all purposes as if originally set forth herein.

This application is related to U.S. patent application Ser. No. 09 948 998 entitled METHOD AND APPARATUS FOR FLEXIBLE STORAGE AND UNIFORM MANIPULATION OF XML DATA IN A RELATIONAL DATABASE SYSTEM by Muralidhar Krishnaprasad et al. filed on Sep. 6 2001 the entire contents of which are incorporated by reference for all purposes as if originally set forth herein.

The present invention relates to query processing. The invention relates more specifically to techniques for effectively and efficiently supporting XML sequence type and XQuery sequence natively in a SQL system.

The approaches described in this section could be pursued but are not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Relational database management systems RDBMSs store information in tables where each piece of data is stored at a particular row and column. Information in a given row generally is associated with a particular object and information in a given column generally relates to a particular category of information. For example each row of a table may correspond to a particular employee and the various columns of the table may correspond to employee names employee social security numbers and employee salaries.

As is well known each column of a relational table is associated with a data type and all information within a particular column is required to conform to the particular column s data type. For example only numbers can be stored in a column that is associated with the number data type.

Extensible Markup Language XML provides a convenient way to express information in a hierarchically structured format. XML formatted information can be stored within a relational table. According to current approaches any relational table column that stores XML formatted information in a native format such that the structure of the XML information is preserved is associated with one of two types an XMLType document type or an XMLType content type. Only XMLType document type instances can be stored in an XMLType document type column and only XMLType content type instances can be stored in an XMLType content type column.

A user retrieves information from and makes updates to a database by interacting with a database application. The user s actions are converted into a query by the database application. The database application submits the query to a database server. The database server responds to the query by accessing the tables specified in the query to determine which information stored in the tables satisfies the query. The information that satisfies the query is retrieved by the database server and transmitted to the database application. Alternatively a user may request information directly from the database server by constructing and submitting a query directly to the database server using a command line or graphical interface.

Queries submitted to the database server must conform to the syntactical rules of a database query language. One popular database query language known as the Structured Query Language SQL provides users a variety of ways to specify information to be retrieved from relational tables.

Although not necessarily a database query language a new language for querying information contained in XML documents was recently conceived XML Query Language XQuery . XQuery is based on XML and is described in XQuery 1.0 An XML Query Language W3C Working Draft 29 Oct. 2004. Another related technology XPath is described in XML Path Language XPath 2.0 W3C Working Draft 29 Oct. 2004. XQuery may use XPath for path traversal.

When a SQL query is executed the results are returned as a row set which is a set of rows. In contrast when an XQuery query is executed the results are returned as an instance of XMLType sequence type. In XQuery terminology the result of an XQuery is an instance of XQuery data model. In SQL XML terminology the result of an XQuery is an instance of XMLType sequence type.

As described in XQuery 1.0 and XPath 2.0 Data Model W3C Working Draft Oct. 29 2004 an XML sequence is sequence of items. Each item may be either a node or an atomic value. The entire contents of XQuery 1.0 and XPath 2.0 Data Model are incorporated by reference for all purposes as though fully set forth herein.

There are some significant differences between XMLType sequence type instances and XMLType document type instances or XMLType content type instances. Unlike XMLType document type instances and XMLType content type instances XMLType sequence type instances do not have a multi tiered hierarchical structure. XMLType document type instances and XMLType content type instances consist of a document node that is the parent of one or more child nodes but XMLType sequence type instances do not contain such a parent document node. XMLType sequence type instances are organizationally flat. There is no nested sequence within an XMLType sequence type instance. However each item of the sequence can be a node having hierarchical structures.

Also unlike XMLType sequence type instances XMLType document type instances and XMLType content type instances do not allow for the representation of atomic values that are not nodes. Everything within an XMLType document type instance or an XMLType content type instance is a node of some kind. This is significant because for example if an XQuery query processor were to be asked whether a node is an instance of an atomic value the query processor would respond negatively. Thus if XMLType sequence type instances are serialized into XMLType content type instances important information may be lost in translation.

Although at least one currently available RDBMS provides SQL functions to manipulate XMLType document type instances and XMLType content type instances that are contained in relational tables these functions are not designed to operate on XMLType sequence type instances. Because of the differences between XMLType sequence type instances and XMLType content type instances some of which are described above none of these functions as they are currently implemented operates correctly relative to XMLType sequence type instances.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Techniques for effectively and efficiently supporting XML sequence type and XQuery sequence natively in a SQL system are described. According to one aspect of the techniques SQL functions that correctly handle XML sequences also called XQuery sequences semantics are constructed. For example SQL functions that convert XMLType sequence type instances into XMLType content type instances and that convert XMLType content type instances into XMLType sequence type instances are described below. Existing SQL query processors can be enhanced to recognize and evaluate such SQL functions. Thus XML sequences are handled effectively.

Furthermore according to another aspect of the techniques rules for simplifying an abstract syntax tree AST that represents one or more such SQL functions are provided. For each such SQL function that is represented in an AST that represents a SQL query one or more rules that are relevant to that SQL function may be determined. Relevant rules are applied to the representation of the SQL function within the AST. Through the application of the rules to the representations of the SQL functions within the AST the AST is modified in a manner that simplifies the AST prior to the evaluation of the AST at query execution time. A SQL query processor can evaluate a simplified AST at a lower computational expense. Thus XML sequences are handled efficiently as well.

Before the techniques referred to above are described in detail an example system in which the techniques may be used is briefly described. is a block diagram showing a database architecture that may be used to implement an embodiment of the present invention. The architecture comprises a user interface a database server and a database . Database server interacts with the user via user interface and accesses and maintains database in accordance with the user input. Database server may also interact with other systems not shown .

In general database server creates a database by organizing information in one or more tables. The organization of the table is referred to as a definition. An index is a structure that is used for accessing particular information in the table more quickly. Therefore a table definition supports any access mechanism to the data search by name by ID by date etc. whereas an index is designed for a specific access method. The index itself is generally not the authoritative source of the data but rather contains pointers to the disk addresses of the tables storing the authoritative data.

Database server contains a SQL query processor which receives SQL queries as input constructs ASTs to represent those queries applies rules to simplify the ASTs and evaluates the ASTs to execute the queries thereby retrieving data from and or manipulating data within database . Techniques for constructing an AST that incorporates XQuery functionality are described in U.S. patent application Ser. No. 10 948 523 referred to above.

The system shown in supports XML or XMLType as a native datatype. Using XMLType users can store XML documents in databases via the use of XML tables or XMLType columns of tables. Furthermore users can convert their relational data into XMLType views via the use of SQL XML publishing functions such as XMLELEMENT XMLCONCAT etc. For more information on these functions the reader is referred to 101 10.1 the entire contents of which are incorporated by reference for all purposes as though fully set forth herein. XQuery can be used in SQL through a function such as XMLQUERY which enables queries on XMLType values. The XMLTABLE function enables one to convert XML values possibly from one or more XMLType columns or values returned from an XQuery into a virtual relational table.

According to one embodiment an XMLType column of a relational table is actually associated with one of three major types XMLType DOCUMENT XMLType CONTENT or XMLType SEQUENCE . Columns of XMLType DOCUMENT can contain XMLType document type instances. Columns of XMLType CONTENT can contain XMLType content type instances. Columns of XMLType SEQUENCE can contain XMLType sequence type instances.

Several different SQL functions for handling and or producing XML sequences are described below. Although such SQL functions might be used within SQL queries directly typically a SQL query containing an invocation of XQuery embedded in the XMLQuery function or XMLTABLE construct is translated into a SQL query with these SQL functions manipulating XMLType sequence . Each occurrence of such SQL functions is actually produced by the rewrite of XQuery used in XMLQuery or XMLTable as described in U.S. patent application Ser. No. 10 948 523 entitled EFFICIENT EVALUATION OF QUERIES USING TRANSLATION . The SQL functions described below either accept an XMLType sequence as an input parameter or produce an XMLType sequence as an output parameter i.e. as a result of the function . Some of the SQL functions described below may do both.

To process a SQL query that is translated from the original SQL query containing an invocation of XQuery in XMLQuery or XMLTable construct and thus contains one or more of the SQL functions described below a query processor optimizes the invocation of these SQL functions during query compilation time using a set of algebra rules. The query processor then evaluates these SQL functions during query execution time.

The SQL function PKSQL2XML converts a SQL scalar value into an XML sequence. The resulting XML sequence is a sequence of one item which is an XQuery atomic value rather than an XQuery node. The XQuery atomic value is equal mathematically to the original SQL scalar value.

The SQL function UPKXML2SQL is the inverse of PKSQL2XML . The SQL function UPKXML2SQL converts an XML sequence of one item an XQuery atomic value into a SQL scalar value. The resulting SQL scalar value is equal mathematically to the original XQuery atomic value.

The SQL function XQRNG receives two integers as input and produces an XML sequence that represents a range of integers starting with the first integer and ending with the second integer.

The resulting XML sequence is actually a sequence of atomic values that starts with an XQuery atomic value that is mathematically equal to the first integer and ends with an XQuery atomic value that is mathematically equal to the second integer. For each particular integer between the first and second integers in the integer domain the resulting XML sequence also contains a separate XQuery atomic value that is mathematically equal to the particular integer. The XQuery atomic values in the resulting XML sequence are in numerically ascending order.

The SQL function SEQ2CON converts an instance of XMLType sequence type into an instance of XMLType content type. For each item in the original XMLType sequence type instance the resulting XMLType content type instance contains a corresponding node. The resulting XMLType content instancealso contains a document node to which the other nodes in the resulting object are hierarchically subordinate.

The SQL function CON2SEQ is the inverse of SEQ2CON . The SQL function CON2SEQ converts an instance of XMLType content type into an instance of XMLType sequence type. The resulting XMLType sequence type instance contains one or more nodes. Each such node corresponds to a separate node within the original XMLType content type instance.

According to one embodiment the XML content to XML sequence conversion involves ignoring the top level document node in the original XMLType content type instance and adding nodes to the resulting XMLType sequence type instance for each child node of the top level document node.

The SQL function XQCONCAT receives one or more input parameters that may be instances of any XML types e.g. XMLType document XMLType content XMLType sequence etc. and produces an XMLType sequence as an output parameter. For each particular input parameter the resulting XML sequence contains a separate item that represents the particular input parameter. In one embodiment the items in the resulting XML sequence are in the same order as the input parameters that those items represent. If the input parameter is an instance of XMLType sequence type then every item in the XMLType sequence type becomes an item in the resulting XML sequence. This is because there is no concept of nested sequences in XMLType sequence types.

The SQL function XQAGG receives as an input parameter a SQL collectionof one or more XMLType instances e.g. XMLType document XMLType content XMLType sequence etc. and produces an XMLType sequence as an output parameter. For each particular XMLType instance in the original SQL collection the resulting XML sequence contains a separate item that represents that XMLType instance. If the instance is of XMLType sequence type then every item in the XMLType sequence type becomes an item in the resulting XML sequence because there is no concept of nested sequences in XMLType sequence types.

For example the original SQL collection may be a row set that is the result of a SQL query thus each XMLType instance in the original SQL collection may be computed from a separate row from the SQL query. The resulting XMLsequence from XQAGG may be stored in a relational table column that is of XMLTYPE SEQUENCE type.

The SQL function XQSEQUENCE may be viewed as the inverse function of XQAGG described above XQAGG converts a SQL collection of XMLType instances into one instance of XMLType sequence and XQSEQUENCE converts an instance of XMLType sequence into a SQL collection of XMLType instances.

XQSEQUENCE receives an XMLType sequence instance as an input parameter and returns as an output parameter a SQL collection of one or more XMLType instances. For each particular item in the original sequence the resulting SQL collection contains a separate XMLType instance that represents the particular item.

For example the resulting SQL collection may be logically considered as a row set thus each XMLType instance in the resulting SQL collection becomes a separate row. The resulting SQL collection may then be provided as an input parameter to the SQL TABLE function to generate a virtual table from which a SQL query can select rows.

The SQL function XQEXTRACT is similar to the existing SQL function EXTRACT in that it applies a specified XPath expression to an XMLType instance to determine nodes which are hierarchically located so as to satisfy the XPath expression. However while EXTRACT return an instance that is of XMLType content type XQEXTRACT instead returns an instance that is of XMLType sequence type.

The SQL function XQEXTRACTVAL receives as an input parameter an XML sequence of a single item that is a node. XQEXTRACTVAL applies the XPath expression text to the item node to obtain the concatenation of all text value of text nodes under the item node. XQEXTRACTVAL returns as an output parameter an instance of XMLType content type.

As is discussed above an AST that represents one or more of the foregoing SQL XML sequence functions can be simplified prior to evaluation by applying to each such function one or more rules that are relevant to that function. For each such SQL function that is represented in an AST one or more rules that are relevant to that SQL function may be determined. Relevant rules are applied to the representation of the corresponding SQL function within the AST. Such rules are sometimes called algebra rules. 

In block it is determined that an AST includes a representation of a SQL function that either a has an input parameter that is of XML sequence type or b has an output parameter that is of XML sequence type. For example a query processor may determine that an AST contains a representation of SEQ2CON or CON2SEQ .

In block in response to the determination of block one or more rules that apply to the SQL function are determined. For example in response to determining that the AST contains a representation of CON2SEQ the query processor may determine a set of rules that apply to CON2SEQ . Depending on the specific usage of CON2SEQ one or more of the rules may or may not apply. Some rules apply only to certain combinations of SQL functions some of which are described in greater detail below.

In block prior to evaluating the AST to execute a SQL query that the AST represents the AST is modified through the application of the rules determined in block to the representation of the SQL function in the AST. For example the query processor may translate the representation of CON2SEQ into a representation of a different SQL function a different combination of SQL functions or an expression that may or may not include SQL functions. Such an expression may include one or more input parameters of the SQL function to which the rules are applied.

In many cases the SQL functions described above and the rules described below allow existing mechanisms within a query processor to be used to evaluate a query that operates on or otherwise uses XMLType sequence type instances. Existing operators that are already used relative to instances of XMLType content or XMLType document can be used to evaluate SQL queries that contain XMLType sequence type instances or expressions such as XQuery queries that evaluate to XMLType sequence type instances. Thus for example a query processor developer would not need to implement an equal comparison operator specifically for XMLType sequence type instances which are actually XMLType content instances if an equal comparison operator already existed for XMLType content type instances instead the query processor could convert XMLType sequence type instances into XMLType content type instances and then the query processor could apply the XML content equal comparison operator to the XMLType content type instances to produce a result. Afterward the query processor could convert the XMLType content type instances back into XMLType sequence type instances if needed.

Some rules and the SQL functions to which they apply are described below. Each rule specifies a pattern that may be detected within an AST and a result to which the SQL functions matching the pattern are to be translated. Several passes may be made over an AST in determining and applying relevant rules so SQL functions or expressions may mutate multiple times if some rules become applicable as the result of applying other rules. In one embodiment when a pass over the AST results in no additional changes then the application of the rules to the AST is complete. Although all of the following rules are implemented in one embodiment in other alternative embodiments one or more of the following rules may be omitted.

The null in out rule applies to several of the SQL functions introduced herein. More specifically in one embodiment the null in out rule is applicable to the following SQL functions UPKXML2SQL PKSQL2XML XQRANGE SEQ2CON CON2SEQ XQCONCAT and XQEXTRACT .

In the following description all of the above SQL functions are generically represented as OPR . Using this notation the null in out rule states that occurrences of OPR NULL should be changed to NULL instead. Thus for example in an AST PKSQL2XML NULL would be changed to NULL instead.

The case distribution rule also applies to several of the SQL functions introduced herein. More specifically in one embodiment the case distribution rule is applicable to the following SQL functions UPKXML2SQL CON2SEQ SEQ2CON and XQEXTRACT .

Again in the following description all of the above SQL functions are generically represented as OPR . Using this notation the case distribution rule states that occurrences in an AST of an expression

The scalar subquery pushdown rule also applies to several of the SQL functions introduced herein. More specifically in one embodiment the scalar subquery pushdown rule is applicable to the following SQL functions UPKXML2SQL CON2SEQ SEQ2CON and XQEXTRACT .

Again in the following description all of the above SQL functions are generically represented as OPR . Using this notation the scalar subquery pushdown rule states that occurrences in an AST of an expression

Thus for example in an AST the expression PKXML2SQL SELECT name FROM employee would be changed to SELECT PKXML2SQL name FROM employee instead.

Expressions that match the following pattern are changed in the AST merely to s as contained in the expression 

If c in the expression SEQ2CON CON2SEQ c is of any of a group of specified XML content types then the expression is changed simply to c . According to one embodiment for purposes of this rule the specified XML content types are XMLType CONTENT element XMLType CONTENT comment XMLType CONTENT text and XMLType CONTENTpi . In the foregoing notation the character means zero or more occurrences and the character means zero or one occurrences.

If c in the expression SEQ2CON XQAGG c is of XMLType CONTENT element then the expression is changed simply to XMLAGG c . The XMLAGG function is described in 101 10.1 referred to above.

If x in the expression SEQ2CON XQAGG x is of XMLType SEQUENCE element then the expression is changed to XMLAGG SEQ2CON x .

The expression SEQ2CON XQEXTRACT c path is changed to EXTRACT c path if c is of any of a group of specified XML content types. According to one embodiment for purposes of this rule the specified XML content types are XMLType CONTENT element XMLType CONTENT text XMLType CONTENT pi and XMLType CONTENT comrent . In the foregoing notation the character means zero or more occurrences and the character means zero or one occurrences. The EXTRACT function is described in 101 10.1 referred to above.

If x in the expression CON2SEQ SEQ2CON x is of XMLType SEQUENCE element then the expression is changed simply to x . In the foregoing notation the character means zero or more occurrences.

If c in the expression CON2SEQ XMLAGG c is of XMLType CONTENT element then the expression is changed to XQAGG CON2SEQ c . In the foregoing notation the character means zero or more occurrences. The XMLAGG function is described in 101 10.1 referred to above.

Input parameters of a first instance of XQCONCAT that is itself nested as an input parameter of a second instance of XQCONCAT become input parameters of the second instance instead and the first instance is removed. Thus for example the expression XQCONCAT x1 XQCONCAT x2 x3 x4 is changed to XQCONCAT x1 x2 x3 x4 instead. The input parameters x2 and x3 added to the second instance retain the position of the removed first instance relative to the input parameters x1 and x4 already in the second instance.

The expression XQCONCAT x1 x2 . . . xn is changed to CON2SEQ XMLCONCAT SEQ2CON x1 SEQ2CON x2 . . . SEQ2CON xn if all of the input parameters x1 through xn of the original XQCONCAT expression are of XMLType SEQUENCE element .

The expression SELECT XQAGG x FROM t is changed to CON2SEQ SELECT XMLAGG SEQ2CON x FROM t if x is of XMLType SEQUENCE element . The XMLAGG function is described in 101 10.1 referred to above.

The expression XQEXTRACT x path is changed to CON2SEQ EXTRACT SEQ2CON x path if a x is of XMLType SEQUENCE element and b the original expression s output parameter return value is of any of a group of specified XML sequence types. According to one embodiment for purposes of this rule the specified XML sequence types are XMLType SEQUENCE element XMLType SEQUENCE text XMLType SEQUENCE pi and XMLType SEQUENCE comment . In the foregoing notation the character means zero or more occurrences and the character means zero or one occurrences. The EXTRACT function is described in 101 10.1 referred to above.

The expression XQEXTRACT c path is changed to CON2SEQ EXTRACT c path if a c is of XMLType CONTENT element and b the original expression s output parameter return value is of any of a group of specified XML sequence types. According to one embodiment for purposes of this rule the specified XML sequence types are XMLType SEQUENCE element XMLType SEQUENCE text XMLType SEQUENCE pi and XMLType SEQUENCE comment .

The expression SELECT VALUE v FROM TABLE XMLSEQUENCE SELECT XMLAGG c FROM t v SELECT VALUE v FROM SELECT c FROM t is changed to SELECT c FROM t if c is of XMLType CONTENT element . In the foregoing notation the character means zero or one occurrences. The XMLSEQUENCE XMLAGG VALUE and TABLE functions are described in 101 10.1 referred to above.

The expression SELECT VALUE v FROM TABLE XQSEQUENCE SELECT XQAGG i FROM t v SELECT VALUE v FROM SELECT i FROM t is changed to SELECT i FROM t if i is of XMLType SEQUENCE item .

The expression SELECT VALUE v FROM TABLE XQSEQUENCE x is changed to SELECT CON2SEQ VALUE v FROM TABLE XMLSEQUENCE x v if x is of XMLType SEQUENCE element .

The expression SELECT VALUE v FROM TABLE XQSEQUENCE CON2SEQ c v is changed to SELECT SEQ2CON VALUE v FROM TABLE XMLSEQUENCE c v if c is of XMLType CONTENT element .

The expression SELECT VALUE v FROM TABLE XQSEQUENCE x v is changed to SELECT CON2SEQ v FROM TABLE XMLSEQUENCE SEQ2CON x v if x is of XMLType SEQUENCE element .

The SQL XML publishing functions include XMLELEMENT XMLFOREST XMLAGG and XMLCONCAT all of which are described in 101 10.1 referred to above. In the following description the generic function F represents any of the SQL XML publishing functions.

The expression XMLCONCAT c1 c2 . . . cn is changed to SEQ2CON XQCONCAT CON2SEQ c1 CON2SEQ c2 . . . CON2SEQ cn if all of the input parameters c1 through cn of the original XMLCONCAT expression are of XMLType CONTENT element .

The expression SELECT XMLAGG c FROM t is changed to SELECT SEQ2CON XQAGG CON2SEQ c FROM t if c is of XMLType CONTENT element .

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any medium that participates in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infrared data communications.

Common forms of machine readable media include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge a carrier wave as described hereinafter or any other medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal. An infrared detector can receive the data carried in the infrared signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

