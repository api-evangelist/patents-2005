---

title: Advanced application framework system and method for use with a diagnostic medical ultrasound streaming application
abstract: An application interface provides an environment in which applications may discover and attach to data streams. The interface facilitates efficient sharing and management of acquired data through arbitration and parallel processing: allowing multiple applications to work in parallel on the same or different data streams to implement independent or co-dependent functionality. Further, the interface acts as a bridge between system address spaces allowing applications to execute in their own address space separate from the resource intensive acquisition processes. The interface also provides an environment for prototyping applications where a user may allocate data streams to an application and debug the application's execution. Because the interface provides a standardized/normalized interface to the acquired image data, applications may be developed independent of the imaging system's implementation details, data formats and protocols.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08292811&OS=08292811&RS=08292811
owner: Siemens Medical Solutions USA, Inc.
number: 08292811
owner_city: Malvern
owner_country: US
publication_date: 20050713
---
This application is a continuation in part under 37 C.F.R. 1.53 b of U.S. patent application Ser. No. 10 393 062 filed Mar. 20 2003 now U.S. Pat. No. 6 932 767 which was filed on the same date as and incorporated by reference U.S. patent application Ser. No. 10 393 091 SYSTEM AND METHOD FOR REAL TIME STREAMING OF ULTRASOUND DATA TO A DIAGNOSTIC MEDICAL ULTRASOUND STREAMING APPLICATION now U.S. Pat. No. 6 733 449.

Diagnostic medical ultrasound systems are routinely used in medical applications for the purpose of imaging various body tissues and organs and for other diagnostic and therapeutic purposes. These systems allow medical professionals to view the internal conditions of a patient thereby enabling them to render a better diagnosis. In one example of a diagnostic medical ultrasound system a piezoelectric transducer acquires image data by transmitting a series of ultrasonic pulses into a patient and receiving the echoes therefrom. These echoes are converted manipulated into an image and displayed on a monitor or stored for later use. This process can be further characterized as a continuous or streamed process. As the echoes are received by the transducer they are converted and displayed in a continuous fashion i.e. streamed from the transducer to the display.

The ultrasound system is primarily designed to process the received echoes in this streaming fashion. To improve the functionality of the ultrasound system applications may be provided which post process the received echoes to enhance the usability of the data. For example color coding may be added to further enhance the visibility of Doppler shifts in the echoes. Any post processing of the received echo information must either operate in a streamed fashion i.e. operate on the received echo data as it is received in real time or buffer store a portion of the received echo data and operate on that buffered stored portion.

Development of applications which can operate in real time on the received echo information is complex and resource intensive such that the number of such streaming applications offered on a given ultrasound system is often limited. Furthermore many of today s applications rely heavily on expensive custom hardware components specifically designed to perform data processing such as a 3D imaging calculator. Use of these hardware components limits the reusability and flexibility of the application and the ultrasound system. The hardware components also typically tie up any ultrasound data being processed until a final result is produced thereby preventing multiple applications from operating in parallel. Further these applications are typically structured based on the nature of ultrasound system itself i.e. the application s functionality is divided among three functions acquisition of data manipulation of data and storage or display of the manipulated data. Typically the application developer in designing the software architecture of the application makes initial assumptions about each function s role in the application. For example the data acquisition function might assume that a certain piece of hardware in the ultrasound system was always going to be used. It may then use global data structures that are very specific to this piece of hardware. The acquisition function would then acquire data place it into and control it with one of these global data structures. The data manipulation and storage functions would then need to access these global data structures in order to retrieve both control and ultrasound imaging data to perform their tasks. In this way all three functions have become dependent on a specific piece of hardware. Should that hardware change or any control information in the highly coupled data structure change all three functions would need to be modified. Another example of functional co dependency is a simple in process frame grabbing application. A data source acquisition function might always assume it will acquire the same kind of data and that this data will always be compressed and stored in the same particular way. As a result the acquisition function would be coded in a way to take advantage of these assumptions typically for performance reasons. If either the data manipulation or data storage function changed it would likely break the acquisition function. If a need arises to make data storage out of process it is likely to have significant impact on both data acquisition and manipulation because both assumed that the whole application would be handled in process. In sum the more assumptions made the more dependent each function becomes on the other two and the more difficult application development and maintenance becomes.

While such applications provide a valuable diagnostic tool to physicians they also suffer from inherent limitations and may make real time data processing at minimum difficult if not impossible to complete without extensive testing and cost. Furthermore these applications are not designed to be reusable and do not allow access to intermediate data.

Accordingly there is a need for a flexible reusable low cost ultrasound streaming application architecture that reduces dependency on custom hardware components and legacy programs while making ultrasound data readily available at any point throughout the course of processing. Further there is a need for an ultrasound streaming application architecture that further reduces the number of initial programming assumptions made in development thereby reducing dependencies between the underlying functions of the application.

As shown in the disclosed embodiments relate to a an ultrasound application in which each of the three underlying functions of acquisition manipulation and storage are decoupled from each other. represents the data dependencies of an ultrasound streaming application using the pipes and filters framework disclosed herein. As can be seen data acquisition data manipulation and data storage operate with virtually no coupling. Furthermore the disclosed embodiments eliminate the dependencies of these functions by taking advantage of the object oriented programming principles of encapsulation inheritance and polymorphism. Encapsulation allows the internal implementation of the object to be modified without requiring any change to the application that uses it. In the disclosed embodiments the responsibilities of the underlying functions of the framework are clearly defined and encapsulated in classes. Inheritance enables an application developer to develop abstract objects to establish the roles of each underlying function and then develop subclasses based on those abstract objects for specific embodiments of the present invention. Finally polymorphism allows the disclosed embodiments to produce different results based on the specific objects that are provided creating greater flexibility. Thus encapsulation inheritance and polymorphism allow the functions of an ultrasound streaming application to be compiled and tested in isolation before being integrated into the overall system. Furthermore new modules designed to enhance or extend the behavior of the application can be integrated easily into an existing application. Finally new applications can be developed quickly as modules that fit into a generic framework can be reused and incorporated into a new application.

The front end acquisition hardware is coupled with the transducer . The front end acquisition hardware causes the transducer to generate acoustic energy into a subject and receives the electrical signals generated by the transducer in response to the received echoes representing a two dimensional representation of the subject. In one embodiment the front end acquisition hardware is configurable to acquire information corresponding to a plurality of two dimensional representations or image planes of a subject for three dimensional reconstruction. Other configurations such as those for acquiring data with a two dimensional 1.5 dimensional or single element transducer array may be used. To generate each of the plurality of two dimensional representations of the subject during an imaging session the acquisition hardware is configured to transmit receive and process during a plurality of transmit events. Each transmit event corresponds to firing acoustic energy along one or more ultrasound scan lines in the subject. As a result of the succession of transmit events occurring during use of the system information is received continuously throughout this process. The constant flow of data generated by the acquisition hardware can be characterized as a stream of data. It will be appreciated that a data stream may include both a meta data stream and a raw data stream synchronized thereto. The meta data stream includes data which describes the raw data stream such as describes the characteristics of the raw data stream i.e. frame rate data source etc. In application the meta data stream will vary less often than the raw data stream since the raw data stream includes the actual acquired data. As parameters of the acquisition change the corresponding meta data stream i.e. the descriptive data may vary accordingly. References herein to a data stream may refer to the meta data stream the raw data stream or both depending upon the implementation of the applications utilizing the particular data.

Data streams such as those generated by the acquisition hardware described above are characterized by properties such as the data format the transmission or acquisition rate the number of image bytes per sample etc. Depending on the type of data being represented the data format may be different. Different streams may also be transmitted at different rates. The number of image bytes per sample may also be different depending on the type of data represented. For example physiological and Doppler derived waveforms may have a constant number of image bytes per sample while the number of image bytes per sample may be programmable for 2D streams. Additional properties of streams may include a source property and a sink property. Each stream must have a source and a sink the source being the location from which the stream originates and the sink being the location where the stream terminates. Sources may be further characterized as being live or stored . A live source is a source which is actually generating the stream typically in real time while a stored source is a source which stores a representation of a stream created at an earlier time. The stream sink may be the display CPU memory or other storage or processing device. A stream may also be classified as a clone of another stream. Cloned streams are copies of streams used to provide multiple applications with access to a particular stream s data. The original stream will be owned by the first application who gains access to it meaning that application will be able to alter various stream properties such as acquisition rate. An application can alter these properties by communicating with the actual data source acquiring the information either directly or through an ultrasound stream manager as described below. If another application desires the data contained in the same stream a clone will be made. In one embodiment a cloned stream differs from a copy of a stream in that the cloned stream s properties depend on the properties of the original stream. The second application receiving the cloned stream is not permitted to communicate directly with the acquisition hardware as it does not own the stream. In other words the application processing the cloned stream is only permitted to alter the cloned streams properties within the boundaries of the properties of the original stream. In contrast some or all of the properties of a copy of a stream may be altered independently of the original stream. For example if the application controlling a live stream configures the acquisition hardware to acquire data at 8 bits per second the cloned stream will also be provided with data at 8 bits per second. It should be noted however that a cloned stream can be manipulated to represent data samples at various rates other than that of the live stream. For example a cloned stream can be sped up or slowed down through interpolation or frame dropping as know in the art. Depending on the desired stream contents a stream s type may be set as a pixel waveform or audio and video sample. It will be appreciated that other stream types may be used depending on the implementation.

In one embodiment nine different types of streams are capable of interacting within the disclosed pipes and filters framework as will be discussed below. The individual properties of a stream correspond to that stream s number. Streams can be either 2d streams trace streams video streams or waveform streams. 2D streams are used for two dimensional image data generated by the transducer. 2D streams are also used to display B mode images and can be utilized by panoramic imaging 3D imaging and equalization applications. Trace streams are used for displaying Doppler and M Mode data. Video streams are used to display digital imaging and communications in medicine or DICOM clips. Waveform streams are used for Physiological Waveforms and Doppler derived waveforms as well as displaying ECG EKG signals. Additionally each waveform stream is capable of acquiring and displaying i.e. contains sufficient bandwidth for two waveforms. For example in one embodiment streams and are used to denote 2D streams of ultrasound data. Stream can be used to display either another 2D stream or a Trace display. Stream is used for a Trace stream. Streams and are used for physiological streams. Thus six A B physiological waveforms are capable of being displayed. Finally stream represents a waveform stream reserved for Doppler imaging.

The transmit beamformer is coupled with the transducer and is of a construction known in the art such as a digital or analog based beamformer capable of generating signals at different frequencies. The transmit beamformer generates one or more excitation signals which causes the transducer to emit one or more ultrasonic pulses. Each excitation signal has an associated center frequency. As used herein the center frequency represents the frequency in a band of frequencies approximately corresponding to the center of the amplitude distribution. Preferably the center frequency of the excitation signals is within the 1 to 15 MHz range and accounts for the frequency response of the transducer . The excitation signals have non zero bandwidth.

It will be appreciated that alternative methods of generating and controlling ultrasonic energy as well as receiving and interpreting echoes received therefrom for the purpose of diagnostic imaging now or later developed may also be used with the disclosed embodiments in addition to or in substitution of current beamforming technologies. Such technologies include technologies which use transmitters and or receivers which eliminate the need to transmit ultrasonic energy into the subject along focused beam lines thereby eliminating the need for a transmit beamformer and may permit beam forming to be performed by post processing the received echoes. Such post processing may be performed by a receive beamformer or by digital or analog signal processing techniques performed on the received echo data. For example please refer to U.S. patent application Ser. No. 09 518 972 entitled METHOD AND APPARATUS FOR FORMING MEDICAL ULTRASOUND IMAGES now U.S. Pat. No. 6 309 356 and U.S. patent application Ser. No. 09 839 890 entitled METHOD AND APPARATUS FOR FORMING MEDICAL ULTRASOUND IMAGES the disclosures of which are herein incorporated by reference.

Control signals are provided to the transmit beamformer and the receive beamformer by the real time controller . The transducer as controlled by the transmit beamformer is caused to fire one or more acoustic lines in each transmit event and the receive beamformer is caused to generate in phase and quadrature I and Q information along one or more scan lines. Alternatively real value signals may be generated. A complete frame of information corresponding to a two dimensional representation a plurality of scan lines is preferably acquired before information for the next frame is acquired. The real time controller is also used to manage the data flow created by the receive beamformer as it collects image information making the stream of data available to the back end subsystem .

Upon the firing of one or more ultrasound scan lines into the subject some of the acoustical energy is reflected back to the transducer . This reflected acoustical energy is detected by the transducer and converted into electrical signals which are passed to the receive beamformer . In addition to receiving signals at the fundamental frequency i.e. the same frequency as that transmitted the non linear characteristics of tissue or optional contrast agents also produce responses at harmonic frequencies. Harmonic frequencies are frequencies associated with non linear propagation or scattering of transmit signals. As used herein harmonic includes subharmonics and fractional harmonics as well as second third fourth and other higher harmonics. Fundamental frequencies are frequencies corresponding to linear propagation and scattering of the transmit signals of the first harmonic. Non linear propagation or scattering corresponds to shifting energy associated with a frequency or frequencies to another frequency or frequencies. The harmonic frequency band may overlap the fundamental frequency band.

The baseband processor is coupled with the receive beamformer and receives the converted electrical signals representative of the reflected acoustical energy. The baseband processor passes information associated with a desired frequency band such as the fundamental band or a harmonic frequency band. In one embodiment the baseband processor may be included as part of the receive beamformer . Furthermore the baseband processor demodulates the summed signals to baseband. The demodulation frequency is selected in response to the fundamental center frequency or another frequency such as a second harmonic center frequency. For example the transmitted ultrasonic waveforms are transmitted at a 2 MHz center frequency. The summed signals are then demodulated by shifting by either the fundamental 2 MHz or the second harmonic 4 MHz center frequencies to baseband the demodulation frequency . Other center frequencies may be used. Signals associated with frequencies other than near baseband are removed by low pass filtering. As an alternative or in addition to demodulation the baseband processor provides band pass filtering. The signals are demodulated to an intermediate frequency IF e.g. 2 MHz or not demodulated and a band pass filter is used. Thus signals associated with frequencies other than a range of frequencies centered around the desired frequency or an intermediate frequency IF are filtered from the summed signals. The demodulated or filtered signal is passed to the additional processors and as either the complex I and Q signal or other types of signals such as real value signals. It should be noted that band pass filtering as well as other types of data filtering known in the art should not be confused with the filter elements of the pipes and filters framework disclosed herein. As known in the art filtering data involves allowing data with certain characteristics to pass while blocking data without those characteristics. On the other hand while the filter elements discussed below may perform functions similar to those provided by the band pass processor the filter elements as used by the architecture described herein are more general processing stages that manipulate transform or enrich streaming data.

By selectively filtering which frequencies are received and processed the backend subsystem produces images with varying characteristics. In tissue harmonic imaging no additional contrast agent is added to the target and only the nonlinear characteristics of the tissue are relied on to create the ultrasonic image. Medical ultrasound imaging is typically conducted in a discrete imaging session for a given subject at a given time. For example an imaging session can be limited to an ultrasound patient examination of a specific tissue of interest over a period of to 1 hour though other durations are possible.

Tissue harmonic images provide a particularly high spatial resolution and often possess improved contrast resolution characteristics. In particular there is often less clutter in the near field. Additionally because the transmit beam is generated using the fundamental frequency the transmit beam profile is less distorted by a specific level of tissue related phase aberration than a profile of a transmit beam formed using signals transmitted directly at the second harmonic.

The harmonic imaging technique described above can be used for both tissue and contrast agent harmonic imaging. In contrast agent harmonic imaging any one of a number of well known nonlinear ultrasound contrast agents such as micro spheres or the Optison agent by Nycomed Amersham of Norway are added to the target or subject in order to enhance the non linear response of the tissue or fluid. The contrast agents radiate ultrasonic energy at harmonics of an insonifying energy at fundamental frequencies.

The echo color flow and digital signal processors are coupled with the baseband processor and receive the filtered signals from the transducer receive beamformer . The digital signal processor comprises one or more processors for generating two dimensional Doppler or B mode information. For example a B mode image a color Doppler velocity image CDV a color Doppler energy image CDE a Doppler Tissue image DTI a Color Doppler Variance image or combinations thereof may be selected by a user. The digital signal processor detects the appropriate information for the selected image. In one embodiment the digital signal processor is adapted for Doppler processing and a B mode processing. As known in the art the Doppler processing estimates velocity variance of velocity and energy from the I and Q signals. As known in the art the B mode processing generates information representing the intensity of the echo signal associated with the I and Q signals. The echo processor performs baseband and amplitude mode signal processing of RF and IQ data in a known manner. The color flow processor adds color to the acquired information as known in the art.

The information generated by the echo color flow and digital signal processors is provided to the scan converter . Alternatively the scan converter includes detection processes as known in the art and described in U.S. Pat. No. 5 793 701 entitled METHOD AND APPARATUS FOR COHERENT IMAGE FORMATION assigned to the assignee of the present invention the disclosure of which is herein incorporated by reference. The scan converter is of a construction known in the art for arranging the output of the signal processors and into two dimensional representations or frames of image data. The scan converter converts acoustic ultrasound line data typically in a polar coordinate system into data which may be plotted on a Cartesian grid. Using volume averaging or other similar algorithms on the returned echo data the slice information is merged into a single 2D plane. This permits display of the ultrasound image on a two dimensional output device such as a display monitor . Preferably the scan converter outputs formatted video image data frames using a format such as the DICOM Medical industry image standard format or a TIFF format. Thus the plurality of two dimensional representations is generated. Each of the representations corresponds to a receive center frequency such as a second harmonic center frequency a type of imaging such as B mode and positional information. The harmonic based representations may have better resolution and less clutter than fundamental images. By suppressing the harmonic content of the excitation signal the benefits of harmonic imaging of tissue may be increased. In any event the scan converter provides its output to the PCI bus . In one embodiment the PCI bus is a standard peripheral component interconnect board as known.

The user interface is coupled with the system controller and includes one or more input devices which the clinician sonographer physician uses to interface with the ultrasound system . The user interface includes input devices such as a keyboard mouse trackball touch screen or other input devices or combinations thereof as are known in the art. Further the user interface may also include graphic user interface GUI elements coupled with the input devices and with the display for both input and output functions. In addition to controlling the ultrasound functions of the ultrasound system the user interface may afford the user the opportunity to modify graphical representations imaging planes and displays produced by the ultrasound system . Finally the user interface allows the user to coordinate multiple ultrasound probes .

The system controller is coupled with the front end subsystem the backend subsystem the PCI bus and the user interface and controls and coordinates the functions of the ultrasound subsystems. The term system controller broadly refers to the appropriate hardware and or software components of the ultrasound system that can be used to implement the preferred embodiments described herein. It should be understood that any appropriate hardware analog or digital or software can be used and that the embodiments described herein can be implemented exclusively with hardware. Further the system controller can be separate from or combined with in whole or in part other processors of the ultrasound system including attendant processors which are not shown in for simplicity.

The various elements of the ultrasound system including the front end subsystem backend subsystem and user interface are controlled in real time by the system controller . The system controller controls the operation of the components of the system . A user via the user interface can adjust imaging parameters such as but not limited to image depth image width and frame rate. The controller interprets the set up information entered by the user and configures the components of the system accordingly.

The video processor acts as an interface between the system controller and the display . In various embodiments the video processor can be configured to work with a variety of display types such as cathode ray tubes or liquid crystal displays. The video processor can also be configured to output information to a printer memory storage device such as a computer storage device or a video recorder computer network or other means for communicating data representative of an ultrasonic echo known in the art. The display monitor is connected to the display controller and is a standard display monitor as known in the art. In alternate embodiments the display can be replaced with a printer memory storage device or any other output device known in the art.

The ultrasound stream manager is further coupled with the display controller and the operating environment and acts as the interface between the acquisition hardware the operating environment and the display controller . Effectively the ultrasound stream manager is an Application Programming Interface API to the ultrasound system and manages the inputs and outputs of the operating environment providing data inputs from the acquisition hardware and facilitating data output to the display controller or other output or storage device coupled with the system locally or via a network. It should be noted that while the embodiments described herein comprise an ultrasound stream manager working with an ultrasound streaming application utilizing a pipes and filters framework the disclosed ultrasound stream manager may also be used with non pipes and filters based applications and frameworks and is capable of interacting with multiple applications of various types. Furthermore the pipes and filters applications and framework disclosed herein may be implemented so as to access system resources without using the ultrasound stream manager . In one embodiment outputs from the operating environment may be provided via the ultrasound stream manager to the acquisition hardware such as for use in control feedback applications. The ultrasound stream manager provides an abstracted interface between the operating environment and various sources of data within the ultrasound system . In one embodiment these sources of data include the user interface imaging probe output receive beamformer output baseband processor output echo processor output color flow processor output digital signal processor output pre scan converter post scan converted or audio and video streams from the video processor output. Additional hardware may be provided for acquiring waveform streams such as ECG EKG streams. It will be appreciated that the ultrasound stream manager may provide abstracted interfaces as described herein to any point within the ultrasound system . For example an interface may be provided to the raw data stream prior to processing by the receive beamformer prior to processing by the filter block prior to Doppler or B Mode processing and or prior to scan conversion.

In one embodiment the ultrasound stream manager forwards the live display stream provided by acquisition hardware to the display controller for substantially immediate display. Substantially simultaneously the data from the acquisition hardware is made available to the operating environment of the system processor for further processing as will be described below. In an alternate embodiment the user may select whether to view the live display stream or to view the live display stream in combination with or in place of the processed display stream described below . In yet another embodiment the user may also select whether to display multiple processed streams the disclosed embodiments being capable of displaying such streams synchronously. In one embodiment the ultrasound stream manager is implemented as a combination of software and hardware. It will be appreciated however that the ultrasound stream manager may be implemented entirely in software or entirely in hardware.

The operating environment is a logical environment in which ultrasound applications operate receiving and or processing ultrasound data and optionally generating one or more data outputs. The operating environment is an architecture which defines operating rules and provides programmatic constructs e.g. the ultrasound stream manager for interfacing with the ultrasound system . Effectively the operating environment is similar to the operating system of a conventional personal computer. The operating environment generally comprises one or more applications that process the ultrasound data streams optionally provided by the ultrasound stream manager or provided directly from the acquisition or storage hardware. The processed ultrasound data streams from the applications are then directly forwarded to the display controller or other outputs not shown or optionally provided back to the ultrasound stream manager in order to be forwarded to the display controller or other outputs not shown . Utilizing the data flow of this embodiment the display is able to display both the raw image produced by acquisition hardware as well as the information processed by the system controller i.e. the one or more applications in real time. In alternate embodiments other output devices may be provided in addition to or in place of the display such as alternative output devices such as printer or projector storage devices such as a CD DVD or video recorder computer storage device a remote network device a CPU buffer of an ultrasound system a memory or software components such as another application .

The operating environment may also be configured to receive system configuration information via global variables. Parallel processing specialized processors such as DSPs ASICs and FPGAs and distributed processing can all be utilized by the operating environment . In one embodiment operating environment allows multiple applications to run in parallel.

As used herein the terms sequential and incremental are used to refer to applications or computer operating environments architectures which operate incrementally on data streams i.e. operate on a portion of the data or a subset thereof in the stream as it is received and generating an output before processing the next data portion or subset thereof. Typically a sequential or incremental application is implemented as described herein as a series of processing stages each stage consuming its input from a source or prior stage and generating an output to a sink or to the next stage before consuming and processing the next input. This is distinguished from the use of the term sequential for computer architectures to distinguish these architectures from parallel processing architectures which generally refer to the way in which computer program code is executed by the architecture both of which may be used to implement the disclosed sequential incremental processing environment. In the disclosed architecture multiple streams may be incrementally sequentially processed wherein the incremental processing of each stream occurs in parallel with the incremental processing of the other streams.

As will be discussed the operating environment supports the execution of conventionally written applications sequentially written applications and or applications written using both sequential and conventional programming code and techniques. Applications receive input data process that data and generate output data. Conventional application receive all or a portion of the input data and process that data through a collection of interdependent functions and or procedures and then generate data outputs. Sequential incremental applications receive the input data in succession i.e. incrementally over time and process each input datum as it arrives through a series of independent processing stages the last stage of which generates the data outputs. A mixed application combines a conventional application with one or more sequential functions or applets. Although each processing stage must wait for the previous stage to generate its output before processing that output the processing performed by the particular stage is independent of the other stages i.e. is self contained and does not involve the other stage e.g. the previous stage is free to accept and process additional input. These applets perform specific tasks for the conventional application which are better performed sequentially. For example processing ultrasound data generated by the acquisition hardware in real time may be better performed by a sequential application or applet which can process the data as it arrives from the acquisition hardware in real time.

Each of the one or more applications comprises sequential program code and or conventional program code . As described above sequential program code comprises a series of one or more processing stages . Each processing stage has at least one input and at least one output. The input of a processing stage is coupled to either a source or another processing stage . Each of these stages performs one function on the data provided to it and then passes the data to either another processing stage or to a data sink . Processing stages are interconnected with abstract communication interfaces that facilitate the transmission of data between processing stages . Each processing stage may be stateless or stateful as will be described. It will be appreciated that each processing stage may perform more than one function may operate on more than one piece of data at any given time and may employ feedback to re process the output s or maintain state. Sequential program code is characterized by the way it handles data. Sequential program code processes i.e. consumes and delivers data incrementally. In one embodiment the sequential program code is adapted to interact with conventional program code .

Conventional program code is also characterized by the way it handles data. Conventional program code consumes substantially all of its input before producing any output. The data processed by conventional program code can then be forwarded to a sink or back to the sequential program code . It should be apparent to one skilled in the art that the logical interconnection between the conventional program code and the sequential program code is implementation and application specific e.g. the data provided to conventional program code can be taken from any processing stage and can be sent back to the sequential program code segment at any processing stage . Alternatively any function performed by conventional program code can be performed by processing stages . In one embodiment of the present invention sequential program code is implemented using a pipes and filters framework as described below. It will be appreciated that for a given application there may be more than one conventional code segment and or more than one sequential code segment and further that multiple applications may share sequential or conventional program code segments and .

A pipes and filters framework also referred to herein as an architecture divides the task of a system i.e. an application program into several sequential processing stages. It will be appreciated that a pipes and filters architecture defines a logical structure for application development and implementation as well as a logical environment in which applications so constructed may be executed. It will be further appreciated that the underlying physical implementation of the pipes and filters architecture may depend on the underlying hardware and programming environment on top of which the pipes and filters architecture is implemented and all such physical implementations and programming environments are contemplated including the ultrasound system described herein. These stages are in one sense logically coupled with each other by the data flow through the system the output of one stage is the input to the subsequent stage.

Each processing stage is implemented by a filter component. A filter consumes and delivers data incrementally in contrast to consuming all of its input before producing any output to achieve low latency and enable real parallel processing. The input of the system is a data source such as the ultrasound transducer or a stored file. The output flows into a data sink such as a file terminal animation program and so on. Data source filters and data sink filters are abstractions of the actual data sources and data sinks of the system. All filters are logically interconnected by pins. Pins facilitate the flow of data between adjacent processing stages. A sequence of interconnected processing filters between a data source filter and data sink filter is referred to as a processing pipeline or pipeline. A pipeline may optionally contain pipes and allocators. As will be described below data source filters data sink filters processing filters pipes pins and allocators are logical programmatic constructs which are abstractions of actual programming code and or hardware elements of the physical system in which the pipes and filters architecture is implemented. It will be appreciated that each of these constructs may be actually implemented in many different ways depending as described above upon the physical implementation and programming environment and that the functionality of two or more of these constructs may be combined into a single construct or that any one of these constructs may be further logically divided into two or more additional constructs each performing part of the functionality of the larger construct.

A data source filter is a construct which provides data to one or more filters either through pins or a combination of pins and pipes described in more detail below. In one embodiment a data source filter may be implemented as a filter whose function is to provide data to the pipeline from a physical data source within the system. Data sources filters are abstractions of actual sources of data i.e. system outputs from within the hardware and or software of the ultrasound system. The pipes and filters architecture manages the actual interface between a particular data source filter and the actual source of data it represents i.e. provides access to the actual data and allows control over the flow of data. Effectively a data source filter is a tap into a particular point in the ultrasound system from which data may be siphoned and directed to one or more applications with or without affecting the system operation. In one embodiment an ultrasound stream manager is provided described in more detail below which manages the available data sources and data sinks described below. It should be noted that while the ultrasound stream manager is adapted to manage data sources and data sinks data source filters and data sink filters can be managed directly by an application . Effectively a data source filter is a standardized Application Programming Interface API to some output point within the ultrasound system. Applications that require data from a particular source within the ultrasound system need only know how to interact with the corresponding data source filter. Standardization of the data source filter interface permits modularity among applications and sources of data. For example an application designed to operate on a live data stream from the ultrasound transducer is equally capable of operating on a pre recorded data stream supplied from a storage device. In this case the user may choose which data source filter to connect the application to or the application itself may provide functionality to allow the user to switch among different data source filters. Data source filters may provide inputs such as flow control inputs which allow applications to control the flow of data from the data source or other inputs to control other aspects of the data source.

Data sources include live data sources such as the transducer output stored data sources such as a hard disk and sources available via a network interface either wired or wireless of the ultrasound system such as remote ultrasound systems or remote storage devices. A particular source of data may be shared among multiple applications by creating more than one data source filter associated with the particular source of data. In one embodiment data sources filters are created on demand i.e. when an application requests access to a particular source of data. In one embodiment data sources may be cloned wherein the cloned data source is copy of the original data source but may not be modified. Exemplary sources of data include both hardware i.e. physical sources and software i.e. logical sources such as user interface inputs B Mode image data Color Mode image data BC Mode image data Doppler image data M Mode image data pre scan converted data RF data IQ data waveform data such as Doppler derived ECG EKG pulse respiratory function and other physiological waveforms phono auxiliary audio and video data. B Mode image data comprises a rectangular array of pixels depicting the intensity of the echo data acquired by the transducer. Color Mode image data displays the velocity and the magnitude of the echo data. In BC Mode both the Brightness and Color components are displayed in a single image. Doppler image data comprises frequency analysis of the echo data. M Mode image data represents a cross sectional view of a given location being scanned. Pre scan converted data is the data signal being supplied to the scan converter . RF data is the raw echo samples. IQ data is data derived from the RF signal and represents the magnitude and direction of the echo. Waveform data can be any waveform that can be encoded as a pair of coordinates for each column on the display. Typically waveform data is used to represent ECG EKG and Doppler derived images. Video data is a digital video sample representative of luminance and chrominance. Audio data is an amplitude representation of an audio signal. The data provided by a particular data source is characterized by various properties. The data may be streaming data such as a live feed from the transducer or non streaming data such as a system control variable or user interface control setting. In one embodiment streaming data is further characterized by a data format a frequency or rate and or a number of image bytes per sample. As will be described the data source via the ultrasound stream manager normalizes the data received from the source of data to a general data format and controls the data flow.

It will be appreciated that the possible sources of data and the number of data source filters associated with the available sources of data is implementation dependent. In one embodiment the sources of streaming data and the number of data source filters that can be associated with the available sources of the streaming data are limited and fixed by the architecture. In this embodiment the streaming data sources include 2D image data trace stream data Doppler and M Mode and waveform data. Up to four data streams may be defined for the 2D data stream referred to as Streams . In this embodiment the video hardware of the ultrasound system is limited to displaying a maximum of four 2D streams acquired at any given time. Up to two data sources may be defined for the trace stream data referred to as Streams and and up to three data sources may be defined for waveform data referred to as Streams . Further in one embodiment the trace stream data sources utilize one of the 2D stream data sources such that when using the trace data source only three of the four 2D data sources are available. Further M Mode and Doppler cannot be displayed simultaneously. Each waveform data source can acquire up to two waveform data streams.

A data sink is similar to a data source but receives data from one or more filters either through pins or a combination of pins and pipes described in more detail below. Data sink filters are abstractions of actual inputs to other parts of the hardware and or software of the ultrasound system . The pipes and filters architecture manages the actual interface between a particular data sink filter and the actual system output it represents i.e. provides access to the output and provides control over the flow of data. Effectively a data sink is a tap into a particular point in the ultrasound system into which data may be introduced by one or more applications with or without affecting general system operation. As will be described below in one embodiment the available data sinks are managed by an ultrasound stream manager . Effectively a data sink filter is a standardized API to some output point within the ultrasound system. Applications that need to send data to a particular output within the ultrasound system need only know how to interact with the corresponding data sink filter. As with data sources standardization of the data sink interface permits modularity among applications and data outputs. For example an application designed to display data on a video display is equally capable of sending its output to a video recorder. In this case the user may choose which data sink filter to connect the application to or the application itself may provide functionality to allow the user to switch among different data sinks via their corresponding filter s .

Data sinks include live data sinks such as a video display or user interface graphic user interface or other system indicators stored data sinks such as a hard disk or video recorder and sinks available via a network interface either wired or wireless of the ultrasound system such as remote ultrasound systems remote terminals remote displays or remote storage devices. A particular output sink to the ultrasound system may be shared among multiple applications by creating more than one data sink filter associated with the particular sink. The architecture via the ultrasound stream manager detects and prevents conflicts among the various applications . In one embodiment data sink filters are created on demand i.e. when an application requests access to a particular system input. Exemplary system outputs include the ultrasound display via the video controller a video recorder output a remote network device a memory or processor buffer a memory or processor register a printer or a storage device. The data required by a particular system output is characterized by various properties. The output may accept streaming data such as a processed live feed from the transducer or non streaming data such as a system control variable or user interface control setting. In one embodiment streaming data is further characterized by a data format a frequency or rate and or a number of image bytes per sample. As will be described the data sink filter or optionally the ultrasound stream manager makes the necessary conversion of the data from the application to the format required by the system input.

It will be appreciated that the possible system outputs and the number of data sink filters associated with the available system outputs is implementation dependent. In one embodiment the data sinks may include a video displayer filter for rendering video clips an AVI writer filter for writing compressed clips to disk in the AVI format a shared memory filter for allowing another process to access the video clip or a DICOM shared memory filter for allowing another process to access a video clip formatted according to DICOM specifications.

Note that where multiple pipelines are implemented within a single application or among multiple applications a data sink filter may be created for one pipeline which is also the data source filter of another pipeline. In this way pipelines may be interconnected with the same modularity as described above.

The ultrasound stream manager USM acts as an interface between applications and the actual ultrasound system hardware and or software. The USM manages the creation and operation of data sources and sinks as described above. In one embodiment applications register with the USM when they are first executed. The applications then make requests to the USM for the creation of various data sources and data sinks to particular sources of data and system inputs. By registering with the USM the USM need not be pre configured with knowledge of which applications are present and operating in the system. Registration also permits an application to be part of the ultrasound hardware control sequence. The USM further permits multiple applications to coexist and execute substantially simultaneously and share sources of data and system outputs or sinks. Communication among applications may also be supported.

Further the USM acts as a control interface for the data sources and sinks allowing the applications to control the flow of data. Applications use the USM interface to interact with hardware specific sources and sinks. Applications may have on demand access to data sources or sinks either synchronously or asynchronously. In one embodiment this access is provided via an Asynchronous Completion Token software design pattern. In one embodiment a token object is created by USM and passed as part of a notification method invoked upon the arrival of a frame from the acquisition hardware . The USM maintains the abstraction of the actual ultrasound system hardware and or software freeing the applications from the complexities of obtaining inputs and transmitting outputs to the system. As described above the USM may provide access to any ultrasound specific source of data and any system input within the ultrasound system. Further the USM may provide normalization and data conversion such that the applications may use a generic data format. The USM normalizes input data from the specific source data format into the generic data format and converts output data from the generic format into a format compatible with the particular system output. For network based data sources or sinks Quality of Service QOS protocols may be implemented to maintain real time streaming data flow. For output to a video display the USM allows the application to specify the display precision such as in terms of the vertical synchronization signal of the video display hardware. In the case of displaying concurrent data streams on the video display the USM synchronizes the concurrent streams allowing them to share the display in multiple windows wherein each display of each data stream is synchronous with the others.

The USM further implements data stream management features to handle high bandwidth data streams i.e. large and or fast data streams. In particular for applications which are unable to process data streams at their native rate either because the rate is too fast or the application is slowed by competition for system resources the USM implements a store and notify function to permit the application to catch up once additional system resources become available. Further in one embodiment the USM may buffer data streams using two or more fixed capacity buffers which alternate between buffering the data stream and providing the data stream to the applications . The alternating ping pong approach enables handling of large long data streams that would otherwise exceed the capacity of a single buffer. In particular this enables use of the ultrasound system as a playback device for pre recorded data streams.

Referring back to the pipes and filers architecture filter components or filters are the processing stages of the pipeline which process data incrementally. A filter is an encapsulated processing step stage or function. Filters may have the ability to maintain state or operate statelessly. Filters can be source filters which generate data transform filters which manipulate or transform data e.g. convert between semantically equivalent format data representations or sink filters which store or render data. Other filter types are also possible such as an observer filter that monitors pipeline data and notifies client software when a data item of interest is being processed. The function implemented by a filter may generate data samples or provide data samples from the ultrasound system source filter transform data samples transform filter or sort render or otherwise output samples sink filter . Other filters coupled between the source and sink filters receive one or more inputs from data source filters described above or other filters and generate one or more outputs to other filters or to data sink filters. Filters connect to other pipeline components using pins. Pipeline components include filters and pipes described below. Filters can be either abstract or concrete. An abstract filter defines the interfaces and common behavior for a group of similar filters i.e. acts as a template while a concrete filter is an actual implementation of the specific behavior for a given application or group of applications. Using a filter abstraction enables a filter pipeline to be programmed generically so that filters and pipeline behavior can be changed at runtime because all filters share common connection and control interfaces. A concrete filter implements the function for the filter as described above.

Filters can be characterized as either active or passive. An active filter starts processing on its own as a separate process or thread. Active filters may be triggered by the availability of data the demand for data by a subsequent filter or some other event or signal. Passive filters on the other hand are activated by being called either directly or indirectly by an upstream filter push or a downstream filter pull . Depending on the classification of the filter the activity of a filter will be triggered by several events. A passive filter will be activated by the subsequent pipeline element pulling output from the filter or the previous pipeline element pushing new input data to the filter. Active filters pull their input from and push their output down the pipeline.

Functions performed by exemplary filters of one embodiment of the present invention include but are not limited to determining end systolic end diastolic peak systolic and peak diastolic values. Filters can be used to calculate maximum and minimum amplitudes for various streams based on temporal rules as well as determining other stream characteristics. Filters can combine an ECG stream with a 2D stream to create composite information. Notification filters can also be implemented to monitor either the activity of other filters in or the data of the pipeline. Other functions performed by exemplary filters can include video image sourcing video image compression video image decompression AVI format writing and shared memory sinking.

Pipes may be used to interconnect one filter with another filter a data source with the first filter s and or the last filter s with a data sink. Pipes provide a way to buffer data between threads and processes that are asynchronous. This synchronization is accomplished by implementing a first in first out FIFO buffer. Pipes can hold data until a subsequent filter requests it and block previous filters from operating if its buffer is full.

Pipes can be implemented in a variety of ways. Pipes can provide program to program messaging using shared memory. Furthermore pipes can be designed as message passing buffers. Pipes can be TCP IP based and can allow for object to object communication. While all pipes must have at least one input and at least one output multiple inputs and outputs are also possible. For example a T pipe i.e. a pipe with two outputs can be utilized to send the result of one processing stage to multiple subsequent filters. Reverse T pipes can likewise be used to synthesize data from multiple filters. Feedback pipes may also be provided to feed data outputs back as inputs to a previous filter.

Pins are abstract connection points between filters or between filters and pipes. Pins are able to negotiate the type of data that will be transferred between filters to make sure adjacent filters in the processing pipeline are compatible. By creating these abstract interfaces arbitrary filters are able to connect in a safe manner that ensures compatibility and eliminates the physical dependencies between filters. The interfaces provided by the pin elements make filters reusable enabling an application developer to configure an arbitrary set of filters at run time. Allocators provide physical memory for the filters and pipes to work with. Abstract allocators provide an interface and concrete allocators implement that interface for an application or group of applications.

While provide some basic examples of pipelines and their behaviors it should be apparent to one skilled in the art that many alternate pipeline configurations are possible for use in a diagnostic medical ultrasound system according to the disclosed embodiments. Various pipelines may include any combination of active or passive filters and pipes. The pipeline itself may include feedback loops. Multiple paths can be present in a pipeline through the use of T and reverse T filters or pipes.

As mentioned above the acquisition hardware provides a stream of data representative of the succession of received ultrasonic echoes for use by an ultrasound streaming application according to one embodiment of the present invention. Alternatively data can be introduced into an ultrasound streaming application or sourced from storage devices such as a disk tape or memory buffer. Alternatively data may be sourced from a network device. Furthermore the data provided by acquisition hardware can represent any ultrasound data. Examples included but are not limited to B mode C mode BC mode Doppler M mode pre scan converted RF and IQ data. The data can also be representative of waveforms such as ECG EKG pulse respiratory functions phone audio video and auxiliary data.

An application is a software program designed to implement one or more tasks in the ultrasound system . Applications may include either sequential or conventional code or combinations thereof. The sequential code is preferably structured in accordance with the pipes and filters architecture described herein and as will be described below the pipe and filters architecture provides a development and execution environment in which such code can easily be developed and implemented. In this regard a typical application includes at least one pipeline comprising one or more filters and pins and optionally pipes and allocators. Data is streamed from a data source processed by the filter elements of the pipeline and streamed to a data sink to implement the given task of the particular application . In applications which utilize both conventional and sequential code the sequential code may be contained within sub applications or applets which are utilized by the conventional code for specific processing tasks such as processing streaming data in real time. Outputs of the applets may be fed back to the conventional code and or sent directly to a data sink. Applets may operate asynchronously from the conventional code and from other applets. The application may utilize multiple sequential code applets operating concurrently wherein optionally the conventional code is used to facilitate communications between applets. In one embodiment the pipes and filters operating environment provides a library of applets which may be utilized by any application . Further in another embodiment applets are created from the applet library at the time of invocation thereby allowing multiple instantiations of the same applet by one or more applications .

As discussed above the USM of the disclosed embodiments provides stream arbitration services capable of being called on by one or more applications concurrently. These services abstract and provide applications access to the ultrasound system to receive streaming data system configuration parameters and or user interface input and to output data back to the ultrasound system to be used to control the system presented to the user and or stored. These services can be used to manage all data inputs and outputs regulate data flow either autonomously or under application control and normalize and de normalize input and output data formats. The USM is designed to transparently optimize the execution of applications such as by taking advantage of system hardware such as specialized co processors floating point processors digital signal processors etc. parallel or multithreaded processing functionality. The USM further decouples the applications from the ultrasound system outputs and system inputs thereby increasing the flexibility of the applications to work with different inputs and outputs as described above without recoding or recompiling the application . When interacting with multiple applications the USM ensures that each application is allocated appropriate resources and that resource contention is managed.

Further the disclosed operating environment provides for robust error handling maintaining data integrity isolating and reporting errors and preventing errors in one application from corrupting other applications currently executing. In one embodiment an error logger thread is registered with each buffered pipe and filter which detects errors and places an error object corresponding to the type of error observed in an error handling queue. Each error object includes meta data that describes the error and the state of the filter pipe. A dedicated error handler thread processes errors in the error handling queue and takes appropriate action depending on the severity of the error. In one embodiment the error logger and the error handler are allowed to operate in different threads to avoid thread deadlock issues. Deadlock issues can occur when the error handler determines that the best course of action is to shutdown an entire pipeline and discard any data in the pipeline at the time the error occurred. If the pipeline contains any active filters that operate in their own thread shutdown of the thread is non trivial unless the error handling resides in a separate thread context. In another embodiment the environment may provide for redundant operation to protect mission critical applications.

Other features of the pipes and filters architecture environment include allowing the recombination and reuse of defined filters and pipes as well as allowing filters to be dynamically modified or swapped in and out at run time. The environment further permits the sharing of state information between filters and between applications . In one embodiment a symbol table is provided for allowing filters to store and maintain state for themselves or for an application . In managing the data inputs and outputs the USM permits applications to request dedicated access to specific data streams and modify the properties of those data streams. In embodiments wherein the number of data streams is limited the environment provides functionality to allow applications to release data streams no longer needed and reallocate those data streams to other applications .

Given the decoupled nature of the pipes and filters architecture environment a development environment may also be provided for facilitating the development of streaming applications . In one embodiment this development environment permits the development simulation and testing of applications with synthetic inputs and outputs such as media samples. This permits a developer to easily verify the operation of an application or set of applications in an environment which closely approximates the actual ultrasound system. Individual filters or pipelines or portions thereof can be tested in isolation prior to being incorporated into larger pipelines or applications . Further the development environment may provide a library of filters pipelines or applets which can be replicated recombined reused or shared among multiple pipelines or applications . In one embodiment the development environment permits the development of applications using standard object oriented programming techniques the library providing abstract and concrete classes of filters pipes pins media samples and allocators. The library may also provide standardized data transport protocols for pins pipes and media samples as well as ultrasound specific data types structures. Further the development environment provides for separate compilation of the application components allowing modification to portions of an application without having to recompile the entire application . In one embodiment the development environment includes a graphic user interface GUI . The GUI displays graphic representations of the application and or pipelines such as by using a filter graph making it easier for the developer to construct the application. In an alternate embodiment the development environment is capable of operating on an ultrasound system or a conventional computer system.

The CPU buffer of the system controller can be any type of buffer known in the art including static or dynamic memory. A wide variety of applications have access to the CPU buffer . These applications can be characterized as either display based applications or non display based applications . Display based applications create data to be displayed or stored by the ultrasound system via the VI board . These applications can include but are not limited to panoramic imaging 3D imaging or color imaging. Non display based applications do not send their results to the display via the VI board . Typical applications can include a beam profiler a TEQ equalizer Doppler analysis etc. Although the information generated by non display based applications is not forwarded to the display via VI Board this information can be used by display based applications .

The VI board comprises an application specific integrated circuit ASIC VPDM or video processor display manager two field programmable gate arrays the VI decoder FPGA and the VI encoder FPGA and a ColorKey mixer . In one embodiment the VPDM comprises megabytes of synchronous dynamic random access memory or SDRAM. The VPDM Video Processor Display Manager ASIC enables the display of overlay and the ultrasound images on the screen by using the color key from the video card output and the data from the Backend hardware subsystem or the stream manager s display stream. In alternate embodiments the VPDM can comprise various amounts of various types of memories known in the art. The encoder FPGA primarily sends a video composite signal to the VCR for recording. The decoder FPGA assists in getting a signal from the VCR to the VI board for display purposes and also assists in recording clips to the magnetic disk . The ColorKey mixer is used to incorporate color into the display images as is well known in the art. The ColorKey mixer synthesizes data from the VPDM as well as information from the graphics card . The graphics card takes information passed from the CPU buffer to the image displayer and processes the data for use by the VI board . The graphics card can be a standard graphics card as is known in the art such as a Matrox Millenium G400 with 32 MB of RAM an ASUS V7100 2VID with 32 MB of RAM or a LeadTek TI 4200 with 128 MB of RAM.

In one embodiment of the present invention the ultrasound stream manager comprises a CpuStream object and a StreamList Manager . In this embodiment the ultrasound stream manager creates a programmatic construct CpuStream for each stream of the system . Each CpuStream object contains a hardware processing interrupt a frame queue a request queue a queue thread handler and a frame metadata construction component . The two queues request queue and frame queue are first in first out FIFO circular queues. In one embodiment the queues comprise a physically contiguous non paged memory. The StreamList manager is coupled to each CpuStream instance and the various applications and acts as an interface between the two. When an ultrasound streaming application registers with the ultrasound stream manager it will request access to a stream by its number as described above. This request can be synchronous or asynchronous.

When data arrives from the acquisition hardware the hardware interrupt processing adds the data to the frame queue in the form of a programmatic construct FrameInfo not shown . This construct contains meta data associated with an incoming frame. In one embodiment this construct contains offset timestamp and cine address information for the data being acquired. The timestamp denotes the time the acquisition hardware acquires the information the cine address denotes the address of the frame in the pre scan converted buffer and the offset denotes the offset of the frame in relation to the beginning of the pre scan converted buffer. As requests from the request queue are serviced entries in the frame queue are removed. The entry could also be removed from the frame queue if buffer overrun occurs.

The ultrasound stream manager also has a queue thread handler running for each CpuStream object to service the asynchronous requests and to process pending synchronous requests. The queue thread handler is activated when a new request is added to the request queue or when data is added to the frame queue via the PCI bus . The queue thread handler will also notify the appropriate application provided a request is pending in the request queue when either a new frame is added to or there are unread frames in the frame queue . Frame MetaData Construction converts the physical address of the frame to a usermode address and incorporates this address as part of the frame meta data. The usermode address is a virtual address mapped by the ultrasound stream manager to a physical memory address. Frame MetaData Construction also converts the offset and cine address into a physical address and passes this address to the requesting application.

Initially the RecordingController creates the FilterGraph which manages connection and processing of abstract filter components. All pipeline components share a common abstract API for common operations such as starting stopping pausing resuming and flushing. Next the RecordingController creates each of the pipeline elements including all filters and pipes. The RecordingController registers a callback with the StreamMonitorFilter so that it can receive notifications when a desired number of frames has been processed by the pipeline. The RecordingController calls a method on the FilterGraph to add the components to the FilterGraph . Components are added in sink first order. As each component is added the FilterGraph queries a component s output pins to find a match with its downstream filter s input pins. A match occurs if the filters media types are compatible. If a match is found a connection is made. If a match is not found an exception is raised. Once all of the components have been added the pipeline is ready to capture a video clip.

The RecordingController calls the start method on the FilterGraph . The FilterGraph then sends this message to the VideoSourceFilter which is first filter in the pipeline. The VideoSourceFilter then propagates this call in a cascading fashion down the pipeline. As each active filter gets the message to start processing samples it activates it internal threads which immediately start to process data if available. As part of the start method the CompressionFilter is initialized and attempts to pull data from Pipe and the AviWriterFilter opens an output file and attempts to pull data from Pipe via an indirect call through the StreamMonitor . Finally the VideoSourceFilter enables the footer interrupt which starts the process of generating samples.

The ultrasound stream manager provides a frame of data to the VideoSourceFilter each time the footer interrupt occurs typically 30 or 60 times per second . The VideoSourceFilter completely encapsulates interaction with the ultrasound stream manager . The footer interrupts facilitate the USM s control over hardware interrupts on demand.

When the footer interrupt occurs the VideoSourceFilter takes the sample and calls the push method on its output pin. Since Pipe is the next component in the pipeline this effectively puts the sample in a queue. The VideoSourceFilter will continue to put samples in Pipe asynchronously as provided by the ultrasound stream manager . The CompressionFilter threads pull samples out of Pipe asynchronously as they become available. The CompressionFilter compresses the sample with the transform method and then pushes the result onto its output pin which places it in Pipe . The AviWriterFilter indirectly calls the StreamMonitorFilters pull method which forwards this request to Pipe . If a sample is available it is returned to the AviWriter which writes the data to the disk file.

For each sample that is passed down the pipeline the StreamMonitorFilter counts the sample and determines whether it needs to notify the RecordingController that the desired number of frames has been processed. Once the desired number of frames has been captured the StreamMonitorFilter notifies the RecordingController . The RecordingController then calls its own internal method checkIsDone to verify that the desired number of frames has been captured. If the clip has the desired number of frames the RecordingController calls stop on the FilterGraph which calls stop on the VideoSourceFilter . The VideoSourceFilter then disables the footer interrupt which tells the ultrasound stream manager to stop producing frames. The VideoSourceFilter then calls stop on downstream filters in a manner very similar to the starting the pipeline. On receiving the stop message the AviWriterFilter calls its writeHeader method to finalize the data and close the file.

The scan converter is coupled to the BE PCI board and processes both a Siescape stream a 2D stream and normal B mode data stream . The Siescape stream is passed to the backend PCI bus which makes the data accessible to the ultrasound stream manager . The pipes and filters architecture comprises data source filters data sink filters and a clip data source filter which encapsulate the source stream API and sink stream API of the USM . The data source filters make the data accessible to the ultrasound streaming application Siescape via the multiple 2D output streams . As discussed earlier each of the stream numbers correspond to a particular type of stream. Four output streams represent 2D streams. One output stream represents a trace stream. Three output streams represent waveform streams. Similarly ultrasound stream manager has multiple input streams for acquiring data output from the various ultrasound streaming applications employed in a given embodiment. In this embodiment three input streams represent waveform streams one input stream represents a trace stream and four input streams represent 2D streams.

Initially the ultrasound streaming application Siescape registers with the ultrasound stream manager and acquires data from the stream. Siescape then performs the various transform filters on the information. Namely the SieScape application performs a correlate function a rotate function a clip function and a paste function. In this embodiment the functions are performed as a pipeline in a pipes and filters framework. It should be readily apparent to one skilled in the art that these functions could be performed by sequential code segments as conventional code segments or as a combination of both. Once the data has been transformed by the SieScape application the information is sent back to the ultrasound stream manager via a 2D input stream.

Once this information is received by the ultrasound stream manager the information will be forwarded to the VPDM of the VI board . In this example the information is then sent to the clip recorder application by the VI FPGA via the source stream API and clip data source filter . The clip recorder application compresses the data with the transform filter and transmits the data to sink filter disk writer via output pin and input pin .

Another exemplary application which utilizes the pipes and filters architecture of the disclosed embodiments is an Automated Boundary Detection ABD application. An ABD application identifies the boundaries of an object represented by the ultrasound image data whether the image data is a live data feed from the transducer or prerecorded. For example when imaging the heart of a subject the ABD application can determine the boundaries of the heart i.e. the locations of the cardiac walls. This is useful for example to estimate the cardiac blood volume of the subject heart. Prior ABD applications could only operate on pre recorded image data either post scan converted or pre scan converted and therefore were incapable of operating in real time.

An ABD application implemented as a streaming application executing on an ultrasound system having the disclosed pipes and filters architecture is capable of processing the live image data stream either post scan converted or pre scan converted in real time increasing the usefulness of this diagnostic tool.

In operation the real time ABD application sets up data stream using the ultrasound stream manager by requesting a data source for live B mode image data either B mode or BC mode etc. The ABD application further instructs the ultrasound stream manager to simultaneously send the live B mode image data to the video display. An asynchronous notification handler is then enabled which gives full control of the data stream to the ABD application as described above. This enables acquisition of the image data on demand. The ABD application then determines the boundary or boundaries of the objects currently being imaged using techniques that are known in the art.

Once the ABD application receives control of the image data stream the ABD application may control data throughput by slowing or speeding up the acquisition rate for example if the clinician changes the rate at which they are moving the transducer over subject. Further the ABD application may specify a region of interest ROI on the data stream so it can control the amount of data being processed thereby increasing application performance. In one embodiment the ABD application may provide control feedback to the user or directly to the transducer for adjusting the beam steering or beam focus or other parameters of the image scan so as to achieve optimal imaging for boundary detection.

It will be appreciated that there are many known ultrasound applications which may be reconfigured to take advantage of the disclosed pipes and filters architecture. Further applications may be configured to use feedback to automate ultrasound functions control beam depth focus or steering select a region of interest or manipulate other parameters of the ultrasound system.

A clip playback application allows the user to view previously recorded video clips in order to perform diagnoses or to study ultrasound images. The application consists of a control component a playback source filter a decompression filter and a video displayer sink filter which encapsulates or hides calls to the USM s stream APIs .

As was described above the ultrasound stream manager acts as an API to the ultrasound system effectively abstracting the complexities of the ultrasound system from the various applications which are accessing the ultrasound data. depicts a logical block diagram of the diagnostic medical ultrasound system of showing the application interface to which the applications connect either locally or remotely such as via a network to access the ultrasound data as has been described. While the application interface is depicted separately from the ultrasound stream manager it will be appreciated that the application interface may be implemented within the ultrasound stream manager or separately and coupled with the ultrasound stream manager locally or remotely such as via a network. As has been described the ultrasound stream manager may further be local or remote from the various data sources acquisition hardware etc.

As was described post processing of the received echo information must either operate in a streamed fashion i.e. operate on the received echo data as it is received in real time or buffer store a portion of the received echo data and operate on that buffered stored portion. Additional properties of streams may include a source property and a sink property. Each stream must have a source and a sink the source being the location from which the stream originates and the sink being the location where the stream terminates. Sources may be further characterized as being live or stored . A live source is a source which is actually generating the stream typically in real time while a stored source is a source which stores a representation of a stream created at an earlier time. The stream sink may be the display CPU memory or other storage or processing device. A stream may also be classified as a clone of another stream. Cloned streams are copies of streams used to provide multiple applications with access to a particular stream s data. The original stream will be owned by the first application who gains access to it meaning that application will be able to alter various stream properties such as acquisition rate. An application can alter these properties by communicating with the actual data source acquiring the information either directly or through an ultrasound stream manager as described below. If another application desires the data contained in the same stream a clone will be made. In one embodiment a cloned stream differs from a copy of a stream in that the cloned stream s properties depend on the properties of the original stream. The second application receiving the cloned stream is not permitted to communicate directly with the acquisition hardware as it does not own the stream. In other words the application processing the cloned stream is only permitted to alter the cloned streams properties within the boundaries of the properties of the original stream. In contrast some or all of the properties of a copy of a stream may be altered independently of the original stream.

As was described with respect to shows one embodiment of the logical structure of the system controller and the data flow of one embodiment of the diagnostic medical ultrasound system . As discussed above the system includes the acquisition hardware the system controller the display controller and the display . In one embodiment the system controller logically includes an ultrasound stream manager application interface and one or more operating environments . The acquisition hardware is coupled with the ultrasound stream manager and acquires ultrasound data and provides the data in the streaming fashion discussed above to the ultrasound stream manager . In an alternate embodiment the acquisition hardware may include a storage device such as a computer disk drive or video recorder which stores previously acquired ultrasound data.

The ultrasound stream manager is further coupled with the display controller and the operating environment and acts as the interface between the acquisition hardware the operating environment and the display controller . Effectively the ultrasound stream manager in concert with the application interface is an Application Programming Interface API to the ultrasound system and manages the inputs and outputs of the operating environment providing data inputs from the acquisition hardware and facilitating data output to the display controller or other output or storage device coupled with the system locally or via a network. It should be noted that while the embodiments described herein comprise an ultrasound stream manager working with an ultrasound streaming application utilizing a pipes and filters framework the disclosed ultrasound stream manager may also be used with non pipes and filters based applications and frameworks and is capable of interacting with multiple applications of various types. Furthermore the pipes and filters applications and framework disclosed herein may be implemented so as to access system resources without using the ultrasound stream manager . In one embodiment outputs from the operating environment s may be provided via the ultrasound stream manager to the acquisition hardware such as for use in control feedback applications. The ultrasound stream manager and application interface provide an abstracted interface between the operating environment s and various sources of data within the ultrasound system . In one embodiment these sources of data include the user interface imaging probe output receive beamformer output baseband processor output echo processor output color flow processor output digital signal processor output pre scan converter post scan converted or audio and video streams from the video processor output. Additional hardware may be provided for acquiring waveform streams such as ECG EKG streams. It will be appreciated that the ultrasound stream manager and application interface may provide abstracted interfaces as described herein to any point within the ultrasound system . For example an interface may be provided to the raw data stream prior to processing by the receive beamformer prior to processing by the filter block prior to Doppler or B Mode processing and or prior to scan conversion.

In one embodiment the ultrasound stream manager forwards the live display stream provided by acquisition hardware to the display controller for substantially immediate display. Substantially simultaneously the data from the acquisition hardware is made available to the operating environment s of the system processor via the application interface for further processing as will be described below. In an alternate embodiment the user may select whether to view the live display stream or to view the live display stream in combination with or in place of the processed display stream described below . In yet another embodiment the user may also select whether to display multiple processed streams the disclosed embodiments being capable of displaying such streams synchronously. In one embodiment the ultrasound stream manager application interface is implemented as a combination of software and hardware. It will be appreciated however that the ultrasound stream manager application interface may be implemented entirely in software or entirely in hardware.

The operating environment s is a logical environment in which ultrasound applications operate receiving and or processing ultrasound data and optionally generating one or more data outputs. The operating environment is an architecture which defines operating rules and provides programmatic constructs e.g. the ultrasound stream manager and application interface for interfacing with the ultrasound system . Effectively the operating environment s is similar to the operating system of a conventional personal computer. The operating environment s generally comprises one or more applications that interface with the application interface to process the ultrasound data streams optionally provided by the ultrasound stream manager or provided directly from the acquisition or storage hardware. The processed ultrasound data streams from the applications are then directly forwarded to the display controller or other outputs not shown or optionally provided back to the ultrasound stream manager via the application interface in order to be forwarded to the display controller or other outputs not shown . Utilizing the data flow of this embodiment the display is able to display both the raw image produced by acquisition hardware as well as the information processed by the system controller i.e. the one or more applications in real time. In alternate embodiments other output devices may be provided in addition to or in place of the display such as alternative output devices such as printer or projector storage devices such as a CD DVD or video recorder computer storage device a remote network device a CPU buffer of an ultrasound system a memory or software components such as another application .

The operating environment may also be configured to receive system configuration information via global variables. Parallel processing specialized processors such as DSPs ASICs and FPGAs and distributed processing can all be utilized by the operating environment . In one embodiment operating environment allows multiple applications to run in parallel. As shown in multiple operating environments e.g. virtual machines may be provided either within the same system controller or remote from each other such as over a network.

As was described above the operating environment s supports the execution of conventionally written applications sequentially written applications and or applications written using both sequential and conventional programming code and techniques. Applications receive input data process that data and generate output data. Conventional application receive all or a portion of the input data and process that data through a collection of interdependent functions and or procedures and then generate data outputs. Sequential incremental applications receive the input data in succession i.e. incrementally over time and process each input datum as it arrives through a series of independent processing stages the last stage of which generates the data outputs. A mixed application combines a conventional application with one or more sequential functions or applets. Although each processing stage must wait for the previous stage to generate its output before processing that output the processing performed by the particular stage is independent of the other stages i.e. is self contained and does not involve the other stage e.g. the previous stage is free to accept and process additional input. These applets perform specific tasks for the conventional application which are better performed sequentially. For example processing ultrasound data generated by the acquisition hardware in real time may be better performed by a sequential application or applet which can process the data as it arrives from the acquisition hardware in real time. The various application structures for applications which can be used with the disclosed embodiments are described in more detail above.

The ultrasound stream manager USM via the application interface acts as an interface between applications and the actual ultrasound system hardware and or software. The USM manages the creation and operation of data sources and sinks as described above. In one embodiment as will be described below applications request access to particular data sources data streams via the application interface which registers the application with the USM when they are first executed. The applications then make requests via the application interface to the USM for the creation of various data sources and data sinks to particular sources of data and system inputs and for the actual data streams to be provided. By registering with the USM the USM need not be pre configured with knowledge of which applications are present and operating in the system. Registration also permits an application to be part of the ultrasound hardware control sequence. The USM and application interface further permit multiple applications to coexist and execute substantially simultaneously and share sources of data data streams and system outputs or sinks. Communication among between applications may also be supported as will be described.

Further the USM acts as a control interface for the data sources and sinks allowing the applications to control the flow of data via the application interface . Applications via the application interface use the USM to interact with hardware specific sources and sinks. Applications may have on demand access to data sources or sinks either synchronously or asynchronously. As was described above the USM maintains the abstraction of the actual ultrasound system hardware and or software freeing the applications from the complexities of obtaining inputs and transmitting outputs to the system. The USM may provide access to any ultrasound specific source of data and any system input within the ultrasound system. Further as will be described below the USM may provide normalization and data conversion such that the applications may use a generic data format. The USM normalizes input data from the specific source data format into the generic data format and converts output data from the generic format into a format compatible with the particular system output. For network based data sources or sinks Quality of Service QOS protocols may be implemented to maintain real time streaming data flow. For output to a video display the USM allows the application to specify the display precision such as in terms of the vertical synchronization signal of the video display hardware. In the case of displaying concurrent data streams on the video display the USM synchronizes the concurrent streams allowing them to share the display in multiple windows wherein each display of each data stream is synchronous with the others.

The USM and application interface further implement data stream management features to handle high bandwidth data streams i.e. large and or fast data streams. In particular for applications which are unable to process data streams at their native rate either because the rate is too fast or the application is slowed by competition for system resources the USM via the application interface implements a store and notify function to permit the application to catch up once additional system resources become available. Further in one embodiment the USM may buffer data streams using two or more fixed capacity buffers which alternate between buffering the data stream and providing the data stream to the applications . The alternating ping pong approach enables handling of large long data streams that would otherwise exceed the capacity of a single buffer. In particular this enables use of the ultrasound system as a playback device for pre recorded data streams.

As mentioned above the acquisition hardware provides a stream of data representative of the succession of received ultrasonic echoes for use by an ultrasound streaming application according to one embodiment of the present invention. Alternatively data can be introduced into an ultrasound streaming application or sourced from storage devices such as a disk tape or memory buffer. Alternatively data may be sourced from a network device. Furthermore the data provided by acquisition hardware can represent any ultrasound data. Examples included but are not limited to B mode C mode BC mode Doppler M mode pre scan converted RF and IQ data. The data can also be representative of waveforms such as ECG EKG pulse respiratory functions phone audio video and auxiliary data.

As was also described above an application is a software program designed to implement one or more tasks in the ultrasound system . Applications may include either sequential or conventional code or combinations thereof. The sequential code is preferably structured in accordance with the pipes and filters architecture described herein and as will be described below the pipe and filters architecture provides a development and execution environment in which such code can easily be developed and implemented. As discussed above the USM of the disclosed embodiments provides stream arbitration services capable of being called on by one or more applications concurrently via the application interface . These services abstract and provide applications access to the ultrasound system to receive streaming data system configuration parameters and or user interface input and to output data back to the ultrasound system to be used to control the system presented to the user and or stored. These services can be used to manage all data inputs and outputs regulate data flow either autonomously or under application control and normalize and de normalize input and output data formats. The USM is designed to transparently optimize the execution of applications such as by taking advantage of system hardware such as specialized co processors floating point processors digital signal processors etc. parallel or multithreaded processing functionality. The USM further decouples the applications from the ultrasound system outputs and system inputs thereby increasing the flexibility of the applications to work with different inputs and outputs as described above without recoding or recompiling the application . When interacting with multiple applications the USM ensures that each application is allocated appropriate resources and that resource contention is managed.

As was described above given the decoupled nature of the pipes and filters architecture environment a development environment may also be provided for facilitating the development of streaming applications . In one embodiment this development environment permits the development simulation and testing of applications with actual or synthetic inputs and outputs such as media samples. This permits a developer to easily verify the operation of an application or set of applications in an environment which closely approximates the actual ultrasound system. In one embodiment the development environment includes a graphic user interface GUI . The GUI displays graphic representations of the application and or pipelines such as by using a filter graph making it easier for the developer to construct the application. In addition in one embodiment the GUI provides interactive user interface elements which present the user with a selection of available data sources data streams and permit the user to select which source s stream s they wish to use with a given application . In an alternate embodiment the development environment is capable of operating on an ultrasound system or a conventional computer system.

The data stream normalization processor is coupled with the data stream input s and operates to normalize i.e. convert the received data stream s from their proprietary format s or protocol s into a generic or common format protocol that can be provided to the applications . This allows simpler implementation of the applications as they do not have to be implemented so as to be able to use multiple different stream formats or protocols. Further such applications may be more flexibly utilized with different data sources. In embodiments wherein data may be passed back to the stream manager from the interface the normalization processor may act to convert generic normalized data into the appropriate requisite format. The data stream format may include the bit or frame rate arrangement of data or other characteristics of the data stream.

The data stream buffer is coupled with the data stream normalization processor and stores the normalized first data stream as it is received. The capacity of the data stream buffer is implementation dependent and provides sufficient capacity to allow the applications to process the data stream as specified by the user of the system. For example in one embodiment the data stream buffer may act to regulate the rate of data flow from the stream manager to the application so that the application is not overrun with data or data starved. In one embodiment the stream buffer further acts to store record the incoming data stream for purpose of providing access to it in the future in addition to or rather than providing concurrent live access. Such a recorded data stream may be referred to as a Cine stream. 

The application input s output s includes the data stream outputs and the command inputs and is operative to couple the application s with the interface logically representing the connection point or interface to which the applications connect and interact with the interface . The application input s output s output communicate the particular data streams to the requesting applications from the buffer via the connections as will be described. In one embodiment the application input s output s also receive inputs from the applications such as commands or control inputs e.g. for control feedback applications. As described above the application input s output s may be coupled with multiple applications within one operating environment or among multiple operating environments . As will be described below in one embodiment an application may be required to continually acknowledge its receipt of a data stream in order for the interface to continue to send the data stream. This hand shaking is referred to as pulling and prevents the interface from allocating a data stream to an application which is not using it. In an alternate embodiment once a data stream is allocating the interface will push the data stream to the requesting application without the need for acknowledgment. It will be appreciated that application input s output s and the connections with the applications may be implemented using various standard programming constructs such as message passing buffers global variables shared memory space etc. In one embodiment the application input s output s is implemented to dynamically support communications with multiple applications by dynamically allocating deallocating resources as necessary e.g. when an additional application wants to use the interface to access a data stream.

The data stream allocator is coupled with the data stream buffer the application input s output s and the request processor . The data stream allocator under control of the request processor as will be discussed provides particular applications with access to particular normalized data streams which are stored in the buffer via the application input s output s . Effectively the data stream allocator acts as the intermediary routing the appropriate data from the buffer to the application input s output s for communication to the appropriate application . Where multiple applications are coupled with the application input s output s the data stream allocator ensures that the given data is communicated to the proper application such as by tagging the data or otherwise directing the application input s output s to properly direct route the data. The data stream allocator may allocate one data stream to more than one application as will be described in more detail below multiple data streams to one or more applications or combinations thereof. When allocating one stream to multiple applications the data stream allocator may allocate the first instance or original stream to one particular application to which control of the stream is allowed and allocate copies or clones of the stream to the other applications as described above which may only listen to but not control the data stream. When allocating multiple data streams to one or more applications the data stream allocator may synchronize the data streams to one another or to a separate metric such as a clock or counter. In one embodiment the data within the data streams is augmented with a sequence number or time stamp or other indicator temporal or otherwise of the relationship between the data within the data stream. In this embodiment the data allocator synchronizes the augmented data streams based on this information. Such augmentation may be implemented by the normalization processor upon receipt of the data with the sequence number time stamp etc. being stored in the data buffer associated with the particular data of the data stream. In another embodiment an arbitrator is coupled with the data stream allocator and the application input s output s . The arbitrator controls access to a particular data stream that has been allocated to more than one application . The arbitrator ensures that each of the applications obtains the requisite access to the particular data stream.

The request processor is coupled with the application input s output s the data allocator and the stream manager and is operative to receive a request for access to a particular data stream from the application s or the user as will be discussed. In response to the request the request processor causes the data stream allocator to provide access to the requested normalized data stream from the data buffer to the requesting application via the application input s output s . If the data stream is currently not being provided by the stream manager the request processor communicates with the stream manager to cause the stream manager to provide the requested data stream. The request processor maintains a data structure not shown which identifies all of the available data streams which data streams are currently being provided by the stream manager and the applications to which the provided data streams are presently allocated.

Requests made of the request processor may be received from the applications themselves or via the GUI from a user of the system. The GUI is coupled with the request processor and operative to interact with a user to present information about data streams to the user and receive requests for access to particular data streams from the user. The interface facilitates both development and execution of the applications . GUI is provided which allows a user to control the interface to execute applications and allocate manage and control data streams to a given one or more applications . Further as will be discussed the GUI provides access to tools that can be used for debugging or diagnostic purposes. In one embodiment the user develops an application and using the GUI manually allocates the necessary data stream while continuing to refine and test the application . Once the application is complete it can automatically request access to the necessary data stream from the interface i.e. bind upon execution. In another embodiment an application need not be statically bound to a particular data stream and may allow a user to utilize the GUI to select among multiple available data streams to be processed by the application at execution.

In an alternate embodiment the request processor and data stream allocator may be configured to allow an application or user via the GUI to request specific portions of one or more data streams. In normal operation the data stream allocator provides serial sequential access to the normalized data stream as it is received from the data source via the stream manager and normalized by the data stream normalization processor. However random access to the data stream may also be provided such as by storing the data stream in whole or in part in the buffer as described above and providing random access to the stored data stream or portion thereof. For example access based on a high or low threshold first or last element or other criteria may be provided. In one embodiment where the data within the data stream has been augmented with a time stamp or other relationship indicator random access may be provided based on such augmentation such as by time stamp.

In one embodiment additional outputs to the stream manager may be provided to allow applications to communicate commands to the stream manager such to control the provision of particular data streams.

In another embodiment a registry memory may be provided which allows applications to communicate with each other share data or otherwise interact. The registry memory may also be used by an application to report errors or may be used as storage for global variables applicable to all of the applications .

In an alternative embodiment application development tools may be provided which assist a user in developing and refining applications . Such tools may include debugging tools or tools for viewing application execution or data stream historical activity. These tools may be further coupled with the registry memory allowing access to and manipulation of the data contained therein for monitoring debugging maintenance or other purposes.

While the operating environment in which the applications execute has been depicted as being separate and external to the interface thereby possibly allowing for multiple operating environments it will be appreciated that the interface may be implemented as part of the operating environment .

The interface provides an environment in which applications may discover and attach to data streams. The interface facilitates efficient sharing and management of acquired data through arbitration and parallel processing allowing multiple applications to work in parallel on the same or different data streams to implement independent or co dependent functionality. Exemplary applications include three dimensional 3D or four dimensional 4D 3D over time applications SieScape which effectively stitches multiple two dimensional images together to form a panoramic image URI which deals with delivering RF data to universities for research purposes Elasticity imaging which compares multiple images in order to detect stiff tissues within softer tissues Stress Echo which compares tissues such as cardiac tissues under stress and at rest to allocate stress related problems or 4FHI which acquires 3D images of complete cardiac cycles of a fetal heart. Further the interface acts as a bridge between system address spaces allowing applications to execute in their own address space separate from the resource intensive acquisition processes.

The interface also provides an environment for prototyping applications where a user may allocate data streams to an application and debug the application s execution. Because the interface provides a standardized normalized interface to the acquired image data applications may be developed independent of the imaging system s implementation details data formats and protocols.

It is therefore intended that the foregoing detailed description be regarded as illustrative rather than limiting and that it be understood that it is the following claims including all equivalents that are intended to define the spirit and scope of this invention.

