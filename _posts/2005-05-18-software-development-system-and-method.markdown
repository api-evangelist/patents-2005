---

title: Software development system and method
abstract: A computer design model processing system and methods are described that can create visual models of computer systems, store versions of design models in a centralized repository, automatically generate and deploy computer software systems in response to the stored computer design models, define dependencies between computer design models, and automate and assist the development of multiple, possibly dependent, computer design models by multiple developers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735062&OS=07735062&RS=07735062
owner: OutSystemsâ€”Software em Rede, S.A.
number: 07735062
owner_city: Linda-a-Velha
owner_country: PT
publication_date: 20050518
---
This application claims the benefit of U.S. Provisional Patent Application Ser. No. 60 646 112 filed Jan. 21 2005 entitled Web Services Implementation System. 

The present invention relates to the development of computer software systems specifically to those developed using computer design models. More particularly the invention relates to facilitating the modification of multiple interrelated computer software design models.

Development of web based computer software systems can be very complicated and therefore difficult to accomplish. Developers of such systems often need to be familiar with a wide range of technologies for describing and implementing complex software systems including modern object oriented programming languages XML and specific schemas specific query s and transformations schemes scripting languages interface definition languages process description languages database definition and query languages and more. For example a typical web based computer software system might include application logic written in an object oriented programming language XML for transmission of data between computer software sub systems SQL for storing and retrieving data in databases and WSDL for describing the interfaces to web based services. There are complexities involved in getting such technologies to work effectively together without even considering the business problem to be solved for the end user.

Translating from the requirements of a business problem to an implemented distributed solution using these technologies typically requires a good understanding of each of the various architectures and protocols that make up the solution. Furthermore end users expect the resulting software system to be fast available scalable and secure even in the face of unpredictable demand and unreliable network connections.

In areas other than software development such as electronic consumer products industrial manufacturing processes have enabled manufacturers to deliver products that have a high degree of reliability at low cost coupled increasingly in many cases with the ability to have items customized to satisfy individual needs. Building mechanical or electronic systems involves the coordination of a complex chain of manufacturing steps many of which are wholly or partially automated. It can be useful for computer software system developers to apply manufacturing like principles to the construction of software.

This can be accomplished at least in part by raising the level of abstraction for describing computer software systems. Abstractions can be used in connection with a modeling language to build computer design models that represent a problem domain that is being addressed by a particular computer software system instead of focusing on one particular technological problem such as programming data interchange or data storage. Generally speaking a model is a computerized representation in which each element in the representation corresponds to an element or concept in a given domain. Models allow a problem to be precisely described in a manner that avoids delving into technological detail and they allow the problem to be described using terms and concepts that are familiar to people who work in the domain of the problem rather than in terms only familiar to information technology experts. Models thus can be used to help bridge the gap between business and technology.

In embodiments of the invention models are used to capture high level information that is otherwise typically expressed informally. Models can be used to facilitate the manual development of executable programs or can be used to automatically implement executable programs. The latter is beneficial because with the manual approach high level information can get lost in low level artifacts such as source code files where it is difficult to track maintain or enhance consistently.

Furthermore information captured by models can be used to efficiently assist the creation and modification of interrelated computer designs by concurrent developers. One implementation of the present invention includes a visual modeling environment that provides computer software system developers the ability to easily create computer design models that express the behavior of an intended computer software system. The implementation also includes a application generator that further translates the computer design models into an actual computer software system. Each design model is structured and transmitted between the visual modeling environment and an application generator in XML format. Each model typically includes a set of sub models expressing distinct aspects of the system including a a set of user navigation sub models that define the way end users will interact with the computer software system b a set of business rule sub models that define the data processing rules to be executed upon user interaction c a set of data transmission sub models that define data message formats to be carried among models and sub models within a computer software system d and a set of entity relationship sub models that define how data is structured in persistent repositories.

Each of the sub models and their component elements can be translated by the application generator into appropriate artifacts to be jointly deployed into an application server system and a relational database management system for execution as appropriate. The visual modeling environment provides computer design model developers the ability to easily identify and accept or reject modifications to a computer design model or other related computer design models using an intuitive graphical user interface prior or after regenerating the computer design model into a new actual implementation of the intended computer software system. These and other advantages of the invention will appear more clearly from the following detailed description.

In general in one aspect an embodiment of a method for facilitating the modification of computer design models that each define a software program facilitates the modification of design models that are affected by a change to another design model. The method includes receiving a modified computer design model that is a modification of an original design model. The method includes comparing the modified design model with the original to identify changed elements and identifying design models other than the modified design model that are dependent on the changed elements of the modified design model. The method also includes facilitating the modification of the identified other design models to accommodate the changed elements. Various embodiments can include the following details and variations.

The method can include prior to the receiving step the step of facilitating the modification of a computer design model by displaying a graphical representation of the design model. The graphical representation can enable changes to be made to the model. The method can include prior to the receiving step the step of creating referencing elements to other computer design models from the said computer design model. For example a model can reference elements of another model and these referencing elements can be specified.

The method can include prior to the receiving step the step of storing information about the design model in file for example an XML format file. The method can also include the step of automatically generating an executable program for use in an application server system in response to the modified design model. The method can also include automatically generating a persistent data structure description for example a database schema and or database table for use in a relational database system in response to the modified design model.

In one embodiment the computer design model includes a data persistency sub model containing entity elements that define one or more data structures for storing data operated on by the said software program a data structure sub model containing structure elements defining one or more hierarchical data structures for transmitting information from and to the said software program and a behavior sub model containing action elements that define a set of sequential and conditional instructions that define a business rule of the said software program.

In one embodiment the method includes prior to the comparing step the step of storing the modified computer design model in a source control repository. This can be accomplished by one or more of the following steps creating a new version record in the source control repository storing an XML file in the source control repository such that it is attached or related to the new version record extracting the design model interface specifications in XML format storing the design model interface specification in the source control repository attached to the new version record extracting a list of other design models to which the design model includes references to and storing the list of other design models to which the design model includes references to attached to the new version record.

The source control repository can be based on a relational database. The step of extracting the design model interface specifications in XML format can include one or more of the following sub steps generating an in memory representation of the model searching the in memory representation of the model to find elements defined as interface elements creating an XML element in the said design model interface specification for each entity interface creating an XML element in the said design model interface specification for each structure interface and creating an XML element in the said design model interface specification for each action interface.

The step of extracting a list of other design model models to which the design model includes references to can include creating an in memory representation of the model searching the in memory representation of the model to find referencing elements and querying the source control system about the referenced other computer design model in response to the referencing elements.

The step of comparing the modified design model includes the sub steps of retrieving the original design model interface specification parsing the original design model interface specification to create a first in memory representation of the design model interface specification retrieving the modified design model interface specification parsing the modified design model interface specification to create a second in memory representation of the design model interface specification comparing the first and the second in memory representations to identify any elements that are deleted in the representation of the modified design model and comparing the first and the second in memory representations to identify any elements that are changed in the representation of the modified design model.

The step of identifying design models other than the modified design model that are dependent on the changed elements can include one or more of the following steps receiving a list of deleted or changed elements in the modified version of the design model retrieving a list of other design models that include references to the original design model from the source control system and determining which other design models include references to the deleted or changed elements in the modified version of the design model.

The step of facilitating the modification of the identified other design models can include one or more of the following steps receiving a list of other design models that depend on the deleted or changed elements in the modified version of the design model displaying the list of design models for review and selection and upon user command providing each of the design models for modification of said referencing elements.

A system for implementing the method can include software running on a programmable computer. For example the system can includes a receiving module for receiving a modified computer design model that is a modification of an original design model. The system also can includes a comparison module for comparing the modified design model with the original to identify changed elements and and identification module for identifying design models other than the modified design model that are dependent on the changed elements of the modified design model. The system also can include a facilitation module for facilitating the modification of the identified other design models to accommodate the changed elements. Each of these modules can be implemented in software and or hardware on the same or on different computers as appropriate for the implementation. These modules can also be provided in the form of computer code stored in a computer readable medium.

In general in another aspect a method for providing a first computer design model includes determining whether any references are changed or missing. This allows a developer to be notified about the changed or missing references for example at the time that the first computer design model is provided.

In one embodiment a method for providing a first computer design model includes identifying references in the first computer design model to elements of other computer design models locating the most current interface specifications for the identified references to elements of other computer design models comparing the most current interface specification for the elements of other computer design models with previous interface specifications for the elements of other computer design models and determining in response to the comparing step whether any references in the first computer design model to elements of other computer design models are changed or missing.

The first computer design model may be stored in a source control repository. The first computer design model may include referencing elements to other computer design models.

The method also includes prior to the step of identifying references the step of specifying a version of a computer design model to be provided by displaying a graphical representation of the source control repository content.

In one embodiment the step of identifying references includes retrieving the first computer design model from the source control repository and parsing the first computer design model to list said referencing elements to other computer design models.

In one embodiment the step of locating the most current interface includes receiving a list of referencing elements to other computer design models querying the source control repository for the list of other design models whose interface is being referenced and retrieving the interface specification of the most recent version of each of the other design models.

In one embodiment the step of comparing the most current interface step includes receiving the current interface specification for each of the referenced other design models and parse them to create in memory representation of the other design models interface specification extracting the first design model element interface specifications and parse them to create an in memory representation of the first design model expected interface specifications to referenced elements and comparing the first design model element interface specifications with the other referenced design models interface specifications.

In one embodiment the step of determining whether any references are changed or missing step includes receiving the other design models current element interface specifications that are changed or missing facilitating the substitution of the interface specifications to referenced elements in the first design model with the current interface specification to referenced elements in other design models and automating the substitution of the references to the interface specifications accordingly to the current interface specifications.

A system for implementing the method can be implemented with software running on a programmable computer. For example the system can include an identification module for identifying references in the first computer design model to elements of other computer design models a location module for locating the most current interface specifications for the identified references to elements of other computer design models a comparison module for comparing the most current interface specification for the elements of other computer design models with previous interface specifications for the elements of other computer design models and a determination module for determining in response to the comparing step whether any references in the first computer design model to elements of other computer design models are changed or missing. Each of these modules can be implemented in software and or hardware on the same or on different computers as appropriate for the implementation. These modules can also be provided in the form of computer code stored in a computer readable medium.

In general in one aspect a method for facilitating collaborative use of a computer design model includes receiving a specification for a file containing a computer design model. The specification identifies the file s computer network location. The method also includes determining whether the computer design model in the specified file is the version most recently stored in a repository. The most recently stored version may be the most recently published version meaning that the executable code generated from that model is published to the web site and may be in operation. If the version of the computer design model in the specified file is not the most recently stored the method includes facilitating the selection of elements of the computer design model in the specified file and elements of the most recently stored version.

In one embodiment upon determination that the computer design model in the specified file is the not the most recently stored in a source control repository the user is provided with the choices of editing the version of the computer design model in the specified file downloading the most recently stored version and merging the version of the computer design model in the specified file with the most recently stored version. In one embodiment the step of facilitating the selection of elements is performed upon the user choice of merging the version of the computer design model in the specified file with the most recently published version.

Optionally prior to the step of determining whether the computer design model is the most recently stored the method can include facilitating the selection of a repository by prompting the user to select a repository available on a computer network.

In various implementations the file can include any useful data for the purposes described here. In one implementation a file containing a computer design model includes a list of design model history descriptors each of them comprising information about a user who provided the design model version to be stored a moment in time when the design model version was provided to be stored and a repository where the design model version was stored.

In one embodiment the method includes annotating a computer design model with version information for example by assigning a global unique identifier to the design model and or by annotating the design model with a history descriptor including a timestamp of the creation a base version number and an identification of the user who created the design model.

In one embodiment the method includes determining whether the computer design model is the most recently published by retrieving the file comprising the computer design model from a specified computer network location parsing the file to extract a design model global unique identifier and a first design model history descriptor querying a repository for the most recently stored version of the design model using the extracted design model global unique identifier parsing the most recently stored version of the design model to extract a second design model history descriptor and comparing the first history descriptor with the second history descriptor to determine whether the computer design model in the specified file is different from the most recently stored version.

In one embodiment the step of facilitating the selection of elements of the most recently published version also may include presenting a comparison of the elements of the first computer design model with the elements of the second computer design model facilitating selection of elements in the second model for merging into the first model presenting an indication of the merging action to be taken for each selected element and taking the indicated action thereby merging the first version with the second version. Facilitating the selection of elements of the most recently published version may include presenting a visual comparison of the elements for example a visual indication of new elements changed elements and deleted elements. The indicated action may be taken upon user confirmation.

A system for facilitating collaborative use of a computer design model when opening the design model may include software and or hardware implementations of any or all of the above elements. For example the system can be implemented with software modules running on a computer. The system may include a receiving module for receiving a specification for a file containing a computer design model a determining module for determining whether the computer design model in the specified file is the version most recently stored in a repository and a facilitation module that upon a determination that the version of the computer design model in the specified file is not the most recently stored facilitates the selection of elements of the computer design model in the specified file and elements of the most recently stored version.

In general in another aspect a method for merging a first version of a computer design model with a second version of a computer design model includes presenting a comparison of the elements of the first computer design model with the elements of the second computer design model facilitating selection of elements in the second model for merging into the first model presenting an indication of the action to be taken for each selected element and taking the indicated action thereby merging the first version with the second version.

The computer design model may contain one or elements that can be merged and can include a data persistency model comprising entity and attribute elements that define a data structure for storing data from the software program a data structure model containing structure and attribute elements that define an hierarchical data structure for transmitting information from and to the software program a behavior model containing action elements that define a set of sequential and conditional instructions that define a business rule of the software program and a user navigation model containing screen elements that define the visual and interactive content for presenting information to the end user of the software program.

The elements can be presented visually for example as a list of new elements a list of deleted elements a list of local changed elements a list of foreign changed elements and a list of conflict elements. The elements of the first version may be presented in a first visual list and the elements of the second version in a second visual list. The elements of the first and second lists may be annotated with specific visual marks that denote the element status as one of new changed or conflict and the elements of the first and second lists annotated with specific visual marks that denote non existing elements including marks in the first list for elements that are deleted in the second list and marks in the second list for elements that are new in the first list. The method may also include selecting all the elements of the first list automatically and upon user selection of elements or non existing elements in the second list updating the first list with specific visual marks that denote the merge action to be taken as one of merge remove or replace.

Taking the indicated action thereby merging the first version with the second version may include determining which new elements of the second list are selected merging the corresponding element of the second version into the first design model version determining which deleted elements of the second list are selected removing the corresponding element from the first version and determining which changed or conflict elements of the second list are selected replacing the corresponding element of the first version with the corresponding element of the second version.

A computer design model can be stored in a persistent repository. Upon creation a global unique identifier may be assigned to the model as well as history descriptor information. The computer design model can be annotated with version information upon modification and annotated with history descriptor information that includes a timestamp of the modification and an increment to the version number of the previous most recent history descriptor.

Elements can also be annotated with version information such as a global unique identifier and a version tag the version tag including for example a timestamp of the creation and a base version number. Upon modification a computer design model element can be annotated with version information replacing the version tag of the element with a new version tag for example including a timestamp of the modification and an increment to the previous version number.

The visual comparison of elements described above can be performed by receiving the second version of the computer design model comparing the version history descriptors of the first and second versions to obtain a baseline history descriptor and comparing the version tags of the elements of the first and second versions to provide a list of new elements a list of deleted elements a list of local changed elements a list of foreign changed elements and a list of conflict elements. The step of comparing the version history descriptors may include parsing the first version to extract a first list of version history descriptors parsing the second version to extract a second list of version history descriptors and comparing the first and the second lists of version history descriptors to determine the baseline history descriptor as the most recent history descriptor that is present in both lists.

The step of comparing the version tags of the elements may include parsing the first version to extract a first list of elements comprising all elements in the first version parsing the second version to extract a second list of elements comprising all elements in the second version and comparing the global unique identifiers of the elements in the first and second lists to obtain the list of new elements including all elements that are exclusively present in the first list comparing the global unique identifiers of the elements in the first and second lists to obtain the list of deleted elements including all elements that are exclusively present in the second list comparing the first and the second lists to obtain the list of local changed elements including all elements that are present in both the first and the second lists where the timestamp in the version tag of the element in the first list is ulterior to the baseline version history descriptor timestamp and the timestamp in the version tag of the element in the second list is prior to the baseline version history descriptor timestamp comparing the first and the second lists to obtain the list of foreign changed elements including all elements that are present in both the first and the second lists where the timestamp in the version tag of the element in the first list is prior to the baseline version history descriptor timestamp and the timestamp in the version tag of the element in the second list is ulterior to the baseline version history descriptor timestamp and comparing the first and the second lists to obtain the list of conflict elements including the elements that are present in the first and the second lists where both the timestamps of the version tags of the element in the first and the second lists are ulterior to the baseline version history descriptor timestamp.

A system for facilitating collaborative use of a computer design model when opening the design model may include software and or hardware implementations of any or all of the above elements. For example a system for merging a first version of a computer design model with a second version of a computer design model includes comparison module for presenting a comparison of the elements of the first computer design model with the elements of the second computer design model a selection module for facilitating selection of elements in the second model for merging into the first model and indication module for presenting an indication of the action to be taken for each selected element and an action module for taking the indicated action thereby merging the first version with the second version.

In the following description numerous specific details are set forth in order to provide a more thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without or with a variation on these specific details.

Moreover the system and methods can be implemented using software that is stored on one or more processor readable storage mediums and executed using one or more processors. Each of the identifiable software components can be executed by the same or distinct processors communicating across a distributed network of computers or some combination. For example the visual modeling environment described below can be executing using a processor and the application generator described below can be executed using another processor.

Reference in this specification to one case e.g. one embodiment one implementation etc. means that a particular feature structure or characteristic described in connection with the case is included in at least one case of the invention. The appearances of the phrase in one case in various places in the specification are not necessarily all referring to the same case nor are separate or alternative cases mutually exclusive of other cases. Moreover various features are described which may be exhibited by some cases and not by others. Similarly various requirements are described which may be requirements for some cases but not other cases.

Computer design models describe using abstractions the intended behavior of a computer software system. Examples of functionality provided by such computer software systems include login verification notification database storage order processing electronic wallet calendar scheduler directories news and information and so on. This functionality can be combined with other functionality to support business processes. Using the modeling environment it is possible for a developer to model distinct aspects of a computer software system such as a the user navigation and user interface content to be presented to end users b the business rules that apply to the execution of the interactive events triggered by the end user c and the data transmission and data repository formats and relationships that support the execution of the application. These distinct aspects in some implementations can describe the intended behavior of the computer software system.

Once a model is designed it is compiled into a model description document to be submitted to a model version repository . The visual representations of the models in the modeling environment are translated into a structured representation used for processing by other components of the system . The modeling environment is responsible for creating a model description document from visual representations. As described below the model description document can be generated at various times for example when a developer triggers the submission of a model to the model version repository .

In one embodiment the model description document is structured using XML extensible Markup Language . XML is a language that can be used to describe information or to make information self describing and which can facilitate mapping of visual models into a structured representation that can be parsed by other components of the system .

The version repository stores the model descriptions . By storing versions as development progresses the repository retains information about how and when a computer design model changed over time. For each model a model description is stored along with information about the evolution of the model. At any point in time an authorized developer can add a new version of a model to the version repository . Additionally the version repository is integrated with the visual modeling environment to support collaboration among concurrent developers . In the simplest case one single developer adds revised versions of a computer design model to the version repository . In more complex implementations multiple developers retrieve and add distinct versions of a computer design model to and from the version repository . In such scenario the modeling environment can assist the developers to accept or reject modifications performed by others such that a coherent version is stored in the version repository that can supersede other versions.

The model version repository is preferably based on a database server such as Microsoft SQL Server or Oracle Database and accessed via software services hosted in an application server system. These software services provide to the modeling environment means to submit and retrieve models as well as to submit and retrieve information about repository content.

In the context of the model processing system an application generator may be used to translate computer design models into an implementation of a computer software system. An implemented computer software system may include an executable program to run into an application server system and a database definition to be hosted in a relational database system . The user navigation and user interface aspects as well as the business rule and data transmission aspects of the model are translated into the executable program . The executable program can be any executable or interpreted program for example a web application targeting the .NET. platform from Microsoft Corporation or the Java 2 Enterprise Edition J2EE platform developed by Sun Microsystems.

The data repository aspects of the computer software system are translated into a database . The database can be any sort of relational database for example a Microsoft SQL Server or an Oracle database. Given the nature of the intended computer software systems and the level of abstraction provided the generated Executable Program is automatically configured to access the Database according to the computer design model specifications.

Once the executable program and the database are available on the model processing system respectively in the target application server system and the relational database system the application server system can handle requests from end users for example using a Hyper Text Transfer Protocol HTTP client typically a Web Browser. This means that the elements in the model that denote the way end users see and interact with the computer software system are generated as code for example web pages that are hosted in an application server system and served via HTTP to a client . A request generates a response that takes the form of a graphical user interface to be displayed in the client system . Some controls embedded in the graphical user interface may react to subsequent user generated events and cause the browser to generate subsequent requests back to the application server system . For example when a user presses a button visible in the client system a form may be submitted to the application server system that in response provides the content of a new interactive form to the client system .

In one embodiment three types of sub models are used to model a computer software system a entity relationship sub models b user navigation sub models c business rule sub models. Each of these sub models contain details about the intended computer software system behavior each of them modeling a different perspective with accurate abstractions that are directly related with the business domain and can be translated into an actual implementation to be hosted in a system including an application server system and a database system.

In order to better illustrate the present invention an exemplary problem domain is presented namely a computer software system to handle the registration of citizens of a country to store information about persons and cities and information about which persons live in which cities. The system also stores each person s name and age as well as each city s name and population. The system enables listing inserting and editing persons into a database using a graphical user interface. Every time a new person is inserted the population of the city where the person lives is incremented.

In one embodiment a computer software system model can be composed of several sub models each of them providing one perspective of the computer software system under development modeled using distinct modeling languages. The underlying model integrates such perspectives so that a self consistent computer software system can be analyzed and built.

In the case of the illustrative example the complete problem is expressed within a model composed of three sub models. The complete design model for the intended computer software system includes at least an entity relationship sub model as presented in a user interface navigation sub model as presented in and a business rule sub model as presented in .

Referring to a type of model sometimes used to model a business domain is the entity relationship diagram.

An entity relationship diagram like the example shown is a specialized graph that can illustrate for example the structure for a persistent database resembling the graphical breakdown of a sentence into its grammatical parts. Entities are rendered as rectangles and . Relationships are portrayed as lines connecting the rectangles and . In a logical sense entities are the equivalent of grammatical nouns such as persons or cities. Relationships are the equivalent of verbs or associations such as the act a person living in a city. Therefore the problem domain of storing information about all persons and cities and the information about which persons live in which cities can be modeled with a diagram such shown in the figure. The Person entity and the City entity are connected by means of the lives in relationship associating each Person with a City .

The figure also shows the data to be associated with each entity as entity attributes and . The entity Person contains two attributes the Name and the Age . The entity City contains two attributes the Name and the Population .

The same problem domain could have been expressed correctly using the Standard Query Language SQL as presented below which is commonly used in conjunction with relational database management systems RDBMS to handle persistent data representations.

Unlike the visual model in the SQL textual representation is bound to the technical implementation of a RDBMS. There is no direct mapping for nouns and verbs into an SQL construct. Using a model processing system such as the system of the present invention it is possible to define a direct mapping between the visual representations in the entity relationship graph into an SQL textual representation enabling developers to create read test and modify concrete computer software systems directly from design models in a much more efficient way focusing on the business domain like an entity relationship diagram instead of the technology domain like SQL and RDBMS .

Entity relationship diagrams may not be enough to model an entire computer software system since they are only sufficient to represent how the several entities that support the execution of that computer software system are organized and interrelated in a persistent repository.

A developer benefits from being able to express how data shall be presented and organized to the end user of a computer software system for instance in a web page. A developer also benefits from an ability to express which business activity the computer software system shall take in response to user interaction. It also can be useful to model other parts of the problem domain such as listing inserting and editing persons into the database using a graphical user interface and every time a new person is inserted the population of the city where the person lives must be incremented .

The user navigation sub model of comprises two nodes and that represent two web pages a first web page called List Persons for listing Person entity data and a second web page called Edit Person for editing an individual record of Person entity data. The sub model also includes four relationships representing transitions between pages upon user interaction. The transition called Search from the first page to the same first page presents a new result set of person records upon a search criteria input by the end user. A second transition called New from the first web page to the second web page presents an edit form to input a new Person entity record. A third transition called Edit from the first to the second web page presents an edit form to update one Person entity data record. A fourth transition called Save from the second to the first web page stores a Person entity data record according to data input in the second web page.

Referring briefly again to the user navigation sub model describes how an end user interacts with the application server system to perform the intended business functions of the computer software system. Using a computer software system derived from the sub model in the application server system could for example handle requests from an end user using a Hyper Text Transfer Protocol HTTP based client system like a Web Browser. A request generates a response that takes the form of a graphical user interface to be displayed in the client system . The returned user interfaces are directly derived from the modeled content of a sub model node representing a web page in the user navigation sub model. Some of the embedded controls react to subsequent user generated events and cause the client system to generate subsequent HTTP requests back to the application server system . These subsequent requests will trigger a transition expressed in the user navigation sub model. In response to the new request a new response is sent containing the content of web page node that is the destination of the represented transition.

For example given the sub model in an end user posts an initial request to the application server system requesting access to web page indicating a well known Unified Resource Locator URL like for example http server citizens listpersons.aspx. The application server system directs the request to the executable program that implements the corresponding computer design model. The executable program renders the content of the web page and sends it to the end user s client system . The end user interacts with the web page. For example if the end user presses the New button a request is submitted back to the application server system to be directed to the executable program given that the model expresses a transition to web page . The executable program renders the content of the edit web page and sends it back to the end user s client system .

An example business rule shown in is associated with the Save transition in . When the end user presses the Save button in the Edit Person web page resulting from node of the user navigation sub model in the business rule represented by the sub model in will be executed by the executable program . The business rule sub model demonstrated in includes four nodes and that represent instructions about how the computer software system updates the database data upon user navigation from the first web page to the second web page upon selection of the Save operation by pressing a button or a hyperlink. The relationships among the nodes in represent the sequence of execution of the instructions in the context of the business rule. The example business rule is as follows a create a new person record invoking CreatePerson b step through to obtain the current data about the city where the person lives invoking GetCity c increment the population attribute of the city record e.g. instruction city.population city.population 1 and d store the updated record of the city in the database invoking UpdateCity .

The execution of business rule sub models is associated with events represented in the user navigation sub model.

Some of the elements available in a business rule modeling language can enable the easy handling and transformation of data according to the entity relationship sub models. In the example of the elements and represent data access instructions. Element enables the creation of record of data into a database table derived from the Person entity in . Element enables the retrieval of one record of data from the database table derived from the City entity in . Element enables the update of one record of data into the database table derived from the City entity in .

Referring again to as the end user posts requests to the application server system triggering events using the user interface presented in the client system if any business rule is associated with the triggered event the corresponding implementation in the executable program will be executed.

In one embodiment a modeling environment presents computer design model and sub models using a visual paradigm and stores the computer design models in a model description documents .

In one implementation of the visual application modeling environment here shown in editing a model comprises editing each of the sub models that compose the model one at a time within a model canvas that presents the sub model according to a modeling language. Each type of sub model may be described using a distinct modeling language.

In order to create the sub models the developer uses a set of available constructs in a palette . These constructs can be dragged from the palette into the model canvas to create a new element in the sub model. Once created in the model canvas elements can be connected to establish relationships according to the modeling language. Depending on the type of sub model being edited in the model canvas the palette will only present the relevant specific constructs for the specific modeling language. For example while editing a user navigation sub model the palette will include constructs such as screens.

Following the example presented in the model canvas displays a graph depicting a series of web pages the nodes and possible navigation paths the line connectors among the web pages. Double clicking the elements in the model canvas results in the presentation of dedicated editors that allow the developer to further define the behavior and semantics of the element. In the example of the content of each web page in the model canvas is not presented in detail. The content can be edited by selecting e.g. double clicking each of the nodes of the graph that represent each of the web pages. In such a situation the model canvas can include a What You See Is What You Get WYSIWYG representation for the content of the web page.

In the example implementation of all elements created in the model canvas are catalogued in model tree . Using the model tree a developer can locate and select the context to be presented in model canvas by selecting e.g. double clicking a node of the model tree . The model tree is especially useful when editing complex models comprising several sub models of several types.

Depending on the type of sub model selected the context in the model canvas will change. Some of the elements properties are editable within a property editor allowing the developer to quickly change the element behavior or semantics without having to change the context in the model canvas . The property editor is especially useful when editing complex elements of a model that otherwise would have to be visually annotated in the model canvas to describe every detailed aspect of the elements behavior. For example when specifying a web page a developer may want to define whether the web page requires automatic end user authentication if the content is to be transmitted using encryption and other specifics.

Computer design models have proven to be well matched with human expressive patterns but typically they have not lent themselves to the process of automated processing. It is useful to store the results of editing a model in a well structured format to enable transmitting versioning archiving validating and transforming the design model into a computer software system. XML eXtensible Markup Language can be used to fill that need by providing the building blocks for storing a visual representation in an open document. Such a document can be used to exchange the variety of data captured in the models and sub models across the different components of the processing system in e.g. the modeling environment the version repository and the application generator .

In one embodiment a model description document has a root element called a Model . The Model element contains a set of sub elements submodels that may group the sub models that define the computer software system. These sub models include Entities Structures ScreenFlows and Actions elements. Entities elements represent entity relationship sub models. ScreenFlows elements represent user interface navigation sub models. Actions elements represent business rule sub models Structures elements represent data transmission sub models. As a demonstrative example the XML below contains some elements that can be found in a model description document .

The Entities element of a design model contains a set of individual Entity elements. A design model can have any number of Entity elements where each Entity represents a persistent data repository. Groups of logically associated entities are modeled in an entity relationship sub model.

When an application generates a computer software system it creates a database table that stores the data about the described entity. The table definition is inferred from the Entity definition in the model description document. Each Entity generates a database table whose columns are generated from each of the Attribute elements within the Entity .

In one embodiment an Entity is defined by a name which is unique to the Model an id that is virtually unique to the entire Model universe a primary key that identifies a key Attribute of the Entity that will uniquely identify an Entity record within a database a version identifier that is used to support model version comparison that is incremented whenever any of the Entity or Attribute attribute value is modified and a time stamp representing the moment of modification.

Each Attribute is defined by a name which is unique to the Entity an id that is virtually unique to the entire Model universe and a data type that defines a constraint to the type of data that can be stored in the database column corresponding to the Attribute. Example data types are number text and date.

A relationship in a design model that relates one first Entity with a second Entity is stored as an additional Attribute of the first Entity. In such case the relationship is denoted by the type of that Attribute constraining the values that can be stored in the first Entity to the existing values of the primary key column records in the table implementing the second Entity . The following XML excerpt illustrates how relationships can be represented 

Looking at the example in it can be noticed that the description of depicted sub model includes two Entity elements the first named Person and the second named City. Person has three Attribute elements called Name Age and LivesIn. City has two Attribute elements called Name and Population. 

The Structures element of a design model contains a set of individual Structure elements. A design model can have any number of Structure elements. Each Structure element defines a data structure that can be used to transmit data among elements of a computer design model. Such a data structure can be composed of the definitions of other Structure elements meaning that unlike an Entity a Structure can define a hierarchical data structure. An example of the use of a Structure is a definition for an order processing system. In such an exemplary computer software system an order is represented by an identifier a customer record and a list of items being ordered given that a customer is further represented by a name and customer identifier and that each item is represented by a product identifier a quantity and an amount. In such case a Structure can be defined to support the transmission of complete order records among sub models of a model or even to other computer software systems.

Once the application generator generates the computer software system it creates a series of data definitions that can be used to transmit data among web pages and business rules using the most appropriate format. These formats include web page forms XML data structures or any other adequate definitions of data tokens to be processed by an implementation of a sub model or by a third party computer software system.

In this example a Structure element is defined by a name which is unique to the Model and an id that is virtually unique to the entire models universe.

Likewise each Attribute of the Structure is defined by a name which is unique to the Structure an id that is virtually unique to the entire models universe a data type that defines a constraint to the type of data that can be transmitted according to the Structure definition a version identifier used to support model version comparison that is incremented whenever any of the Structure or Attribute attribute value is modified and a time stamp representing the moment of modification.

A Structure element can be defined by composition of one or more other Structure elements if one or more Attribute elements of a first Structure are of a type defined as Record of Structure or a type defined as RecordList of Structure. Record types define an inclusion of one record of the data defined by the indicated Structure. RecordList types define an inclusion of a sequence of zero or more records of the data defined by the indicated Structure. These constructs can be applied recursively thus meaning that a Structure can define a hierarchical data structure to be transmitted.

The inclusion of a sequence of records of a first Structure element within a second Structure element is stored as an additional Attribute element of the second Structure element whose data type refers to the first Structure element. For example 

Given again the order processing system example an order structure could include an Attribute of type RecordCustomer and an Attribute of type RecordListItem. 

The Actions element of a design model contains a set of individual Action elements. A design model can have any number of Action elements. Each Action element represents a sequence of procedural rules to be applied to data to be presented stored or transmitted by the computer software system. Each Action defines a business rule sub model.

When the application generator generates the computer software system it creates a class method that implements the behavior expressed in the Action element design sub model. An Action element for example can contain the following XML elements and attributes 

In this example an Action is defined by a name which is unique to the Model an id that is virtually unique to the entire Models universe zero or more InputParameter elements and zero or more OutputParameter elements. These define a data transmission interface that input the Action with the universe of data to be processed during its execution InputParameter elements and the definition of the expected data to be transmitted back at the end of the processing OutputParameter elements a version identifier that is incremented whenever any of the Action InputParameter or OutputParameter attribute value is modified a time stamp representing the moment of modification and a series of Node elements that express the several instructions to be executed within the action and the sequence of their execution.

The ScreenFlows element of a design model contains a set of individual ScreenFlow elements. A design model can have any number of ScreenFlow elements. Each ScreenFlow contains a set of possibly interrelated Screen elements. A ScreenFlow can have any number of Screen elements. Each Screen element represents a web page providing content and possible transitions to other web pages.

Once the application generator generates the computer software system it creates a dynamic web page like an Active Server Page or Java Server Page to be rendered by the application server system. The implementation of the dynamic web page is created given the Screen element definition.

In this example a Screen is defined by a name which is unique to the model an id that is virtually unique to the entire models universe zero or more InputParameter element declarations each of them defining a data transmission interface that indicates to the Screen element the universe of data to be used for presentation during its rendering a version identifier that is incremented whenever any of the Screen or InputParameter attribute value is modified a time stamp representing the moment of modification a Content element that contains all information required by the application generator to create an implementation of an executable program capable of presenting the end user with a user interface that reassembles the content expressed in the model and supports the user interaction with event triggering controls like buttons and links and a Links section that includes the definitions of user navigation transitions in the models referring the destination of the transition.

Referring again to a developer using the modeling environment may decide to save a model description document using the model version repository . The processing system allows developers to integrate changes and additions to their models. In some embodiments the model version repository of the present invention enables developers to use the visual modeling environment to retrieve existing versions of a computer design model submit new versions of a computer design model and obtain multiple versions of one design model for visual comparison and merge of elements of both.

The model repository also can be used by the application generator to retrieve a computer design model in order to generate an executable program to be published in the application server system and to apply changes to the database .

The model repository can store information about each known design model each known design model version and each design model developer and his access rights to each design model.

For each design model the model version repository stores a model s global unique identifier a version tag of the most recent version of the model used by the application generator to create an executable program and a Boolean indicator about whether the design model is active for retrieval by the visual modeling environment and generation by the application generator.

For each design model version the model version repository stores the design model to which the version is an implementation of a version tag as a number that is incremented whenever a new version of the model is submitted to the repository the submitted model description document an identifier of the developer who submitted the version the moment when the version was submitted and an history of other versions of the model from which the current version was modified.

For each developer the model repository stores a username and an encrypted password for authentication.

For each access right definition the model repository stores a username a model identifier and a grant to an access right. For each user model pair rights can be granted to allow a developer to retrieve existing versions of a design model or additionally to submit new versions of the design model.

Referring now to a demonstrative example of the progression of a design model in the model version repository shows a first version tagged as v1 that was created and submitted by the developer with username dev1. A second version tagged as v2 was also submitted by dev1 and was developed after retrieval of version with tag v1. The third version tagged as v3 was submitted by dev2 who started the modifications after retrieving version tagged as v1. This third version v3 supersedes the modifications submitted by dev1 to v1. A fourth version tagged as v4 is submitted by dev1 who started the modifications after retrieval of version tagged as v3. 

In some embodiments the modeling environment facilitates submission of a new version of a design model after modification. The modeling environment also provides developers the ability to retrieve an existing version of a design model for modification also using the modeling environment .

As shown in the history of the versions of a design model can be tracked within the model repository . In order to allow the modeling environment to identify conflicts between versions a version history is also maintained inside the model description within a Versions element. The Versions element contains a set of individual Version elements. A design model can have any number of Version elements. Each Version element represents a tagged version of the design model including a tag number and the date of submission.

For example when retrieving a model such as the example having the depicted progression the model description document will include four Version elements each of them representing one of the previously submitted model versions.

The information available within the Versions element of the model can be used to detect possible conflicts prior and after the submission of a design model version to the model repository .

Referring to a computer design model edited using the modeling environment can be used to generate and deploy a fully functional computer software system and this process of generating and deploying the computer software system given a model is supported by the sub system shown. Referring briefly again to the sub system use can be triggered upon a developer request to generate and deploy a model using the modeling environment or upon application manager request to generate and deploy a model for example using the management console .

The process starts by retrieving a model description document from the model repository and providing that document to the application generator . The application generator is responsible for parsing the XML content of the model description document into an internal representation. From there on the application generator applies a series of built in generation rules and templates that directly support the translation of the model element definitions into source code of a corresponding executable program . Depending on the sub models included in the model description document and translation rules built in the application generator the source code is output and organized in several files each containing the source code of the implementation of the several sub models within a model.

In one example implementation which targets the Microsoft .NET. application server system user navigation sub models are transformed into active server pages business rule sub models are transformed into C classes and entity relationship sub models are transformed into a database modification script to be applied to the RDBMS . In the same example implementation the database modification script contains SQL statements that create the database tables with columns and constraints corresponding to the entity relationship sub models.

Right after generating the source code of executable program a native source code compiler is used to create the executable binary files that actually implement the computer software system behavior in a format that can be hosted and managed by an application server system . In the example implementation targeting the Microsoft NET. application server system the native C classes and active server pages are compiled using a reference implementation of a C language compiler.

Given a database modification script the application generator accesses the RDBMS to create or modify the application database .

Once the executable binary files are generated a deployment service is used to execute all steps of transferring installing and configuring for execution the executable binary files into the application server system . In one example implementation targeting the Microsoft NET. application server system the deployment service transmits a compressed file comprising all executable binary files to the application server system decompresses the executable binary files after arrival creates an application inside the application server system copies the executable binary files to the target folder into the application server system and configures the application to be accessed by concurrent client systems .

From there on the application server system will handle requests from end users using a Hyper Text Transfer Protocol HTTP client system like a web browser. When a request is received the executable program running in the application server system processes the request and generates a response. The response can be in HTML or any other adequate markup language or protocol supported by the client system . A request generates a response that takes the form of a graphical user interface to be displayed in the client system . The returned user interfaces often have embedded controls in them that react to subsequent user generated events and cause the browser to generate subsequent HTTP requests back to the application server system . Taking advantage of the application server system architecture it is possible for a single client system that the application server system maintains its state throughout a number of interactions with different requests generated by different user interfaces. For example it is possible for an executable program hosted in an application server system to generate an initial page as the response to the initial request. This initial page could contain a button. When the user presses the button the client system generates a new request targeted against the same executable program . The application server system enables the existing executable program to process the request and generate another user interface page.

In one embodiment elements in one design model can be used in other design models. Sharing elements of design models enhances the ability of developers to reuse available functionality. The processing system can facilitate sharing of one or more elements of a computer design model allowing these elements to be transparently used from other computer design models as if they are part of those other design models. Elements shared by a design model are referred to here as Public elements.

Using the citizen registration example presented earlier one can imagine a need for the same organization to create a new computer software system that manages information about weddings. The new computer software system would need to handle information about the husband and wife in a wedding and the city where the wedding takes place sharing the repository for City data management with the one already existing computer software system.

Referring to two exemplary design models for the two presented problem domains are shown in which model A expresses the entities and relationships that describe the problem domain of registering persons as residents of the cities in a country and model B expresses the entities and relationships that describe the problem domain of registering weddings in the same country.

Given Model A the developer of Model B may decide to reuse the existing Person and City entities from Model A both to decrease the time required to design Model B and to ensure the data integrity of several models for different problem domains.

As shown Model B defines the Wedding entity which includes one attribute Date that records the date of each wedding and three relationships with entities of Model A. The husband relationship indicates the person that was the husband for the wedding the wife relationship indicates which person was the wife for the wedding and the occurred at relationship indicates the city in which the wedding occurred.

Models that include references to elements of other models like Model A to Model B in the above example are referred to as consumer models. Models that include elements that are referenced from other design models like Model A are referred to as producer models. One model can be simultaneously a producer and a consumer. These names are used for illustrative purposes to better identify each model involved from a particular point of view.

A developer identifies and models the entities and relationships required in Model A STEP for example to achieve the result presented in . The developer identifies STEP the need to use the entities in Model A from Model B design models and thus sets the relevant model elements as Public. The developer submits STEP the Model A version to the model repository.

The same or another developer STEP uses the modeling environment to edit Model B. The developer browses STEP with a user interface public elements of other models and selects the public elements in Model A to be referenced from Model B. The developer models STEP the new Wedding entity in Model B referencing entities in Model A already added as references to Model B during step . The developer includes STEP new functionality in Model A to handle data in any of the three entities according to the expressed relationships and constraints just as if they were part of a single model.

The model description document of the consumer design model resulting from step would include a new section that includes all referenced elements from other models for example 

The References element of a design model contains a set of individual Reference elements. A design model can have any number of Reference elements. Each reference indicates in a consumer model the public elements of a producer model that can be used in the consumer model. From within a consumer model any number of public elements of a producer model can be referenced as long as the developer editing the consumer model is granted access to the producer model.

Given that the definition of an element of a producer model cannot be edited from the consumer model the References section of a consumer model will only include a subset of the definitions of the element the element s interface which includes the subset of the definitions of an element that is required to use an element from a consumer model.

 Entity element interfaces as present in the Reference sections of a consumer model can include the information below 

 Structure interfaces as present in the Reference sections of a consumer model can include the information below 

 Action interfaces as present in the Reference sections of a consumer model can include the information below 

In some implementations the Nodes section need not be included in the interface since the information about the actual behavior of the action is not required by a consumer model in order to use the node. The consumer needs only its identification inputs and outputs.

Referring again to having completed step the developer executes step to trigger the execution of the application generator to obtain an executable program to be hosted in the application server system and a database that implement the computer software system represented within Model A. Similarly having completed step a developer may execute step to trigger the execution of the application generator to obtain an executable program. In the case of computer software system derived from Model B it will actually implement the behavior and semantics of all elements of Model B as well as the implementation of the referenced elements of Model A from Model B.

Referring to the operations performed by the processing system when adding removing or updating the references of a consumer model can begin with a developer deciding STEP to add or remove references from a consumer design model opened with the modeling environment. The modeling environment verifies STEP that the user is connected and logged on to the model version repository and if that is not the case STEP the user is prompted with a logon window requiring for example his username and password. Once the user is authorized by the model repository STEP the modeling environment retrieves STEP public element information about producer design models from the model version repository. This information can include the list of design models the user is allowed access to the list of public elements for each of the listed design models and the public elements interface specification in the same XML format used within the model description document References section. In addition the modeling environment loads into memory the list of design model elements that are referenced from the current design model as expressed in the model description. This is the information for the version that is being edited by the developer. This information is used to mark which elements of the producer design models are referenced from the consumer design model.

The modeling environment performs a series of conflict checks STEP to modified elements in the information retrieved from the model repository performing a comparison between the definition of the elements interface that is retrieved from the model version repository and the definition of the elements interface that is available within the model description of the consumer model. The comparison of reference definitions sequence includes detecting if one producer design model is listed only in the consumer design model description detecting if one element in a producer design model is listed only in the consumer design model description and a textual comparison of the XML attributes of the reference present within the consumer model description document and the corresponding definition retrieved from the model version repository in step . In addition the results of the comparison are compiled to identify references to elements of a design model that are not present in the model repository or to elements of a design model that doesn t contain such public elements in its most recent version or to elements of a design model that were deleted or that are not public anymore referred to as Missing references and references to elements of a design model which interface definition is different in the most recent version.

The developer is provided with the results from the comparisons in STEPS and . Displayed are the list of design models the user is granted access to the list of public elements for each of the listed design models visual marks denoting which of the listed public elements are already referenced from the design model visual marks denoting which of the listed design models are Missing and visual marks denoting which of the listed elements of the design models are Missing and visual marks denoting which of the listed elements of the design models are Modified. 

This automated detection of conflicts is beneficial for distributed teams of developers who are collaborating by means of sharing model elements among them particularly whenever the producer design models are prone to changes.

Referring to in one exemplary implementation of the visual modeling environment a user interface prompts and enables developers to check add and remove references from a computer design model such as with the flow chart in .

Using the example implementation in the list of design models that the user has access to is presented in the left pane . In the example screenshot the developer is granted access to two design models named Calendar and Customer respectively. The list of public elements of the selected design model Customer is listed in the right pane . In the example screenshot there are three public elements the Create RentalCo Customer Action the Customer Entity and the Customer Report Structure. Each of the public elements is labeled with a visual mark in this case a check mark identifying which of them are referenced from the design model being edited. In the example screenshot there are two references to the Customer design model one to the Create RentalCo Customer Action and other to the Customer Entity. The Customer Report public Structure is not referenced.

Referring also again to during STEP for example the developer interactively selects pubic elements from the listed design models to be referenced or unselects them to be unreferenced. One implementation having the form of the example user interface presented in allows the developer to click the visual mark to alter the selection of the elements individually. Additionally for those elements that are Missing or Modified the developer will interactively decide whether to update the interfaces of the references in the consumer design model according to the definition retrieved from the model repository or to keep the existing interface definition.

After choosing elements to be referenced STEP the developer may accept the selections to proceed editing the design model using the selected set of references. The visual modeling environment will update the References section of the model description of the consumer model STEP . The update of References section can for example find all design model elements selected e.g. in step and for each of them add the corresponding Entity Action or Structure section to the References section of the corresponding design model. If the References section does not include a Reference for the corresponding design model yet a new Reference section can be added. All design model elements unselected in step can be identified and for each of them the corresponding Entity Action or Structure section to the Reference section of the corresponding design model removed. Further the system can identify Missing design models detected in step and updated in step and remove the corresponding Reference section find Missing elements of design models detected in step and updated in step remove the corresponding Entity Action or Structure sections. The system also can find Modified elements of the design models detected in step and updated in step .

As described the use of computer design models to define large scale computer software systems is significantly enhanced using references among computer design models. Further enhancement is achieved automating the process of generation and deployment of executable programs from interrelated computer design models. Referring to the flow of generation of the executable programs is shown for two exemplary interrelated design models Model A and Model B where Model B includes references elements in Model A. Model A is provided to the Application Generator and two sets of source files are generated the source code files for the private elements of Model A and the source code files for the public elements of Model A .

Both sets of source files and are provided to the source code compiler to generate two new sets of binary executable files the binary executables for the private elements of Model A and the binary executables for the public elements of Model A . Considering that Model A doesn t include references to other design models the deployment of Model A would involve the direct deployment of the outputs and of the source code compiler. Model B differs from Model A in the sense that it includes Reference elements. In such case Model B is provided to the application generator and two sets of source files are generated namely the source code files for the interfaces that reference Model A and the source code files for the private elements of Model B.

The source code files for the interfaces of Model A are implemented with a proxy that accesses the functionality provided by the actual implementation of Model B. Again the source code compiler is applied to the sources output from the application generator. Then the deployment service deploys the executable program for Model B. Deployment of Model B involves not only the output from the source code compiler and but also the actual implementation of the public elements of Model A . Thus the resulting executable program for Model A includes the binaries and and the resulting executable program for Model B includes the binaries and .

Given the high productivity rates that developers desire to attain the time to implement and maintain computer design models can be reduced if the complexity induced by version and dependency management complexity can be removed or at least reduced.

Referring again to in some embodiments the processing system automates and assists a developer to detect and apply design model modifications made by other developers to a design model or to other dependent design models. The modeling environment presents relevant information and tools to support this effort for example when opening a design model merging two versions of a design model retrieving a design model from the model repository and submitting a design model to the model repository.

Assisted modification of design models is beneficial when opening a design model that is not retrieved from the model repository. Often developers disconnected from the model repository store the result of their work on a local hard disk drive. Another scenario is having distributed developers working in different instances of the computer design model processing system exchanging design model description documents among themselves.

In order to assist developers in such cases the system can notify a developer if the model description document being opened is not up to date according to the model versions stored in the model repository and allow the developer to select how to proceed with design model. Options include opening the local version of the design model discarding the local version of the design model retrieving the most recent version from the model version repository or calculating differences and merging the local version of the design model with the most recent version of the design model stored in the model version repository.

Referring to the system can facilitate management of model versioning by taking steps for example upon opening a model description document using the visual modeling environment.

A developer selects STEP a design model description to be opened possibly by browsing a file system. The modeling environment verifies STEP if the developer is already connected and logged on to the model version repository. If that is not the case the developer is authenticated e.g. prompted with a logon window requiring his username and password . Once the user is authorized by the model repository the modeling environment can either open a local version or the modeling environment retrieves a list of versions of the design model from the model repository for comparison with the information available within the model description being opened. The list of versions retrieved from the model repository is compared with the list of versions present in the Versions section of the model description STEP . If at least one of the versions retrieved from the model repository is more recent than the most recent version present in the Versions section of the model description it means that there are more recent versions of the model than the one that the developer is trying to open. In such case the visual modeling environment will proceed to step otherwise the local copy of the design model document is used STEP .

If there is a more recent version in the model version repository the developer is prompted with three options available for decision 1 opening the design model document selected in step and proceeding with the older version STEP 2 retrieving the most recent version of the design model stored in the model version repository and updating references as explained below with reference to 3 comparing and merging the design model document selected in step with the most recent version of the design model stored in the model version repository as described below with reference to .

In step the visual modeling environment parses the complete design model description and creates an in memory representation suitable for visual editing of the models.

Often multiple developers editing the same design model diverge in the modifications they perform in parallel. At the end unlike with what happens with source code design models cannot be easily compared and merged by using simple textual comparisons.

There is a benefit then to assisting a developer editing a model whenever there are other model versions that she wants to merge with her current version.

Referring to a developer can merge two different model versions by first deciding to merge two versions of a design model STEP . In this example the two versions are the currently open computer design model and a selected second model description for example one that the system identified in STEP above. The first and the second versions of the design model are parsed STEP loading into memory a list of elements in each model version each of them tagged with the version number expressed in the Version attribute of the element as available in the model description. The content of the Versions element in the model description documents of each of the versions is also parsed and loaded into a in memory representation. A sequence of sub steps is then executed to calculate the differences between the first and the second versions. The first and the second lists are compared to determine the most recent version record that is present in both lists referred to as a baseline. The first and the second lists of elements are compared to detect which of them exist only in the first and if the stamp of the element in the first list is ulterior to the baseline add the element to a list of New local elements. If the stamp of the element in the first list is prior or equal to the baseline add the element to a list of Deleted local elements. The first and the second lists of elements are compared to detect which of them exist only in the second and if the stamp of the element in the second list is ulterior to the baseline add the element to a list of New foreign elements. If the stamp of the element in the second list is prior or equal to the baseline add the element to a list of Deleted foreign elements. The first and the second lists of elements are compared to detect which of them exist in both but are marked with different version numbers. If the stamp of the element in the first list is ulterior to the baseline and the stamp of the second is prior or equal to the baseline add the first element to a list of Changed local elements. If the stamp of the element in the second list is ulterior to the baseline and the stamp of the first is prior or equal to the baseline add the second element to a list of Changed foreign elements Given the lists resulting these comparisons the modeling environment will prompt the developer with visual representation of the two lists of elements each presenting visual marks about New Changed and Deleted elements STEP .

In one example implementation of the modeling environment the user interface that prompts and enables developers to compare and merge elements of two design model versions is presented in . Using such interface a developer comparing two versions of design model will be presented with the elements of the first in the left pane and the elements of the second in the right pane . In the example screenshot the design model being compared includes two ScreenFlow elements with several Screen elements each and four Action elements.

Following again the steps in with the example of to better understand the use of the described user interface given the output from step the lists include visual marks about the differences detected. The example screenshot in has an example of a visual mark for a Changed element and an example of a visual mark for a Deleted element.

When prompted with the differences of the two model version the developer proceeds interactively with step to decide which version of each element is going to be included in the final resulting merged version. In this example a default selection includes the element versions from the first version. If the developer decides to choose an element version from the second version the selection is performed pressing the button available upon selection of each of elements in the right pane .

In step the developer reviews and confirms the selection of elements to be present in the resulting merged model version. In this example additional visual marks are presented to help the developer performing step within the same user interface.

Following the execution of step the developer can proceed editing the resulting merged version using the visual modeling environment.

Often when a design model is referenced by others the responsibility to accept and apply modifications to the dependable models is a distributed responsibility among the developers that maintain each of them. In such case the assisted verification of modifications of the dependable design models is supported by a method of the present invention that assists a developer to interactively retrieve a design model version from the model version repository obtaining immediate information about the modifications to the models it references.

The method for assisting the developer retrieving a model version from the model version repository is depicted by the flow chart in including the following steps 

In step the modeling environment verifies if the developer is already connected and logged on to the model repository.

If the developer is not connected proceed with step prompting a logon window requiring the developer username and password and step verifying the logon operation.

If the developer is connected and is authorized by the model repository in step or step proceed to step .

In step the modeling environment retrieves a list of available models in the model version repository to which the developer is granted access to.

In step prompt the list of models to the developer further including an option to browse all versions of a specific model.

In step if the developer selects a model directly the modeling environment proceeds to step otherwise proceeds to step .

In step the modeling environment retrieves the model description for the selected version of the selected design model. If stepping from step to step the most recent version is retrieved.

In step for each of the referenced design models from the retrieved design model the modeling environment retrieves the interface specification of the public elements.

In step the same the same sub steps of step in are executed for detecting conflicts between the expected interfaces specification and most recent interface specification.

In step the modeling environment verifies if any missing or modified references are found. In such case prompts the user with the list of missing and modified elements and executes the same sub steps of flow chart in thus allowing the developer to immediately review and eventually accept the modifications performed in the referenced models minimizing the probability of having different specifications of interfaces being used for one element definition.

Referring to mentioned another method of the present invention assists a developer to interactively submit a design model version to the model repository obtaining immediate information about the models affected by the modifications executed. This method is demonstrated by the flow chart shown in step the developer selects the submit option in the modeling environment.

In step the modeling environment verifies if the developer is already connected and logged on to the model repository.

If the developer is not connected proceed with step and a logon window is prompted requiring his username and password.

In case the user is already connected authorized by the model repository in step or the modeling environment will proceed to step .

In step determine whether the most recent version in the repository is included in the Versions section meaning that the version being submitted is based on the most recent version already submitted.

In the case that the most recent version is included in the Versions section proceed with step immediately adding the new version to the model repository.

In the case that the most recent version is not included in the Versions section proceed with step prompting the developer with two options a proceed submitting the model version even considering that a possibly conflicting version was already submitted or b merge the model version being submitted with the most recent version of the model existing in the model version repository.

Upon user selection of option b in step the modeling environment interrupts the flow execution and triggers for example the execution of flow chart in to merge the version being submitted with the most recent version available in the repository.

In steps and respectively a new version record is created in the model repository and the model description is stored.

Although the present invention has been described with reference to specific exemplary embodiments it will be evident that various modifications and changes can be made to these embodiments without departing from the broader spirit of the invention as set forth in the claims.

Accordingly the reader will see that the system of the present invention can be used to process computer design models with any degree of complexity given that they can be expressed in a structured and hierarchical format. Examples of sub models that may extend the presented computer design models include class sub models object sub models component sub models deployment sub models use case sub models state chart sub models collaboration sub models storyboard sub models or any other that describe the behavior of computer software systems.

Additionally it will also be evident that other types of design models that can be similarly be processed using such methods if they can be expressed in a structured and hierarchical format. For example electronic design models could be automatically processed to produce compound electronic circuits. Using the methods of the present invention the modification of those models could be significantly improved.

Thus the scope of the invention should be determined by the appended claims and their legal equivalents rather than by the examples given.

