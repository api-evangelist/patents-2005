---

title: Time of day synchronization and distribution within a multiprocessor embedded system and related methods
abstract: A software-defined radio includes a pair of radio subsystems such as a red (command) and black (data) radio subsystem having an operating environment conforming to the Software Communications Architecture (SCA) specification, for example, as used for Joint Tactical Radio System (JTRS). A clock is read by at least one of the radio subsystems for determining time of day. A processor of the radio subsystem is operative for distributing the time of day to the radio subsystems using a global hardware timing pulse. Each processor can include a free-running timer to which any time sources within the pair of radio subsystems are set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689207&OS=07689207&RS=07689207
owner: Harris Corporation
number: 07689207
owner_city: Melbourne
owner_country: US
publication_date: 20051017
---
The present invention relates to a software communications architecture SCA for radios and other applications having embedded processors.

With advances in processing capabilities and programming technologies software defined mobile wireless communications devices e.g. radios continue to increase in popularity. Rather than relying upon hardware and circuitry components to perform tasks such as frequency modulation bandwidth security functions and waveform requirements these functions are performed by software modules or components in a software radio. That is with a software radio analog signals are converted into the digital domain where the above noted functions may be performed using digital signal processing.

Because most of the functions of the radio are controlled by software software radios may typically be implemented with relatively standard processor and hardware components. This may not only reduce device hardware costs but is also provides greater flexibility in upgrading the device since new communications waveform modules can be uploaded to the device relatively easily and without the need to interchange new hardware components.

One particular class of software radio which takes advantage of the above described advantages features is the Joint Tactical Radio JTR . The JTR radio includes relatively standard radio and processing hardware along with the appropriate waveform software modules for the communication waveforms the radio will use. JTR s also utilize operating system software that conforms with the Software Communications Architecture SCA Specification see www.JTRS.saalt.mil which is hereby incorporated by reference in its entirety. The SCA is an open architecture framework that specifies how hardware and software components are to interoperate so that different manufacturers and developers can readily integrate their respective components into a single device.

Still another class of mobile wireless communications devices that increasingly use software components for communicating with different waveforms or protocols are cellular communication devices. That is many cellular devices are now designed to operate with more than one of the numerous cellular standards that are used throughout the world such as the Global System for Mobile Communications GSM and Personal Communications Services PCS for example.

The Joint Tactical Radio System JTRS Software Component Architecture SCA defines a set of interfaces and protocols often based on the Common Object Request Broker Architecture CORBA for implementing a Software Defined Radio SDR . In part JTRS and its SCA are used with a family of software re programmable radios. As such the SCA is a specific set of rules methods and design criteria for implementing software re programmable digital radios.

The JTRS SCA specification is published by the JTRS Joint Program Office JPO . The JTRS SCA has been structured to provide for portability of applications software between different JTRS SCA implementations leverage commercial standards to reduce development cost reduce development time of new waveforms through the ability to reuse design modules and build on evolving commercial frameworks and architectures.

The JTRS SCA is not a system specification as it is intended to be implementation independent but a set of rules that constrain the design of systems to achieve desired JTRS objectives. The software framework of the JTRS SCA defines the Operating Environment OE and specifies the services and interfaces that applications use from that environment. The SCA OE comprises a Core Framework CF a CORBA middleware and an Operating System OS based on the Portable Operating System Interface POSIX with associated board support packages. The JTRS SCA also provides a building block structure defined in the API Supplement for defining application programming interfaces APIs between application software components.

The JTRS SCA Core Framework CF is an architectural concept defining the essential core set of open software Interfaces and Profiles that provide for the deployment management interconnection and intercommunication of software application components in embedded distributed computing communication systems. Interfaces may be defined in the JTRS SCA Specification. However developers may implement some of them some may be implemented by non core applications i.e. waveforms etc. and some may be implemented by hardware device providers.

The specifications for the JTRS radio and SCA typically require an interface for command and data red and black processing systems. A radio platform may include multiprocessor embedded systems including Field Programmable Gate Arrays FPGA s . In some current systems the timing synchronization between processing elements is often orchestrated in the software. This scheme uses a series of message exchanges between the processing elements where one of the elements provides the definitive time reference in the messaging that is sent. This current technique has limits on the accuracy that can be achieved because of the interrupt latency and timing variability in the message exchange. It would be desirable to determine a way to accurately synchronize the time of day between multiple processors and processes within these embedded systems operative typically as a software radio such that the synchronization can be accurately determined with less than one microsecond of inaccuracy.

In view of the foregoing background it is therefore an object of the present invention to provide a time of day synchronization and distribution within a software defined radio having multiple radio subsystems without using a series of time inaccurate message exchanges.

In accordance with a non limiting example of the present invention a software defined radio includes a pair of radio subsystems each having a processor. A real time clock is operative to be read by at least one of the radio subsystems for determining time of day. The processor is operative for distributing the time of day to radio subsystems using a global hardware timing pulse. The pair of radio subsystems can be formed as a red command and black data radio subsystem that are conformable to the Software Communications Architecture SCA specification.

In one aspect each processor can be formed as a Field Programmable Gate Array FPGA each including a free running timer to which any time sources within the pair of radio subsystems are set. Each processor can include registers in which the time of day is stored which are incremented in unison to each other using a common clock to create a free running system time. At least one processor can be operative for computing time of day offsets to the free running system time when the time of day has changed and distributing the time of day offsets to the free running system time for the radio subsystems.

In another aspect a waveform source can be instantiated to the radio subsystems wherein the time of day can be obtained from a waveform. Time of day offsets can be distributed using a Common Object Request Broker Architecture CORBA .

Different embodiments will now be described more fully hereinafter with reference to the accompanying drawings in which preferred embodiments are shown. Many different forms can be set forth and described embodiments should not be construed as limited to the embodiments set forth herein. Rather these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the scope to those skilled in the art. Like numbers refer to like elements throughout and prime notation is used to indicate similar elements in alternative embodiments.

In one non limiting embodiment of the present invention free running timers are synchronized in counters for example in Field Programmable Gate Arrays FPGA s and time sources are latched relative to free running counters. The system captures these offsets and distributes offsets around the system. Time is as accurate as it can be clocked into the FPGA s. This allows a system to use CORBA as a standard SCA communication mechanism to pass time of day offsets around the system. A time of day service code can be responsible for providing these offsets to the rest of the system. Thus it is possible to keep accurate time to all system components such as the red processors e.g. FPGA s or Digital Signal Processor DSP s as well as the waveform and operating environment software.

When a radio powers up the current time of day is read from a real time clock RTC chip and stored in a pair of FPGA registers on both sides of the radio i.e. in the radio platform using the SCA architecture the red and black subsystems. The time is substantially instantiated e.g. created or loaded in all processing elements using a global hardware timing pulse. Once the registers are loaded they can begin to increment in lock step using a common clock source. These registers will continue to increment while the radio is powered creating a free running system time. When the radio time is changed an offset to the radio time relative to the free running system time will be computed and stored in memory. Radio time of day is distributed as an offset to the free running system time. By having a set of processing elements synchronized from the same clock pulse the system can ensure that system times will always be synchronized to within a high degree of accuracy. This can be critical for frequency hopping applications.

By passing radio time changes as an offset to the system time the system can ensure accurate time transfer. Time can also be updated from any processor and can still be synchronized without worrying about latency when passing messages. Time dependent waveforms e.g. SINCGARS or HaveQuickII time typically need to be synchronized as closely as possible otherwise communication between radios can be compromised. Thus a JTRS SCA based radio can now have an SCA based architecture with a predefined mechanism for synchronizing the operating environment and the waveform application components to the degree of accuracy that is required by many frequency hopping waveforms.

The time of day synchronization and distribution within a multiprocessor embedded system and related methods can be used for any type of radio software communications architecture as used on mainframe computers or small computers including laptops with an added transceiver such as used by military and civilian applications or in a portable wireless communications device as illustrated in . The portable wireless communications device is illustrated as a radio that can include a transceiver as an internal component and handheld housing with an antenna and control knobs. A Liquid Crystal Display LCD or similar display can be positioned on the housing in an appropriate location for display. The various internal components including dual processor systems for red and black subsystems and software that is conforming with SCA is operative with the illustrated radio. Although a portable or handheld radio is disclosed the architecture as described can be used when any processor system operative with the transceiver using SCA and the time of day synchronization and distribution in accordance with the present invention.

Generally TOD is used to manage and provide accurate time throughout the radio. TOD is made up of a black side component which could be indicated as TOD B Process and the red side component which could be indicated as TOD R Process the TOD Service and a TOD plugin . TOD B Process and TOD R Process are responsible for updating the black and red hardware components of the radio. The TOD service provides time information and manages the synchronization of various hardware and software time components within the radio. This synchronization includes making calls to TOD B Process to update the clock. The TOD Service will also provide any registered users notification of any pending time adjustments via a notification server. The TOD plugin connects to the platform database and is used to write and receive TOD data.

In one non limiting example the time of day can be updated by two sources the user for example via HMI ascii front panel testable interface or by a GPS Process with GPS having the higher priority. A source with a lower priority cannot update the time if the time has already been changed by a source with a higher priority. Because a waveform cannot see a time jump or go backward in time time changes can only be made when a waveform is not instantiated.

When a time update is requested the delta time change is computed and a message is sent through a notification server having a notification service that there is a pending update. This message will be used by all plugins that need to track time changes. The time offset can be tracked until there is no waveform instantiated. Once there is no waveform instantiated the TOD service can make a call to the TOD B Process to update the clock and synchronize the TOD R Process to TOD B Process .

There will typically be one TOD Service instance running on the radio. This instance will interface with the TOD B process as well as the TOD plugin as part of the system. The TOD B process interacts with the Real Time Clock RTC chip and driver and any black FPGA hardware. It also updates the UTC Time Now object and the Operating System OS clock on power up . Any time adjustments can be sent to the TOD R process and are synchronized using a hardware line between TOD B and TOD R. Updates to UTC Time Now object and the OS clock only on power up on the red side are then performed by TOD R. The TOD system plugin will be used to access the database.

Time adjustments may come from other sources besides the Global Positioning System GPS . Time adjustments may not be immediate. A policy will typically exist that will determine which time sources can adjust the time. More accurate time sources could be allowed to adjust the time if the current time was set using a less accurate source. Less accurate time sources however will not be allowed to adjust the time if the current time was set using a more accurate time source.

The GPS process can send time updates before the GPS one 1 pulse per second PPS interrupt occurs. The time update can contain the time value at the next pulse. The time obtained from the TOD Service typically may be the most accurate time data in the radio due to CORBA latency. The accuracy of the time on this port is indeterminate. Multiple components in the radio may be interested in obtaining time information through TOD Service.

Time can be obtained through the RTC chip the Now object or the TOD Service. The TOD Service is used by waveforms to obtain time. Any other components that are interested in obtaining time can use the TOD Service. The components that use the time provided by the TOD Service should be aware that this time will not be the most accurate time in the radio due to CORBA latency.

A state diagram is shown in at . UPDATE BLACK and SYNCH RED handle updating black and red time components respectively . POWER UP is start up of all TOD components. UPDATE TIME handles time updates that come in from HMI or GPS. SYNCH MANPACK handles time synchronization between some channels. WAIT FOR NO WAVEFORM will monitor system until there is no waveform instantiated.

TOD B and TOD R Process are stand alone processes that are used to synchronize time between the red and black sides. The TOD Service contains an instance of a TOD B Application Programming Interface API to command the TOD B process . The TOD B process acts as a slave to the TOD Service in this regard. No communications channel exists for TOD B to make calls on the TOD Service. The TOD B Process is responsible for synchronizing the current time with TOD R Process.

The TOD Service can include different ports for interface and communication. A User TodOp port allows the HMI to make adjustments to the time of day. Since GPS has a higher priority than HMI the HMI will only be allowed to change the time if GPS has not already updated time. Also these adjustments are not always made immediately. Since a waveform cannot see a jump in time the adjustment will be made when there is no instantiated waveform. Once there is no instantiated waveform the adjustments are made to the underlying time components that exist in TOD B and TOD R. A GpsTodOp port allows GPS make adjustments to time of day. The same applies as before because adjustments are not always made immediately. Since a waveform cannot see a jump in time the adjustment will be made when there is no instantiated waveform. Once there is no instantiated waveform the adjustments are made to the underlying time components that exist in TOD B and TOD R.

A TimeAdNotification port is used to send out notifications that a component in the system wants to adjust the time. This notification will be used by all components that need to track the time to keep up to date of the current delta time.

An AccessDatabase port will allow TOD Service to retrieve and update a database configuration as needed. This connection is an internal connection between TOD Service and a TOD system plugin. The data that is included in database configuration includes UTC time UTC offset power up time time last updated and who last updated.

A NotifyTimeChange port is used to send out the new time offset to any waveform or plugin that is tracking time specific components for a waveform.

c. TOD B synchronizes with TOD R . The synchronization process involves TOD B sending the current time to TOD R. TOD R uses this time to update the Now object and POSIX system time on the red side.

The System Process connects to plugin ports from TOD Service to TOD Plugin ports on the system process. The TOD Service queries TOD B for power up values Time Last Written Time Source etc. . These values are then written to the database through the system plugin port. Database queries will not be allowed until TOD B is initialized.

Since not all plugins are loaded at startup there needs to be a way to track a time offset for the waveforms until their plugin is started. This can be accomplished in various ways and in one non limiting example as described.

When a fill command is called a time from a security service will be sent to the TOD Service. This will be done by creating a port CORBA connection between a security service and TOD Service. An offset will be computed between the fill time and the radio time. This offset will be updated during time changes. When a waveform plugin is started it will make a call through the WaveformTodOpPort CORBA to obtain the offset. The plugin can use this offset as a basis for any time offsets that it may need. During the case that a waveform is started and its plugin is already running the plugin can obtain the offset from the TOD Service to ensure the correct offset is being used. The system will not update the Now object when the system is in a FILL mode or in WAVEFORM mode. The system will wait until there are no waveforms instantiated. The waveform will get the Offset using the WaveformTodOp port. The system will add a function to retrieve this parameter.

In the system as described the HMI can send a command to fill and the security service can send a time message to the TOD Service which computes offset between fill time and radio time and then the TOD Service stores the offset.

For the Waveform Plugin the system starts the plugin. On waveform instantiation a domain manager will make a port connection between the waveform and TOD Service. The waveform will make a call through the WaveformTodOp port and get the offset from TOD Service. The plugin updates its time components based on offset.

The security service can send a time offset to the TOD Service which can store and track offsets. When a waveform is instantiated the waveform or the waveform plugin can retrieve the time offset from the TOD service.

Referring again to . The TOD Service is responsible for taking the time of day requests from GPS HMI and a waveform. The TOD Service will go through the TOD plugin to access the database . The TOD Service will go through the TOD B process to update time components on the black side of the radio. The TOD B process will update the black side POSIX the Now object and the Real Time Clock . The TOD B process will also send updated time to the TOD R process which will update the red side POSIX and Now object .

As indicated the time of day for the radio can be based off the free running BFPGA timer that is powered off the 19.2 MHz TCXO . On power up the black and red timers can be preloaded. The BFPGA and the RFPGA can receive a one 1 Pps that comes out of the RTC. On the pulse the Clock Signal CLK line could trigger and start the timers. When if GPS acquires a GPS pulse could be sent to the RFPGA. When the RFPGA receives the pulse it can record the current time of day and store that value in a register. It can send an interrupt to GPS TOD as long as the offset is accounted for somewhere where GPS will store the offset for use when sending time to TOD. When an MFPGA is configured the time of day in the BFPGA can be loaded into the MPFGA.

As shown in the FPGA designer can provide a synchronization line to the BIOP which can be used to obtain time POSIX system time or Now time . The FPGA can have the 19.2 MHz reference from the TCXO. The FPGA timer can be set to any time reference by a waveform providing the delta between that reference and UTC is established.

As shown in the interaction between red and black subsystems is shown. Time of day on the radio is tracked by the Now object and is maintained by the TOD B black side time component . The Now object is a software component connected to a BFPGA timer used to track UTC time as number of seconds since the base date currently Jan. 1 1970 . The TOD B component is used to update the Now object as well as update the TOD R component red side time component . In this paradigm TOD B is considered the master and TOD R is considered the slave. TOD Service and the TOD platform plugin are CORBA components that together handle time and date requests from GPS and HMI. The platform plugin is also used to read and write to the platform database.

HMI can request a time change via the TOD platform plugin . That request can be sent to TOD Service where an offset to the radio time can be computed and stored in the database. That offset will be stored until no waveforms are running on the radio. When no waveforms are running on the radio TOD Service can make a call to TOD B to update the radio time and reset the stored offset to zero. TOD B black side TOD will update the Now object to reflect the offset write the new time to the real time chip RTC and send the new time to TOD R red side TOD .

GPS time change can follow the same algorithm as the HMI change with the exception that the initial request will go to the TOD Service instead of through the platform plugin.

When a new offset is computed by TOD the new offset will be sent to every waveform plugin. It is expected that the waveform plugin will store the current time offset. This offset should be stored in the waveform database so it can be kept through power ups. Once the time change is made TOD will make a call to every waveform plugin to update their time. The waveform will reset their time offset to zero and update any other offsets that the waveform is tracking. It is up to the waveform to implement a function that will perform the updates. A time change request can come from either HMI or GPS. When a time change is requested a waveform can be in one of three states 1 The waveform is running 2 the waveform is not running but another waveform is running or 3 the waveform is not running and there are no other waveforms running.

When the waveform is running a time request comes into TOD which computes an offset between the new time and the current Now time. The offset is stored in the database. The time change is sent to the waveform. The waveform then decides whether or not to accept the time change. If the waveform accepts the time change the Now object and all other TOD components will be updated to reflect the new time. The stored offset will be reset to zero.

When the waveform is not running but another waveform is running a time request comes into TOD which computes an offset between the new time and the current Now time. The offset is stored in the database. A call is made to the waveform plugin that there is a new offset. The waveform is responsible for tracking the current offset. The waveform can store the new offset into its database. Once there is no waveform running TOD can update radio time components including Now to reflect the new time. TOD can reset its offset to zero and make a call to the waveform plugin to reset their offset to zero. The waveform plugin can reset its offset and update any other offsets the waveform may be tracking to reflect the new time.

When no waveforms are running on the radio a time request comes into TOD. The TOD updates time components on the radio including Now . TOD can make a call to the waveform plugin to reset its offset to zero. The waveform plugin can reset its offset and update any other offsets the waveform may be tracking to reflect the new time.

When a time request is made the TOD can compute an offset between the Now time and the new time cumulative offset . When a time request is made TOD can compute an offset between the last offset and the new time current offset . When a time request is made TOD can send both the current offset as well as the cumulative offset to all waveform plugins. When system time has changed Now object updated TOD can send a current offset of zero and a cumulative offset of zero to all waveform plugins to indicate the offsets have been reset.

Each waveform that needs to actively track waveform offsets can implement a function called UpdateOffset which can take in the new time offset as well as the cumulative time offset. The UpdateOffset function can be used to store the current offset to the waveform s database as well as update any offsets the waveform plugin is maintaining.

Many modifications and other embodiments of the invention will come to the mind of one skilled in the art having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore it is understood that the invention is not to be limited to the specific embodiments disclosed and that modifications and embodiments are intended to be included within the scope of the appended claims.

