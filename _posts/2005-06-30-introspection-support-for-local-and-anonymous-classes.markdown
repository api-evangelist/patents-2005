---

title: Introspection support for local and anonymous classes
abstract: A technique in accordance with one embodiment of the present invention provides introspection support for anonymous and local classes. As a result of the technique, an enclosing class that defines a generic type variable that is not defined within a local or anonymous class that refers to the generic type variable can be determined. According to one embodiment of the invention, when a compiler determines that a particular class is a local or anonymous class, the compiler emits, into the particular class' binary class file, information that indicates which class encloses the particular class. In response to the invocation of a method (described herein) relative to a reflective proxy that corresponds to an enclosed class, information that identifies an enclosing class that encloses the enclosed class is returned. This is so even if the enclosed class is a local or anonymous class.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07669184&OS=07669184&RS=07669184
owner: Sun Microsystems, Inc.
number: 07669184
owner_city: Santa Clara
owner_country: US
publication_date: 20050630
---
The present application is related to U.S. patent application Ser. No. 11 105 116 entitled INTROSPECTION SUPPORT FOR GENERIC TYPES by Joseph D. Darcy filed on Apr. 12 2005 the entire contents of which are incorporated by reference for all purposes as though fully and originally disclosed herein.

Java Development Kit JDK is a software development kit for producing Java programming language referred to as JPL herein programs. JDK version 1.5 introduced several extensions to the JPL. One of these extensions is the introduction of generic types. 

Generic types in JPL are analogous to but not exactly the same as templates in the C programming language. Generic types may be most easily understood through a discussion of the scenarios that make the use of generic types beneficial.

According to the syntactical rules of strongly typed programming languages such as JPL the data type of a variable is supposed to be expressed in the declaration of that variable. The following declaration is illustrative Integer x new Integer 0 In the above declaration the variable x is declared to be of type Integer. Thus any attempt to assign to x an object that not an instance of the Integer class or a subclass thereof should be forbidden and should cause the compiler to alert the programmer that something is amiss in the assignment.

The following declaration is somewhat more sophisticated and informative List myIntList new LinkedList In the above declaration the variable myIntList is declared to be of type List. When the above expression is evaluated a new instance of the LinkedList class i.e. a LinkedList object is created instantiated via the invocation of the LinkedList constructor method and assigned to myIntList. The List and LinkedList classes are used as examples in the discussion below but it should be understood that the behaviors of the classes discussed below are not limited only to these classes.

A variable of a particular type can be assigned objects that are of subtypes of that particular type. Like other variables of type List the variable myIntList can be assigned LinkedList objects because type LinkedList is a subtype of type List. The LinkedList object is a linked list of other objects. Prior to the introduction of generic types in JPL the compiler could not determine what the specific types of these other objects were. The type system is a conservative approximation of run time behavior. For example without generic types if only Foo type objects were inserted into a LinkedList then the compiler could not determine upon extraction of these objects from the LinkedList that the objects were of type Foo. Without generic types the compiler merely could determine that these objects were instances of some indeterminable subtype of the Object class in JPL all classes are subclasses of the Object class. Because this was as specific as the compiler could get the extracted objects could only have the methods of the Object class as opposed to the Foo class invoked relative to them.

Because of this shortcoming it often became necessary for a programmer to cast such a returned object into a particular data type prior to assigning that object to a variable that was declared to be of the particular data type. The following code is demonstrative Integer x Integer myIntList.iterator .next In the above code the Object type object returned by the method is expressly cast into an instance of class Integer. If this cast were not performed then the compiler might complain that a non Integer type object was being assigned to a variable of type Integer. Indeed such a complaint would be beneficial because if the compiler did not complain about such an assignment then the compiled program might exhibit unexpected and unwanted behavior if and when the method returned an object that actually was not an Integer.

Having to cast objects in this manner usually irritates programmers and makes source code undesirably verbose and less readable. Some might even consider casting to be a dirty programming practice. Fortunately the advent of generic types in JPL made casting unnecessary at least for the purposes discussed above. A sample declaration that incorporates generic types follows List myIntList new LinkedList 

This is similar to the non generically typed declaration above except that the declaration expressly indicates that the objects within the linked list assigned to myIntList are going to be instances of class Integer. In light of the declaration the compiler knows that every object returned by the myIntList.iterator .next method is an Integer object. The compiler will not complain about the expression Integer x myIntList.iterator .next because the compiler can determine that the object returned by the method must be an Integer object and that variable x can reference objects of type Integer. A single declaration makes potentially many casts unnecessary.

It is also should be noted that generic types allow for specificity in this manner without requiring multiple separate implementations of the class. Although myIntList is a List object that references Integer objects it was not necessary for the programmer to specifically code an implementation of the List class to reference only Integer objects. Generic types allow a class to be defined once in a generic manner and then invoked multiple times in different specific declarations.

Due to the more precise approximation of run time behavior that generic types provide generic types also help to avoid runtime failures.

In the above generic type declarations the angle bracket enclosed parameters e.g. are called the formal type parameters of the generic types. The specific invocation of such a generic type is called a parameterized type. For example the following expression is a parameterized type List In the foregoing parameterized type is an example of an actual type argument. Parameterized types specify actual type arguments that are to be put in the place of formal type parameters when the generic type declaration is invoked. Although examples provided below contain only one formal type parameters and only one actual type argument it should be understood that generic type declarations may specify multiple formal type parameters and parameterized types may specify multiple actual type arguments.

Although JPL generic types and C templates are somewhat similar syntactically and functionally there are some significant differences between the two. The declaration of a JPL generic type is not expanded into multiple different specific declarations for different actual type arguments. Instead much like with non generic type declarations in JPL a JPL generic type declaration is compiled into a single class file.

Because generic types are so useful many of the non generic type declarations that used to exist in the JPL libraries have been replaced with generic type declarations. Non generic method declarations also have been replaced in these libraries with generic method declarations. In other words the former non generic type and method declarations have been generified. The existing libraries have been generified in a way that allows migration compatibility. Programmers who are writing new JPL programs can make use of the generic types and methods by putting parameterized types in their programs.

Classes may be categorized according to a taxonomy that is based to some extent on where those classes are declared relative to other classes. Some classes are top level classes and some classes are nested classes. Top level classes are classes that are not declared within any other class. In contrast nested classes are classes that are declared within another class although perhaps not at the most immediate level.

Nested classes can be categorized further based on whether they are named and are declared immediately within another class. Nested classes that are named and declared immediately within another class are called member classes. The class in which a member class is immediately declared i.e. declared no more than one level down is the declaring class relative to that member class. In other words a member class is a member of its declaring class much in the same way methods and fields may be members of a declaring class.

Some nested classes are not member classes. For example some nested classes are declared within some method that is contained within another class. If a first class is declared within an method that is contained within a second class then the second class is not a declaring class relative to the first class because the first class is not immediately declared within the second class. Under such circumstances although the second class is not the first class declaring class the second class is still the first class enclosing class the first class is contained within the second class but is not immediately declared within the second class.

Among these non member classes are two further subcategories of classes local classes and anonymous classes. Local classes are declared within an intermediate executable block of code such as a method declaration. Anonymous classes are classes that have no declared name.

In the example code below class Local is a local class because it is declared within the declaration of method foo rather than immediately within the declaration of class Top. Class Top still encloses class Local 

Variables of enclosing classes including type variables are included within the scope of the enclosed classes so the enclosed classes and members thereof are allowed to refer to such variables.

It is often useful for a program to have a way of determining at run time characteristics of elements of the running program. The ability to determine such characteristics is called introspection. The JDK Core Reflection Application Programming Interface API supports introspection about the classes in the current JPL Virtual Machine JVM . The Core Reflection API also can be used to construct new class instances and new arrays access and modify fields of objects and classes invoke methods on objects and classes and access and modify elements of arrays. The mechanisms of the Core Reflection API allow certain program elements e.g. classes fields methods etc. to have a corresponding reflective proxy that indicates information about those program elements.

For example certain methods of the Core Reflection API return information about the signature of a method including the types of the method s formal parameters or the return type of the method. Such information may include generic type specific information such as the number and names of generic type parameters.

Because a class may refer to a generic type variable that is defined outside of that class it is useful to have a way of determining the class in which a particular generic type variable has been defined. The Core Reflection API implements a method called getDeclaringClass . When invoked relative to a reflective proxy that corresponds to a member class the getDeclaringClass method returns a reflective proxy that corresponds to the member class declaring class. If the member class refers to a generic type variable that is defined in the declaring class then the getDeclaringClass method can be used to determine the class in which the generic type variable was defined. If the declaring class defines the generic type variable then the reflective proxy that corresponds to the declaring class indicates this fact. If not then the getDeclaringClass method can be invoked relative to that reflective proxy to go one class level higher. In many cases the process may be continued until the class that defines the generic type variable has been determined.

However in some cases this process cannot be used to determine the class in which a particular generic type variable has been defined. If the getDeclaringClass method is invoked relative to a reflective proxy that corresponds to a local or anonymous class then the getDeclaringClass method returns null. This is an entirely correct result because as is discussed above local and anonymous classes are not immediately declared within a class therefore there is no declaring class relative to such classes.

Thus when a local or anonymous class refers to a generic type variable that is defined outside of that class the getDeclaringClass method does not provide any way of determining the class in which the generic type variable is defined.

In accordance with one embodiment of the present invention there is provided a technique that provides introspection support for anonymous and local classes. As a result of the technique the class that defines a generic type variable that is not defined within a local or anonymous class that refers to the generic type variable can be determined.

According to one embodiment of the invention a method called getEnclosingClass is implemented. In response to the invocation of the getEnclosingClass method relative to a reflective proxy that corresponds to an enclosed class information that identifies an enclosing class that encloses the enclosed class is returned. This is so even if the enclosed class is a local or anonymous class. In one embodiment of the invention the reflective proxy of the enclosing class includes information that indicates which generic type variables are defined by the enclosing class.

According to one embodiment of the invention when a compiler determines that a particular class is a local or anonymous class the compiler emits into the particular class binary class file information that indicates the identity of an enclosing class that encloses the particular class. The information in the particular class binary class file can then be used at run time to allow the getEnclosingClass method to determine the particular class enclosing class.

In accordance with one embodiment of the present invention techniques are provided which support introspection for local and anonymous classes. An operational flow diagram which illustrates a high level overview of the operation of one embodiment of the present invention is shown in .

Referring to in block an invocation of a getEnclosingClass method of a reflective proxy is detected. The reflective proxy corresponds to an enclosed class that may be a local or anonymous class. For example the run time environment of a virtual machine may detect the invocation of such a method. Although the method name getEnclosingClass is used for purposes of illustration embodiments of the invention may use a different name for a method that performs the same operations as those described herein in connection with getEnclosingClass . 

In block in response to the invocation of the getEnclosingClass method an enclosing class that encloses the enclosed class is determined. For example the run time environment may determine such information from a binary class file that corresponds to the enclosed class.

In block information that identifies the enclosing class is generated. The information may be returned as a result of the getEnclosingClass method. For example the run time environment may generate and return the information.

In one embodiment the enclosing class reflective proxy indicates among other information the generic type variables that the enclosing class defines. Thus in response to the invocation of a particular method of the enclosing class reflective proxy e.g. method toGenericString information including these generic type variables is returned at run time.

In other aspects the invention encompasses in certain embodiments computer apparatuses computing systems and computer readable media configured to carry out the foregoing technique.

In one embodiment of the invention the run time environment determines a local or anonymous class s enclosing class based on information that is stored in a binary class file that corresponds to the enclosed class. Each class has a separate corresponding binary class file. According to one embodiment of the invention a compiler stores the identity of the enclosing class in the binary class file in response to determining that an enclosed class is a local or anonymous class.

In block a class declaration is detected. In block it is determined whether the class declaration is a declaration of a local class or an anonymous class. If the class declaration is a declaration of a local class or an anonymous class then control passes to block . Otherwise control passes to block .

In block information that identifies the enclosing class of the local or anonymous class is emitted into the binary class file for the local or anonymous class. The information may be accessed by the run time environment in response to the invocation of the getEnclosingClass method of the reflective proxy that corresponds to the local or anonymous class.

Alternatively in block information that identifies the enclosing class is not emitted into the binary class file for the enclosed class whose declaration was detected in block .

According to one embodiment of the invention if a particular named class declaration is contained within a method declaration that is contained within another class declaration then the particular class declaration is determined to be a local class declaration.

According to one embodiment of the invention if a particular class is declared without a name then the particular class declaration is determined to be an anonymous class declaration.

An anonymous class declaration may be contained in an initialization expression for a field of the enclosing class. In the following example code an anonymous class is declared in the initialization expression for field t which is a member of class Foo 

It is possible for a local or anonymous class to be nested within multiple classes. For example a local or anonymous class may be nested within class Foo which may be nested within class Bar which may be nested within class Baz. According to one embodiment of the invention the enclosing class for a local or anonymous class is the class that most immediately encloses the class. In the previous example the most immediately enclosing class of the anonymous class is Foo. 

As is described above in one embodiment of the invention a compiler emits into a binary class file that corresponds to a local or anonymous class information that identifies the class that encloses the local or anonymous class even if this enclosing class is not a declaring class relative to the local or anonymous class. According to one embodiment of the invention the binary class file contains a structure of the following form where the types u2 and u4 indicate types for unsigned numbers that are two and four bytes long respectively for additional information on and definitions of types and constants discussed herein the reader may refer to 2ed. which is by Tim Lindholm and Frank Yellin and which is incorporated by reference for all purposes as though fully disclosed herein 

The attribute info field contains an attributes table. Each value of the attributes table is an attribute structure. According to one embodiment of the invention each attribute is a structure of the following form 

The attribute name index is an index into the constant pool of the class. The constant pool entry at this index is a structure representing the name of the attribute. For additional information about some of the structures described herein the reader may refer to

According to one embodiment of the invention one kind of attribute that may be contained in the attributes table is an EnclosingMethod attribute. According to one embodiment of the invention only local and anonymous classes have an EnclosingMethod attribute. According to one embodiment of the invention the EnclosingMethod attribute has the following format 

The attribute name index is a valid index into the constant pool table. The constant pool entry is a structure representing the string EnclosingMethod. In the embodiment described above the value of attribute length is four.

The class index item is a valid index into the constant pool table. The entry at that index is a CONSTANT Class info structure that represents the innermost class that encloses the declaration of the current class. According to one embodiment of the invention it is into this structure that the compiler emits information that identifies the enclosing class information for a local or anonymous class. In one embodiment of the invention a CONSTANT Class info structure has the following form 

In one embodiment the tag item has the value CONSTANT Class as is further defined in and the value of the name index is a valid index into the constant pool table. In one embodiment the entry at that index is a structure that represents a valid fully qualified class or interface name which may be encoded.

According to one embodiment of the invention each reflective proxy implements a getSimpleName method which when invoked returns the simple name of the class that corresponds to the reflective proxy.

According to one embodiment of the invention each reflective proxy implements a getCanonicalName method which when invoked returns the canonical name of the class that corresponds to the reflective proxy as defined by the JPL Specification.

According to one embodiment of the invention each reflective proxy implements an is AnonymousClass method which when invoked returns true if the class that corresponds to the reflective proxy is an anonymous class and returns false otherwise.

According to one embodiment of the invention each reflective proxy implements an is LocalClass method which when invoked returns true if the class that corresponds to the reflective proxy is a local class and returns false otherwise.

According to one embodiment of the invention each reflective proxy implements an is MemberClass method which when invoked returns true if the class that corresponds to the reflective proxy is a member class i.e. a class that is immediately declared within a declaring class and returns false otherwise.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

In computer system bus may be any mechanism and or medium that enables information signals data etc. to be exchanged between the various components. For example bus may be a set of conductors that carries electrical signals. Bus may also be a wireless medium e.g. air that carries wireless signals between one or more of the components. Bus may also be a medium e.g. air that enables signals to be capacitively exchanged between one or more of the components. Bus may further be a network connection that connects one or more of the components. Overall any mechanism and or medium that enables information signals data etc. to be exchanged between the various components may be used as bus .

Bus may also be a combination of these mechanisms media. For example processor may communicate with storage device wirelessly. In such a case the bus from the standpoint of processor and storage device would be a wireless medium such as air. Further processor may communicate with ROM capacitively. In this instance the bus would be the medium such as air that enables this capacitive communication to take place. Further processor may communicate with main memory via a network connection. In this case the bus would be the network connection. Further processor may communicate with display via a set of conductors. In this instance the bus would be the set of conductors. Thus depending upon how the various components communicate with each other bus may take on different forms. Bus as shown in functionally represents all of the mechanisms and or media that enable information signals data etc. to be exchanged between the various components.

The invention is related to the use of computer system for implementing the techniques described herein. According to one embodiment of the invention those techniques are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another machine readable medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus embodiments of the invention are not limited to any specific combination of hardware circuitry and software.

The term machine readable medium as used herein refers to any medium that participates in providing data that causes a machine to operate in a specific fashion. In an embodiment implemented using computer system various machine readable media are involved for example in providing instructions to processor for execution. Such a medium may take many forms including but not limited to non volatile media volatile media and transmission media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Transmission media includes coaxial cables copper wire and fiber optic cables including the wires that comprise bus .

Common forms of machine readable media include for example a floppy disk a flexible disk a hard disk a magnetic tape or any other magnetic medium a CD ROM any other optical medium punchcards papertape any other physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM any other memory chip or cartridge or any other physical medium from which a computer can read.

Various forms of machine readable media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk of a remote computer. The remotecomputer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line. Appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the worldwide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are exemplary forms of carrier waves transporting the information.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

Processor may execute the received code as the code is received and or stored in storage device or other non volatile storage for later execution. In this manner computer system may obtain application code in the form of a carrier wave.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

