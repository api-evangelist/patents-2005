---

title: Method and system for parallelizing completion event processing
abstract: Disclosed are methods for handling RDMA connections carried over packet stream connections. In one aspect, I/O completion events are distributed among a number of processors in a multi-processor computing device, eliminating processing bottlenecks. For each processor that will accept I/O completion events, at least one completion queue is created. When an I/O completion event is received on one of the completion queues, the processor associated with that queue processes the event. In a second aspect, semantics of the interactions among a packet stream handler, an RDMA layer, and an RNIC are defined to control RDMA closures and thus to avoid implementation errors. In a third aspect, semantics are defined for transferring an existing packet stream connection into RDMA mode while avoiding possible race conditions. The resulting RNIC architecture is simpler than is traditional because the RNIC never needs to process both streaming messages and RDMA-mode traffic at the same time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07761619&OS=07761619&RS=07761619
owner: Microsoft Corporation
number: 07761619
owner_city: Redmond
owner_country: US
publication_date: 20050513
---
The present application is related to U.S. Patent Applications Method and System for Closing an RDMA Connection Ser. No. 11 128 875 and Method and System for Transferring a Packet Stream to RDMA Ser. No. 11 128 710.

The present invention is related generally to remote direct memory access RDMA and more particularly to local processing of RDMA connections carried over packet streams.

DMA direct memory access is a traditional technology that moves or copies items from one place to another in the dynamic memory of a computing device while using only a small amount or none of the resources of the computing device s central processing unit. RDMA extends this concept and moves or copies memory items from one computing device to another. In high speed networking and in high performance computing environments RDMA is expected to become increasingly invaluable. For example data centers and server farms will rely on RDMA to coordinate computing devices connected by networks running packet protocols such as TCP.

Due to the great commercial value of RDMA various aspects of it are being standardized by for example the RDMA Consortium. However these efforts do not as yet adequately address all of the areas of RDMA processing that are significant for producing the efficiencies promised by RDMA. For example RDMA connections are often of long duration and often require intensive use of local input output I O resources. When a single computing device is called upon to support multiple simultaneous RDMA connections the local processing involved can overwhelm the resources of the computing device leading to a bottleneck and to RDMA transfer inefficiencies.

In another area of concern the network interface controller NIC that supports the RDMA connection protocol can get confused or overwhelmed because it also supports the underlying network packet protocol. Coordinating these two protocols with their disparate demands and coordinating both with the operating system of the computing device leads to complex problems and error prone implementations. Most critically problems can arise either when closing an existing RDMA connection or when initiating an RDMA connection on top of an existing packet stream.

The above are just a few examples of the areas of concern left to be addressed before RDMA can achieve its full potential.

In view of the foregoing the present invention provides techniques for efficiently processing I O completion events by distributing those events among a number of processors in a multi processor computing device. For each processor that will accept I O completion events not all processors in the computing device need participate in this at least one I O completion queue is created. Each completion queue supports one or more RDMA connections. When an I O completion event is received on one of the completion queues the processor associated with that queue processes the event. In this manner multiple processors simultaneously handle multiple completion events eliminating processing bottlenecks.

In some embodiments each participating processor is assigned a unique identifier. When an interface comes up an interface queue is created for that interface. The interface queue contains an array of descriptors one descriptor for each participating processor. Each descriptor also stores an identifier of the completion event handler for its processor. Whenever a new completion queue is created it is bound to one of the completion event handlers and thus to one of the participating processors.

Whenever a new completion queue is created a load balancing algorithm can be run to decide which participating processor will be given responsibility for events coming in on the new completion queue. Many load balancing algorithms are known in the art and can be applied here.

Turning to the drawings wherein like reference numerals refer to like elements the present invention is illustrated as being implemented in a suitable computing environment. The following description is based on embodiments of the invention and should not be taken as limiting the invention with regard to alternative embodiments that are not explicitly described herein.

In the description that follows the environment surrounding the present invention is described with reference to acts and symbolic representations of operations that are performed by one or more computing devices unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of the computing device of electrical signals representing data in a structured form. This manipulation transforms the data or maintains them at locations in the memory system of the computing device which reconfigures or otherwise alters the operation of the device in a manner well understood by those skilled in the art. The data structures where data are maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the invention is being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.

RDMA is a recently developing technology that enables one computer to access the memory of a remote peer directly with little or no processor overhead. RDMA enables zero copy sends and receives over a conventional packet network e.g. over a TCP Transmission Control Protocol stream.

The computing device of may be of any architecture. is a block diagram generally illustrating an exemplary computer system that supports the present invention. The computer system of is only one example of a suitable environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing device be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in . The invention is operational with numerous other general purpose or special purpose computing environments or configurations. Examples of well known computing systems environments and configurations suitable for use with the invention include but are not limited to personal computers servers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers and distributed computing environments that include any of the above systems or devices. In its most basic configuration the computing device typically includes at least one processing unit and memory . The memory may be volatile such as RAM non volatile such as ROM or flash memory or some combination of the two. This most basic configuration is illustrated in by the dashed line . The computing device may have additional features and functionality. For example it may include additional storage removable and non removable including but not limited to magnetic and optical disks and tape. Such additional storage is illustrated in by removable storage and by non removable storage . Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media. Computer storage media include but are not limited to RAM ROM EEPROM flash memory other memory technology CD ROM digital versatile disks other optical storage magnetic cassettes magnetic tape magnetic disk storage other magnetic storage devices and any other media that can be used to store the desired information and that can be accessed by the computing device . Any such computer storage media may be part of the computing device . The computing device may also contain communications channels that allow it to communicate with other devices including devices on the network . Communications channels are examples of communications media. Communications media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communications media include optical media wired media such as wired networks and direct wired connections and wireless media such as acoustic RF infrared and other wireless media. The term computer readable media as used herein includes both storage media and communications media. The computing device may also have input devices such as a touch sensitive display screen a hardware keyboard a mouse a voice input device etc. Output devices include the devices themselves such as the touch sensitive display screen speakers and a printer and rendering modules often called adapters for driving these devices. All these devices are well know in the art and need not be discussed at length here. The computing device has a power supply .

While similar the RDMA chimney differs from the traditional TCP chimney offload architecture in several important aspects.

The RDMA Module includes an RDMA Off Load Manager ROLM not shown in . The ROLM performs the following functions see a later section for exemplary implementation details 

The following is a brief overview of the semantics of the WSK API RDMA programming model. There are guarantees and constraints to ensure the proper ordering of a user s RDMA operations. The user can also request fence indicators on certain RDMA operations. All calls are asynchronous.

The RAL proxy interface interacts with the SDP Sockets Direct Protocol to enable kernel bypass RDMA. The interface to the RAL Proxy is a control interface thus it is significantly more sophisticated than the WSK API. The RAL Proxy control interface allows the RAL Proxy to directly manipulate PDs CQ Memory Windows and STags for locally accessed buffers. However all other constraints of the WSK API apply such as ordering constraints. Note that data transfer is not done through this control interface a QP is set up for direct user mode access so all send and receive data are communicated directly from and to the RNIC by the user mode application.

The RDMA Module uses the Transport Layer Interface interface to talk with the TCP chimney module to start and terminate or upload a TCP connection. Once the connection is offloaded to the RNIC the RDMA Module interacts directly with the NDIS Miniport Driver to access the RNIC miniport. To support the RAL Proxy the RDMA Module can add and remove TCP Listen requests through the Transport Layer Interface .

There are three parts to the RNIC Initialization with NDIS 1 advertising RNIC offload capabilities 2 advertising offload handlers and 3 providing call handlers.

 1 NDIS obtains offload capabilities from the miniport by calling the MINIPORT REQUEST HANDLER to query the RNIC miniport s capabilities at initialization time. NDIS issues NdisRequest to query information with OID TCP OFFLOAD TASK. The RNIC miniport returns a list of offload tasks supported by this RNIC through the completion routine. At the end of the offload task list there is a task structure whose task type equals RdmaChimneyOffloadNdisTask. The TaskBuffer field of that task structure contains the NDIS TASK RDMA OFFLOAD structure. This structure contains a list of variables that the RNIC advertises according to the verb specification.

 2 The miniport advertises its dispatch routines offload handlers to NDIS. There are two types of chimney offload handlers generic offload handlers and chimney specific offload handlers. Generic chimney offload handlers and their completion handlers are shared across all types of chimneys. They include InitiateOffload TerminateOffload UpdateOffload and QueryOffload. Because an RDMA chimney is built upon a TCP chimney RDMA offload uses the same set of generic offload handlers as does the TCP chimney. Generic offload handlers are advertised to NDIS when the miniport initializes its TCP chimney. Chimney specific offload handlers are specific to one type of chimney and are advertised to NDIS individually by different chimneys. The RDMA chimney defines RDMA specific offload handlers for some of the most frequently used verbs e.g. Post SQ and Post RQ. For RDMA most of the Update and Query type of verbs are embedded into the two RDMA specific offload handlers RdmaOffloadUpdateHandler and RdmaOffloadQueryHandler. For example Query QP is implemented as an opcode of the RdmaOffloadQueryHandler.

The following structure is defined for the miniport to store RDMA specific offload handlers. The miniport sets the following fields before passing the structure into the above function the Type field of the NDIS OBJECT HEADER is set to NDIS OBJECT TYPE PROVIDER CHIMNEY OFFLOAD CHARACTERISTICS the field OffloadType is set to NdisRdmaChimneyOffload and RDMA specific offload handlers are set to corresponding miniport dispatch routines.

 3 The miniport obtains RDMA chimney specific completion and event handlers from NDIS by calling the NdisMGetOffloadHandlers API 

The RDMA Module needs to be notified by the TCP offload module whenever an interface is brought up or brought down. The RDMA Module also needs to be notified by the TCP offload module of all existing interfaces at the time it initializes. After being notified of the interface events the RDMA Module has an NDIS handle to that interface and can then register up calls for the interface with NDIS. After this the RDMA Module can begin to use this interface for RDMA offload purposes.

At initiation the RDMA offload module registers up calls to the TCP offload module using the following dispatch table 

The TCP offload module calls the above add interface notification up call to the RDMA Module when a new interface has been brought up in the system or when the RDMA Module registers with the TCP offload module. For the later case interface s may have already been brought up in the system and the TCP offload module needs to call up calls for each existing interface.

In order to initiate an RDMA offload process the RDMA Module calls the initiate offload function of the TCP offload module because RDMA is a dependent protocol of TCP. As such the RDMA Module needs to obtain Initiate offload handlers from the TCP module and set corresponding completion handlers to the TCP module. These two sets of handlers are exchanged through the Transport Layer Interface .

Following are the definition of the Initiate Offload handler provided by the TCP module to the RDMA Module and its completion handler 

Offload handlers are exchanged between the TL client and provider in the following way. When a TL client is bound to a TL provider it is provided with the following structure 

To avoid a race condition that might occur during the initiation of an RDMA connection offload the RDMA Module asks the TCP layer to flush all pre posted receive buffers. Moreover the RDMA Module ignores all receive indications from the TCP layer after a certain point in the state transition. Here is a function provided by the TLNPI layer and called by the RDMA Module to flush all pre posted receive buffers on a connection 

This section is illustrated with a series of workflow diagrams that represent offload procedures. In the calls in these diagrams a W refers to WSK an R refers to the RDMA Module and an M refers to the RNIC miniport. So for example WR represents a call between the WSK module and the RDMA Module .

For the WSK layer a socket can have the following states StreamingMode RdmaTransitionInProgress or RDMAMode. For the RDMA Module layer a connection can have the states NotReadyToOffload ResourceReservationInProgress ReadyToOffload WaitForFirstRecvBuffer OffloadInProgress or Offloaded.

The WR1 call forwards the SIO RDMA RESERV RESOURCE Ioctl request from WSK to the RDMA Module . This call essentially starts the state machine in the RDMA Module . The RDMA Module maintains a separate state machine for each connection. The successful completion of this call places the connection in the ReadyToOffload state. While this call is pending the state of the connection is ResourceReservationInProgress. This API is provided by the RDMA Module to the WSK Module 

WR1 C is the completion routine of WR1 and it indicates the result of that call. If the return result is STATUS SUCCESS then the actual values of the QP properties are also returned.

RM1 is potentially a series of calls made by the RDMA Module to the RNIC miniport to create a QP. To create the QP the miniport needs to be provided with a Protection Domain ID and a Completion Queue handle. Multiple QPs can share one PD and one CQ. The RDMA Module decides whether the QP to be created will share PDs or CQs with other QPs based on its PD CQ sharing policy. For the WSK interface by default a PD is unique on a per connection basis but the consumer has the option to put different connections into one PD. A CQ is shared among a limited number of QPs. For the RAL Proxy interface there are no defaults The RDMA Module exposes essentially all of the parameters that can be set for the creation of a PD CQ and QP directly to the RAL Proxy. If the RDMA Module decides that a new PD CQ should be created for this QP then the following dispatch routines are called.

RM1 PD is an asynchronous call to create a PD. Upon successful completion the Protection Domain ID PDID is created. In terms of the NDIS API this call is embedded into the Update Offload call with create PD as its op code.

RM1 CQ creates a CQ or modifies a previously created CQ. The call to create a CQ is asynchronous and specifies the length of the CQ. That length is the sum of the lengths of the RQs and SQs send queues that share this CQ. The length of a CQ can change when more SQs and RQs are associated with this CQ. In terms of the NDIS API the create CQ call is embedded into the Update Offload call with Create CQ as its op code. After the CQ has been successfully created completion notification is requested on the new CQ. It is required by the RDMA verb spec that a consumer of a QP request completion notification for a CQ if notification has been requested when a CQE completion queue event is queued. Otherwise the completion event handler is not called if anything is queued into this CQ.

The following apply when RM1 CQ is called to modify an existing CQ. 1 If the RDMA Module decides that this QP can share a CQ with other QPs then it retrieves the handle of an existing CQ that is to be shared from its internal table. However the existing CQ may not be large enough to accommodate the new QP so it may need to be resized by the Modify CQ verb. 2 Modify CQ is called after the RM1 QP create QP call. The RDMA Module first tries to create a QP of the desired size and if the creation of the QP is successful then it tries to modify the existing CQ that will be shared by the newly created QP. 3 If the CQ cannot be grown to accommodate the additional QP then a new CQ is created. 4 In terms of the NDIS API this call is embedded into the Update Offload call with Modify CQ as its op code. 5 The re sizing operation on a CQ is expensive and may affect the operation of the QPs that are associated with the CQ being resized. The RDMA Module tries to re size the CQ as few times as possible and associates only a reasonable number of QPs with a CQ.

RM1 QP creates a QP. After the PD ID and CQ handle have been created the RDMA Module layer calls the Create QP verb to create a QP for this connection. This call is made before the RM1 CQ call if the RM1 CQ call is to modify an existing CQ. In other words a QP is created first and then the CQ is modified to accommodate that new QP. In terms of the NDIS API this call is embedded into the Update Offload call with Create QP as its op code.

RM1 C QP RM1 C PD and RM1 C CQ are the completion handlers corresponding to the above original calls.

When the completion handler of Create QP is called the RNIC state for this connection has been allocated. The PD CQ and QP are initialized. The QP is in the IDLE state. The RDMA Module calls WR1 C with the corresponding status and reason code. The completion chain eventually pops up to the WSK or RAL Proxy consumer and this finishes the Ioctl call to reserve RDMA offload resources. At the successful completion of this process the RDMA Module sets the connection state to ReadyToOffload.

After RDMA resources have been successfully allocated the consumer may wish to exchange additional configuration information before transitioning into RDMA mode. The only parameter that can be changed through the WSK interface is the amount of RDMA read resources IRD and ORD . This call can be made while the connection is in streaming mode or RDMA mode. If there are outstanding calls to WskRdmaGet the RDMA Module completes the call with an error. If there are no outstanding WskRdmaGet calls then the ORD value may be changed. The IRD value should only be changed if there will be no RDMA Read Requests arriving on the link. If there are changing IRD could cause the connection to be torn down. For some applications this value will be changed before any RDMA Reads can be generated. For other applications an application specific negotiation is done to flush RDMA Read Requests before the change is made. Note that both the IRD and ORD are specified. If no change is desired then the values from the last call which set the IRD or ORD resource should be used.

In a request is made to change RDMA read resources. RR1 WR simply passes the request structure through to the RDMA Module . The RDMA Module then issues a Modify QP RR1 RM to change the RDMA Read Resources if there are no outstanding RDMA Read Requests. Note that it is expected that changing IRD while the QP is still in the IDLE state will always succeed.

WSK sets the state of this connection to RdmaTransitionInProgress and keeps the connection in this state until it receives a successful completion of the offload . When is called the connection has been switched into RDMA mode. WSK moves the state of this connection to RDMAMode. 

Immediately after WSK moves to the RdmaTransitionInProgress state it flushes the receive buffers and begins to ignore any receive indications from the TCP layer. It returns STATUS DATA NOT ACCEPTED for all receive indication up calls from the TCP layer. By doing so it effectively asks the TCP layer to process all incoming data and then buffer them. Later the buffered data are forwarded to the RNIC . This is required to avoid a race condition that could happen during RDMA offload initiation. Moreover immediately after WSK moves to the RdmaTransitionInProgress state all of its pre posted receive requests if any to the TCP layer are completed with a certain number of bytes most likely with zero bytes .

At 2 the following API is used by the WSK to signal the transition to RDMA mode. This API requests that the TCP stack flush all pre posted receive buffers. TLNPI should expose an API for this purpose . Moreover this API sets the state of this connection in the RDMA Module to WaitForFirstRecvBuffer state which is the last state before the offload actually starts. Note that the TCP state may be in the host stack or it may have been offloaded already.

The following call is made by the RDMA Module layer to the TCP layer. It asks the TCP layer to flush all pre posted receive buffers. This call is specified by the TLNPI interface.

At the consumer may perform one or more normal TCP sends on the outgoing half of the TCP stream. This feature may be used by some ULPs to set up the RDMA connection. If a ULP requires that a last streaming mode message be sent to the remote peer to trigger the remote peer to switch to RDMA mode then that last streaming mode message is sent in this step that is after call 2 and before step . After the consumer has sent his last streaming mode message to the remote peer the consumer posts the first RDMA receive request to trigger the real transition process and to notify the RDMA module that the last streaming mode message has been sent. After step the consumer cannot send any more streaming mode messages.

A consumer is not required to wait for the completion of call 3 WskSend before making call 4 WskRdmaRecv . As such it is possible that the consumer may make call 4 to trigger the offload process before the TCP layer completes sending the last streaming message. In other words call 4 may be made by the consumer before the TCP ACK for the last streaming message is received or even before the TCP layer sends out the last streaming message. If this happens the RDMA Module waits for the completion of call 3 before it actually starts executing call 4 for the consumer. This helps solve many race conditions that would have happened if un completed outgoing streaming mode messages were handed down to the RNIC as part of the RDMA offload state. This means that the RNIC need not have dual modes to support both Streaming mode and RDMA Mode traffic at the same time. This also frees the RNIC from the complications of re transmitting the last streaming mode message when the hardware is in RDMA mode. From the RNIC s point of view there will be no last streaming mode message to send The message should have already been sent and TCP ACK received by the software stack before the offload initiates. This also implies that no outgoing streaming mode messages are forwarded down to the RNIC at or after RDMA offload initiation.

At step the consumer makes a WskRdmaRecv call and the actual RDMA offload process begins. The consumer should be able to estimate the size of the first incoming RDMA message based on his application and protocol needs. This call is designed to avoid a potential race condition when entering RDMA mode. If the consumer were not required to pre post a buffer before entering RDMA mode it is possible for the remote peer to send an RDMAP Send Type Message before the consumer has time to post a receive buffer after the transition to RDMA mode completes . If this occurs the connection would be torn down. Thus the API requires that the consumer pre post at least one buffer. After WSK gets this call at 4 it forwards the request to the RDMA Module through call WR4 not shown in .

WR4 is an API provided by the RDMA Module to let users pass in a receive buffer after requesting the transfer to RDMA mode. WR4 posts an RDMA receive buffer to the RDMA Module layer and starts the offload process by calling TCP offload functions. The WR4 API is specified as follows 

RT4c is the initiate offload call provided by the TCP layer. The RDMA Module passes in an NDIS PROTOCOL OFFLOAD BLOCK which has RDMA OFFLOAD STATE.

A set of calls is made by the TCP chimney to start its offload process. This goes all the way down to the RNIC with a linked list of offload state blocks. In that linked list the RDMA protocol offload block is a dependant block of the TCP protocol offload block. As such the miniport knows that this TCP connection is also going to be offloaded as an RDMA connection. The QP handle is contained in the RDMA OFFLOAD STATE block and it will be the QP used for this connection. A completion routine is called by the RNIC miniport to the TCP chimney to indicate that the offload has been completed. It indicates that both the TCP and the RDMA offload have been completed.

The TCP layer signals completion to the RDMA Module . This is the completion routine corresponding to call RT4c. At this point the RDMA Module is notified that the RDMA offload has been completed and it takes two actions immediately 1 It signals a completion for call 2 which is the first call made by the user to initiate the RDMA offload process. This completion is not signaled for WR4 because that is a Receive call which posts a receive buffer and it should not be completed until the receive buffer is filled. The WR4 call will be completed by WR4 C later. 2 The RDMA Module sets its internal state machine for this connection to the Offloaded state. The prototype of this completion call is 

Upon receiving a completion indication corresponding to the start offload call the WSK layer sets the state of this connection to RDMAMode. The completion routine is called by the RDMA Module layer and is defined as follows 

The completion routine corresponding to call 2 the WSK Ioctl call that sets the socket into RDMA mode is called by the WSK layer to the user of WSK. Upon receiving a successful completion at this point the user of WSK can be sure that the RDMA connection has been offloaded and that new RDMA requests can be posted on this connection. The WSK sets the state of this socket to RDMAMode. 

WR4 C is the completion routine for the WR4 call. It is called by the RDMA Module after it receives a CQ completion indication from the RNIC . The CQE retrieved from the CQ indicates that the receive buffer posted at the beginning of the offload by WR4 has been filled. The receive completion routine is defined as follows 

The completion routine for call 4 indicates that the receive buffers posted have been filled with RDMA data.

To summarize the WSK states WSK is in StreamingMode before the consumer makes call 2 is in RdmaTransitionInProgress immediately after call 2 and before call 2 completes and is in RDMAMode immediately after call 2 completes. While the WSK is in StreamingMode the consumer can call 

After the RNIC has transferred the TCP stream into RDMA mode incoming data may have been buffered by the TCP layer. As discussed above no outgoing streaming mode data are forwarded to the RNIC during RDMA chimney offload. The RNIC does not need to send the last streaming mode message The message should have already been sent and a TCP ACK received by the software stack before the offload initiates. However the RNIC does need to process incoming RDMA mode data that are received before and during the RDMA offload process. Those data are either handed down to the RNIC as part of the TCP offload delegated state or forwarded to the RNIC through the TCP forwarding interface.

There is a potential race condition in which a remote peer may begin to send RDMA mode data even before the local peer initiates offload. In this case the TCP software stack accepts all incoming data does normal TCP protocol processing on these data and buffers the TCP payload in its buffer. The TCP payload is actually RDMA protocol data including MPA marker DDP header RDMA header etc. Data that are received at this stage are handed down to the RNIC as part of the TCP delegated state with the initiate offload call. The RNIC processes these data as pure RDMA data. They have already been TCP processed by the software stack TCP CRC checked TCP ACK sent etc. .

RDMA data may also come in during the offload process i.e. RDMA mode data may come in after the RDMA module requests Initiate offload to the RNIC and before the RNIC completes the offload request. In this case the TCP software stack accepts all incoming data and buffers them as raw data. No TCP protocol processing is performed on these data. As soon as offload completion is signaled by the RNIC the TCP layer forwards all incoming raw data that are buffered during this stage to the RNIC through the TCP forwarding interface. The RNIC first TCP processes these forwarded raw data and then processes the TCP payload as RDMA data.

For resource allocation there are two types of error recoverable errors and non recoverable errors. Recoverable errors are caused when the user s resource demands exceed the RNIC s capacity e.g. Create QP fails because the requested IRD ORD is too large or Modify CQ fails because the new CQ size cannot be supported. The RDMA Module returns a reason code to indicate to the user what has gone wrong. The user can then decide to re request resource reservation or just abort. Non recoverable errors include those caused by an RNIC failure or a lost connection. Those errors return their own error codes and the user can abort the offload attempt and return an error message to the remote peer if possible. Non recoverable errors include NIC is not an RNIC failure to create a new PD and failure to create QP even with the minimum input values. During the offload process if the RDMA offload fails then the connection is torn down instead of being switched back into TCP streaming mode.

For an RDMA chimney offload a gang offload uses the same algorithm and design as that of the TCP chimney but there are some additional steps to take care of 

At the beginning of the offload the following state is passed in as the RDMA OFFLOAD STATE block to the chimney driver 

After the RDMA Module successfully offloads the connection the QP has the following states Idle RTS Closing Terminate and Error. These states are handled by the RDMA Module and they are not seen by the user. The user is notified of termination error and closing events by the RDMA Module through event handlers.

STags are required for RDMA data transfer operations. STags can have invalid and valid states after they are created. The consumer needs to keep track of the states of local STags that have been advertised for remote access and invalidate them as necessary. The consumer also needs to keep track of any remote STags that are received from the remote peer and invalidate them as necessary. For local STags that are used for local access only the user may choose to keep track of them if he wants to re use the buffers. Otherwise the RDMA Module transparently handles this type of STags.

The RDMA Module sets completion event handlers to the miniport through the Set Completion Event Handler verb. An RNIC may support more than one completion event handler. Each time a new completion event handler is set the RNIC miniport returns an identifier to the consumer. The identifier is used when the consumer creates a new CQ and associates that CQ with the completion event handler. This is the definition of the completion event handler 

The miniport calls the above handler when there is a CQE queued into a CQ and the completion notification has been requested for the CQ. The completion event handler is given the CQ Handle as an input. The RDMA Module implements the completion event handler as follows 

When the RDMA Module creates WRs to post to the SQ it sets the Completion Notification Type of most of the WRs as signaled completion. However to avoid completion processing overhead the RDMA Module sets some of the WRs as unsignaled completion. Those WRs that are set as unsignaled completion have their completion status indirectly notified by immediately subsequent WRs. The following WRs are set as unsignaled completion if they are immediately followed by other WRs PostSQ Fast Register and PostSQ Invalidate Local STag.

Similar to the handling of Work Request Completions there is only one Asynchronous Event handler for an RNIC . That asynchronous event handler is called by the RNIC when there is an affiliated asynchronous event. The RDMA Module registers an asynchronous event handler to the miniport at the time the NDIS exchanges call handlers with the miniport. This is the definition of the asynchronous event handler 

Most asynchronous events are signaled when the RNIC encounters remote or local errors and the RDMA connection is going to be closed. The RDMA Module processes the event logs the error and initiates the connection tear down and resource clean up processes with the RNIC . The RDMA Module eventually makes the Connection terminate up call back to its user signifying that the connection has been torn down.

When an RDMA CQE is indicated from the RNIC to the host stack the host stack usually polls the CQ takes out all CQEs of the CQ and processes them one by one. Traditionally even on a multi processor computing device only one processor performs this work while the rest of the processors are idle. and the following text describe how multiple processors can be used in parallel to speed up CQE processing. This method is applicable to any RNIC that supports multiple CQE handlers.

In step of when an RNIC is indicated as up to the RDMA module the RDMA module sets up a per interface data structure to track the interface. That per interface data structure contains an array of descriptors. Each descriptor corresponds to one processor and stores a completion event handler ID for that processor step . Later if there are CQs to be created on that processor this completion event handler ID is used for them.

The array is initialized at interface up time. The RDMA module uses the SET COMPLETION EVENT HANDLER verb to set completion event handlers to the RNIC . The RDMA module calls this verb N times where N equals the number of processors in the system or the subset of the total number of processors that will be involved in CQE processing . As shown in for each call the RDMA module provides the RNIC with a data structure containing a processor number and a completion callback function. This associates each completion event handler with one processor. For each invocation of the SET COMPLETION EVENT HANDLER verb the RNIC returns a unique completion event handler ID. Thus a one to one mapping is established between completion event handler IDs and processors. illustrates the process of initializing the per interface completion event handler ID array using the augmented SET COMPLETION EVENT HANDLER call.

When a new RDMA connection is to be established the RDMA module decides whether a new CQ should be created for that RDMA connection. If a new CQ is created then the RDMA module runs a load balancing algorithm and other heuristics to determine on which processor to create the CQ step of . Once a decision is made to create a new CQ on a processor for example on processor K the RDMA module uses K as an index into its per interface array of completion event handler IDs and retrieves the completion event handler ID of processor K. That ID is used as an input to create this new CQ. Doing so effectively tells the RNIC that this new CQ is bound to processor K. The result of this step is for each processor a two level tree of CQs and QPs rooted from the processor. For a multi processor computing device this becomes a forest of trees as illustrated in .

When a CQE is queued into a CQ and a decision is made to indicate the CQE to the host OS step of the RNIC miniport driver schedules a DPC to run on the processor that is associated with the CQ. The RDMA Module polls the CQ and processes each CQE polled in the context of the DPC routine step . Because multiple DPC routines can run on multiple processors simultaneously this achieves the goal of parallel CQE processing.

Closing an RDMA connection can be a very complex and error prone process if not handled carefully. Complexity mainly comes from two aspects 1 interactions between the host OS and the RNIC hardware and 2 interactions between the RDMA Module and the TCP layer of the host OS.

The following rules and processes define the interactions between the RNIC and its miniport driver and the host OS for successfully handling RDMA connection closure. These general rules are illustrated below in the context of specific closure scenarios.

The TCP Disconnect Request Handler is used by the TCP software stack to issue a graceful or an abortive disconnect request to the RNIC s miniport driver. The TCP Disconnect Event Handler is used by the miniport driver to indicate a graceful or an abortive disconnect event to the TCP software stack. In the context of RDMA offload the software stack is notified through this event handler about connection status and it then performs RDMA state transitions accordingly.

As a first illustration of these concepts presents an overview of the procedure for handling a graceful disconnect request. After an RDMA connection is established step the RNIC miniport is called to perform a TCP graceful disconnect step .

When the RNIC miniport is called to perform a TCP abortive disconnect this is considered the equivalent of Modify QP RTS Error . 

When a graceful disconnect event is signaled by the miniport driver to the host OS through the TCP Disconnect Event Handler 

When an abortive disconnect event is signaled by the miniport driver to the host OS through the TCP Disconnect Event Handler the RNIC miniport driver applies normal TCP semantics. Briefly If a TCP RST is received from the remote peer indicate this event If the connection is lost times out indicate this event. If the RNIC wants to send out an RST for whatever reason indicate this event. For RDMA Chimney if the miniport needs to perform an abortive LLP close due to RDMA conditions then the miniport should do so. The miniport is allowed to send out a TCP RST by itself. As soon as the LLP connection is abortively closed the miniport indicates this abortive disconnect event back to the host.

These are definitions of the semantics and rules of the TerminateOffload call for the RDMA Chimney offload architecture.

To more fully explain the above concepts illustrate the following possible RDMA closing and error scenarios 

At point A in the RDMA Module knows that the connection has been reset aborted and it calls down Terminate Offload. It also knows that the QP is in the Error state.

At point B in the RDMA Module calls Modify QP Error Idle . If the QP is still flushing then the miniport driver returns STATUS PENDING to the RDMA Module upon a Modify QP Error Idle request. Once the QP has completed flushing the miniport driver completes the original Modify QP Error Idle request with STATUS SUCCESS. Otherwise if the miniport driver deems that the RNIC hardware is taking too long to flush or is being non responsive then the miniport driver can complete the original Modify QP Error Idle request with a special error status STATUS ABORTED . Regardless of the completion status of this request the host stack begins the RDMA resource destroy sequence which includes a DestroyQP call.

At point A in the RDMA Module knows that the LLP has been completely closed so that it can call down Terminate Offload. As soon as the Terminate Offload completes the RDMA Module calls Query QP if necessary to get the current state of the QP. If the result shows that the QP is in the Closing State then the RDMA Module starts a timer to wait for the LLP Closed event. At point B the RDMA event LLP Closed is signaled to the RDMA Module so that the RDMA Module knows that the QP is in the Idle state and the RDMA Module starts the RDMA resource clean up sequence. Point B may happen at any time after point A.

Note If some serious problems happened to the RNIC that prevent it from flushing the RQ successfully then the RDMA Module is not signaled with the RDMA event LLP Closed and the QP is hanging in the Closing state. The RDMA Module does not wait forever for this event It starts the RDMA resource destroy sequence when a timer expires.

Note that the RDMA Module may call Query QP in this case because it needs to differentiate this case from the cases of . For those two cases the QP should be in the Closing state and a timer is needed to wait for the RNIC to signal either a Bad Close or an LLP Closed RDMA event. In the present case the Query QP returns the Error state and the processing at point B of is performed.

Note that in the no error case see and accompanying text the RNIC signals the RDMA event LLP Closed after it successfully moves the QP state from Closing to Idle. So the Bad Close event differentiates the present case from that case.

Also note that the RDMA verb spec requires that the RNIC signal either LLP Lost or LLP Reset in case of an LLP failure. However these two RDMA events are redundant with DisconnEvent a . In the RDMA chimney the RDMA Module always waits on DisconnEvent a and ignores RDMA Events LLP Lost and LLP Reset. 

The remaining cases all involve abnormal closes. An RDMA abnormal close is initiated either by the RNIC itself or by the consumer because of RDMA errors or LLP errors. During an RDMA abnormal close the LLP connection may be closed abortively or if possible gracefully. Typically a terminate message is sent or received by the RNIC if conditions allow.

Note that in point E indicates that a DisconnEvent g or a DisconnEvent a might also be signaled by the RNIC miniport at this point. The miniport signals DisconnEvent g as soon as it receives a TCP FIN from the remote peer and signals DisconnEvent a as soon as the LLP is reset or lost. Both of these events may happen before or after the host stack calls down Disconn g . This is the implication of point E.

After the Terminate Offload call completes the RDMA Module may call Query QP to query the current state of the QP if necessary. Query QP is called to differentiate this case from the non error closing case.

During the entire process if the RNIC miniport receives a TCP FIN from the remote peer it indicates a DisconnEvent g to the host stack and if it receives a TCP RST or if it sends a TCP RST it indicates a DisconnEvent a to the host stack.

Note that in a DisconnEvent g or a DisconnEvent a might also be signaled by the RNIC miniport at point E.

No Figure The remote peer initiates an abnormal close by sending a TCP RST. No Terminate message is sent or received by the local peer. The LLP connection is abortively closed.

In view of the many possible embodiments to which the principles of the present invention may be applied it should be recognized that the embodiments described herein with respect to the drawing figures are meant to be illustrative only and should not be taken as limiting the scope of the invention. Those of skill in the art will recognize that some implementation details such as the detailed semantics and procedures of the RDMA Chimney architecture are determined by specific situations. Although the environment of the invention is described in terms of software modules or components some processes may be equivalently performed by hardware components. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

