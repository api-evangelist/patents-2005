---

title: Methods and platforms for highly available execution of component software
abstract: A method for executing component-based software includes creating a first relation between a first identifier identifying a first software component and an interface for a first container created for the first component, starting a second component defined as a substitution component for the first component when a replacement condition is met, creating a second relation between a second identifier identifying the second component and an interface for a second container created for the second component when starting the second component, changing the first identifier to the second identifier in the first relation and the second identifier to the first identifier in the second relation when starting the second component, using the first component to process requests to the first component received prior to completion of starting the second component, and using the second component to execute requests to the first component newly received after completion of starting the second component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782666&OS=08782666&RS=08782666
owner: Hitachi, Ltd.
number: 08782666
owner_city: Tokyo
owner_country: JP
publication_date: 20051129
---
The present application claims priority from Japanese Application JP 2005 158299 filed on May 31 2005 the content of which is hereby incorporated by reference into this application.

The present relates to methods and platforms for highly available execution of component software consisting of a plurality of software components.

The utilization of web applications using a web browser as the caller is rapidly expanding in many areas of use from on line shopping sites to the business systems of corporations. Today s web applications use a component based structure combining a plurality of small scale software components with a view to facilitating quick development and flexible functional modification. As platform techniques for such component applications there are J2EE Java 2 Enterprise Edition Java is a registered trademark of Sun Microsystems Inc. and .NET registered trademark of Microsoft Corporation . The usual practice is to develop web applications by using one or both of J2EE and .NET. J2EE and .NET provide APIs Application Programming Interfaces for web applications and the developers of web applications develop web applications by using these APIs. Web applications developed by using these APIs are executed on a platform for executing applications known as a J2EE server or a NET server. In the following paragraphs component applications and a platform for their execution will be described with J2EE taken up as an example.

Components in J2EE are referred to as EJBs Enterprise Java Beans . Main EJBs include a session bean and an entity bean. The session bean is an EJB which performs processing correspondingly to the user s session while the entity bean is an EJB representing permanent data irrespective of the user s session. Entity bean data are usually stored in a database. EJBs are components stated in the Java language in accordance with the API of J2EE. An EJB supports two interfaces including a remote interface and a local interface to refer to itself from outside such as another EJB. The remote interface is mainly used for calling the EJB deployed on a remote machine. On the other hand the local interface is used for communication with a local EJB deployed on the same J2EE server. Which of the two interfaces can be used depends on the packaging of the EJB.

The configuration of a platform for execution of component software according to a known technique is shown in with the J2EE server taken up as an example. Reference numeral denotes an execution platform for component based software a deployer and containers each of which is an execution environment for EJB execution and remote request receivers for receiving requests between containers a remote request sender for sending requests between containers and a name server. Reference numeral denotes a file system in which EJB class files and are to be arranged. In the example shown in two files EJB A and EJB B are deployed in the J2EE server. Incidentally though only one application execution platform is shown in this drawing it is also possible to architect one application by making ready a plurality of application execution platforms and distributively deploying an EJB on each platform. The constituent elements shown in will be described below.

The name server is a server that manages the bindings between names and objects and supports functions of JNDI Java Naming and Director Interface APIs. The name server has a table and a name server controller . The table has fields of names and objects . The name server controller provides JNDI APIs to the caller and realizes the functions of each API. The name server has the following four APIs.

Of these APIs bind registers pairs of a name N and an object O N O each in the name server lookup references the name server by the name N and takes out the object O matching the name N rebind changes the object part of the name N object O pair N O from O to On and unbind removes the entry N O of a name N from the name server. Two entries and are registered in the table of the name server of . Although the name server is present in the application execution platform shown in name server may be present independent of the application execution platform.

The deployer reads in EJBs from the file system and creates containers for the EJBs and remote request sender and receivers on that basis referred to as deploying. When EJB A is to be deployed for instance the deployer reads in the class file of EJB A from the file system and creates the container the remote A request receiver and the remote A request sender of EJB A. Then deployer calls the bind API of the name server and registers the pair of the name A of EJB A and remote interface IntConA of the container A IntConA in the name server denoting the registered entry as . When EJB B is deployed in the same way the deployer reads in the class file of EJB B from the file system and creates the container the remote B request receiver and the remote B request sender the remote B request sender will not be used hereinafter and accordingly is not shown in of EJB B. Then deployer calls the bind API of the name server and registers the pair of the name of the component B and the remote interface IntConB of the container B IntConB in the name server denoting the entry as .

The deployer has a function to undeploy any deployed EJB. To undeploy an EJB first an EJB instance operating on the container of the EJB is discarded and then the container remote request receivers and remote request sender are discarded.

The container and the container are execution environments for supporting the execution of an instance of EJB A and an instance of EJB B respectively. The instances and are created in accordance with a create request from the caller.

The remote A request receiver and the remote A request sender are paired and support communication for remote requests of EJB A from the caller. Similarly the remote B request receiver and the remote B request sender not shown in are paired and support communication for remote requests of EJB B from the caller. The protocol of RMI remote method invocation IIOP or the like is generally used for these communication processes. The remote request receivers and may constitute the skeleton of RMI and the remote request sender the stub of RMI. These pairs of remote request receivers and remote request senders are either automatically created by the J2EE server at the time of deploy or incorporation into the J2EE server from the outset.

The file system is a file system of the OS by which the execution platform of component based software operates.

The class files and are object files of Java and are obtained by compiling Java source codes with a Java compiler. Or these class filed consist of object files obtained by compilation and deployment descriptors for their deploying archived as JAR files.

The description of a method call between EJBs with reference to a case in which the instance of EJB B calls a method methodX of EJB A in . The codes for calling the method methodX of EJB A in EJB B are generally stated as shown in . First on the first and second rows of the name server is referenced by using the lookup API of JNDI and the remote interface of the container A of EJB A matching the name A is acquired the home interface . Next on the third row the create method of the home interface of EJB A is called. The call for the method create of the remote home interface reaches the container A via the container B the remote A request sender and the remote A request receiver . The container A upon receiving the create request creates one instance of EJB A and returns the remote interface of this instance of EJB A the component interface as the return value to the instance of EJB B via the remote A request receiver the remote A request sender and the container B . The component interface is received by the instance of EJB B. Finally when the instance of EJB B calls on the fourth row the method methodX to the component interface of EJB A that request reaches the instance of EJB A via the container B the remote A request sender the remote A request receiver and the container A . The called instance of EJB A executes the method methodX and returns the result to the instance of EJB B via the container A the remote A request receiver the remote A request sender and the container B .

For the purposes of the present discussion it was assumed that when EJB B is the caller of EJB A and is to communicate with the container A by using the home interface of EJB A EJB B communicates with the instance of EJB A by using the component interface the same remote request sender and remote request receiver would be used. The message for a remote request passing the remote request sender and the remote request receiver in order to realize such communication is composed as represented by in wherein reference numeral denotes a target identifier indicating the target of access the method to be called and the list of method arguments of the method . The target identifier is a container ID or an EJB instance ID. The remote request receiver or executes a request when the target identifier of the message is a container ID to the container or when it is an EJB instance ID to the EJB instance. Depending on the packaging of the J2EE server two types of remote request senders and remote request receivers may be used one for the home interface and the other for the component interface.

While the foregoing description referred to a case in which an EJB provides a remote interface where a local interface is to be provided local receivers and local senders may as well be used in place of the remote request receivers and the remote request to make possible optimized low cost communication specialized for use within the same J2EE server.

Now with the dissemination of such web application sites competition among these sites is intensifying and every site is pressed for quick modification and addition of functions to match customers preferences. Quick modification and addition of functions requires development and testing within a limited period of time and therefore adequate testing cannot always be done. Therefore bugs are highly likely to remain in a web application already being operated and such bugs may invite failures and stop the service. These bugs may invite failures in the system and in the worst case stop its service. Since the system failure of a web application caused by bugs or any other reason would inflict an enormous loss on the site interest is now focused on methods of execution that can keep the website in service even in the presence of bugs.

As is known to those possessing an ordinary skill in the pertinent arts restarting the application can tentatively solve many of the failures invited by bugs some of the sites operating web applications periodically restart their web applications to prevent failures.

Methods of efficient restoration from failures by implementing restarting at the level of components of fine grain size are disclosed in JP A No. 82926 2002 Patent document 1 and George Candea et al. A Microrebootable System A Technique for Cheap Recovery 6th Symposium on Operating Systems Design Implementation 2004 Non patent document 1 .

Patent document 1 discloses a remedial method for use in a component based application by which codes for measuring the processing time are embedded into software components to monitor the reliability and performance of the system during its execution the processing time is thereby measured the components are determined to be in an abnormal state if the measured processing time exceeds a preset threshold and the components are blocked or restarted.

Non patent document 1 discloses a technique known as microrebooting by which faster restoration from a failure is achieved as compared to restarting the whole application. This timesaving can be achieved by restarting only the failed component in which bugs or any other trouble has occurred out of the components constituting the web application. This document also describes a method by which if there is a sign of imminent failure the likely failure is prevented at low cost by microrebooting the components.

On the other hand restarting involves a problem that a processing request addressed to the restarted component would result in an error. As proposed solutions to this problem JP A No. 77120 1996 and JP A No. 290637 2001 respectively Patent documents 2 and 3 describe methods by which a new component is created in advance instead of ending and restarting an existing component and restoration from failure and prevention of error can be achieved at the same time by replacing the old component with the new.

According to Patent document 2 a monitoring process is allocated to each of the objects and instances constituting the application and monitors the status of execution of every object and instance and any object or instance diagnosed to be abnormal is replaced with a substitute object or instance.

Patent document 3 discloses a method of replacing in a multi process multi thread application some components with new ones without stopping the application. By this method all the processing threads for the components to be replaced are stopped temporarily and the components are replaced when all the threads have been stopped.

However these conventional techniques involve the following problems. First there is a problem of deterioration in performance because when any component is to be replaced the whole processing on that component is stopped. Second when the method of an EJB is to be called as described above the calling party successively acquires the home interface and the component interface of the EJB to be called and finally makes the intended request. Any request to the EJB subsequent to the replacement of the call destination EJB should be executed on the new EJB having replaced the old one. However if the call destination EJB is replaced immediately after the calling side has acquired the home interface or both the home interface and the component interface any subsequent request will be attempted to be executed on the old EJB because the interface is that of the old EJB. If the old component is ended immediately after the EJB replacement any request to that old EJB will end up as an error. A method which allows the old component to survive the EJB is conceivable but since the home interface and the component interface for the old EJB may be kept alive by the caller s program for a long time the attempt to prevent failure by replacing the EJB may fail because the old component may not be completely ended and this might invite a failure.

Then a first problem to be solved by the present invention is to provide a method for executing a component application to replace components adaptively to any sign of an imminent failure or the actual occurrence of a failure which is a technique for component replacement which allows no error or no deterioration in performance to occur at the time of replacing components. A second problem to be solved by the invention is that of the interfaces posing a difficulty in component replacement.

The present invention solves these problems by providing a technique for having every request to a component executed by a new component from the moment it replaces the old component.

The substitutive component is defined for every component in advance and so are conditions that presage the occurrence of a failure in each component.

An application execution platform has a monitor which monitors the state of each component and the execution platform s own state a condition checker which checks on the basis of information from the monitor whether or not a condition defined for each component is met a controller which performs control to replace any component which the condition checker finds meeting the condition with a designated substitute component a duplication deployer which deploys in duplication a component similar to a component already deployed on the application execution platform a communication controller which controls communication between components and a name server which has a function to atomically replace names and objects of two entries.

On the application execution platform the monitor monitors the state of each component and the execution platform s own state the condition checker checks on the basis of the result of monitoring whether or not a condition defined for each component is met and if the condition of a certain component A is met the controller replaces that component A with a substitutive component B.

To accomplish the replacement first the instance of the substitutive component B is created by the duplication deployer on the application execution platform and a pair of the interface of that instance and a name B that uniquely identifies that instance is registered in the name server. Then by using the replacing function of the name server the name A of a registered component currently in operation is replaced with the interface part of the name B of the newly registered substitutive component to enable thereafter the interface of the instance of the substitutive component B to be obtained by the name A. Next the communication controller so replaces the destination of communication as to address the communication to the component A thereafter to the substitutive component B. Finally the completion of all the processing being executed by the instance of the component A is awaited upon completion the instance of the component A is ended and at the same time the entry comprising the instance and the name B is deleted from name server.

By the method for execution of component based software according to the invention when the occurrence of any specific component is presaged a substitute component for the old component is newly deployed and upon completion of the deploy every new request to the component is thereafter processed by the new component any processing being executed by the old component continues to be executed by the old component upon completion of all the processing by the old component the operation of the old component is ended. The replacement of the old component with the new can be thereby accomplished without stopping the processing resulting in avoidance of any performance deterioration and prevention of any failure from occurring by the component replacement. Furthermore the communication processing to send processing received from the caller to a component is made indirect and even if the caller has the interface of the component and makes a request by using that interface that request is sent to the new component not the old component to be processed by the new component with the result that the component replacement can be accomplished in a shorter period of time enabling secure failure prevention to be realized.

It is to be understood that the figures and descriptions of the present invention have been simplified to illustrate elements that are relevant for a clear understanding of the present invention while eliminating for the purpose of clarity many other elements found in the methods and platforms associated with component software. Those of ordinary skill in the art may recognize that other elements and or steps are desirable and or required in implementing the present invention. However because such elements and steps are well known in the art and because they do not facilitate a better understanding of the present invention a discussion of such elements and steps is not provided herein. The disclosure herein is directed to all such variations and modifications to such elements and methods known to those skilled in the art.

An execution platform for component based software capable of achieving highly available operation without sacrificing performance has been realized in the fewest practicable man hours based on a J2EE server which is an existing execution platform of component based software by adding a number of modules to and partially modifying the J2EE server.

The name server is a functionally augmented version of the name server of . The table is exactly the same as the table of . A controller has an API called replace shown in and the function to process it in addition to all the APIs supported by the name server controller of . The main APIs supported by the controller are listed below.

As will be described in further detail below the processing of existing APIs including bind is modified to be atomic. The replace API takes two names name and name as arguments and atomically replaces objects of entries whose name registered in the table is name with objects of entries whose name registered therein is name . For instance where a pair of name Na and object Oa Na Oa and another of name Nb and object Ob Nb Ob are registered in the table and replace Na Nb is called the two entries are turned into Na Ob and Nb Oa . This replace processing can be achieved by combining lookup with rebind . First Na and Nb are looked up to and objects Oa and Ob are taken out. Then Ob is rebound to name Na and Oa is subjected to rebind to name Nb. However if lookup rebind or unbind processing arises apart from replace processing during the execution of processing by these APIs there may occur a problem such as inconsistency in the table. To address this problem first a lock variable L is provided in the controller . The conventional bind lookup rebind and unbind are respectively renamed ibind ilookup irebind and iunbind and bind and lookup are achieved by combining the lock variable with ibind and ilookup respectively. shows the processing flow of replace Na Nb . First the lock variable L is locked at . If the lock variable L is already locked with other processing a time delay occurs awaiting the availability of unlocking lock variable L.

Then at the object paired with a name Na is taken out by ilookup Na and stored into temp. Next at the object paired with a name Nb is taken out by ilookup Nb and stored into temp. At the object name Na is replaced by irebind Na temp and at the object of name Nb is replaced by irebind Nb temp . Finally at the lock variable L is unlocked. shows the processing flow of bind N O . First at the lock variable L is locked ibind N O is executed at and the lock variable L is unlocked at . The same applies to rebind N O and unbind N this can be realized by replacing rebind N O and unbind N at with irebind N O and iunbind N respectively. shows the processing flow of lookup Na . At the lock variable L is locked ilookup Na is executed at the lock variable L is unlocked at and the object obtained as a result of the execution of is returned at .

The substitution definition files and are stated in XML as shown in and comprises such items as EJB name 2nd row substitutive EJB name 3rd row replacement conditions 4th to 6th rows priority 7th row . defining substitution regarding EJB A designates EJB A as the substitutive component namely replaces it with another component of the same EJB and a replacement condition of 300 seconds 5th row as the life time which means replacement in 300 seconds from the time of deploy for example. The priority is used for determining the sequence of substitutive EJBs when replacement conditions are met for a plurality of EJBs at conflicting times. As replacement conditions in addition to the life time shown in the conditions shown in and can be designated. shows respective cases in which replacement is executed when the number of EJB calls has reached 10000 when the memory occupancy of the OS has surpassed 90 and when exceptions of any type has occurred five times in EJB A. A combined condition can also be designated by combining a plurality of such conditions by and or or . The definition files and though stated in XML here may be in any other standard or unique form. Further though EJB A substitution definition and EJB B substitution definition are stated as separate substitution definition files in a number of EJB substitution definitions may be stated collectively in a single file. Instead of using a file or files a user file into which these values are to be entered may be provided to enable the user to enter them into it.

The deployer which is a functionally extended version of the deployer of reads in class files and substitution definition files and deploys EJBs. The following description will refer to a case in which EJB A is deployed by way of example. When EJB A is not deployed on an execution platform of component based software its operation is substantially the same as that of the deployer of described above. Thus the class file of EJB A is read in from the file system and creates the container the remote A request receiver and the remote A request sender of EJB A. The deployer then calls bind API of the name server and registers a pair of the name A of EJB A and the remote interface IntConA of the container A IntConA in the name server . Next the deployer reads in the A substitution definition file sets the EJB name the substitutive EJB name and the priority in the controller and sets the EJB name the replacement condition and the current time in the condition checker .

A configuration in which EJB A is already deployed on the component based software platform will be described with reference to . shows a configuration in which EJB A is deployed in duplication on the component based software platform of wherein EJB A and EJB B are already deployed and the only different elements are and . The deployer reads the class files of EJB A from the file system and creates a new container As remote As receiver remote As sender not shown for EJB A separately from the already deployed container A remote A request receiver and remote A sender not shown in . Then the deployer creates a name As which does not duplicate the name A of EJB A by adding a numeral to the original name A. This numeral is obtained by providing the deployer with a counter for each EJB and incrementing each counter by 1 every time an EJB A is deployed in duplication. This numeral need not be managed by the counters within the deployer but may be managed by an external Db. Also a specific string of characters or the indication of the time may be used instead of a numeral. The pair so created of the name As and the remote interface IntConAs of the container As As IntConAs is registered in the name server by bind API of the name server . Next the deployer reads in the A substitution definition file sets the EJB name the substitutive EJB name and the priority in the controller and sets the EJB name the replacement condition and the current time in the condition checker . If there is no definition file the setting of the controller and the condition checker mentioned above will not be performed.

The creation of the remote request receivers and by the deployer will be described in the following statement of the remote request receivers and .

The deployer has an undeploy function. Undeploying involves the discarding of the instance of the EJB to be undeployed and the discarding of the container the remote request receivers and the remote request senders. In addition to this undeploy function the deployer also perform a partial undeploy. A partial undeploy means that only the instance and the container of the EJB to be undeployed are discarded but neither the remote request receivers nor the remote request senders are discarded.

The monitor measures periodically or systematically for instance every seconds the number of times each EJB has been called the occurrence of any exception or error and the memory occupancy rate of the OS. The measurement of the number of times each EJB has been called can be achieved providing an integral counter in each of the containers and and incrementing the pertinent counter by 1 each time the EJB is called. For exceptions and errors vectors are disposed in the containers and and the type of any exception or error that has occurred the name of the method and the calling time are additionally written therein. Methods to return these counters and lists are prepared in the containers and these methods are periodically called by the monitor to acquire information. The memory occupancy rate of the OS is calculated by using any API that is ready on the execution platform of component based software or if there is no such ready API issuing a system call to the OS to acquire the memory size used by the execution platform of component based software and the maximum memory size from which the occupancy rate is calculated. The monitor has methods getcount getEvent and getMem to acquire these number of EJB calls exception and error occurrence and memory occupancy rate respectively from outside.

The condition checker checks at regular intervals such as for example every minute to determine whether the replacement condition of each EJB is met. The condition checker has a condition table shown in . The condition table is composed of three fields including those of EJB name replacement condition and deploy time . shows a state in which two entries and are registered. These entries are entered in the condition table when the deployer deploys an EJB. The entry shows the replacement condition of EJB A which means that a replacement will be executed when the deploy duration has surpassed 300 seconds. To check the deploy duration the field for the deploy time is used. The entry shows the replacement condition of EJB B which means that a replacement will be executed when the number of EJB B calls has surpassed 10000.

The condition checker successively checks whether each of the entries in the condition table meets the replacement condition. When the replacement condition is based on the deploy duration if the difference between the current time and the deploy time registered in the condition table is longer than the designated duration that replacement condition will be deemed to be met. When the replacement condition is based on the number of EJB calls method getcount in the monitor is called and if it is found greater than the designated value that replacement condition will be deemed to be met. When the replacement condition is based on the number of exceptions and errors method getEvent of the monitor is called to acquire exception and error information the designated number of exceptions and errors is referenced and if the actual number is found greater than the designated number that replacement condition will be deemed to be met. When the replacement condition is based on the memory occupancy rate method getMem of the monitor is called to acquire the memory occupancy rate and if it is found higher than the designated memory occupancy rate that replacement condition will be deemed to be met. This check sequence is applied to every entry in the condition table . The controller is called by using the list of EJB names for which the replacement conditions have been met as arguments.

The remote A request receiver and the remote B request receiver hereinafter referred to as remote request receivers are functionally augmented versions of the remote A request receiver and the remote B request receiver respectively of . They are respectively paired with the remote A request sender and a remote B request sender not shown hereinafter referred to as remote request senders to realize remote communication between EJB A and EJB B. The remote request receivers are realized as the skeleton of RMI and the remote request senders as the stubs of RMI. The remote A request sender and the remote B request sender not shown are known RMI stubs. They are automatically created by using a known RMI compiler rmic when the deployer deploys EJB A and EJB B. The method parallels the known method used by deployer . The remote A request receiver and the remote B request receiver constitute a functionally augmented version of a known RMI skeleton.

The message of request exchanged between the remote A request receiver and the remote A request sender is the same as the aforementioned message exchanged between the remote A request receiver and the remote A request sender . The remote A request receiver when it receives the message from the remote A request sender checks whether or not the container reference variable is NULL if it is NULL the receiver checks the target identifier of the message and if the target identifier is a container ID the receiver calls together with an argument the method of the default container A indicated by the container ID. If the target identifier is an EJB instance ID the method of the instance of EJB A identified by the target identifier on the default container A is called together with the argument .

If the container reference variable is not NULL and the target identifier of the message is a container ID the method of the container identified by the container reference variable is called together with the argument . If the target identifier is an EJB instance ID first the EJB instance reference table is referenced to check whether there is an identical entry in the old EJB instance ID field with the target identifier of the message and if there is the method of the EJB instance on the container identified by the container reference variable identified by the new EJB instance ID of that entry is called together with the argument . If no entry identical with that entry is found in the EJB instance reference table a create method is issued to the container identified by the container reference variable to create one EJB instance on that container and a pair of the target identifier of the message and the identifier of the EJB instance created as a result of create is registered in the EJB instance reference table . The switching of remote request is achieved in this way by replacing the default container with the designated container as the access target when a container is registered in the container reference variable.

The remote request receivers are automatically created when the deployer deploys EJB A or EJB B. The method is similar to known methods by which the deployer of creates the conventional remote request receivers . A difference in the use of a RMI compiler rmic subjected to an extension procedure by which a code for realizing the aforementioned container switching control is embedded into a usual skeleton code. Alternatively the usual RMI compiler rmic may be used for skeleton creation followed by embedding of the container switching control into the created skeleton code.

The controller performs EJB replacement. The controller has a substitution table of and a user interface of .

The substitution table has fields of EJB name substitutive EJB name and priority . The deployer when it deploys any EJB reads the substitution definition files and and registers the values in the substitution table . When EJB A is deployed the registered entry number is or when EJB B is deployed the entry number is . The entry shows that the substitution EJB for EJB A is EJB A and its priority is . The entry shows that the substitution EJB for EJB B is EJB Bnew and its priority is 5.

The user interface is an interface to enable the user to perform setting regarding the replacement of components on the execution platform of component based software . The user interface supports a setting for automatic replacement and a setting for manual replacement. Automatic setting is to instruct that the replacement of components is to be performed automatically. A button indicates that automatic replacement is to be performed and a button indicates that no automatic replacement is to be performed. Only one or the other of these buttons can be selected. In the state shown in the button indicating performance of replacement is selected and in this case the controller executes replacement of the identified components. Where the button is selected no component is replaced. Where manual replacement is set the component to be replaced is designated in an input box and a button is pressed. Then as will be described with respect to phase of component replacement processing the entered component is replaced with a substitute component. The user interface may either be a graphical user interface GUI as denoted by in or a command line interface CUI or a combination of both GUI and CUI may be supported. Also instead of the user selecting selection may be made by another program operating the GUI or the CUI.

The controller is called by the condition checker . The condition checker hands over to the controller EJB names that meet the replacement conditions in a list form. The controller references this list takes out the priority of every EJB in the list from the substitution table and replaces EJBs in the descending order of priority. If there are two or more EJBs in the same position in the order of priority the selection may be made at random or by using some other prioritization method. EJBs are replaced thereafter in a determined sequence. For instance one may be replaced at a time using 10 second intervals or they may be successively replaced without intervals.

The processing method will be described below with reference to a case of replacing EJB A as an example. The replacement processing is executed in the flow shown in . First at step the substitution table is referenced and a substitutive EJB which is the replacement target EJB is removed. In the case of EJB A EJB A itself is the substitutive EJB. Then at the deployer is instructed to deploy EJB A which is the substitution EJB for EJB A. As the substitution EJB A is the same as EJB A the deployer deploys the containers in duplication. The execution platform of component based software after the deployment will take the form of in wherein reference numeral denotes the container As of EJB A deployed in duplication and the remote As receiver of EJB A sign As is used in place of A to aid in distinguishing . Although reference numeral in denotes the instance of EJB A on the container As the instance is not yet created by this point of time. Then the deployer adds an entry to the name server . Next the controller at step calls the replace API of the name server with the name A of the replacement target EJB A and the name As of the newly deployed substitutive EJB A as the arguments. Entries in the table of the name server will be made as shown in . Reference numeral denotes a pair of the name A and the container As of the newly deployed EJB A and a pair of the name As and the old container A. Next the controller at step calls the setContainer method of the remote A request receiver with the container As as the argument. The container reference variable of the remote A request receiver is rewritten from NULL to the container As . Thereafter any request via the remote request receiver is executed in the container As . Next the controller at step waits until all processing being executed in the container A is completed and at step calls the partial undeploy function of the deployer to undeploy the instance of the old EJB A and the container . Finally at step it calls the unbind API of the name server with the name As as the argument and deletes the entry As IntConA from the name server . This completes the replacement processing of EJB A.

The description has so far mainly focused on the replacement processing of EJB A. Now will be described the operation from the viewpoint of calling the method of EJB A by EJB B which is the caller. First part of the request code of EJB A in EJB B is supposed to be as shown in . Referring to after the instance of EJB B first executes the first two rows of the name server is referenced to search for an entry whose name field is A. As a result the home interface IntConA of the container A registered in the object field of the entry is obtained. The instance executes the third row of and calls the create remote method of the home interface IntConA obtained by lookup . This remote request is sent via the container B to the remote A request sender where it is converted into the message to reach the remote request receiver . The target identifier of the message is the container A and the method is create . The remote A request receiver upon receiving this message first references the container reference variable and as its value is NULL calls the create method of the container A identified by the target identifier of the message .

The container A creates the instance of EJB A and returns the component interface of the instance to the instance of EJB B via the container A the remote A request receiver the remote A request sender and the container B. The instance then executes the fourth row of and calls the methodX remote method of the instance of EJB A. This request is sent to the remote A request sender via the container B and converted into the message . Here the target identifier of the message is the instance of EJB A and the method is methodX . When this message arrives at the remote A request receiver the remote A request receiver first references the container reference variable and as its value is NULL the methodX method of the instance of EJB A identified by the target identifier of the message is called. The result is returned to the instance of EJB B via the container A the remote A request receiver the remote A request sender and the container B.

Next the execution platform of component based software on which the replacement condition of EJB A is met and the controller has executed and completed the replacement of EJB A is shown in . The container A is replaced by the container A . The name A of the name server is replaced by the remote interface IntConAs. Into the container reference variable of the remote A request receiver is stored the container As . It is supposed here that the aforementioned EJB B again calls the methodX remote method on the fourth row of to EJB A. Then as in the above described case a message is prepared and handed over to the remote A request receiver even after the container replacement the remote A request sender is paired with the remote A request receiver and cannot communicate with the remote As sender . The remote A request receiver first references the container reference variable and as the value is not NULL searches the EJB instance reference table for any entry corresponding to the target identifier of the message . As there is none the create method of the container As identified by the container reference variable is executed to create the instance of EJB A on the container As . The identifier of the instance on the container A stored in the target identifier of the message and the identifier of the just created instance are paired and registered in the EJB instance reference table the method methodX of the instance is executed and the obtained value is returned to the instance . In this way all the requests using the home interface or the remote interface acquired before the container replacement will be executed on the new instance of the new container.

Finally a case in which a new instance differing from the aforementioned instance of EJB B calls the methodX remote method of EJB A by executing the code of in the state shown in after the EJB A replacement will be described. Referring to the new instance of EJB B first executing the first two rows of issues lookup to the name server and an entry whose name field is A is searched for. As a result the home interface IntConAs of the container As registered in the object field of the entry is obtained. The new instance executes the third line of and calls the create remote method of the home interface IntConAs. This remote request is sent via the container B to the remote A request sender where it is converted into the message and reaches the remote As receiver . The target identifier of the message is the container As and the method is create . Upon receiving this message the remote As receiver references the container reference variable and as its value is NULL calls the create method of the container As identified by the target identifier of the message . The container As creates the instance of EJB A and returns the component interface of the instance to the new instance of EJB B via the container As the remote As receiver the remote A request sender and the container B . The new instance then executes the fourth row of and the methodX remote request of the instance of EJB A is processed. After the containers are replaced the remote request having executed the program beginning with lookup of the name server is executed in the new container As.

The execution platform provided with the method for highly available execution of component based software according to the invention can be utilized as application platform software for executing a broad range of applications. In particular it can also be utilized as application platform software for the execution of mission critical applications that require high availability.

Those of ordinary skill in the art may recognize that many modifications and variations of the present invention may be implemented without departing from the spirit or scope of the invention. Thus it is intended that the present invention covers the modifications and variations of this invention provided they come within the scope of the appended claims and their equivalents.

