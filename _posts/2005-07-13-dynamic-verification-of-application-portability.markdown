---

title: Dynamic verification of application portability
abstract: A system and for dynamic verification of application portability may include an application server configured to support a debugging interface, an application deployed on the application server, and a portability verification tool. The portability verification tool may be configured to invoke the debugging interface during an execution of the application to determine whether the application violates one or more specified portability criteria during the execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774757&OS=07774757&RS=07774757
owner: Oracle America, Inc.
number: 07774757
owner_city: Redwood City
owner_country: US
publication_date: 20050713
---
The present invention is directed to computer systems. More particularly it is directed to verification of portability of computer system applications.

The complexity and expense of developing and deploying enterprise level computer systems applications has been increasing over time. In addition to supporting a rich set of functional features a modern enterprise application may also have to be scalable enough to support large numbers of concurrent users and provide a high level of availability maintainability and interoperability with other applications. The development cycle for a single major release of an application may take months or even years and may require hundreds of person years of development resources. As a result enterprise application vendors are understandably eager to reduce the total cost of application development.

In the past application vendors often developed a first version of an enterprise application for a particular execution platform e.g. a combination of a computer hardware architecture and an operating system designed for the hardware architecture and then ported the application to other execution platforms as needed. Each ported version of the application typically went through a quality assurance test cycle on the corresponding platform. Quality assurance testing during which the functionality performance and other features of the enterprise application are tested often represents a substantial portion of the total expense of application development. In order to reduce porting and testing costs and also in response to growing customer demand for applications that can be deployed across a variety of hardware architectures and operating systems in recent years many application vendors have begun to target their applications to application server environments such as the Java 2 Enterprise Edition J2EE environment that are intended to be platform agnostic. Typically a standards organization or a collaborative body such as the participants in the Java Community Process in the case of J2EE is responsible for defining standards for the application server technology in the form of formal specification documents. The specification documents define the functionality and interfaces that must minimally be supported for compliance with a particular version of the application server technology. As application server is typically designed and advertised as being compliant with a particular version of an application server technology and potential users and developers may consult the specifications associated with that version to determine the set of features supported by the application server. Applications developed in accordance with a particular version of a specification are expected in principle to be deployable without modification at any application server that conforms to that version of the specification regardless of the specific operating system or hardware architecture of the platform on which the application server is executed. Thus once an application vendor has developed and tested such a portable application on an application server on one platform no further source code changes should be required to deploy the application on other platforms and the application vendor should also be able to reduce or eliminate additional testing required for the other platforms.

Unfortunately application servers provided by different application server vendors may differ slightly in the set of functions and features provided even where the different application server vendors claim compatibility with the same set of specifications. For example the specifications may allow optional features to be implemented and different application server vendors may implement different sets of optional functions. As a result an application developed on a particular application server may sometimes use features such as application programming interfaces APIs that are vendor specific and hence may not be truly portable. Also portability may require compliance with certain standards for run time behavior e.g. standards relating to exception handling. Traditional tools for identifying non portable features of applications may require access to application source code changes to application server code restarts of application servers to initiate or terminate portability analysis and or cumbersome modifications to an application server runtime environment which may be difficult to accomplish for application developers and potential customers. In addition portability criteria may change over time e.g. as standards or specifications change and traditional portability verification tools may themselves require source code modifications to adapt to changes in portability criteria.

Various embodiments of a system and method for dynamic verification of application portability are disclosed. According to a first embodiment a system may include an application server configured to support a debugging interface an application deployed on the application server and a portability verification tool. The portability verification tool may be configured to invoke the debugging interface during an execution of the application to determine whether the application violates one or more specified portability criteria during the execution. For example in one embodiment the application may be considered non portable if it utilizes an interface s to an application server service s e.g. services that are not implemented within the application itself but are typically supported by an application server such as transaction services security services messaging services etc. that are not required by or defined in an application services standard specification. The debugging interface may support a function that notifies the portability verification tool when specified types of events e.g. exceptions occur during application execution and the portability verification tool may be configured to use the notifications to identify instances of non portable behavior e.g. when a ClassNotFound exception occurs as a result of the application attempting to access a non standard interface or object class . Such a use of a debugging interface may allow application portability to be verified for example without modifying the application server code or the application code without installing an additional portability verifying application at the application server and without requiring cumbersome changes in the run time execution environment of the application server. In some embodiments the debugging interface may be platform independent allowing the application server and the portability verification tool to be executed on computer hosts employing different processor architectures and or operating systems.

A number of different types of portability criteria may be specified in various embodiments for example based on specific versions of enterprise application execution technologies such as J2EE . In one embodiment an application may be deemed non portable if a particular type of event such as an unchecked exception or an exception of a particular object class occurs during the execution. The debugging interface may support a number of different functions such as functions allowing monitoring of exceptions and other events such as function invocation e.g. method entry during application execution. The portability verification tool may be configured to invoke one or more such functions and to make a determination that the application is non portable if an event of a particular type identified as being non portable occurs. The portability verification tool may also be configured to generate a portability verification report that identifies any instances of non portable behavior detected during the application execution. In some embodiments the tool may also be configured to generate a code coverage report which may for example indicate the fraction of the application s defined functions or methods that were actually called during the execution and or may identify the set of functions that were actually called or identify the set of functions that were not called . In one embodiment the portability verification tool may also be configured to dynamically identify at least one portability criterion e.g. via a parameter file.

While the invention is susceptible to various modifications and alternative forms specific embodiments are shown by way of example in the drawings and are herein described in detail. It should be understood however that drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

In one specific embodiment the application server may provide a reference implementation of a particular application services standard specification such as a J2EE specification. A reference implementation is an implementation of a standard that adheres strictly to the requirements defined in the standard and does not implement any non standard features that are not required by the standard. If an application deployed to such an application server attempts to invoke a non standard application server service the application server may throw an exception of a particular category. For example if the application was developed on an application server that provided support for vendor specific object classes and one or more vendor specific object classes were referenced in the application a ClassNotFound exception may be thrown when the application is executed on an application server providing a reference implementation of the standard. The ClassNotFound exception may indicate that the vendor specific object class could not be found in the set of classes accessible from the application e.g. the set of classes including application server provided classes that may be located using a class path associated with the application . In some embodiments the debugging interface may support a function that allows portability verification tool to monitor the application execution for specified categories of exceptions e.g. including ClassNotFound exceptions. Portability verification tool may be configured to invoke one or more such functions provided by debugging interface to track the occurrence of exceptions that indicate non portable behavior in such embodiments. At the end of the execution the portability verification tool may be configured to generate a report including portability verification results for the execution. The results may be provided to various parties interested in ensuring that the application is portable for example to potential customers who do not wish to be dependent on a particular application server vendor s non standard features or to application developers or development managers who may wish to ensure that non standard features have not been introduced into the application source code. The use of the debugging interface may allow portability verification to be performed without requiring source code changes at the application server or the application restarting the application server or modifying runtime environment variables of the application server e.g. class paths . In addition in some embodiments portability verification tool may be executed within a separate process or even at a different host than application server thus minimizing the impact of portability verification testing on the application .

Application server may be any type of execution environment designed to allow applications to be developed and deployed e.g. independently of the details of hardware architectures and operating systems and may be implemented using any of a variety of technologies in various embodiments. Application server may be configured to provide a variety of application server services e.g. services that implement commonly used functionality that may be useful to a variety of deployed applications such as transaction services security services connection pooling services messaging services etc. Various applications may utilize the specific sets of application server services that they require and application developers may simply employ the services provided by the application server without re implementing them for each individual application. In one embodiment as shown in and described in further detail below application server may be configured to utilize J2EE technology in other embodiments other technologies such as .NET may be employed. Debugging interface may provide a number of different debugging functions or methods that may be invoked by portability verification tool or by any other client of the interface in various embodiments. For example in one embodiment the debugging interface may allow a user to identify the specific application and application server functions or methods that are entered and or exited during application execution to monitor the occurrence of certain types of run time events that may occur during the application execution such as exceptions and errors to set and reset break points in the application code to examine the values of various application or application server variables etc. In some embodiments the debugging interface may be platform independent in that it may be invoked from any computer system such as a workstation or server supporting Java virtual machines that complies with specified standards. For example in one embodiment the debugging interface may be a version of the Java Debugging Interface JDI application server may be executing on a computer server employing SPARCT based processors provided by Sun Microsystems and a Solaris operating system and portability verification tool may be configured to invoke the debugging interface from a workstation employing Intel processors and a Windows operating system. In other embodiments the portability verification tool and the application server may be configured to run within separate processes or virtual machines on the same server or even within the same process at a particular server.

Any type of application or a portion of a multi tiered application that is deployable on the application server may be checked for portability according to specified portability criteria in various embodiments. Application may invoke both internal functions e.g. functions defined and implemented within the application or in shared libraries bundled within a deployed version of the application as well as external functions that may not be implemented within the application e.g. the common functions or services that may be provided by the application server and utilized by a variety of applications as described above such as transaction management functions security related functions connection pooling functions messaging functions etc. As noted earlier portability criteria may be derived for example from a version of a standard or specification e.g. an API specification associated with a particular application execution technology such as J2EE e.g. an application that invokes an external function that is not a requirement or recommendation of a particular version of the specification may be considered non portable with respect to that version of the specification. Application may be a multi tiered commercial application such a web based electronic commerce system for example some of whose components may be executed outside application server e.g. at one or more web servers and or back end database servers or a single tiered application such as a simulation tool. In some embodiments an external client e.g. a set of web based interactive scripts implemented using a load generation tool may be used to exercise application while in other embodiments the functionality of application may be exercised without requiring interaction with external processes or clients e.g. using input parameter files. In various embodiments application application server client and portability verification tool may each be implemented using any desired combination of programming languages and or scripting languages.

J2EE technology provides a component based approach to the design development assembly and deployment of enterprise applications. Multi tiered distributed applications built using reusable components may be supported in a J2EE environment. Logic for a multi tiered application may be divided into components according to function and the various application components may be installed within different hosts depending on the tier to which the component belongs. For example a multi tier application may include a client tier a web tier a business tier and or an enterprise information system EIS tier. Client tier components may include web clients applets and or application client programs configured to run at a client host D. Web tier components may include for example Java Servlets and JavaServer Pages JSP . Business tier components may include for example enterprise beans which may include session beans entity beans and or message driven beans. An EIS tier may include for example database servers enterprise resource planning ERP systems mainframe based transaction processing systems and other legacy applications.

An application server may implement a number of different types of containers to provide access to various objects and to provide interfaces to support the application server services described above as well as for other functions such as multithreading state management and the like. Before an application component is executed it may have to be assembled into a module and deployed within an appropriate container. For example in a J2EE environment a web component may be assembled into a J2EE web module and deployed into a web container and an enterprise bean may be assembled into a J2EE EJB module and deployed into an EJB container . The assembly process may involve specifying container settings for each component in a J2EE application and for the application itself. The container settings customize the underlying support services to meet the specific needs of the component. For example J2EE security model settings may be used to ensure that system resources are accessed only by authorized users J2EE transaction model services may be used to specify relationships among methods that make up a single logical transaction and so on. Since the J2EE architecture provided configurable services application components within the same application can behave differently depending on where they are deployed. For example security settings for an enterprise bean which may control the level of access from the application to a database server can be modified from one production environment to another. An architecture such as J2EE provides an environment for developing a complex application once in accordance with a particular set of J2EE standard specifications and then deploying the application using flexible and configurable deployment settings as often as needed at any application server that supports the same set of specifications.

In some embodiments various subcomponents facilities and or services supported by an application server may each have associated standards or specifications for example EJB container may have an associated standard specification web container may have its own associated standard specification and even debugger interface may have its own standard specification. In some such embodiments a combination of standard specifications for subcomponents of the application server environment may be combined to form a higher level specification. When verifying the portability of an application with respect to the higher level specification portability verification tool may have to take the specifications for each subcomponent into account e.g. by using a first set of portability criteria for the application s web module deployed to web container and using a different set of portability criteria for the application s EJB module deployed to EJB container .

In one embodiment portability verification tool may also be configured to dynamically obtain input specifying one or more portability criteria e.g. from an input parameter file or via manual input. That is in such an embodiment the portability verification tool may provide an interface to specify a portability criterion without requiring a modification of the source code of the tool . An input parameter file may be used to specify for example categories of exceptions errors or other events whose occurrence may result in a designation of an application as being non portable. For example as described earlier if the application server adheres strictly to an application service standard e.g. if the application server provides a reference implementation of the standard a ClassNotFound exception or its equivalent may be thrown if the application attempts to access a class or a service not required by the standard and such an exception may be an indication of non portability. Any desired format may be used to provide the parameters e.g. the input parameter file may be a text file with a list of exception types or other rules a file formatted using XML Extensible Markup Language or formatted according to a custom language or syntax for specifying portability criteria. In addition to event based portability criteria e.g. criteria based on exceptions errors etc. a variety of other types of portability criteria may be specified in various embodiments e.g. in some embodiments a reference to a certain specific object class from another specific object class may be considered a portability violation or a violation of a recommended coding style or methodology e.g. a naming convention for objects classes or methods identified in a standard specification may be considered a portability violation. In some embodiments different sets of portability criteria may be specified for different containers within an application server for example certain types of exceptions such as EJBExceptions may be considered portable if thrown within an EJB container of a J2EE application server but may be considered non portable if thrown within a web container . Portability criteria may be hard coded within portability verification tool in some implementations.

In one specific embodiment where an occurrence of a particular category or class of exceptions is considered a portability violation an exclude list of exceptions may also be provided as input to portability verification tool to indicate specific subclasses or instances of exceptions that are not to be considered as violating portability. If a specific exception that appears to belong to a portability violating category of exceptions occurs portability verification tool may be configured to check whether the specific exception is identified within the exclude list and to determine that that specific exception violated portability criteria only if it is not listed in the exclude list. For example according to one set of portability criteria in one implementation occurrences of unchecked exceptions in general may be considered indications of non portability but a specific unchecked exception such as a null pointer exception may not be considered non portable and may be specified in an exclude list. In general unchecked exceptions may include exceptions that do not have to be declared in method signatures and for which exception handlers may not have to be provided in the application code. Unchecked exceptions may represent a subclass of a defined higher level exception class in some embodiments. In embodiments where the Java programming language is employed for example an unchecked exception is a subclass of the java.lang.RuntimeException class. Since the occurrence of unchecked exceptions such as ClassNotFound IllegalArgument exceptions etc. may in general be unpredictable and such exceptions may be thrown from a large number of locations in the application code compilers may be configured not to require that declarations of the unchecked exceptions be provided in the method signatures in some embodiments. In addition explicit exception handlers for unchecked exceptions may also not be required in such embodiments. The occurrence of an unchecked exception may have unpredictable platform dependent results in some embodiments. If a null pointer exception occurs during application execution in such an implementation the portability verification tool may be configured to exclude the occurrence from a list of portability violations but the occurrence of any other unchecked exception may be considered a portability violation.

As indicated by the arrow labeled in the embodiment shown in after the class method map has been generated the application may be deployed to an application server . In one embodiment the application server may have been started in debug mode prior to the deployment of the application. In one implementation a runtime parameter or an environment variable setting may be used to enable debug mode operation of application server while in other implementations no runtime parameters or changes to environment variable settings may be required. In some embodiments the application may be compiled using a debug flag such as a g flag to support the use of debugging interface while in other embodiments such flags may not be required during application compilation. In the embodiment depicted in portability verification tool may be configured to invoke one or more methods or functions of the debugging interface to enable notification of function invocations e.g. notifications when specified methods are entered and the occurrence of events such as exceptions during the execution of application as indicated by the arrow labeled .

For example in one implementation where a version of JDI is being used the debugging interface may specify a collection of specific programming interfaces such as a MethodEntryRequest interface a MethodExitRequest interface and an ExceptionRequest interface. An invocation of the MethodEntryRequest interface may allow portability verification tool to request to be notified e.g. by the application server placing a MethodEntryEvent object in an event queue accessible by the portability verification tool when a specified method is entered by the application . An implementation of the MethodEntryRequest interface may for example support methods such as addClassFilter String classPattern and addClassExclusionFilter String classPattern to allow the inclusion or exclusion of specific methods in a set of methods for which notifications are to be enabled. The classPattern string parameters to such methods may allow the specification of classes e.g. using regular expressions whose methods are to be included or excluded. Portability verification tool may use its class method map to request notifications for only those methods that are defined in the application in some embodiments. In some implementations portability verification tool may also be configured to invoke one or more interfaces e.g. a MethodExitRequest interface to request a notification on an exit by application from a method of a specified set of methods.

Similarly portability verification tool may also invoke one or more ExceptionRequest interfaces to request notifications of certain types of exceptions or errors during the execution of application e.g. by the application server placing an ExceptionEvent object in an event queue accessible by portability verification tool . Various implementations of the ExceptionRequest interface may also support methods such as for example addClassFilter String classPattern addClassExclusionFilter String classPattern addThreadFilter ThreadReference thread addExceptionClassFilter String classPattern etc. to specify the kinds of exceptions for which notifications are to be generated e.g. based on a class in which the exception occurs or a thread of execution in which the exception occurs or a class to which the exception belongs . In some embodiments portability verification tool may be configured to use one or more such methods to restrict the set of exceptions for which notifications are generated while in other embodiments portability verification tool may be configured to receive notifications for all exceptions and to analyze the notifications to determine whether any specific exceptions that violate portability criteria occurred during the execution. Thus in some embodiments only a subset of the exception notifications may represent portability violations. Exception related portability criteria may specify categories or types of exceptions e.g. unchecked exceptions as described above and or specific object classes of exceptions whose occurrence may indicate non portability. It is noted that in other embodiments where for example the debugging interface may not be a version of JDI functionality similar to that described above for JDI e.g. functionality for generating notifications when certain types of events of interest occur such as function invocations and or exceptions may be provided using other APIs or techniques.

As described earlier in some embodiments a portability criterion may include a requirement that no unchecked exceptions should be thrown by an application i.e. that if the application throws an unchecked exception the application should be considered non portable. In some embodiments where an occurrence of an unchecked exception is considered an indication of non portability portability verification tool may be configured to set up exception notifications specifically for unchecked exceptions. In other such embodiments portability verification tool may be configured to receive notifications for all exceptions that occur in the application classes of interest and identify specific types of exceptions that indicate non portability using information contained in the notification such as an exception stack trace. For example an exception stack trace may indicate that the corresponding exception belongs to a specific class of exceptions e.g. the Java.lang.RunTimeException class or its subclasses for Java applications that are unchecked exceptions.

After the requests for notifications have been set up by portability verification tool using debugging interface the application may be exercised by client as indicated by the arrow labeled in . The client may be configured to issue a series of requests to application and receive responses to those requests. If application is an electronic banking application for example client may be configured to issue multiple deposit balance check withdrawal and other banking related requests. Client may be multi threaded in some embodiments e.g. client may represent or simulate any desired number of concurrent users of application . A combination of client programs that may have been developed for functional testing and or for load testing or performance benchmarking may be used to exercise application in some implementations in order to thoroughly test as many aspects of the functionality of the application for possible violation of portability criteria as possible. During the execution of the application in response to the client portability verification tool may be configured to receive notifications from the application server in accordance with the invocations of the debugging interface by the portability verification tool as indicated by the arrow labeled .

At the end of the execution of the application portability verification tool may be configured to generate a portability and or coverage report for the execution as indicated by the arrow labeled in . The report may include information about any violations of portability criteria detected during the execution e.g. identifications of one or more exceptions that violated the criteria the corresponding stack trace or other identification of the classes and methods where the exceptions occurred etc. In some implementations a list and or description of the portability criteria may also be included in the report along with an indication of the source from which the criteria were obtained or derived e.g. if the criteria were specified in an input parameter file to portability verification tool the name location and or contents of the parameter file may be included in the report or an identification of the particular versions of standard specifications from which the criteria were derived may be included . In addition to an indication of detected portability violations in some embodiments portability verification tool may also be configured to include code coverage analysis in the report which may indicate the extent to which the methods and classes defined in the application were exercised during the execution. For example using class method map and the notifications received during the execution of the application portability verification tool may be configured to compute the fraction of classes and methods that were actually referenced or called e.g. a ratio of the number of methods actually executed to the number of methods identified in the map and or to list the methods or classes that were not called or referenced during the execution. Various other details may also be included in report such as details of the hardware and software platform used during portability verifications. In some embodiments a separate report for portability verification and code coverage may be generated.

In one example implementation for the example a combined portability and coverage report may be organized into the following sections 

The Summary Of Detected Portability Violations section may indicate for example how many portability violations occurred during the execution and if various categories of portability criteria were specified the number of violations of each category of portability criteria. Similarly the Summary of Code Coverage section may include a statement indicating the fraction of methods of the application that were exercised during the execution e.g. 100 of methods were exercised . Details sections may include information such as stack traces for exceptions lists of methods called during the execution lists of methods not called during the execution etc.

It is noted that in order to increase the probability of finding portability violations multiple test iterations may be run in some embodiments. That is client programs may be repeatedly invoked or iterated especially for applications that support large numbers of users where concurrent operations on behalf of multiple users may potentially result in race conditions that may lead to non portable behavior such as certain types of exceptions being thrown . Since each execution of application may result in different sequences of low level operations such as lock acquisitions I O operations etc. at application server repetitive testing may help to identify non portable run time behavior that may occur relatively rarely. For example the same exceptions may not be thrown each time an application is executed so the application may be executed several times to increase confidence in the portability results. It is noted that the probability of detecting non portable behavior unrelated to race conditions may also be increased by repeating test iterations in some implementations. It is also noted that in some embodiments some of the operations depicted in may be performed in a different sequence than the sequence illustrated in or omitted entirely. For example in one embodiment the identification of the classes and methods defined in an application may be performed after the application is deployed at the application server and in another embodiment code coverage reports may not be generated.

Portability verification tool may be configured to determine or identify the set of object classes Methods and or functions defined in the application block e.g. using one or more of the techniques described above such as inspecting deployment descriptors to identify top level classes and utilizing reflection APIs to detect other classes and methods defined in the application. The application server may be started up e.g. in a debug mode block and the application being analyzed for portability may be deployed thereto block . The portability verification tool may be configured to invoke facilities or functions provided by the debugging interface such as for example the MethodEntryRequest and or ExceptionRequest APIs described above to request notifications when certain events occur during the execution of the application block .

With the event notification requests set up the client may be executed to exercise the application block . As noted earlier a number of different types of client applications may be used such as multi user test scripts generated using a load generating tool single user functional tests etc. Notifications of the occurrence of events for which notification requests were earlier set up such as method entry notifications and exception notifications may occur during application execution block . The notifications may be logged or saved in a persistent store or database by portability verification tool in some embodiments for later analysis. After the execution completes the logged or stored notification information may be analyzed e.g. to identify occurrences of specific types of exceptions block that indicate portability criterion violations. A portability and or coverage report may then be generated as described above block . It is noted that in some embodiments some of the operations depicted in may be performed in a different sequence than the sequence illustrated in or omitted entirely. For example in one embodiment the identification of the classes and methods defined in an application may be performed after the application is deployed at the application server and in another embodiment code coverage results may not be generated.

As described earlier in conjunction with the description of in some embodiments an application server such as a J2EE server may implement a number of different types of containers to provide support for a variety of commonly used low level functions such as multithreading transaction and state management resource pooling and the like. In such embodiments a client request directed at an application may first be received or handled by code for one of the components which may then invoke application code on behalf of the request. is a block diagram illustrating exemplary interactions between container code and application code on behalf of a client request at an application server according to one embodiment. As shown a client request may be intercepted by a first layer of container code e.g. code for a web container for a client request directed at a JSP or Servlet component . The first layer of container code may then invoke the code of the application component deployed at the container which may in turn potentially invoke other container code either within the same container as code or in another container . Portability related exceptions generated in the application code and the code called from the application code may be caught in the first layer of container code in some embodiments and notifications for such exceptions may be sent to the portability verification tool for analysis of possible violation of portability criteria.

In some embodiments the debugging interface supported by application server may be a version of JDI Java Debugging Interface as described earlier. In one specific implementation a version of JDI may be supported by an application server as part of a debugging infrastructure architecture such as the Java Platform Debugger Architecture JPDA . is a block diagram illustrating various layers of JPDA according to one embodiment. As shown JPDA may include two interfaces JDI and the Java Virtual Machine Debug Interface JVMDI DI a protocol Java Debug Wire Protocol or JDWP and two additional software components that link the interfaces together debugger back end layer and debugger front end layer . The architecture may provide standard interfaces to enable Java programming language debugging tools to be easily written without regard to platform specifics such as hardware operating system and virtual machine implementation and may describe or specify specific implementation choices for remote and cross platform debugging. The modularity of the architecture may allow for extensibility and or customization e.g. to allow debugging client programs such as portability verification tool to define and use custom interfaces tailored for a particular application set or customer.

The JVMDI may describe the functionality that must be provided by a Java virtual machine JVM in order to enable debugging of Java programming language applications running under that JVM. In a reference implementation of JPDA for example JVMDI may be implemented by the Java HotSpot VM provided by Sun Microsystems. The services a VM must provide for debugging may include requests for information for example a current stack frame actions for example set a breakpoint and notification for example when a breakpoint has been hit . A debugger may make use of VM information other than this e.g. using the Java Native Interface JNI but the JVMDI is typically the source of all debugger specific information. Specifying the VM interface in this way may allow any VM vendor to plug easily into the debugging architecture and may also allow the use of alternate communication channel implementations . VM implementations that do not adhere to JVMDI may also provide access via JDWP.

The JDWP defines the format of information and requests transferred between the VM being debugged and the debugger front end layer which implements the Java Debug Interface. JDWP does not require a specific transport mechanism so a variety of different transport mechanisms such as sockets serial lines shared memory and so on may be used in various embodiments using any suitable communication channel . The specification of the protocol allows the VM being debugged and the debugger front end layer to run under separate VM implementations and or on separate platforms. It also enables the front end to be written in a language other than Java. Information and requests sent over JDWP may be formatted as specified in JVMDI but may also include additional information and requests necessitated by bandwidth issues such as information filtering and batching. In a reference implementation a module called the back end debugger layer may be configured to run as an agent of the HotSpot VM and receive JDWP packets from the debugger front end layer . The back end code may execute the commands it receives over the JDWP calling into the HotSpot VM via JVMDI when necessary. Results may be returned back to the debugger front end layer via JDWP.

In the JPDA architecture depicted in JDI may provide a remote view of the VM being debugged to the portability verification tool or any other JDI client such as a debugger an integrated development environment IDE a monitoring tool etc. JDI may define information and requests at the user code level and may provide introspective access to a running virtual machine s state Class Array Interface and primitive types and instances of those types. JDI may also provide explicit control over a virtual machine s execution.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

