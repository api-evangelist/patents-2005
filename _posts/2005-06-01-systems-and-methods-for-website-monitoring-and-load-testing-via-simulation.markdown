---

title: Systems and methods for website monitoring and load testing via simulation
abstract: Described herein are systems and methods for website or web based application monitoring and load testing. A server is configured to execute monitoring or load testing agents on various agent devices that are placed in various locations across a network. The agents receive a playback script from the server and execute the script to simulate a user session that is part of a website monitoring or load testing project. Execution of the playback script may cause the agent to send commands to a generic browser application that in turn carries out those commands. Alternatively, or in combination, execution of the script may cause the agent to simulate operating system commands such as mouse, keyboard, and voice commands. The results of the script execution by the agent are stored and sent back to the server for potential real time alerting notification and compilation into a related report. Methods for recording the playback scripts are also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07770068&OS=07770068&RS=07770068
owner: Neustar, Inc.
number: 07770068
owner_city: Sterling
owner_country: US
publication_date: 20050601
---
The present invention generally relates to the field of website monitoring and load testing and more particularly relates to abstract simulations of monitoring and load testing based on pre recorded scenarios of user interactions with a browser or operating system.

Conventional website or web based application monitoring and load testing is typically accomplished by using a proprietary web browser to interact with a website. In order to accomplish website transaction monitoring which simulates a user scenario at a website such as purchasing a good checking a stock quote etc. two conventional methods are used. One method involves simply replaying a sequence of predefined static GET or POST requests. This method is deficient in that replaying a sequence of static i.e. hardcoded requests causes a transaction to fail for dynamic sites that contain information that often changes. The second conventional method requires the use of a proprietary browser that must examine understand and process all of the hypertext markup language HTML and Javascript that is sent to the browser for processing. For example to simulate a simple click of the link Men s Shirts the browser must scan through the HTML and look for this link 

These conventional proprietary browsers must be able to parse through the HTML find the associated text and then scan all of the HTML code near the target text to pick up the uniform resource locator URL to follow. This is the simplest case scenario. More sophisticated modern websites that employ dynamic hidden variables form posts Javascript logic etc significantly complicate the proprietary nature of conventional solutions by requiring equally sophisticated capabilities in the proprietary browser. Some conventional solutions may also employ a combination of the two described methods.

Similarly integrated applications that are hosted by websites are moving away from simple HTML pages to pages that involve more client side application interpretation. Specifically new technologies such as Flash ActiveX and Java Applets are sent to the browser to be executed in a shell within the browser. These integrated applications are effectively delivered to the local machine and are unrelated to the local web browser except that modern web browsers will run these integrated applications intertwined with a normal web page. For example a Flash application might run in the upper right hand corner of a particular webpage or website but in fact the Flash application is a discrete application that is running on the local machine. Such applications are very difficult to monitor by conventional website monitoring or load testing systems because the applications are both proprietary and delivered in a binary format.

Therefore what is needed is a system and method that overcomes these significant problems found in the conventional systems as described above.

Accordingly systems and methods for website monitoring and load testing are described herein that do not require complex proprietary solutions and that raise the level of abstraction for monitoring and load testing in order to simplify the process and make it portable to various platforms. A website monitoring and load testing server is configured to execute monitoring or load testing agents on various agent devices that are placed in various locations across a network. The agents receive a playback script from the server and execute the script to simulate a user session that is part of a website monitoring or load testing project. Execution of the playback script may cause the agent to send commands to a generic browser where the commands are carried out. Alternatively or in combination execution of the script may cause the agent to simulate operating system commands such as mouse keyboard and voice commands. The results of the script execution by the agent are recorded and sent back to the website monitoring and load testing server. In the case of website monitoring that result is used for potential real time alert notification portal display and compilation into the relevant report. For the case of load testing that result is compiled into the relevant report.

Additionally described herein are improved methods for recording website monitoring and load testing scenarios that provide the basis for the various playback scripts that are executed by an agent.

Certain embodiments as disclosed herein provide for systems and methods to simulate operating system or commercial web browser interactions for the purpose of carrying out website monitoring or load testing. For example one method as disclosed herein allows for a server to execute monitoring or load testing agents on various agent devices that are placed in various locations across a network. The agents receive a playback script from the server and execute the script to simulate a user session that is part of a website monitoring or load testing project. Execution of the playback script may cause the agent to send commands to a generic browser application that in turn carries out those commands. Alternatively or in combination execution of the script may cause the agent to simulate operating system commands such as mouse keyboard and voice commands. The results of the script execution by the agent are stored and sent back to the server for compilation into a related report. Methods for recording the playback scripts are also provided.

After reading this description it will become apparent to one skilled in the art how to implement the invention in various alternative embodiments and alternative applications. However although various embodiments of the present invention will be described herein it is understood that these embodiments are presented by way of example only and not limitation. As such this detailed description of various alternative embodiments should not be construed to limit the scope or breadth of the present invention as set forth in the appended claims.

Additionally the system includes a control server that has a data storage area . The control server manages the website monitoring and load testing efforts carried out by the system on the target website . As shown in the diagram of system the target website has a data storage area and each of the various components of the system in the illustrated embodiment are communicatively coupled with each other via a network .

The network may be any of a variety of private or public networks. The network may be a packet switched network or a circuit switched network. The network may be a local area network LAN or a wide area network WAN and may be implemented over a wired or wireless physical network medium. Network may also be any combination of networks such as the ubiquitous Internet.

In the illustrated embodiment the playback engine module is configured to execute a script of user actions that simulate a website load testing or monitoring sequence. The playback engine may execute a playback script and send commands to the API module or the operating system module . In one embodiment the API module translates a playback script command from the playback engine and causes the browser to take the appropriate action that is related to the particular playback script command. Alternatively or in combination the playback engine can send commands to the operating system module where the command is translated into a simulated operating system level command that in turn causes the browser to take an appropriate action. For example the action may be to move the mouse to a particular X Y location or to enter text data.

It should be noted that the playback module API module and the operating system module can alternatively be combined into a single module for ease of implementation. In the illustrated embodiment these functional modules are separated out to identify the different functional aspects of one embodiment of the agent .

The other application module provides the browser with a similar capability to execute other types of applications that are integrated with a website. For example a Java applet or an ActiveX applet may be a type of other application. These types of applications may similarly be separately executable applications that are executed on the local machine as part of the overall execution of the web browser .

As shown in the illustrated embodiment the browser API commands comprise commands for clicking a link selecting a text box changing text in a text box clicking an object and pressing specific buttons that are part of the user interface of a browser. Advantageously these types of commands can be part of a playback script that is translated by the API module when executed by an agent.

As also shown in the illustrated embodiment the operating system commands comprise system level commands for pressing a keyboard moving a mouse and pressing a mouse button. Additional commands can also be included although not shown in this embodiment. In one embodiment voice commands may be employed to effectuate the same operating system level functionality. Advantageously operating system commands can be part of a playback script that is translated by the operating system module when executed by an agent. Furthermore the operating system commands can be used in combination with the browser API commands to provide a rich and complete set of commands in a playback script that are capable of carrying out all of the actions in a user session to be simulated by an agent device.

In one embodiment the various events can be divided into browser events and operating system events. For example all data entry events such as typing in text and all general mouse movement events can be identified as operating system events. Additionally all browser specific events such as pressing the browse forward button or browse backward button can be categorized as browser events. These categorizations can later be advantageous when an agent is playing back the session commands because they may assist the playback engine in routing the session command to the operating system module or the browser API module.

After an event is received it is recorded in step . If more events are available as determined in step then the process returns to step to receive and then record the event. In one embodiment it may be determined that more events are available by examining the content of an event buffer that captures all user input during the recording session. If no more events are available the recorded events are translated in step into commands that are stored in step as a playback session.

In one embodiment the translated commands may identify whether the command is an operating system level command or a browser API command. As previously discussed that designation may be advantageous for later playback at an agent device by the playback engine. In one embodiment certain operating systems commands may include 

As shown in the above example commands a browser API command may be generally designated by a precursor or other field such as the Ie field that designates the browser as Internet Explorer. Alternatively operating system level commands may be generally designated by a similar type of construct such as the Os field at the beginning of the command or in another location .

In this fashion actual user interactions can be recorded as operating system or browser API commands that are later executed by a playback engine to simulate a user session for use in website monitoring or website load testing.

Next in step the server coordinates the start times for each agent that is part of the website monitoring or load testing effort. For example in a load testing embodiment it may be important for all of the agents to start at the same time or alternatively for all of the agents to proceed sequentially. Other configuration settings may also be set up by the server prior to the execution of the website monitoring or load testing effort.

Once the website monitoring or load testing effort is set up in step the server sends the session commands to each agent. In one embodiment the server may send each command individually and control the agent session on a command by command basis. This may be needed for example to implement extremely accurate timing of various commands that are sent by various agents to the website being tested. Alternatively the server may send the entire website monitoring or load testing playback script to the agent device for execution. Various combinations of precise command by command control and total agent control can also be employed.

After an agent session ends or during the agent session depending on the desired implementation the server receives the results of the testing from the agent as shown in step . These results may include information such as the timing of a web page download a more granular breakdown of the download time into e.g. connect time SSL time first byte time and transfer time. Other possible information in the results from the agent may include identification of specific content in a webpage download and various other helpful items for website monitoring or load testing.

After the results are received by the server the results can be compiled by the server as shown in step . In one embodiment the compilation may result in a variety of reports. Additionally the compilation may perform analysis of the results for example textual comparisons to validate the success of an operation or particular command. For example text from the content of a results page text from the title of an application being simulated text from the title of an application running in a browser e.g. Microsoft Word Adobe Acrobat Java Applet ActiveX Applet etc. . These textual data items in the results can be compared to a master results template to identify whether any errors occurred during the agents execution of the playback script. In the case of monitoring real time alert notifications may be generated.

Next in step the agent sends commands from the playback script to the browser or the operating system. Commands sent directly to the browser may be routed through a browser API that is specific to the particular type of standard browser being employed e.g. Internet Explorer Firefox so that the command may be translated into a command that is understood by the browser. Similarly commands that are sent to the browser through the operating system may be routed through an operating system module for similar translation. In one embodiment the commands sent to the operating system cause the agent device to simulate certain events text input mouse movements key presses and those events are passed to the standard browser which is the active running application on the agent device.

If the command being sent is successful as determined in step then the response is recorded by the agent in step and if there are more commands as determined in step then the process returns to step for the processing of more commands. If the command is not successful as determined in step then the agent may query the browser or the operating system for information about the failure as shown in step . This failure information along with any response information from the unsuccessful command is also recorded by the agent in step . Similarly if there are more commands as determined in step then the process returns to step for the processing of more commands. If there are no more commands in the playback session as determined in step then the process may complete by reporting all of the recorded results to the controller. In alternative embodiments the reporting of recorded results may occur in more of a real time fashion to provide the controller with dynamic feedback as to the how the website monitoring or load testing session is proceeding.

The computer system preferably includes one or more processors such as processor . Additional processors may be provided such as an auxiliary processor to manage input output an auxiliary processor to perform floating point mathematical operations a special purpose microprocessor having an architecture suitable for fast execution of signal processing algorithms e.g. digital signal processor a slave processor subordinate to the main processing system e.g. back end processor an additional microprocessor or controller for dual or multiple processor systems or a coprocessor. Such auxiliary processors may be discrete processors or may be integrated with the processor .

The processor is preferably connected to a communication bus . The communication bus may include a data channel for facilitating information transfer between storage and other peripheral components of the computer system . The communication bus further may provide a set of signals used for communication with the processor including a data bus address bus and control bus not shown . The communication bus may comprise any standard or non standard bus architecture such as for example bus architectures compliant with industry standard architecture ISA extended industry standard architecture EISA Micro Channel Architecture MCA peripheral component interconnect PCI local bus or standards promulgated by the Institute of Electrical and Electronics Engineers IEEE including IEEE 488 general purpose interface bus GPIB IEEE 696 S 100 and the like.

Computer system preferably includes a main memory and may also include a secondary memory . The main memory provides storage of instructions and data for programs executing on the processor . The main memory is typically semiconductor based memory such as dynamic random access memory DRAM and or static random access memory SRAM . Other semiconductor based memory types include for example synchronous dynamic random access memory SDRAM Rambus dynamic random access memory RDRAM ferroelectric random access memory FRAM and the like including read only memory ROM .

The secondary memory may optionally include a hard disk drive and or a removable storage drive for example a floppy disk drive a magnetic tape drive a compact disc CD drive a digital versatile disc DVD drive etc. The removable storage drive reads from and or writes to a removable storage medium in a well known manner. Removable storage medium may be for example a floppy disk magnetic tape CD DVD etc.

The removable storage medium is preferably a computer readable medium having stored thereon computer executable code i.e. software and or data. The computer software or data stored on the removable storage medium is read into the computer system as electrical communication signals .

In alternative embodiments secondary memory may include other similar means for allowing computer programs or other data or instructions to be loaded into the computer system . Such means may include for example an external storage medium and an interface . Examples of external storage medium may include an external hard disk drive or an external optical drive or and external magneto optical drive.

Other examples of secondary memory may include semiconductor based memory such as programmable read only memory PROM erasable programmable read only memory EPROM electrically erasable read only memory EEPROM or flash memory block oriented memory similar to EEPROM . Also included are any other removable storage units and interfaces which allow software and data to be transferred from the removable storage unit to the computer system .

Computer system may also include a communication interface . The communication interface allows software and data to be transferred between computer system and external devices e.g. printers networks or information sources. For example computer software or executable code may be transferred to computer system from a network server via communication interface . Examples of communication interface include a modem a network interface card NIC a communications port a PCMCIA slot and card an infrared interface and an IEEE 1394 fire wire just to name a few.

Communication interface preferably implements industry promulgated protocol standards such as Ethernet IEEE 802 standards Fiber Channel digital subscriber line DSL asynchronous digital subscriber line ADSL frame relay asynchronous transfer mode ATM integrated digital services network ISDN personal communications services PCS transmission control protocol Internet protocol TCP IP serial line Internet protocol point to point protocol SLIP PPP and so on but may also implement customized or non standard interface protocols as well.

Software and data transferred via communication interface are generally in the form of electrical communication signals . These signals are preferably provided to communication interface via a communication channel . Communication channel carries signals and can be implemented using a variety of wired or wireless communication means including wire or cable fiber optics conventional phone line cellular phone link wireless data communication link radio frequency RF link or infrared link just to name a few.

Computer executable code i.e. computer programs or software is stored in the main memory and or the secondary memory . Computer programs can also be received via communication interface and stored in the main memory and or the secondary memory . Such computer programs when executed enable the computer system to perform the various functions of the present invention as previously described.

In this description the term computer readable medium is used to refer to any media used to provide computer executable code e.g. software and computer programs to the computer system . Examples of these media include main memory secondary memory including hard disk drive removable storage medium and external storage medium and any peripheral device communicatively coupled with communication interface including a network information server or other network device . These computer readable mediums are means for providing executable code programming instructions and software to the computer system .

In an embodiment that is implemented using software the software may be stored on a computer readable medium and loaded into computer system by way of removable storage drive interface or communication interface . In such an embodiment the software is loaded into the computer system in the form of electrical communication signals . The software when executed by the processor preferably causes the processor to perform the inventive features and functions previously described herein.

Various embodiments may also be implemented primarily in hardware using for example components such as application specific integrated circuits ASICs or field programmable gate arrays FPGAs . Implementation of a hardware state machine capable of performing the functions described herein will also be apparent to those skilled in the relevant art. Various embodiments may also be implemented using a combination of both hardware and software.

Furthermore those of skill in the art will appreciate that the various illustrative logical blocks modules circuits and method steps described in connection with the above described figures and the embodiments disclosed herein can often be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules circuits and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled persons can implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the invention. In addition the grouping of functions within a module block circuit or step is for ease of description. Specific functions or steps can be moved from one module block or circuit to another without departing from the invention.

Moreover the various illustrative logical blocks modules and methods described in connection with the embodiments disclosed herein can be implemented or performed with a general purpose processor a digital signal processor DSP an ASIC FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor can be a microprocessor but in the alternative the processor can be any processor controller microcontroller or state machine. A processor can also be implemented as a combination of computing devices for example a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

Additionally the steps of a method or algorithm described in connection with the embodiments disclosed herein can be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module can reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of storage medium including a network storage medium. An exemplary storage medium can be coupled to the processor such the processor can read information from and write information to the storage medium. In the alternative the storage medium can be integral to the processor. The processor and the storage medium can also reside in an ASIC.

The above description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the invention. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles described herein can be applied to other embodiments without departing from the spirit or scope of the invention. Thus it is to be understood that the description and drawings presented herein represent a presently preferred embodiment of the invention and are therefore representative of the subject matter which is broadly contemplated by the present invention. It is further understood that the scope of the present invention fully encompasses other embodiments that may become obvious to those skilled in the art and that the scope of the present invention is accordingly limited by nothing other than the appended claims.

