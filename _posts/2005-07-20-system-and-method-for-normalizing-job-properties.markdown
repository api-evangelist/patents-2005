---

title: System and method for normalizing job properties
abstract: This disclosure provides a system and method for normalizing job properties. In one embodiment, a job manager is operable to identify a property of a job, with the job being associated with an operating environment. The job manager is further operable to normalize the property of the job and present the normalized property of the job to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07984443&OS=07984443&RS=07984443
owner: Computer Associates Think, Inc.
number: 07984443
owner_city: Islandia
owner_country: US
publication_date: 20050720
---
This application claims the priority under 35 U.S.C. 119 of provisional application Ser. No. 60 590 405 filed Jul. 22 2004.

This disclosure generally relates to enterprise job scheduling and more specifically to a system and method for normalizing job properties.

There are numerous heterogeneous operating environments for jobs applications or other processes. Typically each of these operating environments comprise one of disparate operating systems including UNIX Windows or Windows Server Linux z OS or other mainframe OS and others. Generally these jobs or applications whether enterprise or consumer are compatible or optimized for one of these heterogeneous operating systems. Some properties of these jobs are similar across the heterogeneous systems while others are unique to each operating system job type or job dependencies. For example the status property of a job residing in an enterprise job scheduler for a mainframe system may indicate one of the following example states Abend Requeued JCL Error and others. But the status of a second job residing in an enterprise job scheduler for a Unix based system may indicate one of the following example states Exited Running Suspended Failed and such.

This disclosure provides a system and method for normalizing job properties. In one embodiment a job manager is operable to identify a property of a job with the job being associated with an operating environment. The job manager is further operable to normalize the property of the job and present the normalized property of the job to a user. In one example the property is a status property and the normalized status property is selected from one of the following running failure waiting success cancel restart on hold late to start running late inactive and unknown.

In certain embodiments the property is a first property the job is a first job and the operating environment is a first operating environment. In these embodiments the job manager is further operable to identify a second property of a second job based on for example the same request from the user with the second job associated with a second operating environment. The job manager may be further operable to normalize the second property of the second job and present the normalized second property of the second job to the user.

The details of one or more embodiments of the disclosure are set forth in the accompanying drawings and the description below. Particular features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

At a high level system is all or a portion of the enterprise that includes or is communicably coupled with server one or more clients and a plurality of heterogeneous operating environments . For example system may be associated with the entire enterprise a geographical or logical location within the enterprise or any other portion of the enterprise. It will be understood that the enterprise may be a corporation non profit organization government agency or any other person or entity that includes utilizes or receives the results from multiple computing devices and operating environments . In other words job management system is typically a distributed client server system that allows users of clients to submit jobs for execution on any of the plurality of operating environments . But system may be any other suitable environment without departing from the scope of this disclosure. Generally dynamically as used herein means that certain processing is determined at least in part at run time based on one or more variables. Whereas the term automatically as used herein generally means that appropriate processing is substantially performed by at least part of job management system . It should be understood that automatically further contemplates any suitable administrator or other user interaction with system without departing from the scope of this disclosure.

Returning to the illustrated embodiment system includes invokes executes references or is communicably coupled with a plurality operating environments . Each operating environment is any system or subsystem operable to at least partially or fully execute or process jobs . For example each operating environment is one of a plurality of heterogeneous environments including Unix Linux Windows or mainframe environments as well as others. In another example an operating environment may represent a particular application. Moreover each operating environment may include one server or may be distributed across a plurality of computers. For example illustrated system includes three operating environments and respectively. In this example first operating environment is server environment executing UNIX second operating environment is a mainframe environment executing z OS and third operating environment is a distributed processing environment including a plurality of clients executing Windows. In another example two operating environments may be executing the same operating system but may include different storage capabilities file systems or computing devices. In yet another example two operating environments may be substantively similar or identical except for executing two disparate cyclical releases or versions of the same operating system. As illustrated in each operating environment typically includes one or more job schedulers each of which may be tailored to designed for or at least partially compatible with job executing in the associated operating environment . In this case operating environment and job scheduler may be used interchangeably as appropriate. Of course illustrated operating environments are for example purposes only. Indeed while illustrated separately server may represent include or execute one of the operating environments or one of the operating environments may include or utilize server without departing from the scope of the disclosure.

Illustrated server includes memory and processor and comprises an electronic computing device operable to receive transmit process and store data associated with system . For example server may be any computer or processing device such as for example a blade server general purpose personal computer PC Macintosh workstation Unix based computer or any other suitable device. Generally provides merely one example of computers that may be used with the disclosure. For example although illustrates one server that may be used with the disclosure server can be implemented using computers other than servers as well as a server pool. Server may be adapted to execute any operating system including Linux UNIX Windows Server z OS or any other suitable operating system. But the present disclosure contemplates servers other than general purpose computers as well as servers without conventional operating systems. According to one embodiment server may also include or be communicably coupled with a web server and or a data server.

Memory may include any memory or database module and may take the form of volatile or non volatile memory including without limitation magnetic media optical media random access memory RAM read only memory ROM removable media or any other suitable local or remote memory component. In this embodiment illustrated memory includes job objects and normalization policies but may also include any other appropriate data such as a job history a security or audit log print or other reporting files HTML files or templates and others. Job objects are representations of enterprise jobs and their associated properties. These jobs may be update or report batch jobs database processing commands or other tasks. Each job object typically comprises at least a mapping of property names to values that represent the parameters variables output format or other details of the associated job. For example job object typically comprises at least a job identifier and a pointer or other reference to the appropriate or associated operating environment . The environment pointer may be automatically dynamically or manually populated based on operating system compatibility data storage location utilization priority department or business rules geography other criteria or characteristics or any combination thereof. In another example each job object may include job predecessor job successor triggers calendar VRM requirements dataset predecessors user requirements and network predecessors. In certain embodiments the constituent data may be dynamically populated based on the particular type of job. For example in the case of a distributed job job object may include two or more identifiers of the associated operating environments while a standalone job merely includes one environment pointer. Job object may be in any appropriate logical or physical format including an executable a Java object text SQL XML and such. Indeed job object may be a default job or a particular instance of a job as appropriate. Moreover job object may be keyed on or associated with a user a user or security group a department or any other variable or property. As described in more detail below job object may include any properties operable to be normalized.

Normalization policies include any parameters variables algorithms instructions rules records objects or other policy components for normalizing processing. For example normalization policies may include an enterprise wide or a default normalization policy thereby providing a consistent view of job properties and information. In another example normalization policies may also store a plurality of individual user normalization policies each of which may be associated with a user and allowing the particular user to customize or overwrite the enterprise normalization. In one embodiment normalization policies may comprise one or more tables stored in a relational database described in terms of SQL statements or scripts. In another embodiment normalization policies may store or define various data structures such as Java objects text files extensible Markup Language XML documents Virtual Storage Access Method VSAM files flat files Btrieve files comma separated value CSV files internal variables or one or more libraries. In short normalization policies may comprise one table file or object or a plurality of tables files or objects stored on one computer or across a plurality of computers in any appropriate format. Moreover normalization policies may be local or remote without departing from the scope of this disclosure and store any type of appropriate data.

Server also includes processor . Processor executes instructions and manipulates data to perform the operations of server such as for example a central processing unit CPU a blade an application specific integrated circuit ASIC or a field programmable gate array FPGA . Although illustrates a single processor in server multiple processors may be used according to particular needs and reference to processor is meant to include multiple processors where applicable. In the illustrated embodiment processor executes job manager which performs at least a portion of the management of heterogeneous jobs and or the normalization of their properties.

Job manager typically comprises any software component operable to allow users access to operating environments submit jobs query the status or other job properties normalize some or all of these properties or any other appropriate job management processing. As used herein software generally includes any appropriate combination of software firmware hardware and or other logic. For example job manager may be written or described in any appropriate computer language including C C C Java J Visual Basic assembler Perl any suitable version of 4GL another language or any combination thereof. It will be understood that while job manager is illustrated in as a single multi tasked module the features and functionality performed by this engine may be performed by multiple modules. For example job manager may be a job scheduler and a plurality of adapters see . In another example job manager may comprise a connection listener a request controller communicably coupled with a plurality of job parsers and managers a view controller a session manager a template manager an adapter manager and a profile manager as shown in more detail in . Further while illustrated as internal to server one or more processes associated with job manager may be stored referenced or executed remotely such as GUI and one or more agents residing in the appropriate operating environments . Moreover job manager may be a child or sub module of another software module not illustrated without departing from the scope of this disclosure. In certain embodiments job manager may include or be communicably coupled with an administrative workstation or graphical user interface GUI through interface . In these embodiments job manager may run as a persistent process e.g. a daemon or service operable to listen on a particular port through or in interface .

Server may also include interface for communicating with other computer systems such as clients over network in a client server or other distributed environment. In certain embodiments server receives job submissions or customizations from internal or external senders through interface for storage in memory and or processing by processor . Generally interface comprises logic encoded in software and or hardware in a suitable combination and operable to communicate with network . More specifically interface may comprise software supporting one or more communications protocols associated with communications network or hardware operable to communicate physical signals.

Network facilitates wireless or wireline communication between computer server and any other local or remote computer such as clients . Illustrated network comprises two sub nets or virtual LANS and respectively. Indeed while illustrated as two networks network may be a continuous network without departing from the scope of this disclosure so long as at least portion of network may facilitate communications between job manager and one or more of the operating environments . In other words network encompasses any internal or external network networks sub network or combination thereof operable to facilitate communications between various computing components in system . Network may communicate for example Internet Protocol IP packets Frame Relay frames Asynchronous Transfer Mode ATM cells voice video data and other suitable information between network addresses. Network may include one or more local area networks LANs radio access networks RANs metropolitan area networks MANs wide area networks WANs all or a portion of the global computer network known as the Internet and or any other communication system or systems at one or more locations.

Client is any local or remote computing device operable to receive job submissions and present output such as properties or reports via a GUI . At a high level each client includes at least GUI and comprises an electronic computing device operable to receive transmit process and store any appropriate data associated with system . It will be understood that there may be any number of clients communicably coupled to server . For example illustrated clients include one directly coupled client and two communicably coupled clients to the illustrated server . Further client job owner and user may be used interchangeably as appropriate without departing from the scope of this disclosure. Moreover for ease of illustration each client is described in terms of being used by one user. But this disclosure contemplates that many users may use one computer or that one user may use multiple computers to submit or review jobs via GUI . As used in this disclosure client is intended to encompass a personal computer touch screen terminal workstation network computer kiosk wireless data port wireless or wireline phone personal data assistant PDA one or more processors within these or other devices or any other suitable processing device or computer. For example client may comprise a computer that includes an input device such as a keypad touch screen mouse or other device that can accept information and an output device that conveys information associated with the operation of server or clients including digital data visual information or GUI . Both the input device and output device may include fixed or removable storage media such as a magnetic computer disk CD ROM or other suitable media to both receive input from and provide output to users of clients through the display namely GUI .

GUI comprises a graphical user interface operable to allow the user of client to interface with at least a portion of system for any suitable purpose. Generally GUI provides the user of client with an efficient and user friendly presentation of data provided by or communicated within system . For example GUI may be a front end of job manager and provide functionality to monitor jobs and alerts as well as a summary of the jobs and alerts. GUI may provide an alternate to a Business Scheduling View BSV graphical interface for monitoring. Further GUI may help the user by providing certain advantages including ease of use compatibility with Java and non Java browser platforms and performance. Conceptually the user logs into job manager through GUI which then presents a list of job schedulers. By selecting a particular job scheduler GUI displays the list of active jobs on that scheduler with the appropriate normalized or raw properties. Using GUI the user can define filters in order to configure his or his group s view to a specific set of jobs and or job properties. After configuration the user can save this view for later reuse. When a view is saved for later use it may show up on a list of available pre configured views during login. This feature may give the user the ability to quickly see the same type of information from where he left off last time. Alternatively the user can start on a new view by selecting from the list of job schedulers in the view. From an example Job Status view the user can select a job and zoom into its details thereby easily locating or viewing the specific properties for each desired job . The user can also manage job using this particular view of GUI . For example the user can start stop or suspend the job often according to the particular job scheduler capabilities. In addition to the Job Status view GUI may provide Alert and Dashboard views. The example Alert view may show alerts that have been generated by job manager or job scheduler in response to a particular filter. The example Dashboard view may provide a statistical summary of the jobs and alerts. Moreover the filters may be applied in the Dashboard view to set the overall severity level of the view. When multiple filters are applied to the Job Status Alert or Dashboard views information from various heterogeneous job schedulers may be collected into one view. This view shows the selected job and all its direct dependencies including its immediate predecessors successors triggers resource and other requirements and the current status of each. The consolidated data is often presented in a single way in an example Enterprise view. Thus the Job Status Alert and Dashboard views as well as others may be types or children of certain Enterprise views. Another view may be a Map view which graphically displays the details of a selected job or jobset. Yet another view may be a Server Configuration view in which the administrator or other user can add edit and delete servers or operating environments that are available to job manager . This view does not typically create back end servers. Instead it creates or populates the configuration information to access the environments based on information supplied by the user. Of course this configuration information may be automatically retrieved received or polled as appropriate. Of course each view may be static and or dynamic as appropriate. Generally static views do not change while displayed while dynamic views automatically change at a regular update interval or dynamically update according to other criteria. In certain embodiments GUI may also present a Credentialed User view allowing the user or administrator to add edit and delete Credentialed Users. The Credentialed User information provides login credentials to back end servers or operating environments . Credentialed Users are set up to simplify access to the back end servers environments and to provide an additional level of security. The portal user ID may be used as a key to access the credentialed user information. In addition to the portal user ID the system administrator can set an environment password which can be different than the Portal password. This feature is for users who have access to multiple back end servers with the same user ID but different passwords for each. In addition for each user ID in the credentialed user information an alias ID can be set up. The alias ID can be either a group ID one to many or many to one or can be a user s personal ID for the back end server. The alias ID has an associated password for the back end server. In addition a group user group ID can be set to provide the credentials.

Regardless of the particular view or data GUI may comprise a plurality of customizable frames or windows having interactive fields pull down lists and buttons operated by the user. In one embodiment GUI presents normalized information associated with jobs including job status and associated buttons and receives commands from the user of client via one of the input devices. This normalized information may be presented in tabular graphical and any other suitable format. Moreover it should be understood that the term graphical user interface may be used in the singular or in the plural to describe one or more graphical user interfaces and each of the displays of a particular graphical user interface. Therefore GUI contemplates any graphical user interface such as a generic web browser or touch screen that processes information in system and efficiently presents the results to the user. Server can accept data from client via the web browser e.g. Microsoft Internet Explorer or Netscape Navigator and return the appropriate HTML or XML responses using network . For example server may receive a job submission from client using the web browser execute the particular job in the appropriate operating environment and present the results in the web browser.

In one aspect of operation a user logs into job manager using GUI and is presented with the following example functionality or views Administration Monitoring Configuration and Event Management. Both the Administration and Monitoring views normally includes an applet deployed in an HTML page. The Configuration view is provided by a series of HTML pages that communicate with a Configuration servlet or process. The applets graphically display the objects defined in the job management system. The applet communicates with the appropriate servlet or process to send and receive data to the job management system. Event Management provides web enabled access to the log facility. Job manager may use the Jacada Terminal Emulator JTE to provide host emulation capabilities. In certain embodiments the user may be provided access to certain functionality based on assignments to Portal workgroups. Based on the particular functionality selected by the user job manager may invoke a particular module from a Server Web Server tier. This example level includes applets servlets servlet engines and adapters.

Each servlet serves as a central point of communication and management between the GUI Applet and or Portlet and the one or more operating environments . The servlet is generally operable to expose a callable interface to GUI to allow the end user to configure and monitor jobs. The servlets in turn are operable to forward those calls into the various adapters that link with the particular environment . The servlets may be further operable to control client sessions. This session control typically involves session management authentication and persistency. As described in more detail in the embodiments of each individual adapter communicates with the servlets and the associated operating environment and or job scheduler . Adapters encapsulate the job calls to the operating environment and or job scheduler and expose an API that the example servlets can use. In other words once the user selects the appropriate action to take within one of the desired operating environments such as submitting a job using the associated job scheduler the appropriate adapter encapsulates the user command into an object appropriate for the particular operating environment and or job scheduler . After any suitable amount of processing or job management job scheduler communicates output or job details to job manager via the appropriate adapter perhaps in response to a query or automatically upon job completion or error .

At this point adapter may contain unmodified or native data from each job scheduler . However normalization profiles gives the user administrator or job manager the ability to generate select or otherwise identify a set of normalized properties to be shown from the possible properties of the various types of jobs and operating environments . Job manager may then utilize one or more normalization profiles which in this example includes a plurality of job status property objects to normalize the encapsulated job properties. Job manager applies the job status property objects on each set of jobs in the results . The outcome of this process is a set of values for each job that are ordered and normalized as needed. This information may be displayed in a tabular format at this point for the convenience of the user using GUI . It could also be formatted as an XML document or embedded included or otherwise presented using other outputs. In short there is no specific limitation on how the resulting set of values may be displayed or stored. There may also be a sorting function built into normalization profiles job manager or GUI . In this case after the property objects generate the set of values the collection can be sorted by selecting a specific normalized property to sort on. Then using a standard sort capability such as one built into Java a comparator object can be provided to extract the two property values from each job and compare them. The result of the sorting process is a collection of values that are sorted by the chosen property even when the native values are disparate.

Each adapter is an object or other module that encapsulates one or more types of job schedulers . Adapters may be written or described in any particular format or programming language. For example adapter may be a Java object. Regardless of the particular format adapter is generally operable to provide APIs to job manager for communication with each job scheduler to manage and monitor job information. Put another way adapter may be logically located between job manager and at least the associated job scheduler thereby allowing job manager to be communicably coupled with the job scheduler . In certain embodiments each adapter may provide this compatibility by invoking including exposing or executing one or more of the following example methods 

Job scheduler is any executable routine service daemon or other module or process that is operable to execute monitor or otherwise manage jobs in at least one operating environment . Typically job scheduler is associated with a particular type format or compatibility of job . But as illustrated in the various embodiments any job scheduler may be also be configured to run as a more varied job scheduler or even a master job scheduler managing a plurality of slave job schedulers . Moreover while job scheduler is illustrated as residing within a particular operating environment it will be understood that is for example purposes only and merely illustrates that job scheduler is associated with the particular environment . Indeed job scheduler may be distributed across a plurality of environments computers or data stores without departing from the scope of the disclosure. Job scheduler may be proprietary off the shelf customized or any other type of job scheduler. Moreover enterprise may purchase download or otherwise obtain job scheduler using any appropriate technique.

For example illustrates at least a portion of system that includes server communicably coupled to first and second operating environments . In this example each operating environment includes one job scheduler each operable to manage jobs for that particular operating environment . Job manager illustrated as executing on server is communicably coupled to first job scheduler through a first adapter and to second job scheduler through a second adapter . But as illustrated in the respective figures adapters may reside on server and or the associated operating environment as appropriate. For example as illustrated in job manager locally includes loads or otherwise invokes adapter for executing job receiving or retrieving job status or other communications commands instructions and such to first job scheduler . In another example as illustrated in one or more of the adapters may act as an agent service or daemon residing within the operating environment for the appropriate job scheduler . In this example job manager may invoke or interact with remote adapter using a particular port socket or method. In yet another embodiment illustrated in job manager may include one of the job schedulers operable to schedule heterogeneous jobs to a plurality of operating environments . In this embodiment job manager may be considered a logical all in one module with internal job scheduling adapting and normalizing processes and capabilities.

As illustrated in a particular job scheduler or other application job manager or other non illustrated application may be designed or implemented as a metascheduler that caters to more than one type of job or is compatible with more than one operating environment . In this scenario job scheduler can manage heterogeneous jobs on different platforms operating systems or other environments . When job scheduler provides the information about such jobs it may automatically normalize the properties of these jobs. As illustrated the metascheduler could also control subordinate schedulers and respectively. Metascheduler may be operable to consolidate and normalize the information obtained from the subordinates and as appropriate.

In one aspect of operation illustrated in example when retrieving the details or properties of jobs adapter communicates with job scheduler to get the raw values of these job properties. After adapter receives the information it then translates and normalizes certain properties into a common set of values. In particular the status property of job is mapped from the set of job scheduler specific values into a common or customized set of values. In some cases more than one raw value may be used to map to the common set of values. For example a mainframe job may include three properties that determine the normalized job status value. These example properties are queue name status and specific status. In this example the raw values are used in combination to map to a common normalized value.

Connection listener is any module library object or other process operable to listen such as on a known port s for connections from clients . For example connection listener may include or implement the following example properties 

Worker pool is any object or data structure representing the pool of worker threads. Generally each worker thread object represents a thread that can perform a particular task. For example the worker thread may accept a unit of work and perform or execute it. When the task is completed the worker is typically released back into worker pool . Worker threads are handed out to perform tasks on behalf of client . In certain embodiments worker pool can be configured to start with a particular number of threads and automatically grow to handle higher loads as necessary. Worker pool may include the following example properties 

Request controller is any module object or other process operable to route incoming messages to the appropriate objects and . For example the message may first be sent to the appropriate parser object so that the message may be parsed into a request object. There may be many kinds of request objects such as one for each type of request. For example the following table illustrates a number of example request objects 

After the request object is produced by parser object the request is routed to one of the handler objects for subsequent processing. The handler manager processes a request object which often includes the object ID. Based on the request object ID and other information the handler manager routes the request object to the correct handler object . Each handler is responsible for processing the request using operating environment adapters and job schedulers as appropriate. As with parser objects there are typically many handler objects such as one for each type of request. In certain embodiments each handler is responsible for performing or requesting the work that is requested. For example each handler may be operable to load invoke or communicate with the appropriate adapter based on the request object. As a result of its processing a response object is produced. This response object is returned along with the request object after processing typically through adapter . The following table shows an example list of handlers 

View controller routes a processed request object along with its response object if any to the correct objects. First the request is fed to a view manager which is operable to generate a view for use by GUI . The view manager provides calls or other executes view handlers to process requests into views. For example it may route the request to the correct view handler. There are any number of handler objects such as one for each type of view.

Illustrated job manager also includes session manager . In this embodiment session manager is any module generally responsible for handling sessions. In other words it creates stores and destroys sessions that are assigned to each unique client often utilizing a map of the current sessions. The session typically maintains persistent information for a unique client for the lifetime of the connection. Certain back end objects specific to client are stored and reachable from the client s session. In certain embodiments session manager implements the following example methods 

Template manager may be any module operable to manage templates which are generally stored as objects in HTML files with placeholder variables representing dynamic sections. But in certain circumstances templates may not be complete blocks. Some may represent small sections of a complete page such as a frame table graph etc. At runtime the component sections are typically replaced by the actual data. Template objects are identified by their file names. Since they are often uniquely named on the file system there may be no need to invent a new tagging scheme to identify them. Once requested executed or otherwise located a transformation of the template yields the output that is returned to the user through GUI . During startup initialization or at any other appropriate time job manager reads in or loads the desired templates. Templates are often preprocessed after they are read from the file system. Each template may be encapsulated inside an object that uses a vector. Each entry in the vector contains an internal object that is either a static portion of the template or a dynamic portion represented by a variable name. When the entries are traversed in order and printed out the resulting output resembles the template file. This process may be called printing. The template object exposes the printing functionality with a parameter. The caller provides a map that contains variable names and values as its parameter. When the template object encounters a variable name in the vector while printing it uses the map to resolve the variable name into a value. That value is then printed in lieu of the variable otherwise the variable may be deemed empty. Sometimes template manager executes code in response to a variable entry in the vector. The caller can register callbacks with the object for this scenario. Callbacks can be registered for specific variable name index number or all variables. Parameters to a callback include the current vector entry and working buffer of the printing process. Template manager hands these objects out to transformers as necessary. Transformers can use the same template object simultaneously. In this scenario the template object is responsible for safely supporting multiple callers.

Adapter manager is responsible for handling adapter wrappers often utilizing a map of adapters. The adapter wrapper encapsulates a local or back end adapter . By providing a high level interface layer on top of each adapter the wrapper provides a consistent and semantic set of methods to each type of job scheduler. Typically adapter manager creates stores and destroys wrappers that are assigned to each unique back end connection or environment . In certain embodiments adapter manager implements the following example methods 

Profile manager is responsible for handling profile objects such as for example servers users groups and views. In this example the server profile object encapsulates a configured server the user profile object encapsulates a user record the group profile object encapsulates a Portal group record and the view profile object encapsulates a view record. The profile manager communicates with configuration Portal and its own data store to create update and delete these objects. In certain embodiments profile manager includes the following example methods 

In one aspect of operation a flow describes a path of execution of a client request through job manager . The request typically originates from GUI and results in a new or updated page that is returned to the browser. When the servlet receives a request it is routed the request controller . This controller produces a request object that encapsulates the HTTP request and response. Request controller then forwards this object to parser manager . Parser manager is comprised of one or more parsers. Each parser inspects the request and breaks it down into various pieces of information as appropriate. For example the session ID and request ID are extracted. The parser may use this information to look up objects that are relevant to the request. For example the session ID translates to a session object. When control returns to request controller from the parser the request object is forwarded to handler manager .

Handler manager is comprised of one or more handlers. Based on information in the request object such as the request ID handler manager forwards the request to the corresponding handler. Each handler may be considered an atomic piece of business logic dedicated to servicing a request. A handler often depends on other objects to accomplish its work. Some of these objects include adapters model objects and other manager objects. For example when a job status handler executes it uses the correct adapter instance in conjunction with the job status model object to accomplish its work. When the handler finishes its work it produces a response object. A response object can contain different pieces of information such as output data error codes and others. Handler manager returns this response object to request controller .

Request controller forwards the response object to view controller . View controller is comprised of one or more view objects. Each object is dedicated to producing a specific view such as job status. The job status response object provides the information to the view to produce the output for the browser. Views are normally closely tied to templates. Template manager provides HTML templates that form the basis for the output. The final output is a combination of data from a response object and a template. After the output is composed view controller sends it to client . Control then returns to request controller and out of the servlet.

Property includes any job property status variable characteristic object or other component operable to include identify or reference or a particular of the associated job. For ease of readability property may be referred to as job status property objects but this is not meant to limit the scope of the disclosure. Such an example job status property object may have three purposes. First it represents a specific property of job such as for example the property object may represent the name of job . Second the object may be operable to extract the value of the property that it represents from job . So for example when a property object that represents the name of job is applied to a job object that is named Job A the result is the value Job A. Job status property also may convert the value into a normalized format instead of keeping the unmodified or raw value. This is typically beneficial when jobs from two different types of job schedulers provide different values that are actually equivalent for the same type of property. For example a property object that represents the status of job may extract two different values from two heterogeneous jobs such as Completed and 0. However both values are substantively equivalent because they are both interpreted as successful statuses in the two schedulers . Therefore the property object can translate the two values into a single normalized value such as Success a completed 0 and others. Properties may each include a name and a value. Generally many properties in normalization policy may be normalized. Accordingly in some embodiments property may each also comprise a mapping of the particular property value and the associated normalized value. In certain embodiments property object includes a method operable to normalize the value or includes metadata associated with the particular value type that allows subsequent modules to normalize the value. In other words each property operable to be normalized may be a collection of tuple objects. For example one tuple object may comprises the property identifier the property value and the default normalized value. In another example one tuple object may comprise an identifier of the operating environment the property identifier the property value and the default normalized value. In a further example one tuple object may comprise the user ID or group ID the property identifier the property value and the associated or customized normalized value. Of course these examples and the associated illustration are for readability purposes only. Normalization policies may be in any format and may include any suitable data. Moreover job manager may use any appropriate component or technique to normalize the data without departing from the scope of the disclosure.

Turning to the illustrated embodiments illustrates an example job requirements or job properties view . In this view the user may be able to view or modify various properties of job or jobset. In other words job properties view is a graphical representation of the objects that can be included in the definition of the job. Job objects may include job predecessor job successor triggers calendar VRM requirements dataset predecessors user requirements and network predecessors. The dialog may be a modeless frame that contains a context sensitive panel for displaying the graphical view of the selected item s objects. This frame may contain a palette on the left side that has a list of objects that can be created for the selected object. On the right may be the graphical layout of the objects for the selected item. Users may have the option to drag items from the palette and drop them onto the graphical layout. Dragging and dropping an object may create a new object but the user often fills in the properties for that object in the main view. Upon dropping the object an icon may appear in the graphical layout. Also the main view may select the new object and display its properties so the user may fill in any missing attributes. Until the user fills in required properties all icons representing the new object may have a graphical design that alerts the user that the object is incomplete.

Accordingly job properties view gives the user the ability to drag existing objects into the job properties view from the main panel s tree view. Job properties view may not allow invalid objects to be dropped and the cursor may change to a No symbol to notify the user. When a valid object is dropped an icon may appear in the job properties view layout and the main view may select the dropped object and display its properties. Job properties view may always be locked onto the object that was selected when it was launched. Users may have the ability to select objects in the main view without job properties view changing. When the user is finished changing the requirements for job or jobset the applet may provide the option to either close the dialog or change the job properties view s selection to edit another object s requirements. Job properties view may display a blank panel if the user deletes the selected job or jobset from the view. When the user selects an object in job properties view the main view may select the same object and display its properties.

Method begins at step where job manager receives a job request from the user typically using client . But as described above the user may submit job request directly to server without departing from the scope of method . The job request may comprise one or more of the following types of jobs an update job a command a task or any other appropriate enterprise job or request. Next at step job manager authenticates the user. This authentication may include verifying that the user can submit this particular type of job can update the requested or associated data or any other security or authentication procedure or technique. Of course while not illustrated modules other than job manager may perform this authentication and communicate the results to job manager . Job manager then identifies a job object using the received job request at step . For example the job request may include a job identifier or other pointer. In this example job manager queries the plurality of job objects to determine the particular job object associated with the request based on the pointer. Once the appropriate job object is identified Job manager identifies operating environments for the job at step . As described above in the case of a distributed job there may be more than one operating environment associated with the job. Job manager may identify the appropriate operating environment using any suitable technique. For example job manager may determine the appropriate operating system to execute the job. In another example job manager may identify the location of the data storage associated with the job request. In yet another example job manager may identify the appropriate virtual location for executing the job request. Next at step job manager invokes a job scheduler in the identified operating environment . Once job manager has invoked job scheduler it may execute the job using the invoked job scheduler at step . It will be understood that this execution may include an immediate submission adding the job to queue associated with the invoked job scheduler or any other appropriate technique.

Method begins at step where server receives a status request from a user typically at client . Next at step job manager loads a default normalization policy . Of course job manager may load the default normalization policy at startup initialization or any at other appropriate time. At decisional step job manager determines if the requesting user is associated with a user normalization policy . For example job manager may parse the status request to identify the user ID. In another example job manager may store an alias for the requesting user for the various back end operating environments . In yet another example job manager may receive a user identifier from GUI or another module. Once job manager has sufficiently identified the appropriate user job manager loads the user normalization policy at step if appropriate.

Once the one or more normalization policies have been loaded or identified job manager identifies a first job associated with the status request at step . Next job manager identifies a first job property for the identified job at step . For example the job property may be job status property object stored in server . In another example job manager may query the appropriate operating environment through an adapter . This job property may comprise a status name output or any other appropriate data or characteristic. At decisional step job manager determines if a data map exists for the identified job property in the loaded user normalization policy . If the map does not exist then job manager selects the data mapping from the default normalization policy at step . If the user normalization policy does include the appropriate data map the job manager selects loads or otherwise identifies the data map in user normalization policy at step . It will be understood that job manager may select the data map using any appropriate technique such as for example loading a job status property object based on property name identifying an algorithm associated with the user job operating environment one of six and property or any other appropriate technique. Once the appropriate data mapping has been identified job manager normalizes the identified job property using the appropriate data map at step .

Next at decisional step job manager determines if there are more properties associated with the particular job . If there are then job manager identifies the next job property for the particular job at step and processing returns to decisional step . Once there no more properties associated with the particular job then job manager determines if there are more jobs associated with the status request at decisional step . If there are more jobs then job manager identifies a next job using the status request at step and processing returns to step . Once the status request has been appropriately processed then job manager generates a presentation including the normalized properties at step . In certain embodiments job manager may identify the appropriate template and embed the normalized properties in the template. In another embodiment job manager may identify a dynamic page already resident on the appropriate client . In this case job manager may encapsulate the normalized properties in a presentation object for communication to client . Next at step job manager communicates the presentation or presentation object to the requesting user at client .

The preceding flowcharts and accompanying description illustrate exemplary methods and . In short system contemplates using any suitable technique for performing these and other tasks. Accordingly many of the steps in these flowcharts may take place simultaneously and or in different orders than as shown. Moreover system may use methods with additional steps fewer steps and or different steps so long as the methods remain appropriate.

Although this disclosure has been described in terms of certain embodiments and generally associated methods alterations and permutations of these embodiments and methods will be apparent to those skilled in the art. Accordingly the above description of example embodiments does not define or constrain this disclosure. Other changes substitutions and alterations are also possible without departing from the spirit and scope of this disclosure.

