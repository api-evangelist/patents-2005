---

title: Hierarchical arrangement for spooling job data
abstract: A hierarchical spooling data structure includes a plurality of nodes. In accordance with certain aspects, the plurality of nodes include at least four nodes: a first node representing a fixed page of the job; a second node representing a fixed document of the job, the second node including a reference to the first node; a third node containing data representing a fixed sequence of documents of the job, the third node including a reference to the second node; and a fourth node containing data representing a root of the job, the fourth node including a reference to the third node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08243317&OS=08243317&RS=08243317
owner: Microsoft Corporation
number: 08243317
owner_city: Redmond
owner_country: US
publication_date: 20050324
---
This application is a continuation in part of U.S. patent application Ser. No. 10 938 476 entitled Spooling Strategies Using Structured Job Information filed on Sep. 10 2004 which is incorporated herein by reference in its entirety.

This application claims the benefit of the following U.S. Provisional Applications all filed on May 3 2004 and each of which is incorporated by reference herein in its respective entirety U.S. Provisional Application No. 60 567 890 and U.S. Provisional Application No. 60 567 920.

The present application is also related to co pending and commonly assigned U.S. patent application Ser. No. 10 794 669 entitled Multilevel Ticket Based Job Management Architecture for Computing Devices filed on Mar. 5 2004 which is incorporated herein by reference in its entirety.

The present application is also related to co pending and commonly assigned U.S. patent application Ser. No. 10 836 327 entitled Document Mark Up Methods and Systems filed on May 1 2004 which is incorporated herein by reference in its entirety.

Computing devices commonly render documents using spooling techniques where spool is an acronym for Simultaneous Peripheral Operations On Line . In a typical spooling technique an application on the computing device generates a document and a spooler on the computing device stores it in a spool storage. The spool storage can be implemented using memory such as RAM memory or more commonly using disk storage. When the device is ready to process the document the device can then access the document from the spool storage and convert it to a format that is compatible with the format expectations of an output device such as a format defined by the Page Description Language . The device can then forward the converted document to the output device whereupon the output device prints the document or performs some other processing with respect to the document. Storing a document in a spool storage rather than directly outputting the document to the printer is generally advantageous because it allows the application that generated the document as well as the spooler on the computing device to perform other tasks while the document is being processed for printing. Generally a print job refers to the task of processing an identified document using a spooling strategy. The print job specifies job information to be processed by the spooling strategy.

Conventional strategies commonly generate and consume job information in a variety of proprietary and narrowly tailored formats. The lack of versatility sophistication and uniformity in these formats can prevent the device from rendering job information in an efficient manner. Further known conventional strategies do not provide versatile techniques for associating metadata with the job information. Known conventional strategies may suffer from yet additional unspecified deficiencies.

In accordance with certain aspects job information stored in a spool storage has a plurality of nodes organized into a hierarchical arrangement representing the job information. The plurality of nodes include a first node representing a fixed page a fixed layout static content page of the job and a second node representing a fixed document a fixed layout static content document composed of fixed pages of the job the second node including a reference to the first node. The plurality of nodes further includes a third node containing data representing a fixed sequence of documents of the job a fixed layout static content sequence composed of fixed documents the third node including a reference to the second node. The plurality of nodes may also include a fourth node containing data representing a root of the job the fourth node including a reference to the third node.

The following description sets forth an example hierarchical structure to be used in the generation and or consumption of job information. In a production phase the structured job information can be created and stored in a spool storage. In a consumption phase the job information can then be retrieved from this storage for processing.

The term job used herein refers to a task in which one or more actions are performed to process a consolidated grouping information. For instance a print job may entail printing job information that defines one or more documents. More generally reference to processing job information can refer to any performing of operations using or based on such job information such as any kind of rendering of the job information e.g. printing or displaying the job information distributing the job information to a target destination with or without modifying it archiving the job information altering the job information based on metadata associated with the job information making decisions regarding how to render or otherwise process the job information or some other form of processing. The term job information refers to any kind of information used to specify the nature of the job such as the actual information to be rendered and or information that defines how the job is to be rendered and so on.

A package is a logical concept that refers to a collection of job information that comprehensively specifies an entire job. The package can contain multiple parts also referred to as elements or features herein. In the case where the job information defines a hierarchical tree of nodes such nodes may define respective elements in the package. Collections of elements can be treated as a single unit. For instance a package may specify multiple documents and each of these collections can contain multiple elements e.g. image resources font resources etc. .

The term document as used herein refers to any unit of any kind of information. For example a document may pertain to information created by a text editing application a spreadsheet processing program a drawing program and so on. Each document can have multiple associated parts each of which can itself be considered a component document in its own right. A job can specify documents that originate from multiple different sources.

The term spool storage represents storage for storing job information implemented using any physical storage medium. In one case the spool storage may be implemented using RAM memory. In another case the spool storage may be implemented using disk storage solid state memory or another type of physical storage medium. The spool storage can be fixed or removable. The spool storage may define a single file a collection of associated files or some other storage strategy. A unit of spool storage such as a single file that stores an entire package defining a job is also referred to as a container. 

More generally any of the functions described herein can be implemented using software firmware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module functionality and logic as used herein generally represent software firmware or a combination of software and firmware. In the case of a software implementation the terms module functionality or logic represent program code that performs specified tasks when executed on a processing device or devices e.g. CPU or CPUs . The program code can be stored in one or more fixed and or removable computer readable memory devices.

The above mentioned processing device s can be implemented in different ways. For example the processing device s can be implemented using semiconductor transistor based computing mechanisms e.g. by electronic integrated circuits ICs or fixed electronic logic circuitry . Alternatively the processing device s can be implemented in whole or in part using quantum computing mechanisms optical computing mechanisms mechanical computing mechanisms biological computing mechanisms and so forth.

Certain discussions in this disclosure are framed in the exemplary context of an object oriented programming paradigm. By way of background in such an approach an application implements program modules as respective objects. Objects can include properties which convey attributes of the objects e.g. the characteristics or traits of the objects . Objects can include methods associated therewith that provide functions that can be performed by the objects. Objects interact by passing messages to each other. The object oriented programming paradigm commonly organizes objects in parent child hierarchies. A child inherits the properties of its parent. A class refers to a general blueprint which describes a collection of objects. However the principles described herein are not to be construed as limited to an object oriented programming paradigm.

This disclosure includes the following sections. Section A describes an exemplary system for producing and consuming structured job information. Section B describes an exemplary flowchart which explains the operation of the system of Section A. Section C describes an exemplary computer environment for implementing the system of Section A.

This Section i.e. Section A.1 provides an overview of the system used to produce and consume the structured job information . The next Section i.e. Section A.2 delves into greater detail regarding the organization of the job information itself.

By way of overview the system includes an application module coupled to a spool storage via interface functionality which can be implemented in one example as an application programming interface API . The spool storage stores the job information . This chain of components implements the production aspects of the processing of the job information . The system also includes a spooling module that is configured to retrieve the job information from the spool storage and then perform some kind of processing on it to provide an output result. This chain of components implements the consumption aspects of the processing of the job information . As noted above processing can refer to any kind of action performed on the job information which may or may not modify the content of the job information . The processing may comprise printing the job information displaying the job information routing the job information to a target location with or without modifying it archiving the job information and so on. In any case the recipient of the output result generated by the spooling module can comprise one or more of the target entities . . . associated with different usage cases . A variety of the usage cases will be discussed below.

The modules logic and storage units shown in the system can be implemented by any variety and grouping of physical mechanisms and devices. In one exemplary case a computing device not shown implements the application module interface functionality spool storage and spooling module . More specifically the various logic and modules can be implemented by machine readable code stored in the memory of the computing device and executed by the processing unit s of the computing device. The spool storage can be implemented by a storage medium e.g. a hard disk provided by the computing device. The computing device can operate using any kind of platform e.g. as defined by the operating system and or other software configuration of the computing device . More specifically in one implementation the functionality and associated formats to be described below are specifically configured to operate using different computing platforms thus defining a standard approach that has wide applicability to different technical environments and which thus serves to facilitate interaction among different technical environments and associated users.

In one case the target entities . . . can be implemented as devices that are separate from the computing device which implements the other components of the system . The computing device can be communicatively coupled to the target entities . . . via any kind of communication channel such as is USB coupling parallel coupling network coupling of any kind manual transport of removable media and so forth. In a common case for instance one or more of the target entities . . . can comprise printers for printing documents fed to them by the spooling module . The computing device can be communicatively coupled to the printer s via any kind of hardwired and or wireless links using any kind of communication protocol. Or the spool storage can be implemented as a removable media and transported to the printer. The target entities . . . can alternatively represent display devices storage devices other computing devices and so on.

The above allocation of system functions to devices is only exemplary. In other implementations different aspects of the system can be implemented by separate computing devices. For instance a first computing device can implement the application module and a separate computing device can implement the spooling module . In other implementations the spool storage can also be implemented as a separate unit which couples to the computing device which implements the application module and or the spooling module . In other implementations the target entities . . . can be integrated into the same computing device which implements the application module and or the spool module . Still other configurations are possible.

In any event where one or more computing devices are used to perform aspects of the system those computing devices can correspond to any type of computing devices such as general purpose computing devices application specific computing devices e.g. game consoles such as Xbox video game systems produced by Microsoft Corporation of Redmond Wash. portable computing devices such as a personal digital assistants mobile phones etc. and so on. to be discussed below in turn shows one exemplary computer environment for implementing aspects of the system .

Further details regarding each of the above identified components of the system will follow. Beginning with the production aspect of the system the system can use any kind of application module to generate any kind of document. Common types of application modules include text processing programs spreadsheet processing programs graphics processing programs markup language processing programs database search and retrieval programs and so on. There is no constraint on the type of application program that can be used to supply job information to be processed using the system . The application module can represent a program implemented in any programming environment for example the application module can be implemented as a managed program within the Microsoft Corporation s NET programming environment.

The interface functionality formats the output of the application module into the structure of the job information . Generally exemplary and non limiting functions performed by the interface functionality can include 1 persisting the job information in the spool storage having the desired structure 2 submitting job information to the spooling module for scheduling and printing 3 monitoring different stages of the job production and hooking up to back end notifications to inform any interested listening entities 4 monitoring different stages of the job consumption and hooking up to back end notifications to inform any interested listening entities 5 enabling the spooling module to send output data to the target entities . . . and so on. The interface functionality also provides functionality for retrieving information regarding the job information and for enabling the generation of notifications for various events pertaining to the production and consumption of the job information .

In one implementation interface functionality produces the same uniform structure regardless of the nature of the application module which supplies the job data. For instance the same interface functionality can transform the output of a text editing application spreadsheet application graphics processing program and so forth into the uniform structure . In another implementation each application module may include specifically tailored software to work in conjunction with the interface functionality to provide the uniform structure . In such implementations each application module produces the uniform structure . Alternatively or in addition the spooling module can play a role in the generation of the job information having the uniform structure .

With respect to the consumption aspect of the system the system retrieves the job information from the spool storage and supplies it to the spooling module for processing. The spooling module itself can represent a software program implemented by the same computing device that provides the application module . It includes processing logic for processing the job information . The processing logic can also be viewed as a printer driver. This processing logic in turn can include management logic for governing various operations performed by the processing logic .

The processing logic can include filter logic for actually performing the required processing on the job information . As will be described in greater detail below the filter logic can include one or more filters . . . for performing different processing functions on the job information to generate an output result or gather information regarding the job information or the target entities . . . . The spooling module then feeds the final output result to one or more of the target entities . . . via device port logic . In the common case of printing one or more of the target entities . . . can comprise a printer which receives the output result and prints the document s specified by the output result. Finally the spooling module can also include generically labeled other logic for performing other functions that are not pertinent to the focus of this disclosure and therefore will not be described further herein.

Further details regarding the filter logic are provided as follows. In one implementation the job information that is processed by one or more of the filters . . . retains the same format structure as the job information stored in the spooler storage . Thus in this exemplary implementation the filter logic does not require that the job information be converted into an intermediary form in order to process it. This in turn enables the spooling module to process job information in an efficient manner. This also yields a uniform approach compared to other techniques which resort to a complicated assortment of disparate and ad hoc processing techniques to deal with different proprietary formats.

The functions performed by the individual filters . . . can be generalized in the following manner. A first class of filters accepts job information which conforms to the structure performs some kind of processing on this information which may or may not modify the information and then generates an output result which also conforms to the structure . A second class of filters accepts job information which conforms to the structure performs some kind of processing on this information and then generates an output result which does not conform to the structure or which only partially conforms to the structure . A third class of filters accepts job information which has already been converted into a non structured format and provides yet further modification or processing of such non structured information.

More specifically for example one or more initial filters of the first class can be set up to modify the job information in various ways such as by adding a watermark etc. but does not otherwise change its basic format structure . A terminal filter or multiple terminal filters of the second class can be set up to modify the job information by changing its format such as by either completely removing its format structure or at least partially modifying its format structure . More specifically the terminal filter n e.g. filter n or plural terminal filters can be used to convert job information having the format structure into a non structured form that can be interpreted by an identified target entity . . . . In effect the terminal filter n or filters thus serves the role of a rendering module of a printer driver. For instance filter n may convert the job information having the structure into a page description language PDL format that can be fed to a printer which accepts such format. In another case a filter n can convert the job information into a printer interpretable format and filter n can perform post processing on this format such that the combination of filter n and filter n can be considered as the printer driver.

Suppose as explained above that the terminal filter n is a filter of the first class which generates an output result having job information which still conforms to the structure . A target entity represents an appropriate device to receive such an output result. This target entity is referred to as structure aware because it receives job information conforming to the structure and thus provides necessary processing functioning to recognize such information and process it appropriately.

Suppose alternatively that the terminal filter n is a filter of the second class or third class which generates job information which no longer conforms to the structure . A target entity represents an appropriate entity to receive such an output result. This target entity is referred to as structure unaware because it receives job information that no longer conforms to the structure and thus the entity does not need to devote any specialized functionality for processing information expressed in this structure indeed the target entity need not and generally will not be aware that the job information its receives e.g. in an appropriate PDL format was ever originally expressed using the structure .

There is a third case where the terminal filter n generates an output result which modifies the structured format to some extent but still maintains some vestiges of the structure . Target entity is an example of the kind of entity that can receive and process this output result. identifies this kind of entity as being partially structure aware because it should include at least some processing functionality for interpreting whatever remnants of the structure that still remain in the output result.

Some filters may not alter the job information but rather gather information regarding the job information or the target entities . . . . Such filters may generate an output result of job information that is the same as the job information that is input to them or alternatively may not output any job information. Rather than or in addition to outputting job information such filters may output the information they have gathered. For example a filter may be used to count the consumables the job uses and report to the usage back to an accounting application running on the same computing device as spooling module .

Different jobs may require that different filtering operations be performed on the associated job information . A filter configuration module not shown can be used to define what filters . . . are to be invoked in processing a particular job how the individuals filters . . . are to be configured and how the filters . . . are to be chained together. In other words the spooling module can chain the filters . . . together in different ways to produce different net effects. In a series configuration shown in for example filter A feeds its output result into the input of filter B and filter B feed its output result into to the input of filter C not shown and so on.

More specifically the type of processing that the filter logic performs on the job information can be controlled in element by one or more print tickets associated with the job information . The print tickets include attribute information that defines the operations that should be performed on the job information as it passes through the filter logic . Different print tickets can be associated with different elements of the structure of the job information as will be described in the next subsection A.2 .

The system can also function in a client server mode of operation where the spooling module responds to requests from a client module which may comprise one of the target entities . In a client server implementation a server side application not shown creates document content on the fly in response to a client request. A server process generates parts of the job information one at a time while a separate process at the same time pulls parts from the job information one at a time to send down to the client module.

As shown in the job information generally includes a structure defined by a plurality of nodes coupled together according to a set of established rules. The same general rules can apply to the construction and consumption of the structure regardless of the application and application platform used to produce and consume the job information . The strategies described below therefore provide a standardized mechanism for sharing job information among participants within different programming environments.

The job information uses a hierarchical scheme to connect its nodes together. A hierarchical scheme couples the nodes together using parent child relationships. That is a top most node defines a so called root node. The root node includes one or more child nodes and the child nodes in turn can include one or more of their own respective child nodes and so on. The child nodes can optionally inherit methods properties metadata etc. associated with their respective parent ancestor nodes.

Generally the structure is a logical concept that may or may not map to actual elements of a document to be rendered. That is each node may be considered an object. Certain objects may represent actual elements of a document to be rendered such as various image resources and font resources . Other objects may not have a one to one relationship with elements of the documents to be rendered. These latter types of nodes are therefore analogous to folders in a file hierarchy that is the folders may store individual files that contain content that maps to actual elements of the document but the folders themselves may not have a one to one relationship with actual elements of the document.

The top level of the hierarchy specifies job related information that identifies the entire job itself. For instance the job may pertain to the printing of multiple books each book including multiple chapters and each chapter in turn can include multiple pages and each page in turn can include font resources and image resources. It should be noted that although resources are associated with job level resources can be referenced or used by other levels in schema . In this example the top level of the hierarchy identifies the logical package which encapsulates the entire job that is the entire book. The next level of the hierarchy specifies information that identifies the document sequences associated with the job. In the example of the multiple books the document sequence level might specify individual ones of the multiple books.

The next level of the hierarchy specifies information that identifies the documents associated with the job. In the example of the multiple books the document level might specify individual chapters in the books. Or this level of the hierarchy may specify different kinds of documents to be printed in a single print job such as a first document created using a text editor and a second document created using a spreadsheet program and so on where these two documents together comprise a report of some kind.

The next level of the hierarchy specifies information that identifies different pages within the documents identified in the proceeding level.

Resources can be associated with the root level of the hierarchy defined by schema which is job level . Although resources are associated with the root level of the hierarchy other levels in the hierarchy can reference resources as discussed in more detail below. This allows resources to be shared by the different levels of the hierarchy even though they are associated with the root level of the hierarchy. Particular types of resources can include an image resource a font resource or some other resource .

Further metadata can be associated with any of the levels of the hierarchy of the schema . For instance exemplary metadata can be associated with the job level the document sequence level the document level and or the page level . Metadata specifies any supplemental information pertaining to the job information such as an author who created a document contained in the job a time when the document was created various keywords pertaining to the content a summary of the content and so on. There are no restrictions on the type of and meaning assigned to metadata that can be appended to different elements of the schema . A particular kind of metadata is a print ticket . The print ticket can also be associated with any level of the hierarchy of the schema . For instance exemplary metadata can be associated with the job level the document sequence level the document level and or the page level . A print ticket defines the types of processing operations that should be performed on associated elements of the hierarchy of the job information . For instance a print ticket associated with the job package level will apply to the entirety of the package defined by the job information . A print ticket associated with an individual page of the job information will have a localized effect by only affecting that page . Further details regarding exemplary print tickets are provided in the above captioned co pending U.S. patent application Ser. No. 10 794 669.

Further inheritance may optionally apply to the methods properties metadata etc. in the job information . If inheritance is used to determine what print instructions apply to any given node the spooling module can walk the tree from a child node to its root or vice versa aggregating any print instructions that may apply along the way. This aggregation allows general instructions to be uniformly inherited by all children. A print instruction of a child node may override the general instructions of a parent node.

In summary the schema shown in provides a powerful uniform and versatile mechanism for representing complex job information particularly for those jobs that involve multiple document sequences and or multiple documents. Traditional techniques provide no provisions for representing these kinds of complex scenarios in spool storage therefore these traditional techniques suffer from inefficiencies which may be significant.

In one implementation the hierarchy of the job information is set to provide defined levels corresponding to jobs document sequences documents and pages. In another implementation the hierarchy can be varied in one or more respects.

To further clarify the exemplary schema shows one exemplary instantiation of the schema . The entire collection of nodes shown in defines a package. The package includes a root node associated with the entire package e.g. the entire job. These different nodes in the package are also referred to herein as different parts of the package or job.

Some of the nodes in the package are also referred to as being fixed such as the fixed document sequence nodes and the fixed document nodes. A fixed node refers to a node that is already laid out properly for rendering and that has static content. A fixed page node or fixed page refers to a fixed layout static content page. A fixed document node or fixed document refers to a fixed layout static content document composed of fixed pages. A fixed document sequence node or fixed document sequence refers to a fixed layout static content document sequence composed of fixed documents. For example a fixed document node refers to a document that is already laid out properly for printing on a particular size of paper e.g. letter size A4 size legal size postcard size etc. the organization of text and or graphics on the page has already been determined for the particular size of paper on which the job is to be printed. This layout for the job is determined when the structured job information is created and is typically created by the same component or module as creates the structured job information e.g. the interface functionality or the application module of .

An index can be associated with the package and hence with the root node . This index can be used to locate the package in the spool storage .

The job defined by the root node includes a number of fixed document sequences as identified by fixed document sequence node and fixed document sequence node . Also a metadata node is associated with the root node . If so configured the metadata node associated with the root node job node defines properties which apply to the job as a whole.

Each of the fixed document sequences associated with nodes and can include multiple fixed documents associated therewith. For example the fixed document sequence represented by node includes at least two fixed documents identified by nodes and .

In addition to fixed document nodes node also includes nodes and associated therewith. Node specifies metadata associated with node and node specifies a print ticket associated with node .

Each fixed document includes one or more fixed pages associated therewith. Nodes and for example represent fixed pages associated with fixed document node . Metadata node indicates that metadata can be associated with the document level of the hierarchy as it can for any level . Print ticket node indicates that resource information can be associated with the document level as it can for any level .

Finally each fixed page can include page data associated therewith as well as metadata and a print ticket. For example fixed page node includes page data node and metadata node associated therewith indicating that page data and metadata can be associated with this page. Page node includes print ticket node and page data node associated therewith indicating that a print ticket and page data can be associated with this page.

The package associated with root node can also include a collection of resources. These resources are associated with root node but can be referenced or used by different nodes in the job. Such collection of resources thus defines a shared library of resources that can be applied at different points within a document represented by the package. However this shared library of resources remains associated with a single node and thus all resources can be maintained in a single location e.g. a single folder or directory associated with the single node even though they are referenced by different nodes in the job. Nodes and for example represent resources associated with job node . Resources can be for example image resources font resources or other types of resources. Image resources are images that can be used or referenced by different nodes in the job while font resources are fonts that can be used or referenced by different nodes in the job. A metadata node depends from the resource node which represents metadata that applies the resource node .

Metadata can be associated with individual nodes in the hierarchical structure in different ways. For instance individual nodes can provide linking information that points to associated metadata or the nodes themselves can embed such metadata as integral parts of the nodes and so forth.

As discussed above the different nodes in a package are also referred to as parts of the package or job. An individual part includes common properties e.g. name and content type and a stream of bytes. Part names are organized into a hierarchy similar to paths on a file system. This hierarchy is composed of segments delineated by slashes. The last segment of the name is similar to a filename in a traditional file system. The segments of the names of all parts in a package form a tree.

Alternatively the job may be collapsed into the fixed document sequence so that the fixed document sequence e.g. node or is the root of the hierarchy. In such situations job node would not be included in the hierarchy and resource nodes would be associated with the fixed document sequence node that is the root of the hierarchy although the resource nodes could be referenced by other non root nodes of the hierarchy .

Parts can reference or be related to other parts using Uniform Resource Identifiers URIs or other linking mechanisms. In certain exemplary embodiments three different types of references or relations are defined spines references and relationships. A spine or spine reference refers to a reference from a source part that identifies a target part where both the source and target parts are fixed e.g. references from a fixed document sequence to fixed documents and references from fixed documents to fixed pages . Spines are indicated in by a solid line. The source part of the spine is typically made up of only spine references to other parts there is typically no additional text and or graphic data associated with the source part. Spines can be represented using the Extensible Markup Language XML .

A reference is similar to a spine but the source and target parts need not be fixed and the target part is a resource. Any document related node in the package can reference any resource node indicating that a particular element or aspect of the document is referencing a particular resource for use thereat. This reference can be made even though the resources are associated with only the root nodes. For instance in the exemplary case of fixed page node references resource node . This reference is indicated in with a dashed line terminating with an arrow head. This means that the resource represented by node is used in the page represented by fixed page node . Further fixed page node references resource nodes and indicting that the resource associated with node and the resource associated with node are used in the page associated with node . These references are indicated by two respective dashed lines. References can be represented using XML.

Relationships provide a way to associate nodes with metadata. Any node can be a source node and a metadata node is the target node. Relationships allow this association to be represented without modifying the parts. As such relationships make the connections between parts directly discoverable without examining the content in the parts. This makes the connections independent of content specific schema and also allows the connections to be resolved more quickly. Relationships are indicated in by an alternating dot dash line.

Relationships can be represented using XML using relationship parts. Namely each part in the job information that is the source of one or more relationships has an associated relationship part. This relationship part holds the list of relationships for the source part e.g. expressed in XML using a content type application vnd.ms metro.relationships xml .

Different strategies can be used to link the elements together to form the hierarchies shown in . In one technique the individual elements can be modified so that they point to linked objects e.g. parent and child objects . Linking can be provided by pointers Uniform Resource Locators URLs or some other referencing mechanism. Alternatively or in addition separate relationship information can be defined that specifies how separate elements are linked together. This separate relationship information thus serves as a blueprint for linking together separate objects in the job information. Among other implementations the Extensible Markup Language XML or other markup language can be used in whole or in part to specify the elements in the hierarchies shown in and the relationships among these elements.

Specific examples of XML code that specify elements in the hierarchies shown in are illustrated in Tables I through IV below.

Table I illustrates an example of XML code that specifies a fixed document sequence node. Fixed document nodes are child nodes of a fixed document sequence node. These child nodes are referenced from the fixed document sequence node as spine references. Fixed document nodes are referenced using a element and a source attribute that specifies the URI of the fixed document part being referenced.

As seen in line 1 of the example XML of Table I the fixed document sequence node identifies a namespace that is used to specify the elements of the hierarchies shown in . Lines 2 and 3 each include a element that identifies a particular fixed document that is part of the fixed document sequence FixedDoc1 in line 2 and FixedDoc2 in line 3 .

Table II illustrates an example of XML code that specifies a fixed document node. The fixed document node identifies one or more fixed page nodes. The fixed document node can include one or more elements as well as one or more elements. The element logically binds an ordered sequence of pages together into a single multi page document.

The element is the child element of the element. Each element refers to the source of the content for a single page that is to a fixed page node . Each element may optionally include a height and width attribute reflecting the size of a single page. The required page size is specified in the fixed page part the optional size on is advisory only. The size attributes allow applications such as viewers to make visual layout estimates for content quickly without loading and parsing all of the individual fixed page parts.

As seen in line 1 of the example XML of Table II the fixed document node identifies a namespace that is used to specify the elements of the hierarchies shown in . Lines 2 7 each include a element that identifies a particular fixed page that is part of the fixed document e.g. FixedPage1 in line 2 FixedPage2 in line 3 and so forth .

Table III illustrates an example of XML code that specifies a fixed page node. Each fixed page node represents the content of a page in a element with and elements using the element to group them. The and elements are together the base for all marks rendered on a FixedPage. The element has a region and a fill. A path is described by specifying a Geometry.Data child element and the rendering attributes such as fill or opacity. The element is used to represent a run of text all from the same font. The element provides information for accurate rendering as well as supporting search and selection features in viewers.

The elements elements and elements include references to a brush or brush element. A brush can be used for example to paint the interior of geometric shapes defined by a element to fill the character outlines rendered with a element and to define the alpha transparency mask in opacity mask attributes. Examples of brush elements include a element an I element a element a element and a element.

The element fills defined geometric regions with a solid color. The element can include one or more of an opacity attribute a transform attribute and a color attribute. The opacity attribute specifies uniform transparency of the brush fill for example ranging from 0 fully transparent to 1 fully opaque . The transform attribute describes a matrix transform applied to the brush s coordinate space. The transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The color attribute specifies a color for filled elements such as an sRGB color value specified as 6 digit hexadecimal number or an sARGB color value specified as 8 digit hexadecimal number.

The element can have a transform element as a child The transform element specifies the transformation that is applied to the brush. This transformation is applied after the brush s output has been mapped and positioned.

The element can be used to fill a space with an image. The element can include one or more of an opacity attribute a transform attribute a view box attribute a view port attribute a stretch attribute a tile mode attribute a view box units attribute a view port units attribute and a bitmap source attribute. The opacity attribute specifies uniform transparency of the brush fill for example ranging from 0 fully transparent to 1 fully opaque . The transform attribute describes a matrix transform applied to the brush s coordinate space. The transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The view box attribute specifies a new coordinate system for the contents it redefines the extent and origin of the view port. The view box is expressed as a list of four unitless real numbers and separated by commas. The dimensions specified in the view box attribute are relative to the image s physical dimensions e.g. expressed in units of 1 96 of an inch . The image s physical dimensions are calculated by dividing the image s horizontal dimension in pixels by the horizontal image resolution and the image s vertical dimension in pixels by the vertical image resolution.

The view port attribute specifies a coordinate system in which to position contents. The view port is expressed as a list of four real numbers and separated by commas. The rectangle defined by the view port is specified in user coordinates and defines the brush tile that is repeatedly applied to fill a Path. The stretch attribute specifies how the contents of a view box are mapped to a view port. The tile mode attribute specifies how contents will be tiled in the filled region. The view box units attribute specifies the relation of view box coordinates to coordinates of the image as absolute. The view port units attribute specifies the relation of view port coordinates to current user coordinates as absolute. The bit map source attribute specifies the URI of an image resource that can be used as the image to fill the space.

The element can have a transform element as a child. The transform element describes a matrix transform applied to the brush s coordinate space. The Transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The view port for the brush is then transformed using that local effective render transform.

The element can be used to fill a space with a vector drawing. The drawing can be specified as a child element of the element or as a resource reference. The element can include one or more of an opacity attribute a transform attribute a view box attribute a view port attribute a stretch attribute a tile mode attribute a view box units attribute and a view port units attribute. These attributes are analogous to those discussed above with respect to the element.

The element can have a transform element and or a visual element as a child. The transform element describes a matrix transform applied to the brush s coordinate space. The Transform property on a brush is concatenated with the current effective render transform to yield an effective render transform local to the brush. The view port for the brush is then transformed using that local effective render transform. The visual element is a generic definition of an element that could be displayed on a surface.

The element can be used to fill a region with a linear gradient. The element can include one or more of an opacity attribute a transform attribute a color interpolation mode attribute a spread method attribute a mapping mode attribute a start point attribute and an end point attribute. The opacity attribute specifies uniform transparency of the linear gradient for example ranging from 0 fully transparent to 1 fully opaque . The transform attribute describes a matrix transform applied to the coordinate space of the linear gradient.

The color interpolation mode attribute specifies the gamma space for color interpolation for non extended sRGB colors. For extended colors only linear color interpolation no gamma is typically used. The spread method attribute specifies how the brush should fill the content area outside of the primary initial gradient area. The mapping mode attribute specifies an absolute interpretation of the coordinates specified by the start point and end point attributes. The start point attribute specifies a start point of the linear gradient. The end point attribute specifies the end point of the linear gradient. The linear gradient brush interpolates the colors from the start point to the end point e.g. where the start point represents offset 0 and the end point represents offset 1 . The offset attribute value specified in a gradient stop element relates to the offsets defined by the start point and the end point.

The element can have a gradient stops element as a child. The gradient stops element holds a sequence of gradient stop elements that are sorted in ascending order by an offset attribute value maintaining the relative order of GradientStops with the same Offset attribute value.

The element can be used to fill a region with a radial gradient. The element is similar to the element however whereas the linear gradient has a start and end point to define the gradient vector the radial gradient has an ellipse along with a gradient origin to define the gradient behavior. The ellipse defines the end point of the gradient in other words a gradient stop at 1.0 defines the color at the circumference of the ellipse. The gradient origin defines the center of the gradient. A gradient stop at 0.0 defines the color at the gradient origin.

The element can have can include one or more of an opacity attribute a transform attribute a color interpolation mode attribute a spread method attribute a mapping mode attribute a center attribute a gradient origin attribute a radius X attribute and a radius Y attribute. The opacity attribute specifies uniform transparency of the radial gradient for example ranging from 0 fully transparent to 1 fully opaque . The transform attribute describes a matrix transform applied to the coordinate space of the radial gradient.

The color interpolation mode attribute specifies the gamma space for color interpolation for non extended sRGB colors. For extended colors only linear color interpolation no gamma is typically used. The spread method attribute specifies how the brush should fill the content area outside of the primary initial gradient area. The mapping mode attribute specifies an absolute interpretation of the coordinates specified by the center gradient origin radius X and radius Y attributes.

The center attribute specifies the center of the radial gradient e.g. the center of the ellipse . The radial gradient brush interpolates the colors from the gradient origin to the circumference of the ellipse. The circumference is determined by the center and the radii. The gradient origin attribute specifies the origin point of the radial gradient. The radius X attribute specifies the radius in the X dimension of the ellipse which defines the radial gradient. The radius Y attribute specifies the radius in the Y dimension of the ellipse which defines the radial gradient.

The element can have a gradient stops element as a child. The gradient stops element holds a sequence of gradient stop elements that indicate a location and range of color progression for rendering a gradient.

The element is used to group elements together. Typically elements of a fixed page node are grouped together in a element when they share a composed common attribute e.g. opacity clip render transform opacity mask etc. . By grouping these elements together in a element common attributes can often be applied to the canvas instead of to the individual elements.

The element can include one or more of a render transform attribute a clip attribute an opacity attribute an opacity mask attribute an ID attribute and a navigate URI attribute. The render transform attribute specifies a new coordinate frame for the child elements of the element such as another element. The clip attribute specifies the region to which a brush can be applied by the child elements of the element. The opacity attribute specifies uniform transparency of the canvas for example ranging from 0 fully transparent to 1 fully opaque .

The opacity mask attribute specifies a mask of alpha values that is applied in the same fashion as the opacity attribute but allows different alpha value on a pixel by pixel basis. The ID attribute contains a string value that is used to identify the current element as a named addressable point in the document for purposes of hyperlinking into the current document. The navigate URI attribute is used to associate a hyperlink URI with the element. This may be a relative or absolute URI addressing a resource external to the package or internal to the package.

The element can have a resources element a render transform element a clip element and or an opacity mask element as a child children . The resources element specifies one or more resources for the element. The render transform element establishes a new coordinate frame for the children elements of the element. The clip element describes the region to which a brush can be applied by the children elements of the element. The opacity mask element specifies a mask of alpha value that is applied in the same fashion as the opacity attribute but allow different alpha values on a pixel by pixel basis.

The element can include one or more of a data attribute a fill attribute a fill rule attribute a render transform attribute a pen attribute a clip attribute an opacity attribute an opacity mask attribute an ID attribute and a navigate URI attribute. The data attribute specifies the geometry of the path. The fill attribute specifies the brush used to paint the geometry of the path. The fill rule attribute specifies how intersecting areas of geometric shapes are combined to form a region. The render transform attribute specifies a new coordinate frame for the children elements of the path such as the geometry defined by Path.Data.

The pen attribute specifies a Brush used to fill the pixels of the stroke. The clip attribute specifies the region to which a brush can be applied by the path s geometry. The opacity attribute specifies uniform transparency of the filled path for example ranging from 0 fully transparent to 1 fully opaque . The opacity mask attribute specifies a mask of alpha values that is applied to the glyphs in the same fashion as the opacity attribute but allows different alpha value for different areas of the surface. The ID attribute contains a string value that is used to identify the current element as a named addressable point in the document for purposes of hyperlinking into the current document. The navigate URI attribute is used to associate a hyperlink URI with the element. This may be a relative or absolute URI addressing a resource external to the package or internal to the package.

The element can have a render transform element a clip element an opacity mask element a fill element a stroke element and or a data element as a child children . The render transform element establishes a new coordinate frame for the children elements of the path such as the geometry defined by a data element. The clip element describes the region to which a brush can be applied by the path s geometry. The opacity mask element specifies a mask of alpha values that is applied in the same fashion as the opacity attribute but allow different alpha values on a pixel by pixel basis. The fill element describes the brush used to paint the path s geometry. The stroke element specifies a brush used to fill the pixels of the stroke. The data element describes the path s geometry.

The element can include one or more of a bidi level attribute a caret stops attribute a device font ID attribute a fill attribute a font rendering size attribute a font URI attribute an origin X attribute an origin Y attribute a sideways attribute an indices attribute a Unicode string attribute a style simulations attribute a render transform attribute a clip attribute an opacity attribute an opacity mask attribute an ID attribute and a navigate URI attribute. The bidi level attribute specifies the Unicode algorithm bidirectional nesting level where numerically even values imply left to right layout numerically odd values imply right to left layout. The caret stops attribute specifies the positions within the sequence of UnicodeString characters at which a text selection tool may place a text editing caret. The device font ID attribute specifies an identifier e.g. a globally unique ID or GUID for a specific device font. The fill attribute specifies the brush used to paint the glyph outlines. The font rendering size attribute specifies the font size in drawing surface units e.g. 1 96 of an inch .

The font URI attribute specifies the physical font from which all glyphs in this run are drawn. The origin X attribute specifies the X coordinate of first glyph in the run e.g. in 1 96 of an inch . The origin Y attribute specifies the Y coordinate of first glyph in run e.g. in 1 96 of an inch . The sideways attribute is a flag specifying whether a glyph is turned on its side. The indices attribute specifies a series of glyph indices and their attributes representing this glyph run.

The Unicode string attribute specifies an array of characters represented by this glyph run. The style simulations attribute specifies the style simulation e.g. italic bold bold italic etc. . The render transform attribute specifies a new coordinate frame for the glyph run specified by the element. The clip attribute specifies the region to which a brush can be applied to the outline of a glyph. The opacity attribute specifies uniform transparency of the filled glyph outlines for example ranging from 0 fully transparent to 1 fully opaque . The opacity mask attribute specifies a mask of alpha values that is applied to the glyphs in the same fashion as the opacity attribute but allows different alpha value for different areas of the surface. The ID attribute contains a string value that is used to identify the current element as a named addressable point in the document for purposes of hyperlinking into the current document. The navigate URI attribute is used to associate a hyperlink URI with the element. This may be a relative or absolute URI addressing a resource external to the package or internal to the package.

A fixed page node includes height and width attributes specifying the height and width of the page e.g. in 1 96 of an inch as well as an xml lang attribute specifying the language of the page e.g. English French Japanese etc. . A fixed page node may also reference one or more resources. A fixed page node may also optionally include a content box attribute a bleed box attribute and or a render transform attribute. A content box attribute specifies which area of the page contains imageable content that is to be fit on the imageable area when printing or viewing the page. A bleed box attribute specifies the area which includes printing related crop marks that may be outside of the physical page. A render transform attribute specifies a new coordinate frame for the children of the fixed page node.

The element can have a render transform element a clip element an opacity mask element and or a fill element as a child children . The render transform element establishes a new coordinate frame for the glyph run specified by the element. The clip element describes the region to which a brush can be applied to the outline of a glyph. Only portions of the element that fall within the clip region even partially clipped characters produce marks on the page. The opacity mask element specifies a mask of alpha values that is applied to the glyphs in the same fashion as the opacity attribute but allows different alpha values for the different areas of the surface. The fill element describes the brush used to paint the glyph outlines.

As seen in line 1 of the example XML of Table III the fixed page node identifies a height and width of the page a background for the page e.g. background color and or pattern as well as the namespace that is used to specify the elements of the hierarchies shown in . In lines 2 27 various different brushes are defined. In line 28 which is actually multiple lines various glyphs paths and canvas elements are defined.

Table IV illustrates an example of XML code that specifies a print ticket node. Various different parameters can be included in a print ticket node to specify how the associated node e.g. fixed document node fixed page node etc. is to be processed. Examples of these are illustrated in the example XML code of Table IV.

As seen in line 1 of the example XML of Table IV the print ticket node identifies a version of XML and a data encoding format used by the print ticket node. Line 2 identifies the namespaces that are used to specify the elements of the hierarchies shown in . Lines 4 6 identify a job collate feature indicating that the pages being printed should be collated. Lines 7 9 identify an output color feature indicating that the pages should be printed in monochrome. Lines 10 12 identify a page orientation feature indicating that the pages should be printed in portrait mode. Lines 13 22 identify a media size feature indicating the size of the media on which the pages will be printed.

As noted above the nodes shown in are logical entities. Mapping rules define how the logical nodes map to parts of actual physical storage e.g. in spool storage . A logical package may be physically embodied by a collection of loose files a .ZIP file archive a compound file or some other format. In one case some of the nodes directly correspond in one to one fashion to parts e.g. files stored in the spool storage such as pages image resources font resources etc. Other nodes may not map in one to one fashion to actual parts of the spool storage .

The second series of entries includes separate folders for font resources image resources other resources etc. As the resources are associated with the root node the resources folder is in the SampleSpoolFile folder. The image folder is expanded to show an exemplary series of seven .jpg image files. These image files define shared image resources that can be referenced by any page related node in the package. For example the metadata information stored in the files can make reference to these resources effectively linking specific nodes to specific resources.

Whatever the form of the physical media and file structure information can be stored on this media in simple direct ordered fashion in interleaved fashion or some other fashion. Information can be retrieved from this physical media in sequential mode or random access mode or some other mode.

The procedure includes generating the job information having the structure act . To perform this task the application module can generate job data and the APIs and possibly the spooling module can produce the job information having the format . This generated job information having the format is stored in the spool storage act .

The job information is subsequently retrieved from the spool storage and consuming this job information using the spooling module act . Such consumption may entail applying different combinations of processing operations provided by individual filters . . . . Any such processing of job information is represented generally by act . The processing may entail converting the job information having the structure to processed job information that still maintains the structure . This output result would be appropriate to send to the structure aware target entity which can interpret this structure . The processing may alternatively entail converting the job information having the structure into job information that no longer has any semblance to the structure . This output result would be appropriate to send to the structure unaware target entity . Or the processing may entail converting the job information having the structure to processed job information that has some vestiges of the structure but which deviates from the structure in one or more respects. This output result would be appropriate to send to the partially structure aware target entity .

Whatever the case upon receipt of the job information the target entities . . . can perform prescribed processing on the job information such as by printing it displaying it archiving it etc.

In one exemplary implementation the application module APIs and spooling module can be implemented by software executed by a computing device. In this case provides information regarding an exemplary computer environment that can be used to implement this functionality. For a target entity that is implemented by a computing mechanism as well such a computing mechanism can also be implemented using the type of computing environment shown in or using a related environment.

The computing environment includes a general purpose type computer and a display device . However the computing environment can include other kinds of computing equipment. For example although not shown the computer environment can include hand held or laptop devices set top boxes mainframe computers etc. Further shows elements of the computer environment grouped together to facilitate discussion. However the computing environment can employ a distributed processing configuration. In a distributed computing environment computing resources can be physically dispersed throughout the environment.

Exemplary computer includes one or more processors or processing units a system memory and a bus . The bus connects various system components together. For instance the bus connects the processor to the system memory . The bus can be implemented using any kind of bus structure or combination of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures.

Computer can also include a variety of computer readable media including a variety of types of volatile and non volatile media each of which can be removable or non removable. For example system memory includes computer readable media in the form of volatile memory such as random access memory RAM and non volatile memory such as read only memory ROM . ROM includes an input output system BIOS that contains the basic routines that help to transfer information between elements within computer such as during start up. RAM typically contains data and or program modules in a form that can be quickly accessed by processing unit .

Other kinds of computer storage media include a hard disk drive for reading from and writing to a non removable non volatile magnetic media a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from and or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are each connected to the system bus by one or more data media interfaces . Alternatively the hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by a SCSI interface not shown or other coupling mechanism. Although not shown the computer can include other types of computer readable media such as magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage electrically erasable programmable read only memory EEPROM etc.

Generally the above identified computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for use by computer . For instance the readable media can store the operating system application modules e.g. for implementing the application module other program modules and program data . The computer readable media can also store although not shown logic for implementing the APIs and spooling module . Any of the above described storage media can be used to implement the spool storage such as hard disk .

The computer environment can include a variety of input devices. For instance the computer environment includes the keyboard and a pointing device e.g. a mouse for entering commands and information into computer . The computer environment can include other input devices not illustrated such as a microphone joystick game pad satellite dish serial port scanner card reading devices digital or video camera etc. Input output interfaces couple the input devices to the processing unit . More generally input devices can be coupled to the computer through any kind of interface and bus structures such as a parallel port serial port game port universal serial bus USB port etc.

The computer environment also includes the display device . A video adapter couples the display device to the bus . In addition to the display device the computer environment can include other output peripheral devices such as speakers not shown a printer not shown etc. Any of these units can constitute the target entities . . . shown in .

Computer operates in a networked environment using logical connections to one or more remote computers such as a remote computing device . The remote computing device can comprise any kind of computer equipment including a general purpose personal computer portable computer a server remote printer or archival device etc. Any of these units can also constitute the target entities . . . shown in . Remote computing device can include all of the features discussed above with respect to computer or some subset thereof.

Any type of network can be used to couple the computer with remote computing device such as a WAN a LAN etc. The computer couples to the network via network interface which can utilize broadband connectivity modem connectivity DSL connectivity or other connection strategy. Although not illustrated the computing environment can provide wireless communication functionality for connecting computer with remote computing device e.g. via modulated radio signals modulated infrared signals etc. .

In closing a number of examples were presented in this disclosure in the alternative e.g. case A or case B . In addition this disclosure encompasses those cases which combine alternatives in a single implementation e.g. case A and case B even though this disclosure may not have expressly mention these conjunctive cases in every instance.

More generally although the invention has been described in language specific to structural features and or methodological acts it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing the claimed invention.

