---

title: Standard graphics specification and data binding
abstract: A standard graphics specification for use by both developers of graphics files as well as of applications developed to execute in a runtime environment is disclosed. The graphics files are developed to conform to the graphics specification and therefore will be executable by applications in any runtime environment that likewise conform to the graphics specification. The specification includes program syntax standards and standards for metadata in the form of semantics and annotations that further describe the code. The specification additionally includes standards to which applications may conform to ensure that the applications will be capable of executing any graphics files that conform to the graphics specification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444583&OS=07444583&RS=07444583
owner: Microsoft Corporation
number: 07444583
owner_city: Redmond
owner_country: US
publication_date: 20050527
---
The invention generally relates to rendering graphic displays and specifically to standardizing graphics files and runtime environments to promote compatibility between the two.

A graphics application may be executed on a computer and may result in rendering a graphic display on a computer monitor or other display. The graphics application may include program code for various aspects related to the rendering. For example one part of the program code may be related to mesh another part may be related to lighting and another part may be related to texture. To render a graphic on a display the program code may be sent from a graphics file to a video card and may include a pixel vertex and other types of shader as well as values for the render state mesh lighting and texture which are consumed by the shaders. The graphics file thus includes a structure for setting the state of the video card and the code and data used for the rendering. The graphics file may include names for related portions of the section of data. For example one section may be WorldMatrix another lightArray and another color. 

Generally various graphics applications may perform similar functions when rendering an image. For example a vertex shader program may include data for a world matrix view matrix and projection matrix. A problem exists because there may be no standardization for the names of the various sections of data in the graphics file. For example graphics programmers may want to share graphics files but there may be no standard naming protocol to indicate to a programmer which data represents a world matrix which represents a view matrix and which represents a projection matrix. This is true of other aspects of rendering an image such as with texture lighting and color for example. An application may not be able to use a graphics file that was not specifically written for the application because the application may not be able to discern which values to set into what named section of the graphics file s data section.

Therefore there is a need for a standardization of graphics files and runtime environments such that a graphics file developed independent of and without regard to a particular runtime environment may be executed in that runtime environment without requiring modification or study.

The invention includes using a standard graphics specification based on communication through metadata in the development of both graphics files made to execute in a runtime environment and an application as a hosting environment. The graphics files may be developed independent of any application and naming convention and then marked up with metadata to conform to the graphics specification and therefore will be executable by applications with runtime environments that likewise conform to the graphics specification. The specification may establish metadata syntax standards that further describe the code. The specification additionally may provide standards to which applications may conform to ensure that the applications will be capable of executing any graphics files that conform to the graphics specification.

The standard graphics specification may additionally include a data binding regime to enable a graphics file that is compliant with the graphics specification to bind parameters of a shader to values provided by an application without user intervention. The graphics file requests metadata values by supplying a virtual address path. The application may obtain virtual address paths of the requested values from the graphics files and may map the virtual address paths to actual address paths for retrieval of the appropriate values. The conversion of virtual to actual address paths can be assigned reasonable defaults or be user assisted. Virtualization of bind addresses in a graphics file may occur but is not limited to the instantiation duplication instancing referencing or other methods of reuse of the graphics file.

While a general purpose computer is described below this is merely one example. The present invention also may be operable on a thin client having network server interoperability and interaction. Thus an example embodiment of the invention may be implemented in an environment of networked hosted services in which very little or minimal client resources are implicated e.g. a networked environment in which the client device serves merely as a browser or interface to the World Wide Web.

Although not required the invention can be implemented via an application programming interface API for use by a developer or tester and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers e.g. client workstations servers or other devices . Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. An embodiment of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an example system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a central processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to random access memory RAM read only memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology compact disc read only memory CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as ROM and RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data . RAM may contain other data and or program modules.

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the example operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

A computer or other client device can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. An embodiment of the present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

The first entity may be for example a graphics developer or a game developer that develops a graphics file . The graphics file may be any file including information that when executed provides or facilitates rendering a primitive or other graphic on a display associated with a runtime environment. The graphics file may include for example a pixel shader and or a vertex shader. A pixel shader refers to program code that when executed such as by a graphics processor processes pixels for rendering. The graphics processor for example may execute a pixel shader applying information to pixels on a per pixel basis in preparation for rendering on a display. A vertex shader refers to program code that when executed manipulates vertex data values typically in three dimensional space. The vertex data may include information associated with color texture coordinates orientations in space point size or other data specific to its calculation.

The graphics file may include semantics annotations and other code and data written consistent with a standard graphics specification. The code and data may include parameters or other information for execution of the graphics file . The parameters may include pieces of code and data necessary for executing for example the pixel or vertex shader of the graphics file . The parameters thus represent various attributes of the graphics file .

The term semantic refers to metadata that may be a connection or tag for parameter information in a graphics file. Semantics may be placed on parameters such that they are invisible to a graphics file but visible to an application executing the graphics file. The term annotation refers to metadata that includes information providing named data to applications or program code that set and use parameters of the graphics file . Thus semantics and annotations provide a metadata facility for a graphics file so that an author may advertise the intent or grammar of a parameter to an application attempting to provide a value for the parameter though the semantics and annotations are not restricted solely to this use. Other metadata mechanism may exist beyond these definitions of annotations and semantics. Though this invention describes an implementation built upon semantics and annotations it may be applied to any metadata system. The standard graphics specification may establish the syntax for the semantics and annotations such that a runtime environment for example that uses the standard graphics specification will understand the program code.

The graphics file may be developed by the first entity and the first entity may intend that the graphics file be used in a runtime environment by some other entity such as the third entity . The first entity however may have no information regarding the runtime environment of the third entity . Instead the first entity includes the semantics and the annotations along with the code and data and knows that if the third entity likewise implements a runtime environment that recognizes the semantics and annotations then the graphics file may execute the code and fill the data appropriately at the computer of the third entity . Thus the semantics and annotations are standardized and known by both the first entity in developing the graphics file and by the third entity who is implementing a runtime environment on the computer . Therefore while the first entity may not know at the time of creating the graphics file where the graphics file will end up the first entity knows that any runtime environment that uses the standard graphics specification and thus knows the meaning of the semantics and annotations will be able to execute the graphics file and manipulate the code and data within the graphics file .

The second entity likewise may be a graphics or game developer and may develop a graphics file . The graphics file may include semantics annotations and code and data as described above with regard to the graphics file . The second entity may be independent of the first entity and indeed may not even know of the existence of the first entity . Likewise the second entity may not know the identity or existence of the third entity . The second entity however may include in the graphics file the semantics and annotations that are recognized by the first and second applications of the third entity . The second entity may be assured that some runtime environment will be able to execute the graphics file because the graphics file was developed using the standard graphics specification and thus the semantics and annotations will be recognized by runtime environments.

The semantics and annotations of the graphics file may be substantially the same as the semantics and annotations of the graphics file because both files may have been developed using the standard graphics specification for such semantics and annotations . The runtime environment of the computer likewise may recognize the semantics and annotations because it too may implement the standard graphics specification.

The third entity may be any end user or other entity implementing the graphics file or the graphics file . The third entity may include the computer . The computer may include a central processing unit a first application a second application and a graphics processor . The graphics processor may be implemented using a video card or by any other appropriate means or method. The first and second applications may be any application program or program code that uses or can execute or cause to be executed a graphics file such as the graphics files or . The third entity computer or first application may obtain and execute the graphics file . The computer or the first application may cause the graphics file to be executed such execution being accomplished in part because the computer or the first application is versed in the semantics and annotations of the graphics file . That is the runtime environment of the computer was developed using in part the standard graphics specification and thus understands the semantics and annotations of the graphics file .

Likewise the computer or the second application may cause the graphics file to be executed such execution being accomplished in part because the computer or the second application was developed using in part the standard graphics specification. That is the runtime environment of the computer understands the graphics file because it understands the semantics and annotations . Thus the computer may be capable of executing the graphics files or any other graphics files that likewise conform to the standard graphics specification.

The computer or the first or second applications may understand the semantics and annotations because the standard graphics specification establishes and defines expected behavior of the applications . For example the first and or second applications may be capable of supplying the application values. The application values may be made available to the respective graphics files so that the graphics files may leverage them at runtime. Thus the standard graphics specification used by the first and second entities to develop the graphics files with semantics and annotations may also be used by the third entity the computer or the first or second applications to use the appropriate application values compatible with the graphics files .

The applications may be considered host applications in that each is executed on a host such as for example the computer described with regard to . Each of the applications may use any graphics file that is compliant with the standard graphics specification. For example an application for shader authoring tools may implement the graphics file so that authors can create specification compliant graphics for use in a game. Such shader authoring tools include for example and not by way of limitation FX Composer produced by NVIDIA Inc. of Santa Clara Calif. RenderMonkey produced by ATI Technologies Inc. of Santa Clara Calif. RT shader produced by RTzen Inc. of Bellevue Wash. or ShaderWorks produced by Mad Software Inc.

An application for content creation tools may implement the graphics file so that for example users can assign graphics as materials on objects in a scene and obtain reasonable behavior. Such content creation tools include for example and not by way of limitation 3DS max produced by Autodesk Inc. of San Francisco Calif. Maya produced by Alias Systems Corp. of Toronto Canada Photoshop produced by Adobe Systems Inc. of San Jose Calif. and XSI produced by Softimage Co. of Montreal Canada. Finally game engines may implement the standard graphics specification so that non programmers can plug the graphics file into a game without a software programmer or more expert intervention. A game engine may include any third party render engines. Thus the standard graphics specification may be implemented by both graphics file developers and application developers such that each may develop their own environment graphics file or host runtime environment with an assurance of compatibility to render graphic displays. The standard graphics specification may be viewed for example as a quasi contract between host applications and the graphics file by providing common term definitions and defining interconnections. The contract being that if the host applications implement the standard graphics specification then each will be capable of understanding and executing a graphics file that also conforms to the specification and vice versa.

In conforming with the standard graphics specification the graphics application may expose a user interface for receiving values from a user when for example a rendering will be completed involving the specification compliant graphics file with specification compliant metadata the requests user interface controls. That is the graphics file may expose through the application certain metadata to the user of the host application enabling the user to provide values for the parameters. The user may therefore be able to specify for example the color or shininess of an object to be rendered during execution of the graphics file . Because the host application and the graphics file are compliant with the standard graphics specification the graphics application knows how to expose the user interface and to provide values to the parameters established in the graphics file .

The graphics file may include metadata associated with graphics file parameter color . For example when the graphics application reads the graphics file the graphics application finds UI metadata in the graphics file which indicates to the graphics application to query the user for a value for the graphics file parameter color . The graphics application understands the UI metadata from the graphics file exposes a user interface consistent with the metadata and receives an edited value from the user for the color. The value is set into the graphics file s parameter which was marked with the UI metadata .

The standard graphics specification thus may define a set of metadata that allow graphics files such as the graphics file to declare a user interface that host applications such as the specification compliant host application can expose.

The standard graphics specification may include a standard method of binding parameter values supplied by the graphics application with parameters specified by the graphics file . For example a shader may need to perform a calculation on a camera position. The author of the shader may use standardize metadata from the standard graphics specification to indicate to the graphics application to provide information related to the camera position. Thus the graphics file may be provided with parameter values from the graphics application . Metadata may be placed on the graphics file parameters such that they are invisible to the graphics file but visible to the graphics application executing the graphics file . Additionally this data binding may be accomplished without user intervention though user intervention may also be uses to change values from their reasonable defaults.

Graphics data binding may be factored into three components First host application values that the specification compliant graphics file can use second bound parameters that make use of host application values e.g. parameter values and third specification compliant graphics file parameter metadata that may control for example the casting and coercion of values being transferred from a host environment to bound parameters.

The host application values may include a collection of application values as well as their type and structure exposed to the standard graphics specification compliant graphics files . The host application values collection may be addressed and virtualize using a predefined graphics file syntax. The following are example values collections provided for explanatory purposes only and do not in any way limit the scope of the present invention.

For example the host application values may include providing access to a host application s virtual clock or time value as follows 

The value of Now above may be the value of the host applications virtual clock at the point at which the graphics file will be rendered. The value of Last may be the value of Now at the previous render. The value of FrameNumber may be a counter value that is incremented once per rendered frame.

The host application values may additionally provide for example access to a cubic environment map as follows 

The host application values may provide access to a camera currently being rendered. Thus the specification may define a camera as follows 

Additionally the host application values may provide access to lights in the environment. Thus the standard graphics specification may define a light as follows 

The Color Position and Direction values may have their intuitive meaning. The Range value may be the distance at which the light has zero effect on the scene. The Theta and Phi values represent the inner and outer cone angles of the spotlight measured in radians.

The value of various Num Lights values i.e. NumAmbientLights etc. . . . may be set to the number of lights bound into the associated Light array. Note that because the graphics file can choose to ignore the Num Lights value and instead bind to any element of one of the light arrays the host application may provide a valid binding for elements beyond the number of lights in the array using the default values defined above .

The above are just some examples of host application values that standard graphics specification compliant graphics files may use. The examples are shown for example purposes and there may be other values such as pertaining to shadows or skeleton for example.

In addition to host application values data binding may include bound parameters that make use of host application values . A specification bind address metadata may be an expression that specifies the member or members of the host application values collection to which the associated parameter may be bound. Parameters that have an associated specification bind address annotation may be classified as bound parameters. The syntax of the specification bind address expression may be defined by a grammar. The following is one example of such a string based grammar and is provided for explanation purposes only. There may be other grammars as well.

The index token may denote that all elements of the particular host application values array may be returned in the return set. Multiple index tokens may be valid in the same bind expression and may allow graphics files to bind to sub elements of an array of structures without the need to bind the entire structure itself. For example the following binding expression may bind color values of a first six lights to a graphics file parameter.

If the host application cannot resolve the value of a bind address to a valid value in the specification host application values may instead ignore the existence of that bind address . The host application may additionally resolve the value of a bind address that failed to resolve to a bind address within the specification to a non specification bind address. This behavior may enable authors to create graphics files that bind to extended specification host application values while providing meaningful fallback user interface through the user interface related annotations . Additionally if the host application extends the set of values exposed to the graphics file it may add a top level namespace hence the Id in the Namespace production above and may not be able to augment any other portion of the specification host application values collection.

A third component of specification data binding involving transferring values between the specification host application values and a bound parameter are rules by which values may be manipulated during the assignment of the value into the bound parameter. The host application may guarantee that the values of graphics file parameters with valid specification bind address annotations i.e. all bound parameters are updated before the host application invokes any rendering via the specification compliant graphics file .

Because the type of the specification host application values and the bound parameter type might not be the same the standard graphics specification may appropriately define how values are coerced between different types. The specification may support a selection of data modifiers that can affect the value being transferred from the specification host application values to a bound parameter.

The method may commence at step with execution of a graphics file by a graphics application. Both the graphics file and the application may conform to a standard graphics specification. At step the graphics application may be requested to provide a value. For example the application may be requested to provide a value for LightColor as follows 

Thus the application may be requested to provide a value at the address representing the color of a light called PointLight 0 . The application may know the virtual address of a value representing a color of the PointLight PointLight 0 .Color. At step the application may provide the value at the virtual address. As a plurality of values may reside in a virtual address the graphics application may be requested to provide the actual address associated with the virtual address from a given graphics file to retrieve the value at step . The graphics file may be any representation of a file in a runtime environment. For example the graphics file may be an instantiation duplication reference instance or some other representation created from another method of reuse. Of course the application may alternatively provide a default value representing the color of the PointLight PointLight 0 . At step the value may be retrieved from the actual address and at step the value may be stored in the parameter with the bind address in the graphics file. In the above example the value may be bound to the bind address called Specification.PointLight 0 .Color. Thus the graphics application may provide the requested value for the graphics file without user intervention though user intervention or smart application code may also be used to change values from their reasonable defaults and cause multiple actual addresses per virtual address.

The methods of the present invention may be implemented in hardware software or where appropriate a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions and data embodied in computer readable medium. A processor that executes program code for performing the steps of the methods of the invention as described in and as claimed constitute a computer system that embodies the present invention. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the present invention has been described in connection with the specific examples in conjunction with the various figures it is to be understood that other embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. The examples are offered in explanation of the invention and are in no way intended to limit the scope of the invention as defined in the claims. In summary in no way is the present invention limited to the examples provided and described herein. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

