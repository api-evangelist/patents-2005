---

title: System and methodology providing secure workspace environment
abstract: System and methodology providing a secure workspace environment is described. In one embodiment, for example, in a computer system, a method is described for creating a secured workspace within an existing operating system for allowing users to run applications in a secured manner, the method comprises steps of: creating a policy for configuring the secured workspace, the policy specifying how information created during operation of the applications may be accessed; hooking particular functions of the operating system in order to obtain control over the information created during operation of the applications; during operation of the applications, encrypting the information to prevent unauthorized access; in response to a request for access to the information, determining whether the request complies with the policy; and if the request complies with the policy, satisfying the request by providing access to a decrypted copy of the information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07725737&OS=07725737&RS=07725737
owner: Check Point Software Technologies, Inc.
number: 07725737
owner_city: Redwood City
owner_country: US
publication_date: 20051014
---
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

Computer Program Listing Appendix under Sec. 1.52 e This application includes a transmittal under 37 C.F.R. Sec. 1.52 e of a Computer Program Listing Appendix. The Appendix which comprises text file s that are IBM PC machine and Microsoft Windows Operating System compatible includes the below listed file s . All of the material disclosed in the Computer Program Listing Appendix can be found at the U.S. Patent and Trademark Office archives and is hereby incorporated by reference into the present application.

Object Description SourceCode.txt size 269762 Bytes created Sep. 13 2005 11 28 32 AM Object ID File No. 1 Object Contents Source code.

The present invention relates generally to computers and data processing applications and more particularly to system and methodology providing a secure workspace environment.

Growth of Internet based remote access technologies has lead to an increasing number of users working in unprotected or untrusted environments. Home users connect to their corporate networks via different VPN clients. People on vacations check their emails via public kiosks. Sales agents connect to their databases via wireless services in airports. Large networks now are not just broadband lines that connect offices in several states or countries they are far more complicated and far less controlled at the end points e.g. at individual personal computers . As the number of mobile users grows the number of potential threats also grows. Potential threads include but are not limited to phishing attacks identity theft trade secrets theft and the like.

A network of the typical large organization can be protected with various tools. For example a firewall is installed to protect a company s gateway. Anti virus software is installed on the company s mail server to scan incoming and outgoing email. Anti virus software can be also installed on individual end user computers. For remote users SSL VPN or IPSEC VPN is available to connect to the company s network from remote sites. For managing these environments IT departments typically develop and deploy a set of security rules security policy to endpoints. Notwithstanding the availability of these foregoing tools corporate IT departments still face a complex problem how to ensure confidentiality of the sessions when users connect to their corporate networks from untrusted end points end points that cannot be controlled by IT departments.

Consider VPN for instance. Existing VPN solutions provide a mechanism to encrypt the traffic between a given end point and corporate gateway. However these schemes can be easily broken on the end point thus providing the attacker with access to the end point computer before during or after the session. For example the attacker can install keyboard monitoring keylogger software and monitor all user activities. The attacker is then able to spoof the user s credentials user name and password . Also the attacker may analyze the cache of the user s web browser and thus retrieve information about what sites were visited by the user and reveal all other session information. The attacker may also analyze the files that remain after the session is complete. For example the attacker may analyze files used by the user s computer operating system e.g. Microsoft Windows including analyzing the user s profile present in temporary folders. Similarly the attacker may analyze files used by various applications such as Microsoft Word Microsoft Excel and Adobe Acrobat files that were left by the user after the session completed. All told the basic problem that remains today is how to create a secure environment within untrusted end points such as web kiosks or home computers.

There have been some attempts to try to address this problem. For convenience they can be divided into several categories from an architectural and technological point of view 1 Policy enforcement 2 Virtual operating system OS and 3 Secure environment within existing OS. Each will be examined in greater detail.

Before the secure session between the end point and company gateway is established a small application let us call it the Enforcement Agent EA is downloaded to the end point computer. The EA can be implemented as an Active X component that can be launched by the Internet Explorer browser or it can be a java application or even a tiny executable e.g. downloaded to the user s computer . In operation the EA checks the endpoint computer for compliance with a policy. A typical policy can be for example include requirements that the end point requesting a session must have Windows XP or newer Microsoft Operating system installed must have ZoneAlarm firewall installed must have antivirus installed e.g. McAfee or Norton and must have no known malware installed. If the end point does not comply with these policy requirements the EA reports to the gateway that the given end point is not compliant and the user will not be able to login to the company s network. In such a case the user must install the requisite software or find another computer that meets the policy requirements.

A virtual OS operating system solution attempts to create a virtual more secure operating system inside an untrusted operating system on the end point. A typical solution would be to create a portable USB device with preinstalled and preconfigured Linux OS. Linux is booted from the USB device and all session data and temporary files are saved to the USB device. The preconfigured Linux USB device has all necessary software installed VPN client email client spreadsheet application and word processor for example.

The goal of this solution is to create a secure environment using the underlying operating system or an application. For example an Internet Explorer browser plug in so called BHO could conceivably be developed that is able to encrypt all Internet Explorer session data including cookie cache and temporary files. In this case when the user accesses web sites or web applications from such protected browser all session data is encrypted and not accessible to the attacker.

Each attempt described above provides a real world solution that poses serious barriers for the attacker and thus there are many commercial products that utilize these concepts. However each of the attempts while it provides a serious barrier for the attacker either can be bypassed or has serious drawbacks. For example although policy enforcement is a must have solution for every end point it is not sustainable to targeted attacks. An attacker can take popular keylogger software and modify it so that popular antivirus or antispyware products will not be able to detect it. Another significant drawback of policy enforcement is that it does not delete temporary session data that can be analyzed by the attacker afterwards.

The virtual OS solution is inconvenient at best as it does not give the user a chance to work with the applications that he or she normally works with Internet Explorer Microsoft Word Excel or Adobe Acrobat. As a result the solution incurs a significant learning curve for the user and an increased amount of troubleshooting and support for IT departments. Furthermore the physical requirements of the approach are problematic. Not all kiosks will allow access to plug in USB devices or boot from them.

Currently all existing prior art solutions for providing a secure environment either can be easily bypassed or are oriented to provide only limited protection e.g. of certain application such as a plug in for Internet Explorer . Accordingly a better solution is sought.

System and methodology providing a secure workspace environment is described. In one embodiment for example in a computer system a method of the present invention is described for creating a secured workspace within an existing operating system for allowing users to run applications in a secured manner the method comprises steps of creating a policy for configuring the secured workspace the policy specifying how information created during operation of the applications may be accessed hooking particular functions of the operating system in order to obtain control over the information created during operation of the applications during operation of the applications encrypting the information to prevent unauthorized access in response to a request for access to the information determining whether the request complies with the policy and if the request complies with the policy satisfying the request by providing access to a decrypted copy of the information.

In another embodiment for example a computer system of the present invention providing a secured workspace for allowing users to run applications in a secured manner is described that comprises a computer running under control of an existing operating system a policy for configuring the secured workspace the policy specifying how information created during operation of the applications may be accessed a module for intercepting particular functions of the existing operating system in order to allow the secured workspace to run under the existing operating system the module permitting the secured workspace to obtain control over the information created during operation of the applications an encryption module for preventing unauthorized access to the information and a decryption module for providing authorized access to the information in response to receiving a request that complies with the policy.

In yet another embodiment for example a system of the present invention providing a secured desktop environment that allows users to run application software securely is described that comprises a computer running under an operating system the computer including application software for use by users and a secured desktop environment comprising a configurable policy specifying permitted operations of the application software and specifying permitted access to information created during operation of the application software a hooks engine for intercepting particular calls to the operating system thereby allowing the secured desktop environment to control operations of the application software and control access to information created during operation of the application software and a module operating in conjunction with the policy and the hooks engine for preventing any operation of the application software that is not permitted and or any access to the information that is not permitted.

In another embodiment for example a method of the present invention is described for securing software programs that run under control of a computer operating system the method comprises steps of defining a configurable security policy that specifies operations of the software programs that are permitted patching certain files of the computer operating system so that interactions between the software programs and the computer operating system may be monitored for compliance with the security policy and controlling operations of the software programs to prevent violation of the security policy.

In still another embodiment for example a system of the present invention for securing software programs that run under control of a computer operating system is described that comprises a configurable security policy that specifies operations of the software programs that are permitted means for patching certain files of the computer operating system so that interactions between the software programs and the computer operating system may be monitored for compliance with the security policy and means for controlling operations of the software programs to prevent violation of the security policy.

In another embodiment for example an improved desktop environment for use with an existing operating system is described wherein the improvement comprises a policy specifying behavior of computer programs that is permitted injectable program code that intercepts interactions between the computer programs and the existing operating system so that the computer programs may be monitored for compliance with the policy and wherein the desktop environment blocks any attempted behavior by the computer programs that would violate the policy.

The following definitions are offered for purposes of illustration not limitation in order to assist with understanding the discussion that follows.

Firewall A firewall is a set of related programs typically located at a network gateway server that protects the resources of a private network from other networks by controlling access into and out of the private network. The term also implies the security policy that is used with the programs. A firewall working closely with a router program examines each network packet to determine whether to forward it toward its destination. A firewall may also include or work with a proxy server that makes network requests on behalf of users. A firewall is often installed in a specially designated computer separate from the rest of the network so that no incoming request directly accesses private network resources.

HTTP HTTP is the acronym for HyperText Transfer Protocol which is the underlying communication protocol used by the World Wide Web on the Internet. HTTP defines how messages are formatted and transmitted and what actions Web servers and browsers should take in response to various commands. For example when a user enters a URL in his or her browser this actually sends a HTTP command to the Web server directing it to fetch and transmit the requested Web page. Further description of HTTP is available in RFC 2616 Hypertext Transfer Protocol HTTP 1.1 the disclosure of which is hereby incorporated by reference. RFC 2616 is available from the World Wide Web Consortium W3C and is available via the Internet e.g. currently at www.w3.org Protocols . Additional description of HTTP is available in the technical and trade literature see e.g. Stallings W. The Backbone of the Web BYTE October 1996 the disclosure of which is hereby incorporated by reference.

Network A network is a group of two or more systems linked together. There are many types of computer networks including local area networks LANs virtual private networks VPNs metropolitan area networks MANs campus area networks CANs and wide area networks WANs including the Internet. As used herein the term network refers broadly to any group of two or more computer systems or devices that are linked together from time to time or permanently .

Portal A portal provides an individualized or personalized view of multiple resources e.g. Web sites and services. A portal typically offers a single access point e.g. browser page providing access to a range of information and applications. A portal assembles information from a number of different sources e.g. Web sites and applications enabling a user to quickly receive information without having to navigate to a number of different Web sites. A portal also typically enables a user to obtain a personalized view of information and applications by organizing and grouping information and services for presentation to users.

TCP IP TCP IP stands for Transmission Control Protocol Internet Protocol the suite of communications protocols used to connect hosts on the Internet. TCP IP uses several protocols the two main ones being TCP and IP. TCP IP is built into the UNIX operating system and is used by the Internet making it the de facto standard for transmitting data over networks. For an introduction to TCP IP see e.g. RFC 1180 A TCP IP Tutorial the disclosure of which is hereby incorporated by reference. A copy of RFC 1180 is available via the Internet e.g. currently at www.ietf.org rfc rfc1180.txt .

Thread A thread refers to a single sequential flow of control within a program. Operating systems that support multi threading enable programmers to design programs whose threaded parts can execute concurrently. In some systems there is a one to one relationship between the task and the program but a multi threaded system allows a program to be divided into multiple tasks. Multi threaded programs may have several threads running through different code paths simultaneously.

URL URL is an abbreviation of Uniform Resource Locator the global address of documents and other resources on the World Wide Web. The first part of the address indicates what protocol to use and the second part specifies the IP address or the domain name where the resource is located.

Winsock Windows Sockets 2 Winsock is a Microsoft provided interface that enables programmers to create advanced Internet intranet and other network capable applications to transmit application data across the wire independent of the network protocol being used. With Winsock programmers are provided access to advanced Microsoft Windows networking capabilities such as multicast and Quality of Service QOS . Winsock follows the Windows Open System Architecture WOSA model it defines a standard service provider interface SPI between the application programming interface API with its exported functions and the protocol stacks. It uses the sockets paradigm that was first popularized by Berkeley Software Distribution BSD UNIX. It was later adapted for Windows in Windows Sockets 1.1 with which Windows Sockets 2 applications are backward compatible. Winsock programming was previously centered around TCP IP. Some programming practices that worked with TCP IP do not work with every protocol. As a result the Windows Sockets 2 API adds functions where necessary to handle several protocols. For further information regarding Winsock see e.g. Winsock Reference available from Microsoft Corporation the disclosure of which is hereby incorporated by reference. A copy of this documentation is available via the Internet e.g. currently at msdn.microsoft.com library default.asp url library en us winsock winsock winsock reference.asp .

XML XML stands for Extensible Markup Language a specification developed by the World Wide Web Consortium W3C . XML is a pared down version of the Standard Generalized Markup Language SGML a system for organizing and tagging elements of a document. XML is designed especially for Web documents. It allows designers to create their own customized tags enabling the definition transmission validation and interpretation of data between applications and between organizations. For further description of XML see e.g. Extensible Markup Language XML 1.0 2nd Edition Oct. 6 2000 a recommended specification from the W3C the disclosure of which is hereby incorporated by reference. A copy of this specification is available via the Internet e.g. currently at www.w3.org TR REC xml .

Referring to the figures exemplary embodiments of the invention will now be described. The following description will focus on the presently preferred embodiment of the present invention which is implemented in desktop and or server software e.g. driver application or the like operating in an Internet connected environment running under an operating system such as the Microsoft Windows operating system. The present invention however is not limited to any one particular application or any particular environment. Instead those skilled in the art will find that the system and methods of the present invention may be advantageously embodied on a variety of different platforms including Macintosh Linux Solaris UNIX FreeBSD and the like. Therefore the description of the exemplary embodiments that follows is for purposes of illustration and not limitation. The exemplary embodiments are primarily described with reference to block diagrams or flowcharts. As to the flowcharts each block within the flowcharts represents both a method step and an apparatus element for performing the method step. Depending upon the implementation the corresponding apparatus element may be configured in hardware software firmware or combinations thereof.

The present invention may be implemented on a conventional or general purpose computer system such as an IBM compatible personal computer PC or server computer. is a very general block diagram of a computer system e.g. an IBM compatible system in which software implemented processes of the present invention may be embodied. As shown system comprises a central processing unit s CPU or processor s coupled to a random access memory RAM a read only memory ROM a keyboard a printer a pointing device a display or video adapter connected to a display device a removable mass storage device e.g. floppy disk CD ROM CD R CD RW DVD or the like a fixed mass storage device e.g. hard disk a communication COMM port s or interface s a modem and a network interface card NIC or controller e.g. Ethernet . Although not shown separately a real time system clock is included with the system in a conventional manner.

CPU comprises a processor of the Intel Pentium family of microprocessors. However any other suitable processor may be utilized for implementing the present invention. The CPU communicates with other components of the system via a bi directional system bus including any necessary input output I O controller circuitry and other glue logic . The bus which includes address lines for addressing system memory provides data transfer between and among the various components. Description of Pentium class microprocessors and their instruction set bus architecture and control lines is available from Intel Corporation of Santa Clara Calif. Random access memory serves as the working memory for the CPU . In a typical configuration RAM of sixty four megabytes or more is employed. More or less memory may be used without departing from the scope of the present invention. The read only memory ROM contains the basic input output system code BIOS a set of low level routines in the ROM that application programs and the operating systems can use to interact with the hardware including reading characters from the keyboard outputting characters to printers and so forth.

Mass storage devices provide persistent storage on fixed and removable media such as magnetic optical or magnetic optical storage systems flash memory or any other available mass storage technology. The mass storage may be shared on a network or it may be a dedicated mass storage. As shown in fixed storage stores a body of program and data for directing operation of the computer system including an operating system user application programs driver and other support files as well as other data files of all sorts. Typically the fixed storage serves as the main hard disk for the system.

In basic operation program logic including that which implements methodology of the present invention described below is loaded from the removable storage or fixed storage into the main RAM memory for execution by the CPU . During operation of the program logic the system accepts user input from a keyboard and pointing device as well as speech based input from a voice recognition system not shown . The keyboard permits selection of application programs entry of keyboard based input or data and selection and manipulation of individual data objects displayed on the screen or display device . Likewise the pointing device such as a mouse track ball pen device or the like permits selection and manipulation of objects on the display device. In this manner these input devices support manual user input for any process running on the system.

The computer system displays text and or graphic images and other data on the display device . The video adapter which is interposed between the display and the system s bus drives the display device . The video adapter which includes video memory accessible to the CPU provides circuitry that converts pixel data stored in the video memory to a raster signal suitable for use by a cathode ray tube CRT raster or liquid crystal display LCD monitor. A hard copy of the displayed information or other information within the system may be obtained from the printer or other output device. Printer may include for instance an HP LaserJet printer available from Hewlett Packard of Palo Alto Calif. for creating hard copy images of output of the system.

The system itself communicates with other devices e.g. other computers via the network interface card NIC connected to a network e.g. Ethernet network Bluetooth wireless network or the like and or modem e.g. 56K baud ISDN DSL or cable modem examples of which are available from 3Com of Santa Clara Calif. The system may also communicate with local occasionally connected devices e.g. serial cable linked devices via the communication COMM interface which may include a RS 232 serial port a Universal Serial Bus USB interface or the like. Devices that will be commonly connected locally to the interface include laptop computers handheld organizers digital cameras and the like.

IBM compatible personal computers and server computers are available from a variety of vendors. Representative vendors include Dell Computers of Round Rock Tex. Hewlett Packard of Palo Alto Calif. and IBM of Armonk N.Y. Other suitable computers include Apple compatible computers e.g. Macintosh which are available from Apple Computer of Cupertino Calif. and Sun Solaris workstations which are available from Sun Microsystems of Mountain View Calif.

A software system is typically provided for controlling the operation of the computer system . The software system which is usually stored in system memory RAM and on fixed storage e.g. hard disk includes a kernel or operating system OS which manages low level aspects of computer operation including managing execution of processes memory allocation file input and output I O and device I O. The OS can be provided by a conventional operating system such as Microsoft Windows 9x Microsoft Windows NT Microsoft Windows 2000 Microsoft Windows XP or Microsoft Windows Vista all available from Microsoft Corporation of Redmond Wash. or an alternative operating system such as the previously mentioned operating systems. Typically the OS operates in conjunction with device drivers e.g. Winsock driver Windows implementation of a TCP IP stack and the system BIOS microcode i.e. ROM based microcode particularly when interfacing with peripheral devices. One or more application s such as client application software or programs i.e. set of processor executable instructions may also be provided for execution by the computer system . The application s or other software intended for use on the computer system may be loaded into memory from fixed storage or may be downloaded from an Internet location e.g. Web server . A graphical user interface GUI is generally provided for receiving user commands and data in a graphical e.g. point and click fashion. These inputs in turn may be acted upon by the computer system in accordance with instructions from OS and or application s . The graphical user interface also serves to display the results of operation from the OS and application s .

The above described computer hardware and software are presented for purposes of illustrating the basic underlying desktop and server computer components that may be employed for implementing the present invention. For purposes of discussion the following description will present examples in which it will be assumed that there exists at least one computer that communicates with other computers over a network such as one or more clients e.g. desktop computers that communicate with various servers e.g. Web servers over the Internet. The present invention however is not limited to any particular environment or device configuration. In particular a client server distinction is not necessary to the invention but is used to provide a framework for discussion. Instead the present invention may be implemented in any type of system architecture or processing environment capable of supporting the methodologies of the present invention presented in detail below.

In accordance with the present invention a fully secured environment is provided in the framework of the user s usual operating system host OS such as Microsoft Windows . The main Input Output I O functions of the host OS are hooked or intercepted so that all information including session information that applications save to disk is really stored in encrypted form to prevent unauthorized access. In this manner unauthorized or malicious users even those that have full access to the host OS are prevented from accessing the information or data created in the secured environment.

This process occurs in a fashion that is fully transparently for both applications and users. Applications think that they are working with usual OS functions and that they are storing information to usual storages. The user sees the secured environment as a virtual desktop a Secured Desktop. The user can easily switch between secured and not secured usual desktops for example by hotkeys or GUI elements. By intercepting all relevant OS functions the approach of the present invention can control all applications running on the Secured Desktop allowing or denying them the ability to do any specified action. This approach is used in conjunction with a configurable security policy that specifies behavior or actions of software programs that are or are not permitted. For example it is possible to specify what applications can be run on the virtual desktop at all. In this manner the present invention may prevent the launching of any noncompliant software i.e. computer programs that would violate the policy including banning malicious software e.g. spyware and computer viruses that can steal information or even damage the system.

In the currently preferred embodiment a Secure Workspace System SWS is provided that gives the user a secured area for web sessions with a clear visual separation from non secure areas. The workspace protects sensitive session information while a given session is active and performs total clean up after the session is finished. The workspace enables protection in user space mode without developing device drivers guest user rights are needed to run the Secure Workspace System . The workspace performs API hooking at the lowest possible level in the user space e.g. native Windows NT API NTDLL so that applications that work directly with this layer will not bypass the hooking mechanism.

The Secure Workspace System SWS works at the application level on the client side and prevents unauthorized access to a user s confidential information. The SWS creates a new secured virtual desktop which the user can work on and intercepts file registry operations for all applications started on this desktop. The system saves all sensitive user data on the user s local machine in encrypted form and deletes it when the session is terminated.

During operation the manager starts a usual Windows shell e.g. explorer.exe with an injection of the hooks engine cpsws.dll on the created desktop. The injected hooks engine in turn hooks process creation routines and automatically injects itself into all newly created processes. In this manner each application on the secure desktop receives a workspace hook . In the Microsoft Windows environment for example the injected DLL hooks API calls invocations by overwriting hooked NTDLL routines entry points with JMP instructions thus redirecting them to code inside the cpsws.dll. In this fashion the system can be assured that any kind of call to NTDLL API including from Win32 DLL and from the application itself with GetProcAddress or import table will be first intercepted by the SWS. This allows the SWS to control each application s interaction with the underlying operating system including the operating system s information storage e.g. Windows registry file system and Clipboard .

Access to different system resources are allowed or denied based on the policy cpsws.xml . The hooks engine allows applications started on the secure desktop to create files and registry keys only inside a secure user profile. These items will be encrypted on the host file system and will be deleted when the given session is terminated.

As illustrated in the diagram every loaded in process module including usual system modules such as kernel32.dll shell32.dll and the like even main application executable can communicate with the NT kernel via ntdll.dll calls. Use of the mechanism of ntdll.dll hooking allows maximum possible in user space control of all data flows between a given secured application and hardware persistent storage. In this manner the cpsws.dll can dispatch all files related functions including those used by the application. The cpsws.dll encrypts all data on the fly and stores it to the target persistent storage in encrypted form.

The cpsws.dll also controls creation of out of process COM objects. It does this by hooking the particular ole32.dll functions that are used for object creation. It intercepts creating out of process COM servers and creates their processes itself. Some user32.dll functions such as SetClipboardData and GetClipboardData also may be hooked to allow on the fly encryption of data copied to clipboard by secured applications. In the currently preferred embodiment additional kernel32.dll and shell32.dll functions are hooked to control process creation and file operations at a higher level. In this manner the SWS may for example show user alert messages about rejected operations including denied program startup denied saving files to non secured locations and the like.

 cookie server cookiename cookievalue secured cookie that will be inserted into each HTTP S request to the defined server and

 shell shell id shell identifier refers to corresponding tag in the secured workspace policy defines a shell that will be started on secure desktop explorer.exe by default .

The policy file cpsws.xml may now be loaded at step . At step the secure workspace manager cpsws.exe creates a pipe server that will listen and dispatch requests from injected applications. The pipe server uses a secure cookie as an authorization password on every client connect so only processes that started with the SWS s dll can use this pipe. Next at step the hooks engine cpsws.dll is loaded into the SWS this process is referred to herein as self injection. The hooks engine cpsws.dll hooks all necessary API for example for Windows ntdll.dll kernel32.dll ole32.dll user32.dll and the like and also injects itself into every child process that is created by an already injected process. This is illustrated at step .

As shown at step the method proceeds to create a virtual user profile according to the policy as follows 

At step the method creates a virtual desktop for example via Windows CreateDesktop WinAPI function. The method proceeds at step to create and initialize an empty Discretionary Access Control List DACL security descriptor and assign it to the new desktop. This disallows any other application from starting or installing input hooks on the secure desktop. Any additional initialization may now be performed e.g. get current wallpaper as indicated at step . The machine s shell e.g. explorer.exe is started on the created virtual desktop at step . Since injection occurred via the hooks engine cpsws.dll the shell explorer.exe will be injected by the hooks engine cpsws.dll on startup. This allows the system of the present invention to control applications that will be started on the virtual desktop. Finally at step the method switches operation of the machine to the just created desktop if all preceding operations have succeeded.

During processing of a Windows DllMain function i.e. the optional entry point into a Windows dynamic link library DLL the hooks engine cpsws.dll hooks to a list of functions of ntdll.dll kernel32.dll ole32.dll and user32.dll i.e. operating system applications programming interface API executable files . Then it waits while the parent process writes a secure cookie to its memory e.g. using WriteMemory API . This allows the system of the present invention to further distinguish pipe clients in the SWS.

The API hooks processing proceeds as follows. Every created thread of the already secured application is switched to the secure desktop. The desktop handle is retrieved from the hooks engine cpsws.dll using Windows DLL thread attachment program logic i.e. specifying the Windows DLL THREAD ATTACH flag . The process creation functions e.g. Windows CreateProcessW CreateProcessA functions are hooked to allow injection of cpsws.dll at the point when a new process is going to start. When such a new process has been created the hooks engine cpsws.dll writes a secure token to its memory. A child process may use this as an authorization password for the pipe server.

File functions are intercepted to allow virtualization and encryption of the file system as follows. When an application asks the system to create file the hooks engine cpsws.dll checks the file path in order to determine if creating a file in this directory is allowed by policy. If it is allowed the secure workspace manager cpsws.exe generates a random string that will correspond to requested file name thus allowing the file to be physically created with a secure name.

On write operation the hooks engine cpsws.dll checks the user s rights to change files in the given target directory according to the policy file. If sufficient rights exist the SWS encrypts all data on the fly and writes it to a real file in secure form. Additional information is written to file including for example encryption algorithm ID and real size of file recorded as housekeeping information for use with encryption algorithms that can encrypt data only by blocks with constant length . This additional data is not visible to the application but is instead used by the hooks engine cpsws.dll internally.

On read operation the hooks engine cpsws.dll reads information from the file header and reads a corresponding fragment of data from the file which can be larger than requests due to block encryption . The file information may now be decrypted and returned as decrypted data to the requesting application. In response to a files listing request the hooks engine cpsws.dll checks the user s rights to list the particular directory. If the user has sufficient rights the SWS reads corresponding information from the file headers and returns the real filename and size which recall was written as a field of the file header .

When an application creates a memory mapped section of a file the SWS creates a corresponding in memory section with size of file. The system may now read decrypted content of the file to this section and give the calling application caller a corresponding handle to this section. If an application specifies a section name in the call the hooks engine cpsws.dll can change the name to separate sections created on the respective secure and default desktops. Desired behavior is preferably configured in the policy file cpsws.xml . When an application calls usual ReadFile Windows API function to read data from a file or WriteFile Windows API function to write data to a file functions for files that are mapped to memory the SWS satisfies the calls with simple read write of data from section memory. When an application requests closing of the section data stored in the section is flushed to the corresponding file and the section is closed.

In response to a proper request the SWS of the present invention may be shutdown. Before closing it optionally queries all running applications for shutdown terminates all secured application s and then deletes all secured data from local storages to prevent information leaks and quits. Specific method steps for effecting de initialization are described in detail below. 

The underlying operating system OS may save memory pages of applications running on secure desktop into a global system swap file. The SWS itself does not presently solve this problem in the currently preferred embodiment. However the issue may be addressed by changes elsewhere. For example the swap file itself may be written to an OS supported volume encryption e.g. Microsoft Windows Vista Windows full volume encryption . Additionally in those deployments already employing large amounts of physical memory RAM the amount of data paged to disk for virtual memory management VMM may constitute a rather insignificant amount of application data. Further those skilled in the art will appreciate that the SWS may be designed to include kernel level logic to supplant the OS s native swap file with an encrypted one.

In the currently preferred embodiment the SWS does not encrypt registry entries created by applications on the secure desktop. These are deleted when a given session is terminated. However it is possible that during unexpected session termination sensitive data will be left in the current user file ntuser.dat . The issue may be addressed by encrypting registry items in the same way as files.

Content and names of files created on the secure desktop are encrypted on the host file system. However the corresponding encryption decryption key is stored in memory subject to swapping via the swap file similarly the directory structure is potentially visible outside the secure desktop. In embodiments contemplating use of electronic codebook ECB mode there is the potential disadvantage that identical plaintext blocks are encrypted to identical ciphertext blocks the approach does not hide data patterns. The issue may be addressed by using cipher block chaining CBC mode. In the cipher block chaining CBC mode each block of plaintext is XORed with the previous ciphertext block before being encrypted. This way each ciphertext block is dependent on all plaintext blocks up to that point. Further use of a fully virtual file system without correlation with host PC real file system provides additional protection.

Applications running on the secure desktop can exchange sensitive data through non controlled API with non secured applications on the default desktop e.g. non hooked out of process COM servers started by main system SVCHOST.EXE service . This issue may be addressed by hooking all API calls that can exchange sensitive information. In this manner the SWS does not allow applications that can leak information to be started on the secure desktop.

The following description presents method steps program logic that may be implemented using processor executable instructions for directing operation of a device under processor control. The processor executable instructions may be stored on a computer readable medium such as CD DVD flash memory or the like. The processor executable instructions may also be stored as a set of downloadable processor executable instructions for example for downloading and installation from an Internet location e.g. Web server .

The present invention includes an additional DLL loader that provides a mechanism to start new processes with forced loading of an additional DLL in the address space of the new process. This is done by creating a new process in suspended state allocating a small memory location in its address space and writing to it the code that loads the necessary DLL and that jumps to beginning of process execution code. The context of the main thread of the created process is then changed so that the computer processor s instruction pointer register e.g. Intel x86 Extended Instruction Pointer EIP register points to this created code. The thread is now resumed. After resuming the process thread executes code that loads the necessary DLL into the process space and continues usual processing of executable code. This may be implemented as follows e.g. illustrated by the following pseudocode snippets 

Of particular interest the AddAsmInstruction helper method call at line 30 serves to push a pointer to the DLL path name onto the current stack e.g. x86 stack . Now the helper method is again invoked at line 31 for purposes of calling the LoadLibrary Windows API call with the pushed parameter thereby forcing the loading of the DLL whose name is referenced at line 30 . Then at line 32 the helper method is invoked for purposes of effecting a jump JMP instruction back to the original process code.

The hooks engine provides a generic DLL that functions as an interception mechanism in its own processes. The basic approach is to overwrite part of the DLL code in memory so that a given target function instead calls wrapper code immediately upon execution. Here the start of the target DLL function is disassembled with its old original code being saved in a newly allocated memory block. The original site of this code is overwritten with a simple jump JMP instruction that calls the wrapper function. In this manner the wrapper function gains control and can process the API call itself or call the original DLL function with optionally changed input parameters. Core functionality of the hooks engine may be implemented as follows e.g. illustrated by the following pseudocode snippets 

As shown at line 18 the code performs a memory copy memcpy operation for overwriting the original code as described above. Unused byte locations are padded out with NOP no operation instructions e.g. 0x90 bytes as shown at line 19. At line 20 the AddAsmInstruction helper function is again invoked for generating a jump instruction to the other real function code and at line 22 the helper function is invoked for generating a jump to hook code at the beginning of the DLL exported function.

A file system processing engine of the present invention provides a mechanism for serving file system calls such as files and directories enumeration creating and deleting files and reading and writing file data. When a secured application tries to read or write a user s profile files it serves I O requests allowing on the fly encryption of file names and content. When the application tries to write to any restricted location e.g. specified in policy the engine prevents any unauthorized write or even access operations returning an Access Denied error in this manner the SWS ensures that no private data is left on the system after the SWS is closed down. File content encryption is designed for use with block ciphers in ECB mode with the option of including salt i.e. additional piece of information added to the hash that can be dependent of data offset. Private user s file names are similarly secured in a manner to allow both good security and fast accessing directories tree. When a given application creates a file which must be secured the engine parses the path splits it into corresponding names components and generates a random character string corresponding to real names . The file is physically stored by path which is combined from random names components. When the application opens this file or tries to enumerate names of the secured file the engine extracts the corresponding logical file names from an internal look up table that is stored only in memory.

Memory mapped file sections support can be considered as additional sub functionality of the file system processing engine. When an application tries to create a file section in a secured file the engine creates memory stored section with corresponding attributes and decrypts the file s content to it. If the application specifies a section name during creation or opens an existing section by name the engine can optionally change the section name to divide sections opened by applications on default and secured desktops. The particular section names that should be changed can be specified in policy. On every subsequent read write request of the file the engine performs simple copy of memory data from section memory to I O buffer. Flushing of the section to physical storage occurs on closing the file s handle. The below two pseudocode samples illustrate program logic implementing file processing features.

The first sample illustrates program code from a ZwCreateFile wrapper that changes file name or analyzes requested access rights 

A synchronization objects virtualization engine is provided that can optionally change names of named synchronization objects mutexes semaphores events and the like that are created by secured applications thus allowing independent applications to function on secure and default desktops. For example Adobe Acrobat Reader acrord32.exe creates certain named objects the existence of which it uses to whether an instance of the Reader is already running and thus a second instance should not be started . The specification of its names in the policy XML file makes possible to ensure acrord32.exe is the only running application instance in system.

A Registry processing engine is provided that allows flexible virtualization and protection of selected registry keys which can be customized in the policy . Write protection of selected keys is done by analyzing parameters of ZwCreateKey and ZwOpenKey routines and returning Access Denied status if any modification access is requested. Virtualization is done by creating an additional registry subkey HKCU CPSecured and changing all absolute paths requested by secured applications to really point to this key. Also a Copy On Access feature is provided to allow access to registry keys and values without noticeable delays for importing values from the original keys.

For example beginning with the program logic at line 6 the function checks whether protection is enabled for current application under consideration . At line 13 the TranslateHKEY routine is invoked to check whether the specified path belongs to HKCU HKEY CURRENT USER hive. If so the routine converts it to a virtual key path and returns true. If the path is read only HKLM HKEY LOCAL MACHINE path the routine returns false and the key path remains unchanged. At line 17 if the path points to a virtualized key then the original ZwCreateKey routine is called with the path relative to the HKCU CPSecured location . At line 25 if the path is read only and the application tries to get write access to this key the program logic returns Access Denied for denying access to the key . Line demonstrates a call to the original ZwCreateKey routine for providing read access.

OLE32 calls filtering is provided to intercept the OS COM server s creation requests. When an application asks OLE32 to create an out of process COM server the wrapper checks the COM server presence in the SWS. The path is extracted to an executable image of the COM server from the registry HKCR HKEY CLASSES ROOT hive. The server starts itself if the server was not already started before. Such an approach allows the starting of secured COM servers. The following program logic illustrates main aspects of this functionality 

The CheckIsServerStarted function checks whether the specified image process is already started in secured mode so that is not necessary to start it one more time . At line 14 a do while loop is established to prepare a full list of active secured processes. At line 26 a for loop compares the image path names of secured processes with the requested path. If the comparison finds a matching path the program logic returns true otherwise it returns false. If the server is already started tested at line 64 then the function does no additional work and simply returns true. Otherwise the function proceeds to start the COM server process with embedding parameter.

Exemplary ole32.dll wrappers that intercept attempts to create COM servers may be constructed as follows 

A Clipboard processing engine is provided to serve as a mechanism to intercept saving data to and retrieving data from the OS clipboard by secured application s thereby allowing on the fly encryption of private data stored to clipboard. In Windows OS for example this can be achieved by intercepting only three functions GetClipboardData SetClipboardData and CloseClipboard that are exported by Windows user32.dll. For example a GetClipboardData wrapper may be implemented as follows 

As shown this works in conjunction with a globalDecrypt function to decrypt The data for reconstituting the original Clipboard data. The globalDecrypt function itself may be constructed as follows 

A print interceptor engine is provided to hook the Windows StartDocW and StartDocA functions exported by gdi32.dll. These StartDoc functions start a print job in Windows. By intercepting these functions the SWS may deny any print operations. Additionally the feature can be configured by the policy file.

A process creation interceptor is also provided. When a secured application tries to create a new process it executes hooking engine code that hooks all necessary API calls of the created child process. It also writes some secure data secure token directly to memory of the created process that allows the SWS to further distinguish between a secured application and malicious applications which may try to use SWS functionality to access secured data . Sample pseudocode illustrating main features of process creation wrapper is as follows 

Importantly if the policy does not allow the executable then the function returns false at line 19. Otherwise the function will proceed to allow process creation at line 22 .

Encryption functionality implemented in the present invention is designed to be flexible and easy to configure. It allows for example the use of different cryptographic algorithms for encrypting objects of a given type. The particular encryption algorithm used is noted via a stored ID in the stored object via an opaque header. The header also stores other housekeeping information such as real data length. In the currently preferred embodiment encryption functionality is implemented using the following interface 

Every time engine functionality requests to encrypt or decrypt some blocks of data the engine creates an instance of implementation of the particular preferred crypto algorithm by giving the preferred algorithm ID to the encryption engine. If the engine detects that data is not encrypted yet it will proceed to use the specified algorithm. If data is already encrypted however the engine will use the algorithm ID that is specified in encrypted data header. The particular encryption key employed is currently randomly generated on session initialization.

A URL secure cookie injector is provided for injecting a variable count of secure cookies into HTTP requests. Thus the SWS can inject one or more additional secure cookies into every secured process using the Windows InternetSetCookie API function. The SWS also creates Mozilla Firefox profile files with secure cookies during initialization. HTTP URL and corresponding secure cookie data is given to the secure workspace manager cpsws.exe by the launcher as command line parameters. The manager cpsws.exe cleans up the command line after startup to prevent leaking of this information. This allows the corresponding HTTP server of the enterprise portal to distinguish HTTP requests from secured and unsecured applications e.g. using GWLIB API .

A configuration loader with storage class is provided that loads and analyzes the policy cpsws.xml file in which configuration and policy settings are stored. The loader provides an interface for other functionality parts to access their policies and configuration. It is possible to configure in the XML file what registry keys should be initialized and what values they should have for the SWS environment.

An inter process communication IPC channel is provided to serve as a generic mechanism for low level safe and secure communication between SWS functionality parts loaded into different processes. It is implemented as a pipe server that is started in the cpsws.exe core process on the early stage of initialization given pipe clients that connect to the server from cpsws.dll instances are loaded into secured applications. The server expects a secure token as the first data sent from a given client via pipe. If it receives any other data it closes the pipe connection after waiting a prescribed period of time as an anti hacker delay . A secure token is written directly to secured process memory on its creation so no one else can use the IPC channel engine.

Desktop initialization and security uses the Windows CreateDesktop API both with NT security features to achieve maximum possible control of user space prevention and to prevent keyboard loggers and screen shooters from accessing private information. The CreateDesktop API function creates a new desktop associates it with the current window station of the calling process and assigns it to the calling thread. The virtual desktop which is created by the CreatesDesktop API function can be optionally equipped with special Security Descriptor that ensures no one can launch an application on the secured desktop or install a keyboard hook into it and even make it impossible to get a desktop handle to this desktop . During initialization the manager cpsws.exe creates a desktop and assigns to it security descriptor with an empty DACL. The security descriptor creation and initialization code may for example be implemented along the following lines 

Since the SWS performs HKCU hive and user s profile virtualization it is possible to enforce some user interface predefinitions for applications running under SWS. Examples include disabling or extending some shell features adding configuration shortcuts on Desktop or Start Menu importing some files from the original profile and the like. Also the SWS performs automatic changing of desktop background wallpaper when switching from default desktop to secured one and vice versa.

After creating a virtual desktop the SWS creates notification area tray icons both on secured and default desktops. These icons allow switching between desktops and closing of the SWS. The notification icon on the secure desktop is used also to display some user information messages and security warnings e.g. as information balloons . The SWS draws a special icon on the right side of titles for all secured applications to provide user feedback psychological conviction that he or she is working in a secure workspace.

On the exit command that can be given directly from the notification icon menu or by ExitWindowsEx API call invoked from any secured application the SWS starts the de initialization procedure or method. is a flowchart illustrating a method of the present invention for de initialization. At step the method queries all applications currently running in the SWS for shutdown by sending them WM QUERYENDSESION and WM ENDSESSION messages. This allow applications to ask the user to save any information before shutdown. Next at step all running SWS applications are terminated. The pipe server is closed at step and all encrypted files are deleted from virtual user profile at step . Finally at step the method concludes by deleting HKCU CPSecured registry key.

While the invention is described in some detail with specific reference to a single preferred embodiment and certain alternatives there is no intent to limit the invention to that particular embodiment or those specific alternatives. For instance those skilled in the art will appreciate that modifications may be made to the preferred embodiment without departing from the teachings of the present invention.

