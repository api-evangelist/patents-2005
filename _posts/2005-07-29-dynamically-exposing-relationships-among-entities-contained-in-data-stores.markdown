---

title: Dynamically exposing relationships among entities contained in data stores
abstract: Dynamically exposing relationships among entities contained in data stores. A method disclosed herein can include receiving data related to a given object that is contained in a given data store, and dynamically determining one or more relationships between the given object and one or more further objects. These relationships can include group memberships, management relationships, containment relationships, or the like. As the data related to the stored objects changes, the relationships among the objects can be updated. Once the relationships are defined, representations thereof may be presented to a user via a suitable user interface. The user interface may present these relationships as graphic icons, hypertext, or the like, and may further depict the dynamic relationships distinctly from static directory listings. The user may then navigate these relationships by interacting with these representations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07716252&OS=07716252&RS=07716252
owner: Microsoft Corporation
number: 07716252
owner_city: Redmond
owner_country: US
publication_date: 20050729
---
In traditional command line environments users can navigate through a file system or data store using a containment relationship of the directories and files that are stored in the file system or data store. Users can also navigate across links that have been statically defined within that file system. These links may have been defined by the users themselves or may come pre defined when the file system is installed. In any event these links may be characterized as static links in that they are in some sense predefined and unchanging absent active user intervention.

In graphical user interface GUI environments users may create icons that represent shortcuts to files folders or applications. By clicking or otherwise interacting with such icons the user may proceed directly to the file folder or application to which that shortcut points without browsing or navigating through an intermediate directory structure.

The subject matter described herein pertains to dynamically exposing relationships among entities contained in data stores. One or more objects are contained in a data store and data that is related to such objects is received. One or more relationships between the given object and one or more further objects are dynamically determined. These relationships can include group memberships management relationships containment relationships or the like. As the data related to the stored objects changes the relationships among the objects can be updated.

Once the relationships are defined representations thereof may be presented to a user via a suitable user interface such as a programmatic interface a command line interface and graphical interface. The user interface may present these relationships as graphic icons hypertext or the like and may further depict the dynamic relationships distinctly from static directory listings. The user may then navigate these relationships by interacting with these representations.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

The file system can be implemented as a kernel component that registers itself with an input output I O manager as an active file system. There can be several types of file systems including local network file systems and remote distributed file systems. Several file systems can be active at the same time and can be dynamically located when a volume is mounted or when a remote name is being resolved. The I O manager can sequentially call each registered file system until one file system recognizes the volume structure or remote name. In general the file system is an example of a data store that can serve as either the source or destination of a relationship.

The directory structure can be implemented using for example the ACTIVE DIRECTORY directory service which is available from Microsoft. The ACTIVE DIRECTORY service enables the management of the identities and relationships that define network environments. The ACTIVE DIRECTORY service is a Microsoft technology part of Active Platform that enables applications to find use and manage directory resources such as user names network printers and permissions in a distributed computing environment. Distributed environments are usually heterogeneous collections of networks that often run proprietary directory services from different providers. To simplify directory related activities such as locating and administering network users and resources Active Directory presents applications with a single set of interfaces that eliminate the need to deal with differences among these proprietary services. Active Directory is a component of Microsoft Windows Open Services Architecture WOSA .

It is understood that the file system and the directory structure as shown in are provided only for convenience of illustration and discussion and do not limit the teachings herein. For example other implementations could also include two or more file systems and or two or more directory structures .

The user may interact with an environment that is based on Graphical User Interface GUI technology and or with an environment that is based on command line shell technology. Another example environment shown in is an environment that is embedded within an application . This application can be realized as for example as a web based service or executing on a general purpose computing system or other device.

A suitable but non limiting example of the GUI environment is any of the WINDOWS family of operating systems available from Microsoft Corporation of Redmond Wash. hereinafter Microsoft and any application software that is compatible with WINDOWS operating systems. A suitable example of such an environment is any of the command shell environments supported by the WINDOWS family of operating systems available from Microsoft. For convenience the environments and are collectively referred to herein as environments .

It is understood that the foregoing examples are provided for convenience of discussion and illustration and do not limit the subject matter disclosed herein. It is further understood that users may access the different environments either concurrently or separately in different implementations of the teachings herein. Also the environments could be implemented as separate environments or could be implemented as integrated environments according to different embodiments of the teachings herein.

The environments can each include respective user interfaces which are shown as and in the environments depicted in . User interfaces and are referred to collectively herein as user interfaces and are described in more detail in connection with below. The user can issue various commands relating to browsing or manipulating the contents of the data stores via the user interfaces . The commands and any responses thereto received by the user through the respective user interfaces are represented by the reference numerals and and are referred to herein collectively as commands or responses for convenience of description and illustration.

These commands from the user are passed through one or more of the environments to one or more providers . The providers can be for example Cmdlet Providers that are available from Microsoft. Cmdlets are described further below in connection with . The providers allow the user to navigate the containment or contents of the data stores . The providers can include a respective relationship provider for the file system and a respective relationship provider for the directory structure . The respective relationship providers and are referred to herein collectively as relationship providers for convenience.

The relationship providers expose respective data and from each one of the data stores and . Exposed data and are referred to herein collectively as exposed data for convenience. The exposed data can include for example particular contents of the data stored in the data stores properties of such data types of such data or the like.

A relationship provider engine accesses the exposed data for example through the relationship providers . Illustrative data accesses between the relationship provider engine and the relationship providers are represented by the reference numerals and collectively data accesses for convenience . By accessing this exposed data through for example the data accesses the relationship provider engine can define relationships among particular data elements or objects stored in the file system and or the directory structure . Having done so the relationship provider engine can publish or expose these relationships to the user as relationships data which can be provided via one or more of the user interfaces . The relationships data can be considered part of the response data that is provided to the user .

It is understood that the data flow for the data accesses and the relationships data are shown in for convenience of illustration and discussion only and not to limit the teachings herein. These same comments apply equally to the components through which the data accesses and the relationships data are shown to flow. For example the relationships data could flow through one or more of the relationship providers on its path to the user . Alternatively the relationships data could pass directly to the user by a different channel altogether bypassing the providers or relationship providers . Also the data accesses could enable the relationship provider engine to access the exposed data directly from the data stores rather than through the relationship providers .

In the architecture shown in a given relationship provider can correspond to a given data store . Accordingly as data stores are added to or deleted from the architecture corresponding relationship providers can be plugged into or out of the relationship provider engine . Also new relationships may be exposed within one or more existing data stores without adding or removing any data stores . Thus new relationships may be added without adding new data stores . When a given relationship provider is plugged into the relationship provider engine the relationship provider can then expose data particular to that data store to the relationship provider engine . In turn the relationship provider engine can identify and expose relationships between or among entities in a given data store or in different data stores and . In this sense the relationship providers may be viewed as being pluggable into the relationship provider engine or more generally pluggable into the architecture .

The relationship provider engine may be viewed as supporting pluggable components such at the relationship providers . The relationship provider engine can communicate with a first relationship provider to access information about entities that are provided by or native to first data store . The relationship provider engine can also communicate with at least a second relationship provider to access information about further entities that are provided by or native to at least a second data store .

As various data stores and related relationship providers are added to the architecture or as the contents or states of these data stores and related components otherwise change over time the exposed data may also change accordingly. Accordingly the relationship provider engines in cooperation with the pluggable relationship providers can dynamically expose these changing or evolving relationships among the data elements stored in the data stores and revealed in the exposed data . From the vantage point of the user the relationship provider engine can serve to virtually unify or integrate two or more data stores . Because of this virtual unification or integration any structural or organizational differences between the two data stores do not impede the definition of relationships between objects stored in these two data stores and do not impede navigation from objects in these data stores .

Turning first to the data store it may be described as containing one or more containers . The term container may refer to a directory which may be a top level or root directory within the data store . The directory can contain files and other containers. These other containers can include for example subdirectory which in turn can contain one or more files . It is understood that the subdirectory in turn may contain further subdirectories and file and so on. However for convenience and clarity only one subdirectory is shown in .

Turning now to the data store assume only for the sake of the illustrative implementation shown in that this data store is implemented using the ACTIVE DIRECTORY service which was discussed above. In the context of the data store the term container can refer to a node that may be implemented as an ACTIVE DIRECTORY Organizational Unit OU . An OU is a type of directory object contained within domains and is a container into which users groups computers and other organizational units can be placed.

The term container can also refer to a node that may be implemented as an ACTIVE DIRECTORY Container. In the context of Active Directory the term container can refer to an object of the container structural class or an object that has child objects.

The term container can also refer to a node that is associated with domain controller locations and naming under the Domain Name System DNS . Finally the term container can refer to any other directory object type . Any of the foregoing can in turn contain other directory objects of any type.

Recall that the relationship provider engine shown in can define and reveal as a first non limiting example one or more relationships between entities associated with the relationship providers . Also the relationship provider engine can define and reveal as a further non limiting example one or more relationships within an entity associated with a given relationship provider . The relationship provider engine can perform any of the foregoing using the data exposed to or by the relationship providers . These relationships can be exposed dynamically based on the data properties or type of the items in the data stores that are exposed through the relationship providers . As represented generally by the relationship data or collectively relationships as shown in these revealed or defined relationships can map an item at one path to an item at another path. In the example shown in the relationship data indicates that the file in the data store is related to a directory object in the other data store . Also in the relationship data indicates that the OU is related to the directory object .

It is understood that the relationship data is shown in for discussion only and not for limitation. More particularly the relationship data may relate data items objects properties of data or the like that may appear in the same data store . However the relationship data may also relate data elements items objects or the like that may appear in any number of different data stores . It is further understood that the relationship data can relate two or more data elements items objects or the like. Finally the relationships represented by the relationship data may be characterized as one to many one to one many to one many to many or the like.

As an example of the foregoing discussion assume that data pertaining to a particular user who may or may not be the user shown in is contained in the data store . More particularly data pertaining to the particular user may be stored in a user object associated with a particular OU . Given the contents of the particular OU corresponding to the user the relationship provider engine may determine the group or groups in which the user is a member. A MemberOf relationship associated with the OU may facilitate this determination. In this example relationship data could link the OU with a further directory object which is assumed to indicate or correspond to the group or groups of which the particular user is a member. It is understood that this determination may be repeated recursively to investigate and determine what group or groups the user is in and in turn what group or groups that group is in. Should the group membership of the user change or should the composition or definition of particular groups change the corresponding relationship data can be updated dynamically by the relationship provider .

Assume further that the user is an administrator or other user with requisite rights or privileges to access the contents of the data store . The user may navigate the data store by utilizing at least in part the relationship provider . Thus in this example the command data may take the form of navigation commands issued by the user and the response data corresponding thereto can take the form of directory listings of the like that are provided to the user in response to these commands. The user may accordingly navigate to the directory that contains the OU which in turn pertains to the particular user . Should the user navigate to this OU the relationship provider may list the OU along with other static or pre defined contents of the directory in which the OU resides. This static data can be provided using for example a representative user interface which can be for example any of the interfaces described above in connection with or any of the displays described below in connection with .

The user interface as shown in can include a first area or field that can contain depictions or representations of relatively static contents of for example a given directory or file system structure. The user interface can also include at least a further area or field that can contain depictions or representations of the relationship data exposed by the relationship provider engine . In some embodiments the representation of the relationship data in field may be highlighted or otherwise rendered to the user in a manner that distinguishes it from the static directory contents shown in field . In such embodiments this highlight or rendering may take the form of for example special coloration typeface or the like that may be applied to content rendered in field as compared to field . Also in such embodiments the representation of the relationship data in field may be rendered as one or more graphic icons as hyper text or the like.

In other embodiments the content in fields and may be rendered alike such that the user may not readily distinguish the static directory contents from the dynamic relationship data . These embodiments may be suitable for implementations wherein it is desired to make the differences in the static and dynamic content shown respectively in fields and transparent to the user .

It is noted that the user interface and the fields and are shown in block form for clarity and conciseness in illustration and discussion and not to limit possible applications of the teachings herein. More particularly the static and dynamic content displayed respectively in the fields and may be arranged in any suitable configuration for presentation to the user . For example the content shown in the fields and may be displayed separated from one another or may be integrated and displayed together.

In any event by interacting with content shown in field such an icon or hyper text the user may navigate from for example the OU corresponding to the user to one or more objects corresponding to or representing the group or groups of which the user is a member. In this manner the user can quickly navigate and investigate the group membership of the user using the relationship data . In this example the OU may be viewed as an origin object from which the user may navigate and the object may be viewed as a destination object to which the user may navigate. Using this terminology it is understood that the origin object and the destination object may reside in the same data store or in different data stores .

In connection with the user interface UI the relationship provider engine can facilitate not only a listing of the relatively static contents of a given directory via field but can also facilitate a representation of the dynamic relationship data via field . For example the relationship provider engine can cause the UI to depict in field the relationship data that relates the user and the OU . Recall that in this example the relationship data dynamically indicates the group or groups in which the user is a member.

The above non limiting example discusses group membership of a particular user and the data objects representing that group membership such as other directory object . However in other examples the teachings herein may be applied to define and expose other types of relationships involving particular objects in the data stores or involving users whose data is stored in the data stores . For example containment relationships of particular objects may be defined and exposed to the user for navigation. Also management relationships of given users may be defined and exposed to the user for navigation. Such management relationships can indicate who manages the user or who is managed by the user for example. In short the types and nature of the relationships represented by the relationship data can be as dynamic as the underlying data stored in the data stores .

In block data related to a given object or entity in a data store is received by for example the relationship provider engine . This data can take the form of data that can be exposed directly to the relationship provider engine . Alternatively the data may also be exposed by way of the relationship providers shown in as indicated by the data accesses represented by lines and .

In block the data received in block is analyzed to determine dynamically a relationship between the given object or entity i.e. an origin object and one or more other objects or entities i.e. one or more destination objects . This analysis can be performed by for example the relationship provider engine . Having determined this relationship between the origin object or entity and the one or more destination objects the process flow can include linking the origin object with the one or more destination objects block . Also the process flow can include enabling navigation between the origin object and the one or more destination objects block . This navigation can be performed by for example the user shown in .

Turning to block the process flow can include providing or presenting a graphical or visual representation of the relationship determined in block . More particularly if the user has navigated to the origin object the process flow can include providing a representation of the destination object that is visible to the user through for example the user interfaces . As discussed above examples of this representation of the destination object can include graphical icons hypertext links or the like.

In block a relationship provider engine that routes calls to one or more relationship providers is defined. The relationship provider engine is discussed further in connection with below.

In block Cmdlets are defined that facilitate defining the relationships and exposing the defined relationships to the end user . The term Cmdlet pronounced command let is used herein to refer to a light weight command that may be provided by a given environment . Several illustrative cmdlets are referenced as in and discussed in detail below in connection with . These Cmdlets can differ from commands in other environments in several ways 

The cmdlets may also expose functionality related to the defined relationships to the end user . For example the cmdlets may enable the end user to navigate from one data store to another data store based on a relationship discovered or defined between items stored in these two data stores and .

The Relationship Provider Attribute can be placed on the class that derives from the Relationship Provider base class . The attribute can contain a Name field a FromProvider field a ToProvider field and one or more ParameterFlags fields .

The Name field can be exposed to the end user to identify the relationship . The FromProvider field can identify the provider relationship provider or data store from which the relationship originates.

The ToProvider field can identify the provider relationship provider or data store to which the relationship maps or links. Note that the FromProvider field and the ToProvider field can identify the same provider relationship provider or data store . These fields and can also contain wildcard patterns that allow the specified relationship to be valid for source and destination providers that match the wildcard pattern.

The ParameterFlags field can identify any additional parameters that may be required and or available for the specified relationship . Illustrative for this ParameterFlags field can include a PropertyAvailable parameter a PropertyRequired parameter a TargetAvailable parameter and a TargetRequired parameter .

The base class for the Relationship Provider can be implemented as an abstract class with one or more methods and one or more abstract properties . For illustration only but not limitation shows several methods . These methods can be named respectively for convenience only a IsRelationshipValid method a GetRelationshipTargets method a ResolveRelationship method and a CanResolveRelationship method . These methods can be used by the relationship provider engine described elsewhere herein for example and to expose the relationships to the end user through for example one or more cmdlets.

To expose a relationship a class can derive from the Relationship Provider base class and override the following methods . It can also declare one or more Relationship Provider Attribute s on the class which can contain the name of the relationship the FromProvider the ToProvider and any ParameterFlags .

The method IsRelationshipValid can indicate to the relationship provider engine whether the relationship that this Relationship Provider presents is valid for the given path property and target. The method can return true if the relationship is valid and can return false if the relationship is not valid.

For example assume that a group defined under an implementation of the Active Directory service has a Members relationship. If the method is passed a path to an Active Directory group it should return true. If the method is passed a path to an Active Directory user it should return false since Active Directory users do not have a Members relationship.

The method GetRelationshipTargets can return to the relationship provider engine all the targets that are possible to traverse in this relationship given the specified path and possibly property .

For example assume that an Active Directory group has a Members relationship. These members are users in the group. If GetRelationshipTargets is called on a Relationship Provider that services this relationship the relationship provider engine can look up the Members attribute of the group that is specified by the path and return the users in that group as unique strings.

The method ResolveRelationship can perform the mapping from the FromProvider to the ToProvider . The method can receive as input the path in the FromProvider and possibly the property and or target of the relationship . Relationship Providers that implement this method can return a path in the space related to the ToProvider .

For example assume that an Active Directory group has the Members relationship . The target for the relationship is the X.500 path of the user to whom the relationship is resolved. The property is implied by the relationship and is members . Given the path to a group and the target DN of the member this method would return a string that represents the path of the member. This could be either provider qualified AD LDAP mydomain CN myUser DC mydomain or drive qualified AD CN myUser DC mydomain where AD is a drive that was mounted to the defaultNamingContext of the domain.

The method CanResolveRelationship can indicate to the relationship provider engine whether the relationship that this Relationship Provider presents can be resolved from a given path property and target. More particularly the method evaluates whether an input relationship can be resolved from a given FromProvider to a given ToProvider . The method can return true if the relationship can be resolved and can return false if the relationship cannot be resolved.

Recall that the base class can define one or more properties . These properties can include a Description Property which can be implemented as a localized string that describes the relationship that the Relationship Provider provides.

A relationship illustrated in block form in can be associated with a name a FromProvider and a ToProvider . Sometimes this information alone may be inadequate for a given Relationship Provider to provide the mapping of the from path to the to path for a given relationship . For instance in the Active Directory service there may be a members relationship between a group and many users. The members attribute on a group object lists the users that are a member of the group. When relationship mapping is performed the Relationship Provider can determine which user the to path should represent. This is exposed through the Target parameter to the cmdlets and Relationship Provider APIs.

Similarly there are cases in which the property to use for the relationship is provided to the Relationship Provider . For instance assume that a relationship maps a Registry path to a FileSystem path. Given a RegistryKey path that has a property that contains a file system path the property name is specified in order for the Relationship Provider to know which property of the RegistryKey to read to get the path in the FileSystem.

In the example above referencing the Active Directory service this property can be implied by the relationship but the target is nevertheless specified. In the Registry example above the target can be implied but the property is nevertheless specified. Given these two examples other scenarios may involve both a target and a property to be specified.

A Relationship Provider can be identified through CommandDiscovery APIs using for example a file such as a .relationshipprovider file. This file can be created by for example running export command on the assembly containing the Relationship Provider . The file can use the RelationshipProviderAttribute to find the class and to generate an XML file with the name of the relationship as the name of the file with a .relationshipprovider extension. It is understood that the description of this file including but not limited to the name of the extension of this file is provided only for ease of description herein and not to limit the subject matter described therein. Any suitable file extension may be chosen in implementing this embodiment of the subject matter described herein.

Upon invocation of the relationship provider engine a SessionState object can search through for example appropriate environment variables to look for .relationshipprovider files in conjunction with .cmdletprovider files. When the SessionState object locates a .relationshipprovider file it can read that file create a corresponding RelationshipProviderInfo instance and put it in a Relationships.RelationshipCollection.

In an alternative to the filename based approach discussed above a given relationship provider may provide information about one or more given relationships when the plug in corresponding to this relationship provider is installed in the relationship provider engine . Still other embodiments may use further techniques for finding given relationship providers and or relationships given the description herein.

If the FromProvider field or the ToProvider field contains any wildcard characters the RelationshipProviderInfo can also be stored in a wildcard provider collection instead of directly in the RelationshipCollection. After all the CmdletProviders and Relationship Providers have been loaded each RelationshipProviderInfo in the wildcard provider collection can then be processed. For each of the providers or relationship providers the FromProvider field and the ToProvider field can be matched against the existing CmdletProviders. Each match pairing a FromProvider field and a ToProvider field can become a new instance of RelationshipProviderInfo and be entered into the RelationshipCollection. Any time that NewProvider is called to add a new provider or relationship provider the providers or relationship providers in the wildcard provider collection are processed again to find new matches. If new matches are found then new RelationshipProviderInfo instances are created and added to the RelationshipCollection.

If a CmdletProvider or relationship provider that is declared as the FromProvider or the ToProvider is not loaded at the time the relationship is loaded the relationship can be put in a delay load table . In some implementations relationships in the delay load table are not shown as valid relationships to the user when the get child relationship get relationship path or resolve relationship methods described below and referenced in as and respectively are called. In these implementations the relationships in the delay load table are seen only through get relationship all and can be removed using remove relationship .

When a CmdletProvider or relationship provider is added to the system the relationships in the delay load table are processed. Any relationships in the delay load table that are now valid due to the addition of their missing FromProvider or ToProvider are then added to a normal relationship table and become valid relationships that are visible to all the relationship commands.

When a CmdletProvider or relationship provider is removed from the system the relationships in the normal relationship table are processed and any that are no longer valid are moved to the delay load relationship table .

APIs for adding getting and removing the relationship providers are exposed to cmdlets referenced as in and described below cmdlet providers and relationship providers through the RelationshipProviderIntrinsics interface as described below.

The get relationship cmdlet can receive a path as input and returns all the RelationshipProviderInfo objects for the valid relationships at that path. This can be done by looking up a Provider ID associated with the path and finding all RelationshipProviderInfo objects for that Provider ID. The Provider ID can be the same as the name of the CmdletProvider . The FromProvider and ToProvider properties of the base class for the Relationship Provider can use the Provider ID name to state the provider or relationship provider to which the relationship maps. Also it is noted that the Provider ID can also be implied by or inferred from context and need not be explicitly supplied by a user.

For each of these the associated RelationshipProvider.IsRelationshipValid method can be called. If true is returned then the relationship is valid for the given path and the RelationshipProviderInfo can be returned from the get relationship cmdlet .

The resolve relationship cmdlet can receive a path as input a relationship name and optionally a property and a target. The RelationshipProviderInfo is looked up in the RelationshipCollection for the given relationship name and FromProvider which is inferred from the path . It then gets the appropriate RelationshipProvider instance for that relationship and calls the ResolveRelationship method passing the path property and target that were specified. The Relationship Provider then returns the path to which the relationship resolves.

A Relationship parameter can be added to the get child cmdlet . When this parameter is specified an optional Property parameter can also be specified. When called with these parameters the appropriate Relationship Provider can be found and the GetRelationshipTargets method can be called with the path and the specified property. The Relationship Provider can return strings indicating the targets that are available for that relationship at that path.

A Relationship parameter can be added to the set location cmdlet . When this parameter is specified an optional Property and Target parameter can also be present. When called with these parameters the appropriate Relationship Provider can be found and the ResolveRelationship method can be called with the path and the specified property and target parameters. The Relationship Provider can return an MshPath as a string that the set location cmdlet uses as the new target of the set location action. The processing can then proceed as if the set location cmdlet had been called on the resulting path.

The Push location cmdlet can behave similarly to the set location cmdlet except that the current location is pushed onto a stack before changing the current location to the new path. The Pop location cmdlet can pop a location from a stack and set the new path to that location.

Specified below is an illustrative class from which relationship providers can derive. Functionality for this class may be implemented by overriding the abstract methods as follows 

Specified below is an illustrative class suitable for representing the relationship to the end user . It can contain the information to load the relationship provider .

Specified below are illustrative APIs that can be exposed to cmdlets for managing which relationships are loaded and for getting information about those relationships . They can be accessed through SessionState.Relationship. 

The computer and network architectures in computing environment can be implemented with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers server computers client devices hand held or laptop devices microprocessor based systems multiprocessor systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers gaming consoles distributed computing environments that include any of the above systems or devices and the like.

The computing environment includes a general purpose computing system in the form of a computing device . The components of computing device can include but are not limited to one or more processors e.g. any of microprocessors controllers and the like a system memory and a system bus that couples the various system components. The one or more processors process various computer executable instructions to control the operation of computing device and to communicate with other electronic and computing devices. The system bus represents any number of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures.

Computing environment includes a variety of computer readable media which can be any media that is accessible by computing device and includes both volatile and non volatile media removable and non removable media. The system memory includes computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . A basic input output system BIOS maintains the basic routines that facilitate information transfer between components within computing device such as during start up and is stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently operated on by one or more of the processors .

Computing device may include other tangible removable non removable volatile non volatile computer storage media. By way of example a hard disk drive reads from and writes to a non removable non volatile magnetic media not shown a magnetic disk drive reads from and writes to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive reads from and or writes to a removable non volatile optical disk such as a CD ROM digital versatile disk DVD or any other type of optical media. In this example the hard disk drive magnetic disk drive and optical disk drive are each connected to the system bus by one or more data media interfaces . The disk drives and associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for computing device .

Any number of program modules can be stored on RAM ROM hard disk magnetic disk and or optical disk including by way of example an operating system one or more application programs other program modules and program data . Each of such operating system application program s other program modules program data or any combination thereof may include one or more embodiments of the systems and methods described herein.

Computing device can include a variety of computer readable media identified as communication media. Communication media typically embodies computer readable instructions data structures program modules or other data and includes any information delivery media. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared other wireless media and or any combination thereof.

A user can interface with computing device via any number of different input devices such as a keyboard and pointing device e.g. a mouse . Other input devices not shown specifically may include a microphone joystick game pad controller satellite dish serial port scanner and or the like. These and other input devices are connected to the processors via input output interfaces that are coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port and or a universal serial bus USB .

A display device or other type of monitor can be connected to the system bus via an interface such as a video adapter . In addition to the display device other output peripheral devices can include components such as speakers not shown and a printer which can be connected to computing device via the input output interfaces .

Computing device can operate in a networked environment using logical connections to one or more remote computers such as remote computing device . By way of example remote computing device can be a personal computer portable computer a server a router a network computer a peer device or other common network node and the like. The remote computing device is illustrated as a portable computer that can include any number and combination of the different components elements and features described herein relative to computing device .

Logical connections between computing device and the remote computing device are depicted as a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. When implemented in a LAN networking environment the computing device is connected to a local network via a network interface or adapter . When implemented in a WAN networking environment the computing device typically includes a modem or other means for establishing communications over the wide area network . The modem can be internal or external to computing device and can be connected to the system bus via the input output interfaces or other appropriate mechanisms. The illustrated network connections are merely exemplary and other means of establishing communication link s between the computing devices and can be utilized.

In a networked environment such as that illustrated with computing environment program modules depicted relative to the computing device or portions thereof may be stored in a remote memory storage device. By way of example remote application programs are maintained with a memory device of remote computing device . For purposes of illustration application programs and other executable program components such as operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computing device and are executed by the one or more processors of the computing device .

Although embodiments of dynamically exposing relationships among entities contained in data stores have been described in language specific to structural features and or methods it is to be understood that the subject of the appended claims is not necessarily limited to the specific features or methods described. Rather the specific features and methods are disclosed as exemplary implementations of dynamically exposing relationships among entities contained in data stores.

