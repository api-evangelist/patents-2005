---

title: Information security method and system
abstract: The present invention discloses an improved information security system and method. A polymorphic engine is used to enhance the security features of a software application and the data generated by or made available to the application and/or the operating system. The polymorphic engine operates to randomly alter the standard executable code of the original application while preserving its functional characteristics. Each polymorphed instance of the application differs from any other instance of the same application in form only. Various other security features operate to protect the polymorphic engine itself and/or the polymorphed code generated therefrom. These other security features include: just-in-time instruction code decryption; virtual CPU instruction code pre-processing; call mutation; stack manipulation; secure hook-capture of device input; secure display device output; application level decryption of encrypted hardware data streams; and a dynamic, randomly configured graphical keypad interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07555780&OS=07555780&RS=07555780
owner: Symantec Corporation
number: 07555780
owner_city: Mountain View
owner_country: US
publication_date: 20050216
---
This application is a divisional of U.S. application Ser. No. 09 855 073 filed on May 14 2001 which claims priority to U.S. Provisional Patent Application Ser. No. 60 203 877 entitled INFORMATION SECURITY SYSTEM filed on May 12 2000 which is incorporated herein by reference.

This invention generally relates to information security systems. More specifically the invention relates to a system and method for improving the security features of executable computer program code and or data which is generated stored or manipulated by program code in order to more effectively prevent theft decompilation unauthorized reproduction and or unauthorized use.

As computers have become more widely used and more pervasively networked information privacy and financial losses etc. due to information security breaches have dramatically increased as well. According to a Mar. 12 2001 survey press release published by the Computer Security Institute eighty five percent of 538 respondents primarily large corporations and government agencies detected computer security breaches in the preceding year. http www.gocsi.com prelea.sub . 000321.htm incorporated herein by reference. Sixty four percent of the same respondents confirmed financial losses due to computer breaches with thirty five percent of 186 respondents being capable of quantifying their losses as totaling 377 828 700. By comparison the losses from 249 respondents in 2000 totalled 265 589 940 with the average annual total over the prior three year period being 120 240 180. This trend illustrates that the threat of computer crime and other electronic information security breaches continues to grow with financial loss exposure also increasing.

As in previous years the most serious financial losses have occurred from theft of information 34 respondents reporting 151 230 100 and fraud 21 respondents reporting 92 935 500 . Notably those respondents that cited their Internet connections as a frequent point of attack rose from 59 in 2000 to 70 in 2001. Some examples of security breaches and cyber crimes on the rise are system penetration from external sources 40 of respondents denial of service attacks 38 employee abuse of Internet access privileges for example downloading pirated software or inappropriate use of email systems 91 and computer virus attacks 94 .

Many advances have been made in recent years in the field of computer information security. Most of these security countermeasure technologies have employed computer software to identify authorized users of a system protect against virus infection encrypt decrypt data streams prevent unauthorized registration and or use of pirated software applications and block malicious or surreptitious communications originating from a particular source. Unauthorized access to a particular computer system however may often be obtained by exploiting various security flaws present in the program code of the countermeasure software itself. Additionally unauthorized access may also occur with the theft of user identification and password information.

With respect to the unauthorized and illegal reproduction of computer software one of the most prevalent problems is that the software applications can be reverse engineered with decompiling tools. Decompilers are essentially software applications that examine other compiled software applications in order to reconstruct the original source code. For commercial software applications offered for sale decompilation and reverse engineering is often prohibited by software license agreements. Decompilers however are freely available for a variety of platforms. Generally a decompiler works by analyzing the byte code of software and making educated guesses about the source code that created it. Most decompilers also provide additional debugging information which can help the decompiler generate a more accurate representation of the original source code. If the software employs code routines for protecting itself against unauthorized use such as with the aid of serial numbers hardware locks locking to floppy disks or CD s time limited license expiration etc. the code fragments can be decompiled analyzed modified and recompiled to produce a new version of the software application in which the security code routine has been defeated and is no longer capable of preventing unauthorized use. The modified software application is thereafter unprotected and may be duplicated and distributed ad infinitum for illegal royalty free use for example over the internet as what is known to those skilled in the art of software piracy as warez .

Several debugging tools such as for example NUMEGA.RTM. SOFTICE.RTM. are readily available for this purpose. http www.numega.com drivercentral components si driver.shtml . A debugging tool more commonly known as a debugger is a software development program that allows the user to debug and troubleshoot computer code as the application is being developed. Generally the debugger acts to interrupt the CPU in order to watch each individual instruction as it arrives for processing and execution. For example a debugger may be used to analyze and determine precisely which code fragment in a compiled application is responsible for interrogating whether a valid serial number has been provided in order to permit an authorized user to execute the program application. Once the serial number interrogation code fragment is located by the debugger it becomes rather simple to decompile the code fragment to determine the characteristics that a valid serial number key must have in order to permit program execution access. For example for any serial number interrogation code fragment and any valid serial number the operation of the code fragment on a valid serial number s permits user access 1 True therefore allow access as given by s 1 and the operation of the interrogation code fragment on an invalid serial number x denies user access 0 False therefore deny access as given by x 0. Given the code fragment an inverse function .sup. 1 may be derived such that 1iC 1Ri isii 1nC si n wherein any operation of the inverse function .sup. 1 upon a random seed R.sub.i generates a random and valid serial number s.sub.i. Moreover an algorithm may be deduced from the inverse function of the code fragment .sup. 1 to generate a stand alone application capable of generating multiple random yet valid serial numbers. Alternatively the interrogation code fragment may be removed altogether and the program recompiled to a version which no longer has an interrogation code routine and that looks for a serial number prior to permitting the user to execute the application.

Another representative software security weakness involves the MICROSOFT.RTM. WINDOWS.RTM. Application Programming Interface API . For example when the user displays a webpage requesting that the user login there may be a textbox provided for the username and another textbox for the password. Using the WINDOWS.RTM. API another application can continuously or periodically request the contents of the textboxes even if the webpage display subroutine passes asterisk characters to obscure that content. Such an application can be designed to run in the background and would be generally undetectable to the average user.

Yet another exploitable software security vulnerability involves the logging of user keystrokes. In these types of breaches an application can monitor the data originating from the operating system s keyboard device driver routines to look for username password or other sensitive data and store and or transmit the data for future use. Additionally keyboards like most electronic devices generally emit electromagnetic radiation of particular frequencies which propagate away from the keyboard in all directions. Someone monitoring these frequencies at a distance can analyze the signals to determine which keys on the keyboard have been depressed.

The cut and paste feature of many operating systems also presents a security problem. Each time the cut and paste feature is used for example in MICROSOFT.RTM. WINDOWS.RTM. another application can interrogate the clipboard and make copies of the contents. There are many other examples of exploiting software security flaws that involve other mechanisms such as digital wallets passports web browser cookies etc. Often a computer virus is selected as a transport mechanism for depositing these malicious applications onto a target computer system.

There is a need therefore within the electronic information security art to more effectively counter the exploitation of security flaws in software applications during the execution of the application code. There is also a need to more effectively prevent 1 unauthorized duplication and distribution of software applications and 2 the capturing of identification password and or other data that might be used inter alia to gain access to a particular computer system.

In general the present invention suitably protects standard and or custom compiled code using a polymorphic engine which randomly alters the executable code of a compiled application while conserving the application s original operational and functional characteristics. Once the code has been randomly polymorphed it becomes statistically impossible to retrieve the original application source code. Additionally each polymorphed copy of the application randomly differs from any other copy and therefore precludes the possibility of generating a patch or crack for any one polymorphed copy that will work generically with any other polymorphed copy of the application. Moreover the code polymorphing process can be iteratively applied to generate multiple layers of protection.

In order to protect the polymorphic engine from debugging decompilation and or reverse engineering by analysis of memory snap shots a running line encryption method is also disclosed which protects the polymorphic engine while the engine s code resides in memory. This is generally accomplished by having only one line of the engine s encrypted instruction code decrypted for any given CPU instruction cycle. As the polymorphic engine s code moves through the stack to be processed by the CPU these instructions are decrypted just in time and provided to the CPU for execution and then immediately re encrypted before decryption and subsequent execution of the next line of instruction code. The present invention also discloses a virtual CPU instruction set pre processor employing a matchable data structure that is randomly created when the polymorphed application initializes. The matchable data structure correlates instructions specific to the CPU s instruction set with virtual CPU opcodes generated by the polymorphic engine.

As an added layer of protection the present invention also discloses stack manipulation and call mutation features that operates with the polymorphic engine to further subvert attempts to analyze and reverse engineer the application code. For applications or operating systems that use member calls to classes where the calls contain certain header data required by the class member to function properly the call mutation feature operates as an execution sequence redirector by 1 inserting mischievous data into the header of the original call thereby rendering the original call ineffective 2 rerouting the original call to a substitute call in which the substitute routine queries the stack pointer to determine where the substitute routine has been called from and 3 comparing the data obtained from the stack to a matchable data structure in order to pass program execution control to the appropriate routine. The software application still includes similar or identical functionality but the header of the original call is different and not readily traceable. This process can be iteratively applied to generate multiple layers of protection and may also be applied to API or other pointers as well.

A secure output display interface for concealing data protects users from applications that may use operating system calls to capture data by placing a hook into OS routines that preprocess input i.e. from a keyboard mouse light pen etc. and by interpreting the input before it is made available to other OS processes. The hook captured input is then enciphered and hidden from the OS. For example a user password entered in a textbox could be hook captured from the keyboard device driver enciphered and stored and then the hook routine passes literal asterisk characters to the appropriate textbox. In such a system queries from other OS routines to the textbox object would return the series of asterisks characters placed there by the hook routine and not the literal text of for example a password entered by the user. In one of the various aspects of the present invention the hook capture routine helps to secure user input to the polymorphed application by modifying display device output as well as corresponding literal data object content.

Another security feature of the present invention involves a secure hardware input device driver interface i.e. keyboard mouse light pen Ethernet cards etc. for entering secure data content. In one aspect of the present invention the polymorphed application communicates with an encryption chip located within the user input device to notify the device when encrypted communication is desired. All other communication with the input device in the absence of a request for encrypted data traffic will be unencrypted. Encrypted data streams from the input device are decrypted at the polymorphed code application level not the hardware or OS level in order to prevent background applications from obtaining the decrypted data stream.

In yet another embodiment of the present invention a secure software application for entering authentication information i.e. username and password data etc. is described. The authentication application is a dynamic randomly configured graphical keypad display which is designed to subvert optical capture recognition and hardware input device logging.

Other aspects and features of the present invention will be more fully apparent from the detailed description that follows.

The present invention offers substantial advantages and improvements over existing electronic information security technology with respect to the security features of executable application code and or data which is generated stored or manipulated by the application code in order to more effectively prevent unauthorized reproduction access and or use of the same. In accordance with various exemplary embodiments disclosed herein the present invention operates to protect standard or custom compiled code using a polymorphic engine which randomly alters the standard executable code of a compiled application while conserving the application s original operational and functional characteristics. Other methods and systems for protecting data traffic to and from the polymorphed application and the polymorphic engine itself are also described.

The following descriptions are of exemplary embodiments of the invention only and are not intended to limit the scope applicability or configuration of the invention in any way. Rather the following description is intended to provide convenient illustrations for implementing various embodiments of the invention. As will become apparent various changes may be made in the function and arrangement of the elements described in these embodiments without departing from the spirit and scope of the invention.

In an alternative exemplary embodiment of the present invention benign instructions may also be inserted into the polymorph instruction code to further differentiate the polymorph from the original compiled executable without altering the functional operation of the polymorphed code . Generally a benign function is an instruction or a set of instructions whose operation is inconsequential to the overall operation function or result of the remainder of the application code. depicts exemplary benign instructions wherein where possible an alternative instruction is selected randomly to replace a functionally benign instruction.

Once the isomorphic instructions have been substituted for original instructions step the resulting code polymorph is physically different from the original compiled executable yet has substantially the same operational and functional characteristics. The process shown in of generating a code polymorph may be more concisely represented by the following .PSI. o where represents the original compiled executable .PSI. represents the set of data parameters and or variables operated on by and o represents the result generated by execution of the original compiled code . The polymorphic algorithm operates to perform a substantially unitary transformation of the original compiled code to generate a functionally isomorphic code polymorph as in the following circumflex over . circumflex over .

where circumflex over X represents the polymorphic algorithm whose action on the originally compiled executable code generates a code polymorph circumflex over X which when applied to the set of data parameters and or variables .PSI. typically operated on by the originally compiled code produces substantially the same functional result o. Therefore the unitary transformation performed by the polymorphic algorithm circumflex over X on the originally compiled code may also be represented by .therefore.circumflex over X .PSI. .PSI. where the operation of the polymorphic algorithm circumflex over X may be more simply considered as any representative or exemplary unitary transformation such as for example multiplication of a particular value by the quantity . In the present invention however the polymorphic engine is not considered to be merely limited to performing mathematically unitary transformations of the original compiled code but also functionally unitary transformation of individual and or blocks of CPU instructions themselves. Therefore the generated code polymorph circumflex over X is said to constitute a functionally isomorphic variant of the originally compiled code having the property inter alia of being statistically impossible to reverse engineer in attempts to regenerate the original code .

The polymorphic engine in one exemplary embodiment of the present invention is configured to randomly scan select assign and or substitute isomorphic code fragments that are functionally correlated to substantially reproduce any particular operations or set of operations that may be found in the original executable code . This may be accomplished by comparing original instruction codes that are candidates for isomorphic substitution with multiple functional isomorphs of which at least one will be randomly selected for actual substitution into the generated polymorphed code . In other words for each discrete operation of the polymorphic engine as it is applied to the original compiled code a different code polymorph version of the original program is generated which has physically different instructions but substantially the same functional characteristics of any other code polymorph . This relationship among multiple code polymorphs is depicted in wherein no two code polymorphs contain physically identical code but all of the code polymorphs operate to produce substantially the same functional result. This relationship may be represented by the following 21123

wherein multiple application of the polymorphic algorithm circumflex over X to the original compiled code generates a series of code polymorphs circumflex over X .sub.i . These code polymorphs circumflex over X .sub.i have the relationship of circumflex over X .sub.i.noteq.circumflex over X .sub.j which is to say that no two code polymorphs are statistically physically identical to each other. However the code polymorphs circumflex over X .sub.i also have the relationship of 3i 1nX i n o .

As such they operate to substantially produce the same functional result when applied to the set of data parameters and or variables .PSI. typically operated on by the originally compiled code .

Once the code has been randomly polymorphed it becomes statistically impossible to retrieve the original application source code. Additionally each polymorphed copy of the application randomly differs from any other copy precluding the possibility of generating a patch or crack for any one polymorphed copy that will work generically with any other polymorphed copy of the application. Moreover in an alternative exemplary embodiment the code polymorphing process may be iteratively applied to generate multiple layers of protection by looping the generated code polymorph back through the polymorphic engine as depicted in such that a layered code polymorph is produced.

In one exemplary aspect the method for processing executable code to generate a polymorphed code variant may be thought of as wrapping or applying a wrapper to the original executable. In another exemplary embodiment wrapping 120 of the polymorphed code additionally enciphers the polymorph to further subvert attempts to reverse engineer the application. shows a generic prior art process for encrypting decrypting the code of an at least partially encrypted program . As the prior art program is compiled the decryption algorithm is generally both known and stored in the executable application code therefore the encrypted code block can be directly added at the compiling stage. However in accordance with an exemplary aspect of one embodiment of the present invention as shown in a random cipher algorithm is generated during the wrap process to encrypt the code of the protected application . This random cipher algorithm is generated in situ and therefore generally not known or available to the polymorphic engine during the wrapping process. Because the cipher algorithm is not known at the time of wrapping the newly created random cipher algorithm must be executed in order to correctly determine the result to apply to subsequent layers for providing additional encryption of the code segment . The random cipher algorithm in an exemplary embodiment of the present invention is mathematically symmetric such that the inverse of the algorithm decrypts the enciphered block.

Generally the ability of polymorphed code variants to remain securely protected will be at least partially dependent on the ability of the polymorphic application to resist hacking and or cracking attacks. In order to protect the polymorphic engine itself from debugging decompilation and or reverse engineering by inter alia analysis of memory snap shots a running line encryption method may also be employed. In an exemplary embodiment of the present invention running line encryption operates to protect the polymorphic engine while the engine s code resides in memory. This is generally accomplished by 1 encrypting the polymorphic algorithm s compiled instruction code 2 having only one line of the engine s encrypted instruction code decrypted for any given CPU instruction cycle and 3 re encrypting the instruction code after the instruction has been executed. As program execution flow moves the polymorphic engine s code through the stack to be processed by the CPU these instructions are decrypted just in time to be provided to the CPU for execution and then immediately re encrypted before the decryption and subsequent execution of the next line of instruction code.

In one exemplary embodiment of the present invention the running line encryption encoding process proceeds by 1 calculating the original opcode length 2 exclusive or ing XOR the first byte of the opcode using a key generated by a random number generation routine RNG 3 employing an encryption algorithm to encipher the first byte of the opcode and 4 sequentially stepping through the original opcode to repeat steps 1 3 on subsequent instructions. It will generally be understood by those skilled in the art that any encryption algorithm including but not limited to RSL public private key encryption etc. now known or hereafter derived by those skilled in the art may be used to encipher the opcode at step 3 . The runtime decoding operation of the running line encryption process in one exemplary embodiment proceeds by A decrypting the first byte of enciphered instruction B providing the decoded instruction to the CPU for processing C re encrypting the first byte of the instruction after processing and D sequentially stepping through the encrypted instruction code to repeat steps A C to execute the enciphered program.

In another exemplary embodiment the present invention also includes a virtual CPU instruction set pre processor that uses a matchable data structure which is randomly created when the polymorphed application initializes. The matchable data structure may comprise for example a look up table a database a symmetrical correlation algorithm an asymmetric correlation algorithm a functional algorithm a parametric algorithm a one way function or any method for correlating a first set of data with at least a second set of data now known or hereafter derived by those skilled in the art. In accordance with one exemplary embodiment the matchable data structure correlates instructions specific to the CPU s instruction set with virtual CPU opcodes generated by the polymorphic engine thus the original opcodes are replaced with nonsensical random context instructions. The virtual CPU pre processor in accordance with another exemplary aspect may function to further obscure polymorphed code by 1 calculating the original opcode length 2 using a matchable data structure to convert the original opcode into a random context instruction and 3 placing the random context instruction code on the same line as the original code so that correlation with the original code is generally accomplished by determining the location of the random context code in the instruction code stream. In a further exemplary aspect two matchable data structures may be used wherein one data structure correlates the original CPU instructions with random numbers and the other data structure correlates the random numbers of the first data structure with random context instruction codes. In yet a further exemplary aspect of the present invention a customized import table may be constructed from an original instruction code table whose contents are overwritten with erroneous information. Other methods now known or hereafter derived in the art may be used to correlate original CPU instructions with random context instruction codes in accordance with the present invention.

In yet another exemplary embodiment of the present invention another layer of protection is provided by a call mutation feature that operates with the polymorphic engine to further impede attempts to analyze and reverse engineer application code. Many applications and or operating systems use member calls to classes where the calls generally contain header data for the class member to function properly. Call mutation operates as a execution sequence redirector by 1 overwriting the header of the original call with erroneous data thereby effectively destroying the original call 2 rerouting the original call to a substitute call in which the substitute routine queries the stack pointer to determine where the substitute routine has been called from and 3 comparing the data obtained from the stack to for example a look up table in order to pass program execution control to an appropriate routine. In one exemplary aspect the overall function of the application is substantially the same but the header of the original call is destroyed and not easily traced. This process can be iteratively applied to generate multiple layers of protection and may also be applied to pointers as well.

In a more specific exemplary embodiment the call mutation routine scans polymorphed code for API calls such as for example CALL API NAME JMP API NAME MOV Register API NAME etc. This data is used to generate an extended instruction pointer EIP table in which EIP s as the offset from the base address are correlated to API pointers as shown in .

Decoding and resolution of the mutated calls may be accomplished in one exemplary embodiment of the present invention by 1 the polymorphic engine obtaining the EIP for the particular calling line of code 2 determining the destination address from the EIP look up table based on the EIP reference from the stack pointer 3 correlating the AIP place holder in the import address table 4 decrypting the AIP data 5 conditioning the stack frame so that control is passed back to the line of instruction code immediately following the EIP on the stack 6 determining if the program redirection is of the CALL or JMP type and if so performing a call to the original API and 7 determining if the program redirection is instead of the MOV type and if so returning the original value in the appropriate register with minimal or no further execution of a call.

In yet another exemplary embodiment a secure output display interface for concealing data may also be used to protect users from applications that may use operating system calls to capture data by placing a hook interface between OS routines and a hardware input device i.e. from a keyboard mouse light pen etc. . This is generally accomplished by capturing interpreting and modifying device input before it is made available to other OS processes. shows a prior art edit textbox which bidirectionally communicates with the operating system and may be directly interrogated to provide the original data from the input device corresponding to the displayed textbox data which is concealed in this example by asterisk characters. however depicts a system and method in accordance with one embodiment of the present invention in which the edit textbox is protected from bidirectional communication with the operating system . This is generally accomplished with a secure hook capture display interface which receives data from an input device and masks that data from the operating system .

The hook captured input is enciphered and hidden from the OS . For example a user password ABC to be entered into a textbox can be hook captured from for example the keyboard device driver enciphered and stored and then the hook routine passes literal asterisks characters to the textbox . Queries from other OS routines to the textbox object would return the series of asterisks characters placed there by the hook routine and not the literal text ABC entered by the user. In one of the various exemplary aspects of the present invention the hook capture routine would help to secure user input to and or from the polymorphed application by modifying display device output as well as corresponding literal data object content.

In a further representative aspect of the present invention layered security methods such as for example the described exemplary embodiment in accordance with steps may be used to detect for example the presence and or operation of a computer virus. Moreover it will be apparent to those skilled in the art that while each security layer steps may individually provide suitable protection for the execution of a computer application the combination of security layers and the interoperability of the component features of the same offers substantial benefits with respect to the discrete implementation of any single component security feature by itself.

An exemplary application of the security features of the present invention described herein is directed to a try before you buy implementation. Generally this may be accomplished in one representative aspect by allowing the software developer to insert a macro or marker into the original source code Step xSecure Start . . . xSecure End which instructs the polymorphic engine wrapper to encrypt the designated code block Step DO Cool Stuff . . . to avoid execution without a valid key. The source code is then compiled to produce executable code . During polymorphic wrapping an encryption method is selected which is suitably adapted such that brute force decryption attempts would generally not be practicable with industry standard equipment. When the protected application is formally licensed and or registered read purchased a key is supplied to the user which is mathematically customized to the signature of the application s operating environment. A fingerprint key may be constructed as a function of for example software hardware system component information network connectivity data user identification data CPU serial numbers etc. or any other information now known or hereafter derived by those skilled in the art. The key is combined with a calculated fingerprint signature and the protected code block decrypted using the resulting combination . If the application is ported to a different machine or executed without a valid key the decryption will fail and for example a warning may be displayed indicating that the software is operating in a demonstration or trial use mode.

In another exemplary aspect of an embodiment of the present invention the program stack may be manipulated to further subvert attempts to reverse engineer application code. generally depicts generic prior art relationships existing between application code application data and the program stack . however shows an exemplary embodiment of the present invention having different relationships among these same components application code application data and the program stack . A first context Context A see and is generally comprised of the application code and the application data in both the prior art embodiment and the present exemplary inventive embodiment. Additionally a second context Context B see and is generally comprised of the program stack in the prior art embodiment and the exemplary inventive embodiment as well. One difference between the prior art and the present exemplary inventive embodiment however involves what happens when a memory dump or memory snap shot occurs in an attempt to address and or reverse engineer the code.

In the prior art embodiment interrogation of memory will generally produce only the information corresponding to Context A but the information of Context B is contained in the data of Context A by virtue of the PUSH POINTER MSG instruction See . Therefore the prior art code is susceptible to reverse engineering. In accordance with one aspect of the present exemplary embodiment when a memory interrogation of Context A occurs substantially all information contained in Context B is lost in such a fashion that the information generally cannot be regenerated from the contents of Context A . This occurs because the polymorph wrap process dynamically replaces the original code with a new call which is written directly to the stack. In other words the call to the unwrapping code of the polymorphic wrapper application is placed on the stack and generally never in the code of the protected application itself. The code on the stack therefore is generated in situ and concurrent with the removal of the original code. In another exemplary embodiment of the present invention the original code may or may not be encrypted. In yet another exemplary embodiment of the present invention the system and method depicted in may also be used for API call redirection as well.

In still other exemplary embodiments the system of the present invention may include a host server or other computing systems including a processor for processing digital data a memory coupled to said processor for storing digital data an input digitizer coupled to the processor for inputting digital data an application program stored in said memory and accessible by said processor for directing processing of digital data by said processor a display coupled to the processor and memory for displaying information derived from digital data processed by said processor and a plurality of databases said databases including data that could be used in association with the present invention. The database may be any type of database such as relational hierarchical object oriented and or the like. Common database products that may be used to implement the database include DB2 by IBM White Plains N.Y. any of the database products available from ORACLE.RTM. CORPORATION Redwood Shores Calif. MICROSOFT.RTM. ACCESS by MICROSOFT.RTM. CORPORATION Redmond Wash. or any other database product. The database may be organized in any suitable manner including for example data tables look up tables or any matchable data structures now known or hereafter derived in the art.

Association of certain data may be accomplished through any data association technique known and practiced in the art. For example the association may be accomplished either manually or automatically. Automatic association techniques may include for example a database search a database merge GREP AGREP SQL and or the like. The association step may be accomplished by a database merge function for example using a key field . A key field partitions the database according to the high level class of objects defined by the key field. For example a certain class may be designated as a key field in both the first data table and the second data table and the two data tables may then be merged on the basis of the class data in the key field. In this embodiment the data corresponding to the key field in each of the merged data tables is preferably the same. However data tables having similar though not identical data in the key fields may also be merged by using AGREP for example.

The present invention may be described herein in terms of functional block components screen shots optional selections and various processing steps. It should be appreciated that such functional blocks may be realized by any number of hardware and or software components configured to perform the specified functions. For example the present invention may employ various integrated circuit components e.g. memory elements processing elements logic elements matchable data structures and the like which may carry out a variety of functions under the control of one or more microprocessors or other control devices. Similarly the software elements of the present invention may be implemented with any programming or scripting language such as for example C C Java COBOL assembler PERL eXtensible Markup Language XML etc. or any programming or scripting language now known or hereafter derived in the art with the various algorithms being implemented with any combination of data structures objects processes routines or other programming elements. Further it should be noted that the present invention may employ any number of conventional techniques for data transmission signalling data processing network control and the like. Still further the invention could be used to detect or prevent security issues with a client side scripting language such as JavaScript VBScript or the like. For a basic introduction of cryptography please review a text written by Bruce Schneider entitled Applied Cryptography Protocols Algorithms And Source Code In C published by John Wiley Sons second edition 1996 which is hereby incorporated by reference.

It should be appreciated that the particular implementations shown and described herein are illustrative of the invention and its best mode and are not intended to otherwise limit the scope of the present invention in any way. Indeed for the sake of brevity conventional data networking application development and other functional aspects of the systems and components of the individual operating components of the systems may not be described in detail herein. Furthermore the connecting lines shown in the various figures contained herein are intended to represent exemplary functional relationships and or physical couplings between the various elements. It should be noted that many alternative or additional functional relationships or physical connections may be present in a practical system.

It will be appreciated that many applications of the present invention could be formulated. One skilled in the art will appreciate that the network may include any system for exchanging data such as for example the Internet an intranet an extranet WAN LAN satellite communications and or the like. It is noted that the network may be implemented as other types of networks such as an interactive television ITV network. The users may interact with the system via any input device such as a keyboard mouse kiosk personal digital assistant handheld computer e.g. Palm Pilot.RTM. cellular phone and or the like. Similarly the invention could be used in conjunction with any type of personal computer network computer workstation minicomputer network via a leased line T1 D3 etc. . Such communication methods are well known in the art and are covered in a variety of standard texts. See e.g. GILBERT HELD UNDERSTANDING DATA COMMUNICATIONS 1996 hereby incorporated by reference.

As will be appreciated by one of ordinary skill in the art the present invention may be embodied as a method a system a device and or a computer program product. Accordingly the present invention may take the form of an entirely software embodiment an entirely hardware embodiment or an embodiment combining aspects of both software and hardware. Furthermore the present invention may take the form of a computer program product on a computer readable storage medium having computer readable program code means embodied in the storage medium. Any suitable computer readable storage medium may be utilized including hard disks CD ROM optical storage devices magnetic storage devices and or the like.

Data communication is accomplished through any suitable communication means such as for example a telephone network Intranet Internet point of interaction device point of sale device personal digital assistant cellular phone kiosk etc. online communications off line communications wireless communications and or the like. One skilled in the art will also appreciate that for security reasons any databases systems or components of the present invention may consist of any combination of databases or components at a single location or at multiple locations wherein each database or system includes any of various suitable security features such as firewalls access codes encryption de encryption compression decompression and or the like.

The present invention is described herein with reference to screen shots block diagrams and flowchart illustrations of methods apparatus e.g. systems and computer program products according to various aspects of the invention. It will be understood that each functional block of the block diagrams and the flowchart illustrations and combinations of functional blocks in the block diagrams and flowchart illustrations respectively can be implemented by computer program instructions. These computer program instructions may be loaded onto a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute on the computer or other programmable data processing apparatus create means for implementing the functions specified in the flowchart block or blocks.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including instruction means which implement the function specified in the flowchart block or blocks. The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions specified in the flowchart block or blocks.

Accordingly functional blocks of the block diagrams and flowchart illustrations support combinations of means for performing the specified functions combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each functional block of the block diagrams and flowchart illustrations and combinations of functional blocks in the block diagrams and flowchart illustrations can be implemented by either special purpose hardware based computer systems which perform the specified functions or steps or suitable combinations of special purpose hardware and computer instructions.

In the foregoing specification the invention has been described with reference to specific embodiments. However it will be appreciated that various modifications and changes can be made without departing from the scope of the present invention as set forth in the claims below. The specification and figures are to be regarded in an illustrative manner rather than a restrictive one and all such modifications are intended to be included within the scope of present invention. Accordingly the scope of the invention should be determined by the appended claims and their legal equivalents rather than by merely the examples given above. For example the steps recited in any of the method or process claims may be executed in any order and are not limited to the order presented in the claims.

Benefits other advantages and solutions to problems have been described above with regard to specific embodiments. However the benefits advantages solutions to problems and any element s that may cause any benefit advantage or solution to occur or become more pronounced are not to be construed as critical required or essential features or elements of any or all the claims. As used herein the terms comprises comprising or any other variation thereof are intended to cover a non exclusive inclusion such that a process method article or apparatus that comprises a list of elements does not include only those elements but may include other elements not expressly listed or inherent to such process method article or apparatus. Further no element described herein is required for the practice of the invention unless expressly described as essential or critical . Other combinations and or modifications of the above described structures arrangements applications proportions elements materials or components used in the practice of the present invention in addition to those not specifically recited may be varied or otherwise particularly adapted by those skilled in the art to specific environments manufacturing or design parameters or other operating requirements without departing from the general principles of the same.

