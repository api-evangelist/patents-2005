---

title: Method and system for displaying animation with an embedded system graphics API
abstract: An animation file player can display animation files with an embedded system graphics application programming interface (graphics API). In an example implementation, an animation file comprises a Flash® animation file such as, a Shockwave Flash® animation file, and the embedded system graphics API comprises an OpenGL®|ES graphics API. The present invention is not intended to be so limited, and other types of animation files and embedded system graphics APIs can be used.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07911467&OS=07911467&RS=07911467
owner: Hooked Wireless, Inc.
number: 07911467
owner_city: Los Altos
owner_country: US
publication_date: 20051230
---
Animation is increasingly popular in a variety of applications. No longer restricted to film animation is now implemented in many digital forms and is found on the World Wide Web and in many multimedia applications. A variety of animation files and animation file players are available. Animation of varying length can be displayed on computers as stand alone movies and video clips or as part of web pages and in multimedia presentations. The complexity of an animation and the amount of graphics processing power required to generate the animation can vary widely depending upon a particular application.

One type of animation file player currently in widespread use is the Flash or Shockwave Flash SWF animation file player available from Adobe Systems Incorporated formerly Macromedia Inc. . SWF file players play a compiled form of Flash animation files. For convenience any such Flash or Shockwave Flash SWF animation file players are referred to herein as SWF file players. Associated files that can be played by SWF file players are referred to herein as Flash animation files or simply Flash animation. Flash animation files were designed to hold relatively simple vector and bitmap animations in small file sizes. Accordingly Flash animation files have been used widely in web pages to provide simple animations such as rotating logos walking figures and dancing text. One common SWF file player is a desktop personal computer player typically installed as a Web Browser Plugin.

Graphics application programming interfaces APIs are now widely used by many computer graphics applications such as computer games flight simulators modeling applications etc. and support hardware acceleration of graphics rendering. Graphics APIs such as OpenGL API available from SGI and DirectX API available from Microsoft Corp. are designed to run on personal computers or other computing devices with significant processing and display resources. Newer graphics APIs such as an OpenGL ES API are now available that are designed to run on embedded systems having limited resources such as a mobile telephone having a smaller display resolution less memory and less processing power than a personal desktop computer.

A SWF file player however is widely believed not to take advantage of any graphics hardware acceleration or graphics application programming interface API. Possible technical and business motivations not to use the graphics hardware acceleration or graphics APIs include historical portability since typical desktop personal computers did not have reliable graphics support when the SWF file player was first developed rendering accuracy and a desire to maintain careful control over the behavior of the SWF player. At the same time the lack of use of any hardware acceleration API has been noted and bemoaned by producers of Flash animations and the consumers of Flash animations.

Some specialized alternative SWF file players have recently been released that use an OpenGL API a considerably larger heavyweight graphics API than an OpenGL ES API. The full blown OpenGL API however cannot be easily implemented on a resource constrained embedded system such as a mobile phone. Further these alternative OpenGL based SWF players make use of features not found in the smaller lightweight OpenGL ES graphics API such as the begin end paradigm of geometric data specification and the texgen method of automatically generating texture coordinates from vertex data thereby making them incompatible with devices having an OPENGL ES API. Often the motivation for these alternative players is to have a SWF player on a desktop computing platform not supported commercially by Macromedia. These alternative players have required the use of the OpenGL graphics API both to accelerate the rendering process and also to ease the programming burden.

The inventors recognized that a file player is needed that displays animation on an embedded system and makes use of an embedded system graphics application programming interface graphics API .

The present invention solves the above problems and allows the display or play back of animation files on an embedded system and makes use of an embedded system graphics API. A file player and animation techniques are provided which allow display of animation with an embedded system graphics API on an embedded system. This can include an embedded system with or without graphics hardware acceleration. Any type of embedded system can be used including but not limited to a mobile phone kiosk game console vehicle navigation system or other type of embedded computing device.

In one embodiment an animation file player is provided that can display animation on a mobile device having a graphics subsystem. In particular the animation file player can display Flash animation files with an embedded system graphics API. In an example implementation an animation file comprises a vector animation file such as a Shockwave Flash SWF animation file and the embedded system graphics API comprises a mobile device graphics API such as an OpenGL ES graphics API. The present invention is not intended to be so limited and other types of animation files and embedded system graphics APIs can be used including but not limited to a Java J2ME implementation using JSR 239 or JSR 184 as the graphics API or a Microsoft Direct3D Mobile graphics API.

In one embodiment the animation file player includes a parser and a converter. The parser parses an animation file to obtain animation information that includes at least one of image data and object shape data associated with a frame in the animation. The converter converts the animation information to graphics rendering information. The graphics rendering information can be processed by the graphics subsystem of the graphics enabled mobile device.

An animation file such as a Flash animation file is a series of frames in a timeline of an animation. Each frame can have layers that are composited to make the final result. A layer often contains image data or object shape data. According to a further feature for image data such as bitmap data the converter reduces the image data to texture data and generates polygons having texture coordinates mapped to the texture data.

According to a further feature for object shape data the converter converts object shape data to a collection of polygons having an area approximating the object shape area. In one example the converter tessellates the object shape data at an acceptable degree of linear approximation in accordance with at least a display resolution of the graphics enabled mobile device to obtain tessellated data. Object space data from a previous frame can also be re used or morphed to reduce calculation work.

In a further embodiment an embedded system including but not limited to a graphics enabled mobile device is provided which includes a display a memory for storing an animation file an embedded system graphics API and an animation file player that converts animation information in the animation file to graphics rendering information and passes the graphics rendering information to the embedded system graphics API. The embedded system graphics API processes the graphics rendering information to obtain pixel data and outputs the pixel data to the display for display on the embedded system.

In a still further embodiment a method for displaying animation through an embedded system graphics API on an embedded system is provided. The method includes parsing an animation file to obtain animation information that includes at least one of image data and object shape data associated with frames in the animation converting the animation information to graphics rendering information processing the graphics rendering information with the embedded system graphics API to obtain pixel data and displaying the pixel data to show the animation.

Further embodiments features and advantages of the present invention as well as the structure and operation of the various embodiments of the present invention are described in detail below with reference to the accompanying drawings.

The present invention will be described with reference to the accompanying drawings. The drawing in which an element first appears is typically indicated by the leftmost digit s in the corresponding reference number.

While specific configurations and arrangements are discussed it should be understood that this is done for illustrative purposes only. A person skilled in the pertinent art will recognize that other configurations and arrangements can be used without departing from the spirit and scope of the present invention. It will be apparent to a person skilled in the pertinent art that this invention can also be employed in a variety of other applications.

The present invention allows the display or playback of animation files on an embedded system and makes use of an embedded system graphics application programming interface. A file player and animation techniques are provided which allow display of animation with an embedded system graphics application programming interface on an embedded system. This can include an embedded system with or without graphics hardware acceleration.

For the sake of clarity embodiments of the present invention are described further below with respect to an example embedded system comprising a mobile device. The present invention is not so limited and embodiments can include any type of embedded system including but not limited to a mobile phone kiosk game console vehicle navigation system or other type of embedded computing device as would apparent to a person skilled in the art given this description.

Animation file player can play animation on graphics enabled mobile device . The term play with respect to animation is used broadly herein to refer to display playback or any other type of output provided for a user to perceive animation content. Animation file player can be implemented in software firmware hardware or any combination thereof.

In an embodiment animation file is any type of animation file including but not limited to a Flash animation file made up of a series of frames 1 to n in a timeline of an animation see . Each frame can have layers such as foreground and background layers that are composited to make the frame. A layer often contains image data and or object shape data. Animation file can include but is not limited to an animation made up of keyframes and interpolated frames in between the keyframes. Header data and other data fields can be added.

In one embodiment as shown in animation file player can include a parser and converter . Parser parses animation file to obtain animation information that includes at least one of image data and object shape data associated with a frame in the animation. Converter converts the animation information to graphics rendering information. The graphics rendering information can be processed by a graphics subsystem of graphics enabled mobile device .

It is helpful to describe animation file player further with respect to an example layered architecture for graphics enabled mobile device . Next the operation of animation file player is described with reference to flowcharts and an example animation . This layered architecture operation and example is illustrative and not necessarily intended to limit the present invention.

In an embodiment mobile device is a graphics enabled mobile device having an architecture . Architecture includes an application layer embedded system graphics application programming interface graphics API operating system and hardware .

In an embodiment animation file player can be included in application layer . Graphics API can be any type of embedded system graphics API including but not limited to an OpenGL ES graphics API available from The Khronos Group Inc. a Java J2ME implementation using JSR 239 or JSR 184 as the graphics API or a Microsoft Direct3D Mobile graphics API. Other similar proprietary or open graphics APIs may be used as they become available as would be appreciated by a person skilled in the art given this description.

Operating system can be any type of operating system for a mobile device including but not limited to Symbian Microsoft Windows Mobile Palm OS or Apple operating environment for iPod devices.

As shown in further detail in hardware can include a processor coupled to memory graphics subsystem and communication interface . Graphics subsystem further includes a graphics processor and memory . Memory can include texture memory for storing texture data and a frame buffer for storing pixel data output from graphics processor . A display is coupled to graphics subsystem to allow display of output pixel data. Communication interface is any type of communication interface that allows data to be communicated to and from graphics enabled mobile device . In one example communication interface is a wireless interface supporting voice and data communication over a network. Graphics subsystem is illustrative and not intended to limit the present invention. Graphics subsystem can include any type of renderer software or hardware and may include graphics acceleration hardware. Alternatively graphics subsystem need not have any graphics acceleration hardware for those embedded systems where such hardware is not desired to be included.

In an embodiment animation file player is an application in application layer . File player runs in graphics enabled mobile device on top of graphics API and operating system . In this way file player can access or leverage functionality in graphics API to perform graphics data processing. For example graphics rendering information such as commands and or data can be passed to graphics API to carry out desired rendering. Such rendering can then be accelerated with graphics hardware depending upon whether the embedded system includes graphics acceleration hardware. File player can also access or leverage functionality in operating system as well. In this way file player may access system resources or memory in mobile device through operating system . File player can also be manually or automatically selected to run through operating system or otherwise executed directly.

The operation of animation file player will be described further with respect to a method for display for animation file information and an example animation .

In step an animation file is stored in memory in mobile device . Such storage can be permanent or temporary and can include storage in any type of memory or buffer. The animation file can be downloaded through communication interface over a network pre stored in mobile device or otherwise loaded buffered or streamed into mobile device .

Animation file can be any type of file having data to be animated. The data in the file can include but is not limited to any type of graphics data static and or dynamic multimedia data audio data video data text data or combination thereof. Any type of file format compatible with animation can be used including but not limited to Flash animation file format such as a Flash animation file like a SWF file in a format promulgated by Adobe formerly Macromedia Inc. . Other animation file formats for display of animation can be used including but not limited to any vector animation file format.

Data representing animation is stored in an animation file . In particular animation file includes digital data defining a header and frame data for a series of frames 1 to N. Each frame can include data that defines a scene for a frame to be animated. In the case of Flash animation such as a SWF file this frame data can include image data such as bitmap s and object shape data such as vector data defining lines and curves B spline curve data or other data defining shapes of object s . Other fields and data can be used depending upon a particular file format specification.

In step animation file player converts stored animation file to graphics rendering information. Step is described in further detail below with reference to .

In step animation file player passes the graphics rendering information to graphics subsystem . This includes passing appropriate graphics rendering information to graphics API .

In step graphics subsystem processes the received graphics rendering information to obtain output pixel data. In the case of an OpenGL ES graphics API output pixel data for the animation converted by file player is output to a frame buffer in memory .

In step the animation is played on display on mobile device . In this way animation content in an original animation file not designed for graphics accelerated mobile devices can be converted and played on graphics enabled mobile device . File player converts animation files such that they can play animation on a limited resolution display of a mobile device and leverage graphics accelerated hardware if available on a mobile device .

In step parser parses frame data in an animation file stored in step . In the example of Flash animation parser parses image data and or object shape data from a sequence of frames in the animation file.

In step file player stores the parsed image data and or object shape data from a sequence of frames also called a timeline into a temporary animation data structure.

Converter then carries out step on the parsed and stored data in the temporary animation data structure. For each frame in an animation timeline converter processes the parsed image data and or object shape data loop steps .

For image data loop converter reduces image data to image data texture step and generates polygons and attribute data mapped to the image data texture step . For example consider a bitmap representing an image such as sky in a scene in frame . Such a bitmap may have been originally in a background layer of a Flash animation file. In step converter reduces the bitmap to a texture with the sky image data. In step converter generates a polygon e.g. a quadrilateral made up of two triangles also called a four vertex triangle strip . Vertices of the two triangles are assigned attribute data e.g. texture coordinates that map to the sky texture .

For object shape data loop converter converts parsed object shape data to a set of polygons and attributes data such as color and texture coordinates . The set of polygons have an area that approximates the object shape data step . In one implementation converter includes a tessellator to tessellate the object shape data into a set of polygons e.g triangles having a configuration approximating the object shape data. In particular object shape data in a frame is tessellated to an acceptable degree of linear approximation in accordance with the mobile device display resolution and other performance criteria such as available computing power complexity of animation scenes etc. . Any known or future developed tesselation algorithm can be used. In one embodiment the tesselation work in step is carried out for object shape data in each frame of an animation.

Incases involving a SWF file and OPEN GL ES API a SWF file object shape data can also have a bitmap mapped to it. Since the Flash shape data does not have texture coordinates per se instead it has a bitmap which is fixed to geometric coordinate data with a linear mathematical mapping. Converter then translates the linear mathematical mapping to the OpenGL ES API. According to a further feature converter reuses the geometric coordinate data x and y as texture coordinates and uses the OpenGL ES API capability of specifying a texture transform matrix to perform the required linear mapping from geometric coordinates to texture coordinates.

Once image data and object shape data for each frame have been processed and loop completes control proceeds to step . Converter then builds graphics rendering information for graphics API that includes the textures polygons and attribute data generated in steps for an animation sequence. For example in the case where graphics API comprises an OpenGL ES API converter builds graphics rendering information that includes the textures polygons and attribute data generated in steps for an animation sequence that can be rendered as an animation by the OpenGL ES API and displayed on display of mobile device .

Step and step are described in even further detail below in section with reference to an example implementation of file player involving SWF files and an OpenGL ES API.

According to a further embodiment an optimization is provided that reduces tessellation calculation work. is a flowchart diagram that shows the steps of an optimization of step . Converter first compares object shape data in a current frame with object shape data in a previous frame step . For instance ball changes shape at frame compared to previous frame . On the other hand base does not change shape significantly between frames and

Based on the result of this comparison a check is made to determine whether tessellation is needed step . If object shape has not changed at all or insignificantly between frames then tessellation is not needed and control passes to step . In this case converter can simply re use prior tessellated data from the previous frame and avoid unnecessary tessellation work. Such re use can be simply copying prior tessellated data or applying a geometric transformation to the prior tessellated data to obtain new tessellated data for the object shape data in the current frame. For example one or more transformation matrices for scaling rotating and translating the prior tessellated object data can be applied. More complicated morphing or other types of transformation can also be carried out. In this way new object shape data can be obtained for a current frame of an animation without necessarily having to carry out the tessellation work for each frame. In the case of Flash animation where motion tweening is used between frames as in the case of the ball moving but not changing shape no re tessellation is needed.

Of course steps are an optional optimization and can be omitted in applications where tessellation is carried out for each frame of an animation as described earlier. Control then proceeds back to step .

In step when object shape data has changed significantly in a current frame or appears for the first time in a current frame control proceeds to step . In step converter tessellates the object shape data into a set of polygons e.g triangles having an area approximating the object shape data. In particular object shape data in a frame is tessellated to an acceptable degree of linear approximation in accordance with the mobile device display resolution and other performance criteria such as available computing power complexity of animation scenes etc. . Any known or future developed tesselation algorithm can be used. Control then proceeds back to step . For example in the case of Flash animation where shape tweening is used between frames as in the case of the ball changing shape at impact on base re tessellation is needed.

The operation of converter and steps are described further with reference to an example implementation of file player that can play a SWF file and render graphics with an OpenGL ES API. This example is illustrative of advantages of an example implementation used in combination with SWF files and OpenGL ES API and is not intended to limit the present invention.

Consider that the main geometric elements in a SWF file are images or bitmaps which can be linearly transformed typically translation scale and rotation and shapes composed of B spline curves or simple vector data which can also be scaled and rotated. OpenGL ES meanwhile allows the efficient rendering of textured triangles in 3D or 2D. In this way file player according to an embodiment basically reduces the images or bitmaps in a SWF file to suitable textures in OpenGL ES then displays them with a pair of suitably transformed triangles arranged as a quadrilateral as described above with respect to steps and converts the shape information both B spline curves and simple vectors to a collection of suitably transformed and possibly textured triangles as described above with respect to steps .

One approach to convert object shape data in step is to approximate a shape defined by a continuous B spline curve with a set of triangles and then use the OpenGL ES API to render the set of triangles. For example an animated two dimensional 2D SWF shape can be rendered on display as follows. First animate the shapes B spline curve control data as defined in the SWF file to the current time value. This step may be common to all SWF players whether they use OpenGL OpenGL ES or a proprietary software based renderer. Second triangulate the area of the B spline curve defined shape at a degree of linear approximation that is acceptable given the scale of the object with respect to the resolution of the display and the feedback from performance monitoring. A variety of triangulation algorithms are available here. As long as the algorithm is more or less on the order of N log N in running time complexity where N is the number of vertices considered the algorithm will suffice. In one example a scan line or plane sweep style algorithm may be used. This algorithm generates slabs of trapezoids. The trapezoids are trivially decomposed into a pair of triangles. Alternatively more complex triangulation algorithms can be used. In an example the triangulation algorithm Triangle A Two Dimensional Quality Mesh Generator and Delaunay Triangulator created at Carnegie Mellon University version 1.6 released Jul. 28 2005 available for download at http www.cs.cmu.edu quake triangle.html can be used.

Once the triangulation or tesselation of the shape data is complete the triangles must be prepared for efficient display using the OpenGL ES API. The triangles should be arranged in triangle strips or fans or indexed triangle lists. The triangulation algorithm in use lends itself to triangle strips. A set of triangle strips with similar attribute data such as color and texture is typically referred to as a Mesh. Many shapes have a border and this can be converted to line strips in a similar but slightly more simple manner than the triangulation of shape data. Meshes can be rendered using the OpenGL ES API entry point glDrawArrays for Triangle Strips or Line Strips or glDrawElements for indexed triangles.

It may be possible to skip re tesselating at each time step and improve efficiency by transforming the tesselation from an earlier time step via the matrix transform state in OpenGL ES API. This may even be possible in cases where the curves morph as long as the topology of the curve remains similar. According to one advantage an animation file player capable of being run on mobile phones or other embedded system devices is provided at a moment in time where there are increasingly large numbers of internet capable phones with OpenGL ES API or other embedded system graphics APIs coupled with a large number of SWF files. Embodiments of the present invention then allow such SWF files to be viewed either as components of websites or as entertainment in their own right with an embedded system such as a phone.

According to a further advantage an animation file player is provided which can also be used with an embedded system provided with a graphics subsystem such as a software and or hardware renderer if available. This is especially advantageous in certain applications since there exist many SWF files that can only be viewed on an embedded system having limited resources if opportunities to gain performance are taken. Otherwise the playing of animation on an embedded system like a mobile phone may consume too many computational resources and the animation will run too slowly to be interesting. Further many mobile phones are projected to have hardware to accelerate graphics operations. These phones will also include an embedded system graphics API such as an OpenGL ES API a Java graphics API or Direct3D Mobile graphics API provided to give programmers access to that hardware acceleration. Accordingly certain embodiments of the present invention can meet a particular need for a file player that can display animation in SWF files with graphics hardware acceleration on a mobile phone.

These advantages are illustrative of certain embodiments and not intended to limit the present invention.

While various embodiments of the present invention have been described above it should be understood that they have been presented by way of example only and not limitation. It will be apparent to persons skilled in the relevant art that various changes in form and detail can be made therein without departing from the spirit and scope of the invention. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

