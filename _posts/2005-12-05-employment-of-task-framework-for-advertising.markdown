---

title: Employment of task framework for advertising
abstract: A task-based advertisement system and method are provided. The system employs high-order concepts (e.g., booking a flight, checking stock quotes etc.) embodied in “task(s)” which can then be bid upon by advertisers. The task(s) employed by the system are based upon a semantic solution to a natural-language query. The system includes a search engine that is capable of serving content in response to user query(ies). The system further includes a task server that can include hardware and/or software to retrieve task(s) in response to user query(ies). The task(s) retrieved by the task server can be presented to advertiser(s) who can bid on the task(s).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07831585&OS=07831585&RS=07831585
owner: Microsoft Corporation
number: 07831585
owner_city: Redmond
owner_country: US
publication_date: 20051205
---
This application is related to co pending U.S. patent application Ser. No. 11 270 407 filed Nov. 9 2005 and entitled ADAPTIVE TASK FRAMEWORK co pending U.S. patent application Ser. No. 11 270 393 filed Nov. 9 2005 and entitled ADAPTIVE TASK FRAMEWORK and co pending U.S. patent application Ser. No. 11 290 076 filed Nov. 30 2005 and entitled ADAPTIVE SEMANTIC REASONING ENGINE The entirety of the aforementioned applications is hereby incorporated by reference.

Human languages are rich and complicated including huge vocabularies with complex grammar and contextual meaning. Machine interpretation of human language even in a very limited way is an extremely complex task and continues to be the subject of extensive research. Providing users with the ability to communicate their desires to an automated system without requiring users to learn a machine specific language or grammar would decrease learning costs and greatly improve system usability. However users become quickly frustrated when automated systems and machines are unable to interpret user input correctly resulting in unexpected results.

Natural language input can be useful for a wide variety of applications including virtually every software application with which humans are intended to interact. Typically during natural language processing the natural language input is separated into tokens and mapped to one or more actions provided by the software application. Each application can have a unique set of actions. Consequently it can be both time consuming and repetitive for software developers to draft code to interpret natural language input and map the input to the appropriate action for each application.

The Internet in particular has provided users with a mechanism for obtaining information regarding any suitable subject matter. For example various web sites are dedicated to posting text images and video relating to world national and or local news. A user with knowledge of a Uniform Resource Locator URL associated with one of such web sites can simply enter the URL into a web browser to be provided with the web site and access content thereon. Another conventional manner of locating desired information from the Internet is through utilization of a search engine. For instance a user can enter a word or series of words into a search field and thereafter initiate the search engine e.g. through depression of a button one or more keystrokes voice commands . . . . The search engine then utilizes search algorithms to locate web sites related to the word or series of words entered by the user into the search field and the user can then select one of the web sites returned by the search engine to review content therein.

As more and more people have begun to utilize the Internet it has become apparent that revenue opportunities exist for small and large businesses alike. For instance many retail companies utilize the Internet to sell goods online thereby reducing costs associated with managing and maintaining a store location providing an ability to centralize inventory and various other similar benefits that result in decreased costs that are passed on to customers. Given this increased use of the Internet for generating business and or revenue it has also become apparent that the Internet can be utilized as an advertising mechanism. In one example an individual who enters the key word flower into a search engine may be interested in purchasing flowers thus it is beneficial for a company that sells flowers to advertise to that user at the point in time that the user is searching for the aforementioned term. Oftentimes users will see the advertisements and click on such advertisements to purchase flowers thereby creating business for the flower retailer. Furthermore the search engine is provided with additional revenue by selling advertisement space for a particular period of time to the flower retailer when the term flower is utilized as a search term. In a similar example a sporting goods company may wish to display advertisements on a web site related to sports and can purchase advertising space for a limited amount of time on the web site. Again the buying and selling of advertising space can lead to increased revenue for an owner of the web site as well as the advertiser.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

A task based advertisement system and method are provided. The system employs high order concepts e.g. booking a flight checking stock quotes etc. embodied in task s which can then be bid upon by advertisers. Conventionally advertisements have been relatively static with respect to a user s query so that a query such as flights from Boston to Seattle surfaces ads that correspond to keyword s purchased by the advertiser but are not derived semantically from the query. To the contrary the task s employed by the system are based upon a semantic solution to a natural language query. Thus the system can lower the barrier to entry for advertiser s since instead of coming up with a comprehensive list of keyword s the advertiser s can bid on tasks instead. Additionally with the system user s can enter more complex queries and obtain better results than with conventional keyword based system s . Further advertiser s can provide material that is targeted to the user based upon the semantic content in the task e.g. user provided with more relevant content .

The system includes a search engine that is capable of serving content in response to user query ies e.g. Internet search engine . The system further includes a task server that can include hardware and or software to retrieve task s in response to user query ies . The task s retrieved by the task server can be presented to advertiser s who can bid on the task s . For example the advertiser s can have a financial incentive to provide better content to user s .

The task server provides the search engine with a standardized method for interpreting natural language input. A task as used herein describes and defines a fundamental unit of action relevant to user. Task s may be defined using extended markup language XML databases text files or in any other suitable manner.

The search engine can receive any manner of natural language input e.g. handwritten text tablet input speech and typed text . The search engine can process the natural language input to generate a query for processing by the task server e.g. a simple string of text characters . The task server selects one or more tasks based at least in part upon the query. The task server can provide the task along with associated metadata and slot information to describe an action to the search engine.

Overall the task server is responsible for receiving an input query finding a set of likely task s given the input query filling out slot values given a task and the input query retrieving the most likely tasks with the most like slot values. Optionally the task server can receive user feedback data to update model s .

In one example the system is based on a closed set of tasks e.g. predefined tasks . One or more advertiser s bid on task s . In another example in addition to a set of predefined tasks advertiser s can bid on and construct their own tasks for example when a suitable task does not exist.

An advantage of bidding on a task rather than keyword s as in conventional systems is that keyword bidding requires advertisers to bid on every possible city. With conventional systems advertiser s are not presented with contextual information to understand the difference between arrival and departure cities. With tasks advertiser s are presented with contextual information which can assist the advertiser s to target their advertisement s to particular task s .

In response to a query received from a user the task server returns a list of the most likely task s given the query to the search engine. The search engine can then provide the task s to the advertiser s for review and bidding. Thereafter zero one or more advertiser s can bid on the task s for example with indicia that the particular advertiser is willing to pay for the right to display an ad based at least in part on the task s e.g. amount of money credits and the like .

The advertiser s can also provide information regarding advertisement s that are to be displayed to the user in the event that the advertiser is a successful bidder on the task. For example the advertiser can use an identifier to select from stored advertisements accessible by the search engine. Additionally and or alternatively the advertiser can dynamically provide advertisement s that are to be displayed to the user in the event that the advertiser is a successful bidder on the task.

When the task is returned from the task server the advertisement may not be ready for display for various reasons. In one example the task can be an XML packet which is sent to advertiser s by the search engine. Advertiser s that desire to bid on the task can then send back a data packet e.g. HTML that includes information to be displayed to the user in the event the advertiser is a successful bidder. The advertisers can then return an HTML blob containing whatever information they deem relevant given the task. For example a particular advertiser might include a banner ad with parameters embedded in the links so that the site can be pre populated with information if the user clicks it. A second advertiser might query their database to return instances of flights so that they can display flights leaving tomorrow starting at 299 or display a list of flights to the user. Yet other advertisers might choose not to display anything either because supply is limited or for other reasons. Significantly the advertiser controls the content that s display in this example.

In another example a link e.g. URL can be constructed by the search engine without having to contact the advertiser s directly. In this example the the advertiser is responsible for filling out a template such that the results cab be rendered by the search engine. Significantly in both examples the advertiser can be notified about the semantics of the query and therefore is able to provide more targeted advertisements.

Optionally the task retrieval process of the task server can improve with user feedback. For example feedback can be based on the click through data stage e.g. which advertisement was selected by the user . Additionally and or alternatively feedback can be based on intent data that is what the user did once they receive the advertiser s advertisement.

The click through data can be obtained by logging which advertisement was clicked and whether it was the last advertisement clicked. A query classifier model can then be built that attempts to surface the best tasks given the query. This can be expressed mathematically using the Na ve Bayes approximation as P Task Query P Task P term Task . Additionally intent data can be employed to train the slot filling models that determine the best mapping.

To the accomplishment of the foregoing and related ends certain illustrative aspects are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles of the claimed subject matter may be employed and the claimed subject matter is intended to include all such aspects and their equivalents. Other advantages and novel features of the claimed subject matter may become apparent from the following detailed description when considered in conjunction with the drawings.

The claimed subject matter is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.

As used in this application the terms component handler model system and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal . Computer components can be stored for example on computer readable media including but not limited to an ASIC application specific integrated circuit CD compact disc DVD digital video disk ROM read only memory floppy disk hard disk EEPROM electrically erasable programmable read only memory and memory stick in accordance with the claimed subject matter.

Referring to a task based advertisement system is illustrated. The system employs high order concepts e.g. booking a flight checking stock quotes etc. embodied in task s which can then be bid upon by advertisers.

Conventionally advertisements have been relatively static with respect to a user s query so that a query such as flights from Boston to Seattle surfaces ads that correspond to keyword s purchased by the advertiser but are not derived semantically from the query. To the contrary the task s employed by the system are based upon a semantic solution to a natural language query. Thus the system can lower the barrier to entry for advertiser s since instead of coming up with a comprehensive list of keyword s the advertiser s can bid on tasks instead. Additionally with the system user s can enter more complex queries and obtain better results than with conventional keyword based system s . Further advertiser s can provide material that is targeted to the user based upon the semantic content in the task e.g. user provided with more relevant content .

Referring briefly to the system includes a search engine that is capable of serving content in response to user query ies e.g. Internet search engine . The system further includes a task server that can include hardware and or software to retrieve task s in response to user query ies . The task s retrieved by the task server can be presented to an advertiser s who can bid on the task s . For example the advertiser s can have a financial incentive to provide better content to user s .

The search engine can receive query ies from user s and provide result s if any to the user s . Thus the search engine can provide a place where user s can express their intentions in the form of query ies with the search engine returning a result set comprising web site s that will likely meet the user s wishes. Additionally the search engine can present targeted advertisement s based at least in part upon the user s query ies as discussed below. The targeted advertisement s can be employed for example to generate revenue for entity ies associated with the search engine .

The task server provides the search engine with a standardized method for interpreting natural language input. Additionally the task server can provide application developer s with a standard manner of defining the tasks the search engine is capable of performing. A task as used herein describes and defines a fundamental unit of action relevant to user. The task server enables the search engine to define and manage tasks. Task s may be defined using extended markup language XML databases text files or in any other suitable manner.

The search engine can receive any manner of natural language input e.g. handwritten text tablet input speech and typed text . The search engine can process the natural language input to generate a query for processing by the task server e.g. a simple string of text characters . The task server selects one or more tasks based at least in part upon the query. The task server can provide the task along with associated metadata and slot information to describe an action to the search engine .

Referring to an exemplary task is illustrated. The task can be generated by the task server in response to a user s query. For example the task can include a name that identifies the task e.g. a task for booking airline flights may be named BookFlight . The task can also include a title for example that can be displayed to users. Additionally the task can include a description that briefly describes the task . The description can be displayed to users either to allow the users to select the appropriate task or confirm that the appropriate task has been selected. For example the name title and description can be implemented using alphanumeric text strings.

The task can include an entity component . The entity component can include one or more named entities. A named entity as used herein is a token that is known to have a specific meaning. The named entity can be task specific or can be utilized with multiple tasks. The task can include a named entity NE recognizer component . The NE recognizer component can include one or more recognizers capable of matching tokens or portions of the natural language input to the entities included in the entity component . The NE recognizers are capable of recognizing tokens corresponding to the named entities contained within the entities component . These tokens have a specific task meaning. Recognizers may be general or may be specific to a certain category of tokens. For example a city recognizer may include a list of names e.g. Seattle Boston . Similarly a date recognizer may be capable of recognizing and interpreting dates such as Jun. 14 2005. The software developer may define certain recognizers when specifying a task.

The task can also include a keyword component . The keyword component can include one or more keywords. Keywords can be used to select a task from a set of tasks. For example the BookFlight task keyword component can include keywords such as Book Flight airline and the like. The keywords can be determine by the software developer or automatically generated by the task server . In addition the task server can add additional keywords to the keyword component based upon natural language input user actions and or user feedback. Furthermore the keywords may be weighted such that the presence of certain keywords in the query is more likely to surface certain tasks. Such weight can also be used to rank or order a selected group of tasks.

The task can also include a slot component that specifies or defines slots for information required for the task. The slot component can provide a mechanism for defining parameters used by the task. For example a task that books airline flights may include slots for the arrival city the departure city the flight date and time. The slot component can include any integer number of slots from zero to N. Typically information from the natural language input is used to fill the slots.

Turning next to an exemplary slot is illustrated. A slot can include a slot name that identifies the slot . For example the BookFlight task discussed above can include slots named DestinationCity ArrivalCity and Date. The slot can also include a slot type . Slot type indicates the type of the value of the slot data. Types can include integers real numbers textual strings and enumerated types e.g. type City can include a list of city names .

The slot can also include an annotation component . The annotation component can include one or more annotations. Annotations are tokens that mark or indicate the significance of other tokens. The annotation component identifies an annotation token and uses that information to interpret other tokens within the natural language input. For example the token from when contained within a natural language input string that maps to a BookFlight task indicates that the token that follows is likely to contain the name of the departure city. Annotations may appear either before or after the relevant token. For example the token departure city when contained within a natural language input string that maps to a BookFlight task indicates that the token that precedes it is likely to contain the name of the departure city. Consequently the phrase leaving from Boston and Boston departure city can both be interpreted to fill the departure city slot with the value Boston. Annotations which appear before the token are called pre indicators while annotations which follow the relevant token are called post indicators. The annotation component can recognize task system defined annotations as well as task specific annotations.

Next referring to an exemplary task framework is illustrated. The framework can include a task component that includes one or more tasks as described previously. The framework can be a component of the task server .

Tasks can be generated by one or more applications or tasks can be generated automatically by the task framework . In addition the task framework may update or modify tasks generated by application s . The task component can be a flat file a database or any other structure suitable for containing the data for one or more tasks.

The task framework can include a task retrieval component . The task retrieval component uses the query to select one or more tasks from the collection of tasks contained within the task component . The task retrieval component may determine the appropriate task to be retrieved from the task component based upon keywords in the query. The collection of tasks in the task component can be indexed based upon the task keywords. The tokens contained within the query can be used to select an appropriate task or set of tasks. The application can also include additional information with the query. For example the application could pass user context information to the framework to be used in the selection of the appropriate task. The task retrieval component can use a variety of methodologies to select appropriate tasks. The task retrieval component can be trained to improve performance based upon user actions and responses to the selected tasks.

In addition the task framework can include a slot filling component . The slot filling component can be responsible for providing the best matching of the list of tokens from the natural language input or query with the task parameters. Typically a slot filling component can receive a list of tokens and one or more tasks. The slot filling component can generate one or more possible mappings of the tokens to the slots of the task. The slot filling component can generate a score or rank for each of the possible mappings of tokens to task slots. The slot filling component can use a mathematical model algorithm or function to calculate a score or rank for mappings. The slot filling component can utilize a heuristic function a hidden Markov model a Na ve Bayes based model Maximum Entropy Minimum Divergence Models MEMD blending strategies linear discriminative models or any combination thereof to calculate a score for a mapping of tokens to a task.

The slot filling component can include a method responsible for taking the natural language input culture information a list of tokens a list of named entities a task and a predetermined maximum number of desired solutions. Culture information can include information such as the writing system and formatting utilized by the relevant culture. Named entities identify tokens with a specific meaning to the slot filling system e.g. Boston . The slot filling component can produce a list of up to the maximum number of requested semantic solutions with a A semantic solution representing a mapping of tokens to slots that can be used by the search engine .

Optionally the task framework can also include a logging component . Tasks can pass information or feedback to the task framework after completion of the task or during task processing. The logging component stores the feedback information. This information can be used to train the task framework and improve system performance. The feedback from tasks can include user actions. The task framework can include a defined intent interface to facilitate feedback.

In addition the task framework or the slot filling component can include one or more GlobalRecognizers that provide the ability to recognize tokens that have special meaning to the task system in general. For example the token Boston has special meaning as the city of Boston Mass. The GlobalRecognizers property provides a set of recognizer components that identify special tokens making them available throughout the entire system and across multiple tasks. For example there may be several tasks that utilize city date or number entities. Entities are a mechanism for providing type information. For example the city entity includes a set of annotations e.g. city place and town . Occurrences of the annotations within the list of tokens indicate the likelihood of a city entity. GlobalRecognizers allows such entities or special tokens to be defined once rather than for each individual task.

In summary keywords are terms that might be used to surface a task. Slots are parameter values that may or may not be filled by the user Query. Slots are uniquely specified by their Name and Type.

Additionally preIndicators are words that might disambiguate slots by occurring before a value to Boston would prefer the Arrival City slot over the Departure City slot even though Boston maps to CITY and can be a value for either slot. PostIndicators are words that might disambiguate slots by occurring before a value from Boston would prefer the Departure City slot over the Arrival City slot even though Boston maps to CITY and can be a value for either slot. Consider the example of Table 1 

Additionally as discussed previously the task server can employ user feedback to learn from user behavior such that if users start entering queries such as departing Boston for Seattle to mean Departure City Boston and Arrival City Seattle . The task server will automatically learn the pattern departing for without needing to explicitly add new Pre or Post indicators to the task definition.

Referring back to in one example the system is based on a closed set of tasks e.g. predefined tasks . One or more advertiser s bid on task s via the advertiser . In another example in addition to a set of predefined tasks advertiser s can bid on and construct their own tasks for example when a suitable task does not exist.

An advantage of bidding on a task rather than keyword s as in conventional systems is that keyword bidding requires advertisers to bid on every possible city. With conventional systems advertiser s are not presented with contextual information to understand the difference between arrival and departure cities. With tasks advertiser s are presented with contextual information which can assist the advertiser s to target their advertisement s to particular task s .

In response to a query received from a user the task server returns a list of the most likely task s given the query to the search engine . The search engine can then provide the task s to the advertiser s for review and bidding. Thereafter zero one or more advertiser s can bid on the task s for example with indicia that the particular advertiser is willing to pay for the right to display an ad based at least in part on the task s e.g. amount of money credits and the like .

The advertiser s can also provide information regarding advertisement s that are to be displayed to the user in the event that the advertiser is a successful bidder on the task. For example the advertiser can use an identifier to select from stored advertisements accessible by the search engine . Additionally and or alternatively the advertiser can dynamically provide advertisement s that are to be displayed to the user in the event that the advertiser is a successful bidder on the task. Information received from advertiser s is discussed in greater detail below.

When the task is returned from the task server the advertisement may not be ready for display for various reasons. In one example the task can be an XML packet which is sent to advertiser s by the search engine . Advertiser s that desire to bid on the task can then send back a data packet e.g. HTML that includes information to be displayed to the user in the event the advertiser is a successful bidder.

In this example suppose the ReserveFlight Task is returned by the task server based on the query flight to Boston from Seattle and that three advertisers have bid on the task. Advertising logic of the search engine can determine that all of these advertisers should be notified. Accordingly the search engine can send an XML packet to each of the advertisers for example 

The advertisers can then return an HTML blob containing whatever information they deem relevant given the task. For example a particular advertiser might include a banner ad with parameters embedded in the links so that the site can be pre populated with information if the user clicks it. A second advertiser might query their database to return instances of flights so that they can display flights leaving tomorrow starting at 299 or display a list of flights to the user. Yet other advertisers might choose not to display anything either because supply is limited or for other reasons. Significantly the advertiser controls the content that s display in this example. Optionally due to latency issues with farming out the task results to the advertisers the search engine can choose to return a page to the user with static advertisements and then asynchronously populate the user s view as the search engine receives results from the advertisers .

In another example a link e.g. URL can be constructed by the search engine without having to contact the advertiser s directly. In this example the the advertiser is responsible for filling out a template such that the results cab be rendered by the search engine . For example for the ReserveFlight Task the results template can contain results of the form Arrival City Departure City Arrival Time Departure Time Ticket Price Availability or anything else for that matter. Given a common result format the search engine can render the results in a consistent manner and in accordance with their look and feel. Significantly in both examples the advertiser can be notified about the semantics of the query and therefore is able to provide more targeted advertisements.

As discussed previously the task retrieval process of the task server can improve with user feedback. For example feedback can be based on the click through data stage e.g. which advertisement was selected by the user . Additionally and or alternatively feedback can be based on intent data that is what the user did once they receive the advertiser s advertisement.

The click through data can be obtained by logging which advertisement was clicked and whether it was the last advertisement clicked. A query classifier model can then be built that attempts to surface the best tasks given the query. This can be expressed mathematically using the Na ve Bayes approximation as P Task Query P Task P term Task . Those skilled in the art will recognize that there are many other mathematical approaches that can be used to obtain this approximation and all such mathematical approaches are intended to be encompassed by the hereto appended claims.

Additionally intent data can be employed to train the slot filling models that determine the best mapping e.g. flights departing Boston for Seattle is flights departing for . For example this information can be supplied by the advertiser in an intent packet such as 

It is to be appreciated that the system the search engine the task server and or the advertiser s can be computer components as that term is defined herein.

Referring next to an exemplary user interface is illustrated. The user interface displays results from the search engine based on a user s query. In this example the user interface includes a first advertisement area a second advertisement area and a third advertisement area . Inclusion in one or more of these areas and can be based for example upon successful bidding of advertiser s to task s retrieved by the task server . A web results area is also included in the exemplary user interface .

Turning briefly to an exemplary user interface is illustrated. The user interface displays results from the search engine based on a user s query. The user interface includes a task results area in which one or more advertisement s can be displayed. The user interface further includes an events monitor area which displays information obtained from the task server related to the query.

Turning briefly to methodologies that may be implemented in accordance with the claimed subject matter are illustrated. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the claimed subject matter is not limited by the order of the blocks as some blocks may in accordance with the claimed subject matter occur in different orders and or concurrently with other blocks from that shown and described herein. Moreover not all illustrated blocks may be required to implement the methodologies.

The claimed subject matter may be described in the general context of computer executable instructions such as program modules executed by one or more components. Generally program modules include routines programs objects data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Referring to a method facilitating a user query session is illustrated. At a user submits a natural language query to a search engine. For example the user can submit a query such as flights to Boston from Seattle with 2 kids . The query is sent to the search engine and optionally additional information can be sent to the search engine for example implied from the user s profile and or location obtained through various techniques.

At the user receives search results and associated advertisement s the advertisement s based at least in part upon task s retrieved and bid upon by advertiser s . At the user selects one or more of the advertisement s e.g. clicks through and is brought to the advertiser s site. At the user visits one or more web site s associated with advertiser s . For example parameter value s can be filled in and the page can be populated with results based on the retrieved task s e.g. richer semantic information available than with conventional systems . At the user executes a web action. As discussed previously the user web action can provided to as feedback to the task server.

Next referring to a search engine method is illustrated. At a query e.g. natural language query is received for example from a user. At the query is provided to a task server. At task results are received from the task server.

At advertiser s are provided the task results for bidding. At bid s are received from the advertiser s . At information regarding advertisement s to be displayed to the user is retrieved and or received as discussed previously. At advertisement s and search results are provided to the user.

At click through information is received from the user. At the click through information is logged. At information regarding the click through is provided to the task server e.g. to be employed as feedback to update a query classifier model. At information regarding a user s web action is received e.g. from the advertiser selected by the user . At the user web action is logged e.g. for billing purposes . At information regarding the user web action is provided to the task server e.g. to be employed as feedback to update slot filling model s .

Turning to a task server method is illustrated. At a query e.g. natural language query is received from a search engine. At based at least in part upon the query task s are retrieved. For example when a user submits a query such as flights to Boston from Seattle with 2 kids a ReserveFlight Task with parameter values Arrival City Las Vegas and Departure City can be retrieved. A set of likely task s can be identified by a task server for example using a combination of Information Retrieval IR and Query Classifier QC algorithms. At task parameter s are provided with most likely value s e.g. based on the particular task and query . For example given the most likely set of task s the best guess slot values can be calculated using a variety of statistical and heuristic methods.

At the search engine is provided with the task results. At information regarding user click through is received from the search engine. At model s that perform task retrieval can be updated based at least in part upon click through information. At information regarding a user web action is received from the search engine. At model s that find best parameter values given a query are updated based at least in part upon the user web action.

Referring to an advertiser method is illustrated. At task results are received from a search engine. At bid information associated with the task results is provided to the search engine. At information associated with a user web action if any is provided to the search engine.

Next turning to a search engine method is illustrated. At a natural language query is received e.g. from a user . At the query is provided to a task server. At task results are received from the task server.

At advertiser s are notified of the task results. At search results and static advertisement s are provided to the user. At bid s are received from advertiser s . At information regarding advertisement s of the successful bidder s is retrieved and or received. At updated advertisement s are provided to the user.

In order to provide additional context for various aspects of the claimed subject matter and the following discussion are intended to provide a brief general description of a suitable operating environment . While the claimed subject matter is described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices those skilled in the art will recognize that the claimed subject matter can also be implemented in combination with other program modules and or as a combination of hardware and software. Generally however program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular data types. The operating environment is only one example of a suitable operating environment and is not intended to suggest any limitation as to the scope of use or functionality of the claimed subject matter. Other well known computer systems environments and or configurations that may be suitable for use with the claimed subject matter include but are not limited to personal computers hand held or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include the above systems or devices and the like.

With reference to an exemplary environment includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to an bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable nonremovable volatile nonvolatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the claimed subject matter can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes examples of the claimed subject matter. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the claimed subject matter are possible. Accordingly the claimed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

