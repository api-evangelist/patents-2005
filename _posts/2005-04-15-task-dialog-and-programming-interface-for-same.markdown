---

title: Task dialog and programming interface for same
abstract: A task dialog having a main instruction and a command region, and optionally a content and/or footer region, is automatically generated in response to a request from an application program. The task dialog main instruction is automatically sized and located so as to form a concise instruction or question located prominently in the dialog. A command region is below the instruction and includes UI controls for responding to the dialog. Optional content and footer regions can be used by a developer for inclusion of text that provides guidance to the user regarding the main instruction. If included, however, the content and/or footer regions are automatically sized and placed so that they do not obscure the main instruction or the command region controls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08490015&OS=08490015&RS=08490015
owner: Microsoft Corporation
number: 08490015
owner_city: Redmond
owner_country: US
publication_date: 20050415
---
The invention generally relates to computer user interfaces UIs and to creation of user interfaces. More specifically embodiments of this invention relate to dialog UIs and to programming interfaces allowing software developers to more conveniently create such dialogs.

The use of dialogs as part of a computer s graphical user interface GUI is known. As used herein a dialog includes a window or other portion of a graphical computer display which appears in order to communicate information from a computer program and or obtain information from the user. A familiar example is the message box dialog used in various versions of the WINDOWS operating system available from Microsoft Corporation of Redmond Wash. . A message box often contains a brief message e.g. Save file before closing program and one or more graphical buttons for possible responses e.g. yes no ok etc. . Dialogs are also used for more complex purposes such as editing properties of an object adjusting operational parameters of a program etc. Some dialogs can be quite extensive and open ended. In other words the dialog may present the user with a large number of possible options some of those options may be loosely related or unrelated and the user may not be given clear direction about what is required.

A well designed dialog permits a user to interact very efficiently with a computer program. Although criteria for evaluating dialogs can vary a good dialog will often make it easy for a user to quickly understand what is needed and what the response options may be. Unfortunately dialogs are often misused and or poorly designed by software developers. In some cases a user must carefully study a dialog in order to derive what information the computer program is conveying and or seeking. This can require excessive time and try the user s patience. Even if the user is able to determine what a badly designed dialog is seeking the proper response may not be readily apparent. This can result in a user selecting an undesired option and may cause serious problems.

Consistency across dialogs generated by various computer programs is also an area of concern. In many environments a single computer will often have software from numerous sources. One company may develop the operating system OS while other companies may develop individual application programs. The OS and other programs executing on the computer may all generate dialogs to obtain user input and or advise the user of important information. If all of these dialogs have a similar design the user becomes accustomed to a general dialog format. The user then knows where to look in each dialog for important information and can thereby respond more quickly. If the dialogs have different layouts and are otherwise not consistent in how they communicate information and seek user input the user may be required to spend more time studying each dialog. In part to promote consistent dialog design various guidelines have been promulgated. Unfortunately software developers frequently fail to observe such guidelines. The developers may be unaware of or not fully understand the guidelines or may simply be unwilling to follow them.

Software developers create dialogs in various manners. For example various versions of the WINDOWS operating system provide a MessageBox function. A software developer can include this function in a program in order to generate a message box type of dialog. When calling the MessageBox function an application program passes several parameters to the OS including a pointer to a text string and details regarding various buttons to be displayed for a user response Ok Cancel etc. . The OS then generates a message box dialog displaying the text string and providing any response buttons specified in the function call. The MessageBox function is well suited to creating relatively simple dialogs. However many developers overuse this function. Specifically developers often attempt to shoe horn a more complex dialog into a message box. As one example some developers treat the text region of a message box as a monolithic block and expect the user to fully read and digest all of that text. This can result in dialogs such as is illustrated in . In the example of the message is not concise and the most important information can be hidden from the user. Moreover expecting all users to carefully review such detailed text within a dialog ignores the reality that many users are impatient and unwilling to read extensive dialog text.

Other tools are available that permit a developer to generate more complex dialogs that may not be suitable for message boxes. However these tools require substantially more effort on a developer s part. Instead of simply calling a function that passes a pointer to text and specifies certain buttons the developer must carefully specify the sizes shapes and positions of many or all of the dialog components. For example suppose a developer wished to display a single prominent message to provide a number of response option controls e.g. buttons and to place a brief description by each of those controls. The developer would have to specify the size shape and position of the prominent message the sizes shapes and positions of the response controls and the sizes shapes and positions of the response control descriptions. Human nature and the economics of software development dissuade many developers from investing the time to code a well designed dialog.

For these and other reasons there remains a need for methods and systems to assist software developers in creating better dialog user interfaces.

Embodiments of the invention address these and other challenges. In at least some embodiments a task dialog is automatically generated in response to a request from an application program. The request need not contain data regarding placement and sizing of various task dialog elements. However the resulting task dialog has a main instruction that is automatically sized and located so as to form a concise instruction or question located prominently in the dialog. A command region is below the instruction and includes UI controls for responding to the dialog. Optional content and footer regions can be used by the developer for inclusion of supplemental text that provides guidance to the user regarding the main instruction. If included however the content and or footer regions are automatically sized and placed so that they do not obscure the main instruction or the command region controls.

The following detailed description is divided into three parts. Part I describes an example of a computer system environment in which embodiments of the invention may be implemented. Part II describes examples of at least some programming interfaces which can be used to implement embodiments of the invention. Part III describes embodiments of task dialog user interfaces UIs and methods for implementing task dialogs.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers hand held or laptop devices multiprocessor systems microprocessor based systems minicomputers and the like. The invention is described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines objects components data structures etc. that perform particular tasks or implement particular abstract data types.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Hardware components of computer may include but are not limited to processing unit system memory and system bus that couples various system components including system memory to processing unit . System bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may include computer storage media and communication media. Computer storage media includes volatile and nonvolatile and removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

System memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . Basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system OS application programs other program modules and program data .

Computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates hard disk drive that reads from or writes to non removable nonvolatile magnetic media magnetic disk drive that reads from or writes to removable nonvolatile magnetic disk and optical disk drive that reads from or writes to removable nonvolatile optical disk such as a CD ROM CDRW DVD or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital video tape solid state RAM solid state ROM and the like. Hard disk drive is typically connected to system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to system bus by a removable memory interface such as interfaces and .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for computer . In for example hard disk drive is illustrated as storing OS application programs other program modules and program data . Note that these components can either be the same as or different from OS application programs other program modules and program data . OS application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into computer through input devices such as keyboard pointing device shown as a mouse but which could be a trackball or touch pad and stylus shown in conjunction with digitizer . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to processing unit through user input interface that is coupled to the system bus. Although mouse keyboard digitizer and modem are shown in as connected to computer through a serial port these and other devices may be connected to computer through other ports e.g. a parallel port PS 2 port game port or a universal serial bus USB port and related interfaces and structures. Monitor or other type of display device is also connected to system bus via an interface such as video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers not shown and a printer not shown which may be connected through an output peripheral interface not shown .

Computer may operate in a networked environment using logical connections to one or more remote computers such as remote computer . Remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer although only memory storage device has been illustrated in . The logical connections depicted in include local area network LAN and wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment computer is connected to LAN through network interface or adapter . When used in a WAN networking environment computer may include modem or other means for establishing communications over WAN such as the Internet. Computer may also access WAN and or the Internet via network interface . Modem which may be internal or external may be connected to system bus via user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between computers may be used.

A programming interface or more simply interface may be viewed as any mechanism process or protocol for enabling one or more segment s of code to communicate with or access the functionality provided by one or more other segment s of code. Alternatively a programming interface may be viewed as one or more mechanism s method s function call s module s object s etc. of a component of a system capable of communicative coupling to one or more mechanism s method s function call s module s etc. of other component s . The term segment of code in the preceding sentence is intended to include one or more instructions or lines of code and includes e.g. code modules objects subroutines functions and so on regardless of the terminology applied or whether the code segments are separately compiled or whether the code segments are provided as source intermediate or object code whether the code segments are utilized in a runtime system or process or whether they are located on the same or different machines or distributed across multiple machines or whether the functionality represented by the segments of code are implemented wholly in software wholly in hardware or a combination of hardware and software. By way of example and not limitation terms such as application programming interface API entry point method function subroutine remote procedure call and component object model COM interface are encompassed within the definition of programming interface.

A programming interface may be viewed generically as shown in or . illustrates an interface Interface as a conduit through which first and second code segments communicate. illustrates an interface as comprising interface objects I and I which may or may not be part of the first and second code segments which enable first and second code segments of a system to communicate via medium M. In the view of one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although show bi directional flow and interfaces on each side of the flow certain implementations may only have information flow in one direction and or may only have an interface object on one side.

Aspects of a programming interface may include the method whereby the first code segment transmits information where information is used in its broadest sense and includes data commands requests etc. to the second code segment the method whereby the second code segment receives the information and the structure sequence syntax organization schema timing and content of the information. In this regard the underlying transport medium itself may be unimportant to the operation of the interface whether the medium be wired or wireless or a combination of both as long as the information is transported in the manner defined by the interface. In certain situations information may not be passed in one or both directions in the conventional sense as the information transfer may be either via another mechanism e.g. information placed in a buffer file etc. separate from information flow between the code segments or non existent as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation e.g. depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration and so this description should be considered illustrative and non limiting.

The concept of a programming interface is known to those skilled in the art. There are various other ways to implement a programming interface. Such other ways may appear to be more sophisticated or complex than the simplistic view of but they nonetheless perform a similar function to accomplish the same overall result. Some illustrative alternative implementations of a programming interface are described in connection with .

A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown some interfaces can be described in terms of divisible sets of functionality. Thus the interface functionality of may be factored to achieve the same result just as one may mathematically provide 24 or 2 times 2 times 3 times 2. Accordingly as illustrated in the function provided by interface Interface may be subdivided to convert the communications of the interface into multiple interfaces InterfaceA InterfaceB InterfaceC etc. while achieving the same result. As illustrated in the function provided by interface I may be subdivided into multiple interfaces I I I etc. while achieving the same result. Similarly interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces I I I etc. When factoring the number of interfaces included with the 1st code segment need not match the number of interfaces included with the 2nd code segment. In either of the cases of the functional spirit of interfaces Interface and I remain the same as with respectively. The factoring of interfaces may also follow associative commutative and other mathematical properties such that the factoring may be difficult to recognize. For instance ordering of operations may be unimportant and consequently a function carried out by an interface may be carried out well in advance of reaching the interface by another piece of code or interface or performed by a separate component of the system. Moreover one of ordinary skill in the programming arts can appreciate that there are a variety of ways of making different function calls that achieve the same result.

In some cases it may be possible to ignore add or redefine certain aspects e.g. parameters of a programming interface while still accomplishing the intended result. This is illustrated in . For example assume interface Interface of includes a function call Square input precision output a call that includes three parameters input precision and output and which is issued from the 1st Code Segment to the 2nd Code Segment. If the middle parameter precision is of no concern in a given scenario as shown in it could be ignored or replaced with another parameter. In either event the functionality of Square can be achieved so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system however once it is recognized that precision is not necessary for the narrow purpose of calculating the square it may be replaced or ignored. For example instead of passing a valid precision value a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly as shown in interface I is replaced by interface I redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I to ignore unnecessary parameters or parameters that may be processed elsewhere. As is clear from the foregoing a programming interface may in some cases include aspects such as parameters which are not needed for some purpose and which may be ignored redefined or processed elsewhere for other purposes.

It may also be feasible to merge some or all of the functionality of two separate code modules such that the interface between them changes form. For example the functionality of may be converted to the functionality of respectively. In the previous 1st and 2nd Code Segments of are merged into a module containing both of them. In this case the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus for example formal Call and Return statements may no longer be necessary but similar processing or response s pursuant to interface Interface may still be in effect. Similarly shown in part or all of interface I from may be written inline into interface I to form interface I . As illustrated interface I is divided into Iand I and interface portion Ihas been coded in line with interface I to form interface I .

A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown in one or more piece s of middleware Divorce Interface s since they divorce functionality and or interface functions from the original interface are provided to convert the communications on the first interface Interface to conform them to a different interface in this case interfaces InterfaceA InterfaceB and InterfaceC. This might be done e.g. where there is an installed base of applications designed to communicate with say an operating system in accordance with an Interface protocol but then the operating system is changed to use a different interface in this case interfaces InterfaceA InterfaceB and InterfaceC. The point is that the original interface used by the 2nd Code Segment is changed such that it is no longer compatible with the interface used by the 1st Code Segment and so an intermediary is used to make the old and new interfaces compatible. Similarly as shown in a third code segment can be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to for example interfaces Iand I redesigned to work with DI but to provide the same functional result. Similarly DI and DI may work together to translate the functionality of interfaces I and I of to a new operating system while providing the same or similar functional result.

Rewriting. Yet another possible variant is to dynamically rewrite code to replace the interface functionality with something else but which achieves the same overall result. For example there may be a system in which a code segment presented in an intermediate language e.g. MICROSOFT IL JAVA ByteCode etc. is provided to a Just in Time JIT compiler or interpreter in an execution environment such as that provided by the MICROSOFT .NET FRAMEWORK the JAVA runtime environment or other similar runtime type environments . The JIT compiler may be written so as to dynamically convert the communications from the 1st Code Segment to the 2nd Code Segment i.e. to conform them to a different interface as may be required by the 2nd Code Segment either the original or a different 2nd Code Segment . This is depicted in . As can be seen in this approach is similar to the Divorce scenario described above. It might be done e.g. where an installed base of applications are designed to communicate with an operating system in accordance with an Interface protocol but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed base applications to the new interface of the operating system. As depicted in this approach of dynamically rewriting the interface s may be applied to dynamically factor or otherwise alter the interface s as well.

It is also noted that the above described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways serially and or in parallel or with other intervening code. Thus the alternative embodiments presented above are not mutually exclusive and may be mixed matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that as with most programming constructs there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein but nonetheless are represented by the spirit and scope of the invention.

As used herein a task dialog is a specialized type of dialog employed when a decision or other information is needed from a user in order to continue a specific task. In at least some embodiments a task dialog is limited to receiving input to and or providing information regarding a single task or event. Task dialogs include message boxes and confirmation dialogs as well as dialogs asking a user for information in order to complete a particular command or instruction. show examples of task dialogs according to at least some embodiments of the invention. Although the dialogs shown in are all shown as independent windows in a GUI generated by an OS such as various versions of the WINDOWS OS the invention is not limited in this regard. For example task dialogs according to the invention might also be generated as a pane of or frame within a pre existing window.

Shown in is a generic task dialog according to at least some embodiments of the invention. Task dialog is divided into header content command and footer regions. Each of these regions is described in more detail below. Task dialog also includes a window title . In at least some embodiments window title is the name of the program or command in an application program which caused task dialog to be generated. Not all of the regions shown in are required in every task dialog. For example the content and footer regions are optional in at least some embodiments. Text within some or all of the regions can also be accessible as text. For example a user might wish to copy text from one of the regions and paste that text elsewhere.

The header region of task dialog is displayed prominently and informs the user of the purpose of the task dialog. In this manner the user can readily determine the type of information being provided and or being sought. The header region of task dialog contains a main instruction and a main icon . For simplicity icons are shown generically in the drawings as the word icon inside a box. Although optional main icon is often useful for providing the user with a rapidly understood visual clue to the purpose of the task dialog. For example standardized icons can be specified by a developer for error messages e.g. a red circle with an x for warning messages e.g. a yellow triangle with an exclamation mark and for informational messages e.g. an i inside of a balloon . Of course a developer could specify other icons. As but one example an icon corresponding to the program causing a task dialog to be created can be used as a main icon . Main instruction is a text string specified by a developer and is preferably a concise sentence or question directed to and easily understood by a computer user. In at least some embodiments a main instruction is required i.e. a developer must specify a main instruction when creating a task dialog .

Immediately below the header region is a content region. Within the content region the developer can place additional text . Text within the content region can also contain one or more hyperlinks selection of which may open a new window another program a link to an Internet resource etc. For convenience hyperlinks are represented in the drawings with underlining. In at least some embodiments and as explained in more detail below text within the content region is automatically made smaller in size than text in the header region. In this manner text does not distract the user from a primary message being conveyed by header region text . The developer can for example use the content region for longer portions of text that might be needed to explain additional details regarding the primary message in the header region. If a developer attempts to place more text within a content region than can be displayed a scrolling text box is automatically generated in the content region not shown . If the content region is too small to effectively include a scrolling text box the entire task dialog is displayed in a scrolling window also not shown . In at least some embodiments a content region is optional i.e. a developer need not include content text in a task dialog.

Beneath the content region is the command region. Placed within the command region are one or more UI controls with which a user can provide a response to the task dialog. As used herein UI control includes various types of graphical elements which a user can select by e.g. hovering a cursor over the control and pressing a mouse button so as to interact with the computer program that caused the task dialog to be created. For example a UI control may allow a user to respond to a question initiate an action display additional information etc. UI controls include but are not limited to buttons radio buttons check boxes text input boxes expansion controls described below etc. Controls within the command area can include buttons having responses from a predefined collection e.g. buttons for yes no ok cancel etc. buttons with specialized commands specified by a program requesting the task dialog e.g. save delete disconnect connect etc. or combinations of both standard and specialized buttons or other controls. A developer can also specify which of the controls in the command area is the default choice i.e. the choice which is automatically highlighted for selection by the user. As described in more detail below the sizing and arrangement of controls within the command region is also automatic. In the command region includes two buttons generically labeled Command an expansion control and text More Options accompanying the expansion control. Upon selection of an expansion control by the user and as explained in connection with subsequent drawings additional text is displayed. In at least some embodiments expansion controls are optional. If used however expansion controls are automatically placed in the command region. In certain embodiments a developer can specify the text to be placed next to the expansion control glyph in the expanded and collapsed conditions but cannot modify the glyph.

Beneath the command region is the footer region. In at least some embodiments the footer region is limited to text with or without hyperlinks and an icon. In at least some embodiments the footer region icon may be the same as or different than the main icon. A footer region icon or the entire footer region may be omitted at the developer s option. The footer text which is preferably limited to information which might be helpful to the user but which is not essential for use of the task dialog is automatically sized and arranged.

In at least some embodiments a task dialog may optionally include a progress region located between the header and content regions. The progress region can be used to provide an informational UI control that informs the user how much of a particular process being performed by the computer e.g. downloading a file converting a file to another format performing a scan of files for viruses etc. has been completed. Examples of such informational UI controls include a thermometer bar which indicates the percentage of task completion. is an example of a task dialog as shown in but which includes a progress region having a progress indicating informational UI control . A progress region and associated informational UI control could be included in various combinations with other task dialog formats and elements described herein.

Application requests generation of a task dialog by transmitting that request to programming interface PI . Although shown in as a part of OS PI can be implemented in various of the manners described in connection with . PI includes one or more functions or methods which application accesses through one or more calls. Included in the call are parameters flags and other elements providing the information or pointers to the information which OS will use to generate a task dialog. Included at the end of this detailed description are Appendices A though R describing functions and structures according to at least some embodiments by which application may access PI . Because Appendices A through R will be readily understood by persons skilled in the art they will not be extensively discussed herein. In general however the information provided by application program may include at least some or all of the following 

The information set forth above may be provided directly i.e. as a value passed as part of the function call indirectly i.e. as a pointer to a variable structure or other object or both.

Using information received by PI from application program OS automatically generates a task dialog so that the main instruction will be prominently displayed so that the content region if the task dialog is to have a content region will be located under the main instruction and in smaller text so that the command region will be located under the header and or content region s etc. OS automatically sizes command buttons if used to be large enough for the specified button text. OS automatically places expansion controls if used and verification controls if used in the proper location s relative to command buttons or command links.

As seen in the attached Appendices A through R application is not required to include extensive layout and other formatting data in the function call. Instead OS accesses one or more theme files containing data that specifies how various components of all task dialogs whether called by application by other programs or by OS itself are to be displayed. In this manner all task dialogs may have a consistent layout thereby enhancing the efficiency with which a user can interface with those task dialogs. Table 1 sets forth examples of task dialog components that may be controlled by reference to one or more theme files.

Also included in theme file s may be one or more styles for components of a task dialog. Set forth below in Table 2 are examples of possible style data.

Based on the information passed by application to PI in a task dialog function call and using data in theme file s OS generates the desired task dialog on display . When the user then selects a command button or other control displayed as part of the task dialog OS communicates data regarding that button or other control via PI to application . Application then processes that data.

In some embodiments a developer can specify the modality of a task dialog. In other words the developer can include as part of a function call or other type of PI an indication of whether the user will be required to respond to the message box before continuing to work in the application which caused the task dialog to be created. In certain embodiments the default modality will require the user to respond to the task dialog before further work in the application that caused the task dialog but will allow the user to switch to other applications without responding to the task dialog. If the application causing the task dialog is currently running in several windows the user might depending on the hierarchy of those windows be able to move to other windows. In some embodiments child windows of the parent window causing the task dialog are disabled until the user responds to the task dialog but higher level windows and pop up windows are not disabled.

In some embodiments an application requesting a task dialog with a hyperlink in content or footer text must explicitly indicate whether hyperlinks are to be enabled.

In at least some embodiments different levels of task dialog customization may be available. For example a software company developing OS might wish to allow its own internal developers to make more extensive changes to a task dialog but may wish to limit the degree to which an external developer of an application program may customize a task dialog. There could be various reasons for such an approach. If the company developing OS wishes to maintain a design philosophy that is consistent across multiple user interfaces including task dialogs that company may have more confidence that its internal developers will be careful about observing UI design guidelines. Conversely the desire and or capacity for external developers to follow those guidelines might be uncertain. Moreover the OS manufacturer may wish to limit external developers ability to customize task dialogs in order to ensure that future versions of OS will be compatible with applications developed for earlier versions of OS .

Shown in are examples of task dialogs that according to at least embodiments could be created by a developer of an OS that generates a task dialog but which might not be available to external developers as part of an application PI for creating task dialogs. Shown in is a task dialog with an icon in an unexpanded content region. The content region of also includes text of multiple styles . shows the task dialog of in an expanded condition and reveals additional UI controls placed in the content region. In the example of the content region includes buttons having drop down menus for selecting different download priorities and for selecting different applications with which to open a document as well as a verification control . shows an unexpanded task dialog which when expanded also includes additional UI controls in the content region verification controls for options A C . shows an unexpanded task dialog which when expanded includes scrolling multi style text in the footer region.

Although specific examples of carrying out the invention have been described those skilled in the art will appreciate that there are numerous other variations and permutations of the above described systems and techniques. As but one example multiple hyperlinks can be included in content region text and or in footer region text. An operating system may also generate task dialogs. These and other variations fall within the spirit and scope of the invention as set forth in the appended claims. As used in the claims the phrase data indicative of includes pointers or other references to data located elsewhere as well as the actual data itself. In the claims various portions are prefaced with letter or number references for convenience. However use of such references does not imply a temporal relationship not otherwise required by the language of the claims.

The TaskDialog function creates displays and operates a task dialog. The task dialog contains application defined message text and title any icon and any combination of predefined push buttons.

 in Handle to the owner window of the task dialog to be created. If this parameter is NULL the task dialog has no owner window.

 in Handle to the module that contains the icon resource identified by the pszIcon member and the string resource identified by the pszWindowTitle or pszMainInstruction member. If this parameter is NULL the pszIcon parameter must be null or use a predefined icon value e.g. TD ERROR ICON and the pszWindowTitle and pszMainInstruction must be NULL or point to actual null terminated strings.

 in Pointer that references the string to be used for the dialog box title. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. If this parameter is NULL the filename of the executable program is used.

 in Pointer that references the string to be used for the main instruction. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro.

 in Specifies the push buttons displayed in the dialog box. This parameter may be a combination of flags from the following group.

 in Pointer that references the icon to be displayed in the dialog box. This parameter must be an integer resource identifier passed to the MAKEINTRESOURCE macro or one of the following predefined values 

If this parameter is NULL no icon will be displayed. If the hInstance parameter is null and one of the predefined values is not used no icon will be displayed.

Returns S OK if successful. If the operation fails it returns an HRESULT which could be one of the following error codes.

When you use a task dialog box to indicate that the system is low on memory the strings pointed to by the lpMainInstruction and lpWindowTitle parameters should not be taken from a resource file because an attempt to load the resource may fail.

If you create a task dialog while a dialog box is present use a handle to the dialog box as the hwndParent parameter. The hwndParent parameter should not identify a child window such as a control in a dialog box.

The TaskDialogIndirect function creates displays and operates a task dialog. The task dialog contains application defined messages title verification check box command links and push buttons plus any combination of predefined icons and push buttons.

 in Pointer to a TASKDIALOGCONFIG structure that contains information used to display the task dialog.

 out Pointer to an integer location that receives one of button IDs specified in the pbuttons member of the pTaskConfig parameter or one of the following values 

If this value is NULL no value is returned. If the pszVerificationText member of the TASKDIALOGCONFIG structure is specified and this value is null then the verification checkbox will be displayed in the dialog but it will be disabled. If this value is specified but the pszVerificationText member of the TASKDIALOGCONIG structure is not specified then it will be set based upon whether the VERIFICATION FLAG CHECKED flag is specified in the TASKDIALOGCONFIG structure.

Returns S OK if successful. If the operation fails it returns an HRESULT which could be one of the following error codes.

When you use a task dialog box to indicate that the system is low on memory the strings pointed to by the various string and icon s in TASKDIALOGCONFIG should not be taken from a resource file because an attempt to load the resource may fail.

If you create a task dialog while a dialog box is present use a handle to the dialog box as the hwndParent parameter. The hwndParent parameter should not identify a child window such as a control in a dialog box.

The TASKDIALOGCONFIG structure contains information used to display a task dialog. The TaskDialogIndirect function uses this structure.

Handle to the module that contains the icon resource identified by the pszMainIcon orpszFooterIcon members and the string resource identified by the pszWindowTitle pszMainInstruction pszContent psz Verification Text pszExpandedInformation pszExpandedControlText pszCollapsedControlText or pszFooterText members.

Specifies the behavior of the dialog box. This parameter can be a combination of flags from the following group.

Indicates that the dialog should be able to be closed using Alt F4 Escape and the title bar s close button even if no cancel button is specified in either the dwCommonButtons or pButons members.

Specifies the push buttons displayed in the dialog box. This parameter may be a combination of flags from the following group.

If no common buttons are specified and no custom buttons are specified using the cButtons and pButtons members the dialog box will contain the OK button by default.

Pointer that references the string to be used for the dialog box title. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. If this parameter is NULL the filename of the executable program is used.

A handle to an Icon that is to be displayed in the dialog box. This member is ignored unless the USE HICON MAIN flag is specified. If this member is NULL and the USE HICON MAIN is specified no icon will be displayed.

Pointer that references the icon to be displayed in the dialog box. This parameter must be an integer resource identifier passed to the MAKEINTRESOURCE macro or one of the following predefined values 

This parameter is ignored if the USE HICON MAIN flag is specified. Otherwise if this parameter is NULL or the hinstance parameter is NULL no icon will be displayed.

Pointer that references the string to be used for the main instruction. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro.

Pointer that references the string to be used for the dialog s primary content. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. If the ENABLE HYPERLINKS flag is specified for the dwFlags member then this string may contain hyperlinks in the form Hyperlink Text.

WARNING Enabling hyperlinks when using content from an unsafe source may cause security vulnerabilities.

Indicates the number of entries in the pbuttons array that should be used to create buttons or command links in the dialog. If this member is zero and no common buttons have been specified using the dwCommonButtons member then the dialog box will have a single OK button displayed.

Pointer to an array of TASKDIALOG BUTTON structures containing the definition of the custom buttons that are to be displayed in the dialog. This array must contain at least the number of entries that are specified by the cbuttons member.

Indicates the default button for the dialog. This may be any of the values specified in nButtonID members of one of the TASKDIALOG BUTTON structures in the pbuttons array or one of the IDs corresponding to the buttons specified in the dwCommonButtons member.

If this member is zero or its value does not correspond to any button ID in the dialog then the first button in the dialog will be the default.

Pointer that references the string to be used to label the verification checkbox. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. If this parameter is NULL the verification checkbox is not displayed in the dialog box.

Pointer that references the string to be used for displaying additional information. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. The additional information is displayed either immediately below the content or below the footer text depending on whether the EXPAND FOOTER AREA flag is specified. If the ENABLE HYPERLINKS flag is specified for the dwFlags member then this string may contain hyperlinks in the form Hyperlink Text.

WARNING Enabling hyperlinks when using content from an unsafe source may cause security vulnerabilities.

Pointer that references the string to be used to label the button for collapsing the expanded information. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. This member is ignored when the pszExpandedInformation member is NULL. If this member is NULL and the pszCollapsedControlText is specified then the pszCollapsedControlText value will be used for this member as well.

Pointer that references the string to be used to label the button for expanding the expanded information. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. This member is ignored when the pszExpandedInformnation member is NULL. If this member is NULL and the pszExpandedControlText is specified then the pszExpandedControlText value will be used for this member as well.

A handle to an Icon that is to be displayed in the footer of the dialog box. This member is ignored unless the USE HICON FOOTER flag is specified and the pszFooterIcon variable must not be NULL. If this member is NULL and the USE HICON FOOTER is specified no icon will be displayed.

Pointer that references the icon to be displayed in the footer area of the dialog box. This parameter must be an integer resource identifier passed to the MAKEINTRESOURCE macro or one of the following predefined values 

This parameter is ignored if the USE HICON FOOTER flag is specified. Otherwise if this parameter is NULL or the hinstance parameter is NULL no icon will be displayed.

Pointer that references the string to be used in the footer area of the dialogbox. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. If the ENABLE HYPERLINKS flag is specified for the dwFlags member then this string may contain hyperlinks in the form Hyperlink Text.

WARNING Enabling hyperlinks when using content from an unsafe source may cause security vulnerabilities.

The TASKDIALOG BUTTON structure contains information used to display a task dialog. The TASKDIALOGCONFIG structure uses this structure.

Pointer that references the string to be used to label the button. This parameter can be either a null terminated string or an integer resource identifier passed to the MAKEINTRESOURCE macro. When using Command Links you delineate the command from the explanations by placing a new line character in the string.

The TaskDialogCallbackProc function is an application defined function used with the TaskDialogIndirect function. It receives messages from the Task Dialog when various events occur. TaskDialogCallbackProc is a placeholder for the application defined function name.

 in Specifies additional notification information. The contents of this parameter depends on the value of the uNotification parameter.

 in Specifies additional notification information. The contents of this parameter depends on the value of the unotification parameter.

An application must register this callback function by passing its address in the pfCallbackFunc member of the pTaskConfig parameter to TaskDialogInternalCall.

The TDN CREATED notification is sent by the Task Dialog once the dialog has been created and before it is displayed.

The TDN BUTTON CLICKED notification is sent by the Task Dialog when the user selects a button or command link in the task dialog.

To prevent the Task Dialog from closing the application must return TRUE otherwise the Task Dialog will be closed and the button ID returned to via the original application call.

The TDN HYPERLINK CLICKED notification is sent by the Task Dialog when the user clicks on a hyperlink in the Task Dialog s content.

To prevent the TaskDialog from shell executing the hyperlink the application must return TRUE otherwise ShellExecute will be called

The TDN TIMER notification is sent by the Task Dialog approximately every 200 milliseconds when the TDF CALLBACK TIMER flag has been set in the dwFlags member of the pConfig parameter to the TaskDialogIndirect function.

To reset the tickcount the application must return TRUE otherwise the tickcount will continue to increment.

The TDN DESTROYED message is sent by the Task Dialog when it is destroyed and its window handle no longer valid.

 in Pointer to a TASKDIALOGCONFIG structure that contains information used to display the task dialog.

The value returned from processing this message only applies the actual posting of the message to the TaskDialog not the layout of the TaskDialog. If the layout of the TaskDialog fails the dialog will close and an HRESULT will be returned to the application that originally called TaskDilaogInternalCallback.

The entire contents of the dialog frame is destroyed and reconstructed. Hence any state information held by controls in the dialog such as the progress bar expando or verification checkbox is lost.

It is not necessary for the button ID passed to this function to actually exist in the TaskDialog at the time it is called.

The value returned from processing this message only applies the actual processing of the message and not any processing that may occur due to the action being invoked. For example if the TaskDialog callback function fails the dialog will close and an HRESULT will be returned to the application that originally called TaskDilaogInternalCallback.

The TDM SET MARQUEE PROGRESS BAR message is used to indicate whether the hosted progress bar should be displayed in marquee mode or not.

 in Specifies whether the progress bar should be shown in Marquee mode. A value of TRUE turns on Marquee mode.

The TDM SET PROGRESS BAR STATE message is used to indicate whether the hosted progress bar should be displayed in marquee mode or not.

The TDM SET PROGRESS BAR RANGE message is used set the minimum and maximum values for the hosted progress bar.

The TDM SET PROGRESS BAR MARQUEE message is used to indicate whether a marquee progress bar is in motion or not.

