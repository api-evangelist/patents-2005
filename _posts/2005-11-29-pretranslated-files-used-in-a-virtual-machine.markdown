---

title: Pre-translated files used in a virtual machine
abstract: A method and apparatus for speeding the startup of applications by making available a pre-translated class file to the class loaders. The Java virtual machine (JVM) starts faster if application class loaders can use the pre-translated class files or internal representations instead of fetching classes from Java archive files or system directories. JVM understands java executable format and can start faster by using them without the user application class loaders having to know the complexities of executable files. The Java archive file format is modified to allow the pre-translated class files to be stored in the Java archive file such that the class loaders are able to process the modified Java archive file without requiring any change to the class loader.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08042103&OS=08042103&RS=08042103
owner: International Business Machines Corporation
number: 08042103
owner_city: Armonk
owner_country: US
publication_date: 20051129
---
The present invention relates generally to an improved data processing system and in particular to a method and apparatus for executing programming languages. Still more particularly the present invention relates to a computer implemented method apparatus and computer usable program code for processing files in a virtual machine.

Computer developers have made a number of different computer microprocessors suited to particular sorts of problems. Machine instructions are in a sense the language for a particular processing unit architecture. Some microprocessors execute complex instruction sets while others execute reduced instruction sets.

The instructions are usually difficult for a human being to read and understand let alone write as a program. Consequently higher order languages have been conceived that mimic aspects of human languages such as English. Such languages including Java permit rapid development of useful programs though the resultant code is not immediately executable on a microprocessor. Java is a trademark of Sun Microsystems Incorporated. In order for such higher order codes or programs to be used by a microprocessor the programs must be interpreted and compiled into a machine language that is suited for the particular processor architecture.

Java programs are architecture independent in the sense that all microprocessors that have a Java Virtual Machine JVM are able to compile such programs to the machine language of the microprocessor. The compiling step may introduce a delay in executing a program however this is the cost of making a program independent of the architecture.

Developers have wanted a more rapid way to execute Java programs. Java programs are often packaged as a bundle of class files. Each class file provides instructions to perform a particular function of a program. However in order to perform each function as mentioned above a Java virtual machine JVM must compile the function into machine instructions and then execute the compiled machine instructions. It would be advantageous to have such compiled machine instructions available at the outset of executing a program. Compiled machine instructions are among pre translated versions of the high level language. Consequently pre translated files might be faster to perform if such compiled machine instructions were accessible to a Java virtual machine without compilation.

The aspects of the present invention provide a computer implemented method and computer program product for processing files in a virtual machine. A virtual machine receives a file loaded by a class loader for the virtual machine. The virtual machine determines if the file contains a distinctive pattern. The distinctive pattern indicates a set of values and a set of modified class data. If it is determined that the file contains the distinctive pattern the virtual machine obtains access to the set of modified class data for an executable class resource.

With reference now to a block diagram of a data processing system is shown in which embodiments of the present invention may be implemented. In the depicted example data processing system employs a hub architecture including north bridge and memory controller hub MCH and south bridge and input output I O controller hub ICH . Processing unit main memory and graphics processor connect to north bridge and memory controller hub . Graphics processor may connect to north bridge and memory controller hub through an accelerated graphics port AGP .

In the depicted example local area network LAN adapter audio adapter keyboard and mouse adapter modem read only memory ROM hard disk drive HDD CD ROM drive universal serial bus USB ports and other communications ports and PCI PCIe devices connect to south bridge and I O controller hub through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS .

Hard disk drive and CD ROM drive connect to south bridge and I O controller hub through bus . Hard disk drive and CD ROM drive may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. Super I O SIO device may connect to south bridge and I O controller hub .

With reference now to a block diagram illustrates the relationship of software components operating within a computer system that may implement the present invention. Java based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. Java virtual machine JVM is one software application that may execute in conjunction with the operating system. Java is a trademark of Sun Microsystems Incorporated. Java virtual machine provides a Java run time environment with the ability to execute Java application or applet which is a program servlet or software component developers may write in the Java programming language. Java virtual machine may operate in computer systems similar to data processing system of . Nevertheless developers of a Java virtual machine in accordance with an illustrative embodiment of the present invention may implement Java virtual machine on a so called Java chip Java on silicon or Java processor with an embedded picoJava core.

At the center of a Java run time environment is the Java virtual machine which supports all aspects of Java s environment including Java s architecture security features mobility across networks and platform independence.

The Java virtual machine is a virtual computer that is a computer that developers specify in the abstract. The specification of the Java virtual machine defines certain features that every Java virtual machine implements with some range of design choices that may depend upon the platform on which the developers design the Java virtual machine to execute. For example all Java virtual machines execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A developer may implement the Java virtual machine completely in software or partially in hardware. This flexibility allows the developers to design different Java virtual machines for systems ranging from mainframe computers to PDAs and other micro devices.

The Java virtual machine may also be the name of a virtual computer component that actually executes Java programs. The Java virtual machine and not the central processor directly runs Java programs. For example the processor is processing unit of . The Java virtual machine allows Java programs to execute on a different platform as opposed to only the one platform for which the developer compiled the code. Developers may compile Java programs for the Java virtual machine. In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format the compiled code can execute on many processors given the presence of the Java run time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code that the Java compiler generates and the Java Interpreter executes. A Java interpreter is part of the Java virtual machine that alternately decodes and interprets a bytecode or bytecodes. The compiler generates these bytecode instructions so that they are easy for the interpreter on any computer to interpret and translate on the fly into native machine code. A just in time compiler may translate the bytecodes into native code in a process sometimes called just in time compiling jitting a method. Embodiments of the present invention may skip steps that are normally performed just prior to just in time compiling. Embodiments of the present inventions skip when the embodiments discover a pre translated file.

One type of software based execution engine is a just in time compiler. With this type of execution the compiler compiles the bytecodes of a method to native machine code when the application successfully fulfills some type of criteria for jitting a method. The Java virtual machine then caches the native machine code for the method and reuses the code upon the next invocation of the method. Developers may also implement the execution engine in hardware and by embedding the execution engine on a chip so that the execution engine may execute the Java bytecodes natively. Java virtual machines usually interpret bytecodes but Java virtual machines may also use other techniques such as just in time compiling mentioned above to execute bytecodes.

With reference now to this figure depicts a block diagram of a Java virtual machine in accordance with a preferred embodiment of the present invention. Java virtual machine includes class loader which is a mechanism for loading types such as classes and interfaces given fully qualified names. Classes may be located in a Java archive file JAR for example Java archive file . Java virtual machine also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader . Java interpreter or just in time compiler are examples of the execution engine . Native method interface allows access to resources in the underlying operating system. Java native interface JNI is an example of native method interface . Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by Java virtual machine to execute a program.

Java stacks store the state of Java method invocations. When the Java virtual machine launches a new thread the Java virtual machine creates a new Java stack for the thread. In these examples the Java virtual machine performs only two operations directly on Java stacks the Java virtual machine pushes and pops frames. A thread s Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables the parameters with which a thread invoked the method an associated return value if any and intermediate calculations. Java stacks comprise stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method the Java virtual machine pushes a new frame onto the Java stack of the thread. When the method completes the Java virtual machine pops the frame for that method and discards the frame. The Java virtual machine does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the developers have suitably designed the Java instruction set for a variety of platform architectures.

Developers use program counter PC registers to indicate the next instruction a thread executes. Each instantiated thread gets an associated PC register and Java stack. If the thread is executing a Java virtual machine method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined. Native method stacks stores the state of invocations of native methods. Native method stacks registers or other implementation dependent memory areas store the state of native method invocations in an implementation dependent way. Some Java virtual machine implementations combine the native method stacks and Java stacks .

Method area contains class data while heap contains all instantiated objects. These examples show the constant pool located in method area . The Java virtual machine specification strictly defines data types and operations. Most Java virtual machines establish one method area and one heap and all the threads running inside the Java virtual machine such as Java virtual machine share the method area and the heap. When Java virtual machine loads a class file the Java virtual machine parses information about a type from the binary data contained in the class file. Java virtual machine places this type of information into the method area. Each time the Java virtual machine creates a class instance or array it allocates the memory for the new object from heap . An instance is an object of a particular class. In programs written in the Java programming language an instance of a class is created using the new operator followed by the class name. An instance of an executable class is an executable function that is stored to memory or other storage in the form of machine instructions. An instance of an executable class includes the instructions plus any unchanging values used by the function.

In these illustrative examples modified class data take the form of a set of modified bytecodes and optionally modified metadata. The set of modified bytecodes contains one or more modified bytecodes. In the depicted examples the set of modified bytecodes and metadata are modified from a Sun class file. A Sun class file is a class file written according to the Sun Java specifications including for example the class format validator 0xCAFEBABE. Modified class data is class data that a virtual machine is capable of interpreting. More importantly modified class data is class data that is tailored to the specific virtual machine in order to allow more efficient memory management and quicker execution. Such gains are possible in comparison to the particular virtual machine processing ordinary Sun class files. A virtual machine is for example Java virtual machine of .

Modified class data may be pre translated since the data is already in a somewhat optimized form for the particular virtual machine. Modified class data is sometimes called an internal representation. An internal representation may be a static internal representation. A static internal representation is merely a set of modified class data and a set of values. The set of values may be one or more values in these examples. A dynamic internal representation is an allocation in a memory to at least one data structure that may vary during operation of the static internal representation. The memory may be for example main memory of .

Thus a static internal representation may have a dynamic internal representation. In that case the combined static internal representation and the dynamic internal representation are together also a modified class data. A set of values contains one or more values. In these examples the set of values may include a single constant defined for use in the static internal representation. A value is a number that is stored without changing during the operation of executable code. A value may be for example a known constant such as pi which a developer may approximate with 3.14159.

Java virtual machine includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

Illustrative embodiments of the present invention include a Java virtual machine that may flexibly read input files that contain both Java executable resource files and locators that reference Java executable resource files. The illustrative embodiments of the present invention use archive files that include class proxy files that have a distinctive pattern to signal to the Java virtual machine that the file is a class proxy file. A distinctive pattern indicates a presence of a set of modified class data and a set of values. A class proxy file is a file that does not actually contain the details of a class file but rather contains a locator used to find a class file elsewhere. A Java virtual machine loads class files and executes the bytecodes within the class files. A class loader loads the class files. The class loader loads class files from an application and the class files from the Java application programming interfaces APIs which an application may need. In particular the class loader skips a translating step when internal representations are available. The execution engine that executes the bytecodes may vary across platforms and implementations.

To better access executable file a Java virtual machine may have a path or paths established in a configuration file such that the Java virtual machine searches among such paths for class files and executable class resources. To avoid ambiguity when loading and processing such files a developer may establish executable file with a unique name as related to other files stored among the paths.

The class loader determines whether the class file has been found step . A negative determination may result in the class loader reporting a failure step with the process terminating thereafter. A positive determination results in the class loader reading the contents of the class file into a byte array and passing a reference to the byte array to a function for example defineClass step with the process terminating thereafter. A Java specified application programming interface is a program that defines how to create a class from a sequence of bytes. This step includes reading individual class proxy files each having a .class suffix.

If virtual machine finds no class proxy files as occurs when step is negative virtual machine behaves like a conventional class loader. Virtual machine further checks to determine if any files have a class format validator for example 0xCAFEBABE step . The class validator if 0xCAFEBABE is known as the magic number for Sun class files and indicates that the file contains class files. Sun is a trademark of Sun Microsystems Incorporated. If any necessary file lacks the validator the virtual machine performs step . Otherwise virtual machine creates an internal representation of the class file as an object in the data processor for example data processing system of .

The virtual machine may create an internal representation in two steps as may occur in an IBM J9 Java Virtual Machine. First the virtual machine may translate the class file into at least one of modified bytecode or modified metadata step . Second the virtual machine may create a dynamic internal representation and establish access instructions for later use by virtual machine step . Dynamic internal representation type of class is a defined set of data structures that allocate space for each variable that the instantiated object may use for example counters indexes and other variables that are used to temporarily store information. Such variables are set aside from other objects or classes to maintain better data integrity. Java stacks of are a kind of dynamic internal representation type. It is appreciated that other virtual machines may be built that perform translating step and creating step as one step and still remain within the scope of the invention.

The virtual machine determines if a set of modified class data is loaded into the virtual machine step in response to a positive determination from step . A positive determination from step causes virtual machine to obtain a modified class data representation of the class step . Obtaining includes looking up an offset into memory to find a beginning part to the modified bytecodes and a set of values wherein the modified bytecodes and set of values may comprise an internal representation. Obtaining includes providing a virtual machine access to the modified class data representation and the set of values. The virtual machine then creates a dynamic internal representation for use by the modified class data during operation of modified class data step . It is appreciated that although the present illustrative embodiment of the invention obtains a modified class data of the class other embodiments may obtain other internal representations.

The virtual machine may handle a negative determination at step in two or more ways depending on which form the Java archive file takes among the exemplary forms shown in and . Generally the ways can be among the steps performed when the virtual machine locates and loads a set of modified class data step .

One mechanism for handling a negative determination at step involves the virtual machine reading a class proxy file for example class proxy file of . The Java archive file has a Java executable class resource that includes a modified class data for at least one class proxy file in Java archive file . Class proxy file includes a locator that points to an offset within executable class resource or an offset within the archive file. The offset represents the beginning of a modified class data corresponding to class proxy file . Thus the virtual machine or class loader reads the locator from class proxy file . In addition virtual machine loads the modified class data by looking up the modified class data based on the locator. Looking up may include opening the class proxy file .

A second way at step to locate a set of modified class data involves virtual machine reading a class proxy file for example class proxy file of . Java archive file may lack an executable class resource. Instead each class proxy file may have a locator that names an external file with a file path. The file path in this case may include a file name. The file path may be a path that references a directory within a file system of a data processor for example data processor of . In the latter case the virtual machine finds a file that is located on a file system in the file path and uses a default file name. The file system may be for example located on hard disk drive of . Illustrative embodiments of the present invention organize such executable file as shown in .

Java virtual machine may also modify metadata step . For example a virtual machine may compress metadata. More specifically a class file may have many strings that include Java.lang.Object . Such strings if stored internally in full form cause excessive use of memory. Consequently the J9 Java virtual machine may replace each occurrence of Java.lang.Object with an offset into memory where a single representation of Java.lang.Object is located. It is appreciated that many other forms of data compression and re organization may be performed and remain within the scope of this step.

Upon concluding step virtual machine will have created a modified class data. Operation of the embodiment of the present invention that takes the affirmative path in step provides access to modified class data that is contained within the file loaded earlier. Therefore an affirmative path from step permits skipping the lengthy steps of .

A developer may hand edit or use an authoring tool to make an executable class resource such as for example Java executable class resource of . The authoring tool stores a distinctive pattern to a file such that the file has a class name. The authoring tool stores a modified class data to the file to form the executable class resource. In addition the authoring tool may place the file in an archive file for example Java archive file of . Placing means that the tool may compress the file and add metadata to the archive file or other data structure to sort and locate the file later. The authoring tool may add a class proxy file for example class proxy file of . Class proxy file has a locator that references the modified class data.

Thus a virtual machine according to the illustrative embodiments of the present invention may shorten a process of processing class files by detecting the presence of internal representations. Once such internal representations are found a time consuming step of translating is avoided. Consequently a user may find a data processing system more responsive.

Although a Java virtual machine has been shown in one or more illustrative embodiments of the present invention it is appreciated that the invention encompasses any kind or class of virtual machine.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment a developer would implement the invention in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any tangible apparatus that can contain or store the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device . Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories. Such memory elements provide temporary storage of at least some program code in order to reduce the number of times code is retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters coupled to the system enable the data processing system to couple to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

The inventors present this description of the present invention for purposes of illustration and description and do not intend it to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

