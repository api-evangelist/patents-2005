---

title: Mobile networking system and method using IPv4 and IPv6
abstract: A method for communicating Internet Protocol data over a network, comprises providing an IPv4 data stream and providing an IPv6 data stream. An encrypted Internet Protocol communications tunnel is established through the network between a roaming mobile device and a further computing device. The IPv4 and IPv6 data streams are combined for encapsulation within and transmission through said encrypted tunnel. Continual secure communications of the encapsulated IPv4 and IPv6 data streams is maintained between said roaming mobile device and the further computing device while the roaming mobile device roams between network access points. The encapsulated, transmitted IPv4 and IPv6 data streams are received from said tunnel, and the received IPv4 and IPv6 data streams are demultiplexed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07644171&OS=07644171&RS=07644171
owner: Netmotion Wireless, Inc.
number: 07644171
owner_city: Seattle
owner_country: US
publication_date: 20051019
---
This application is a continuation in part of application Ser. No. 11 149 584 filed 10 Jun. 2005 entitled Mobile Networking System and Method 3978 29 currently pending which application claims the benefit of U.S. Provisional Application No. 60 578 318 filed Jun. 10 2004 entitled Mobile Networking System and Method and U.S. provisional Application No. 60 619 777 filed 19 Oct. 2004. This application is related to U.S. Provisional Application Ser. No. 60 103 598 filed Oct. 9 1998 entitled Method And Apparatus For Providing Wireless Connectivity In A Computing Environment U.S. Provisional Application Ser. No. 60 176 305 filed Jan. 18 2000 entitled Method And Apparatus For Providing Mobile and Other Intermittent Connectivity In A Computing Environment U.S. Provisional Application Ser. No. 60 274 615 filed Mar. 12 2001 entitled Method And Apparatus For Providing Mobile and Other Intermittent Connectivity In A Computing Environment U.S. patent application Ser. No. 09 330 310 filed Jun. 11 1999 entitled Method And Apparatus For Providing Mobile and Other Intermittent Connectivity In A Computing Environment now U.S. Pat. No. 6 546 425 U.S. patent application Ser. No. 09 660 500 filed Sep. 12 2000 entitled Method And Apparatus For Providing Mobile and Other Intermittent Connectivity In A Computing Environment now U.S. Pat. No. 7 293 107 and PCT International Application Number PCT US01 28391 filed Sep. 12 2001 entitled Method And Apparatus For Providing Mobile And Other Intermittent Connectivity In A Computing Environment .

All of the above mentioned patent applications are incorporated herein by reference as if expressly set forth.

The technology herein relates to connectivity between networked computing devices. More particularly the technology herein relates to methods and systems that transparently address the characteristics of nomadic systems and enable existing network applications to run reliably in the associated mobile environments. Still more particularly the techniques and systems herein provide a continuous data stream connection between intermittently connected devices such as handheld data units and personal computing devices.

Increasingly companies are seeing rapid access to key information as the way to maintaining a competitive advantage. To provide immediate access to this information mobile and other intermittently connected computing devices are quietly and swiftly becoming an essential part of corporate networks especially with the proliferation of inexpensive laptops and hand held computing devices. However integrating these nomadic devices into existing network infrastructures has created a challenge for the information manager.

Many problems in mobile networking parallel the difficulties in early local area networks LANs before the adoption of Ethernet. There are a variety of mobile protocols and interfaces and because standards are just developing there is little interoperability between systems. In addition performance over these network technologies has typically been slow and bandwidth limited. Implementation costs to date have been high due the specialized nature of deployed systems.

Along with these issues mobile technologies present a category of problems unto their own. Interconnects back into the main network may travel over and through a public network infrastructure thus allowing sensitive information to possibly be tapped into. Furthermore if any of the intermediary interconnects are via a wireless interface the information is actually broadcast and anyone with a similar interface can eavesdrop without much difficulty.

But perhaps even more significantly mobile networking has generally in the past been limited to mostly message oriented or stateless applications and thus has not been readily adaptable for existing or new corporate applications that use client server host terminal web based or shared file systems models. This is because such commonly used applications need stateful sessions that employ a continuous stream of data not just a stateless packet exchange to work effectively and reliably.

To this end many or most popular off the shelf networking applications require TCP IP sessions or private virtual circuits. These sessions cannot continue to function if they encounter network interruptions nor can they tolerate roaming between networks i.e. a change of network addresses while established. Yet mobile networking is by its nature dynamic and unreliable. Consider these common scenarios encountered in mobile networks 

When a mobile device disconnects from a given network or loses contact e.g. through an outage or hole in the coverage of a wireless interconnect the session oriented application running on the mobile device loses its stateful connection with its peer and ceases to operate. When the device is reattached or moves back into contact the user must re connect log in again for security purposes find the place in the application where work was left off and possibly re enter lost data. This reconnection process is time consuming costly and can be very frustrating.

Mobile networks are generally segmented for manageability purposes. But the intent of mobile devices is to allow them to roam. Roaming from one network interconnect to another can mean a change of network address. If this happens while the system is operational the routing information must be changed for communications to continue between the associated peers. Furthermore acquiring a new network address may require all of the previously established stateful application sessions to be terminated again presenting the reconnection problems noted above.

As mentioned before companies need to protect critical corporate data. Off the shelf enterprise applications are often written with the assumption that access to the physical network is controlled i.e. carried within cables installed inside a secure facility and security is maintained through an additional layer of authentication and possible encryption. These assumptions have not been true in the nomadic computing world where data is at risk for interception as it travels over public airways or public wire line infrastructures.

Further to the exemplary illustrative non limiting functionality outlined above another capability is emerging throughout the industry. Due to the potential exhaustion of Internet Protocol Version 4 address space the industry deemed it necessary to develop a new standard that will extend and enhance the networking layer functionality for IP based networks as initially described in IETF RFC 1863 October 1995 incorporated herein by reference . However to increase the available address space a new format was devised. This new format is larger thus rendering some existing networking infrastructure and end system technologies incompatible with the new IP protocol.

The IETF has recognized this deficiency however the solution that has been standardizes is to encapsulate IPv4 packets within IPv6 packets or visa versa thus enabling either protocol to traverse existing network infrastructure known colloquially as 6over4 and 4over6 . Furthermore there are discrepancies between the IPv4 and IPv6 IP protocol specifications with regards to how each deals with mobility.

Having to deploy multiple protocol stacks to ensure interoperability depending on what environments the device might be coupled to at any one point in time may cause an undue burden for a number of reasons 

Thus there is an emerging need to enable proxy based approaches as described above that will allow Mobile End Systems whether fixed or not to use underlying network infrastructure regardless of what version of Internet Protocol is being used.

It would be highly desirable to provide an integrated solution that transparently addresses the characteristics of nomadic systems and enables existing network applications to run reliably in these mobile environments.

The technology herein solves this problem by providing a seamless solution that extends the enterprise network letting network managers provide mobile users with easy access to the same applications as stationary users without sacrificing reliability or centralized management. The solution combines advantages of present day wire line network standards with emerging mobile standards to create a solution that works with existing network applications.

Another aspect of this exemplary illustrative non limiting approach allows designers of end system devices to reduce the requirements on mobile end systems as the network infrastructure evolves. One such exemplary illustrative non limiting functionality would be recognized as the Internet changes from an IPv4 backbone to an IPv6 backbone. As the v4 infrastructure is deprecated there will still be a need to gain access to legacy v4 based application however it will be done over the v6 infrastructure. To reduce the complexity of the end system using an exemplary illustrative non limiting proxy based approach allows the designers to distribute the higher layer interface library software for IPv4 application to interact with without the need to distribute the lower level IPv4 IP layer functionality. The services of the proxy system s may then be used to create the communications session with the ultimate peer. This can also be done in reverse which may be more prevalent today. Designers can for example deploy just the higher layer application programming interfaces for IPv6 applications and deploy the full v6 protocol stack only at the proxy system s .

Exemplary illustrative technology herein for example provides a method for communicating Internet Protocol data over a network comprising providing an IPv4 data stream providing an IPv6 data stream establishing an encrypted Internet Protocol communications tunnel through said network between a roaming mobile device and a further computing device combining said IPv4 and IPv6 data streams for encapsulation within and transmission through said encrypted tunnel maintaining continual secure communications of said encapsulated IPv4 and IPv6 data streams between said roaming mobile device and said further computing device while said roaming mobile device roams between network access points receiving said encapsulated transmitted IPv4 and IPv6 data streams from said tunnel and demultiplexing said received IPv4 and IPv6 data streams

In this particular example Mobile End Systems are sometimes but not always actively connected to Mobility Management Server . For example 

Other Mobile End Systems . . . may communicate with Mobility Management Server via non permanent wire based interconnects such as docking ports network cable connectors or the like. There may be a temporary loss of communications when Mobile End Systems are temporarily disconnected from LAN by breaking connection powering off the Mobile End Systems etc.

Mobile End Systems may be standard mobile devices and off the shelf computers. For example Mobile End System may comprise a laptop computer equipped with a conventional radio transceiver and or network cards available from a number of manufacturers. Mobile End Systems may run standard network applications and a standard operating system and communicate on the transport layer using a conventionally available suite of transport level protocols e.g. TCP IP suite. Mobile End Systems also execute client software that enables them to communicate with Mobility Management Server using Remote Procedure Call and Internet Mobility Protocols that are transported using the same such standard transport level protocols.

Mobility Management Server may comprise software hosted by a conventional Windows NT or other server. In one exemplary non limiting implementation Mobility Management Server is a standards compliant client server based intelligent server that transparently extends the enterprise network to a nomadic environment. Mobility Management Server serves as network level proxy for each of any number of Mobile End Systems by maintaining the state of each Mobile End System and by handling the complex session management required to maintain persistent connections to any peer systems that host network applications despite the mobile interconnect between Mobile End Systems and transceivers being intermittent and unreliable.

For example server allows any conventional e.g. TCP IP based network application to operate without modification over mobile connection. Server maintains the sessions of Mobile End Systems that disconnect go out of range or suspend operation and resumes the sessions when the Mobile End System returns to service. When a Mobile End System becomes unreachable shuts down or changes its point of presence address the Mobility Management Server maintains the connection to the peer system by acknowledging receipt of data and queuing requests until the Mobile End System once again becomes available and reachable.

Server also extends the management capabilities of wired networks to mobile connections. Each network software layer operates independently of others so the solution can be customized to the environment where it is deployed.

As one example Mobility Management Server may be attached to a conventional organizational network such as a local area network or wide area network. Network may be connected to a variety of fixed end systems e.g. one or most host computers . Mobility Management Server enables Mobile End Systems to communicate with Fixed End System s using continuous session type data streams even though Mobile End Systems sometimes lose contact with their associated network interconnect or move from one network interconnect to another e.g. in the case of wireless interconnect by roaming from one wireless transceiver coverage area to another .

A Mobile End System establishes an association with the Mobility Management Server either at startup or when the Mobile End System requires network services. Once this association is established the Mobile End System can start one or more network application sessions either serially or concurrently. The Mobile End System to Mobility Management Server association allows the Mobile End System to maintain application sessions when the Mobile End System disconnects goes out of range or suspends operation and resume sessions when the Mobile End System returns to service. In an exemplary illustrative non limiting implementation this process is entirely automatic and does not require any intervention on the user s part.

Mobile End Systems communicates with Mobility Management Server using conventional transport protocols such as for example UDP IP. Use of conventional transport protocols allows Mobile End Systems to communicate with Mobility Management Server using the conventional routers and other infrastructure already existing on organization s network . A higher level Remote Procedure Call protocol generates transactions into messages that are sent over the mobile enhanced network via the standard transport protocol s . In this exemplary illustrative non limiting implementation these mobile RPC messages contain the entire network transaction initiated by an application running on the Mobile End System so it can be completed in its entirety by the Mobility Management Server. This enables the Mobility Management Server and Mobile End System to keep connection state information synchronized at all times even during interruptions of network medium connectivity.

Each of Mobile End Systems executes a mobility management software client that supplies the Mobile End System with the intelligence to intercept all network activity and relay it via the mobile RPC protocol to Mobility Management Server . In an exemplary illustrative non limiting implementation the mobility management client works transparently with operating system features present on Mobile End Systems e.g. Windows NT Windows 98 Windows 95 Windows CE etc. to keep client site application sessions active when contact is lost with the network.

Mobility Management Server maintains the state of each Mobile End System and handles the complex session management required to maintain persistent connections to an associated peer s such as host computer attached to the other end of the connection end point. If a Mobile End System becomes unreachable suspends or changes network address e.g. due to roaming from one network interconnect to another the Mobility Management Server maintains the connection to the host system or other connection end point by acknowledging receipt of data and queuing requests. This proxy function means that the peer application never detects that the physical connection to the Mobile End System has been lost allowing the Mobile End System s application s to effectively maintain a continuous connection with its associated session end point by simply and easily resuming operations once a physical connection again is established despite the mobile system temporarily losing connection or roaming from one network interconnect A to another network interconnect K within coverage area K.

Mobility Management Server also provides address management to solve the problem of Mobile End Systems receiving different network addresses when they roam to different parts of the segmented network. Each Mobile End System is provided with a virtual address on the primary network. Standard protocols or static assignment determine these virtual addresses. For each active Mobile End System Mobility Management Server maps the virtual address to the Mobile End System s current actual point of presence address. While the point of presence address of a Mobile End System may change when the device changes from one network segment to another the virtual address stays constant while any connections are active or longer if the address is assigned statically.

Thus the change of a point of presence address of a Mobile End System remains entirely transparent to an associated session end point on host system or other peer communicating with the Mobile End System via the Mobility Management Server . The peer sees only the unchanging virtual address proxied by the server .

In an exemplary illustrative non limiting implementation Mobility Management Server can also provide centralized system management through console applications and exhaustive metrics. A system administrator can use these tools to configure and manage remote connections and troubleshoot remote connection and system problems.

The proxy server function provided by Mobility Management Server allows for different priority levels for network applications users and machines. This is useful because each Mobility Management Server is composed of finite processing resources. Allowing the system manager to configure the Mobility Management Server in this way provides enhanced overall system and network performance. As one example the system manager can configure Mobility Management Server to allow real time applications such as streaming audio or video to have greater access to the Mobility Management Server s resources than other less demanding applications such as email.

In more detail Mobility Management Server can be configured via an application or application interface standard network management protocols such as SNMP a Web based configuration interface or a local user interface. It is possible to configure association priority and or to configure application priority within an association. For example the priority of each association relative to other associations running through the Mobility Management Server is configurable by either the user name or the machine name in the preferred implementation when the priority is configured for both the user and the machine that a user is logged in on the configuration for the user may have higher precedence . In addition or alternatively each association may have several levels of application priority which is configured based on network application name. The system allows for any number of priority levels to exist. In one particular implementation three priority levels are provided low medium and high.

A new mobile interceptor component is inserted between the TCP UDP transport module and the transport driver interface TDI of the Mobile End System software architecture. Mobile interceptor intercepts certain calls at the TDI interface and routes them via RPC and Internet Mobility Protocols and the standard TCP UDP transport protocols to Mobility Management Server over network . Mobile interceptor thus can intercept all network activity and relay it to server . Interceptor works transparently with operating system features to allow client side application sessions to remain active when the Mobile End System loses contact with network .

While mobile interceptor could operate at a different level than the transport driver interface e.g. at the socket API level there are advantages in having mobile interceptor operate at the TDI level or more specifically any transport protocol interface. For brevity sake all references to the transport driver interface will be denoted using the acronym TDI. Many conventional operating systems e.g. Microsoft Windows 95 Windows 98 Windows NT and Windows CE etc. provide TDI interface thus providing compatibility without any need to change operating system components. Furthermore because the transport driver interface is normally a kernel level interface there is no need to switch to user mode thus realizing performance improvements. Furthermore mobile interceptor working at the level of TDI interface is able to intercept from a variety of different network applications e.g. multiple simultaneously running applications as well as encompassing network file print and other kernel mode services which would have to be handled differently if the interceptor operated at the socket API level for example .

Referring once again to Mobility Management Server includes an address translator that intercepts messages to from Mobile End Systems via a conventional network interface driver . For example address translator recognizes messages from an associated session peer Fixed End System destined for the Mobile End System virtual address. These incoming Mobile End System messages are provided to proxy server which then maps the virtual address and message to previously queued transactions and then forwards the responses back to the current point of presence addresses being used by the associated Mobile End System .

As also shown in Mobility Management Server includes in addition to address translation intermediate driver and proxy server a configuration manager a control user interface and a monitor . Configuration management is used to provide configuration information and parameters to allow proxy server to manage connections. Control user interface and monitor allow a user to interact with proxy server .

Mobile interceptor in the exemplary illustrative non limiting implementation thus supports Remote Procedure Call protocol and Internet Mobility Protocol to connect Mobility Management Server to each Mobile End Systems . Remote procedure calls provide a method for allowing a process on a local system to invoke a procedure on a remote system. Typically the local system is not aware that the procedure call is being executed on a remote system. The use of RPC protocols allows Mobile End Systems to go out of range or suspend operation without losing active network sessions. Since session maintenance does not depend on a customized application off the shelf applications will run without modification in the mobile environment of network .

Network applications typically use application level interfaces such as Windows sockets. A single call to an application level API may generate several outgoing or incoming data packets at the transport or media access layer. In prior mobile networks if one of these packets is lost the state of the entire connection may become ambiguous and the session must be dropped. In the exemplary illustrative non limiting example implementation providing RPCs the Mobility Management Server and the Mobile End Systems share sufficient knowledge of the connection state to maintain a coherent logical link at all times even during physical interruption.

The exemplary illustrative non limiting implementation Internet Mobility Protocol compensates for differences between wire line and other less reliable networks such as wireless. Adjusted frame sizes and protocol timing provide significant performance improvements over non mobile aware transports dramatically reducing network traffic. This is important when bandwidth is limited or when battery life is a concern.

The Internet Mobility Protocol provided in accordance with a presently preferred non limiting implementation also ensures the security of an organization s data as it passes between the Mobile End System and the Mobility Management Server on the public wire line networks or airway. The Internet Mobility Protocol provides a basic firewall function by allowing only authenticated devices to access the organizational network. The Internet Mobility Protocol can also certify and encrypt all communications between the mobility management system and the Mobile End System .

The Remote Procedure Call protocol engine on Mobile End System of marshals TDI call parameters formats the data and sends the request to the Internet Mobility Protocol engine for forwarding to Mobility Management Server where the TDI Remote Procedure Call engine executes the calls. Mobile End Systems martial TDI call parameters according to the Remote Procedure Call protocol. When the Mobility Management Server TDI Remote Procedure Call protocol engine receives these RPCs it executes the calls on behalf of the Mobile End System . The Mobility Management Server TDI Remote Procedure Call protocol engine shares the complete network state for each connected Mobile End System with the peer Mobile End System s RPC engine . In addition to performing remote procedure calls on behalf of the Mobile End Systems the server RPC engine is also responsible for system flow control remote procedure call parsing virtual address multiplexing in coordination with services provided by address translator remote procedure call transaction prioritization scheduling policy enforcement and coalescing.

The Internet Mobility Protocol engine performs reliable datagram services sequencing fragmentation and re assembly of messages. It can when configured also provide authentication certification data encryption and compression for enhanced privacy security and throughput. Because the Internet Mobility Protocol engine functions in power sensitive environments using several different transports it is power management aware and is transport independent.

When the coalesce timer expires or the RPC protocol engine determines that it will not be receiving more RPC calls decision block the RPC engine provides the Internet Mobility Protocol engine with a request to flush the queue coalesce the RPC calls into a single frame and forward the frame to its peer block . This coalescing reduces the number of transmissions enhancing protocol performance. However the Internet Mobility Protocol may also decide to flush queue based on other external criteria to further optimize performance. In an exemplary illustrative non limiting implementation if a single RPC request will fill an entire frame the IMP layer will automatically try to send the request to the peer.

As mentioned above the Mobility Management Server proxy server also has an RPC protocol engine and an Internet Mobility Protocol engine . shows an example process performed by Mobility Management Server upon receipt of an Internet Mobility Protocol message frame from Mobile End System . Once the frame is received by the Mobility Management Server the Internet Mobility Protocol engine reconstructs the frame if fragmented due to the maximum transmission size of the underlying transport and then demultiplexes the contents of the message to determine which Mobile End System it was received from. This demultiplexing allows the Internet Mobility Protocol to provide the Remote Procedure Call engine with the correct association specific context information.

The Internet Mobility Protocol engine then formulates the received message into a RPC receive indication system work request and provides the Mobility Management Server RPC engine with the formulated work request and association specific context information. When RPC protocol engine receives work request it places it into an association specific work queue and schedules the association to run by providing a scheduled request to a global queue . The main work thread of RPC engine is then signaled that work is available. Once the main thread is awake it polls the global queue to find the previously queued association scheduled event. It then de queues the event and beings to process the association specific work queue .

On the association specific work queue it finds the previously queued RPC receive indication work request . The main thread then de queues the RPC receive indication work request and parses the request. Because of the coalescing described in connection with the Mobility Management Server often receives several RPC transactions bundled in each datagram. It then demultiplexes each RPC transaction back into distinct remote procedure calls and executes the requested function on behalf of Mobile End System . For performance purposes RPC engine may provide a look ahead mechanism during the parsing process of the RPC messages to see if it can execute some of the requested transactions concurrently pipelining .

There are six basic types of RPC work requests in an exemplary illustrative non limiting implementation 

RPC protocol engine handles these various types of requests differently depending upon its type. RPC protocol engine tests the request type indicated by information associated with the request as stored on global queue in order to determine how to process the request.

If the type of work request is a schedule request decision block the RPC engine determines which association is being scheduled block . RPC engine can determine this information from what is stored on global queue . Once the association is known RPC engine can identify the particular one of association work queues . . . the corresponding request is stored on. RPC engine retrieves the corresponding association control block block and calls a Process Association Work task to begin processing the work in a specific association s work queue as previously noted.

The above process continues to loop until a scheduling weight complete test block is satisfied. In this example a scheduling weight is used to decide how many work requests will be de queued and processed for this particular association. This scheduling weight is a configuration parameter set by configuration manager and is acquired when the association connect indication occurs block . This value is configurable based on user or the physical identification of the machine.

Once the RPC engine is finished with the association work queue for the time at least it may proceed to process dispatch queues block to be discussed in more detail below . If after processing work on the association s work queue more work remains in the association work queue the RPC engine will reschedule the association to run again at a later time by posting a new schedule request to the global work queue decision block block decision block block .

Referring once again to if the RPC work request is a connect indication decision block RPC engine is being requested to instantiate a new association with a mobile peer usually but not always the Mobile End System . As one example the connect indication may provide the RPC engine with the following information about the peer machine which is initiating the connection 

In response to the connect indication decision block the RPC engine calls the configuration manager with these parameters. Configuration manager uses these parameters to determine the exact configuration for the new connection. The configuration e.g. association scheduling weight and the list of all applications that require non default scheduling priorities along with those priorities is then returned to the RPC engine for storage and execution. RPC engine then starts the new association and creates a new association control block block . As shown in the following actions may be taken 

A disconnect indication is issued by the Internet Mobility Protocol engine to the RPC engine when the Internet Mobility Protocol engine has determined that the association must be terminated. The RPC engine tests for this disconnect indication block and in response stops the association and destroys the association control block block . As shown in the following steps may be performed 

A terminate session request is issued when system has determined that the association must be terminated. This request is issued by the system administrator the operating system or an application. RPC engine handles a terminate session request in the same way it handles a disconnect request decision block block .

In the exemplary illustrative non limiting implementation the interface between the RPC engine and the Internet Mobility Protocol engine specifies a flow control mechanism based on credits. Each time one thread posts a work request to another thread the called thread returns the number of credits left in the work queue. When a queue becomes full the credit count goes to zero. By convention the calling thread is to stop posting further work once the credit count goes to zero. Therefore the exemplary non limiting implementation provides a mechanism to tell the calling thread that resources are available once the queued work is processed and more room is available by some user configurable pre determined low water mark in the queue. This is the purpose of the resources available work indication tested for by decision block . As shown in the following steps may be performed when the credit count goes to zero 

When the resources available indication is received by the RPC engine decision block the RPC engine determines whether the association has work pending in its associated association work queue if it does the RPC engine marks the queue as eligible to run by posting the association to the global work queue block . If a pending receive request has been posted during the time the association was in the low mark pending state it is processed at this time in the exemplary illustrative non limiting implementation the RPC engine continues to accept any received connect requests during this processing .

Referring once again to if RPC engine determines that the Mobility Management Server channel used for ping has been inactive for a specified period of time decision block the channel is closed and the resources are freed back to the system to be used by other processes block .

Referring back to it was noted above that RPC engine parsed an RPC receive request upon receipt see blocks block . Parsing is used in the exemplary illustrative non limiting implementation because a single received datagram can contain multiple RPC calls and because RPC calls can span multiple Internet Mobility Protocol datagram fragments. An example format for an RPC receive work request is shown in . Each RPC receive work request has at least a main fragment and may have any number of additional fragments . . . N . Main fragment contains the work request structure header and a receive overlay . The receive overlay is a structure overlay placed on top of the fragment by the Internet Mobility Protocol engine .

Within this overlay is a structure member called pUserData that points to the first RPC call within the work request .

The example illustrates a work request that contains several RPC calls . . . . As shown in the example an RPC work request need not be contained in a contiguous block of memory or in a single fragment . In the example shown a second fragment and a third fragment that are chained together to the main fragment in a linked list.

Once the parser identifies an RPC call type a pointer to the beginning of the RPC information is passed to the RPC engine for execution. The RPC engine divides all TDI procedure calls into different priorities for execution. The highest priority calls are immediately executed by passing them to an RPC dispatcher for immediate execution. All lower priority calls are dispatched to dispatch queues for future processing. Each dispatch queue represents a discrete priority.

In the exemplary illustrative non limiting implementation mobile applications call the open address object and open connection object functions before executing other TDI networking functions. Therefore the system assigns application level priorities during the open address object and open connection object calls. In the example non limiting implementation once an address or connection object is assigned a priority all calls that are associated with that object are executed within that assigned priority.

If for example the RPC call is a TDI Open Address Object request or a TDI Open Connection Object Request it is sent to the RPC dispatcher for immediate execution. The Open Address and Open Connection object RPC calls provide access to a process ID or process name that are used to match against the information provided by the configuration manager during the configuration requests that occur within the association connect indication described earlier. This is used to acquire configuration for the address or connection object.

In the exemplary illustrative non limiting implementation all RPC calls have at least an address object or connection object as a parameter. When the call is made the priority assigned to that specific object is used as the priority for the RPC call. The configuration assigned to the address or connection object determines which priority all associated RPC calls will be executed in. For example if the assigned priority is high all RPC calls will be executed immediately without being dispatched to a dispatch queue . If the assigned priority is 1 all RPC calls will be placed into dispatch queue .

Referring once again to once the process association work task process has completed executing its scheduled amount of association work decision block it checks to see if the dispatch queues require servicing block . is a flowchart of example steps performed by the process dispatch queues block of to process the dispatch queues shown in .

In this example dispatch queues are processed beginning with the highest priority queue in this example block . Each queue is assigned a weight factor. The weight factor is a configuration parameter that is returned by the configuration manager when a Mobile End System to Mobility Management Server association is created. As one example low priority dispatch queues can have a weight factor of 4 and medium priority queues can have a weight factor of 8. High priority RPC calls do not in this example use weight factors because they are executed immediately as they are parsed.

RPC engine loops through the de queuing of RPC calls from the current queue until either the queue is empty or the queue weight number of RPC calls has been processed blocks . For each de queued RPC call the RPC dispatcher is called to execute the call. The RPC dispatcher executes the procedural call on behalf of the Mobile End System and formulates the Mobile End System response for those RPC calls that require responses.

If after exiting the loop the queue still has work remaining decision block the queue will be marked as eligible to run again block . By exiting the loop the system yields the processor to the next lower priority queue blocks . This ensures that all priority levels are given an opportunity to run no matter how much work exists in any particular queue. The system gets the next queue to service and iterates the process until all queues have been processed. At the end of processing all queues the system tests to see if any queues have been marked as eligible to run and if so the association is scheduled to run again by posting a schedule request to the global work queue. The association is scheduled to run again in the process global work routine shown in above. This approach yields the processor to allow other associations that have work to process an opportunity to run. By assigning each queue a weight factor the system may be tuned to allow different priority levels unequal access to the Mobility Management Server s CPU. Thus higher priority queues are not only executed first but may also be tuned to allow greater access to the CPU.

The discussion above explains how remote procedure calls are sent from the Mobile End System to the Mobility Management Server for execution. In addition to this type of RPC call the Mobility Management Server RPC engine also supports RPC events and RPC receive responses. These are RPC messages that are generated asynchronously as a result of association specific connection peer activity usually the Fixed End System . Mobility Management Server RPC engine completes RPC transactions that are executed by the RPC dispatcher . Not all RPC calls require a response on successful completion. Those RPC calls that do require responses on successful completion cause the RPC dispatcher to build the appropriate response and post the response to the Internet Mobile Protocol engine to be returned to the peer Mobile End System . All RPC calls generate a response when the RPC call fails the RPC receive response is the exception to above .

RPC events originate as a result of network activity by the association specific connection usually the Fixed End System . These RPC event messages are in the exemplary illustrative non limiting implementation proxied by the Mobility Management Server and forwarded to the Mobile End System . The exemplary illustrative non limiting Mobility Management Server supports the following RPC event calls 

The exemplary illustrative non limiting Internet Mobility Protocol is a message oriented connection based protocol. It provides guaranteed delivery re order detection and loss recovery. Further unlike other conventional connection oriented protocols i.e. TCP it allows for multiple distinct streams of data to be combined over a single channel and allows for guaranteed unreliable as well as new message oriented reliable data to traverse the network through the single virtual channel simultaneously. This new message oriented level of service can alert the requester when the Internet Mobility Protocol peer has acknowledged a given program data unit.

The Internet Mobility Protocol is designed to be an overlay on existing network topologies and technologies. Due to its indifference to the underlying network architecture it is transport agnostic. As long as there is a way for packetized data to traverse between two peers Internet Mobility Protocol can be deployed. Each node s network point of presence POP or network infrastructure can also be changed without affecting the flow of data except where physical boundary policy or limitations of bandwidth apply.

With the help of the layer above Internet Mobility Protocol coalesces data from many sources and shuttles the data between the peers using underlying datagram facilities. As each discrete unit of data is presented from the upper layer Internet Mobility Protocol combines it into a single stream and subsequently submits it for transmission. The data units are then forwarded to the peer over the existing network where upon reception with the help from the layer above the stream is demultiplexed back into multiple distinct data units. This allows for optimum use of available bandwidth by generating the maximum sized network frames possible for each new transmission. This also has the added benefit of training the channel once for maximum bandwidth utilization and having its parameters applied to all session level connections.

In rare instances in which one channel is insufficient the Internet Mobility Protocol further allows multiple channels to be established between the peers thus allowing for data prioritization and possibly providing a guaranteed quality of service if the underlying network provides the service .

The Internet Mobility Protocol also provides for dynamically selectable guaranteed or unreliable levels of service. For example each protocol data unit that is submitted for transmission can be queued with either a validity time period or a number of retransmit attempts or both. Internet Mobility Protocol will expire a data unit when either threshold is reached and remove it from subsequent transmission attempts.

Internet Mobility Protocol s additional protocol overhead is kept minimal by use of variable length header. The frame type and any optional fields determine the size of the header. These optional fields are added in a specific order to enable easy parsing by the receiving side and bits in the header flag field denote their presence. All other control and configuration information necessary for the peers to communicate can be passed through the in band control channel. Any control information that needs to be sent is added to the frame prior to any application level protocol data unit. The receiving side processes the control information and then passes the rest of the payload to the upper layer.

Designed to run over relatively unreliable network links where the error probability is relatively high Internet Mobility Protocol utilizes a number of techniques to insure data integrity and obtain optimum network performance. To insure data integrity a Fletcher checksum algorithm is used to detect errant frames. This algorithm was selected due to its efficiency as well as its detection capability. It can determine not only bit errors but also bit reordering. However other alternate checksum algorithms maybe used in its place.

Sequence numbers are used to insure ordered delivery of data. Internet Mobility Protocol sequence numbers do not however represent each byte of data as in TCP. They represent a frame of data that can be in one example implementation as large as 65535 bytes including the Internet Mobility Protocol header . They are 32 bits or other convenient length in one example to insure that wrap around does not occur over high bandwidth links in a limited amount of time.

Combining this capability along with the expiration of data retransmitted retried frames may contain less information than the previous version that was generated by the transmitting side. A frame id is provided to enable detection of the latest versioned frame. However since data is never added in the exemplary illustrative non limiting implementation and each element removed is an entire protocol data unit this is not a necessity for sequence assurance. In one example the Internet Mobility Protocol will only process the first instance of a specific frame it receives no matter how many other versions of that frame are transmitted. Each frame created that carries new user payload is assigned its own unique sequence number.

Performance is gained by using of a sliding window technique thus allowing for more then one frame to be outstanding transmitted at a time before requiring the peer to acknowledge reception of the data. To insure timely delivery of the data a positive acknowledgement and timer based retransmit scheme is used. To further optimize the use of the channel a selective acknowledgement mechanism is employed that allows for fast retransmission of missing frames and quick recovery during lossy or congested periods of network connectivity. In one example this selective acknowledgement mechanism is represented by an optional bit field that is included in the header.

A congestion avoidance algorithm is also included to allow the protocol to back off from rapid retransmission of frames. For example a round trip time can be calculated for each frame that has successfully transferred between the peers without a retransmit. This time value is averaged and then used as the basis for the retransmission timeout value. As each frame is sent a timeout is established for that frame. If an acknowledgement for that frame is not received and the frame has actually been transmitted the frame is re sent. The timeout value is then increased and used as the basis for the next retransmission time. This retransmit time out is bounded on both the upper and lower side to insure that the value is within a reasonable range.

Internet Mobility Protocol also considers the send and receive paths separately. This is especially useful on channels that are asymmetric in nature. Based on hysteresis the Internet Mobility Protocol automatically adjusts parameters such as frame size fragmentation threshold number of frames outstanding retransmit time and delayed acknowledgement time to reduce the amount of duplicate data sent through the network.

Due to the fact that Internet Mobility Protocol allows a node to migrate to different points of attachment on diverse networks characteristics e.g. frame size of the underlying network may change midstream. An artifact of this migration is that frames that have been queued for transmission on one network may no longer fit over the new medium the mobile device is currently attached to. Combining this issue with the fact that fragmentation may not be supported by all network infrastructures fragmentation is dealt with at the Internet Mobility Protocol level. Before each frame is submitted for transmission Internet Mobility Protocol assesses whether or not it exceeds the current fragmentation threshold. Note that this value may be less than the current maximum transmission unit for performance reason smaller frames have a greater likelihood of reaching its ultimate destination than larger frames . The tradeoff between greater protocol overhead versus more retransmissions is weighed by Internet Mobility Protocol and the frame size may be reduced in an attempt to reduce overall retransmissions . If a given frame will fit it is sent in its entirety. If not the frame is split into maximum allowable size for the given connection. If the frame is retransmitted it is reassessed and will be refragmented if the maximum transmission unit has been reduced or alternatively if the maximum transmission unit actually grew the frame may be re sent as a single frame without fragmentation .

The protocol itself is orthogonal in its design as either side may establish or terminate a connection to its peer. In a particular implementation however there may be a few minor operational differences in the protocol engine depending on where it is running. For example based on where the protocol engine is running certain inactivity detection and connection lifetime timeouts may be only invoked on one side. To allow administrative control Internet Mobility Protocol engine running on the Mobility Management Server keeps track of inactivity periods. If the specified period of time expires without any activity from the Mobile End System the Mobility Management Server may terminate a session. Also an administrator may want to limit the overall time a particular connection may be established for or when to deny access based on time of day. Again these policy timers may in one example implementation be invoked only on the Mobility Management Server side.

In one example implementation the software providing the Internet Mobility Protocol is compiled and executable under Windows NT 9x and CE environments with no platform specific modification. To accomplish this Internet Mobility Protocol employs the services of a network abstraction layer NAL to send and receive Internet Mobility Protocol frames. Other standard utility functions such as memory management queue and list management event logging alert system power management security etc are also used. A few runtime parameters are modified depending on whether the engine is part of Mobile End System or Mobility Management Server system. Some examples of this are 

The Internet Mobility Protocol interface may have only a small number of C callable platform independent published API functions and requires one O S specific function to schedule its work other then the aforementioned standard utility functions . Communications with local clients is achieved through the use of defined work objects work requests . Efficient notification of the completion of each work element is accomplished by signaling the requesting entity through the optional completion callback routine specified as part of the work object.

The Internet Mobility Protocol engine itself is queue based. Work elements passed from local clients are placed on a global work queue in FIFO order. This is accomplished by local clients calling a published Internet Mobility protocol function such as ProtocolRequestwork . A scheduling function inside of Internet Mobility Protocol then removes the work and dispatches it to the appropriate function. Combining the queuing and scheduling mechanisms conceal the differences between operating system architectures allowing the protocol engine to be run under a threaded based scheme e.g. Windows NT or in a synchronous fashion e.g. Microsoft Windows 9x Windows CE . A priority scheme can be overlaid on top of its queuing thus enabling a guaranteed quality of service to be provided if the underlying network supports it .

From the network perspective the Internet Mobility Protocol uses scatter gather techniques to reduce copying or movement of data. Each transmission is sent to the NAL as a list of fragments and is coalesced by the network layer transport. If the transport protocol itself supports scatter gather the fragment list is passed through the transport and assembled by the media access layer driver or hardware. Furthermore this technique is extensible in that it allows the insertion or deletion of any protocol wrapper at any level of the protocol stack. Reception of a frame is signaled by the NAL layer by calling back Internet Mobility Protocol at a specified entry point that is designated during the NAL registration process.

Internet Mobility Protocol in the example non limiting implementation exposes four common entry points that control its startup and shutdown behavior. These procedures are 

The Internet Mobility ProtocolCreate function is called by the boot subsystem to initialize the Internet Mobility Protocol. During this first phase all resource necessary to start processing work must be acquired and initialized. At the completion of this phase the engine must be in a state ready to accept work from other layers of the system. At this point Internet Mobility Protocol initializes a global configuration table. To do this it employs the services of the Configuration Manager to populate the table.

Next it registers its suspend and resume notification functions with the APM handler. In one example these functions are only invoked on the Mobile End System side but in another implementation it might be desirable to allow Mobility Management Server to suspend during operations. Other working storage is then allocated from the memory pool such as the global work queue and the global NAL portal list.

To limit the maximum amount of runtime memory required as well as insuring Internet Mobility Protocol handles are unique Internet Mobility Protocol utilizes a 2 tier array scheme for generating handles. The globalConnectionArray table is sized based on the maximum number of simultaneous connection the system is configured for and allocated at this time. Once all global storage is allocated and initialized the global Internet Mobility Protocol state is changed to  STATE INITIALIZE .

The Internet Mobility ProtocolRun function is called after all subsystems have been initialized and to alert the Internet Mobility Protocol subsystem that it is okay to start processing any queued work. This is the normal state that the Internet Mobility Protocol engine is in during general operations. A few second pass initialization steps are taken at this point before placing the engine into an operational state.

Internet Mobility Protocol allows for network communications to occur over any arbitrary interface s . During the initialization step the storage for the interface between Internet Mobility Protocol and NAL was allocated. Internet Mobility Protocol now walks through the global portal list to start all listeners at the NAL. In one example this is comprised of a two step process 

The Internet Mobility ProtocolHalt function is called to alert the engine that the system is shutting down. All resources acquired during its operation are to be release prior to returning from this function. All Internet Mobility Protocol sessions are abnormally terminated with the reason code set to administrative. No further work is accepted from or posted to other layers once the engine has entered into  STATE HALTED state.

The Internet Mobility ProtocolUnload function is the second phase of the shutdown process. This is a last chance for the engine to release any allocated system resources still being held before returning. Once the engine has returned from this function no further work will be executed as the system itself is terminating

In at least some examples using just the address of the memory which contains the Internet Mobility Protocol state information as the token to describe an Internet Mobility Protocol connection may be insufficient. This is mainly due to the possibility of one connection terminating and a new one starting in a short period of time. The probability that the memory allocator will reassign the same address for different connections is high and this value would then denote both the old connection and a new connection. If the original peer did not hear the termination of the session i.e. it was off suspended out of range etc. it could possibly send a frame on the old session to the new connection. This happens in TCP and will cause a reset to be generated to the new session if the peer s IP addresses are the same. To avoid this scenario Internet Mobility Protocol uses manufactured handles. The handles are made up of indexes into two arrays and a nonce for uniqueness. The tables are laid out as follows.

Table an array of connection objects that contains the real pointers to the Internet Mobility Protocol control blocks.

This technique minimizes the amount of memory being allocated at initialization time. Table is sized and allocated at startup. On the Mobile End System side this allows allocation of a small amount of memory the memory allocation required for this Table on the Mobility Management Server side is somewhat larger since the server can have many connections .

Table is then populated on demand. When a connection request is issued Internet Mobility Protocol searches through Table to find a valid pointer to Table . If no entries are found then Internet Mobility Protocol will allocate a new Table with a maximum of 256 connection objects and then stores the pointer to Table into the appropriate slot in Table . The protocol engine then initializes Table allocates a connection object from the newly created table and returns the manufactured handle. If another session is requested Internet Mobility Protocol will search Table once again finds the valid pointer to Table and allocates the next connection object for the session. This goes on until one of two situations exist 

Two global counters are maintained to allow limiting the total number of connections allocated. One global counter counts the number of current active connections and the other keeps track of the number of unallocated connection objects. The second counter is used to govern the total number of connection objects that can be created to some arbitrary limit. When a new Table is allocated this counter is adjusted downward to account for the number of objects the newly allocated table represents. On the flip side when Internet Mobility Protocol releases a Table instance back to the memory pool the counter is adjusted upward with the number of connection objects that are being released.

Work is requested by local clients through the Internet Mobility ProtocolRequestWork function. Once the work is validated and placed on the global work queue the Internet Mobility ProtocolWorkQueueEligible function is invoked. If in a threaded environment the Internet Mobility Protocol worker thread is signaled marked eligible and control is immediately returned to the calling entity. If in a synchronous environment the global work queue is immediately run to process any work that was requested. Both methods end up executing the Internet Mobility ProtocolProcessWork function. This is the main dispatching function for processing work.

Since only one thread at a time may be dispatching work from the global queue in the example non limiting implementation a global semaphore may be used to protect against reentrancy. Private Internet Mobility Protocol work can post work directly to the global work queue instead of using the Internet Mobility ProtocolRequestWork function.

A special case exists for SEND type work objects. To insure that the semantics of Unreliable Datagrams is kept each SEND type work object can be queued with an expiry time or with a retry count. Work will be aged based on the expiry time. If the specified timeout occurs the work object is removed from the connection specific queue and is completed with an error status. If the SEND object has already been coalesced into the data path the protocol allows for the removal of any SEND object that has specified a retry count. Once the retry count has been exceeded the object is removed from the list of elements that make up the specific frame and then returned to the requestor with the appropriate error status.

Internet Mobility Protocol includes a very efficient mechanism to establish connections between peers. Confirmation of a connection can be determined in as little as a three frame exchange between peers. The initiator sends an IMP SYNC frame to alert its peer that it is requesting the establishment of a connection. The acceptor will either send an IMP ESTABLISH frame to confirm acceptance of the connection or send an IMP ABORT frame to alert the peer that its connection request has been rejected. Reason and status codes are passed in the IMP ABORT frame to aid the user in deciphering the reason for the rejection. If the connection was accepted an acknowledgement frame is sent possibly including protocol data unit or control data and is forwarded to the acceptor to acknowledge receipt of its establish frame.

To further minimize network traffic the protocol allows user and control data to be included in the initial handshake mechanism used at connection startup. This ability can be used in an insecure environment or in environments where security is dealt with by a layer below such that the Internet Mobility Protocol can be tailored to avert the performance penalties due to double security authentication and encryption processing being done over the same data path.

Internet Mobility Protocol relies on signaling from the NAL to detect when a frame has been delivered to the network. It uses this metric to determine if the network link in question has been momentarily flow controlled and will not submit the same frame for retransmission until the original request has been completed. Some network drivers however lie about the transmission of frames and indicate delivery prior to submitting them to the network. Through the use of semaphores the Internet Mobility Protocol layer detects this behavior and only will send another datagram until the NAL returns from the original send request

Once a frame is received by Internet Mobility Protocol the frame is quickly validated then placed on an appropriate connection queue. If the frame does not contain enough information for Internet Mobility Protocol to discern its ultimate destination the frame is placed on the Internet Mobility Protocol socket queue that the frame was received on and then that socket queue is placed on the global work queue for subsequent processing. This initial demultiplexing allows received work to be dispersed rapidly with limited processing overhead.

To insure minimal use of network bandwidth during periods of retransmission and processing power on the Mobility Management Server the protocol allows the Mobility Management Server to acquiesce to a connection. After a user configurable period of time the Mobility Management Server will stop retransmitting frames for a particular connection if it receives no notification from the corresponding Mobile End System . At this point the Mobility Management Server assumes that the Mobile End System is in some unreachable state i.e. out of range suspended etc and places the connection into a dormant state. Any further work destined for this particular connection is stored for future delivery. The connection will remain in this state until one of the following conditions are met 

In the case that the Mobility Management Server receives a frame from the Mobile End System the connection continues from the point it was interrupted. Any work that was queued for the specific connection will be forwarded and the state will be resynchronized. In any of the other cases the Mobile End System will be apprised of the termination of the connection once it reconnects and work that was queued for the Mobile End System will be discarded.

For connect and other requests engine queues the connect or send request and signals a global event before return to the calling application block .

To dispatch a connect or send request from the Internet Mobility Protocol global request queue engine first determines whether any work is pending decision block . If no work is pending no exit to decision block engine waits for the application to queue work for the connection by going to block block . If there is work pending yes exit to decision block engine determines whether the current state has been established block . If the state establish has been achieved yes exit to decision block engine can skip steps used to transition into establish state and jump to decision block of block . Otherwise engine must perform a sequence of steps to enter establish state no exit to decision block .

In order to enter establish state engine first determines whether the address of its peer is known decision block . If not engine waits for the peer address while continuing to queue work and transitions to block block . If the peer address is known yes exit to decision block engine next tests whether the requisite security context has been acquired decision block . If not engine must wait for the security context while continuing to queue work and transitioning to block block . If security context has already been acquired yes exit to decision block engine declares a state pending state block and then sends an Internet Mobility Protocol sync frame block and starts a retransmit timer block . Engine determines whether the corresponding established frame was received block . If it was not no exit to decision block engine tests whether the retransmit time has expired decision block . If the decision block has not expired no exit to decision block engine waits and may go to step block . Eventually if the established frame is never received as tested for by block and a total retransmit time expires decision block the connection may be aborted block . If the established is eventually received yes exit to decision block engine declares a state established state block .

Once state established has been achieved engine tests whether the new connection has been authenticated decision block . If it has not been engine may wait and transition to step block . If the connection has been authenticated yes exit to decision block engine tests whether authentication succeeded decision block . If it did not no exit to decision block the connection is aborted block . Otherwise engine tests whether the peer transmit window is full decision block . If it is yes exit to decision block engine waits for acknowledgment and goes to step decision block . If the window is not full no exit to decision block engine creates an Internet Mobility Protocol data frame block and sends it block . Engine then determines if the retransmit timer has started decision block . If no engine starts the retransmit timer block . Engine loops through blocks until there is no more data to send as tested for by decision block . Engine then returns to a sleep mode waiting for more work and returns to the global dispatcher block .

Once a post mortem responsive frame has been received from the peer yes exit to decision block engine declares a post mortem state block releases connection resources block and returns to sleep waiting for more work block .

If the total retransmit period is not yet expired no exit to decision block engine reprocesses the frame to remove any expired data block and then retransmits it block restarting the retransmit timer as it does so block . The process then returns to sleep block to wait for the next event.

The validity period associated with a PDU specifies the relative time period that the respective PDU should be considered for transmission. During submission the Internet Mobility Protocol RequestWork function checks the expiry timeout value. If it is non zero an age timer is initialized. The requested data is then queued on the same queue as all other data being forwarded to the associated peer. If the given PDU remains on the queue for longer than the time period specified by the validity period parameter during the next event that the queue is processed the given all PDU s that has an expired timeout is removed and completed locally with a status code of timeout failure rather than being retransmitted when the frame is next retransmitted. This algorithm ensures that unreliable data being queued for transmission to the peer will not grow stale and or boundlessly consume system resources.

In the example shown in at least three separate PDUs are queued to Internet Mobility Protocol engine for subsequent processing. PDU is queued without an expiry time denoting no timeout for the given request. PDU is specified with a validity period of 2 seconds and is chronologically queued after PDU . PDU is queued 2.5 seconds after PDU was queued. Since the act of queuing PDU is the first event causing processing of the queue and PDU expiry time has lapsed PDU is removed from the work queue completed locally and then PDU is placed on the list. If a validity period was specified for PDU the previous sequence of events would be repeated. Any event queuing dequeuing etc that manipulates the work queue will cause stale PDUs to be removed and completed.

As described above PDUs are coalesced by the Internet Mobility Protocol Engine transmit logic and formatted into a single data stream. Each discrete work element if not previously expired by the validity timeout is gathered to formulate Internet Mobility Protocol data frames. Internet Mobility Protocol Engine ultimately sends these PDUs to the peer and then places the associated frame on a Frames Outstanding list. If the peer does not acknowledge the respective frame in a predetermined amount of time see showing the retransmission algorithm the frame is retransmitted to recover from possibly a lost or corrupted packet exchange. Just prior to retransmission the PDU list that the frame is comprised of is iterated through to determine if any requests were queued with a retry count. If the retry count is non zero and the value is decremented to zero the PDU is removed from the list and the frames header is adjusted to denote the deletion of data. In this fashion stale data unreliable data or applications employing their own retransmission policy are not burdened by engine s retransmission algorithm.

In the example again three separate PDUs are queued to Internet Mobility Protocol engine for subsequent processing. PDU is queued without a retry count. This denotes continuous retransmission attempts or guaranteed delivery level of service. PDU is queued with a retry count of 1 and is chronologically queued after PDU . PDU is queued sometime after PDU . At this point some external event e.g. upper layer coalesce timer etc. causes engine s send logic to generate a new frame by gathering enough PDUs from the work queue to generate an Internet Mobility Protocol data frame . The frame header is calculated and stamped with a retry ID of 0 to denote that this is the first transmission of the frame. The frame is then handed to the NAL layer for subsequent transmission to the network. At this point a retransmit timer is started since the frame in question contains a payload. For illustration purposes it is assumed that an acknowledgement is not received from the peer for a variety of possible reasons before the retransmit timer expires. The retransmit logic of engine determines that the frame in question is now eligible for retransmission to the network. Prior to resubmitting the frame to the NAL layer engine s retransmit logic iterates through the associated list of PDUs . Each PDU s retry count is examined and if non zero the count is decremented. In the process of decrementing PDU s retry count the retry count becomes zero. Because PDU s retry count has gone to zero it is removed from the list and completed locally with a status of retry failure. The frame header size is then adjusted to denote the absence of the PDU s data. This process is repeated for all remaining PDUs. Once the entire frame is reprocessed to produce an edited frame the retry ID in the header is incremented and the resultant datagram is then handed to the NAL layer for subsequent re transmission.

If the frame is associated with a connection yes exit to decision block engine determines whether the connection state is still active and not post mortem decision block . If the connection is already post mortem the frame is discarded block . Otherwise engine parses the frame block and determines whether it is an abort frame decision block . If the frame is an abort frame engine immediately aborts the connection block . If the frame is not an abort frame yes exit to decision block engine processes acknowledgment information and releases any outstanding send frames block . Engine then posts the frame to any security subsystem for possible decryption block . Once the frame is returned from the security subsystem engine processes any control data block . Engine then determines whether the frame contains application data decision block . If it does this data is queued to the application layer block . Engine also determines whether the connection s state is dormant block and this can happen on Mobility Management Server engine in the exemplary illustrative non limiting implementation and returns state back to established.

If the frame is possibly a Mortis frame yes exit to decision block engine indicates a disconnect to the application layer block and enters the Mortis state block . It sends a post mortem frame to the peer block and enters the post mortem state block . Engine then releases connection resources block and returns to sleep waiting for more work block . If the parsed frame is a post mortem frame yes exit to decision block blocks are executed. Otherwise control returns to block to dequeue the next frame from the receive queue block .

Blocks A B are together a flowchart of example steps performed by Internet Mobility Protocol engine in response to a passive connection request. Engine first determines whether there is another connection for this particular device block . If there is yes exit to decision block the engine determines whether it is the initial connection decision block . If peer believes the new connection is the initial connection yes exit to decision block engine aborts the previous connections block . If not the initial connection no exit to decision block engine tests whether the sequence and connection ID match decision block . If they do not match no exit to decision block control returns to decision block . If the sequence and connection ID do match yes exit to decision block engine discards duplicate frames block and returns to step of block .

If there is no other connection no exit to decision block engine determines whether it can allocate connection resources for the connection decision block . If it cannot an error is declared no exit to decision block block and the connection is aborted block . If it is possible to allocate connection resources yes exit to decision block engine declares a configure state block and acquires the security context for the connection block . If it was not possible to acquire sufficient security context no exit to decision block the connection is aborted block . Otherwise engine sends an established frame block and declares the connection to be in state establish block . Engine then starts a retransmitter block and waits for the authentication process to conclude block . Eventually engine tests whether the device and user have both been authenticated block . If either the device or the user is not authenticated the connection is aborted block . Otherwise engine indicates the connection to the listening application block and gets the configuration block . If either of these steps do not succeed the connection is aborted decision block block . Otherwise the process returns to sleep waiting for more work block .

Referring once again to mobile network may comprise a number of different segments providing different network interconnects corresponding to different wireless transceivers . In exemplary illustrative non limiting example implementations network including Mobility Management Server is able to gracefully handle a roaming condition in which a Mobile End System has moved from one network interconnect to another. Commonly network topographies are divided into segments subnets for management and other purposes. These different segments typically assign different network transport addresses to the various Mobile End Systems within the given segment.

It is common to use a Dynamic Host Configuration Protocol DHCP to automatically configure network devices that are newly activated on such a subnet. For example a DHCP server on the sub net typically provides its clients with among other things a valid network address to lease . DHCP clients may not have permanently assigned hard coded network addresses. Instead at boot time the DHCP client requests a network address from the DHCP server. The DHCP server has a pool of network addresses that are available for assignment. When a DHCP client requests an network address the DHCP server assigns or leases an available address from that pool to the client. The assigned network address is then owned by the client for a specified period lease duration . When the lease expires the network address is returned to the pool and becomes available for reassignment to another client. In addition to automatically assigning network addresses DHCP also provides netmasks and other configuration information to clients running DHCP client software. More information concerning the standard DHCP protocol can be found in RFC2131.

Thus when a Mobile End System using DHCP roams from one subnet to another it will appear with a new network address. In exemplary illustrative non limiting implementations Mobile End Systems and Mobility Management Server take advantage of the automatic configuration functionality of DHCP and coordinate together to ensure that the Mobility Management Server recognizes the Mobile End System s new network address and associates it with the previously established connection the Mobility Management Server is proxying on its behalf.

One example exemplary illustrative non limiting implementation uses standard DHCP Discover Offer client server broadcast messaging sequences as an echo request response along with other standard methodologies in order to determine if a Mobile End System has roamed to a new subnet or is out of range. In accordance with the standard DHCP protocol a Mobile End System requiring a network address will periodically broadcast client identifier and hardware address as part of a DHCP Discover message. The DHCP server will broadcast its Offer response this message is broadcast rather than transmitted specifically to the requesting Mobile End System because the Mobile End System doesn t yet have a network address to send to . Thus any Mobile End System on the particular subnet will pick up any DHCP Offer server response to any other Mobile End System broadcast on the same subnet.

This example non limiting implementation provides DHCP listeners to monitor the DHCP broadcast messages and thereby ascertain whether a particular Mobile End System has roamed from one subnet to another and is being offered the ability to acquire a new network address by DHCP. shows example DHCP listener data structures. For example a Mobile End System listener data structure may comprise 

These data structures are continually updated based on DHCP broadcast traffic appearing on network . The following example functions can be used to maintain these data structures 

In the exemplary illustrative non limiting implementation all Mobile End Systems transmit the same Client Identifier and Hardware Address in DHCP Discover requests. This allows the listener data structures and associated processes to distinguish Mobile End System originated Discover requests from Discover requests initiated by other network devices. Likewise the DHCP server will broadcast its response so any Mobile End System and or the Mobility Management Server will be able to pick up the DHCP server Offer response to any other Mobile End System. Since multiple DHCP servers can respond to a single DHCP Discover message the listener data structures shown in store each server response in a separate data block tied to the main handle via linked list.

Upon receiving a Discover request having the predetermined Client Hardware Address and Client Identifier the exemplary illustrative non limiting implementation recognizes this request as coming from a Mobile End System . If the message also has a BOOTP relay address set to zero this indicates that the message originated on the same subnet as the listener. Listeners may ignore all DHCP Offers unless they have a transaction ID xid matching that of a Discover message recently sent by a Mobile End System . The listener can determine that a Mobile End System has roamed if any response comes from a known server with a new BOOTP relay agent ID and or offered network address masked with an offered subnet mask. Listeners add new servers to the data structures only after receiving a positive response from an old server. If a listener receives responses from new server s but none from an old server this may indicate roaming this can be a configurable option . If the listener fails to receive responses from new or old servers the listener is out of range this determination can be used to signal an upper layer such as an application to halt or reduce sending of data to avoid buffer overflow .

If the listener never receives a response from any server there is no point of reference and thus it is impossible to determine whether roaming has occurred. This condition can be handled by signaling an error after a timeout and allowing the caller to retry the process. The exemplary illustrative non limiting implementation determines that a Mobile End System has roamed if any response has come from a known server with a new BOOTP relay agent ID or a new offered network address when masked with offered subnet mask . If the listener data structures see responses from new servers but none from an old server it is possible that roaming has occurred but there must be a delay before signaling in order to wait for any potential responses from the old servers. If there are no responses from new or old servers then the Mobile End System is probably out of range and Mobility Management Server waits for it to come back into range.

If a DHCP server packet has been received the packet is examined to determine whether its client identifier matches the predetermined client ID decision block . If it does not it is discarded. However if the packet does contain the predetermined ID a test is performed to determine whether the packet is a DHCP Offer packet decision block . Offer packets are rejected unless they contain a transaction ID matching a recently sent DHCP Discover sequence.

If the packet transaction ID matches block then a test is made as to whether the server sending the DHCP offer packet is known i.e. the server ID is in the listener data structure shown in block . If the server ID is not on the list no exit to decision block it is added to the list and marked as new or first if it is the first server on the list block . If the server is already on the list Y exit to decision block a further test is performed to determine whether the packet BOOTP relay address GIADDR matches the server address GIADDR decision block . If there is no match then the Offer packet must be originating from a different subnet and it is determined that a hard roam has occurred block . The caller application is signaled that there has been a roam. If on the other hand decision block determines there is a match in BOOTP relay addresses then no roam has occurred the listener process stamps the server receive time resets new flags for all other servers on the list and stores the current ping number with the server block . The process then returns to a wait period.

If the event is a received client packet the listener process determines whether the packet has the predetermined client ID is a DHCP Discover packet and has a BOOTP relay address GIADDR of 0 blocks . These steps determine whether the received packet is DHCP Discover message sent by another Mobile End System on the same sub net as the listener. If so the listener process then sets the transaction ID to the peer s transaction ID block for use in comparing with later received DHCP Offer packets calls a ping check block and resets the timer block .

In response to a timer timeout the process calls a ping check block . Pings in the exemplary illustrative non limiting implementation are DHCP Discover packets with a random new xid. Example steps for this ping check are shown in . The purpose of the ping check routine is to determine if a soft roam condition has occurred i.e. a Mobile End System has temporarily lost and then regained contact with a sub net but has not roamed to a different sub net . The process determines whether there is a sub net roam condition an out of range condition or a no server condition. In other words 

These conditions are determined by comparing Mobile End System prior ping response with the current ping response decision blocks . For example if the current ping number minus the old server s last ping response is greater than the sub net server pings and there is at least one server marked new there has been a sub net roam to a different server. The result of this logic is to either signal a subset roam an out of range condition or a no server condition or none of these to the calling process.

When the listener process of signals block the process determines whether the signal indicates a roam out of range or back in range condition decision block . A roam signal yes exit to decision block causes the process to close corresponding listener and call the operating system to release and renew DHCP lease to a network address block . If the listener signals out of range decision block the process signals this condition to registrants block . If the signal is a back in range decision block then this condition is signaled to all registrants block . Upon receiving a disabled roam command block the process closes all listeners block and disables the operating system interface change notification block .

A further interface based listener feature enables roaming across network points of attachment on the same network or across different network media. This interface based listener feature operates without requiring the beaconing techniques described above while permitting the system to fall back on beaconing if the underlying interface s is unable to support the appropriate signaling.

In this further non limiting implementation an interface based listener integrates information from network interface adapters e.g. via a low level interface roaming driver with information available from network stacks to determine whether a mobile node has moved to a new Network Point of Attachment. show an example listener algorithm that may be used to efficiently determine the migration path of the mobile node. This process is shown using a single network interface connected to a single network medium but can be used by itself or in conjunction with other roaming algorithms to traverse across many diverse network media and interfaces e.g. to create a self healing infrastructure using redundant paths .

Referring to at system initialization time or when the network adapter driver loads block low level interface roaming drivers register with the roaming control center module of block . Such registration which is made via the function crRegisterCardHandler in the example non limiting implementation provides entry points for 

The example non limiting function crRegisterCardHandler also provides a interface description string or token that can be used by the roaming control center module for preliminary match ups to the correct roaming driver. A default roaming driver may also be installed for interfaces that use an O S generic mechanism for signaling querying media connectivity as well as changes to network point of attachments.

In the exemplary illustrative non limiting implementation when an interface s state becomes enabled i.e. access to the network is now possible block the roaming control center tries to enable Interface Assisted Roaming IAR according to the following steps please note however that the steps may be interchanged or either might be omitted based on the design of the operating system O S and or the hosting device being used in a particular application 

1. If a generic handler is installed a call to the generic crOpenInstance handler is made. The generic handler queries the low level adapter driver to see if it can generically support signaling the status of media connectivity as well as any changes to the network point of attachment block . If the interface driver is unable to support this functionality generically no exit to block an error status is returned to the caller to indicate that it should use an alternative mechanism for acquiring signaling information.

2. If the generic handler returns an error no exit to block a search is made with the token of the activated interface through the currently registered roaming drivers block . If the interface matches one of the tokens that was registered during crRegisterCardHandler phase block the roaming control center calls the specific crOpenInstance for that instance of the adapter. This function attempts to open the low level driver poll once for status media connectivity and the network point of attachment ID and set the periodic polling timer if applicable . If the low level driver does not support the requests for some reason an error is returned indicating that the roaming control center should use an alternate mechanism for acquiring signaling information.

3. If either of the previous steps is unable to achieve the required functionality an error is returned to the roaming control center to signal that it should not use the IAR functionality and fall back to other roaming algorithms such as the beaconing listener shown in Mobile IP or in some cases the currently attached network itself deals with roaming no exit to block block . Otherwise Interface Assisted Roaming is enabled block and the roaming control center follows the algorithm outlined below.

Initially the interface assisted listener records current media connectivity status and network point of attachment identification information in a local data store block . Assuming the interface assisted subsystem is successful in providing roaming feedback the subsystem waits for a status event block . The event can comprise for example 

If the status of the interface signifies either a change in medium connectivity has occurred or a change in network point of attachment yes exit to block or of any clients of the roaming control center are notified of the state change using the following rules 

1. If the status signifies a change from being connected to the underlying network medium to being detached yes exit to block and there are no other paths to the peer the listener concludes that the mobile end system has lost its connection and the roaming control center signals its clients with a status of ROAM SIGNAL OUT OF CONTACT block .

2. If the status signifies that the interface has been reconnected to the medium and the network point of attachment has not changed no exit to block after no exit to block and a ROAM SIGNAL OUT OF CONTACT was previously signaled this indicates that the mobile end system had previously lost but has now reestablished contact with a particular network point of attachment. In this case the roaming control center will revalidate any network address it may have registered or acquired for proper access block and signals ROAM SIGNAL ROAM SAME SUBNET block to alert the roaming control center clients that a reattachment has occurred and that they should take whatever steps necessary to quickly reestablish transport level communications. For example during the disruption in service it is possible that some data may have been lost and the clients may need to act to recover such lost data.

3. If the status signifies that the interface is attached to the medium but the network point of attachment has changed yes exit to block the roaming control center will signal its clients that a roaming condition has occurred. To more efficiently support handoffs between network point of attachments the roaming control center in this example employs the use of a learning algorithm along with a local data store. The data store is normally populated dynamically i.e. learning but it can be seeded with static information i.e. already learned information to improve performance. The data store itself maintains a list of network points of attachment identifiers along with information such as network and media access address network mask etc. This network topology map assists the roaming control center in deciding the correct signal to generate to its clients.

Determination of the correct signal is done in the following manner in the example non limiting implementation 

a A search is made through the network topology map data store to determine if the interface has already visited this particular network point of attachment block . If a match is found yes exit to block a further check is made to see if the network point of attachment is on the same network segment as the one that the interface was previously associated with. If the network segment is the same the roaming control center generates a ROAM SIGNAL ROAM SAME SUBNET. This alerts the roaming control center clients that a handoff occurred and it should take whatever steps necessary to quickly reestablish transport level communications as during the handoff it is possible that some data may have been lost.

b If during the search a match is found but the new network point of attachment is not on the same network segment then the listener concludes that the mobile end system has roamed to a different subnetwork. In this case the roaming control center 

c If the search yields no match no exit to block a new record is created in the local data store populated with the network point of attachment s identifier media access address network mask and other ancillary information block . The roaming control center then executes blocks and to acquire and register a network address and to generate a roam signal.

Since the interface assisted roaming technique described above gives access to the underlying interface information it is possible to employ an additional set of policy parameters defined by the user and or the system that can enable automatic efficient selection of alternate valid network paths. If there is more than one network available at a time the subsystem can choose the path s with the least cost associated with it i.e. a wide area network connection versus a local area connection . This can be done by a number of metrics such as for example bandwidth cost per byte and or quality of service. Such least cost routing techniques can provide advantages in terms of network connection quality efficiency and reduction in frame loss. For example it is possible to provide a make before break handoff scheme based on other heuristics available media connectivity signal strength retransmission rate etc. thus allowing continuous packet flow with minimal loss to and from the roaming node. See policy management discussion below.

Through further experimentation evidence has shown that some network adapters may erroneously signal that they are re connected to the medium before they are totally registered on the network segment. In some instances during roaming events the storage area of where the network identifier is kept may not yet been updated and thus it is possible for the system to incorrectly believe that these adapters have roamed back onto the same subnet. Eventually when the device finishes registering the storage area is updated with the new network identifier causing yet another ROAM signal to be generated. This scenario would correctly work if both pieces of information were gated together and only signaled once when the interface was finished registering with the network. However when polling it is difficult to determine when the network ID is valid if the in contact with network signal is generated previously.

In essences the roaming node may in fact be in media connectivity state since it can communicate at the media access level with the network but in fact one cannot yet send any application data across the link since the registration process has not completed. Therefore it is desirable to compensate for this condition. One way to provide such compensation is to determine peer connectivity by sending link confirmation frames or what is more commonly known as an echo request response packets. These echo or ping frames are generated by one peer most likely the roaming node to determine if two way peer to peer connectivity is achievable. If the requesting peer receives a response frame to its request it can be concluded that a duplex path has been achieved. At this point the NPOA information can be regarded as valid until the next disconnect situation is realized. Other information such as the reception of any frame from the peer on the interface in question also allows the roaming node to assume the registration process has concluded and two way communications is achievable.

Another race condition between the network interface and the underlying protocol stack situation has arisen that can sometimes cause a problem. It is possible for a device to have roamed to a new network segment and been signaled correctly from the interface below but the transport stack itself has not made the necessary adjustments to its routing table s for application data to flow. To compensate for this condition an additional signal ROAM SIGNAL ROUTE CHANGE was added and is generated whenever the underlying transport s routing table changes. When this signal is indicated the roaming subsystem clients take whatever action is necessary to determine if connectivity to the peer systems is achievable. This may entail the roaming client to enumerate through the underlying transport s routing table to determine if the routing modification has affected the communications path to the peer. Other more intrusive algorithms such as the ones described above can also be used to confirm that a two way communication path exists between the peers.

A further aspect of an exemplary non limiting implementation provides an algorithm and arrangement for accessing the MMS Mobility Management Server in what we call disjoint networking mode. The new algorithm allows for dynamic static discovery of alternate network addresses that can be used to establish continue communications with an MMS even in a disjoint network topology in which one network may have no knowledge of network addresses for another network.

In general the algorithm allows for a list of alternate addresses that the MMS is available at to be forwarded to an MES Mobile End System during the course of a conversation. Thus the MMS uses a connection over one network to send the MES one or more MMS network addresses or other MMS identities corresponding to other networks. As one example this list can sent during circuit creation. It is also possible for the list to change midstream. In this case the list can be updated at any time during the connection.

If when the MES roams to another network it uses the list of MMS alias addresses identifications to contact the MMS from the new network point of attachment. This allows the MES to re establish contact with the MMS over the new network connection even though the primary and ancillary networks may not share any address or other information.

There are at least several uses for this new algorithm in addition to the ability to more efficiently obtain an alternative network address or other identifier for communicating with the MMS over a disjoint network. One example usage is secure network operation. For example using the algorithm shown in one can setup a secure network where the MMS is used as a secure firewall gateway from a multitude of networks some all may be wireless and a corporate backbone and allow for secure and seamless migration of the mobile node between all disassociated networks. Think for example of the MMS as a hub with one fat pipe connecting to the corporate network and many little spokes connecting many logically discrete networks. Since they are logically discrete traffic on one network segment cannot reach another except through the MMS which can act as a router in this example .

Normally for a node to roam from network segment to network segment there must be routing information paths provided on each network segment i.e. default route etc specifying how to get back to the main public or initial address used to contact the MMS . Once a connection is established that address is used for the life of the connection. When a frame is sent from the MES the IP network layer infrastructure on the client and intermediary nodes routers looks at the destination address of the frame and correctly forwards the packet on to its ultimate destination the MMS . This is done by using what is commonly referred to as IP forwarding or IP routing. With this functionality turned on frames broadcasts etc from one network segment can leak onto another. By not using IP forwarding frames sent on one segment are not forwarded onto the other thus breaking the communications pipe or creating a disjoint network.

The alternate address list shown in has the effect of pushing or distributing some of the routing intelligence out to the MES . Each segment therefore can be kept discrete and without knowledge of any other segment attached to the MMS . The MES can be authenticated by the MMS so that the MMS only sends a list L to authorized MES units . When the MES roams onto another networks segment it can automatically select the correct address to use to initiate continue communications with the MMS midstream thus solving the disjoint network problem and not require any changes to the routing infrastructure. This provides for a more secure computing environment by only letting validated users to gain access to the network.

For example by using the MMS in this manner combined with user level security encryption we can limit traffic from and to the corporate backbone to only the frames destined for those nodes on that segment using the roaming techniques described above. Frames can be optionally encrypted to thwart any potential eavesdropping by devices that may be validated by the spoke network infrastructure.

Now suppose that for some reason the MES now needs to migrate or roam to the 10.1.x.x Ia network. Since the 10.1.x.x Ia network has no knowledge of the 192.168.x.x Ib network i.e. no routes to it when the MES moves into its domain the communication pipe is broken even though the MMS is attached to it. Again the same thing happens when the mobile node attaches to any of the other 10.x networks depicted.

Now using the algorithm shown in the MMS at connection initiation time or by some other method shares its interfaces address on each of the various disjoint networks Ia Ib Ic Id with the MES and the MES records these. Once recorded if the MES roams into any one of the networks and detects that it has roamed onto a new network segment the MES can now select the appropriate network address to communicate with the MMS for that network segment. If more then one address can be used the MES can select the appropriate address to use based on a number of metrics such as speed cost availability hops etc. An MES that has not received a list as in may be effectively prevented from roaming between the various networks because it has no way to contact the MMS over any network other than its home network.

Another application for the technique is in distributed network interfaces. In today s networks folks have deployed what is known as Network Address Translators NATs . By use of this conventional technology one can have many network devices use only one public network address for access to information on the Internet. The technology provides this functionality by funneling all information and queries destined to the Internet through a single few device s . The device s records the request at the network layer then remaps the address and port information in the packet to the devices own address port tuple and sends it onto its destination. Upon reception of a frame from the Internet or other such network the device s does the reverse look and forwards it back to the correct source by replacing its address port tuple information with that of the initiating device. These mappings may be defined statically also at the NAT.

Suppose someone wants to use the MMS for the LAN WLAN internally and have it sit behind a NAT. Currently unless the MMS is the NAT or by using a different proxy for all communications with the MMS when someone roams outside of the bounds of the intranet the MMS is no longer accessible since the address to converse with it is no longer accessible. With the algorithm one can statically dynamically define another interface address that is not directly attached to the MMS. Therefore using the algorithm described above the MES can now automatically select the appropriate disjoint address to use when attaching to a network that is outside the intranet s domain.

A further non limiting exemplary illustrative implementation provides the unique ability to offer additional security cost savings and services based on a number of metrics. Since the MMS described above is intimately involved with each application session the MES establishes either side i.e. the MMS and or the MES can apply policy based rules to tailor and control the communications between the MES and its ultimate peer. It can further condition or modify applications request based on the locale or proximity of the device and its attachment to the network. For example the MMS and or the MES can include a rules engine that applies learned statically defined or other rules based on policy to each application session that is established or request that is attempted. The MMS can further distribute some none or part of such rules and or processing to the MES to provide further metering or security against rogue attacks of the mobile device. Unlike certain other policy management technology available in a distributed topology the MMS provides a central place to administer the rules and policy decisions and have them distributed to the remote device at any time during the course of a conversation connection.

The rules themselves can be configured based on user user group device device group process application identity and or network point of attachment. Once defined learned they can be combined to govern and control a variety of different events activities and or services including for example 

Furthermore by employing the distributed architecture the MMS can also apply or share the same decision set. Having the MMS perform the policy management processing and or decision making may be desirable in instances where the mobile device has limited processing power to execute the engine or bandwidth limitations are applicable or for security purposes.

The example table shows a number of example metrics on which policy management decisions may be based including 

The example table further includes a deny request entry that indicates the result of a policy management decision to be made based on the metrics. As one example the particular example entries in the table specify that all connections to destination ports and should be denied or throttled back if the available bandwidth is reduced to less than 100 000 bytes per second. Furthermore in the particular example shown rules rows and allow only network traffic to flow to and from the MMS all other network traffic that is not proxied is implicitly discarded .

In one example before each RPC request or frame is processed the rules engine is consulted to determine if the status of the operation. Base on the outcome of this process the request may be allowed denied or delayed. is an example flowchart of steps that may be performed by the MMS and or the MES to make policy management decisions.

Furthermore by combining the roaming technology outlined previously with other location or navigational information that mat be available the MMS detects when a mobile end system has moved from one point of attachment to another. By combining this information in conjunction with the ability of the mobile end system to detect a change in environment of network topology or locale enable the exemplary illustrative non limiting implementations herein to provide additional levels of location based monitoring and services.

To fully realize the potential of this information enhancements to both the Internet Mobility Protocol and RPC engine are outlined. Several new RPC protocol and configuration enhancements will be added to provide this functionality. These are listed below.

When the mobile end system has determined that it has moved to a new point of attachment using interface assisted roaming or some other method such as detecting changes from a global positioning system it will send a formatted Location Change RPC Request message to its peer in this case the mobility management server. The Location Change RPC formats one or more of the point of attachment identification information into a type length value format. The type identifies the kind of identification information types supported will include but will not be limited to 48 bit IEEE MAC Addresses IPV4 Addresses IPV6 Addresses longitude latitude altitude and attachment names in ASCII. The length indicates the length in bytes of the identification data and the data contains the actual point of attachment identification. The mobility management server upon receipt of the Location Change RPC Request will build a Location Change Alert that contains the point of attachment identification and other pertinent information such as the mobile end system identification the user name and PID. It then will forward the alert to the alert subsystem on the server. The alert will be formatted with the same type length data format utilized within the Location Change RPC Request . The alert subsystem will then forward the location change alert with this information to all applications that have registered for the alert. Applications that have registered for the alert may include monitoring applications such as the current active status monitor a long term activity log the policy management engine and other third party applications and network management tools. One such third party application may combine this location information with Web based maps to provide detailed information about a mobile end system s or MMS location. In addition to such applications other actions can be associated with location change alerts. This includes sending an email printing a message launching a program and or change in policy.

The Location Change RPC will contain a field in its header that indicates if it was triggered due to location change distance change or rate change.

In some instances the MES may not know it has roamed. Depending on the medium and the network adapter it is attached to the MMS may be the only entity that notices that the MES has migrated to a new point of attachment. Consider the case of a mobile router. The addresses behind the router stay the same only the routers address changes. In this case the MMS knows the new care of address of the MES. Therefore for complete motion detection it needs to be a combination of the both the MES and MMS to detect motion. In the exemplary illustrative non limiting implementation the MMS detects motion of the clients at the IMP layer when the source address changes and a new IMP message is received. When this occurs the MMS locally generates a Location Change Alert. It also sends a message back to the MES that its point of attachment has changed.

The Topology RPC Request is sent from the mobility management server to mobile end systems. Upon receipt of this RPC the mobile end system will read the topology information stored in its local data store and build a Topology RPC Response. The Topology RPC response will be formatted with a Total Length Field followed by consecutive type length data point of attachment identification followed by type length value data indicating the subnet and network information. This information may be used on the server to build a complete topological map of the mobile network being served by the server.

The user interface on the server will provide a method for mapping and displaying location information. This location information will be available for each active mobile end system and the long term activity log will maintain a history of all active and previously active mobile end system location changes. The user interface will permit the system administrator to configure the point of attachment information in human readable form. For example if the point of attachment information is provided in the form of a 48 bit IEEE MAC address this MAC address will be displayed along with the information provided through the user interface on the server. If the point of attachment represented an access point in front of the HallMark Cards store it might be configured to present the following information HallMark Street Address City State Zip . When displayed to the user information HallMark Street Address City State Zip is presented.

A configurable timer is provided on the mobile end system to limit the rate at which Location Change RPCs may be sent from the mobile end system to the mobility management server. If the timer interval is larger than the rate at which the point of attachment changes are occurring the mobile end system will wait until the timer interval expires before generating another Location Change RPC.

A distance metric will be provided for triggering the generation of Location Change RPCs. This setting configures the system to send an update when the user moves three dimensionally every n feet from kilometer or other appropriate unit of measure from the last point of origin. By default this setting is disabled. Enabling this setting causes a Change Notification when the distance interval in the configuration is exceeded.

A rate change metric will be provided for triggering the generation of Location Change RPCs. This parameter is configured in distance per second such as miles per hour. It will specify an upper and lower bounds and a time interval that the attained rate must be sustained i.e. 0 MPH for 10 minutes or 70 MPH for 1 minute . When this speed is reached a Location Change Notification will be generated.

In addition to its exemplary illustrative non limiting functionality outlined above the MES can also act as a Mobile Proxy Communications Service MPCS . Such additional non limiting and exemplary Mobile Proxy Communications Service functionality allows for application data communicated to from nodes attached to a locally coupled mobile private network MPN to communicate with their ultimate peer s that may or may not be attached to the MPN via the MPCS potentially through at least one IP based Point of Presences networks PPNs that is coupled to the MES MPCS. The exemplary MPCS provides services for the following example non limiting devices and or users 

Exemplary illustrative non limiting functionality and services available to at least one of the FMESs VMESs VMCs and or MPNs by the MPCS operating on an MES can include any or all of the following 

Additional components make up the core functionality of the exemplary non limiting example implementation of the MPCS. Each component can operate standalone to provide a subset of services however it is the combination of these services working in concert with each other that provide the enhanced capabilities of the exemplary illustrative non limiting implementation. Illustrative non limiting example additional components include 

By adding these components to the MES the technology herein is able to provide functionality for enabling secure persistent managed access to the devices users and networks coupled to the MPNs of the MPCS MES.

This component is designed and operates in accordance with at least IETF standard RFC3022 potentially RFC 2002 2003 and their successors. Additional functionality will also be added to make it cognizant of multiple PPNs. This module facilitates mapping of communications for FMESs VMPNs VMESs and or VMCs from the MPNs to the PPNs and visa versa based on at least one of but not limited to policy configuration Internet Protocol suite framing information version addresses ports protocol application name or symantecs etc.

Since the MPCS is acting as a proxy and or NAPT for at least one mobile private network this agent supplies firewall and intrusion detection logic for at least the FMES since they are not mobile aware devices. Furthermore this functionality can be extended to cover VMESs and VMCs that ultimately couple to the MPNs associated with the MPCS.

This component is designed and operates in accordance with at least IETF standard RFC2131 and its successors. It provides locally administered addresses for the at least one coupled MPNs and or VMPNs. It also supports Vendor specific extensions and or provides DHCP inform services to allow the propagation of information to the mobile devices coupled to the MPNs or VMPNs potentially used for dynamic discovery and or other enhanced services.

This component provides local proxy device user authentication. After address acquisition has occurred by the nodes coupled to MPNs or by the VMPNs this agent further provides means for device user network level authentication before any other services of the MPCS are consumed. A local authentication capability along with the ability to communicate with a verifying authentication authorization accounting AAA service may be used for new or unknown devices networks users the MPCS is not cognizant of. The backend or verifying AAA service may be at least one of the well known or standard authentication systems. Along with the other AAA functionality this agent can include remediation services to ensure that any visiting or fix devices are operating within specific administrative requirements. One such non limiting example of a requirement might be to ensure that any of the nodes that join the network are operating with a certain level of anti virus protection to ensure that it does not affect the operations of other devices on the MPNs associated with the MPCS. The remediation agent works in conjunction with the foregoing policy management functionality herein thus allowing this to be centrally administrable.

This component alerts joined MESs or VMESs to the fact that a change has occurred on one of the PPN interfaces attached to the MPCS. The capability allows for accelerated discovery and application of policies on the MES VMESs or VMPNs. The component may also supply a query capability to enable the discovery of the state associated with each of the PPNs coupled to the MPCS.

This component acts as a DNR DNS server as specified by IETF standards. However in one exemplary non limiting illustrative implementation it provides the enhanced capability and acts as a proxy as well as a rendezvous server. In this mode of operation selectively and based on configuration information this component responds by substituting an address associated with the MPCS in the name resolution response instead of the address of the ultimate peer being queried. At this point it records the source address of the requestor the name and potentially the address of the ultimate peer for use by the Application Level Proxy Agent.

This component provides proxy services for at least the FMES VMES VMCs and or VMPNs coupled to at least one of the MPN that are coupled to an MPCS. In essence it works in conjunction with the transport level redirector of the MES previously described the NAPT service and the DNR DNS Directory Services proxy Agent to extend such functionality as session persistence roaming and policy management to the mobile visiting nodes or networks subnetworks. Application sessions have an associated mapping that can be centrally configured by the at least one offering MMS that the MPCS is communicating with. In one mode of operation and in coordination with the DNR DNS Directory Services Proxy upon receiving an IP datagram destine to the address specified in the resolution response frame the Application Level Proxy Agent can also create a mapping and proxy the connection or the data to the ultimate peer through the associated MMS. In the event that the associated MMS is unreachable via the PPNs the MPCS local policies and configuration can also be cached and employed to allow for disconnected operations.

The policy management component takes into consideration new configuration policy implications for the operation of the MPCS. This includes but not limited to 

This component allows unattended operation of the MPCS. In one exemplary non limiting implementations it is envisioned that MESs capabilities combined with the MPCS functionality are to be deployed on embedded headless systems i.e. no display thus remote access for configuration monitoring and control is employed. The one non limiting exemplary implementation the interface is developed using standard HTTP base communications using SSL for security purposes.

To support the additional load of the MPCS and high volume MES deployments MMS clustering services enable for load balancing and sharing with automatic failover support. The clustering services provide 

Referring to in this exemplary illustrative non limiting implementation the MPCS system is coupled to at least one Point of Presence network or subnetwork PPNs and etc over which it can communicate via the coupled network with at least one MMS that is a member of an MMS cluster MMSP systems . It will be appreciated that the set of members to any given MMSP may contain one or more systems within a given zone. Furthermore multiple zones can be combined to create a clustering of MMSPs that allow selection based on preference and or availability. In one non limiting example there are two clusters of MMSP one in New York zone and one in Los Angeles zone . A device on the west coast of the US might prefer to communicate with the pool of MMS servers in zone due to proximity. However if the MMS systems in MMSP in zone are inaccessible for some reason at capacity or for some policy reason the MPCS and or MES can be redirected failed over to or selected based on preference to the MMSP in zone New York . End users of the systems may or may not be involved in the selection preference process.

Load balancing among MMSs within a given zone of a given pool is accomplished by controlled weighted random distribution based on availability configuration and load analysis. The load balancing functionality has no single point of failure and MES MPCS reestablishing communications to the MMSs in pool MMSP will randomly distribute redirection session requests among the available load balancers in the pool zone. Due to the periodic communications between MMS within the pool the algorithm detects inaccessible or resource blocked MMS peers quickly. Redirection of the MES MPCS session happens via secure communications.

Initially every MMS in the pools MMSP reads a list of peers from the central configuration authority on startup and keeps this list up to date by being a subscriber to the MMSP configuration change notification service. There are at least two types of servers in a given MMSP 

When at least one MMS in the list is configured as a status collector every MMS in the given pool in the given zone begins sending its Server Status Messages to all status collector systems in the pool on a fixed interval. If no servers are collecting status this messaging activity does not occur. If a MMS detects in the configuration process it is a load balancer it will immediately be ready to redirect clients and will open the load balancer port and start accepting status messages from other servers. The central configuration information allows the MMSs to perform load balancing on configuration data only but it will never redirect clients to MMSs that it has not heard from within the fixed interval e.g. have timed out . It will be further appreciated that each server in the pool can operate as a Status Collector a Receptor or both. In the case that the MMS operates as both it can redirect MMS MPCS sessions as well as accept them locally.

The MPCS may also be coupled to at least one mobile private network MPN network . It will be appreciated that there can be more than one MPN coupled to the MPCS MES system . For example it could be concurrently coupled to an 802.11 network an 802.15 or Bluetooth network WiMax capable devices or other wired or wireless infrastructure. Entire new networks of devices can be logically joined to provide a hierarchical nesting of networks VMPNs . Administration of these networks or subnetworks can be accomplished via the MPCS services or centrally from an MMSP. For the sake of brevity discussion will be limited to access via MPN . Coupled to MPN at least the following distinct types of nodes that may attach 

FMESs in the illustrative implementation are nodes that are coupled to MPN and might be considered permanently attached. These devices use the standard Internet Protocol suite to communicate with their peers. However due to a variety of reasons cost overhead etc these devices are not mobile aware . Some non limiting examples of these kind of devices might be a camera fingerprint reader printer telemetry or single purposed devices located inside a vehicle and might only be removed for repair replacement or when the vehicle itself is decommissioned. Since these devices are not mobile aware ordinarily if something happens that disrupts the communication path i.e. a roam disconnect etc between these devices and the ultimate peer the communications session can be severed data lost or experience any number of the problem related to mobility described previously. To resolve these issues these devices can be configured to communicate directly with MPCS which acts as a proxy for the communications session. Since MPCS is based on the facilities provided by the embedded MES these communications session gain the benefits of the technology herein and can now operate in a mobile environment with or without modification.

Alternatively by employing the services of the DNR DNS directory proxy it is possible to not have to re configure the FMES to be cognizant that it is communicating with MPCS . Via standard name resolution techniques it is possible to redirect the FMES communications to MPCS . Once the communication session is established to MPCS it proxies the actual communication session with the appropriate ultimate application peer system . Again it will be appreciated that there can be more then one application session to more than one application service and that the application services can be geographically disbursed or be control by more than one administrative domain.

Another type of system that can take advantage of services provided by MPCS is a visiting mobile end system VMES . These devices are of the type that have already been provisioned with MES functionality. These devices might be in communication with the same MMSP that MPCS is or one that is totally different. Through the use of MPCS s NAPT Gateway Join Agent and the Interface Signaling Agent these devices become authorized to use and become cognizant of the different PPNs and MPNs that are coupled to MPCS . It is quite possible that some of the communications session operating or being established from the VMES will also use the proxy services of MPCS base of policy or administrative requirements.

In one non limiting example illustrative implementation VMES can register with Interface Signaling Agent of MPCS to be alerted to state changes that are associated with PPNs and or . If conditions change on the PPNs e.g. available bandwidth QoS media connect status etc an alert can be sent to the listening registered VMES. The reception of this alert can then cause the facilities on the registered VMES to reevaluate conditions taking in to consideration any downstream changes. Policy or other parameters might be adjusted e.g. turning on compression etc based on the state of the alert. It will also be appreciated that instead of using a register approach these alerts might be multicast broadcast to all nodes on the MPNs. This would eliminate the need for each device having to instantiate communications with the Interface Signaling agent of MPCS .

Another type of system that can take advantage of services provided by MPCS is a visiting mobile client VMC . VMC is a device that may or not be mobility aware but is not part of the set that is consider an FMES attached MPNs . In one non limiting illustrative implementation VMC falls into the class of devices that may migrate from one point of attachment to another but may not require that communication session survive across network inaccessibility. A non limiting example of this might be a device that is normally used in a lab environment such as a piece of test equipment. Again these devices are considered not permanently attached to MPN but would like to use the services of MPCS to communicate with the appropriate ultimate application peer system and or . In this case the system would be potentially employing the application level proxy agent or just the NAPT service on MPCS to communicate over PPNs . In a further exemplary non limiting implementation the VMCs might be mobile aware by using alternate mobile technology such as mobile IP. When provisioned in this manner the VMC would still avail itself of a subset of service available on the MPCS such as the gateway join remediation agent the NAPT Foreign home agent and or the application proxy level services.

Yet another aspect of the exemplary illustrative non limiting technology herein although not depicted on for clarity sake an entire MPN or previously described as VMPNs that are made up of another MES MPCS may ultimately decide to attached to MPN as one of its PPNs and allow the devices attached to the VMPN to use the services of MPCS . One non limiting example might be in the case where the VMPN has determined that all of its current PPNs are inaccessible but it is knowledgeable that MPCS is within range and has access to network resources through PPNs and or . At this point it may request to join MPN and if allowed begin using the services of MPCS . Furthermore the VMPN may decide to continue to use the services of MPN even if its own PPNs become accessible again base of policy. In this case it is probable that MPCS may have a higher quality link to network cloud versus the PPNs coupled to the VMPN. In yet another example it is possible that the VMPN and MPSC might actually reverses roles if the PPNs coupled to the VMPN become accessible. In this case MPCS would become the VMPN to the other MPCS.

In any case it should also be appreciated that due to the capabilities of the MES MPSC services it is desirable in non limiting exemplary implementations to allow any of the above devices to publish access to services that could be consumed by other nodes on the networks or subnetworks if so configured and is allowed by administrative policy.

Given the variety of systems that can become coupled to MPN there is a need to manage and control access to the MPNs and PPNs. The Gateway Join Remediation Agent service of MPCS accomplishes this and allows for local and central administrative control over what devices might be coupled to MPN . This service provides the necessary components for authentication authorization and accounting. In one non limiting implementation it contains standardized authentication services such as 802.1x Radius etc and may act as a proxy or supplicant to a more authoritative authentication service. Deploying it in this fashion would limit the potential exposure to security breaches since MPCS does not require a local cache of credential material. However there may be a need in some circumstances to support local authentication to allow for disconnected modes of operation when access to PPNs and is unavailable. Once the authentication and authorization of the device is successfully determined additional checks can be invoked to ensure that the coupled device is operating within specific administrative guidelines. One non limiting example of such a guideline would be to require the device to be using at least a specific version of an anti virus program and associated definitions. If the device does not meet the specific requirements it could be redirected to a trusted area that contains the necessary updates to meet the requirements. Alternatively further access could be revoked or denied. This could be accomplished in coordination with the proxy agent the NAPT Home Foreign agent or any network control capabilities at the link layer.

Such arrangements as described above can save costs and complexity by providing compatibility and bridging between two IP network technologies. For example all mobile end systems do not need to support both IPv4 and IPv6 IP layers in order to communicate with both IPv4 and IPv6 networks allowing the mobile end system to save the memory and other overhead associated with maintaining both IP stacks. In other exemplary implementations mobile end systems may comprise less flexible or capable devices e.g. wireless cameras or other devices that can communicate only using one version of IP e.g. IPv4 . The technology herein allows such devices to nevertheless communicate more flexibility over other IP networks e.g. IPv6 . The technology herein also provides bridging gateway technology that can be used to maintain overall compatibility at both ends of a communications path e.g. Mobile End System s and or Mobility Management Server s and or Fixed End System s irrespective of whether IPv4 or IPv6 is being used.

The description above of IPv4 and IPv6 Internet Protocols are simply examples any type of Internet Protocol or other communications protocols conventions and or standards could be used including as one non limiting example IPv x where x constitutes any future version of the Internet or futurenet Protocol.

Many businesses have employees who occasionally telecommute or work from home. Such employees often use laptop computers to get their work done. While at work the employees typically connect their laptop computers to a local area network such as an Ethernet through use of a docking port or other connector. The LAN connection provides access to network services e.g. printers network drives and network applications e.g. database access email services .

Now suppose an employee working on a project needs to go home for the evening and wants to resume working from home. The employee can suspend the operating system and applications running on the laptop computer pack up the laptop computer and bring the laptop computer home.

Once home the employee can resume the operating system and applications running on the laptop computer and reconnect to the office LAN via a dialup connection and or over the Internet. The Mobility Management Server which continued to proxy the laptop computer vis vis the network and its applications during the time the laptop computer was temporarily suspended can re authenticate the laptop computer and resume communicating with the laptop computer.

From the perspective of the employee now working from home all of the network drive mappings print services email sessions database queries and other network services and applications are exactly where the employee left them at the office. Furthermore because the Mobility Management Service continued to proxy the laptop computer s sessions none of those network applications terminated the laptop computer s sessions during the time the employee was traveling from the office to home. The technology herein thus provides efficient persistence of session across the same or multiple network mediums that is very powerful and useful in this and other contexts.

Imagine a large warehouse or retail chain. Within this campus inventory workers use vehicle mounted i.e. trucks and forklifts personal laptop computers and handheld data collection units and terminals to perform inventory management of goods. Warehouse and retail workers are often inexperienced computer users that do not understand network sub nets and require management supervision. The technology herein allows the creation of a turnkey system that hides the complexity of the mobile network from the warehouse users. The users can move in and out of range of access points suspend and resume their Mobile End Systems and change locations without concern for host sessions network addresses or transport connections. In addition the management software on the Mobility Management Server provides management personnel with metrics such as number of transactions which may be used to gauge worker productivity. Management can also use the network sub net and access points to determine worker s last known physical location.

Imagine a large hospital using radio LAN technology for network communications between several buildings. Each building is on a unique sub net. The technology herein enables nurses and doctors to move from room to room with handheld personal computers or terminals reading and writing patient information in hospital databases. Access to the most recent articles on medication and medical procedures is readily available through the local database and the World Wide Web. While in the hospital pagers one and two way are no longer required since the technology herein allows continuous connection to the Mobile End System . Messages can be sent directly to medical personnel via the Mobile End System . As in the case with warehouse workers medical personnel are not required to understand the mobile network they are using. In addition the Mobile End System allows medical personnel to disable radio transmission in area where radio emissions are deemed undesirable e.g. where they might interfere with other medical equipment and easily resume and reconnect where they left off.

Freight companies can use the technology herein to track inventory. While docked at a warehouse the Mobile End System may use LAN technology to update warehouse inventories. While away from local services the Mobile End System can use Wide Area WAN services such as CDPD and ARDIS to maintain real time status and location of inventory. The Mobile End System automatically switches between network infrastructures hiding the complexity of network topology from vehicle personnel.

Corporate employees may use the system in accordance with the technology herein for access to E mail web content and messaging services while within an enterprise campus that has invested in an infrastructure such as 802.11. The cost of ownership is reduced since pager service and other mobile device services are no longer required. The purchase of mobile infrastructure is a one time capital expense as opposed to the costly pay per use model offered by many existing mobile device services.

If an organization has a LAN that needs to be connected to the Internet the administrator of the LAN has two choices get enough globally assigned addresses for all computers on the LAN or get just a few globally assigned addresses and use the Mobility Management Server as an address multiplier. Getting a large number of IP addresses tends to be either expensive or impossible. A small company using an Internet Service Provider ISP for access to the Internet can only use the IP addresses the ISP assigns and the number of IP addresses limits the number of computers that can be on the Internet at the same time. An ISP also charges per connection so the more computers that need to be on the Internet the more expensive this solution becomes.

Using the Mobility Management Server as an address multiplier could solve many of these problems. The enterprise could put the Mobility Management Server on hardware that is connected to the Internet via an ISP. Mobile End Systems could then easily connect. Because all connection to the Internet would go through the Mobility Management Server only one address from the ISP is required. Thus using the technology herein as an address multiplier allows the enterprise to get just a few in many cases one addresses and accounts from the ISP and allows the entire LAN to have simultaneous connections to the Internet assuming enough bandwidth is provided .

Using the services of the MES MPCS solves an important problem for environments such as enterprises or public safety first responder organizations where there is a need to setup a temporary command post. When deployed in this fashion a suitable vehicle such as a Recreation Vehicle RV or ambulance police squad car fire safety vehicle equipped with the technology described herein can allow communications with locally administered device associated with the mobile command post to become a consumers of backend services located at home office via the PPN networks associated with MPCS . In reverse services that are located at the temporary command post can be accessed from nodes attached back at the home office. One example might be a camera to allow for remote expert technical or medical help from personnel back at the organizations headquarters. Status information might also be able to be garnered remotely to detect the positioning of the mobile assets working at the temporary command post. Consider being able to remotely track where fire personnel are at the scene from the fire station headquarters based coordinates being receive at the temporary command post. Another example might be an individual such as an insurance adjustor who works out of his vehicle and has a multitude of devices printers cameras etc that need to be in communications with the home office. Other such examples include point of sales situations such as concert venues flea markets etc where access to fixed infrastructure is limited or non existent.

While the technology herein has been described in connection with what is presently considered to be the most practical and preferred embodiment it is to be understood that the invention is not to be limited to the disclosed embodiment but on the contrary is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims.

