---

title: Implementation for collecting unmanaged memory
abstract: A method and system for garbage collecting managed and unmanaged memory that is no longer referenced. The time between allocations is compared with a threshold to determine if the garbage collector needs to collect unused memory. Unmanaged memory referenced by objects in the unused managed memory may be freed during the collection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07707232&OS=07707232&RS=07707232
owner: Microsoft Corporation
number: 07707232
owner_city: Redmond
owner_country: US
publication_date: 20050513
---
Many modern programs execute in an environment in which memory is managed by a memory manager known as a garbage collector. In response to a request for memory the garbage collector finds a sufficient amount of free memory and allocates it to the program. The program may then use the memory until it no longer needs the memory. The program may not explicitly inform the garbage collector that it is done using the memory. Instead periodically the garbage collector performs a garbage collection.

The garbage collector is responsible for determining which memory blocks are no longer being used by the program. The garbage collector may do this by traversing the objects associated with a program and marking the memory blocks they are using. If an allocated memory location is no longer referenced by an object of the program the garbage collector may indicate that the allocated memory location may be returned to the free pool of memory locations.

The garbage collector may collect on a periodic schedule. If an object remains referenced at the end of a period the garbage collector may determine that the object is longer lived and place it with a collection of objects that are checked less frequently to determine if they are still referenced by the program. If an object in this collection is still referenced when the garbage collector checks the collection the object may be moved to yet another collection of objects which is checked even less frequently. This is known as generational garbage collection and each of these collections are known as generations. The difference in time between checking objects in one generation as compared to another generation may be 100 1 or more. Garbage collectors use various heuristics to decide when to collect various generations.

Unfortunately objects that are in any generation may cease to be referenced immediately or shortly after being placed in the generation and continue to tie up memory until garbage collection for their generation occurs. If an object in an infrequently collected generation has a larger size than the garbage collector is aware of the garbage collector s heuristics may not work well and this can cause a great deal of memory to be consumed. Examples include but are not limited to when a small managed object references a very large amount of unmanaged memory.

What is needed is an improved method and system for tracking and garbage collecting memory of a size larger than the garbage collector is aware of.

Briefly in one aspect the present invention provides a method and system for properly garbage collecting memory that is no longer referenced. In managed code environments it is possible for managed objects to allocate unmanaged memory. A garbage collector may be unaware of the unmanaged memory and may thus choose not to collect or defer collection of the managed objects essentially leaking memory. An aspect of the present invention tracks unmanaged memory allocations by managed objects and forces a garbage collection when the time between subsequent allocations is greater than a threshold. Unmanaged memory referenced by managed memory may be freed during the collection.

Other aspects will become apparent from the following detailed description when taken in conjunction with the drawings in which 

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microcontroller based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner a touch sensitive screen of a handheld PC or other writing tablet or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

When writing a program in unmanaged code a developer may explicitly allocate and free memory for each object used by the program. If the program fails to allocate memory for an object and then attempts to use the object e.g. via a pointer errors may occur. If the program fails to free memory after the object is no longer needed the memory may become inaccessible for future allocations as a memory allocator may believe that the memory is still in use. Not freeing memory after it is no longer needed is sometimes called a memory leak and may lead to performance degradation or a system crash.

In managed code a developer may not be required to explicitly release managed memory. For example the program may create an object use the object as long as desired and then cease referencing the object. A memory manager known as a garbage collector may allocate memory for the object. Some time after the program stops referencing the object the garbage collector may determine whether the object is referenced and if not may free memory associated with the object.

In a managed code a program may reference an object until the object goes out of scope e.g. a method is exited or until the program causes all variables associated with the object to be associated with nothing or null .

In operation the program may request that an object be created via an API or declaration. The garbage collector may then locate available memory find a suitable block of memory and return a reference by which the program may access the memory.

A garbage collector e.g. garbage collector may periodically locate memory that is no longer referenced so that the memory can be returned to a free pool of memory managed e.g. managed memory by the garbage collector .

Memory blocks associated with objects may be associated with 3 or more sets sometimes called generations . The first generation sometimes called gen 0 may be associated with memory blocks that have most recently been allocated e.g. since the garbage collector last performed a collection . When collecting free memory blocks associated with gen 0 the garbage collector may associate any memory blocks not returned to the free pool with the second generation sometimes called gen 1 .

The garbage collector may attempt to collect free memory blocks from the memory blocks associated with gen 1 on a less frequent basis than collecting free memory from the memory blocks associated with gen 0. This may be done to avoid processing overhead as performing a garbage collection frequently may consume substantial processing resources. Furthermore if a program continues to reference a memory block for more than one generation it may be more likely that the memory block may be used for a longer lived object. Attempting to collect a memory block associated with a longer lived object too frequently may waste valuable resources.

If the garbage collector chooses to collect free memory blocks from the gen 1 memory blocks and finds memory blocks still referenced by objects the garbage collector may associate these memory blocks with yet another generation sometimes called gen 2 . The garbage collector may attempt to collect free memory blocks from the memory blocks associated with gen 2 even less frequently than the memory blocks associated with gen 1. In some implementations a garbage collector may collect free memory associated with gen 0 ten times more frequently than the garbage collector collects free memory associated with gen 1. Furthermore the garbage collector may collect free memory associated with gen 1 ten times more frequently than the garbage collector collects free memory associated with gen 2.

Sometimes the amount of memory associated with a generation influences how often the garbage collector chooses to collect free memory associated with the generation. For example if the memory blocks that are associated with gen 2 consume a large portion of available memory e.g. many megabytes the garbage collector may more frequently attempt to collect free memory associated with the gen 2 generation because of the possibility of reclaiming a large chunk of memory. If the memory blocks associated with gen 2 consume a relatively small portion of memory on the other hand the garbage collector may not attempt to collect any free memory blocks associated with gen 2 because of the relatively small amount of memory that may be obtained for the work performed.

More or fewer generations and other frequencies for collecting free memory blocks associated with each generation may be employed without departing from the spirit or scope of the present invention.

A problem arises when a small object e.g. image object stored in the managed memory allocates a large amount of memory e.g. image data from the unmanaged memory . The garbage collector is typically unaware that the managed object has allocated unmanaged memory. If this object lives long enough to be associated with the gen 2 generation the object may not be returned to the free pool of memory until the program closes. If there is more than one of these small objects which allocate a large amount of unmanaged memory the effects on free memory are magnified. In some modern programs this may result in programs with hundreds of megabytes of memory allocated to them even though they are only using a small portion of that memory. This is particularly true for program that access images.

The program may request that the image object be created by calling an API and passing the name of a file that includes the image. For example a developer may place the following line of code in an application 

The API may then create the image object in the managed memory and may also decode the file allocate a memory block from the unmanaged memory place the image data into the unmanaged memory and register a finalizer for the image object with the garbage collector. MyImage references the image object .

If the memory associated with the image object is still referenced by the program the memory is not freed. If the memory associated with the image object is not referenced by the program the garbage collector may call a finalizer of the image object. The finalizer may then free the memory associated with the image data in the unmanaged memory and return to the garbage collector . The garbage collector may then return the memory associated with the image object to a free pool for subsequent use.

At time T the program begins. At time T the program begins rapidly requesting memory. This may occur for example when loading a new Web page or requesting that the program displaying a page showing several images e.g. viewing a photo album .

Shortly after T allocations occur relatively quickly as a program attempts to allocate memory for all objects needed to display a particular page. In faster computers the time between allocations may be on the order of a few milliseconds. On slower computers the time between allocations may be on the order of a few hundred milliseconds. On almost all machines during typical allocations for images e.g. a few megabytes each the allocations will be closer than 1 second apart.

At time T the program suddenly stops using the memory it previously requested. For example the user may navigate to a different window in the application. When navigating to the different window the previously displayed images may no longer need to be displayed or retained in memory.

At time T the program begins rapidly requesting memory again. The program may do so in response to the images associated with the window to which the user navigated for example.

Because the graph assumes that memory is returned to the free pool immediately after the program no longer needs it the graph may not represent the actual memory usage. For example referring to a garbage collector may not collect unused memory right after the drop at T. Furthermore because the garbage collector may examine managed memory the garbage collector may not even attempt to collect the unused memory as the managed memory used by the objects may be very small and not considered worth checking even though the unmanaged memory associated with the objects may be very large.

To cause the garbage collector to collect the unused managed memory and hence call finalizers that release the unused unmanaged memory the allocation monitor may track allocations and the time between allocations. The allocation monitor may be part of a set of components that provide enhanced graphics functionality. For example instead of including code to animate an image a program may simply call an API that accesses the set of components to animate the image.

When an allocation is less than or equal to an allocation threshold e.g. 1 second the allocation monitor may determine that memory is being rapidly allocated to be used for a while by the program. When an allocation occurs after the most recent allocation at a time greater than the allocation threshold the allocation monitor may determine that the program has stopped referencing the memory it previously used e.g. in response to the user navigating to a new page and is allocating memory for another use e.g. to display a new page .

At this point the allocation monitor may cause the garbage collector to collect any unused memory. The allocation monitor may request that the garbage collector perform a gen 1 or gen 2 or higher generation if it exists garbage collection. If the memory is no longer in use this may result in substantial unmanaged memory being returned to the free pool.

The allocation monitor may also track how long it has been since the last gen 1 or gen 2 or higher if it exists garbage collection. If the time is longer than a collection threshold e.g. 30 seconds or more the allocation monitor may cause the garbage collect to collect unused memory. Some programs may continue to allocate frequently over an extended period of time even though they stopped referencing portions of the memory over the time. If a higher level collection e.g. gen 2 has not occurred for a substantial amount of time a gen 2 collection may need to be performed in order to reclaim the unreferenced memory. Even if the program is still using all its allocated memory a gen 2 garbage collection every collection threshold period may not noticeably degrade performance.

The allocation threshold and garbage collection thresholds may be fixed by a developer during development may be computed based on a computer s characteristics e.g. memory size speed and so forth may be tuned based on success in freeing unused memory on a particular computer or may be selected e.g. by a user computer developer or system administrator .

At block an allocation monitor is called and passed the size of unmanaged memory associated with an object. The allocation manager adds the size to a variable e.g. TotalMemory that indicates the total amount of memory tracked by the allocation manager.

At block a determination is made as to whether the TotalMemory is greater than a threshold e.g. 500 KB or 1 MB . If so the actions continue at block . If not the actions continue at block . The threshold may be selectable e.g. at or before run time or fixed e.g. at development time . When the total memory tracked by the allocation monitor is less than or equal to the threshold no further actions need to be performed. This may be done for example to reduce overhead particularly when memory usage is low.

At block variables may be set to the current time the last allocation time and the last collection time. In other embodiments these values are obtained during comparison blocks and may not be assigned to additional variables.

At block the allocation time of the current allocation is stored. This is done so that this value may be used in subsequent iterations of the actions described in conjunction with .

At block a determination is made as to whether the current time the last allocation time is greater than an allocation threshold. If so the actions continue at block otherwise the actions continue at block . As mentioned previously when the time from the last allocation threshold is small this may indicate that the program is in an allocation phase. When the time from the last allocation is relatively large this may indicate that the program is in a new allocation phase that follows an old allocation phase.

At block a determination is made as to whether the current time the last collection time is greater than a collection threshold. If so the actions continue at block otherwise the actions continue at block . As mentioned previously this may be done to collect unused memory in programs that quickly allocate memory and stop referencing at least some of the memory for an extended period of time.

At block a garbage collector performs a garbage collection. The garbage collector may be instructed to collect garbage from any one or more generations.

At block the last collection time is stored for use in subsequent iterations of the actions associated with block .

At blocks and the actions end. The actions described in conjunction with may be repeated each time new memory is allocated. In some embodiments the actions described in conjunction with are performed when managed memory that references unmanaged memory is allocated. In some embodiments the actions described in conjunction with are performed when memory is allocated both in managed and unmanaged memory for an image object.

Turning to the actions start at block . At block the allocation monitor is called and passed a size parameter that indicates the amount of unmanaged memory that has been or is about to be freed. A finalizer that is called by a garbage collector before memory associated with an object in managed memory is returned to a free pool may call the method and pass the size prior to returning to the garbage collector.

At block the size is subtracted from the total memory tracked by the allocation monitor. If this causes the total memory tracked to be less than or equal to the memory threshold discussed in conjunction with the allocation monitor may cease causing garbage collection to occur until the total memory tracked is greater than the memory threshold.

Although some reference has been made to applying aspects of the present invention to memory associated with images it will be recognized that aspects of the present invention may also be applied in other situations in which a pattern for obtaining and then not referencing memory is discovered.

As can be seen from the foregoing detailed description there is provided a method and system for garbage collecting memory that is no longer referenced. While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

