---

title: Bluetooth TDI and winsock interface
abstract: A method, apparatus, and computer program product provide applications and application developers with generic access from user mode to the L2CAP layer of Bluetooth by exposing the L2CAP layer to user mode via a socket interface. In particular, a kernel mode primary component and user mode helper component cooperate to expose a Winsock interface to user mode components, and to manage various Bluetooth-specific functions and operations, allowing a user mode user application to access Bluetooth functionality without providing Bluetooth-specific commands or actions, and without being required to use RFCOMM.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07690005&OS=07690005&RS=07690005
owner: Microsoft Corporation
number: 07690005
owner_city: Redmond
owner_country: US
publication_date: 20051017
---
This is a continuation of U.S. application Ser. No. 09 707 120 filed Nov. 6 2000 which is herby incorporated herein by reference.

This invention relates generally to Bluetooth wireless interface technology and more particularly relates to the interface between user mode components and kernel mode components operating in accordance with the Bluetooth specification.

Generally computers and other electronic devices are interconnected via physical cables or wires. These communication paths allow for the exchange of data or control information between such devices. However it is increasingly recognized that certain advantages arise from the elimination of cables and wires to interconnect devices. Such advantages include ease of configuration and reconfiguration due to the elimination of the need to physically add remove or displace a physical medium. Furthermore space that would ordinarily be used for device interconnection media may be given to other uses. Significantly device mobility is increased through the use of wireless connections.

One method for providing wireless connections between devices employs a light wave in the infrared region of the electromagnetic spectrum to link devices. The IrDA Infrared Data Association protocol defines one such connection mechanism. Unfortunately such a mechanism must usually operate in a line of sight manner any opaque obstruction between transmitter and receiver will prevent proper operation. Additionally IR transmitters are typically not omnidirectional when incorporated into a communicating device so that for proper operation the transmitter must be aimed generally in the direction of the receiver within some nominal deviation such as thirty degrees. Finally IR transmitters are typically fairly low power devices and accordingly the range of IR links is usually limited to approximately one meter.

Radio frequency linking solves many of the problems inherent in infrared linking. One protocol that defines communication between wireless devices through a radio frequency link is the Bluetooth specification. Bluetooth devices do not require a line of sight with one another to operate and their range can be significantly greater than that of IR links. However there are several obstacles to widespread implementation of the Bluetooth specification. Bluetooth compliant devices are generally presented to user mode applications as serial interfaces via RFCOMM. In addition to the fact that the number of such interfaces is limited to 30 emulated RS 232 ports the L2CAP layer is capable of supporting a much greater number of connections there may be situations it which the serial presentation itself is not desirable or even acceptable. For example an application developer may wish to develop an application that uses a customized or proprietary protocol to communicate with another device.

Application developers therefore need a mechanism that provides them with generic access to the transport layer of Bluetooth i.e. the layer implementing L2CAP without being required to interface with RFCOMM and without being required to construct custom kernel mode components for each application to provide such access.

Accordingly the present invention provides a method apparatus and computer program product that furnish applications and application developers with generic access from user mode to the L2CAP layer of Bluetooth by exposing the layer to user mode via a socket interface.

A kernel mode primary component and user mode helper component cooperate to expose a Winsock interface to user mode components. These elements manage various Bluetooth specific functions and operations allowing a user mode user application to access Bluetooth functionality without providing Bluetooth specific commands or actions. This in turn simplifies application development and deployment. For example an application developer may distribute an application configured to exploit Winsock communications facilities and with only minimal changes the application could access radio frequency communications links via an embodiment of the invention.

In a particular aspect of the invention the kernel mode primary component operates to translate TDI data protocol communications from higher layers into BRB or similar data protocol communications and further acts to facilitate connection by independently initiating and accepting connection setup communications once requested to create a connection. The user mode helper component may maintain a name to SDP mapping facility for use by Winsock and may provides additional services relating to aspects of Bluetooth connectivity and communication.

Additional features and advantages of the invention will be made apparent from the following detailed description of illustrative embodiments that proceeds with reference to the accompanying figures.

Turning to the drawings wherein like reference numerals refer to like elements the invention is illustrated as being implemented in a suitable computing environment. Although not required the invention will be described in the general context of computer executable instructions such as program modules being executed by a personal computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations including computing devices such as hand held or laptop devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers server computers set top boxes network PCs distributed computing environments that include any of the above systems or devices and the like. In distributed computing environments tasks are performed by remote processing devices that are linked through a communications network. Further in a distributed computing environment program modules may be located in both local and remote memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Associate VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface . When used in conjunction with an RF connection the personal computer includes an RF interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be another personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the personal computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the personal computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the personal computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between computers may be used.

In the description that follows the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computer unless indicated otherwise. As such it will be understood that such acts and operations which are at times referred to as being computer executed include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However while the invention is being described in the foregoing context it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operation described hereinafter may also be implemented in hardware.

The operation of the Bluetooth radio frequency communications system is described in detail in the Specification of the Bluetooth System Version 1.0B Dec. 1 1999 incorporated herein by reference in its entirety. The Logical Link Control and Adaptation Layer Protocol L2CAP of Bluetooth is layered over a baseband protocol and provides connection oriented and connectionless data services segmentation and reassembly operation group abstractions and quality of service operations. For example compared to other connection media the data packets defined by the Bluetooth Baseband Protocol are quite limited in size. Thus large L2CAP packets must be segmented into smaller Baseband packets prior to transmission.

According to the Bluetooth specification the L2CAP layer interfaces with other communications protocols such as the Bluetooth SDP RFCOMM and Telephony Control. The RFCOMM protocol provides emulation of serial ports over the L2CAP protocol based on the TS 07.10 standard supporting up to 30 emulated RS 232 COM port connections from each of two peer Bluetooth devices. Typically user level applications use RFCOMM to access L2CAP functionality.

According to an embodiment of the invention a kernel level protocol module and user level helper module cooperate to expose an interface to access the L2CAP layer from user mode without requiring the services of RFCOMM. In this embodiment such functionality in exposed to user mode via a Winsock interface.

Winsock Microsoft brand WINDOWS Sockets is a programming interface API that traditionally allows a WINDOWS application to access the TCP IP protocol.

Winsock routines are ordinarily implemented as a dynamic link library dll . The Winsock hierarchy generally consists of a Winsock compliant application interfaced to a Winsock compliant TCP IP stack via the Winsock API. The stack in turn interfaces to the appropriate network driver. The manner in which Winsock is incorporated in this embodiment of the invention is illustrated in . This figure illustrates various interrelated system components in the user level and kernel level of a system according to an embodiment of the invention. In overview the Winsock DLL WS232.DLL accesses the L2CAP layer BTHPORT.SYS via a translation layer BTHTDI.SYS . A Winsock helper WSHBTH.DLL provides addressing and other Bluetooth specific functionality for use by the Winsock DLL . The service provider AFD.SYS is the standard Winsock2 service provider for transports such as TCPIP and IrDA and interfaces to user mode via MSAFD.DLL . In addition to implementing the L2CAP protocol BTHPORT.SYS also may implement the Host Controller Interface HCI Service Discovery Protocol SDP and Link Manager Protocol LMP as these are defined in the Bluetooth specification.

Thus in overview the data flow during a session initiates or terminates at the application having traversed all of the Winsock DLL the AFD user and kernel mode components and the Transport driver BTHTDI.SYS and the L2CAP layer BTHPORT.SYS . Prior to connection BTHTDI.SYS preferably performs an SDP query the results of which may be used to establish a name to SDP mapping in the Winsock helper . The name is preferably a 128 bit UUID associated with a specific service as specified in the Bluetooth specification rather than a text name. Thus for example the application may request a connection by specifying the address of the peer device and the UUID of the desired service at which time BTHTDI performs an SDP query to map the name to the appropriate PSM value. The PSM value used to establish the connection may be inconsistent from server to server however the UUID is preferably consistent.

Alternatively the application may be designed to perform its own SDP query for example to discover additional details about the server to which it is attempting to connect. In this case WSHBTH rather than BTHTDI preferably performs the SDP query for the application.

During connection setup as will be discussed in greater detail hereinafter a connection request from the application traverses the Winsock DLL and the AFD user and kernel mode components and to arrive at the Transport driver BTHTDI.SYS . At this point BTHTDI.SYS preferably initiates and terminates a series of communications with the peer device to automatically establish a valid Bluetooth connection.

The establishment of a Bluetooth connection to a remote device associated with a remote service illustrates the operation of both the translation layer BTHTDI and the Winsock helper module . When Winsock is commanded by the application to establish a remote connection it issues a request to that effect. When BTHTDI receives this request via TDI from the higher layers it translates the request into an appropriate format such as BRB Request and passes it to the L2CAP layer BTHPORT for transmission. Upon receiving an L2CA ConnectCfm Direct Callback communication from the peer remote device via BTHPORT BTHTDI issues a BRB L2CAP CONFIG REQ IRP for purposes of setting packet size and other communications details. If the configuration information is acceptable to the peer a L2CA ConfigCfm Direct Callback communication will be sent by the peer and received by BTHTDI via BTHPORT . Before during or after this exchange the peer device will send and receive similar communications to establish proper configuration of its connection.

During this process WSHBTH preferably aids in establishing the connection by providing Winsock with necessary connection information such as the Bluetooth address of the device a service class ID and a port value. WSHBTH preferably also provides socket address to Bluetooth string address translation. In addition as indicated above WSHBTH preferably also maintains a name to SDP mapping simplifying or eliminating SDP queries. Each item of information available from WSHBTH may be provided by WSHBTH to Winsock pursuant to a request from Winsock expressly or impliedly seeking such information.

Once the connection is established Winsock uses BTHTDI to facilitate Bluetooth communications. For example Winsock may send a data write request to BTHTDI . In turn BTHTDI translates the request to the appropriate format for example BRB L2CAP ACL TRANSFER IRP with flag set to false and forwards it to BTHPORT . Likewise when Winsock sends a data read request BTHTDI translates the request to the appropriate format for example BRB L2CAP ACL TRANSFER IRP with flag set to true and forwards it to BTHPORT . Note that both BTHTDI and BTHPORT may use the well known IRP IO Request Packet kernel mode interface for exchanging information.

As will now be apparent to access the Bluetooth functionality provided by this embodiment of the invention the user application should be either Winsock compliant as provided or interfaced to Winsock via an appropriate translation layer as those skilled in the art will understand. Such translation layers are easily constructed and require few lines of computer code. This embodiment thus allows developers who are familiar with Winsock but not L2CAP to nonetheless easily provide Bluetooth enabled applications without being subject to the limitations imposed by RFCOMM. The Bluetooth specific details of the connection and communications are automatically addressed by BTHTDI and WSHBTH.

Having discussed the structure and function of an embodiment of the invention the detailed operation of the various system components will now be discussed in greater detail. As illustrated in BTHPORT.SYS acts as the bus enumerator for the local Bluetooth radio ejecting a Physical Device Object PDO for every local Bluetooth device . The BTHTDI driver creates a functional device object FDO and associates it with the received PDO. In addition to the collection of local device mapped FDO s created in this manner it will also create a central FDO with a known device name such as Device BthTdi. BTHTDI preferably uses this central FDO to hide the existence of multiple radios from the drivers that interface to BTHTDI .

Thus for example the Winsock helper WSHBTH not shown can query Device BthTdi. In turn BTHTDI preferably initiates multiple queries using each device s FDO and builds a combined response to be sent back to the Winsock helper. Any connection requests that must specify a preferred local Bluetooth device preferably specify the BdAddr of the device. BTHTDI subsequently sends the connection request to the FDO associated with the specified device.

With regard to the Service Discovery Protocol SDP the details and requirements of this protocol are described in the Bluetooth specification incorporated by reference above. In summary the Bluetooth SDP provides a mechanism for applications associated with Bluetooth devices to advertise services to applications associated with other remote devices. There is generally one SDP server for each Bluetooth device the SDP server maintains Service Records accessible by other devices and the applications associated therewith. Each Service Record contains all of the information of a service within a server and consists of a list of Service Attributes such as ServiceClassIDList identifying the type of service represented by a service record ServiceID uniquely identifying a specific instance of a service ProtocolDescriptorList specifying the protocol stack or stacks that may utilize a service and ServiceName a text string containing a human readable name corresponding to the service . A Service Attribute is specified by the tuple consisting of a 16 bit integer Attribute ID Attribute Value identifying the particular attribute and an associated Attribute Value. With respect to SDP querying the Winsock SDP interface WSHBTH.DLL optionally queries by calling directly to the base group s SDP driver rather than by using BTHTDI. Such functionality may be exposed via an appropriate Name Service Provider NSP API. Alternatively WSHBTH.DLL may not provide an NSP function at all or such a function may be provided via separate .DLL files.

With regard to BTHTDI this component is layered over an L2CAP channel providing reliable transport. Each session may be identified by the Bluetooth device address BT ADDR and the Protocols Service Multiplexer PSM number of the two endpoints. Furthermore regardless of which device initiates a session both devices preferably can support both client and server applications.

To enable this aspect of operation BTHTDI preferably supports Server Channels. Each application should register a Server PSM number with the PSM value selected according to the guidelines set forth in the Bluetooth specification with the exception that BTHTDI may allow the use of any valid PSM number regardless of reserved ranges. This allows developers to provide custom implementations of services that may be already otherwise available in the protocol stack. For example if RFCOMM were to use a dynamic PSM a user of the Microsoft brand WINDOWS operating system could provide their own implementation of RFCOMM to be layered atop BTHTDI even if RFCOMM is already available in the WINDOWS protocol stack.

Any service layered over BTHTDI should create a Service Record as described above. The Service Record should additionally contain a Server PSM number that remote devices are to use when using the service. The Server PSM number may for example be listed as a protocol specific attribute.

Relating this information to the earlier description of this embodiment Winsock applications that want to listen or wait for a connection should advertise a BTHTDI session number in the Service Discovery Database. Likewise Winsock applications that wish to connect to a remote device should read the remote device s Service Discovery Database to determine which BTHTDI Server PSM number to use. Preferably as described the Service PSM is hidden from the application itself with the application simply specifying and accepting strings in this context and the lower layers such as WSHBTH.DLL performing querying setting of the Service Discovery Databases.

Extra definitions related to Bluetooth on Winsock may be defined in a header file such as Ws2Bth.H. Such a file may be used to create programs that use Bluetooth via Winsock. This file may define the Winsock address family for Bluetooth AF BTH the format of a Winsock address for Bluetooth SOCKADDR BTH etc.

Some exemplary interface definitions are given below in the context of Winsock 2.0 and where appropriate in the context of Winsock 1.1. For connection and data transfer an interface such as WSAStartup is called to initiate Winsock and to determine the level of Winsock support in the operating system. As an alternative to trying to initially determine the level of Winsock support an application may simply request support at a certain level terminating or retrying with a different level and optionally informing the user if the requested support is unavailable. Subsequently a new socket for inbound or outbound connections is created by a call to a socket interface. The appropriate protocol value for Bluetooth sockets is preferably specified in this call. An example of a call to a sockets interface is as follows 

A bind call is preferably used to link the created socket to the specified port. Server applications preferably call the bind interface with a SOCKADDR BTH structure where the port BTH PORT WILDCARD so that the channel may be automatically specified by BTHTDI. Once a bound socket is created it may be advertised via a complete Bluetooth SDP record established by a call to an appropriate interface such as WSASetServivce . The Winsock server can call getsockname to determine the port number assigned to their socket by BTHTDI pursuant to the bind call.

In order to listen for a connection a Winsock server preferably calls a listen interface to set BTHTDI to accept connections on a particular port. Preferably the relevant service is already advertised in its local SDP database. With respect to accepting a connection request an accept call for BTHTDI preferably behaves in the same manner as for any standard sockets implementation.

A connect request from an originating device preferably specifies the target device in a manner such that the target is identifiable. In this embodiment there are two ways for a target device to be specified according to one mechanism the SOCKADDR BTH can directly specify the port number to which a connect is requested. This mechanism requires that an SDP query be performed prior to attempting to connect. Alternatively the SOCKADDR BTH can specify the unique service class ID of the service with which it wishes to connect. In this case if the peer device has a plurality of ports that correspond to the specified service class ID the connect call preferably iteratively attempts to form a connection until one succeeds or until all ports have been tried. This mechanism does not require prior SDP queries.

Some connections may require an identification number such as a PIN prior to allowing connectivity. In such cases the PIN may be specified via a call to connect with an ioctlsocket SIO SET BTH PIN . Since it is not always known in advance whether a PIN is needed a failure to connect may be used to signal that a PIN is required. Thus the resultant control flow may be similar to the following 

Mechanisms usable for reading and writing data in this embodiment of the invention include all standard read write mechanisms currently supported by other address families.

A Bluetooth PIN structure should be passed in by the application for authentication on the connect call via a structure such as the following 

If as in this embodiment SDP registration is separate from socket control then care should be taken to clean up SDP database entries after abnormal abortion of an application. For SDP registration via the Winsock2 NSP API a new namespace NS BTH is assigned. Servers register their specific service information with Winsock and the BTHTDI driver using the WSASetService call. WSASetService may be used according to the following prototype 

In addition to its use in establishing SD records WSASetService can also be used to update an existing SD record with new information. The parameters of the call in this case are essentially the same as in the initial record registration with the exception that the SD service record passed in via lpBlob should contain the service record handle. If there are any differences in the records the existing record will be changed to match the passed in record. The service record handle can be discovered by querying for the record after it is initially registered using the WSALookupService functions to be described in greater detail below.

Similarly WSASetService can also be used to delete an existing SD record. In this case the fields of the WSAQUERYSET should be set as follows 

Note that IpServiceClassId determines the scope of the query. If set to the UUID of the L2CAP protocol it would return all the L2CAP services on the target essentially enumerating all SD records on the target. If set to the UUID of a specific service it would only return the instances of that service.

The WSALookupServiceNext call enumerates the services that match the query as specified in WSALookupServiceBegin one per call. The WSALookupServiceEnd call terminates the query and cleans up the context. If a WSALookupServiceNext call is pending on the specified handle in another thread it will be as if that call were cancelled.

The WSALookupService functions describe a polled interface which is impractical for applications which wish to wait and automatically connect to new peers as they come into range or to provide special user notification upon seeing a new peer. Therefore non polled mechanisms should also be provided.

WSANSPIoctl may be used to supplement Winsock2 to allow for notification of namespace changes. Exemplary steps to implement this function are to 

For contexts where WSANSPIoctl is unavailable BTHTDI should support this ioctl to give notification of changes in the Bluetooth namespace. Steps to use this are 

The Winsock helper WSHBTH.DLL implements a number of functions that may be used by Winsock 1.1 and or Winsock 2.0. The following chart lists these functions and indicates which version of Winsock requires such a function. Note that any Winsock function that is not fully implemented such as WSHJoinLeaf and WSHGetBroadcastSockaddr in this example are preferably implemented as simple functions that return an error when called.

With respect to the BTHTDI driver this driver exposes a kernel mode TDI interface to BTHPORT for use by AFD.SYS. In this embodiment BTHTDI uses the NT IO model wherein IO request packets IRPs are issued to the transport driver by upper protocol layers TDI clients . BTHTDI extends the NT IO model by defining IRPs to include addressing information IOCTLs for connection setup and data exchange and a callback mechanism for asynchronous notification from BTHTDI to the TDI client.

Each transport protocol defines an address that describes endpoint information associated with address objects that are open in the transport. The TDI address of a BTHTDI endpoint is defined as a simple 8 byte value six bytes of which correspond to the Bluetooth address and the top two bytes of which may remain unused. The address may be specified as follows 

The BTHTDI driver provides the standard DriverEntry function for driver initialization. During initialization it sets the function pointers for DriverUnload and MajorFunctions. The major functions IRP MJ  that are preferably supported are IRP MJ CREATE IRP MJ CLEANUP IRP MJ CLOSE IRP MJ PNP and IRP MJ DEVICE CONTROL. It is not required that all minor functions be processed. For example with respect to IRP MJ PNP PNP minor functions may be propagated down the stack rather than processed.

With respect to IRP MJ DEVICE CONTROL once BTHTDI is called for this function it calls TdiMapUserRequest to determine whether the control code maps to an IOCTL TDI  function. If so the stack location is remapped to an IRP MJ INTERNAL DEVICE CONTROL with the control code changed from IOCTL TDI  to TDI  function codes. Failure of the TdiMapUserRequest preferably indicates that the control code is a BTHTDI specific code. Preferably the following control codes are supported case TDI ASSOCIATE ADDRESS case TDI DISASSOCIATE ADDRESS case TDI DISCONNECT case TDI CONNECT case TDI SEND and case TDI RECEIVE.

A session multiplexing scenario is illustrated in . Application A which supports a service foo creates an address object on a specific port X. Application A optionally registers the service port mapping with SDP. Application B which supports a service bar creates an address object on port Y and also optionally registers the service port mapping with SDP. Subsequently a device with bdAddr A sends a connection request to port X leading to the creation of a connection object associated with the port X address object . The device with bdAddr A also sends a connection request to port Y for service bar leading to the creation of a connection object associated with the port Y address object . Finally a device with bdaddr B sends a connection request to port X initiating the creation of a connection object associated with the port X address object . These various connection scenarios are exemplary and one of skill in the art will appreciate that other session multiplexing scenarios are possible in view of the teachings herein.

With reference to the flow chart of a TDI client will open server endpoints for accepting incoming connections by first opening an address object in Step including a TDI ADDRESS BTH with port BTH PORT WILDCARD so that in Step BTHTDI will select an unused channel number for the object. Alternatively the client may specify a valid PSM number and if the specified port is in use then the opening of the address object preferably fails. Next the client opens a connection object in Step to be associated in Step with the address object just created. This will be the connection object for the first incoming connection received in Step . After accepting an incoming connection if additional connections are desired at decision the TDI client should create another connection object in Step for the next incoming connection and associate it in Step with the existing address object. If this connection is subsequently assigned and the client wishes to accept still further connections the client may create another connection object. When connection setup is complete in step BTHTDI should return the remote bdAddr and port such as via TDI ADDRESS BTH.

With reference to the flow chart of a TDI client opens client connections to remote devices by first opening an address object in step including a TDI ADDRESS BTH with port BTH PORT NULL. The NULL port indicates that the address object will be used for an outbound connection and the stack should not reserve a server channel number for it. The bdAddr value may be ignored and should be set to zero. Subsequently in step the client opens a connection object and associates it in step with the address object. Finally in step the client preferably issues a TDI connect request IRP on the connection object the IRP containing a TDI ADDRESS BTH with the bdAddr and port of the remote device.

As discussed above the BTHTDI driver interfaces to the BTHPORT component through Bluetooth Request Block BRB messages. A more detailed discussion of BRB messaging is given in Windows Whistler IRPs for Bluetooth included at Appendix A and herein incorporated by reference in its entirety. The messages exchanged between the drivers preferably follow the OSI semantics for communication between layers. For each initiated connection the BTHTDI driver registers an interface with the BTHPORT. An exemplary set of interface configuration information is as follows 

TDI CONNECT and TDI DISCONNECT functions preferably result in a request being sent to the BTHPORT driver which then sends the connect disconnect indication received on a PSM number to the callback routines of the interface associated with that PSM number. BTHTDI may also configure the connection for quality of service QoS by sending a request to BTHPORT and receiving an indication callback to the function specified in the interface corresponding to that connection.

TDI SEND and TDI RECEIVE functions preferably result in requests being sent to the BTHPORT driver without the need for a callback routine. The BTHTDI driver preferably implements a full duplex data exchange such that at the application level either peer is free to send data at any time over a valid connection. Thus the BTHTDI driver does not necessarily support TDI SEND DATAGRAM and TDI RECEIVE DATAGRAM.

It will be appreciated in view of the foregoing that a novel and useful architecture has been invented and disclosed herein for exposing the L2CAP layer of Bluetooth to user mode so that user mode applications can easily exploit Bluetooth functionality without being constrained by the limitations imposed by RFCOMM. This invention confers a benefit primarily on application developers and others who in view of the teachings herein may enjoy and exploit generic access to the L2CAP layer without prior knowledge of the intricacies of the Bluetooth protocols.

In view of the many possible embodiments to which the principles of this invention may be applied it should be recognized that the embodiment described herein with respect to the drawing figures is meant to be illustrative only and should not be taken as limiting the scope of invention. For example although the invention has been described in the context of Winsock and the Microsoft brand WINDOWS operating system those of skill in the art will recognize that other systems and general architectures may be used. For example in the UNIX environment equivalent generic access to BTHPORT could be supplied by providing an interface between applications and BTHPORT.

Note also that the elements of the illustrated embodiment shown in software may be implemented in hardware and vice versa and that the illustrated embodiment can be modified in arrangement and detail without departing from the spirit of the invention. Therefore the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof.

