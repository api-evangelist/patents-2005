---

title: Use of rules engine to build namespaces
abstract: A containment mechanism provides for the grouping and isolation of multiple processes running on a single computer using a single instance of the operating system. A system environment is divided into one or more side-by-side and/or nested spaces enabling the partitioning and controlled sharing of resources by creating different views of hierarchical name spaces via virtual hierarchies. A set of declarative rules specifying access capabilities may specify a set of filter drivers to be used to limit access to nodes in the hierarchical name space. The rules may be applied in sequence to construct a new name space from an existing one, or to add to an existing hierarchy. Filter drivers are used to limit access to nodes in the new name space or new portion of the name space. Access to nodes can be limited (read-only access instead of read/write) or nodes can be hidden altogether. Rules may be specified in a declarative language such as XML.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08312459&OS=08312459&RS=08312459
owner: Microsoft Corporation
number: 08312459
owner_city: Redmond
owner_country: US
publication_date: 20051212
---
This application is related in subject matter to U.S. patent application Ser. No. 11 301 093 entitled Using Virtual Hierarchies to Build Alternative Namespaces filed Dec. 12 2005 U.S. patent application Ser. No. 11 301 066 entitled OS Mini Boot for Running Multiple Environments filed Dec. 12 2005 U.S. patent application Ser. No. 11 301 072 entitled Mechanism for Drivers to Create Alternate Namespaces filed Dec. 12 2005 and U.S. patent application Ser. No. 11 301 065 entitled Building Alternative Views Of Name Spaces filed Dec. 12 2005.

When a single computer is used to run multiple workloads a balance should be struck between isolation of applications and the cost of using and administering the application isolating system. Applications should ideally be isolated from each other so that the workload of one application does not interfere with the operation or use of resources of another application. On the other hand the system should be flexible and manageable to reduce the cost of using and administering the system. Ideally the system should be able to selectively share resources while maintaining application isolation. Typically however all processes running under the same user account have the same view of system resources. The lack of isolation of the applications running on a particular computer contributes to application fragility application incompatibility security problems and the inability to run conflicting applications on the same machine.

A number of different solutions have been proposed which address one or more aspects of the problems discussed above. One way to isolate applications running on the same machine is to run the applications on different virtual machines . A virtual machine VM enables multiple instances of an operating system OS to run concurrently on a single machine. A VM is a logical instance of a physical machine that is a virtual machine provides to the operating system software an abstraction of a machine at the level of the hardware that is at the level of the central processing unit CPU controller memory and so on. Each logical instance has its own operating system instance with its own security context and its own isolated hardware resources so that each operating system instance appears to the user or observer to be an independent machine. VMs are typically implemented to maximize hardware utilization. A VM provides isolation at the level of the machine but within the virtual machine no provisions for isolating applications running on the same VM are provided for by known VM implementations.

Other known proposed solutions to aspects of the problems described above include SUN MICROSYSTEM S SOLARIS ZONES jails for UNIX BSD and LINUX the VSERVERS project for LINUX SWSOFT S VIRTUOZZO web hosting solutions from ENSIM and SPHERA and software available from POLICYMAKER and SOFTRICITY.

Another approach that addresses aspects of application isolation is hardware partitioning. A multi processor machine is divided into sub machines each sub machine booting an independent copy of the OS. Hardware partitioning typically only provides constrained resource allocation mechanisms e.g. per CPU allocation does not enable input output IO sharing and is typically limited to high end servers.

Hence in many systems limited points of containment in the system exist at the operating system process level and at the machine boundary of the operating system itself but in between these levels security controls such as Access Control Lists ACLs and privileges associated with the identity of the user running the application are used to control process access to resources. There are a number of drawbacks associated with this model. Because access to system resources is associated with the identity of the user running the application rather than with the application itself the application may have access to more resources than the application needs. Because multiple applications can modify the same files incompatibility between applications can result. There are a number of other well known problems as well.

There is no known easy and robust solution using known mechanisms that enables applications to be isolated while still allowing controlled sharing of resources. It would be helpful if there were a mechanism that allowed an application process group of applications or group of processes running on a single machine to be isolated using a single operating system instance while enabling controlled sharing of resources.

An intra operating system isolation containment mechanism called herein a silo provides for the grouping and isolation of multiple processes running on a single computer using a single instance of the operating system. A single instance of the operating system divides the system into multiple side by side and or nested isolated environments silos enabling the partitioning and controlled sharing of resources by providing a view of a system name space to processes executing within the silos. That is a single OS image serving the computer employs the mechanism of name space containment to constrain which process group of processes application or group of applications can use which resource s . Restricting access to resources is therefore directly associated with or based on the silo the process or application is placed in because if a process or application is unable to resolve a name used to access a resource it will be unable to use the resource. More particularly controlled sharing of resources among the spaces may be implemented via name space containment of hierarchical names spaces including the file system registry object manager or others. The silo also provides the ability to impose other restrictions on all processes contained within a given silo by rewriting access capabilities and or by applying a set of rules evaluated by a rules engine. New points of containment are provided at the process level group of processes level application level or group of applications level. A silo provides an abstraction at the level of a high level operating system e.g. at the level of files directories objects and semaphores to the applications and processes within the silo by enabling the applications and processes to run within the silo s view of the system or parent hierarchy. A process running in a silo is only able to access the subset of the global system name space which the silo s view presents. Names are resolved relative to the view of the global name space. For example when a request using a relative reference is processed the name referenced is resolved relative to the silo s name space so that the process is not able to escape from the silo.

A silo specific view of the system or view of the parent hierarchy in the case of a nested silo may be created by creating and exposing a virtual hierarchy or tree the nodes of which may be linked back to a node or name in a physical hierarchy associated with the external system space in which the silo resides or to a node or name in a parent silo . A virtual hierarchy is volatile. It is not persisted to permanent storage e.g. is not written to disk or to other stable storage media but resides only in memory or other volatile storage media and may be created dynamically as the silo is initiated. When the silo exits the virtual hierarchy may be discarded. The physical hierarchy in contrast is permanent persisted to stable storage and is independent of the existence or non existence of the silo. A silo may be implemented by having the silo provide the root for the processes running in the silo. For example the silo may provide the root of a virtual directory to be used by a process running in the silo. The provided root may represent the root of the file system directory for the process in the silo. A process within the silo cannot see or express any names above the virtual root. One or more hierarchies may be associated with a silo.

A virtual hierarchy is created by grafting branches from the system hierarchy onto nodes directly or indirectly attached to the virtual root associated with the silo. For the virtual file system the grafting operation makes either a file or a directory appear at one or more places within the process s virtual file system directory. The file system implementation effectively builds a new file system view over the system s physical file system name space or over the parent s file system name space. This concept may also be applied to other hierarchical name spaces such as but not limited to the file system the registry and the object manager name spaces.

A silo specific view of the system hierarchy or of a parent hierarchy in the case of a nested silo may be created by creating and exposing a new silo hierarchy or a new branch of an existing system or parent hierarchy some or all of the nodes of which may be linked back to a node or name in a parent silo hierarchy or to a node or name in a global system hierarchy associated with the external system space in which the silo resides. The new silo hierarchy or branch may be virtual. A virtual hierarchy is volatile. It is not persisted to permanent storage e.g. is not written to disk or to other stable storage media but resides only in memory and may be created dynamically as the processes within the silo run and as silos are created and destroyed. The physical hierarchy in contrast is permanent persisted to stable storage and is independent of the existence or non existence of the silo. The root of the silo hierarchy may be the default hierarchy that the applications running in the silo use for starting operations. Thus a silo may be implemented by having the silo provide the root for the processes running in the silo. A process within the silo cannot see or express any names above the silo root. One or more hierarchies may be associated with a silo.

For some hierarchical name spaces a view is created using a mapping function that maps physical nodes in one name space to physical nodes in another. That is all the sub root nodes of the silo hierarchy are junctions back to the system hierarchy or to the parent hierarchy for child silos . This approach may be used for a hierarchy such as the registry. For the silo registry the grafting operation described above makes a key or a value appear at one or more places within the silo registry.

For other hierarchical name spaces such as but not restricted to those which exist only temporarily in memory or other volatile storage while the system or silo is running a view of the system name space may be generated by creating a new branch of the system or parent hierarchy for each isolated environment. Junctions may be created via symbolic links. A process running in an isolated environment is only able to create symbolic links within its name space. Similarly when a symbolic link is resolved for a process running in the isolated environment it is resolved relative to its view of the system name space. One such hierarchical name space is the object manager name space. A new branch of the physical system hierarchy may be created for each silo in the object manager hierarchy which is created and stored only in volatile storage. The silo branch provides a view into the system object manager name space for the silo. Normal object manager symbolic links are used to junction to nodes within the object manager hierarchy. To ensure that a process running within a silo does not escape from the silo when a process in a silo issues a request to create a symbolic link the target name the node the link points to is resolved relative to the silo s name space so that the creation of symbolic links is limited to the silo name space.

When a branch is added to the system hierarchy for each silo the access capabilities for the branch may be specified. For example the access capabilities may specify that a node or branch of the silo hierarchy is by default read only when opened through the silo. That is if a branch grafted onto the system hierarchy for the silo is allowed only read only access capability each node in the grafted branch is also by default only read only. Alternatively rules may be associated with one or more nodes in the silo branch to provide a richer control mechanism for nodes within the grafted branch.

A set of declarative rules specifying access capabilities may be used to limit access to nodes in the hierarchical name space. The rules may be applied to construct a new name space from an existing one by for example filtering out directory entries so that only a subset of the original name space is visible to the silo. Access to nodes can be limited read only access instead of read write or nodes can be hidden altogether. Rules may be specified in any suitable way. One such format is via a declarative language such as XML.

A resource management system controls the use of various system resources such as memory CPU time IO bandwidth and so on. One or more of three kinds of links may be used to point to resources hard links symbolic links and aliases. A hard link is a reference or pointer to the physical data on a volume. In most file systems all named files are hard links. The name associated with the file is a label that refers the operating system to the actual data. More than one name can be associated with the same data but the data must exist in the same file system. A symbolic link is a type of link used in Unix for example which refers to another file by its pathname. In contrast with hard links there are no restrictions on where a symbolic link can point. It can refer to a file on another file system to itself or to a file which does not even exist detected as a problem only when the link is accessed . An alias is designed to maintain a link to its original file even if the original file is moved or renamed.

Secure access to resources can be based on access control lists ALCs or on capabilities. Most commercial resource management systems including some Microsoft WINDOWS operating systems use access control lists to control access to resources. Because of the widespread use of ACL based permission controls multiple applications are often allowed to share resources. Access to the resources is based on privileges associated with the identity of the person running the application or process rather than being based on the needs and characteristics of the application itself. This approach can be problematic. For example a user may have broad access privileges e.g. administrator status because some of the programs he runs need that level of access. For example because program1 run by user1 needs access to files one to ten user1 s access privileges must permit him to access files one to ten. Suppose program2 only needs access to files one and two. When user1 runs program2 program2 will nevertheless have access to files one to ten because user1 s privileges allow access to files one to ten. Thus because file system operations are based on ACL based permission controls in general the file system name space can be and generally is more or less global to all the processes launched by user1 running on the machine. ACL based permission controls lead to a number of problems including a program could waste processing time handling things it should not consider the presence of a new file that the program is not expecting might cause the program to operate incorrectly different programs may write or modify the same file causing interference and so on. This problem is exacerbated because not all programs have the same level of trustworthiness. Program1 may not be as trustworthy as program1 but since the user s privileges allow him to access files one to ten program2 has access to files one to ten and may maliciously modify them. In addition there may be occasions when it is desirable to provide different programs different files even though the programs use the same name for the file. Finally different programs may use the same name but mean different files. Hence there is a need for better control of shared resources than that which can easily be obtained using ACLs and privileges.

One very common resource is a file. A file system is a method for storing and organizing computer files and the data the files contain on storage e.g. on disk . Most file systems use an underlying non volatile data storage device on which files are persisted. A typical storage device provides access to an array of fixed size blocks sometimes called sectors which are generally 512 bytes each. The file system software is responsible for organizing these sectors into files and directories. The file system also keeps track of which sectors belong to which file and which sectors are not being used. Traditional file systems offer facilities to create move and delete both files and directories.

Another common resource is the registry. The registry is a central hierarchical database used in certain operating systems including Microsoft Windows 9x Windows CE Windows NT and Windows 2000. The registry is used to store information necessary to configure the system for one or more users applications and hardware devices. The registry includes information that the operating system refers to during operation. This information includes data such as profiles for each user the applications installed on the computer and the types of documents that each can create property sheet settings for folders and application icons what hardware exists on the system and the ports that are being used. The registry might be analogized to a file system optimized for very small files. In the registry directories are replaced by keys and files are replaced by values.

Other common resources are the system objects managed by an object manager and stored in an object manager name space. The object manager provides a resource management support infrastructure that executive subsystems including the memory manager I O manager and process manager rely on. One way a program accesses a resource such as a file is to open or create the resource. A resource is typically assigned a name when it is created so that it can be shared. To look up or open an existing shared resource or a global resource e.g. a file system disk or other physical device attached to the system a program specifies the resource name. Resources such as files and shared virtual memory may be represented as object data structures defined by the object manager. Objects may be implemented as shells that other executive subsystems can fill in so that custom object types can be built. The object manager tracks information that is independent of the type of resource an object represents. The subsystem specific core of an object contains data relevant to a particular resource.

Creating objects is advantageous because each subsystem does not need to redo work to track the system related state of an object look up its resources charge applications for the memory required to allocate an object and protect resources with security. By concentrating these functions in the object manager security code and naming conventions can be shared across subsystems. The object manager creates object types creates and deletes objects queries and sets object attributes and locates objects. An object type stores information common to all objects representing the same type of resource. When an executive subsystem initializes a function in the object manager is called to define the appropriate object types.

To address the need for a more powerful access control mechanism for resources such as files registry entries and system objects than that provided for by ACLs the silo containment mechanism is introduced that enables the creation of a new isolated environment in which a process program set of programs or application can run. In some embodiments a view of a system hierarchy is created by applying a set of rules to construct the view for the isolated environment. The new view is associated with the isolated environment. Rules may be used to limit access to resources and to hide resources in a nest able fashion. The rules may be applied when constructing a silo view of a hierarchy by constructing a new virtual or physical hierarchy or when constructing a new branch of an existing hierarchy. In each case the silo specific view is implemented by creation of the new hierarchy or new branch as directed by the rules. Directives controlling access to the nodes of the hierarchy or branch may be stored in the nodes of the structure and dynamically evaluated and enforced at runtime or during processing such as for example when a request for access to a node is received. In some cases the new silo hierarchy may be created by joining pieces of the global hierarchy to the leaf nodes of a virtual hierarchy to create a silo specific view of the system hierarchy. In other cases the new hierarchy is created and then nodes of the new hierarchy are mapped to nodes in a physical system hierarchy. Alternatively a new silo specific branch may be added to an existing hierarchy. Symbolic links may link nodes in the silo specific branch to nodes in the existing hierarchy. In some cases the silo hierarchy is stored only in volatile storage e.g. memory so that when the silo exits normally or abnormally the silo hierarchy disappears. In some cases the silo hierarchy is independent of and has no effect on the system hierarchy which is stored or persisted on non volatile storage media. The system hierarchy may be stored only in volatile storage or may be stored in non volatile storage. The new silo hierarchy provides a view of the global hierarchy for the process program set of programs or application running in the silo.

Rules may be applied during the construction of the view creation of the silo hierarchy and also dynamically during processing such as for example when access to a resource is requested. Rules may be implemented through the use of a rules engine and filter drivers as described more fully below.

Although not required the invention can be implemented via an application programming interface API for use by a developer and or included within the network browsing software which will be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs minicomputers mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CDROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . A graphics interface such as Northbridge may also be connected to the system bus . Northbridge is a chipset that communicates with the CPU or host processing unit and assumes responsibility for accelerated graphics port AGP communications. One or more graphics processing units GPUs may communicate with graphics interface . In this regard GPUs generally include on chip memory storage such as register storage and GPUs communicate with a video memory . GPUs however are but one example of a coprocessor and thus a variety of coprocessing devices may be included in computer . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory . In addition to monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

One of ordinary skill in the art can appreciate that a computer or other client device can be deployed as part of a computer network. In this regard the present invention pertains to any computer system having any number of memory or storage units and any number of applications and processes occurring across any number of storage units or volumes. The present invention may apply to an environment with server computers and client computers deployed in a network environment having remote or local storage. The present invention may also apply to a standalone computing device having programming language functionality interpretation and execution capabilities.

Within each partition system may include a system environment and a number of isolated environments. In some embodiments of the invention the isolated environments are silos. The system environment may include or be associated with a number of name spaces including but not limited to one or more of a system processes name space a system objects name space and a file system name space . System may also include an operating system . The operating system may include one or more operating system components including but not limited to an operating system kernel and an object manager . In some embodiments of the invention the object manager resides within the kernel. System may also include other components not here shown but well known in the art.

System may include one or more side by side silos etc. in each partition or associated with each drive letter. Each silo in some embodiments is associated with its own silo process name space silo object name space and silo file system name space but shares a single operating system instance with all the processes in the system. For example in silo is associated with silo processes name space silo objects name space and silo file system name space . Silo etc. does not however have its own operating system instance. That is for example silo is served by the same operating system instance operating system that serves the system environment and any other silos that may exist. Silo etc. may include one or more child silos etc. Silo itself may include one or more child silos and so on to any degree of nesting. Child silo in is associated with child silo processes name space child silo objects name space and child silo file system name space but is served by the same operating system instance that serve all the other environments. A child silo may be created by a process running in its parent silo. For example in a process in silo processes name space may have created child silo by creating a view into the silo name space as described more fully below. A process may not escape from its silo. For example a process in silo processes name space may not escape from silo . Similarly a child process of child silo processes name space may not escape from child silo . Furthermore the smallest entity capable of being siloed placed in its own silo is a process. A sub process cannot be siloed.

Rules specifying allowable capabilities for a process running in the silo may be provided to the rules engine . Rules may be provided in any suitable format. For example rules may be declaratively provided in the form of attributes in an XML file or XML document that defines a silo s view of resources. In some embodiments of the invention the XML file is used to create the view for the silo. Directives for accessing nodes in the view may be stored in the nodes of the view as it is constructed. That is during construction of a hierarchy the rules engine may receive a set of rules evaluate them and associate appropriate directives for accessibility with nodes representing the resource.

Directives stored within the view may limit the access of a process in a silo to a node to which the directives are applied. Access may be limited by rewriting the access capabilities returned with the handle to the node. In some embodiments of the invention directives are applied in sequence. In some embodiments a linked list is the data structure that implements the sequencing of directives. Directives may be applied when an access request is received for a resource associated with a directive and may be applied to all nodes beneath a junction. When an access request is received for a resource such as a file name for example the file name and the directives list is passed to the engine for evaluation. Each rule in the directives list is evaluated. If the end result of processing the rules results in specification of an object in the silo name space access to the resource is allowed and a handle to the node is returned to the caller. If the end result of processing the rules results in specification of an object that does not exist in the silo name space the request fails.

Thus the global name space for resources may be overridden by a silo specific version of the name space the virtual hierarchy for the file system a branch of the physical hierarchy for the object manager an independent physical hierarchy for the registry etc. that restricts the access of processes within the silo to the resources to those appearing within the virtual hierarchy. Processes may be assigned to the silo based on characteristics associated with the process so that resources can be restricted for processes in the silo based on the process instead of based on the user running the process. Each silo may override portions of the global file system name space. Similarly each silo may override portions of the global registry name space or other name space. If the silo is a child silo portions of the parent silo name spaces can be overridden by the child silo name space. For example when a process such as process running within a silo e.g. silo attempts to access a particular part of the file system the access may be redirected to a silo specific version of the file system. Similarly when a process such as process running within a silo e.g. silo attempts to access a particular part of the registry e.g. a key in the registry the access may be redirected to a silo specific version of the registry key. The silo s view of the registry may expose portions of the registry as read only even though the same process running with the same user s token may have read write access to the file when run from outside a silo or from a different silo.

To illustrate the creation of a virtual hierarchy for a silo the following example is directed to the creation of a virtual file system directory for the silo but it will be understood that the process also applies to the creation of an alternative registry or other alternative hierarchical name space. In the tree structure outside of the dotted box illustrates an exemplary physical file system directory as it exists in non volatile storage. Node is the root node. Nodes and represent child nodes of node . Nodes and are first level nodes. Node is a child node of node nodes and are child nodes of node and node is a child node of node . Nodes and are second level nodes. Nodes and are child nodes of node and nodes and are child nodes of node . Nodes and are third level nodes. Physical directory may represent the global hierarchical file system directory for processes in the system environment and may represent for example the following 

Virtual hierarchy enclosed in the dotted box may represent a virtual file system directory that may be created in memory volatile storage for a silo such as silo of created at step . Virtual hierarchy exists independently of physical hierarchy . Physical hierarchy is unaffected by the creation use or operations on virtual hierarchy . An empty virtual root node is created . Then virtual directory nodes are created . For example in nodes and may be created. Nodes may be created on one or more sub root levels. For example nodes and are first level nodes and node is a second level node. Any number of levels of nodes may be created. Nodes may be created on one or more sub root levels. In this is represented by the creation of a second sub root level of nodes i.e. node . For each node an access capability may be assigned via an access mask. Junctions may then be created to the physical hierarchy i.e. to the file system directory in the example on non volatile storage . A junction may be created from a leaf node such as leaf node leaf node and or leaf node to a node in the underlying physical directory. For example in virtual directory a junction junctions are indicated in the figures by dashed arrows extending from leaf node of virtual directory to node of physical directory has been created a junction from leaf node of virtual directory to node of physical directory has been created and a junction from leaf node of virtual directory to node of physical directory has been created. It is not necessary to name nodes in the alternative hierarchy the same as corresponding nodes in the global hierarchy. For example the node named Erick in physical directory may be named ErickX in virtual directory . For example the node named Erick in physical directory may be named ErickX in virtual directory .

Silo hierarchy enclosed in the dotted box may represent a silo specific registry that may be created in memory volatile storage for a silo such as silo of created at step . Silo hierarchy exists independently of physical hierarchy . Physical hierarchy is unaffected by the creation use or operations on silo hierarchy . An empty silo root node is created . Then silo hierarchy nodes are created . For example in nodes and may be created. Nodes may be created on one or more sub root levels but typically for a registry only one level of sub root nodes is created. For example nodes and are first level nodes. Junctions may then be created to the physical hierarchy i.e. to the system registry in the example in volatile storage . A junction may be created from a leaf node such as leaf node leaf node and or leaf node to a node in the underlying physical hierarchy. For example in silo hierarchy a junction junctions are indicated in the figures by dashed arrows extending from leaf node of silo hierarchy to node of physical hierarchy has been created a junction from leaf node of silo hierarchy to node of physical hierarchy has been created and a junction from leaf node of silo hierarchy to node of system hierarchy has been created. It is not necessary to name nodes in the silo hierarchy the same as corresponding nodes in the physical hierarchy. For example the node named WPA in physical hierarchy may be named something else in silo hierarchy .

To illustrate the creation of such a silo hierarchy the following example is directed to the creation of a silo object manager branch of a global object manager hierarchy but it will be understood that the process also applies to the creation of a view of other hierarchical name spaces. In the tree structure outside of the dotted box illustrates an exemplary system hierarchy as it exists in volatile or non volatile storage. Node is the root node. Nodes and represent child nodes of node . Nodes and are first level nodes. Nodes and are child nodes of node . Nodes and are second level nodes. System hierarchy may represent the global hierarchical object manager space for processes in the system environment and may represent for example the following 

Silo branch enclosed in the dotted box may represent a silo specific branch of the object manager name space that may be created in memory volatile storage for a silo such as silo silo of created at step and added to the system object manager name space. To create silo branch an empty silo root node is created . Then silo hierarchy nodes are created . For example in nodes and representing the silo C drive the silo D drive and the silo device may be created. Nodes and may be created representing the silo s hard disk volume and the silo s hard disk volume respectively. Nodes may be created on one or more sub root levels. For example nodes and are first level nodes. Nodes and are second level nodes. Junctions between nodes and and between and are normal symbolic links. Junctions may then be created to the system hierarchy i.e. to the system object manager name space in the example in volatile storage . A junction may be created from a leaf node such as leaf node or leaf node to a node in the system hierarchy. For example in silo branch a junction created via a silo specific symbolic link such as symbolic link extending from leaf node of silo branch to node of system hierarchy has been created and a symbolic link junction from leaf node of silo branch to node of system hierarchy has been created. It is not necessary to name nodes in the silo branch the same as corresponding nodes in the system hierarchy. For example the node named Hard disk VOL in global hierarchy may be named HD VOL in silo branch .

When a process in silo accesses node of the silo s virtual directory e.g. C Program Files node e.g. the Program Files directory of the physical directory will be accessed. Similarly when a process in silo accesses node of the silo s virtual directory e.g. C WINDOWS node e.g. the WINDOWS directory of the physical directory will be accessed. If a process in silo accesses node of the silo s virtual directory and enumerates the list of child nodes of node only node will appear in the list. For example suppose a process outside the silo requests an enumeration of the users in the Documents and Settings directory C Documents and Settings . The list of users will include child nodes and e.g. Madhu node Jeff node and Erick node . A process inside the silo that makes the same request will return a list including only Erick because node is the only child node of node of virtual directory hence creating a view of the global name space. Node of the virtual directory points to node of the physical directory . Furthermore if a process in silo attempts to access nodes and of physical directory the process will be unable to do so because that name is not able to be resolved in the process name space. For example if a process in silo attempted to open the file represented by node e.g. C Documents and Settings Madhu it will be unable to because the name cannot be resolved in the virtual directory the silo s file system name space .

It will be appreciated that a junction from any node of a virtual directory may be established to any node of a physical directory. Furthermore it will be appreciated that any node in the physical directory that exists above the junction will be unavailable to any process using the virtual directory. For example nodes and are unavailable to a process whose virtual directory is virtual directory . Furthermore it will be appreciated that additional levels of nodes may exist between the virtual root node and the leaf nodes in the virtual directory hierarchy. Any number of sub root levels may exist in a virtual directory hierarchy.

In some embodiments of the invention when a junction to the global hierarchy is reached the access capabilities for all the nodes below the junction are by default set to the access capability for the junction node. In some embodiments of the invention additional directives may be applied to the nodes below the junction as described more fully below. For example in if the junction from virtual directory node specifies read only access nodes and by default would only have read only access to any process that reaches those nodes via virtual directory . The capabilities available to the process running in the silo to a child node may also be restricted by rules associated with the child s parent node. These rules are evaluated before access to the child node is granted to a process in a silo. For example suppose that although junction specifies that access to nodes and is read only node is to be hidden and node should be read write. This result may be obtained by associating an additional set of directives with node . Whenever access to a child node of node is received from a process running in a silo associated with silo hierarchy the directives associated with node are evaluated to determine allowed access. A process in the silo that tries to access a name in the silo name space will specify the type of access desired. For example if a process in the silo wants to open C Documents and Settings Erick for writing the open statement will include an indicator requesting the ability to read and write to the file. If access is granted the handle that is returned to the process to enable the process to use the file will include the permissions associated with access that is what type of access is allowed e.g. read only or read write . Furthermore rules may be applied to nodes in the silo hierarchy to enable a silo to access a node permit or not to access a node suppress . Rules may also change the default access capabilities of a process to the node. For example referring again to suppose that the junction specifies that access to the branch comprising nodes and is read only. In this case as described above the access permissions returned in the handle to node would be rewritten to specify read only access. By default read only access would also be applied to any nodes directly or indirectly depending from node . Suppose however that it is desirable to hide node and to allow read write access to node . Such a result may be achieved by specifying rules associated with node . For example the rules associate with node to achieve this result might be Permit all nodes hide read write . Rules may be specified in any suitable manner. In some embodiments of the invention rules are stored via a linked list and are applied in order. Wildcards may be used when specifying rules in some embodiments of the invention. Suppose for example a hierarchy such as a silo file system directory with a parent node called Nodes has 9 child nodes named Aa Ab Ac Ba Bb Bc Ca Cb and Cc. A set of rules associated with sub directory nodes may include the following 

At if the node referenced is a node in the silo hierarchy and the node referenced is not a leaf node a handle is returned to the node . If the node referenced is a leaf node the name used to reference the node is changed to a name that can be resolved in the physical hierarchy . At the rules engine determines if access is allowed to this node by examining the rules information directives stored at the node as described above. If access is not allowed the request fails . If access is allowed the access mask is updated and any directives for the resource represented by the node are associated with the handle and the handle is returned . For example suppose a request to open a file is received. Suppose that the specific request is open C Documents and Settings Erick with read write access . At it may be determined that a silo e.g. silo exists on partition C. If the process requesting access to the Erick folder is a process such as a process of system processes i.e. a process outside the silo a handle to node of may be returned. If the process requesting access to the Erick folder is a process such as process i.e. a process within the silo the node to which access is being requested is node of virtual directory . Node is a leaf node with a junction to node in the physical directory. Suppose node of virtual directory is named ErickX. In this case the name would have to be changed to Erick in order to correctly be resolved in the physical directory. When the handle to C Documents and Settings Erick is returned the access capabilities of node are returned with the handle. Suppose that ErickX is associated with the directive suppress . In this case access is not allowed and the request would fail.

If the process making the request is a silo process the rules engine is invoked . If directive data is not present the list of entries is returned . If directive data is present the list of entries is filtered based on the directives as described above and the filtered data is returned at .

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the present invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device will generally include a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may utilize the creation and or implementation of domain specific programming models aspects of the present invention e.g. through the use of a data processing API or the like are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

While the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiments for performing the same function of the present invention without deviating therefrom. Therefore the present invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

