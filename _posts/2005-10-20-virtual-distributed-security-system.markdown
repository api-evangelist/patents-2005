---

title: Virtual distributed security system
abstract: A distributed security system is provided. The distributed security system uses a security policy that is written in a policy language that is transport and security protocol independent as well as independent of cryptographic technologies. This security policy can be expressed using the language to create different security components allowing for greater scalability and flexibility. By abstracting underlying protocols and technologies, multiple environments and platforms can be supported.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08302149&OS=08302149&RS=08302149
owner: Microsoft Corporation
number: 08302149
owner_city: Redmond
owner_country: US
publication_date: 20051020
---
This application is a divisional of U.S. patent application Ser. No. 10 068 444 filed Feb. 6 2002 which relates to and claims priority from U.S. Provisional Application No. 60 329 796 filed Oct. 16 2001 and U.S. Provisional Application No. 60 346 370 filed Oct. 19 2001 each of which is herein incorporated by reference.

The present invention relates to the field of computer security systems. More particularly the invention provides methods and devices for providing security to distributed computer systems.

Security frameworks have been developed to protect data transmitted in distributed computing systems. Existing security frameworks have an assortment of degrees of privacy security adaptability and scalability. The Kerberos system for example provides secure communications by users sharing a key with a third party. In order to conduct secure communications each party connect to the third party and utilize the key issued by the third party. Among other disadvantages the Kerberos system allows the third party to track the identities of users who are communicating with each. Furthermore the third party has the ability to decrypt messages because the third party issues the keys. The Kerberos security model is fixed that is administrators have limited flexibility in deployment options.

Other existing security systems have merits and limitations. For example security systems that utilize public key and private key infrastructures can include time consuming and expensive encryption and decryption steps. Time consuming encryption and decryption steps can limit the scalability of a security system if they are performed too frequently. As well PKI infrastructures often have revocation issues and many don t address the issue of management of multiple trust roots or cross certification. Most solutions are designed for specific purposes e.g. SSL or IPsec. Existing security systems have also generally focused on specific cryptographic technologies. For example Kerberos uses symmetric keys and PKI uses public keys.

There exists a need in the art for a generic security framework for use with distributed computing systems that is security protocol independent and that can be scaled for use with wide area networks such as the Internet and that is independent of the underlying cryptographic mechanisms being used.

The present invention overcomes one or more problems and limitations of the prior art by providing a generic security framework that is transport and security protocol independent and that can support multiple cryptographic technologies. The security framework utilizes a security policy which may describe the components of the framework their properties capabilities requirements and interactions. The policy is expressed using a security policy language. The security policy language allows different security components to be defined and configured without changing application code. Using this mechanism a specific set of security services can be defined which meet the needs of a specific deployment. Furthermore the security components allow the security services to be partitioned to increase both flexibility and scalability. By capturing the security semantics within a language the underlying implementation is abstract thereby creating a virtual distributed security system. Furthermore with the security semantics expressed in language the underlying protocols are abstracted allowing the security runtime to support different platforms technologies and protocols. Finally with a security policy definition in language form it is possible to construct proofs of the security system.

Aspects of the present invention are suitable for use in a variety of distributed computing system environments. In distributed computing environments tasks may be performed by remote computer devices that are linked through communications networks. Embodiments of the present invention may comprise special purpose and or general purpose computer devices that each may include standard computer hardware such as a central processing unit CPU or other processing means for executing computer executable instructions computer readable media for storing executable instructions a display or other output means for displaying or outputting information a keyboard or other input means for inputting information and so forth. Examples of suitable computer devices include hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCS minicomputers mainframe computers and the like.

The invention will be described in the general context of computer executable instructions such as program modules that are executed by a personal computer or a server. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various environments.

Embodiments within the scope of the present invention also include computer readable media having executable instructions. Such computer readable media can be any available media which can be accessed by a general purpose or special purpose computer. By way of example and not limitation such computer readable media can comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired executable instructions and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer readable media. Executable instructions comprise for example instructions and data which cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions.

Computer device computer device and computer device may be coupled to communications network through communication devices. Network interfaces or adapters may be used to connect computer devices and to a LAN. When communications network includes a WAN modems or other means for establishing a communications over WANs may be utilized. Computer devices and may communicate with one another via communication network in ways that are well known in the art. The existence of any of various well known protocols such as TCP IP Ethernet FTP HTTP and the like is presumed.

Computers devices and may exchange content applications messages and other objects via communications network . In some aspects of the invention computer device may be implemented with a server computer or server farm. Computer device may also be configured to provide services to computer devices and .

Security policies may describe the behaviors of components of a system or an overall security semantics of a system. For example when sending a message a security policy may require that the message be signed in a specific way or that multiple signatures of specific forms must be present that certain credentials must be presented and that at least a portion of the message is encrypted. In another example a security policy may identify the steps that must be taken before accessing a service.

The security policy may be authored by a system administrator or an application developers. Instead of a limited number of access control rules like prior art methods aspects of the present invention allow users and applications to create new access and other rules by creating or modifying a security policy. For example for a particular service an administrator may want users to have a special read access. In prior art systems the rights that may be utilized are hard coded within the security system. For example Windows NT operating systems has 32 defined permission rights. With the present invention the administrator can define new rights by defining or editing a security policy. The security policy may be capability based i.e. an application may define a capability and virtual distributed security system may provide that capability.

Security policies may be authored in a security policy language. The security policy language may be used to describe the security components their properties capabilities requirements interaction semantics and other security aspects. Those skilled in the art will appreciate that such a language could be expressed in many different forms. In some embodiments the security language may be a logic based language such as Prolog or some derivative. In other embodiments the security language may be rule based or a procedural based. Of course the security language may also be any combination of logic based rule based or procedural based. In one embodiment security policies are implemented with extensible markup language XML documents.

An identity component may provide a mechanism to authenticate a principal and provide authoritative proof of the identity. Proof of an identity may be established with a credential ticket license or some other mechanism acceptable to identity component . Aspects of the present invention are described below with respect to licenses. A license contains a set of assertions and is signed by an authority. One skilled in the art will appreciate that in alternative embodiments credentials tickets or other mechanisms may be utilized.

An admission component may provide a mechanism for regulating access to a trust domain of service . Admission component may map external credentials to internal credentials. For example application may provide public key credentials to admission component and admission component may return symmetric key credentials to application .

A permission component may provide a mechanism for pre fetching rights capabilities or other access control information. Permission component allows service to compare signed credentials received from permission component with the required rights capabilities for the operation requested by application . Comparing rights is generally more efficient for service than fetching rights particularly in embodiments where rights do not change.

A shared key component may provide a mechanism to securely share secrets between service security components and other services that exist within a trust domain of service . For example if the admission service returned a symmetric key license it may be encoded using a shared key for the trust domain. Service can obtain the shared key used by admission service from shared key service and use the shared key to decode the license.

A revocation component may provide a mechanism for tracking revocation. For example credentials issued outside the trust domain might be monitored for revocation for example using certificate revocation lists CRLS . Revocation component may also monitor usage within the trust domain and revoke credentials tickets licenses or other mechanisms that are being misused. For example an administrator can set limits on licenses for application such as call limits time limits or frequency limits. A call limit may limit the number of times a license may be utilized. A time limit may limit a license to a specific time period and a frequency limit may limit the number of times a license can be utilized within a given time period. If application exceeds these limits the license can be revoked. When coupled with a metering system this provides a mechanism to limit the exposure of a denial of service attack especially if it is accidental. This mechanism is also important when dealing with server farms. In prior art systems limits are typically divided by the number of servers and allocated accordingly. For example if there are 10 servers and there is a call limit of 20 each individual server will have a call limit of 2. In other prior art systems the call limit is applied to each server. As a result with 10 servers and a call limit of 20 the actual call limit can be 200. Revocation component may track the activity of all of the servers and ensure that the call limit is not exceeded. Of course propagation delays between servers and revocation component or a metering system may cause a call limit to be slightly exceeded in some cases.

A trust component may provide a mechanism for managing trust relationships. Trust component may utilize a trust policy or trust statement to indicate how an entity is trusted and or the extent to which an entity is trusted. A trust relationship allows a first entity to trust a second entity when the first entity trusts an authority that issues a license to the second entity. In some embodiments entities may define the scope of the trust. For example a first entity may trust a second entity for transactions with certain URLs. Trust relationships may contain a cryptographic component. For example with public keys embodiments certification chains are processed and eventually a certificate may be signed by a trusted authority. This mechanism maintains the trusted identities and their certificates so that they cannot be altered without proper authorization. Similarly a party may not trust the root of another party s certificate but may countersign or trust a countersignature on the certificate cross certification . In many circumstances trusts may be shared across different applications and services or even instances e.g. farms of a service. In such an environment trust component provides a mechanism for the trusting parties to be notified or obtain updates including additions changes or deletions of trusted parties. Those skilled in the art recognize that there can be multiple mechanisms for distributing updates including but not limited to polling and eventing and a security policy may make selections among the available options.

Trust component may provide a trust mechanism that spans enterprises or organizations. For example application may work with service in a specific contract to deal with parts ordering and tracking. While application and service may be running at different companies application and service may both also interact another entity such as a parts company. Application and service may both choose to trust any entity that the parts company specifies as trusted e.g. its sub contractors .

A store component may provide a mechanism for storing retrieving encrypting and managing credentials such as licenses. Store component may be used as a lockbox personal storage a directory a registry an escrow or other storage mechanism. Furthermore store component can verify the stored licenses including periodic revocation checks and countersign the credentials allowing parties that trust store component to optimize processing and skip validation checks.

In one embodiment the functionality of store component may be implemented with a directory such as directory shown in . The owners of licenses may retrieve and use the licenses as they are needed. Directory includes a memory module for storing a plurality of licenses. Memory module is shown with three licenses and belonging to a consumer A for illustration purposes only. Moreover while licenses are shown one skilled in the art will appreciate that other credentials such as private keys may be utilized. Memory module may contain licenses belonging to any number of entities and issued by any number of authorities. License was issued by an authority license was issued by an authority and license was issued by an authority .

Directory may also include a processor and a verification module that can be used to verify the status of one or more licenses stored in memory module . illustrates an exemplary method that processor and verification module may use to verify the status of a license. In step directory stores in a memory at least one license issued by an authority to a license owner. License for example was issued by authority and is stored in memory module . Next in step directory periodically transmits an identification message of the license to the authority. The directory may be configured to transmit identification messages hourly daily weekly or at any other interval. In one embodiment of the invention the interval is determined by the authority that issued the license. For example an authority may desire to have updates more frequently for more sensitive licenses. The identification messages may include a license identification number e.g. 156DVX22 for license . The authority may use the license identification number to determine whether the license has been revoked replaced or modified. In an alternative embodiment one or more authorities periodically transmit status messages to directory without first receiving an identification message. For example an authority may send a status message to a directory when the status of a license has changed. Polling and synchronization may be used when an entity has been disconnected or offline.

In step the directory receives from the authority at least one status message indicating the status of the license. The status message may indicate that the license remains valid has been revoked has been modified or some other status. In step it is determined whether the status message includes instructions for modifying the license. If the status message includes modification instructions the license is modified in step . A license may be modified by expanding or limiting its scope or duration or modifying any assertion or condition. Next in step it is determined whether the license includes instructions for deleting the license. A license may be deleted when it has been revoked by the issuing authority. If the status message indicates that the license is to be deleted the license is deleted in step .

Directory may receive from the license owner a request for the license in step . The license owner may request the license when the license owner desires to use the license for example. When the issuing authority has not revoked the license directory may transmit the license to the license owner in step .

Returning to an integrity component may provide mechanisms for signing digitally portions of a message and verifying integrity and signatures of received messages in accordance with security policies. A confidentiality component may provide mechanisms for encrypting and decrypting portions of a message. One skilled in the art will appreciate that there are many mechanisms that may be used to implement integrity component and confidentiality component and that in some embodiments a security policy makes a selection from the available options.

One of the advantages of abstracting underlying protocols and transports is that abstraction facilitates interoperability with other systems. illustrates how an application using a virtual distributed security system can communicate with an existing security component . Interoperability can occur because virtual distributed security may select the most appropriate protocol and transport based on information included in a security policy . In one aspect of the invention protocol may be a composable protocol. Virtual distributed security system may be built as a set of services with an application programming interface API that application may utilize. The API allows application and system virtual distributed security system to communicate with one another through a variety of different mechanisms such as but not restricted to RPC SOAP or shared memory.

A policy language used to create a security policy may define the functionality of a component using security primitives. The security primitives may be in combination with traditional programming elements. Those skilled in the art will recognize that security primitives can take various forms. In one embodiment the primitives might be high level constructs like create a license or manage storage of a license which are controlled by the use of parameters. For example the policy shown in for an admission component might represent create a license of type X for name N using key Y signed by license L. In another embodiment the primitives might be very low level constructs such as fetch the template for type X replace the name with N set the date field to Oct. 24 2001 set the authority field to Z set the key field to Y sign fields name date authority and key with license L using algorithm Y . Of course other embodiments of the invention may combine different levels of constructs.

Security policies such as security policy allow a definition of a distributed security system without the writing of code. Among other advantages a security system that does not require the writing and rewriting of code allows for custom components to be inserted to augment or replace specific steps. Such components could be provided by but not limited to native processor code Java beans or other Java language derivatives or Microsoft CLR modules.

In one aspect of the invention each security module may be described independently and a security policy can then indicate how to combine modules and how to deploy modules. Such information may be part of the policy or part of an independent deployment mechanism. Providing flexibility in describing combining and deploying modules allows a distributed security system to support partitioning replication and farming. For example in policy might specify how to partition service components into separate partitions . Those skilled in the art will appreciate that in addition to security related services the teachings shown in may be applied to non security related services.

Similarly a policy such as policy shown in might further specify which partitions are deployed to systems in a distributed computing systems. Systems may be implemented with applications computing devices separate processors of a multiprocessor system or other hardware or software. As is shown in a single partition may be present on more than one system of the distributed computing system.

A distributed security system may abstract cryptographic objects and operations to make the system independent of the underlying cryptographic technology. Licenses have been described above and may be a credential that is given to another party to identify oneself. Examples of licenses include X.509 certificates and Kerberos tickets. A testament may be proof that a party uses to prove that they own a license or a key within the license. For example an X.509 certificate contains a public key and a corresponding testament may be the associated private key. Similarly a Kerberos ticket includes an encrypted symmetric key and the testament may be the symmetric key itself.

A security policy may utilize elements such as licenses and testaments to create a single programming model for securing messages using operations such as sign verify encrypt and decrypt. To sign a message the license owner for example may encrypt a digest of the message with their testament. The holder of a license may verify the signature. Similarly to encrypt a message an entity may use a key in the recipient s license. The recipient may decrypt the message using a testament belonging to the recipient. In embodiments that utilize public keys a message may be encrypted with a generated symmetric key and the symmetric key may be encrypted with a public key from the license.

Entity can perform a decrypt operation to decrypt key using its testament . Using key entity can decrypt message . Next entity may perform a verify operation . Entity may compute a digest of message and compare the computed digest with the digest sent by entity using license .

One of the advantages of the present invention is that applications running for entities and may be the same regardless of whether licenses and contain public keys symmetric keys digest keys or other forms of credentials. The specifics of the cryptographic algorithms may be handled by the security system not the application. Handling cryptographic algorithms with a security systems is particularly desirable when heterogeneous credentials are used. That is licenses and use different cryptographic techniques. In traditional systems applications must be aware of this and be coded specifically for the presence of diverse cryptographic techniques. The present invention abstracts cryptographic techniques and does not require applications to be aware of the cryptographic technologies being used. As a result cryptographic techniques can be altered at any time simply by altering a security policy.

The disclosed security model can be used to create richer environments. For example while describing it was indicated that admission component might accept public key credentials and generate symmetric key licenses. The logic in admission component or in any other service may be the same regardless of the type of license used. With such a service the services can have increased scalability by simply using a symmetric key license. The operation of receiving a license and then issuing another license is defined as a re issuance operation because component is re issuing the sender s license using its own format. In some cases component or a similar component might return a license with the same key. For example component may accept an X.509 certificate but return an XML license with the same public key because component only accepts XML licenses.

Re issuance may form the basis of a delegation operation. A party A may make a specific delegation to another party B. To do this A may re issues B s license specifying the delegations as well as any conditions and sign the license as the issuing authority. To use this new license B may be required to present the license proof of ownership e.g. a signature and A s license if the recipient doesn t have it . The recipient may then verify that B owns the license and the A issued it and that the delegations in the license correctly correspond to A s license. The abstraction of cryptographic technologies and specific license formats allows applications to use a consistent programming model independent of the cryptographic technologies or license formats used at any specific time.

Another use of licenses and key abstraction is service scalability. Existing systems are typically limited when creating special keys for communications because only the client and the service know the key and state on the service limits scalability. The existing approach has limitations when a service is implemented as part of a server farm. Aspects of the present invention allow the service to re issue the sender s license providing a session key but encrypting it with a secret key that is shared across the farm possibly using the shared key service . Consequently any server in the farm that receives a message can understand and process the message since it can abstract the session key and no state is required to be maintained on the farm. Similarly problems arise in existing systems when a client is part of a farm. The technique described above may also be used by the client to provide a license to the service to use on its reply so that any client farm member can service the message.

Security credentials may be passed between components or services using the simple object access protocol SOAP. In one embodiment of the invention credentials such as licenses may be passed with SOAP messages by including them in a SOAP credentials header. The header may allow for any type of credential to be passed. Message integrity can be associated with SOAP messages by including digital signatures or other integrity mechanisms in a SOAP integrity header. For example this header can contain XML Signatures as defined in the W3C standard. Message confidentiality can be achieved by associating an XML tag encryption technology with SOAP messages. One such scheme is the XML Encryption standard as defined by the W3C. Confidentiality of message attachments may be achieved by including a manifest and encryption meta data of the encrypted attachments in a SOAP confidentiality header.

