---

title: Operating system arrangement for flexible computer system design
abstract: A programmable logic device with an embedded operating system is disclosed. The programmable logic device includes a bus, memory, a number of bidirectional communication ports, a switching mechanism. The operating system embedded in the programmable logic device responds to input received through the ports by either sending data to a device connected to one such port, or by instructing the switching mechanism to establish a direct connection between two such ports. This device may be included as part of a larger computer system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07660939&OS=07660939&RS=07660939
owner: Virinci Technologies, Inc.
number: 07660939
owner_city: Santa Clara
owner_country: US
publication_date: 20050725
---
This application claims priority to the copending provisional patent application Ser. No. 60 592 695 entitled An Operating System Arrangement for Flexible Computer System Design with filing date Jul. 30 2004 and hereby incorporated by reference in its entirety.

Embodiments of this invention relate generally to operating systems and computer system architecture and more specifically to improving system concurrence and providing additional system functionality by decoupling core operating system functions.

In all but the most simplistic of computing applications some form of operating system OS is present on a computing platform in order for that platform to function. The type of platform can vary greatly for instance desktop computers and network servers run operating systems in order to operate but for example cell phones personal digital assistants PDAs complex calculators and automated teller machines ATMs also require an OS. And while the features made available to the user through an OS will vary significantly depending upon the platform in question there is some commonality of function between every functional OS. In particular every OS generally serves as the interface between the central processing unit CPU and the rest of the computer system.

In order for the computing system to function the OS provides two fundamental functions. First the OS functions as a scheduler for the CPU in that tasks for the CPU to perform must be channeled to the CPU in a logical fashion inherent in this function is translation as not all CPUs have the same instruction set i.e. accept the same instructions and so the OS translates requests into a syntax the CPU understands. This first function is what forces an OS to be platform specific as supporting a different type of CPU requires supporting a different instruction set.

The second function of an OS is to be a services broker for the computing system. Applications running on the computing system or devices connected to the system do not need to know exactly what services are available on the system nor exactly how to interface with the hardware resources present in the system instead such applications and devices need only communicate with the OS which can forward requests to hardware or other applications as appropriate. For example if a computer program running on the system calls for a sound to be played the program need not know the make or model of the soundcard installed in the system but simply tells the OS that a sound should be played the OS will instruct the soundcard accordingly.

This concept is illustrated more fully with reference to . depicts a simplified overview of a prior art computer system . Computer system is depicted as being divided into three distinct levels application software operating system OS and hardware resources which includes the central processing unit CPU memory and soundcard . In order to function application needs to access several system resources for this example request will be a request for a computational process to be performed and the results returned and request will be a request for a sound to be played on soundcard . Application issues request and request to OS . In some cases OS would include application program interfaces APIs such as API and API which provide standardized handling of certain types of requests from applications like application . OS interfaces with some hardware through the use of device drivers such as driver device drivers are specific to the piece of hardware they are associated with and provide OS with information on how to interact with that piece of hardware. In present computer systems like computer system OS is written to interact with a particular CPU or at best a class of CPUs corresponding to certain common specifications such as x86 compatible processors and no device driver is necessary the functionality necessary to interact with CPU and related resources like memory are integrated into OS .

Several limitations are inherent to this common method of computer system design. First as noted above OS includes the scheduler and instruction set for CPU . In many cases the OS is actually optimized around a particular instruction set. As a result most operating systems can only run on a single brand or family of processor e.g. x86. And because application software is written to interact with the APIs of a particular OS applications can only run on a single brand or family or processor.

A second limitation results from the duplication of effort caused by the OS itself. With reference to an example application request cycle is depicted. In step at the moment when application sent request requesting that a sound be played application was resident in memory and performing operations on the CPU. In order for OS to respond to request in step application must suspend operations in order to allow OS to access CPU . In step OS processes the request. In step after request is handled OS calls soundcard and instructs that a given sound be played. Finally in step OS suspends again and application can resume executing operations on CPU . Essentially the same request must be issued twice once by application and once by OS before the desired effect occurs this duplication of effort requires more CPU cycles than simply issuing an instruction once would. In a desktop computer for example such CPU switching functions occur extremely frequently. This duplication is traditionally an accepted limitation as bypassing OS would require every application to include the instruction set for every conceivable hardware device. OS acting as a services broker reduces the development cost of application at the cost of reduced CPU efficiency.

A third limitation is inherent to the prior art approach to system architecture within computing systems. In existing computer systems running prior art operating systems such as OS all or substantially all information transfer between devices in the computer system occurs over a single common bus commonly referred to as a multi drop parallel bus. As all attached devices must share this common bus a bottleneck in data transfers exists. Continuing the example from above when application requests that a sound be played and OS passes that request to soundcard a portion of the available bandwidth on the common bus is used which reduces the available bandwidth for other operations within computer system .

An alternative operating system architecture is described. Embodiments of this architecture take several forms and provide substantial advantages over traditional approaches to operating systems and system architecture.

In one embodiment a programmable logic device such as the memory controller within an existing computer system or a dedicated microcontroller attached to a computer system can be programmed with an operating system. This programmable logic device can thereby take over the service brokering function of the operating system. Messages are sent to the OS via the existing system bus are processed on the programmable logic device and an appropriate response can be implemented all without interrupting the operations of the CPU. This embodiment can be practiced on existing architectures or as a component of a system designed around the present invention.

A second embodiment involves a completely redesigned computer system where the operating system running on a programmable logic device as described previously becomes the central point in the system. Every other component is connected directly to the OS each with a separate bus. The OS upon receiving a request either handles the request by passing data to another device or by establishing a direct connection between several attached components. Because each component is on a separate bus communication between two components does not interfere with the available bus bandwidth of the uninvolved components which is a significant advantage over existing architectural schemes. Additionally as the OS is again not running on the CPU every request handled without interrupting CPU usage represents an improvement over traditional OS implementations.

This second embodiment is extendable. Rather than being limited to traditional notions of computer system components a system is described that implements an embodiment of the present invention where everything that might request access to the system can be treated identically. This abstracted view allows individual software applications running on the computer system to be treated nearly identically to how the CPU itself is handled e.g. data is passed to an attached computing entity in accordance with a particular syntax and is received back in accordance with a particular syntax. The OS need not be concerned with whether the entity in question is a soundcard the CPU or an entire self contained computing system. This sort of black box approach to how the OS handles its roll as a resource broker greatly improves interoperability of components as the OS is no longer tied to a single class or family of processor nor is it necessary for every computing system to have its own operating system. If a resource can be connected to the OS and the interface to the resource made available it can be used with a minimum of effort.

Embodiments of the present invention by decoupling the operating system device driver and application layer intelligence allows each of these elements to take advantage of silicon technology and evolve into better and more efficient implementations independent of the other elements. This structure allows the operating system to become a one time investment for use by any kind of computing devices and also as a language or a paradigm for interconnecting computing devices with the added benefits of improved system concurrency and flexible computer system architectures.

A method for providing improved operating system functionality and a system implementing this method are disclosed. Reference will now be made in detail to several embodiments of the invention. While the invention will be described in conjunction with the alternative embodiment s it will be understood that they are not intended to limit the invention to these embodiments. On the contrary the invention is intended to cover alternative modifications and equivalents which may be included within the spirit and scope of the invention as defined by the appended claims.

Furthermore in the following detailed description of the present invention numerous specific details are set forth in order to provide a thorough understanding of the present invention. However it will be recognized by one skilled in the art that the present invention may be practiced without these specific details or with equivalents thereof. In other instances well known methods procedures components and circuits have not been described in detail as not to unnecessarily obscure aspects of the present invention.

Portions of the detailed description that follows are presented and discussed in terms of a method. Although steps and sequencing thereof are disclosed in a figure herein e.g. describing the operations of this method such steps and sequencing are exemplary. Embodiments of the present invention are well suited to performing various other steps or variations of the steps recited in the flowchart of the figure herein and in a sequence other than that depicted and described herein.

Some portions of the detailed descriptions which follow are presented in terms of procedures steps logic blocks processing and other symbolic representations of operations on data bits that can be performed on computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure computer executed step logic block process etc. is here and generally conceived to be a self consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a computer system. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions it is appreciated that throughout the present invention discussions utilizing terms such as accessing writing including testing using traversing associating identifying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Referring now to a block diagram of an exemplary computer system is shown. It is appreciated that computer system described herein illustrates an exemplary configuration of an operational platform upon which embodiments of the present invention can be implemented. Nevertheless other computer systems with differing configurations can also be used in place of computer system within the scope of the present invention. That is computer system can include elements other than those described in conjunction with . Moreover the present invention may be practiced on any system which can be configured to allow it not just computer systems like computer system .

Computer system includes an address data bus for communicating information a central processor coupled with bus for processing information and instructions a volatile memory unit e.g. random access memory RAM static RAM dynamic RAM etc. coupled with bus for storing information and instructions for central processor and a non volatile memory unit e.g. read only memory ROM programmable ROM flash memory etc. coupled with bus for storing static information and instructions for processor . Computer system may also contain an optional display device coupled to bus for displaying information to the computer user. Moreover computer system also includes a data storage device e.g. disk drive for storing information and instructions.

Also included in computer system is an optional alphanumeric input device . Device can communicate information and command selections to central processor . Computer system also includes an optional cursor control or directing device coupled to bus for communicating user input information and command selections to central processor . Computer system also includes signal communication interface input output device which is also coupled to bus and can be a serial port. Communication interface may also include wireless communication mechanisms. Using communication interface computer system can be communicatively coupled to other computer systems over a communication network such as the Internet or an intranet e.g. a local area network .

With reference now to a block diagram of an exemplary computing system is shown upon which embodiments of the present invention may be practiced. depicts computer system from a simplified architectural perspective. CPU memory soundcard and bus device are all interconnected by bus commonly referred to as a multi drop parallel bus. All of the attached devices must share this common bus which imposes a speed limiting factor on the system unrelated to the speed of CPU .

In developing embodiments of the present invention the following considerations were significant. Many of the functions and services provided in a typical operating system need not be architecture or host processor dependent. The inclusion of context switching functions and processor scheduling functions with the rest of the services provided in the operating system bound the operating system to the host processor s architecture in conventional systems. The inclusion of context switching and scheduling functions resulted from an attempt to treat the processor s time as a resource controlled by the operating system. The scheduling points were thus not only coordinating the computational results but also providing the processor s time as needed by the computational tasks. The roots for such an implementation stem from the historical fact that the processor was the smartest device in the system and was best equipped to execute or implement any computational tasks.

Embodiments of the present invention developed from the perspective that application processes threads or tasks can be viewed as types of virtual computing devices implemented as a series of instructions to be executed by a mono acting CPU switching from one process to the other. From this perspective context switching and scheduling functions are a means to administer operating system services other than CPU time and to coordinate the computational results between these virtual computing devices or computational tasks.

Given that the CPU is no longer the device best suited to implement or execute every computational task embodiments of the present invention view the operating system as a broker of system resources acting to coordinate the computational results and leaving the actual execution of the tasks to the entities best suited to do that. For example instead of waking up an application task and changing the processor s role from the operating system to execute an application the operating system is limited to providing the necessary data and events to perform the application logic the actual implementation of the application is performed by the entities best suited for that task.

Further if processor scheduling and context switching functions are treated as a way of implementing computational abstractions or virtual computing devices rather than an operating system provided service an application process task or thread essentially becomes a client for the operating system. The operating system provides services to its clients allowing them to interact with the rest of the computational intelligence other computational clients or other computational devices in the system to achieve the computer system s desired larger computational goals.

In such a paradigm the process creation primitives like fork calls are essentially a means to create new computational clients in the system and to register them with the operating system for services. And similarly the exec primitives of the OS the primitives to load an executable image into a process s space are simply a way by which an operating system s computational client alters its computational behavior to change the tasks it intends to perform in the system. In such a paradigm an FPGA Field

Programmable Gate Array being loaded with its code a DSP being loaded with its image and a Network Processor being loaded with its micro code all essentially become more or less equivalent. Each may be treated like an application process being loaded with a new executable image.

Embodiments of the present invention decouple the operating system services from the actual implementation of the application logic and enable flexible implementation of the applications and computer systems. Such an arrangement allows the application level computations whether implemented in software hardware or in some combination of both to be handled like a software based application or process within a typical operating system.

With reference now to a block diagram of Operating System OS is depicted in accordance with one embodiment of the present invention. OS includes application programming interfaces APIs and . OS also includes device driver programming interface . OS may also include optional CPU interface in one embodiment CPU interface is one type of device driver programming interface. Unlike traditional operating systems such as OS this embodiment of OS need not be designed to interact solely with one class or family of processors. Instead the CPU of a computing system such as CPU of computer system is treated as just another connected device and interacted with via a device driver or similar mechanism. This has implications that become evident below. OS does not include a CPU scheduler as part of the OS instead the CPU scheduler is also treated as a separate device and is interacted with via a device driver or similar mechanism.

With reference now to in accordance with one embodiment of the invention OS is written to run on computer system . However unlike OS OS is designed to be executed on a processor other than CPU . In one embodiment OS is executed on memory controller which has computing capabilities available. In another embodiment OS is executed on a different digital logic device attached to bus such as bus device . In one embodiment bus device is a separate dedicated device such as a printed circuit board with a microcontroller programmed for OS and connected to computer system through a bus such as PCI Express. Any type of bus connection known in the art is acceptable for this use and the selection of one type of bus is intended to be exemplary only. In another embodiment bus device need not be dedicated but simply includes a digital logic device with available computing resources a modern video card for example includes a very powerful processor and could be configured in accordance with this embodiment of the present invention. In one embodiment OS is written to be a message based operating system e.g. OS interacts with the elements of computer system through sending and receiving discrete formatted parcels of data.

With respect now to an example application request cycle is depicted in accordance with one embodiment of the present invention. In operation running OS on computer system alters behavior significantly from the traditional example given previously. In this embodiment the services broker functionality of OS is not executed on CPU though the CPU scheduler functionality may still need to remain on CPU as such functionality is processor dependent. In step an application requests that a sound be played. At the time this request is made the application is performing operations on CPU . Unlike previously however the application does not need to suspend operations for this request to be handled and in step the application continues executing operations on CPU . In step OS performing operations on Bus Device receives and handles the request without usurping CPU . In step the request is processed and forwarded to soundcard . In step the soundcard receives the request and starts playing the requested sound. The duplication inherent to OS s broker services functionality is still present but the loss of CPU efficiency has been removed.

With respect now to a block diagram of a computer system is depicted in accordance with one embodiment of the present invention. In this embodiment computer system utilizes a different architecture in order to make use of the advantages offered by OS computer system includes CPU Memory several exemplary devices and and a programmable logic device PLD upon which OS is run. CPU memory and devices and are each connected to PLD by a separate independent bus . In this embodiment PLD is a dedicated chip designed for use with OS . In one embodiment PLD is readily installed and removed from computer system such that a single PLD could be used to operate several different computer systems at different times. In other embodiments PLD is a fixed part of computer system .

In one embodiment PLD is designed to incorporate physical switches such as a cross bar switch. In another embodiment PLD is designed to incorporate logical switches. In either embodiment the inclusion of such switching functionality in PLD allows OS to create direct connections between attached devices without affecting other attached devices. For example assume device is a hard disk drive or similar permanent data storage and that device is a soundcard. An application currently running on computer system could call for data currently held on device to be routed to device and then call for access to memory . OS would use the switching functionality of PLD to establish a direct connection between device and device allowing data to flow from one to the other. OS would also establish a connection between memory and CPU . In a traditional architectural scheme such as that used on computer system the shared bus would create a bottleneck in the system as the two conflicting connections would have to share the single available bus. In computer system neither connection would affect the bandwidth available for the other as each device is connected to PLD with a unique bus and PLD has switch functionality to allow direct connections to be made.

With reference now to differences between the traditional CPU centric architecture paradigms and an operating system centric paradigm become apparent. depicts a typical computer system . In computer system CPU memory and two peripheral devices soundcard and bus device are interconnected by bus . In computer system the peripheral devices and are typically memory mapped or I O mapped for CPU during power on and initialization CPU programs the devices for appropriate action. For any service requirements the devices interrupt the operation of CPU or CPU constantly polls the devices and CPU acts on to provide the devices with the required services. For example if some data or computational result is available bus device interrupts CPU CPU reads the data from bus device and uses it with the rest of the computations in the system. If the devices are capable of doing DMA Direct Memory Access CPU allocates a portion of memory and then provides the devices the address of the region to read from or to write to.

In the CPU centric paradigm as depicted by computer system for any communication and interaction between devices CPU functions as a mediator. In this architecture no matter how intelligent the devices can scale all such intelligence could only be directed at making the devices more autonomous and independent of CPU enabling devices to interact with other devices without action by CPU is difficult. In such an architecture as that of computer system modifications to enable smarter device interconnection results in a system with limited applications or specific to one host processor s architecture and software.

With reference now to a computing system is depicted in accordance with one embodiment of the present invention computing system includes a programmable logic device PLD on which OS is run. In another embodiment OS is resident in memory and controls PLD . PLD includes some processing intelligence and some storage media in order to store and execute OS . PLD also includes a plurality of communication ports A B C and D. The number of communication ports illustrated is merely exemplary embodiments of this invention may be practiced with any number of communication ports. PLD also includes some form of switching technology. In one embodiment PLD includes physical switching technology such as a cross bar switch. In another embodiment PLD includes logical switching. PLD is connected to a bank of memory . PLD is also connected to a number of computing entities and . These computing entities are connected to PLD by individual buses A B C and D through communication ports A B C and D.

In operation computing system functions similarly to computing system . PLD and OS act as a services broker for computing system . A computing entity can request access to resources within computing system and OS will provide access. One important concept is that a computing entity can be nearly any device that can be connected to computing system . For example computing entity could be an application running on computing system communicating with OS through an API and requesting access to computing entity a hard drive. Computing entities and might be complete computing systems with individual CPUs memory and hard drives and PLD would make those resources available to any other computing entity attached to computing system . In such an arrangement no computing entity needs to know exactly what resources are available in the system or if the resources available have changed since last they were used as OS simply allocates resources as required.

In another embodiment OS does not need to know exactly what is connected to computing system . In this embodiment some or all attached computing entities are treated as black boxes. For example if computing entity was a complete computing system all that would be needed to be provided would be the equivalent of a device driver a listing of what resources are available to computing system and how to format requests for access to them. OS need not care if the CPU in computing entity is for example a PowerPC processor or an x86 compliant processor. Similarly OS would not care if computing entity was an application running on computing entity a CPU or if computing entity was a self contained device upon which an application was running interaction with computing entities could be simplified to essentially message passing and handling resource allocation.

In one embodiment PLD performs a switching function by establishing direct connections between computing entities when needed without impairing other connections. For example if computing entity an application needed access to computational results from computing entity OS would instruct PLD to establish a direct connection between computing entity and computing entity . This connection would not hinder or slow a previously established connection between computing entities and however each computing entity is connected to PLD via its own independent connection and no sharing of the available bandwidth is required.

In one embodiment computing system is configured to allow multiple computing systems to share a single operating system without degrading performance. In one embodiment computing system is configured to restrict access by certain computing entities to certain resources such restriction could be for system security or to ensure availability of resources to higher priority entities. One embodiment enforces restriction based upon which communication port is attempting to access resources. Another embodiment restricts access based upon the identity of the computing entity attempting access. In one embodiment some or all of the computing entities attached to computing system are allowed to map other computing entities or even the system itself to memory locations this allows for more direct interaction between devices irrespective of the physical connections involved which provides greater system transparency.

In one embodiment tracking and managing data flowing to and from computing entities and is accomplished through the use of process identifiers and process control blocks. Applying process identifiers and process control blocks to computing system allows OS to process information related to attached computing entities in the correct context. Each computing entity when sending a request should reference the process identity or otherwise identify the computing entity. Individual process control blocks within OS could track more than one computing entity this implementation allows multiple computing entities to share resources. Multiple computing entities can therefore be grouped into a single logical entity and be provided with common data resources and context.

In another embodiment OS can allocate portions of memory directly to attached computing entities. For example memory block can be assigned directly to computing entity . Access to memory so allocated is through the same bus used to communicate with PLD and OS namely bus A. As such computing entity receives access to both memory block and the resources offered by OS through the same connection. In another embodiment a second separate bus is used to provide attached computing entities access to memory .

A process control block is an operating system s way of providing a window into computer system s resources for a process or a computational task to compute in. In a traditional operating system s implementation such as OS when a new process is created its process control block is created and is initialized with the starting address of execution initial set of register values and necessary resources and parameters. If it is ready to execute the process is placed in the operating system s ready to run process queues. Scheduling of a process is characterized by three factors. First what to compute when the process is scheduled or picked out from the run queues as is indicated by the starting address stored in the process control block or the address to return to when after an operating system call is made . Second who is to execute the process in a traditional computing system such as computer system this would be CPU . Third the environment or the window under which the computations are to be executed as controlled and enforced by the operating system using process control blocks.

In symmetric multi processor SMP implementations a ready to run process could be picked to be run by any of the host processors each of which would produce the same computational results because all of the processors interpret the what to compute part the same the starting address and other processor specific register would mean the same to all the processors and because such computations are done under the same environment or process control block independent of the processor.

Embodiments of the present invention by decoupling the process control blocks from the architecture specific what to compute and who is computing can flexibly and dynamically attach the same process control block or the computational environment or the window into the computer system resources to different computing devices for different computations all under the umbrella of one logical process. As long as the what to compute is coherently managed the same processes could be scheduled to different computing devices.

With reference now to an application process is depicted. Process is an application process reading from a file and performing computing operations in one embodiment process is performing encryption decryption of data at step and then writing back to the file. If the processing performed at step can be better implemented using specialized hardware or on a different processor with necessary capabilities and the system hardware is modified to include such a device then the process logic in process needs to be modified to send the data read from the file to the device implementing the computational logic as a message and get the processed data back from the device and then continue on to write the processed data to the file.

With reference to interactions between an operating system and two attached devices are depicted in accordance with one embodiment of the present invention. shows the possibilities using the said operating system arrangement. In this embodiment component is the combination of operating system and PLD . Devices and are attached to component . In one embodiment device includes a scheduler configured to remove any process control block that is queued to queue in component and against that process control block and hence in the window provided by the operating system into the computer system s resources performs the logic described in device . In device the logic depicted in process is modified to use a service call into the shared operating system to move the process control block corresponding to the process in the shared operating system arrangement to queue when the required processing of the data is needed at step . In one embodiment the shared operating system of component is capable of scheduling back the process control block into process at step after the computations in component are complete to be able to resume the task. In another embodiment this is accomplished using queue which is used to queue all control blocks that can be processed inside device .

Unlike the traditional client server models where the computational results are sent back and forth between the client and servers the arrangement depicted in allows a process to change its incarnations from one type of device to another as needed to achieve its intended computational goals flexibly and efficiently. Because the process is completely re incarnated in device the logic in device can be more intelligent in its processing than is possible using standard message passing mechanisms. Thus the operating system arrangement allows both vertical process as a whole and horizontal different sections of the same process splitting of processes onto several computational devices around the operating system implementation. In a typical operating system implementation the process environment is modified exclusively using operating system calls e.g. allocating memory for the process opening of files network sockets or memory mapping of files or common shared resources . The operating system arrangement of component allows a processor based device to setup or modify the computational environment more intelligently and leave the actual computations to hardware device where device could be very efficient in computing but may not be so efficient in invoking operating system services and interacts with the rest of the computer system using only a limited set of operating system calls e.g. a file read and file write as shown in the example .

In one embodiment devices and are both processors. In this embodiment the two processors may be the same or different types. Hence the arrangement allows the processor control blocks to be moved from one scheduler queue to another to allow different processors to compute and collaborate computational results within a single process context.

Embodiments of the present invention described above thus relate method for providing improved operating system functionality and a system implementing this method. While the present invention has been described in particular embodiments it should be appreciated that the present invention should not be construed as limited by such embodiments but rather construed according to the below claims.

