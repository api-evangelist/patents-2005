---

title: Real-time software receiver
abstract: A real-time software receiver that executes on a general purpose processor. The software receiver includes data acquisition and correlator modules that perform, in place of hardware correlation, baseband mixing and PRN code correlation using bit-wise parallelism.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07305021&OS=07305021&RS=07305021
owner: Cornell Research Foundation, Inc.
number: 07305021
owner_city: Ithaca
owner_country: US
publication_date: 20051222
---
The present application is a divisional application of U.S. patent application Ser. No. 10 753 927 filed Jan. 8 2004 now U.S. Pat. No. 7 010 060. The present application claims priority to U.S. Provisional Application No. 60 439 391 filed Jan. 10 2003 entitled REAL TIME SOFTWARE RECEIVER which is incorporated herein in its entirety by reference.

This invention was made with United States Government support from the Office of Naval Research ONR under contract number N00014 02 J 1822 and from the National Aeronautics and Space Administration NASA under contract numbers NCC5 563 NAG5 11819 and NAG5 12089. The United States Government has certain rights in the invention.

This invention relates generally to software radio receivers and more specifically to a software receiver for positioning systems.

A typical positioning system receiver such as is used in the Global Positioning System GPS includes an antenna a radio frequency RF section a correlator a signal tracking and demodulation component and a component to compute the navigation solution. The antenna which is possibly followed by a pre amplifier receives L band GPS signals. The RF section filters and down converts the GHz GPS signal to an intermediate frequency in the MHz range. The RF section also digitizes the signal. The correlator separates the down converted signal into different channels ten or more in modern receivers allocated to each satellite. For each satellite the correlator mixes the Doppler shifted intermediate frequency signal to baseband by correlating it with a local copy of the carrier replica signal and it distinguishes the particular satellite by correlating the signal with a pseudo random number PRN code. Software routines cause the carrier replica and PRN replica signals to track the actual received signal extract the navigation message and compute the navigation solution.

Baseband mixing is a multiplication of an input signal by a complex exponential where the frequency of the complex exponential approximately matches that of the input signal. The resultant signal is centered at baseband. A complex signal can be broken down into cosine and sine signal components resulting in separate in phase and quadrature components. The frequency of the baseband mixed signal must be controllable to within a few millihertz in the case of a phase locked loop for use in a precision navigation system and the baseband mixed signal must have a continuously varying phase. In a hardware correlator local oscillators generate cosine and sine signal components that have precise frequency control and a continuous phase. Generating cosine and sine signal components on the fly with the correct frequency and phase is too time consuming to be feasible for a software correlator. Instead the software correlator generates cosine and sine signal components on a grid of frequencies off line. These signal components must be stored on a time grid of points sampled at the RF front end sampling frequency for example at 5.714 MHz for one particular RF front end hardware configuration and the signals must last for a typical accumulation period e.g. for a 0.001 second coarse acquisition C A PRN code period when working with GPS L1 civilian signals. It takes tens of gigabytes of memory or more in order to brute force store all frequencies on a one mHz grid ranging from 10 KHz to 10 KHz which is the needed frequency range when tracking GPS satellites from a terrestrial receiver and additional storage is required to store a grid of possible starting phases at each frequency point.

PRN code mixing is a multiplication of a baseband mixed signal by a prompt 1 1 PRN code or by a 2 0 2 early minus late PRN code where the code timing and frequency approximately match that of the input signal. The resultant signal is a constant in the case of prompt PRN code mixing and an approximately linear function of the code timing error in the case of early minus late mixing. A receiver accumulates both of these correlation outputs. The magnitude of the prompt accumulation indicates signal strength and whether a signal has been detected and its in phase real and quadrature imaginary components are used to measure carrier phase and Doppler shift. The magnitude of the early minus late accumulation measures the code timing error it will be zero when the timing error is zero.

The code phase of the baseband mixing signal must be controllable to within a percent or less of a PRN code chip for use in a precision navigation system. In a hardware correlator local oscillators generate the prompt and early minus late PRN code replicas. A software correlator can either compute and store PRN code replicas or compute them in real time.

The current Global Positioning System is slated to realize expanded capabilities that include new civilian codes on the L2 frequency a new L5 frequency and new codes M code CL and CM codes on the L2 frequency. Some of these upgrades are slated to start within one to three years. A hardware correlator requires hardware modifications in order to use these new signals. In the near term a receiver designer will be faced with a complex trade off in order to decide whether the extra complexity is worth the improved performance that will accrue only very slowly as new GPS satellites replace older models. One way to avoid the complex trade off is to use a software receiver that can receive and process new signals without the need for a new correlator chip set.

A software receiver is flexible because its software components can be easily modified. One application of a software receiver is to merge together numerous devices that use wireless digital communication protocols to form a single device. For example a cell phone GPS receiver and Personal Data Assistant PDA could become a single device that plays the role of all three. Another use of a software receiver is to shorten development and to market times for new wireless devices. For example as new frequencies and codes are added to GPS a software receiver having a software correlator simply needs to be reprogrammed while a hardware approach would require a brand new correlator chip design. New PRN codes can be used simply by making software changes. Thus software receiver technology lessens the risks involved for designers during the period of transition to the new signals. Furthermore a software receiver could be reprogrammed to use the Galileo system European GPS or GLONASS Russian GPS .

In the recent past GPS software receivers have been developed that either post process stored signals or operate in real time. Previous real time software receivers function with a limited number of channels or require high end computer speeds or digital signal processor DSP chips such as are disclosed in Akos et al. ION NTM 2001 22 24 Jan. 2001 Long Beach Calif. pp. 809 816 Akos 2001a and Akos et al. ION GPS 2001 11 14 Sep. 2001 Salt Lake City Utah pp. 2851 2858 both incorporated herein in their entireties by reference.

Therefore it is an object of the present invention to create a software receiver that operates in real time and is not restricted to a severely limited number of channels or to a very fast processor.

Another object of the present invention is to minimize the number of sine and cosine signal components that must be stored.

A further object of the present invention is to process incoming signals through bit wise parallelism.

A still further object of the present invention is to process over sampled signals by use of bit wise parallelism.

A still further object of the present invention is to use very long over sampled PRN codes efficiently in a bit wise parallel software receiver.

The objects set forth above as well as further and other objects are addressed by the present invention. The solutions and advantages of the present invention are achieved by the illustrative embodiment described herein below.

The software receiver system and method of the present invention enable the efficient execution of a set of algorithms that perform software correlation on data sampled from incoming channels on a general purpose processor. The system and method of the present invention provide for either PRN code storage or computation of PRN codes in real time. PRN code storage is appropriate for PRN codes that have short periods such as the GPS coarse acquisition codes which are 1023 chips long. In this case the system and method of the present invention pre compute over sampled replicas of entire PRN code periods and store them for orderly and efficient retrieval such as in a table. This table can include a selection of code start times as measured relative to the sample times at which RF data are available from the receiver front end. There is a separate table for each unique PRN code.

The system and method of the present invention can also generate over sampled versions of the prompt and early minus late PRN codes in real time through use of an over sampling function described herein. The values of the over sampling function can be located in a specially designed table that can be generic across PRN codes. The length of the specially designed table can be independent of the length of the PRN code whose replica is being used to process a given received signal. The system and method of the present invention include techniques for efficiently calculating indices into the specially designed table that enable rapid real time table look up.

The system of the present invention includes a software correlator that can mix the received signal to baseband compute baseband PRN correlations through bit wise parallelism and look up tables using either the tabulated or real time generated PRN codes and compute accumulations through bit wise parallelism and processor instructions or look up tables. Bit wise parallelism allows the processing of multiple data samples simultaneously as the multiple bits of a given word of computer data. For example for 32 bit words the software correlator can process up to 32 samples at a time. Bit wise parallelism can optimally operate when each signal in question can be represented by only a few bits which is normally the case in RF digital signal processing of navigation signals.

The bit wise parallel operations of the present invention can save computation time in comparison to integer mathematical correlation operations. If for example four accumulations are required per sample integer mathematics requires six multiplications and four additions per sample except for the last sample . At a sampling rate of for example 5.714 MHz this translates into 57 140 integer operations per PRN code period. In the illustrative embodiment 33 500 bit wise parallel operations are necessary per PRN code period when the RF signal has a 2 bit representation. This operation count is further reduced to approximately 16 750 bit wise parallel operations per PRN code period when the RF signal has a 1 bit representation. Thus there can be a savings of almost a factor of two to almost a factor of four in the operation count.

The system and method of the present invention also include a table of pre computed baseband mixing sine waves algorithms that can produce correlation accumulation outputs that are equivalent to what would be produced by a continuously variable sine wave and a method of use of the table and algorithms. Thus in the present invention a relatively small set of sine wave values need to be pre computed and saved which can conserve computer memory and processing time.

The present invention also includes a system and method for tracking the phase of PRN code replicas in software in order to track the timing of any given chip of the PRN code replica as measured with respect to a pre specified set of sample times at which the basic raw data comes out of the RF front end a chip is an element of a PRN code . The PRN code phase is kept track of via a variable for each channel that indicates the PRN code start time with respect to the RF sample times. The system and method of the present invention allow for the synchronization of the measurements of PRN code phase carrier phase and carrier frequency for each satellite relative to these sample times.

The method for tracking the phase of each PRN code replica and the phase of each carrier replica includes the steps of latching all the C A code phases carrier phases epoch counters and carrier frequencies for each satellite at a pre specified time and computing the pseudo range to each satellite using the C A code phase and epoch counters. The method also includes the step of tracking and updating code and carrier phases by estimating code chipping rate and carrier Doppler shift inputs. The method further includes the step of computing the code phase at the pre specified time for each satellite as a function of the updated code chipping rate and the pre specified time. The method further includes the step of computing the carrier phase at the pre specified time as a function of the updated carrier phase the Doppler shift and the pre specified time. The timing of the PRN code phase or chip location is the most fundamental of GPS measurements for use in navigation data processing. The monitoring of these times in software allows complete control of the precision with which they can be measured and it allows precise synchronization of these times with the measurement times of data from other sensors such as inertial measurement units. This feature gives an enhanced ability to develop what are known as deeply coupled systems that must fuse GPS data with data from other types of sensor systems.

The software correlator of the present invention can advantageously be easily adapted to accept signals at any frequency new PRN codes or even signals for different types of devices. Thus the same processing hardware could use the software correlator to implement such devices as a GPS receiver a cell phone or both. To allow for new codes new frequencies and new types of functionality small changes can be made in the software correlator or different versions of the software correlator can be run on the same processor. Hardware correlator based receivers of the prior art can deal only with frequencies and PRN codes that are hard wired into their designs. Also the system and method of the present invention could be implemented within systems such as GLONASS receivers cell phones and cell base stations pagers wireless Ethernet e.g. 802.11 standards Bluetooth Blackberry wireless internet devices and satellite radio phones e.g. INMARSAT . In fact the system and method of the present invention are applicable to any sort of telecommunication system device that uses spread spectrum code division multiple access CDMA PRN codes for the transmission of information either wired or wireless.

For a better understanding of the present invention together with other and further objects thereof reference is made to the accompanying drawings and detailed description. The scope of the present invention is pointed out in the appended claims.

The present invention is now described more fully hereinafter with reference to the accompanying drawings in which the illustrative embodiment of the present invention is shown. The following configuration description is presented for illustrative purposes only. Any computer configuration satisfying the speed and interface requirements herein described may be suitable for implementing the system of the present invention. The equations herein are stated in general terms but have parameters that are specific to the GPS L1 C A signal for illustrative purposes only. For example the 0.001 sec. accumulation interval seen in many of the equations is the nominal C A code period. Also the C A PRN code of the illustrative embodiment can be replaced by the PRN code of any other CDMA signaling system.

By way of introductory explanation RF signal processing equations and terms are herein provided. The time domain L1 C A signal received from for example a satellite is represented by 

A GPS receiver works with correlations between the received signal and a replica of it. The correlations are used to acquire and track the signal. The replica is composed of two parts the carrier replica and the C A PRN code replica. Two carrier replica signals are used an in phase signal and a quadrature signal. When mixed with the received signal from the RF front end they form the in phase and quadrature baseband mixed signals represented by 

A typical receiver computes the estimates circumflex over circumflex over circumflex over and circumflex over by various conventional means that are described in GPS Receivers A. J. Van Dierendonck B. W. Parkinson and J. J. Spilker Jr. Eds. vol. I American Institute of Aeronautics and Astronautics 1996 Chapter 8 pp. 329 406 Dierendonck incorporated herein in its entirety by reference. These include open loop acquisition methods and closed loop signal tracking methods such as a delay locked loop to compute circumflex over and circumflex over and a phase locked loop or a frequency locked loop to compute circumflex over and circumflex over . The software receiver developed herein uses conventional techniques for forming these estimates.

Both prompt and early minus late correlations are needed to track the carrier frequency carrier phase and code phase in a GPS receiver. A typical receiver uses the PRN code and carrier replicas to compute the following in phase and quadrature correlation accumulations 

Referring now to the operational platform of the software receiver of the present invention includes an antenna conventional RF front end a data acquisition DAQ system a microprocessor a software correlator and application specific code . Conventional RF front end interfaces with antenna and with DAQ system . DAQ system includes a system of shift registers and a data buffer. Microprocessor executes software correlator which includes a set of specially developed bit wise parallel algorithms and application specific code such as the GPS navigation and tracking functions. In the illustrative embodiment conventional GPS software functions signal tracking data extraction navigation solution etc. are provided by the MITEL GPSArchitect software ported to RTLINUX see Ledvina et al. 2000 Nov. 27 28 2000 but can be provided by any equivalent configuration.

Continuing to refer to conventional RF front end can for example be a MITEL GP2015 RF front end which down converts the nominal 1.57542 GHz GPS signal to an intermediate frequency of 88.54 63 10Hz 1.4053968254 MHz and then performs analog to digital conversion. The resultant digitized signal data has a pre determined number of bits sample such as two binary bits sample a sign bit and a magnitude bit or one bit sample. The shift registers in the DAQ system parallelize the magnitude and sign data bit streams into separate words which the DAQ system reads into the memory of microprocessor using DMA. To make the process of reading data into the microprocessor more efficient and to prepare for efficient correlation calculations DAQ system can read a pre specified number of bits of buffered samples such as thirty two bits at a time. The exemplary thirty two bits include sixteen sign bits and sixteen magnitude bits.

Referring now to the shift registers in DAQ system buffer signal data and pack signal sign A and signal magnitude B into separate words that represent the integer values 1 and 3 as is shown in Table 1. In the case of a 1 bit signal the bit stream representing the samples is packed into successive words to prepare the signal for bit wise parallel processing. DAQ system also provides for accurate timing by for example synchronizing signal sign A and signal magnitude B to a 40 7 10Hz 5.714 MHz clock signal which can be for example a third output from conventional RF front end . DAQ system can convert the 5.71424 MHz clock signal down to 357.14 KHz by use of for example a divide by 16 counter for a 16 bit word which can provide a signal indicating when the buffer is full. DAQ system can use any method for providing a buffer full indication.

With further reference to in the illustrative embodiment the DAQ system can consist of an interface card and driver software that can be compatible with for example a 1.73 GHz AMD ATHLON processor running RTLINUX but could be compatible with any operating system and any processor that can accommodate real time operations. The interface card can for example be a NATIONAL INSTRUMENTS PCI DIO 32HS digital I O card. Pertinent features of this card are the thirty two digital input lines DMA and availability of a driver for RTLINUX perhaps gotten from the suite of open source drivers and application interface software for interface cards known as COMEDI COntrol and MEasurement and Device Interface . Modifications to the conventional COMEDI driver for the PCI DIO 32HS card include increasing the number of input bits from sixteen to thirty two enabling DMA and modifying the driver to support continuous interrupt driven acquisition.

With still further reference to microprocessor can be for example a 1.73 GHz AMD ATHLON processor running the RTLINUX operating system but any operating system and processor that can accommodate real time operations can be used. Low latency interrupt responsiveness the ability to execute threads at regular intervals with the kernel having a possibility of being the lowest priority thread and reliable execution of time critical code are among features of an operating system that could enhance the performance of the system of the present invention. The use of RTLINUX is presented herein for illustrative purposes only.

Continuing to refer to analogous to a hardware correlator that takes input directly from the RF front end in serial fashion software correlator reads from a shared memory buffer that both software correlator and DAQ system can access the former to read data and the latter to write data. The shared memory buffer can be implemented as a DMA memory space and a circular buffer. In the illustrative embodiment in which the system and method of the present invention are used in a GPS or similar environment microprocessor can store the most recent twenty one milliseconds of signal data in the circular buffer but could store more or less. The present invention does not fix the size of the circular buffer nor the amount of RF data that can be stored there. The circular buffer allows the processing of code periods that start and stop at different times for different satellites during different iterations of a regularly scheduled program thread. DMA memory space can be written to directly by DAQ system using a DAQ software driver which fills the circular buffer. Communication between software correlator and application specific code can be performed using operating system provided shared memory capability. For example the mbuff driver included with RTLINUX can be used to create and manage this shared memory space. Any memory management system that accommodates real time processing can be used. If the mbuff driver is used kernel modules can share memory and the kernel can be restricted from swapping the shared memory space to long term storage.

Continuing with the analogy to hardware correlation and still referring primarily to in hardware correlation the correlator receives frequency and phase information from tracking and acquisition loops that are part of application code and Numerically Controlled Oscillators NCOs generate signals that correspond to the written frequencies and phases. In contrast software correlator includes simulated carrier and code NCOs that receive their frequency commands from application specific code . Software correlator uses these frequency commands to reconstruct carrier replica signal and prompt PRN code and early minus late PRN code which it mixes with the signal data resulting in fully mixed prompt integrand and fully mixed early minus late integrand .

To further continue the analogy a hardware correlator generates in real time a particular C A code replica at the correct Doppler shifted frequency and phase. In contrast software correlator can generate C A codes off line and store them in a memory table the pre computed over sampled PRN code table . The pre computed over sampled PRN code table is used to select PRN codes with the correct timing relationship to the sample times of signal data . The codes are then used to form correlations with baseband mixed signals the result from which is summed to produce the standard in phase and quadrature summed prompt accumulation and summed early minus late accumulation that are equivalent to what would be produced by a continuously variable sine wave. These are provided to application specific code such as conventional GPS software that executes signal tracking and navigation functions. In a second approach software correlator can generate the PRN carrier replicas on line at the code chipping rate and can use tabulated functions to re sample the code at the sample rate of the RF front end for purposes of calculating accumulations. Real time over sampled PRN code generator A is used in place of pre computed over sampled PRN code table in this latter approach. This latter method can be used with longer PRN codes such as the new civilian GPS L2 CL codes.

With still further reference to since the received L1 raw signal can have an uncertain carrier phase software correlator computes both in phase I and quadrature Q accumulations as defined in equations 4 and 5 . Software correlator begins the accumulation process by using carrier replica signal which it gets from pre stored carrier replica table . The carrier replicas in this table fall on a rough frequency grid and they all start with a particular phase for example a phase of zero. The baseband mixing process involves selecting a carrier replica signal from carrier replica table that is at the frequency that is as close to ideal as possible. In the case of a 175 Hz grid spacing the baseband mixing process selects a signal that is maximally within 87.5 Hz of the ideal signal. The rough frequency grid can have a spacing of for example 175 Hz but could be larger or smaller depending on a the frequency range needed to cover for example 10 Khz b the amount of space available for storing pre computed signals and c other design decisions. The pre computed signals in carrier replica table each may occupy 180 32 bit words in order to be guaranteed to cover the full 5 714 RF front end samples that occur in one PRN code period for any possible code period start time within the thirty two samples of the initial word. Thus 180 4 720 bytes could be required for each bit of each pre computed carrier replica signal that is stored in the table. The sine and cosine waves of carrier replica signals each have 2 bit representations which translates into a storage requirement of 2880 bytes for the carrier replica signals at a given Doppler shift. There are 115 Doppler shifts that may be stored in order to cover the 10 KHz to 10 KHz range with a 175 Hz grid spacing. This translates into 323 Kbytes of storage for all of the carrier replica signals . This approach avoids the need to pre compute sine waves with a prohibitively large number of possible frequencies and phase offsets and it avoids the need to compute sine waves in real time. Instead the errors created by using pre defined sine wave replicas are compensated for by post processing calculations as described below.

Note that equations 8 and 9 can be derived from equations 4 and 5 as follows. First the carrier phase of the grid signal in the arguments of the cosine and sine terms of equations 6 and 7 are added to and subtracted from the arguments of the cosine and sine terms in equations 4 and 5 . Next trigonometric identities are used to split the resulting cosine and sine terms into sums of products of cosine and sine functions. In each product one of the terms involves an argument like the arguments in the trigonometric terms in equations 6 and 7 . The other trigonometr terms are then approximated by either cos or sin . These approximations are valid because of the inequality in equation 11 and because the average of

A decrease in the carrier to noise ratio C N which characterizes the receiver s sensitivity is caused by the use of an inexact baseband mixing frequency. The worst case decrease is expressed as a function of the frequency grid spacing f and is given by

Referring now to B and A PRN codes composed of prompt PRN codes and early minus late PRN codes are either pre computed or generated in real time. Pre computing involves for each satellite computing an entire PRN code storing the PRN code appropriately for easy retrieval and referencing the PRN code possibly by means of indices that are computed based on for example the incoming RF signal data . Pre computing can be most advantageously used when the PRN code is not very long. Generating PRN codes in real time can be a more appropriate solution when the PRN codes are very long and thus would require an unacceptable amount of storage or perhaps when too many PRN codes are required for the amount of storage available or for any other reason but real time PRN code generation can entail an additional computational cost. Both pre computing and real time determination of PRN codes are described herein with respect to a bit wise parallel implementation.

Continuing to refer primarily to B and A in order to perform bit wise parallel operations software correlator stores pre computed carrier replica sign A and carrier replica magnitude B in data words. Simple representations of signal data and carrier replica signal in terms of one two or more bits are suitable for using bit wise parallelism to perform the calculations described herein. Bit wise parallel operations work with representations of the data that store successive samples in successive bits of a word. For example thirty two samples bits of the RF front end output are stored in two N 32 bit words signal sign A and signal magnitude B or simply a single 32 bit word if signal data consists of a single data bit. Carrier replica sign A and carrier replica magnitude B are stored for example in tables in separate words with each 32 bit word storing thirty two sign or magnitude bits that tabulate to thirty two successive samples of the corresponding cosine or sine wave. Similarly tables can store prompt PRN code and early minus late PRN code which are composed of prompt PRN code sign A early minus late PRN code sign A and early minus late PRN code zero mask B . The data words that comprise the bit wise parallel representations of these three signal types the original RF signal data the carrier replica signal and and the de spreading prompt PRN code and early minus late PRN code are the inputs to the calculations of software correlator .

Further continuing primarily to refer to B and A many intermediate calculated quantities and at least three types of intermediate signals are also stored in bit wise parallel format. First there are the in phase and quadrature baseband mixed signals whose 3 bit representations for the illustrative embodiment are stored as baseband mixed sign A baseband mixed high magnitude B and baseband mixed low magnitude C . The second bit wise parallel signal type is the fully mixed integrand of which there are four signals in phase and quadrature fully mixed prompt integrand and in phase and quadrature fully mixed early minus late integrand . The former are stored as 3 bit representations in the illustrative embodiment as fully mixed prompt integrand sign A fully mixed prompt integrand high magnitude B and fully mixed prompt integrand low magnitude C . The latter are stored as 3.5 bit representations in the illustrative embodiment as fully mixed early minus late integrand sign A fully mixed early minus late integrand high magnitude B fully mixed early minus late integrand low magnitude C and fully mixed early minus late integrand zero mask D . This representation is called a 3.5 bit representation because the sign high magnitude and low magnitude bits are ignored if the corresponding zero mask bit has the value zero. The third bit wise parallel signal type is a value word of which there are two types prompt integrand value words and early minus late integrand value words . Each fully mixed integrand is used to construct value words one word for each possible value that the integer integrand can take on. There are eight possible values for the integrands of the illustrative embodiment 1 2 3 6 1 2 3 and 6 for the in phase and quadrature fully mixed prompt integrands and 2 4 6 12 2 4 6 and 12 for the in phase and quadrature fully mixed early minus late integrands . Each bit wise parallel value word contains a one bit for each sample time when the integrand value equals the value of the value word but it contains a zero bit for all other sample times. The storage of raw data and intermediate results in bit wise parallel format allows the EXCLUSIVE OR operations that are involved in mixing to operate on thirty two samples at a time if microprocessor has a bit wise EXCLUSIVE OR command. Other bit wise commands are used to perform additional software correlation operations in parallel on sets of two thirty two samples.

At this point the problem of over sampling is introduced. Referring now to the problem of over sampling is illustrated with respect to bit wise parallelism as follows. There is normally more than one RF data sample per PRN code chip. The three successive 1 values at sample times tto tall occur during the same PRN code chip as do the four successive 1 values at times tthrough t. The difference in the number of samples for the two code chips arises because the PRN code chip period is not an integer multiple of the sample period. Analogously referring to where sample interval t is less than actual PRN code chip length t over sampling is indicated because the RF sampling frequency f 1 tis greater than the PRN code chipping frequency f 1 t. PRN codes for CDMA signaling are sequences of 1 and 1 values the elements of which are chips. Over the time intervals of interest a carrier replica progresses through its chips at a constant chipping rate of f 1 tchips second. The time interval tis the actual PRN code chip length . Software correlator normally receives PRN code and attempts to align it with the prompt replica version of the code prompt PRN code . It makes use of the signal s correlation with prompt PRN code and with early minus late PRN code in order to determine a chipping rate fthat tends to align prompt PRN code as desired. Conventional methods for determining fare well known in the art. Chips of early code B start and stop 0.5 tseconds before the corresponding chips of prompt PRN code and the chips of late code C start and stop 0.5 tseconds after prompt PRN code . Early minus late PRN code is the difference between early code B and late code C . Example segments of these four types of replica codes are depicted in .

Referring to A C and D software correlator receives through conventional RF front end and DAQ system signal data the raw data source of which is sampled at the rate f 1 tHz. In order to process the resulting RF signal data software correlator needs prompt PRN code and early minus late PRN code replicas sampled at the same times as raw signal . depicts sixteen sample times as vertical dash dotted lines. Referring to prompt PRN code can be represented by its prompt PRN code sign A at the sample times. The bit value one represents 1 and the bit value zero represents 1. Prompt PRN code sign A shown at the sixteen sample times starting with three 1s continuing with ten 0s and finishing with another three 1s is a 16 bit word stored as the integer 2 2 2 2 2 2 57351. Early minus late PRN code requires a 1.5 bit representation. A zero mask bit is set to zero if early minus late PRN code takes on the value zero and it is set to one if early minus late PRN code equals 2 or 2. Early minus late PRN code zero mask B at sixteen sample times shown in is equivalent to 2 2 2 12292. A 2 s sign bit is set to one if early minus late PRN code equals 2 at the sample time and it is set to zero if the code equals 2. The 2 s sign bit is irrelevant if the corresponding early minus late PRN code zero mask B bit equals zero. Early minus late PRN code sign A for sixteen sample times contains X values that indicate bits whose values are irrelevant because the corresponding early minus late PRN code zero mask B bits are zero. In an illustrative embodiment all the X values become zero thus the equivalent integer for early minus late PRN code sign A is 2 4.

Continuing to refer to an alternative to taking the prompt PRN code and early minus late PRN code from pre computed over sampled PRN code table is to generate prompt PRN code sign A early minus late PRN code sign A and early minus late PRN code zero mask B using real time over sampled PRN code generator A . Shown in are two circles and a loose arrow with a quarter circle pointer. These are the symbols for a switch and indicate the ability of the system to choose possible alternate sources of PRN code. Using the real time over sampled PRN code generator A includes a step of generating the PRN code chips in real time by conventional means. For example the GPS civilian L2 CL and CM codes are generated by a 27 bit feedback shift register see 2 R. D. Fontana et al. 2001 Sep. 11 14 2001 Salt Lake City Utah pp. 617 631 . The method further includes the steps of choosing chip values from the PRN code where the chip values correspond to a data interval that contains the samples of a data word and where the chips have a known timing relative to the data interval transforming the relative timing into a time grid index and translating the PRN code chip values and the time grid index for the data interval into the PRN code s over sampled bit wise parallel format. These latter steps can be carried out efficiently by using a table look up function. One table each for prompt PRN code sign A early minus late PRN code sign A and early minus late PRN code zero mask B can include integer values that constitute the bit wise parallel representation of the PRN code for the sample times associated with the data word in question. Indices into each 1 dimensional table are functions of a the time offset between the first PRN code chip and the first sample time of the given data word and b the bit pattern of the PRN code chips that span the sample times of the data word. The sizes of the tables are independent of the period of the PRN code that is being over sampled. The tables can be re used for multiple PRN codes in a multi channel receiver. The computation and use of the tables are discussed in more detail later.

Continuing with the description of bit wise parallelism with respect to the operations of software correlator and continuing to refer to the specially developed algorithms described herein make use of bit wise parallelism so that a single programming language statement such as a C code command can partially process up to thirty two samples at a time. Previously referred to carrier replica signal in the form of cosine and sine signals are stored as binary carrier replica sign A and carrier replica magnitude B. The format of this representation is defined in Table 2 and illustrated in which is a reconstructed carrier and carrier replica in the form of representative sine signal shown in optimal 2 bit representation that has the minimum square error. The format of Table 2 assumes that the cosine and sine signals have an amplitude of approximately 2.4. Note that other representations beyond 2 bit representation are possible. In general more bits yield a better SNR but can also require a larger number of computations for the correlation operations.

Continuing to refer to multiplication of the RF front end output representation the signal sign A and signal magnitude B of Table 1 by the sine wave representation carrier replica sign A and carrier replica magnitude B of Table 2 yields baseband mixed signals consisting of baseband mixed sign A baseband mixed high magnitude B and baseband mixed low magnitude C that can take on the values 6 3 2 1 1 2 3 and 6 as shown in Table 3. Baseband mixed high magnitude B is simply signal magnitude B and baseband mixed low magnitude C is carrier replica magnitude B. Thus these two magnitude bits are available without the need for computation. Baseband mixed sign A is the result of an EXCLUSIVE OR operation between signal sign A and carrier replica sign A. Notice how the relationship of the sign bit value with the actual sign gets reversed from that of Tables 1 and 2.

Continuing to refer to and continuing to describe the bit wise parallel algorithms the required amount of storage for tables of pre computed prompt PRN code and early minus late PRN code can be greatly reduced by making two simplifications. First the prompt PRN code is stored as prompt PRN code sign A. This representation is shown in Table 4. The early minus late PRN code on the other hand is stored in a two bit representation actually a 1.5 bit representation early minus late PRN code sign A and early minus late PRN code zero mask B as denoted in Table 5. Note that the X in the first column of Table 5 indicates that zero or one can be placed in this location without affecting the corresponding code value. The X signifies a lack of effect of the sign bit on the code value when the zero mask bit equals zero. This is why the early minus late PRN code representation is referred to as a 1.5 bit representation. This X value will affect the corresponding fully mixed early minus late integrand sign A but it will not affect any of the early minus late value words because the zero value in the corresponding zero mask location will null out the corresponding bit of all early minus late value words.

Another simplification in the pre computed over sampled PRN code table and continuing to refer to can be to ignore code Doppler shift variations. All signals in the table are assumed to have zero Doppler shift i.e. all C A codes in the table assume that circumflex over circumflex over 0.001 sec. Note that the period of 0.001 is applicable for accumulations that use the full 1023 chips of the C A code only. Any other type of code or accumulation interval may have a different period. The code phase errors due to this assumption can be eliminated by choosing a replica code from the pre computed over sampled PRN code table whose midpoint occurs at the desired midpoint time circumflex over circumflex over 2. The only other effect of this assumption can be a small correlation power loss which is no more than 0.014 dB if the magnitude of the Doppler shift is less than 10 KHz. The pre computed over sampled PRN code table should include a selection of different phases for example fourteen as measured relative to a signal sample spacing of for example 175 nsec. This translates into a code phase spacing of for example 12.5 nsec which equals a pseudo range measurement digitization level of 3.8 m or a maximum measurement error of 1.9 m. The number of phases in the pre computed over sampled PRN code table is dependent upon the design of the system and no set number of phases is required by the present invention. Referring to suppose that pre computed over sampled PRN code table stores over sampled bit wise parallel representations of chips C through C M . The table must allow for the retrieval of over sampled bit wise parallel code replicas for a range of start times of code chip C that span the entire first data sample word in the accumulation interval W . The table may contain code replicas whose different phases yield start times that span only a single sample interval of data word W which is only 1 nof the required number of start times. In this case the software correlator may apply bit shift operations to a tabulated PRN code replica from that sample interval in order to generate the over sampled bit wise parallel PRN code replica that applies when chip C starts in a different sample interval of data word W .

Continuing to refer to and further continuing to describe the bit wise parallel algorithms prompt PRN code and early minus late PRN code replicas can be mixed with the baseband mixed signals to form fully mixed prompt integrand by an EXCLUSIVE OR operation and bit re definitions. An EXCLUSIVE OR between prompt PRN code sign A and baseband mixed sign A produces fully mixed prompt integrand sign A given in Table 6. The fully mixed prompt integrand high magnitude B and fully mixed prompt integrand low magnitude C are baseband mixed high magnitude B and baseband mixed low magnitude C also given in Table 6. Note that the Table 6 representation is identical to that of Table 3 except for the inversion in the meaning of the sign bits. The number of magnitude bits is dependent upon the design of the system and no set number of magnitude bits is required by the present invention. A change in the number of magnitude bits will cause a change in the number of entries of the equivalent of Table 6 and it will affect the possible values of the integrand.

Still continuing to refer to the mixing of the early minus late PRN code with the baseband mixed signals forms fully mixed early minus late integrands . Fully mixed early minus late integrand sign A is an EXCLUSIVE OR between early minus late PRN code sign A and baseband mixed sign A. Fully mixed early minus late integrand high magnitude B and fully mixed early minus late integrand low magnitude C are as above baseband mixed high magnitude B and baseband mixed low magnitude C. Fully mixed early minus late integrand zero mask D is early minus late PRN code zero mask B. The resulting representation is given in Table 7. As in Table 5 each X entry in the table indicates that the corresponding bit can be either zero or one without affecting the corresponding integrand value.

Referring now to B A and B the method for computing in phase and quadrature accumulations for every accumulation period for example every millisecond for GPS C A code by use of bit wise parallelism includes the steps of selecting carrier replica signal according to the proximity of its frequency to the desired frequency and representing sample signal data and carrier replica signal from at least one channel as bits in signal sign A and if present signal magnitude B and carrier replica sign A and carrier replica magnitude B method step . Note that carrier replica signal is chosen so that its frequency is close to the correct signal frequency. The method also includes the step of mixing signal data to baseband by computing in phase and quadrature baseband mixed sign A and in phase and quadrature baseband mixed high and low magnitude B C method step . The method further includes the steps of selecting PRN code from pre computed over sampled PRN code table or of computing it using real time over sampled PRN code generator A representing prompt PRN code as prompt PRN code sign A and representing early minus late PRN code from as early minus late PRN code sign A and early minus late PRN code zero mask B method step . The method further includes the step of de spreading in phase and quadrature baseband mixed signal by mixing it with prompt PRN code and early minus late PRN code resulting in in phase and quadrature fully mixed prompt integrands and fully mixed early minus late integrands method step . The method further includes the step of using prompt value word logic A to compute prompt integrand value words from the in phase and quadrature fully mixed prompt integrands . The method further includes the step of using early minus late value word logic A to compute early minus late integrand value words from the fully mixed early minus late integrands method step . The method further includes the steps of summing over each prompt integrand value word and early minus late integrand value word the number of one bits or zero bits using one bits summation table or using a processor command if available method step and summing over the accumulation interval the number of one bits or zero bits in each prompt integrand value word and early minus late integrand value word to produce prompt accumulations and early minus late accumulations method step . The method further includes the step of multiplying prompt accumulations and early minus late accumulations by corresponding values A and summing the results over the value words of each signal for an entire accumulation interval to yield in phase and quadrature summed prompt accumulations and summed early minus late accumulations method step that are stored for use by acquisition techniques or tracking loops. The method further includes the step of rotating the in phase and quadrature summed prompt accumulations and summed early minus late accumulations method step to simulate a condition in which baseband mixing had been performed using cosine and sine signal replicas with the correct frequency and phase. If there are more channels to process decision step the method includes the step of repeating the previous steps beginning at method step . If there are no more channels to process decision step the method includes the step of setting parameters for the next accumulation period including storing current C A code phases epoch counters carrier phases and carrier Doppler shifts method step . If the time period to wait until the next accumulations need to be calculated has not expired decision step the method includes the step of sleeping until the expiration of the time period method step . If the time period has expired decision step the method includes the step of repeating the previous steps beginning at method step . The length of the time period depends on the nominal accumulation period. It is set to be less than this period normally between 50 to 90 of this period to reduce the possibility that accumulations are missed for any channels.

Referring again to method step calls for computing value words. This computation starts by performing bit wise parallel Boolean logic for each of the possible values in the right hand column of the prompt integrand representation in Table 6. A 32 bit prompt integrand value word is computed for each thirty two samples and each row of Table 6. The prompt integrand value word contains ones for the sample times when the actual integrand equals the corresponding value in the right hand column of Table 6 and zeros for the remaining times when the actual integrand does not equal this value. The prompt integrand value words corresponding to the possible Table 6 values are formed by method step as follows MINUSONE NOT SIGN AND NOT HIGHMAG AND NOT LOWMAG 13 MINUSTWO NOT SIGN AND NOT HIGHMAG AND LOWMAG 14 MINUSTHREE NOT SIGN AND HIGHMAG AND NOT LOWMAG 15 MINUSSIX NOT SIGN AND HIGHMAG AND LOWMAG 16 PLUSONE SIGN AND NOT HIGHMAG AND NOT LOWMAG 17 PLUSTWO SIGN AND NOT HIGHMAG AND LOWMAG 18 PLUSTHREE SIGN AND HIGHMAG AND NOT LOWMAG 19 PLUSSIX SIGN AND HIGHMAG AND LOWMAG 20 

Continuing to refer to B A and B method steps and call for operations for the fully mixed early minus late integrands that are similar to those for the fully mixed prompt integrands . Early minus late integrand value words correspond to values that are double those of the prompt integrand value words i.e. the MINUSSIX word becomes the MINUSTWELVE word. Also an additional AND operation must be performed with the zero mask bits of Table 7 in order to mask out sample times when the early and late PRN codes cancel each other. Possible formulas for the method step computation of these early minus late integrand value words are as follows MINUSTWO ZEROMASK AND NOT SIGN AND NOT HIGHMAG AND NOT LOWMAG 21 MINUSFOUR ZEROMASK AND NOT SIGN AND NOT HIGHMAG AND LOWMAG 22 MINUSSIX ZEROMASK AND NOT SIGN AND HIGHMAG AND NOT LOWMAG 23 MINUSTWELVE ZEROMASK AND NOT SIGN AND HIGHMAG AND LOWMAG 24 PLUSTWO ZEROMASK AND SIGN AND NOT HIGHMAG AND NOT LOWMAG 25 PLUSFOUR ZEROMASK AND SIGN AND NOT HIGHMAG AND LOWMAG 26 PLUSSIX ZEROMASK AND SIGN AND HIGHMAG AND NOT LOWMAG 27 PLUSTWELVE ZEROMASK AND SIGN AND HIGHMAG AND LOWMAG 28 Additional zero masking can occur in the first and last words of an accumulation interval. This is true because the start and stop times of an accumulation interval do not normally fall at the boundaries of data words. Therefore the bits in the first word that precede the accumulation interval may need to get zero masked as might the bits in the last word that come after the end of the accumulation interval.

Referring primarily to the one bits counting operations of method step form the count of the number of one bits in each of the eight value words. If there are no such counting operations in the instruction set of microprocessor the counting can be accomplished using a table look up. In the case of a table look up prompt integrand value words and early minus late integrand value words can be used as addresses in one bits summation table and one bits summation table can output the number of one values or zeros in the address. For example if the table look up operation is called BITSUM the following computations can be performed to compute one bits counts ONESCOUNT BITSUM VALUEWORD 29 where the output of the table ONESCOUNT is the number of one bits in the word VALUEWORD. This operation is repeated for each of the prompt integrand value words and early minus late integrand value words in order to accomplish method step . Selection of table width for example 16 bit or 32 bit depends on the amount of memory available and other design decisions. If the table width is smaller than the number of bits in a value word then multiple calls of the table are used in order to sum up the total number of one values in a given value word. Each call takes as input only a portion of the bits in the value word.

Continuing to refer primarily to the accumulation operations of method steps sum the one bit counts for each prompt integrand value word and for each early minus late integrand value word over the entire accumulation interval multiply each result by the value A that is associated with the value word and sum all of these scaled value accumulations to form the accumulations of equations 6 and 7 summed prompt accumulation and summed early minus late accumulation . For example the following computations can be performed to compute the in phase summed prompt accumulation in equation 6 as follows 

Continuing to refer primarily to the method of the present invention can be adapted to work with a different number of bits in the representation of the RF front end output and of the baseband mixed signals. An increase above two bits can make the logic more complex and may decrease the time savings over straight integer arithmetic. A decrease to a 1 bit representation can have the opposite effect. For example if the RF front end uses 1 bit digitization rather than 2 bit digitization while carrier replica signal retains its 2 bit digitization then the operation count can decrease by a factor of almost two for the 1 bit method which can make the logic execute about 4.2 times faster than straight integer arithmetic.

Returning to the discussion of determining PRN code and now referring again D and A the real time generation of bit wise parallel over sampled prompt PRN code sign A early minus late PRN code sign A and early minus late PRN code zero mask B can be carried out by real time over sampled PRN code generator A . The inputs to this calculation are the actual PRN code chip length t the sample interval t the nominal early to late code delay t the end time of the first code chip relative to the first sample time or put another way the time lag t from the first RF sample time to the end time of the first prompt PRN code chip and prompt code chips . The outputs are the three integers that store the prompt PRN code sign A early minus late PRN code zero mask B and early minus late PRN code sign A which are all in bit wise parallel format.

Referring again to table look ups can be used to translate a PRN code and its timing information to bit wise parallel representations of its over sampled prompt and early minus late versions. The required table look ups can be simplified by recognizing that the following parameters are substantially constant for the purposes of this calculation sampling interval t the nominal chip length t the early minus late code delay t used by software correlator and the maximum number of chips that span a data word of microprocessor . The difference between the actual chipping rate f reciprocal of t and the nominal chipping rate f reciprocal of t that is used for the above simplification can be accommodated by correcting time lag t for the average effects of Doppler shift a procedure discussed later. Using the simplification each look up table has two variable inputs the actual set of prompt code chips and time lag t. A table look up procedure for each signal component yields a single integer result for prompt PRN code sign A another single integer result for early minus late PRN code zero mask B and yet another single integer result for early minus late PRN code sign A .

Referring now to to create an electronically processable table the continuous range of tvalues can be replaced with a discrete grid having m equally spaced points per sample interval t. The integer m is chosen to be large enough so that the granularity t m gives sufficient PRN code timing resolution. In GPS applications m is usually chosen to be large enough so that c t m is on the order of several meters or less where c is the speed of light but reasonably sized because the table sizes are usually proportional to m. Given a choice of m the grid of relative end times of the first prompt code period is 

The size for each table can be a function of the maximum number of code chips that may fall within a data word s sample range. Given t bit information for the following number of code chips is required in order for the prompt PRN code early code B and late code C to be fully specified at all of the data word s sample times 

Continuing to refer to each table can be stored as an array with a single index. The first 2entries correspond to the 2different possible chip sequences that can occur at t t the next 2entries correspond to t t and so forth. The tabulated bit sequences for a fixed tare ordered by interpreting the sequence as a binary index counter with the first chip being the most significant counter bit and the Lchip being the least significant bit. The integer elements of the table can be the x i table elements with corresponding code time offset t and corresponding bit sequence of the chips. The array index of a given x i table element can be computed based on its code time offset tgrid index k and its corresponding bit sequence . The corresponding bit sequence associated with the array index consists of the chip values C C C . . . C L . The C j chip values are either zero or one with zero representing a 1 PRN code value and one representing a 1 PRN code value and they are listed in order of increasing time. The corresponding array index of the x i table element is 

Continuing to refer to the following computations generate the x i table elements entries of the three tables. Given i the corresponding code time offset grid index k i is computed from equation 37a and is used to generate three sequences of chip indices 

The table layout in is only an illustrative embodiment of how one can construct a table that can be used to translate PRN code chip values and timing information into data words that store the bit wise parallel representations of the over sampled prompt PRN code sign A early minus late PRN code zero mask B and early minus late PRN code sign A . Other table layouts are also possible. Possible illustrative index calculations are described below for indexing into the tables for PRN code retrieval during accumulation calculations If another table layout is used then different indexing calculations might be needed. Furthermore different indexing calculations can be used even for the illustrative table layout shown in .

Referring now primarily to accumulation calculations as have been previously outlined herein and elsewhere work with a fixed sequence of code chips. The prompt version of this sequence has a specified timing relationship to the incoming RF signal data . This relationship can be pre determined by a code search algorithm if software receiver is in acquisition mode or by its delay locked loop if it is in tracking mode. Software correlator can calculate an accumulation using prompt code chips C through C M . The timing of the prompt replicas of prompt code chips can define the accumulation interval. The chip sequence starts at start lag tseconds past the first sample of data word W it chips at the constant chipping rate f 1 t and it ends at end time which occurs t M tseconds after the first sample of data word W . The end of the Mprompt code chip can occur during data word W which implies that

These sample counts can be used to develop additional zero mask words that software correlator uses to properly process the first and last data words during its bit wise parallel accumulation calculations as defined in 12 1 B. M. Ledvina et al. Jan. 22 24 2003 Anaheim Calif. and B. M. Ledvina et al. to appear in the 2003 both incorporated herein in their entirety by reference. Note that equations 41 42b and all related timing considerations herein use the following code chip start stop convention a sample is correlated with a particular code chip if the start time of the code chip coincides exactly with the sample time but it will not get correlated with that chip if its sample time coincides exactly with the end time of the code chip.

Continuing to refer to efficiently determining the correct x i X i and x i bit wise parallel code representations for the N data words W through data word W involves making an efficient determination of the correct table index ithat corresponds to data word W1 . . . N where the table index iis a function of start lag t actual PRN code chip length t v and prompt code chips C C C . . . C M 1 . The chip value C is needed in order to specify the late code C at the initial few samples of the accumulation and the chip value C M 1 is needed to specify the early code B at the final few samples. Additional constants that can be used in order to determine the iindices are t n m L k k and nominal chip length t which has been used to generate the three x i tables.

The first step of the index calculation procedure pre computes and stores a table of candidate integers for the final summation term that appears on the right hand side of equation 36 . This table takes the form 

In many cases prompt code chips C C C . . . can be generated as the output of a feedback shift register or a system of such registers. For example the new GPS civilian L2 signals can be generated this way. In this case each iteration of equation 44b can be interleaved with an iteration of the shift register calculations. Shift register generation of PRN codes is well known in the art.

An alternative to building up the previously described table is to calculate the index component only for one data word at a time. Suppose that iis the correct index component for data word W and that is the auxiliary index that would have been used to determine ifrom the i table had the table existed. In order to calculate ifor data word W is computed procedure defined herein feedback shift register calculations that generate C C 1 C 2 . . . C 1 are iterated and the resulting chip values are used to perform iterations of equations 44b or 44c .

Determination of the correct index into the x i x i and x i tables for data word Wcan be reduced to the determination of two quantities. One is the time offset index kthat causes tfrom equation 32 to match the true time offset for data word Was closely as possible. The other quantity is the auxiliary table index . It constitutes an index for the sequence of actual code chips that are associated with data word W. Given these two quantities the correct index for the three x i tables is 1 2 for v 1 2 3 . . . N 45 

The auxiliary index is determined by the position of the Wdata word relative to the PRN code chip sequence. Once that position has been ascertained the index kcan be calculated from the position relative to the Wsamples of the L code chips that are associated with the index .

A time integer can keep track of the number of fine scale time units in a given interval. The fine scale time unit is a small fraction of the sample interval t 

Equation 48d picks bto equal a power of two so that the integer division by bin equation 49 can be accomplished using a rightward bit shift operation. The round operation in equation 49 can be accomplished as part of the division if one first adds sign a b 2 to the quantity k k abefore performing the rightward bit shift that constitutes division by b. This approach can give the correct kbecause the signs of k k and bare both positive and because the rightward bit shift has the effect of rounding the signed division result towards zero. An alternate implementation of the round function could be used for applications that do not guarantee k k. Such applications are normally associated with L 2 PRN code chips per data word.

The round operation in equation 55 can be implemented by adding m 2 to m k k before the rightward bit shift that constitutes division by m. The result of the division will be the correct value of kfor any sign of k k if the computer works with 2 s compliment notation for signed integers and if the rightward bit shift fills in from the left with the 2 s compliment sign bit i.e. with the left most bit.

Given kfrom equation 55 and from equation 54b one can use equation 45 to compute i. This value in turn can be used to index into the tables to determine the Prompt PRN code sign A x the early minus late PRN code zero mask B x and the early minus late PRN code sign A x that correspond to data word W x for v 1 2 3 . . . N 56a for v 1 2 3 . . . N 56b for v 1 2 3 . . . N 56c 

The conditionals in equations 54a and 54b can be reduced to a single conditional per data word during normal operation to improve efficiency. This can be done because the sign of kin equation 53a is fixed for a given accumulation interval. Normally the sign of kdoes not vary from accumulation interval to accumulation interval or from channel to channel for a given receiver because the only variable quantity that affects kis actual chip length t which normally does not vary significantly. If kk. The decision about which condition to check can be made at the beginning of the accumulation because kis calculated prior to execution of the iteration in equations 53a 56c .

When using a processor that creates instruction pipelines if statements can disrupt the pipeline. In this case equations 54a and 54b can be replaced with the following computations 

Summarizing real time over sampled PRN code generator A and referring now to to compute prompt PRN code and early minus late PRN code for an entire accumulation interval the method includes the steps of iterating equations 44a 44c method step to construct the table of i values. The method further includes the step of computing the auxiliary constants method step in equations 48a 48e and 50a 50e . The method further includes the step of initializing kand method step by evaluating equations 51 a 52b . The method further includes the step of iterating equations 53a 53b 57a 57c 49 55 and 45 method step to compute for each iteration k k k and i. The method further includes the step of iterating equations 56a 56c method step to compute for each iteration x x and x.

As mentioned already it may prove efficient to interleave the equations 44a c iterations and the accompanying shift register iterations between the iterations that compute kthrough xIn this scenario v can be computed from equation 57c . Afterwards the shift register iterations that generate code chips C 1 though C 1 can be performed and these chip values can be used to iterate equations 44a c from to in order to determine i from i .

The software correlator of the present invention can advantageously be easily modified to work with signals at different frequencies new PRN codes or even signals for different types of devices. Thus the same hardware could use the software correlator to implement such devices as a GPS receiver a cell phone or both. To allow for new codes new frequencies and new types of functionality small changes can be made in the software correlator or different versions of the software correlator can be run on the same processor. The changes involve using a different baseband mixing frequency and a different PRN code in the correlation and perhaps changes that would provide the new signals of interest to the software correlator . In order for the present invention to work with signals at different frequencies new PRN codes or signals for different devices two fundamental changes need to be made. First the baseband mixing frequency must be tailored to that of the signal data which also involves pre computing and storing sine and cosine tables at this new frequency. Second new pre computed over sampled PRN code tables must be constructed. The size of the new tables should match the over sampled accumulation period or at least one over sampled period of the PRN code. As an alternative to generating new pre computed over sampled PRN code tables the new PRN codes can be generated in real time by over sampled PRN code generator A . Also the system and method of the present invention could be implemented within systems such as GLONASS receivers cell phones and cell base stations pagers wireless Ethernet e.g. 802.11 standards Bluetooth Blackberry wireless internet devices and satellite radio phones e.g. INMARSAT . In fact the system and method of the present invention are applicable to any sort of telecommunication system device that uses spread spectrum code division multiple access CDMA pseudo random number codes for the transmission of information either wired or wireless.

Referring now to navigation calculations require measured values of the PRN code phase carrier phase and carrier frequency. The measurements for all tracked satellites must be taken at exactly the same time. A time interval counter TIC function provides a periodic timing scheme to synchronize these measurements at time t. At time t the TIC function latches all of the PRN code phase carrier phases and carrier frequencies along with the code epoch counters and software correlator makes these available to application specific code for example GPS receiver software. GPS receiver software uses the code phase and epoch counters to compute the pseudo range to each satellite. Software correlator keeps track of the code and carrier phase of each signal as determined by the code chipping rate and the carrier Doppler shift inputs. The quantity circumflex over f the estimated code chipping rate of software receiver for satellite j during its kPRN code period can be determined either by an acquisition search procedure or if tracking by a delay locked loop. Likewise circumflex over the associated carrier Doppler shift can be defined by an acquisition procedure or if tracking has commenced by a phase locked loop or a frequency locked loop. These determinations are made by application specific code . Software correlator can use these two frequencies to update quantities that keep track of its code and carrier phases according to the formulas 

Software correlator can keep a running track of these quantities and can initialize these iterations as part of the signal acquisition calculations that it carries out in conjunction with application specific code FIG. . The quantities circumflex over and circumflex over are either sent to software correlator by application specific code or they are initialized arbitrarily by software correlator and application specific code executes feedback control of circumflex over f and circumflex over to force the sequences defined by equations 58 and 59 to converge to appropriate values. Information about the previously described conventional method can be found in Dierendonck.

The TIC time t can occur at for example the millisecond boundaries of the receiver clock. At each time t the PRN code phase of each signal is computed in the following manner 

The carrier phase calculation at time t is similar to the PRN code phase calculation circumflex over circumflex over circumflex over Doppjk circumflex over 61 where circumflex over is the carrier phase at time t. The Doppler shift that gets returned at time t is circumflex over .

With respect to the performance of the system and method of the present invention a sample screen shot from the illustrative embodiment of the present invention is provided in Table 8. This table illustratively shows the tracking of nine channels. The roof mounted L1 antenna of the illustrative embodiment can have a pre amp with 26 dB of gain. The software correlator of the present invention can provide positional accuracy on the order of 10 15 meters when working in conjunction with application specific software .

Two comparison tests illustrate the performance of the system and method of the present invention. In the first test a first configuration includes a MITEL GP2021 hardware correlator but is in all other ways identical to a second configuration that includes the software correlator of the present invention. The two configurations differ in SNR by less that 1 dB and in navigation solutions by no more than 5 10 meters. In the second test timing studies using the system of the present invention show that processing six channels uses only about 20 of the processor s capacity while Akos 2001a report a real time software GPS receiver that would require 100 of the capacity a 1.73 GHz microprocessor to implement a 6 channel GPS receiver when processing data from an RF front end with a sampling frequency of 5.714 MHz.

Referring now to among other indicators that could assess the accuracy of the PRN code generated by real time over sampled PRN code generator A which includes prompt PRN code sign A early minus late PRN code sign A and early minus late PRN code zero mask B is the low distortion of the generated codes versus the true codes. generated for prompt code comparisons shows juxtaposed plots of the autocorrelation function of the sampled true code and the cross correlation function between the sampled true code and the sampled code as generated from the new xtable. shows a similar comparison for early minus late PRN code . In either case the nominal chipping frequency is f 1 t 1.023 Mfz the sampling frequency is f 1 t 12.199 MHz and the code timing resolution of the table is m 12 i.e. 1 12of a sample. This resolution translates into approximately 1 143of a code chip. The actual chipping rate differs from the nominal by f f 1.5 Hz. This Doppler shift of the code chipping rate corresponds to a significant non zero range rate between the receiver and the transmitter 438 m sec. The correlations are accumulated over 10230 code chips and the code is a time multiplexed version of a pair of the new GPS civilian L2 CL and CM codes. The data word indexing calculations for this example use a code chip start time resolution of t 10 i.e. m 10.

It is obvious from that prompt PRN code and early minus late PRN code distortion is very small. The correlations produced using the new tables are virtually identical to those produced from the exact code. The low distortion of the new approach is best characterized by two parameters the amount by which the correlation peak of the prompt PRN code sign A droops below one and the offset of the zero crossing time of the early minus late PRN code . The former metric characterizes the power loss of the new approach and the latter metric characterizes the net timing error. The droop of the prompt peak is only 0.3 of the nominal amplitude which translates into a 0.03 dB loss. The timing distortion of the new code is less than 4 10code chips. This distortion is very small it translates into about 0.1 m of GPS range measurement error.

It may seem paradoxical that the code timing error is only 4 10code chips when the code timing granularity of the x i tables is t m t 7 10code chips. The resolution of this paradox lies in the averaging effect of the accumulations. The length of a code chip equals 143.099269 code offset time grid intervals for the example shown in . The non integer nature of this number causes the code offset errors of the x i tables to get dithered as the accumulation works its way through successive data words. This dithering tends to average out the table granularity errors and this averaging can reduce the net timing error by an order of magnitude or more as shown in .

Although the invention has been described with respect to various embodiments it should be realized this invention is also capable of a wide variety of further and other embodiments.

