---

title: Annotation processor discovery
abstract: Methods for discovering and accessing annotation processors are provided. The method initiates with identifying an annotation present in a source file and identifying factories available for processing annotations. The method includes determining annotations supported by each of the available factories. Then, one of the available factories is assigned to process the annotation based on the annotation present in the source file being supported by the one of the available factories. A computer readable medium is also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07565364&OS=07565364&RS=07565364
owner: Sun Microsystems, Inc.
number: 07565364
owner_city: Santa Clara
owner_country: US
publication_date: 20050524
---
End developers face the tedious task of having to manually maintain consistency among multiple sets of files. The end developers must maintain the consistency of source code that is unique and original and the code that is implied by the unique and original source code. Annotations are pieces of metadata which can be associated with program elements such as classes fields and methods. An intended use of annotations involves having annotations in a base file hold information that is used to generate new derived files. These new derived files must be logically consistent with the base file and its annotations. The end developer must maintain the consistency for each set of code to ease development the generation of the derived files should be automated.

One attempt to provide assistance to end developers could be through the use of the Javadoc program. Javadoc is a program used to create the Hyper Text Markup Language HTML format JAVA API documentation. It is distributed as part of the JAVA SDK and its output stage is designed to be extensible through Doclet creation. The Doclet API provides the infrastructure to access all aspects of a JAVA source code file that has been parsed by Javadoc. By using the Doclet API a user can walk through a JAVA class description access custom Javadoc tags and write output to a file. However the Javadoc program is limited to running a single Doclet and no properties of the Doclet are queried to determine if the Doclet should be run. Therefore it is impractical to automatically find and run a doclet appropriate to the annotations present on the original source code. Accordingly the Javadoc program is not a viable solution to the end developers to alleviate some of the above mentioned tedium.

In light of the foregoing it is desirable to implement a scheme for alleviating the burden requiring end developers to maintain consistency of multiple sets of files through a tool that provides the infrastructure to allow third parties to generate implied code.

Embodiments of the present invention provide a scheme for discovering annotation processors based on the analysis of partially compiled source files. The present invention can be implemented in numerous ways including as a process a tool a system or a method. Several embodiments of the present invention are described below.

In one embodiment a method for accessing annotation processors is provided. The method initiates with identifying an annotation present in a source file and identifying factories available for processing annotations. The method includes determining annotations supported by each of the available factories. Then one of the available factories is assigned to process the annotation based on the annotation present in the source file being supported by the one of the available factories.

In another embodiment a computer readable medium having program instructions for providing annotation processors is provided. The computer readable medium includes program instructions for identifying an annotation present in a source file and program instructions for identifying factories available for processing annotations. Program instructions for determining annotations supported by each of the available factories are included. Program instructions for assigning one of the available factories to process the annotation based on the annotation present in the source file being supported by the one of the available factories are also provided.

In yet another embodiment an annotation processing tool for identifying annotation processors based on annotations present in a source file is provided. The annotation processing tool discovers annotation processors according to the following method operations. The annotation processing tool receives the source file or files. The source file s are analyzed to identify an annotation present in the source file s . The annotation processing tool searches for available factories which may occur contemporaneously with analyzing the source file s . Supported annotations are extracted for each of the available factories and each of the annotations present in the source file s are matched with one of the factories wherein the factory matched with the annotation is configured to support the annotation.

Other aspects of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the invention.

An invention is described for a tool and systematic method assisting a developer in the generation of sets of logically consistent files. The embodiments described below describe an annotation processing tool discovery mechanism that allows multiple independent annotation processor factories to run independently. It will be obvious however to one skilled in the art that the present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure the present invention.

The annotation processing tool discussed herein finds and executes annotation processors based on the annotations present in the set of specified source files being examined. The annotation processors use a set of reflective application programming interfaces API and supporting infrastructure to perform the processing of program annotations. The annotation processing tool reflective APIs provide a build time source based read only view of program structure. The annotation processing tool runs annotation processors which in turn can produce new source files having further annotations. In addition the annotation processing tool can cause compilation of both original and newly generated source files thereby easing the burden of the end developers during the development cycle. Through the annotation processing tool the annotations present on the source files being operated on are determined. Then the annotation processing tool looks for annotation processor factories that have been written. Annotation processor factories or factories as used herein refer to a factory for creating annotation processors. Each factory is responsible for creating processors for one or more annotation types. An annotation processor is plug in code that performs some computation based on the annotation perhaps including the generation of derived source files. Each annotation processor is created to process annotations of a particular annotation type or set of annotation types. The annotation processor may use its environment to find the program elements with annotations of those types and may freely examine any other program elements in the course of its processing. An annotation processor is constructed by a factory which provides it with an environment that encapsulates the state it needs.

The annotation processing tool queries the factories as to what annotations they process. In return to this query the factory provides the annotations recognized by the factory or by any of the processors the factory may create. If there are no options recognized by the factory then an empty set is returned. Then the annotation processing tool requests a factory to provide an annotation processor if the factory processes an annotation present in the source files being operated on. The annotation processors are then run and if the annotation processors generate new source files these files are fed back into the annotation processing tool. The annotation processing tool will then repeat this process until no new source files are generated.

Through factory lists of it is possible to determine which annotations each factory is capable of supporting. In one embodiment the factory communicates the annotations supported to the tool through a supportedAnnotationTypes method which returns the names of the annotation types supported by the factory. Thus by matching the factories supported with the annotations identified in the source files the proper annotation processors may be obtained for each of the annotations in the source files. As used herein the annotation processor represents a plug in code that completes the functionality based on the annotation. For example one annotation processor may create XML file while another may create HTML file . It should be appreciated that an annotation processor may create a new source file that itself contains annotations. These additional source files with annotations are fed back into the annotation processing tool in order to identify a factory and an annotation processor capable of supporting the annotation. It should be appreciated that each factory is capable of creating one or more annotation processors and the tool directs factories to create annotation processors for particular declarations.

When the tool is searching for processor factories it should be appreciated that in one embodiment an algorithm for finding default implementations for system services may be used. One exemplary algorithm is the sun.misc.Service algorithm available from the assignee. In essence this algorithm looks inside a .jar file to find a service associated with a particular interface. In another embodiment the name of the factory or the path to look on may be specified. For example the name of the factory may be given on the command line.

If annotation did not find a match in factory annotation would then be checked against factory and so on. Thus the annotations are compared against each of the factories in a determined order for each of the factories. This determined order may be used to resolve conflicts as discussed below. It should be appreciated that in one exemplary embodiment an element of the result may be the canonical fully qualified name of a supported annotation type. Alternately the element may be of the form name. representing the set of all annotation types with canonical names beginning with name. Finally by itself represents the set of all annotation types. In another embodiment each of the annotations from list is represented by the string which is then compared against a set of names that each factory supports wherein the set of names that each factory supports is depicted as a string also. Once a match is found a processor is assigned to that annotation. This assignment may be achieved through the getProcessorFor method which returns an annotation processor for a set of annotation types. The set will be empty if the factory supports and the specified type declarations have no annotations. It should be noted that the set of annotation types may be empty for other reasons such as giving the factory an opportunity to register a listener. An AnnotationProcessorFactory must gracefully handle an empty set of annotations. One exemplary appropriate response to an empty set will often be returning an annotation processor that does nothing at all a NO OP annotation processor .

Still referring to the output from operation is input into decision operation where it is determined if another factory is available. If another factory is not found then the method advances to operation where the individual annotation processors are invoked. In one embodiment the annotation processor may be plug in code that completes the functionality based on the annotation. As described with reference to the plug in code may generate an XML or HTML document. If another factory is found in operation then the method advances to operation where the annotations supported by the factory are identified. The method then proceeds to operation where the factory is matched with the relevant annotations not yet claimed. In one embodiment a list of annotations generated from operation is compared against each of the supported annotations for each factory as described above with reference to . In operation the matched annotations from operation are claimed. In decision operation it is determined whether unclaimed annotations exist. If there exists unclaimed annotations then the method returns to operation and repeats as described above. If there are not any unclaimed annotations then the method moves to operation where the individual annotation processors are invoked.

The method of then advances to decision operation where it is determined if new source files have been created. If new source files have been generated then the method proceeds to operation where the additional annotations are located. It should be appreciated that when the individual annotation processors are invoked in operation additional source files may be generated from this invocation. These additional source files may contain additional annotations. If there are additional annotations then these additional annotations are fed back to operation where the annotations are located and proceed as described above. If it is determined that no new source files have been created in operation the method terminates. The method also terminates if the list of factories is exhausted as discussed above. It should be appreciated that as long as there are unclaimed annotations and more factories the tool will continue to ask the factories for processors.

Presented below is exemplary psuedo code for the annotation processing tool discovery process discussed herein.

In summary the above described embodiments provide a tool to help alleviate the end developer from manually maintaining consistency for multiple sets of code. This is achieved through an annotation processing tool that parses through source files to determine the annotations present in the source file and then finds available factories capable of providing annotation processors that support the annotations. In one embodiment conflicts are resolved through the determined order in which the factories are queried. For example if a newer version of an annotation processor for a specific annotation is available the user of the annotation processing tool will list the factory having that newer version of the processor before the factory having the older version so that the newer version processor will assigned. In this sense the embodiments described above also act as a gatekeeper. It should be noted that the tool is efficient in that processors that cannot support the annotations in the source files are not invoked.

Although the present invention is described based on the JAVA programming language other programming languages may be used to implement the embodiments of the present invention such as other object oriented programming languages. Object oriented programming is a method of creating computer programs by combining certain fundamental building blocks and creating relationships among and between the building blocks. The building blocks in object oriented programming systems are called objects. An object is a programming unit that groups together a data structure instance variables and the operations methods that can use or affect that data. Thus an object consists of data and one or more operations or procedures that can be performed on that data. The joining of data and operations into a unitary building block is called encapsulation. 

An object can be instructed to perform one of its methods when it receives a message. A message is a command or instruction to the object to execute a certain method. It consists of a method selection name and a plurality of arguments that are sent to an object. A message tells the receiving object what operations to perform.

One advantage of object oriented programming is the way in which methods are invoked. When a message is sent to an object it is not necessary for the message to instruct the object how to perform a certain method. It is only necessary to request that the object execute the method. This greatly simplifies program development.

Object oriented programming languages are predominantly based on a class scheme. A class defines a type of object that typically includes both instance variables and methods for the class. An object class is used to create a particular instance of an object. An instance of an object class includes the variables and methods defined for the class. Multiple instances of the same class can be created from an object class. Each instance that is created from the object class is said to be of the same type or class.

A hierarchy of classes can be defined such that an object class definition has one or more subclasses. A subclass inherits its parent s and grandparent s etc. definition. Each subclass in the hierarchy may add to or modify the behavior specified by its parent class.

To illustrate an employee object class can include name and salary instance variables and a set salary method. Instances of the employee object class can be created or instantiated for each employee in an organization. Each object instance is said to be of type employee. Each employee object instance includes the name and salary instance variables and the set salary method. The values associated with the name and salary variables in each employee object instance contain the name and salary of an employee in the organization. A message can be sent to an employee s employee object instance to invoke the set salary method to modify the employee s salary i.e. the value associated with the salary variable in the employee s employee object .

An object is a generic term that is used in the object oriented programming environment to refer to a module that contains related code and data. A software application can be written using an object oriented programming language whereby the program s functionality is implemented using objects. Examples of object oriented programming languages include C as well as the JAVA programming language.

Furthermore the invention may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributing computing environments where tasks are performed by remote processing devices that are linked through a network.

With the above embodiments in mind it should be understood that the invention may employ various computer implemented operations involving data stored in computer systems. These operations include operations requiring physical manipulation of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. Further the manipulations performed are often referred to in terms such as producing identifying determining or comparing.

Embodiments of the present invention can be processed on a single computer or using multiple computers or computer components which are interconnected. A computer as used herein shall include a standalone computer system having its own processor its own memory and its own storage or a distributed computing system which provides computer resources to a networked terminal. In some distributed computing systems users of a computer system may actually be accessing component parts that are shared among a number of users. The users can therefore access a virtual computer over a network which will appear to the user as a single computer customized and dedicated for a single user.

The above described invention may be practiced with other computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The invention may also be practiced in distributing computing environments where tasks are performed by remote processing devices that are linked through a communications network.

The invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which thereafter can be read by a computer system. The computer readable medium also includes an electromagnetic carrier wave in which the computer code is embodied. Examples of the computer readable medium include hard drives network attached storage NAS read only memory random access memory CD ROMs CD Rs CD RWs magnetic tapes and other optical and non optical data storage devices. The computer readable medium can also be distributed over a network coupled computer systems so that the computer readable code is stored and executed in a distributed fashion.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims. In the claims elements and or steps do not imply any particular order of operation unless explicitly stated in the claims.

