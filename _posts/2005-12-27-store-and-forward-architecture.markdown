---

title: Store and forward architecture
abstract: A store and forward (S&F) architecture is provided that supports multiple applications within an extensible network to direct information of various formats to any of multiple destinations. In the presently preferred embodiment of the invention, Java applications running on a client send non-priority data to any server on the application network or, alternatively, anywhere on a global telecommunications network such as the Internet, at some time in the future. In the preferred embodiment, S&F allows a client application to send usage statistics to a database on the application network. It also enables T-commerce purchases to be made by the user, where the purchase and other relevant information is sent to a destination web server as if the purchase had taken place on the web via a full web browser on an Internet-connected PC.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07577703&OS=07577703&RS=07577703
owner: TVWorks, LLC
number: 07577703
owner_city: Philadelphia
owner_country: US
publication_date: 20051227
---
This application is a continuation of U.S. patent application Ser. No. 10 142 553 filed May 9 2002 now abandoned.

The invention generally relates to communications systems. More particularly the invention generally relates to store and forward architecture.

The term store and forward architecture pertains to communications systems in which messages are received at intermediate routing points and recorded i.e. stored and then transmitted i.e. forwarded to the next routing point or to the ultimate recipient. Such systems are commonly used in the cable and satellite television industry. For example DirecTV operates a satellite television system that offers such services as Pay Per View. In Pay Per View mode a subscriber to DirecTV selects a program to be purchased and viewed. The subscriber typically has a set top box e.g. a satellite receiver in the case of DirecTV that contains information about the subscriber s privileges and if the subscriber is authorized to purchase Pay Per View broadcasts the set top box decodes the program selected by the subscriber for viewing when it is broadcast e.g. via the DirecTV satellite . The set top box captures information with regard to the purchase i.e. it stores purchase information for billing purposes . At an appropriate time e.g. during a regularly scheduled upstream communication from the set top box to DirecTV such as a telephone call the set top box sends this purchase information to the Pay Per View service i.e. it forwards this stored information to DirecTV to allow the subscriber s account to be billed for their purchase of the program which they selected and viewed .

While such systems provide an effective approach to a dedicated application e.g. Pay Per View services they are not useful or readily configurable for execution of multiple applications e.g. Pay Per View and messaging and shopping . Further such known systems operate within the confines of a well defined network architecture e.g. the Pay Per View server and associated network elements . Thus they are not easily reconfigured to provide disparate services over an extended or extensible network. They cannot discern whether one destination within the network is more appropriate than another because they are set to communicate with a specified destination for a dedicated purpose. They are therefore not agile at routing information among multiple destinations. Finally such known systems operate within specified parameters that treat all communications in a similar fashion because all communications relate to the same thing e.g. Pay Per View . Thus there is no notion of scheduling events such as upward communication based upon the nature of information to be communicated nor are different information formats or protocols handled well within such known systems.

It would be advantageous to provide a store and forward system that supported multiple applications within an extensible network to direct information of various formats to any of multiple destinations.

Exemplary embodiments include methods and systems for a store and forward S F architecture that supports multiple applications within an extensible network to direct information of various formats to any of multiple destinations. In one embodiment of the invention Java applications running on a client send non priority data to any server on the application network or alternatively anywhere on a global telecommunications network e.g. the Internet at some time in the future.

One embodiment is a method for an S F system that allows a client application to send usage statistics to a database on the application network. It also enables television based commerce T commerce purchases of products via interaction with the T.V. to be made by the user where the purchase and other relevant information is sent to a destination web server as if the purchase had taken place on the web via a full web browser on an Internet connected personal computer PC .

One exemplary embodiment is an S F system including client side code in a micro Java virtual machine a Java byte code execution engine i.e. a user space virtual machine UVM and a server side proxy server process communications networks and a server side Application server process. One communications network transports information from the client to the S F proxy e.g. a real time two way radio frequency RF network . Another communications network transports information from the S F proxy to the Application Server process e.g. an Internet protocol IP network .

Exemplary embodiments of the invention provide a store and forward S F system and methods to support multiple applications within an extensible network to direct information of various formats to any of multiple destinations. In one embodiment Java applications running on a client send non priority data to any server on the application network or alternatively anywhere on a global telecommunications network such as the Internet at some time in the future. The S F system has many applications including collecting statistics and T commerce.

In one embodiment the S F system allows a client application to send usage statistics to a database on the application network. It also enables T commerce purchases to be made by the user where the purchase and other relevant information is sent to a destination web server as if the purchase had taken place on the web via a full web browser on an Internet connected PC. This embodiment includes two distinct parts client side code in the UVM and a server side proxy server process.

In this exemplary embodiment the client application is a Java applet running on the client . The client application uses the services provided by the stats API and the S F API to send statistics or application specific data to the application server .

In this exemplary embodiment the stats API is middleware that resides on the client . It facilitates the gathering of user events from client applications on different clients . For example when a user starts an application from the main navigation screen NavShell the stats API records the time and the application that was started. The stats API then uses the S F API to send the statistics data to the S F proxy and ultimately to an application server to collect usage statistics.

In this exemplary embodiment the stats API provides to the S F API the IP address and port number of the application server to which the statistics data is sent to the S F API . In one embodiment the client software can be configured with default values for the application server .

In one embodiment each client can be configured to send statistics without identifying the sender. This allows statistics to be collected anonymously which protects individual subscribers privacy. In addition the client can be configured with the amount of memory to use for storing statistics. Configuration can also specify that statistics are sent after a fixed period of time or after a certain amount of data has been collected.

In one embodiment the S F API is used by the stats API but the S F API can also be used by the client application directly. The S F API allows the user to specify several attributes that affect how when and where the data is sent. The user of the S F API is required to provide the IP address and port number of the application server that receives the data. The user also provides the transmission protocol that the S F proxy uses to send the data to the application server . Internet protocols are supported e.g. UDP transmission control protocol TCP and hypertext transfer protocol HTTP . When the S F API receives a request to send the data and all optional and required parameters are passed to the UVM native S F layer .

In one embodiment the S F API allows the user to specify when the initial attempt to send the data occurs how long this transaction has to complete and how many times to retry sending the data to the S F proxy .

In one embodiment when the UVM native S F layer receives data to send it formats a message that contains the address of the application server as well as the data. For more information about the structure of the message see .

In one embodiment the UVM native S F layer stores data in non volatile read only memory NVRAM to ensure that the data will be saved if the power is lost. In one embodiment the S F proxy can be configured to not send S F data during certain times of the day called blackout periods. These blackout periods are used when the client is being polled to retrieve PPV purchase information. Any additional traffic during these times would affect the reliability of retrieving this information. Alternatively data can be sent from the client to the S F proxy and stored in a database.

One exemplary embodiment is a scheduling algorithm that includes transaction lifetime initial send delay and the blackout schedule. In order to avoid having all the clients on a network attempt to send at the same time which would result in severe data loss a random element is also added to the scheduling algorithm.

In one embodiment each client is also configured with the amount of memory to use for S F data the maximum number of messages to store before sending and the IP address and port of the S F proxy to send to.

The operating system provides access for sending and receiving data over the RF Distribution Network .

In one embodiment the RF Distribution Network is a two way real time RF network. Data delivery over this network is unreliable. One exemplary embodiment of the S F system implements additional levels of reliability. The S F API allows a caller to determine which level of reliability is required.

In one embodiment the S F proxy is a server side process that facilitates upstream communication for the client via an NC1500 which is an upstream communications router manufactured by Motorola . It is specifically used for delivering messages sent by clients via the RF distribution network to a headend communications network not shown . When user event data is received by the S F proxy the S F proxy tries to deliver the data to the application server specified in the data via UDP TCP or HTTP as specified in the data. The S F proxy can send data to any of a number of application servers that are reachable via the IP network . The S F proxy sends data to the application server across the IP network . The S F proxy and the application server can communicate via any standard Internet Protocols such as UDP TCP or HTTP.

In one embodiment the application server is an entity connected to the IP network that can receive data from the client application via at least one of UDP TCP and HTTP. The application server is responsible for parsing and processing the data sent by the client application . The S F proxy can be used to communicate to any application server via the UDP TCP IP or HTTP protocols.

In one embodiment the S F API is used by the client application to send raw data to a third party server using UDP TCP or HTTP. In one embodiment the S F API interfaces with the UVM native S F layer which is part of the UVM. In one embodiment the UVM native S F layer stores data either in dynamic RAM or in non volatile memory until it is received by the S F proxy . One embodiment is a scheduling algorithm that takes into account blackout periods to determine when to send i.e. forward data to the S F proxy . The scheduling algorithm attempts to minimize data loss in the upstream direction by sharing the upstream communications resource across all clients so as not to overload the upstream channel. One embodiment includes formatting data according to an S F protocol.

One exemplary embodiment is a store and forward client proxy protocol that allows for varying levels of reliability which is achieved through the use of messages passed from the client to the S F proxy and from the S F proxy to the client . The client can specify the level of messaging required by setting flags in each request message to the S F proxy .

In one embodiment there are three flags that can be set ACK RESULT and DONE. They can be set individually or in combination but some combinations are invalid. Other flags may be provided as well in alternative embodiments of the invention. The first flag ACK tells the S F proxy whether or not to send the client an acknowledgement when it has received the client s request. The purpose of this flag is to let the client know that it is safe to purge the request data from NVRAM. The second flag RESULT tells the S F proxy whether or not the client wants to be informed of the result of the request. Low priority requests may not require a result to be sent back to the client. The third flag DONE tells the S F proxy whether or not to hold the result of the request until the client sends the S F proxy a message acknowledging the receipt of the request result. This is important if the client must know the result of the request. Without this flag the S F proxy sends the result only once before purging the request. If that message gets lost the client is not able to determine the result. With this flag set the S F proxy holds onto the request and the result until the client indicates that it has successfully received the result.

In this exemplary embodiment if the ACK flag is set or the RESULT flag is set then the client implements a delayed ACK scheme. This means that when the S F proxy receives a request the S F proxy does not send the acknowledgement message right away if the ACK flag is set but tries to complete the transaction first. If the request completes within a few seconds e.g. ten seconds the request result is sent instead of the acknowledgement. If the request cannot be completed in that time the request is written to the database and then the acknowledgement is sent to the client . When the request result is determined later the result is sent if the RESULT flag is set. If the ACK flag is set and the S F proxy receives a duplicate request it sends back an ACK immediately. A likely reason for the S F proxy to receive a duplicate is because the client never received the first ACK probably due to a lost message.

One exemplary embodiment is a method of operating flags. This method describes the effects of the various combinations of flags.

In this exemplary embodiment for the combination ACK 0 RESULT 0 DONE 0 the client sends the request but the S F proxy does not store this in a database. The S F proxy does not send any message to the client about this request. The S F proxy purges all information about this request as soon as it completes or times out.

In this exemplary embodiment for the combination ACK 1 RESULT 0 DONE 0 when the S F proxy receives this message it sends either an ACK or the result but not both. See the discussion of DELAYED ACK for more details. The S F proxy writes this request to the database if the request cannot be completed immediately. The S F proxy purges this request as soon as the result is known or the request timeout occurs.

In this exemplary embodiment for the combination ACK 0 RESULT 1 DONE 0 when the S F proxy receives this message the S F proxy attempts to carry out the request. See the discussion of DELAYED ACK for more details. The S F proxy writes this request to the database if the request cannot be completed immediately. When the result of the request is known the S F proxy sends the result once to the client and immediately purges this request.

In this exemplary embodiment for the combination ACK 0 RESULT 0 DONE 1 which is an invalid combination if the S F proxy receives a request with this combination set it turns off the DONE flag and treats it as if the flags were 0 0 0 .

In this exemplary embodiment for the combination ACK 1 RESULT 1 DONE 0 when the S F proxy receives this message the S F proxy attempts to carry out the request. See the discussion of DELAYED ACK for more details. The S F proxy writes this request to the database if the request cannot be completed immediately. When the result of the request is known the S F proxy sends the result once to the client and immediately purges this request.

In this exemplary embodiment for the combination ACK 1 RESULT 0 DONE 1 which is an invalid combination if the S F proxy receives a request with this combination set it turns off the DONE flag and treats it as if the flags were 1 0 0 .

In this exemplary embodiment for the combination ACK 0 RESULT 1 DONE 1 the S F proxy processes the request immediately but only writes it to the database if the request cannot be completed in a certain period of time. No ACK is sent to the client once the request has been written to the database. Once the result of the request is known the result is sent back to the client . The S F proxy does not purge this result until it receives the DONE message from the client or until the request expiry time elapses.

In this exemplary embodiment for the combination ACK 1 RESULT 1 DONE 1 the S F proxy processes the request immediately but only writes it to the database if the request cannot be completed in a certain period of time and an ACK is sent to the client . Once the result of the request is known the result is sent back to the client . If the result is known before the ACK has been sent the request is not written to the database and the result is sent to the client instead of the ACK. See the DELAYED ACK discussion for more details. The S F proxy does not purge this result until it receives the DONE message from the client or until the request expiry time elapses.

Table C shows pseudo code for an exemplary embodiment of a method for providing a store and forward architecture in the client that includes Java features such as asynchronous application layer APIs e.g. http APIs and a Java API.

One exemplary embodiment is a method for conducting a store and forward transaction that has the following steps.

4. At some point in the future the JVM sends a copy of this request to the proxy server keeping the original in NVRAM the flags field directs what the S F proxy does .

5. The S F proxy receives the message from the client and tries to forward the message before it stores a copy in a database to prevent data loss.

6. If the ACK flag is set the S F proxy sends an acknowledgement back to the client which tells the client that the S F proxy has successfully received the data and the S F proxy attempts to deliver it to the application server specified in the data.

7. The client receives this acknowledgement and can then remove the payload part of this transaction from NVRAM because the S F proxy has it. It must keep some information about the transaction in NVRAM until it has completed.

8. The S F proxy attempts to contact the application server at the IP address and port given in the request data via the protocol that the client requested. In one embodiment UDP TCP and HTTP POST requests are supported.

9. The S F proxy continues to try to send the data until the retry count or time limit to send the data has expired.

10. The S F proxy creates a transaction status message with the final result. If the original request was stored in the database the final result is modified in the database record. If the request was not stored it is not added in this phase. The S F proxy only sends the final result if the RESULTS flag is set. If the DONE flag is set the S F proxy resends the result message until the time limit is reached or it gets a DONE message.

11. When the client receives the transaction result it can notify the original applet if it is still running.

13. When the S F proxy receives this DONE status message from the client the S F proxy purges all records of this transaction from the database .

One exemplary embodiment is an S F protocol that can be configured on each request to control the level of reliability to make the protocol flexible to handle different client requirements. The S F protocol does this by setting up to three bit flags in the store and forward protocol header. Each of these flags adds more reliability. The S F protocol does this by indicating the messages that are exchanged between the client and the S F proxy .

In this exemplary embodiment the three possible flags are SEND DATA ACK SEND RESULT and SEND DONE. The SEND DATA ACK flag indicates that the client wants the S F proxy to send an acknowledgement that the S F proxy received the client s request successfully. The client keeps retransmitting the request until this acknowledgement is received. The SEND RESULT flag indicates that the client wants to have the result of the transaction sent back to it when the transaction has either completed successfully failed or that the lifetime has expired before the transaction could be completed. This flag can be used with the SEND DATA ACK flag or can be used on its own. The SEND DONE flag indicates that the client sends a TRANSACTION DONE message to the proxy after it receives the transaction result. This flag is only valid if the SEND RESULT flag is also on. Setting this flag allows the S F proxy to know when the client is done with the transaction so that the S F proxy can purge all data associated with this transaction.

In at a data send message is sent from the client to the S F proxy . At the data is sent from the S F proxy to the application server . At a transmit status message with data ACK is sent from the S F proxy to the client . At the result is sent from the S F proxy to the client with the status of the client data send request. At a transmit status message with DONE is sent from the client to the S F proxy .

In at a data send message is sent from the client to the S F proxy . At the data is unsuccessfully sent from the S F proxy to the application server . At the S F proxy retries sending the data and then times out at . At the transmit status message with result is sent from the S F proxy to the client because the request did not complete in the allowed time interval. At the client send the transmit status message with done to the S F proxy .

At the S F proxy determines whether the ACK flag is set in the message. If the ACK flag is set at the S F proxy sends an ACK message to the client . If the ACK flag is not set control flows to .

At after determining that the ACK flag is not set the S F proxy sends the message to the destination i.e. the application server . At the S F proxy determines whether the message was sent successfully. If the message was not sent successfully at the S F proxy copies the message to the database at and retries sending the message to the destination at . If it is determined at that the retry was not successful the S F proxy retries sending the message until the retry limits are exceeded at . If the retry was successful the message is purged from the database at . If the message was sent successfully at or if a retry was successful at the S F proxy determines whether the RESULT flag is set at . If the RESULT flag is set the S F proxy sends the result to the client at .

At the client receives the result from the S F proxy and at returns the result to the client application through the S F object.

At after sending the result to the client at the S F proxy determines whether the DONE flag is set. If the DONE flag is set the S F proxy waits for a done message or a timeout at .

At after receiving the result at the client determines whether the DONE flag is set. If the DONE flag is set the client sends a done message to the S F proxy at .

At after determining that the DONE flag was not set at or the RESULT flag was not set at the S F proxy purges the transaction.

The S F proxy receives data sent from the client and passes it on to the host specified in the data. The client also specifies the transport mechanism to be used e.g. TCP UDP or HTTP. If the S F proxy cannot send the data to the final destination i.e. the application server within a given period of time e.g. ten seconds then the S F proxy saves the client data to a database and sends an acknowledgement to the client in some embodiments to tell the client that the S F proxy has successfully received the request and is responsible for ensuring its delivery. The S F server continues to try to deliver the data to the destination application server until a timeout for that request has expired the client cancels the request or it has been successfully delivered.

One exemplary embodiment of the S F proxy has the following command line options p c d u and w. The command line option p specifies the UDP port number that the S F proxy 1 6 listens on to receive requests from clients . In one embodiment if this option is not specified a default of is used and the proxy is run with a EUID of 0. The command line option c specifies the path to a configuration file. The default is . .proxyrc . This configuration file specifies the debugging level to use as well as the name of the debugging output file to use. The configuration file can be changed at run time and is reread by sending the S F proxy process a SIGHUP. The command line option d specifies the data source name DSN to use. This name must refer to an entry in the odbc.ini configuration file that the S F proxy reads. It uses this to determine on which host the database resides and which open database connectivity ODBC driver to use to communicate with it. The command line option u specifies the username the S F proxy uses when logging into the database. The command line option w specifies the password if any to use with the given username to log in to the database .

In this exemplary embodiment the data the S F proxy sends to the client e.g. set top box STB is sent as a UDP packet. This UDP packet is received by the network controller NC and sent downstream to the client via the out of band channel OOB . There is a route or routes for the client IP addresses to the NC which is the gateway to the operation administration management and provisioning OAM P network. OAM P is the network between the S F proxy and the network controller in the RF distribution network .

In one embodiment the application server is a statistics server. When contacted by the S F proxy the application server breaks down the received information into single events and saves them for example in a flat text file. In one embodiment the fetcher is daemon that runs in a central point of the headend not shown . The fetcher collects data from one or more application servers and saves the collected data to for example a central log file. In one embodiment the data bridge not shown is a software utility that can be used to import a flat text file into an Oracle database. The fetcher output files are used by the data bridge to store data in the database. In one embodiment a third party tool such as BrioQuery can be used to create graphical representations of the collected data.

One exemplary embodiment is a method of statistics gathering and transmission. As events are triggered by user interaction with the client statistics are gathered in a buffer. At the client level the fields are shown below in Table A.

In this exemplary embodiment the typical size of the MENU event is approximately 34 bytes. Because of the variable data field a micro browser application Browser statistic can be as large as a visited URL. The events are approximately 90 bytes in this embodiment. When the client buffer is filled and additional statistics are generated before the current ones are removed the oldest statistics are removed to create space. Currently there is no operator indication when this occurs. When an upstream statistic transmission is triggered a single or group of statistics is sent to the S F proxy in a single upstream packet. The packet payload is limited to a maximum of approximately 1000 bytes in this embodiment. In this exemplary embodiment a packet is to be sent up to a maximum of ten times between the first transmission and the maximum expiry time currently twenty four hours. Once an ACK is received from the S F proxy the client assumes the statistic was successfully sent and removes it from memory. If after ten attempts to send the statistic an ACK is not received the statistic is cleared from memory.

In one embodiment the log file format includes a single user event per line with the following four tab delimited fields date event user and data. In addition the following log file parameters may be included server date and time. The date and time are measured for example in seconds since Jan. 1 1970 the UNIX Epoch that the event reached the server in Greenwich Mean Time GMT . This allows for the use of standard UNIX function calls for the decoding of time. The event is a four character user event code that describes a single user action. The user is an identification of the user that caused the event. In one embodiment identification is made only at the set top level not at the user level. The data is any optional data associated with an event.

Table B below outlines the event codes used in one embodiment. Each event is accompanied by a time stamp and the set top username. Some events also include additional data in the optional data field. For example the TVCH event contains the numeric value of the channel that was tuned.

Table C below outlines the additional codes that are added to the existing set to facilitate user interaction with the Guide Browser TV Ticker and Games in one embodiment. Each event is accompanied by a time stamp and the set top name. Some events also include additional data in the optional data field. For example the APDN contains an application identifier.

Some examples of typical user events are as follows each has the following form timestamp event code client address timestamp application specific data field 1 996588616 APDN 0010304ead 996521265 Menu 0 3 2 996588616 APDN 0010304ead 996521427 interactive Golfjar 328 3 996588616 APDN 0010304ead 996521530 Menu 1 8 and 4 996588616 APDN 0010304ead 996521710 interactive Spadesjar 175. All events arrived at the Server on Tue Jul 31 10 10 16 2001. These events can be interpreted as 1 user displayed the menu for 3 seconds and then exited on Jul 30 15 27 45 2001 2 user played Golf game for 328 seconds and exited on Jul 30 15 30 27 2001 3 user displayed the menu 1 for 8 seconds and then exited on Jul 30 15 32 10 2001 and 4 user played Spades game for 175 seconds and exited on Jul 30 15 35 10 2001.

One exemplary embodiment is a method for client side provisioning for statistics gathering which is facilitated through a configuration file. For example a config.props file is uploaded using a carousel user interface utility to a etc directory of an out of band file carousel which is being transmitted to the clients . The carousel user interface is a way to put a configuration file or other information onto a carousel server which is at the headend and sends carouselled data files continuously to clients e.g. set top boxes. The configuration file may include information such as configuration for the S F system the number of messages to store how frequently to send them and the like.

One exemplary embodiment is a method for configuring the following variables SFProxyAddress SFProxyPort SFSchedDelay SFMaxConcMsgs SFMaxMemSize SFBlackoutSchedule StatsAnonymous StatsMaxBufferSize StatsBufferSize StatsFlushTime and Address Port.

In this exemplary embodiment SFProxyAddress defines the IP address of the S F proxy and must be in the dotted decimal format and cannot be a hostname. Also the IP address must be one that is connected to the IP network . There is no default value. Therefore if it is not provided messages are not sent from the client to the S F proxy . For example this exemplary embodiment may set SFProxyAddress 192.168.14.215.

In this exemplary embodiment SFProxyPort defines the port on which the S F proxy server is providing the S F service. For example this exemplary embodiment may set a default value of 1022 or SFProxyPort 10010.

In this exemplary embodiment SFSchedDelay is used in calculating the time at which an upstream message is sent. An upstream message is sent at a random time between blackout periods. The SFSchedDelay determines the window of time within which a random value is chosen. The unit of measure for SFSchedDelay is seconds.

In this exemplary embodiment SFMaxConcMsgs defines the maximum number of S F messages held in memory. A value of zero is valid but pending messages are not purged. An exemplary default value is 100.

In this exemplary embodiment a recommended setting for SFMaxMemSize is 8192 which is the maximum amount of memory that the S F system can use when storing messages. The unit of measure is bytes. An exemplary default value is 8192.

In this exemplary embodiment a recommended setting for SFBlackoutScheduleis 6 AM 12 PM Daily. This defines the a times when the client is not allowed to send upstream messages to the S F proxy and includes a list of start time end time combinations separated by commas e.g. SFBlackoutSchedule M 12 30 T 13 30 W 14 00 W 18 00. The schedule spans for a week. The start times for a blackout period must be smaller than the end time. The days of the week are abbreviated by one letter and are ordered as follows S Sunday 

SFBlackoutSchedule M 18 00 T 0 00 T 18 00 W 0 00 W 18 OOH 0 00 H 18 00 F 0.backslash. 00 F 18 00 A 0 00 A 18 00 S 0 00 S 18 00 M 0 00.

In this exemplary embodiment StatsAnonymous specifies whether or not the statistics gathered are anonymous. In other words if it is anonymous then the user names are marked with an X when they are recorded. A value of false results in user names being recorded. The default is to be anonymous. An exemplary value is StatsAnonymous false.

In this exemplary embodiment the recommended setting for StatsMaxBufferSize is 8192. This specifies the amount of S F memory that can be used for statistics. Once the limit is reached and a new statistic is recorded pending statistics are cancelled starting with the oldest. The unit of measure is bytes and default value is 8192.

In this exemplary embodiment the recommended setting for StatsBufferSize is 880. This specifies the amount of statistics data that is buffered before it is sent to the application server . The values supported are in the range 15 880. The unit of measure is bytes.

In this exemplary embodiment the recommended setting for StatsFlushTime is 1800. This specifies the amount of time statistics are buffered before they are flushed. The value must be greater than zero and the unit of measure is seconds.

In this exemplary embodiment the Address variable specifies the address of the application server and must be in the dotted decimal format. It cannot be a hostname. There is no default value. Therefore if it is not provided statistics are not sent from the client to the proxy. An exemplary value is Address 192.168.14.206.

In this exemplary embodiment Port defines the port on which the application server servicing requests and the default value is 89.

In this exemplary embodiment to disable the gathering and transmission of stats set the following variables to 0 SFMaxMemSize and StatsMaxBufferSize.

One exemplary embodiment is a method of formatting collecting and providing a presentation of statistics that are gathered from user interaction. Some areas in which statistics are gathered include NavShell use web browsing TV viewing TVTicker Browser ETV and Games. In this exemplary embodiment the default configuration sets the user identification field to anonymous. There is however a configuration option that allows the client e.g. the set top box to include the actual user name. The duration and exit time of all applications including games and enhanced TV ETV are collected. The duration and exit time of menus displayed by the NavShell menu display. The duration and exit time of ETV icon display events are collected. The manual selection of a category view that lasts for at least five seconds for TVTicker is collected. The category selected to view a complete story and the length of time that a story is viewed is collected. For Browser the URL and the duration at the URL is collected.

One exemplary embodiment is an S F system that supports multiple applications within an extensible network to direct information of various formats to any of multiple destinations including a client application resident at a client location for storing non priority data and for sending said data to any one or more application servers on the network at some future time and a server side proxy server process . In one embodiment of the S F system the client application allows any of sending usage statistics to a database on the network and enabling T commerce purchases to be made by a user where purchase and other relevant information is sent to a destination server .

Another exemplary embodiment is an S F system that includes a client module an S F proxy and a server . The client module resides on a digital terminal for facilitating the gathering of user events from different applications and for sending the user events to a store and forward proxy in a message batch. The S F proxy includes a server side construct for facilitating upstream communication for the digital terminal . The S F proxy converts user event data received by the S F proxy to a standardized format and sends the converted data to a server . The server facilitates communications from both the client and a fetcher . The server breaks down received information into single events and saves them in a file when contacted by the S F proxy . The fetcher collects data from at least one server and saves the data to a central log file .

In one embodiment the system also includes a data bridge for importing the fetcher central log file into a database .

In one embodiment the configuration file includes any of the following variables SFProxyAddress SFProxyPort SFschedDelay SFMaxConcMsgs SFMaxMemSize SFBlackoutSchedule StatsAnonymous StatsMaxBufferSize StatsBufferSize StatsFlushTime address and port. SFProxyAddress defines an IP address of the S F proxy . SFProxyPort defines a port on which the S F proxy provides store and forward service. SFschedDelay is used in calculating a time at which an up stream message is sent. An upstream message is sent at a random time between blackout periods and SFSchedDelay determines a window of time within which a random value is chosen. SFMaxConcMsgs defines a maximum number of store and forward messages held in memory. SFMaxMemSize is a maximum amount of memory that the S F system can use when storing messages. SFBlackoutSchedule defines a time when the client module is not allowed to send upstream messages to the S F proxy and includes a list of start time and end time combinations. StatsAnonymous specifies whether or not statistics gathered are anonymous. StatsMaxBufferSize specifies an amount of store and forward memory that can be used for statistics. Once a limit is reached and a new statistic is recorded pending statistics are cancelled starting with an oldest. StatsBufferSize specifies an amount of statistics data that is buffered before it is sent to a statistics server. StatsFlushTime specifies an amount of time statistics are buffered before they are flushed. Address specifies an address of a statistics server. Port defines a port on which a server is servicing requests.

In one embodiment of the system the S F proxy facilitates communication between the client module and the application server as follows. The client module sends data to the S F proxy . The S F proxy then transfers the data from to the application server from memory. The S F proxy then sends a result message to the client module to inform it that the data was sent to the application server so that the client module may purge at least a majority of a transaction from client memory. In the event that initial data does not reach the S F proxy or the S F proxy goes down between a time the data are received and the data are sent to the application server a result message is not sent and the client module assumes that the data did not reach the S F proxy thereby causing a retransmit of the data.

In one embodiment of the S F system the S F proxy facilitates communication between the client module and the application server when the application server cannot be contacted within a prescribed period of time as follows. The client module sends data to the S F proxy . The S F proxy then attempts to transfer the data to the application server from memory. After a predetermined interval the S F proxy assumes the application server is down and writes a transaction to a database . The S F proxy then sends a result message to the client module to inform it that data was written to the database so that the client module knows a packet was received and does not require a retransmit. The S F proxy sends the data to the application server at a later date and the S F proxy then sends a result message to the client module so that the client module may purge at least a majority of a transaction from client memory.

In one embodiment of the S F system the client module further includes a buffer for gathering statistics as events are triggered by user interaction. In one embodiment the client module buffer is filled and additional statistics are generated. Before current statistics are removed the oldest statistics are removed to create space. In one embodiment when an upstream statistic transmission is triggered a single or group of statistics is sent to the S F proxy in a single upstream packet. In one embodiment once an acknowledgement is received from the S F proxy the client module assumes a statistic was successfully sent and removes it from memory.

Another embodiment is a method for performing a store and forward transaction. At a client an applet is used to create an instance of a StoreAndForward object. The required data is filled in and a send method is invoked. A request is stored in non volatile memory to guard against power outages. At some point in time a copy of the request is sent to an S F proxy while keeping an original in non volatile memory. At the S F proxy the message is received from the client and a copy is stored in a database to prevent data loss. An acknowledgement is sent back to the client telling the client that it has successfully received the data. The S F proxy attempts to deliver the data to an application server that is specified in the data. The client receives the acknowledgement and then removes a payload part of a transaction from non volatile memory because the S F proxy has the payload. The client keeps some information about the transaction in non volatile memory until the transaction is completed. The S F proxy attempts to contact the application server at an address and port given in the request data via a protocol that the client requested. The S F proxy continues to try to send the data up to a number of request attempts given in the request or until a time limit to send the data is expired. The S F proxy creates a transaction status message with the final result and stores this message in the database . The S F proxy sends the message back to the client and waits for a done message from the client . When the client receives the transaction result the client can notify an original applet if the applet is still running. The client sends a transaction status message to the S F proxy indicating that said transaction is done. When the S F proxy receives the done status message from the client the S F proxy purges all records of the transaction from the database .

Another embodiment is an S F system that includes a client application a server side proxy server process a store and forward protocol header and means for setting at least one flag. The client application is resident at a client location for storing data and for sending the data to any one or more servers on a network at some future time. A store and forward header is sent at the start of every message both from the client to the S F proxy and from the S F proxy down to the client .

In one embodiment the at least one flag is any of the following flags SEND DATA ACK SEND RESULT and SEND DONE. The SEND DATA ACK flag indicates that the client wants the S F proxy to send an acknowledgement that the S F proxy received the client s request successfully and the client keeps retransmitting the request until an acknowledgement is received. The SEND RESULT flag indicates that the client wants to have a result of a transaction sent back to it when the transaction has either completed successfully failed or a lifetime has expired before the transaction could be completed. The SEND DONE flag indicates that the client sends a TRANSACTION DONE message to the S F proxy after it receives a transaction result. Setting this flag allows the S F proxy to know when the client is done with the transaction so that it can purge all data associated with the transaction.

In one embodiment the store and forward header includes any of the following fields a client MAC address and one or more flags. The client MAC address is an identifier for a client appliance. The Flags indicate any of the following a message type a flag and a transport protocol a transaction ID and a data request message. The transaction ID uniquely identifies a transaction from a particular client.

In one embodiment the data request message is included after a common data header and includes any of the following a transaction expiry a send expiry a destination address a destination port number a number of retransmits and one or more optional flags. The transaction expiry set a time by which a transaction must complete. The send expiry sets a time the S F proxy has to send data to an application server . The destination address is the address of an application server to which to send the data. The destination port number is the port on an application server to which to send the data. The number of retransmits sets a maximum number of times the S F proxy attempts to send the data to an application server. The optional flags are set by the client and can specify additional options for a request.

In one embodiment the S F system also includes a transaction status message appended after a common data header. The transaction status message is sent by the S F proxy to the client as an acknowledgement and to send a result of a transaction. The transaction status message is sent from the client to the S F proxy to indicate that the client has finished with a transaction. The transaction status message includes any of the following a result and a state. The result is a last known result of a request and can include any of the following results INVALID INPROGRESS SUCCEEDED FAILED TIMEDOUT CANCELLED or TOO MANY TRIES. If a result is INPROGRESS then the state is a current state of a transaction and can include any of the following DATA RCVD DATA ACKED SENDING DATA and SENT DATA.

Another embodiment is a store and forward system that allows for varying levels of reliability. This system includes a client an S F proxy and a plurality of messages passed from the client to the S F proxy and from the S F proxy to the client . The client can specify a level of messaging required by setting flags in each request message to the S F proxy . The flags can be set individually or in combination.

In one embodiment a flag tells the S F proxy whether or not to send the client an acknowledgement when the S F proxy has received a client s request. The flag lets the client know that it is safe to purge a request data from memory.

In one embodiment a flag tells the S F proxy whether or not the client wants to be informed of a result of a request. Low priority requests may not require a result to be sent back to the client .

In one embodiment a flag tells the S F proxy whether or not to hold a result of a request until the client sends the S F proxy a message acknowledging receipt of the request result. The S F proxy holds onto a request and a result until the client indicates that it has successfully received the result.

Although the invention is described herein with reference to exemplary embodiments one skilled in the art will readily appreciate that other applications may be substituted for those set forth herein without departing from the spirit and scope of the present invention. Accordingly the invention should only be limited by the claims included below.

