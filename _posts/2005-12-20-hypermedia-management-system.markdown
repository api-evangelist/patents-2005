---

title: Hypermedia management system
abstract: A system supplies links between objects. A link service receives a link request from a client. The request identifies a source object. The link service aggregates links from link providers for which the source object is a source of the links, and provides the aggregated links to the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07970867&OS=07970867&RS=07970867
owner: Microsoft Corporation
number: 07970867
owner_city: Redmond
owner_country: US
publication_date: 20051220
---
This is a divisional of application Ser. No. 10 201 544 filed Jul. 22 2002 entitled HYPERMEDIA MANAGEMENT SYSTEM to Anonsen et al.

The present invention relates to hypermedia links. More specifically the present invention relates to managing hypermedia links between objects.

A number of different databases will first be discussed although it will be appreciated that the objects need not reside in a database at all. In conventional relational databases that can be used to store the objects all data are stored in named tables. The tables are described by their features. In other words the rows of each table contain items of identical type and the definitions of the columns of the table i.e. the column names and the data types stored in the column describe the attributes of each of the instances of the object. By identifying its name its column names and the data types of the column contents a table is completely described. Queries to a relational data base are formulated in a query language. One such language is SQL Structure Query Language which is widely used in commercial relational data base systems. The data types offered by SQL can be classified as character arrays names numbers and data types related to date and time. Tables can be modified or combined by several operations of relational algebra such as the application of Boolean operators projection i.e. selection of columns or the Cartesian product.

Relational databases offer several advantages. Database queries are based on a comparison of the table contents. Thus no pointers are required in relational databases and all relations are treated uniformly. Further the tables are independent they are not related by pointers so it is easier to maintain dynamic data sets. The tables are easily expandable by simply adding new columns. Also it is relatively easy to create user specific views from relational databases.

There are however a number of disadvantages associated with relational databases as well. For example access to data by reference to properties is not optimal in the classical relational data model. This can make such databases cumbersome in many applications.

Another recent technology for database systems is referred to as object oriented data base systems. These systems offer more complex data types in order to overcome the restrictions of conventional relational databases. In the context of object oriented data base models an object includes both data and the methods which can be applied to the object. Each object is a concrete instance of an object class defining the attributes and methods of all its instances. Each instance has its unique identifier by which it can be referred to in the database.

Object oriented databases operate under a number of principles. One such principle is referred to as inheritance. Inheritance means that new object classes can be derived from another class. The new classes inherit the attributes and methods of the other class the super class and offer additional attributes and operations. An instance of the derived class is also an instance of the super class. Therefore the relation between a derived class and its super class is referred to as the isA relation.

A second principle related to object oriented databases is referred to as aggregation. Aggregation means that composite objects may be constructed as consisting of a set of elementary objects. A container object can communicate with the objects contained therein by their methods of the contained objects. The relation between the container object and its components is called a partOf relation because a component is a part of the container object.

Yet another principle related to object oriented databases is referred to as encapsulation. According to encapsulation an application can only communicate with an object through messages. The operations provided by an object define the set of messages which can be understood by the object. No other operations can be applied to the object.

Another principle related to object oriented databases is referred to as polymorphism. Polymorphism means that derived classes may re define methods of their super classes.

Objects present a variety of advantages. For example operations are an important part of objects. Because the implementations of the operations are hidden to an application objects can be more easily used by application programs. Further an object class can be provided as an abstract description for a wide variety of actual objects and new classes can be derived from the base class. Thus if an application knows the abstract description and using only the methods provided by the application can still accommodate objects of the derived classes because the objects in the derived classes inherit these methods. However object oriented data bases are not yet as widely used in commercial products as relational databases.

Yet another database technology attempts to combine the advantages of the wide acceptance of relational data bases and the benefits of the object oriented paradigm. This technology is referred to as object relational database systems. These databases employ a data model that attempts to add object oriented characteristics to tables. All persistent database information is still in tables but some of the tabular entries can have richer data structure. These data structures are referred to as abstract data types ADTs . An ADT is a data type that is constructed by combining basic alphanumeric data types. The support for abstract data types presents certain advantages. For example the operations and methods associated with the new data type can be used to index store and retrieve records based on the content of the new data type.

Some conventional object relational databases support an extended form of SQL sometimes referred to as ObjectSQL. The extensions are provided to support the object model e.g. queries involving object attributes . However these object relational databases are still relational because the data is stored in tables of rows and columns and SQL with some extensions is the language for data definition manipulation and query. Both the target of a query and the result of a query are still tables. The extended SQL language is often still the primary interface to the database. Therefore there is no direct support of host object languages and their objects. This forces programmers to continue to translate between objects and tables.

Thus in prior object relational databases an object can be queried for in terms of the object s fields rather than using the relational database column names.

However a number of problems exist with respect to conventional user interface UI technology for object relational technology and other databases or environments other than databases where links between objects are desired.

Conventional user interfaces are hand written. This includes the links between different pieces of data in the databases. Each time such a link is desired it must be hand written again. For example if an order entry page has been coded to include a link that references customer information that link has typically been placed by hand. If the order appears elsewhere in the user interface the link must be hand coded again. Therefore if a third party integrates an application to the order object the order page will not show that information or provide links to it because such links have not been hand coded even though there may be a link in a representation of the order object that is independent of the UI.

A system supplies links between objects. A link service receives a link request from a client. The request identifies a source object. The link service aggregates links from link providers for which the source object is a source of the links and provides the aggregated links to the client.

In one embodiment the link request identifies an instance of the source object and the link service aggregates links based on the instance of the source object. In another embodiment the link request identifies the type of the source object and the link service aggregates the links based on the type.

Link providers can register with the link service so they can provide links in response to requests from clients. When a link provider requests to register with the link service or another system makes the request on behalf of the link provider the link service can query the link provider to obtain information indicative of the links that the link provider will provide.

Traversal of links yields a link result from the link providers. The traversal result can be a destination object which is the destination of the link or an action or a combination of an action and a destination object or other targets which is represented by the link.

The present invention relates to maintaining links between objects. In one exemplary embodiment the links are between objects in an object relational O R database although the objects need not be stored in a database system at all and the present invention can still provide benefits. However for the sake of the present example prior to discussing details of the present invention an environment in which the invention may be used will be discussed

As shown in the data can be organized in terms of entities which is used interchangeably herein with the term objects . Each entity illustratively includes a metadata portion and a remaining attributes portion . The metadata portion describes the entity while the remaining attributes define further attributes of entity such as the data stored therein. Each of the attributes in entity is mapped to a corresponding entity table and a specific column in a given entity table .

Data access system can receive forms of a request such as a query which specifies an entity or portions of an entity or group of entities to be retrieved. Query can illustratively be expressed in terms of objects entities and properties rather than in terms of tables and columns. The particular manner in which queries are expressed does not form part of the present invention.

Data access system receives the query and accesses class table mapping . In this way data access system can determine the location of the data for the entities identified by query . Data access system includes a translator that translates query into a relational database query which is suitable for input to relational data store mechanism . In one illustrative embodiment relational data store mechanism is a server that operates according to the SQL programming language in accessing relational database . Therefore data access system receives queries in terms of objects and translates those queries into an appropriate relational database query that is then provided to the data store mechanism or server which actually accesses the data in relational database .

Relational data store mechanism retrieves the requested data and returns it in the form of relational database results . The results are returned to data access system which then formulates the relational database results into a requested result set . In one illustrative embodiment result set is requested in query . Query may request that the results be output in the form of one or more objects or simply as a data set. In any case data access system arranges the relational database results into the proper format and outputs them as result set .

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier WAV or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic FR infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in FIG. provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

It should be noted that the present invention can be carried out on a computer system such as that described with respect to . However the present invention can be carried out on a server a computer devoted to message handling or on a distributed system in which different portions of the present invention are carried out on different parts of the distributed computing system.

As stated in the background conventional user interfaces have traditionally had any links between objects hand coded. This presents a number of disadvantages. One aspect of the present invention is a system for creating links among objects or entities based on logical relationships between those objects when no physical relationship necessarily exists. One embodiment of the invention allows the logical relationships among such entities to be surfaced as links in a hyperspace thus making the entities themselves the nodes of the hyperspace.

In general hypermedia is referred to as a mechanism for navigating a hyperspace which is comprised of a set of nodes and the hypermedia links that join those nodes. One embodiment of a hypermedia architecture is illustrated in . The hypermedia architecture shows a client that communicates with hypermedia service . Hypermedia service accesses a provider register and also communicates with a set of hypermedia providers and . Hypermedia service HMS is illustratively the central point where clients request hypermedia i.e. hypermedia links or simply links . Hypermedia providers are registered with HMS . Providers are the points at which the links are actually created. New providers can be registered with HMS thus allowing extensibility.

The data that is transferred between client and HMS and between HMS and providers conforms in one illustrative embodiment to an XML schema attached as an exhibit hereto. The definition of a link in the schema includes a link category. Link categories are discussed in greater detail below. Suffice it to say for now that new categories may be defined by a hypermedia provider thus allowing additional extensibility.

There are three types of links that can be retrieved class links instance links and instance specific links. Class links have the context of a class. They represent either a relationship to a destination node or an action that can be performed. A class link provides information that is indicative of where a client can traverse to or what operations can be performed as they pertain to a particular class.

Instance and instance specific links have the context of an instance. The difference between the two types is that instance specific links are directly tied to a specific instance of an entity or object and instance links are tied to a class but an instance of that class must be specified in order to traverse the link. An instance or instance specific link provides information indicative of where the client can traverse to and what operations can be performed with the particular instance being examined.

All three types of links can be traversed which is discussed in greater detail below with respect to . Traversal returns the destination node of the link. If the link represents an action traversal performs the action the link represents and may or may not return a destination node.

In accordance with one embodiment of the present invention the type of link is not the only manner in which links may be grouped. Links also illustratively belong to a link category. One example of a link category is a metamodel category. This is described in greater detail below. Briefly however links that belong to this link category represent associations between entities. These associations are captured in the metamodel or object model of the system.

In addition to being a grouping mechanism a link category also defines a protocol that is followed by the particular providers that supplied the link. The link category gives client an indication of what type of information the link represents and what type of object will result from traversal of the link. All links of the same category can be handled in the same manner. In this way client is able to determine how to handle a link based on the link category to which it belongs.

Therefore client may generate the hypermedia request by requesting class instance or instance specific links or a combination of these. The client can also specify a set of link categories and only links from those categories will be returned. If no category is specified links from all categories will be returned. In any case once client has generated the request for links and identified a node which will serve as the source of the link it provides the request to HMS . Generating the request and providing it to HMS is indicated by blocks and in .

HMS then checks register for information to identify the particular providers that provide links that have as a source node the node identified by client as the source of the links. This is indicated by block . In other words during the registration process providers provided HMS with information about the link categories link types and node classes for which the provider provides links. This information is stored in register . Therefore when HMS receives a request from client it checks register to determine which providers it should access.

HMS then forwards the request generated by client to the identified providers which will provide links having the source node identified by client as the source of the link. This is indicated by block .

The providers which receive the request in turn return the requested links to HMS . This is indicated by block . HMS then aggregates all of the links from the providers which have responded with links and returns those links to client . This is indicated by block in .

In one example to traverse one of the links the user simply selects it such as by clicking on it with the mouse cursor . is a flow diagram illustrating what happens when a link is traversed. After being selected by the user client sends the link along with the traversal request to HMS . This is indicated by block in . The link provided by client is illustratively a class link or an instance specific link.

HMS then identifies the particular provider that provided the link. This is indicated by block . The specific links supplied by the providers in response to requests is maintained by HMS by adding this information to the link during the hypermedia request. This information is then examined during a traversal request. Therefore HMS can identify the provider which supplied the link.

HMS then forwards the traversal request and link to the identified provider. This is indicated by block .

The provider traverses the link returning traversal results to HMS . This is indicated by block . The traversal results can include a destination node which is the destination of the link or performance of an action represented by the link or both or other targets represented by the link. For example if the link represents the relationship between a customer and a query of the customer s orders traversing the link entails the provider returning the query which is an entity like the customer not the results of executing the query. Likewise if the link represents the relationship between a customer and a URL of a particular web page containing a map of the customer s address traversing the link returns the URL it does not open a browser window displaying the page pointed to by the URL. In that example the link does contain a destination the URL but the destination is not an entity or an action. Thus the traversal result may return an entity some result which is not an entity or there may be no substantive result returned. If the link represents an action traversing the link performs the action and the result may indicate this. Combinations of these types of results can occur as well.

Client illustratively includes a handler that handles the traversal results. For example if the traversal returns a query the client handler executes that query against the database and displays the results to the user. If the query returns a URL the client handler opens a browser window displaying the page pointed to by the URL etc. Handling the traversal results at the client is indicated by block in .

HMS then checks the security of the requester. This is indicated by block . This involves determining whether the requester has authorization to register a provider and can be done in any known way. This is indicated by block .

HMS then requests information from the provider about the link categories link types and node classes for which the provider provides links. This is indicated by block .

HMS then caches the information in provider register and information confirming the success of the registration is returned to the requester. This is indicated by block . HMS is then in position to receive requests for links provided by the newly registered provider.

A number of other features of the present invention should be noted. It can be seen from the architecture that any number of providers can be added at any time. Third party providers who integrate applications to the entities or objects stored in the database can be added and links to those third party applications will automatically be returned by HMS so long as an appropriate provider is registered with HMS .

Also third parties can define new link categories for which their providers will provide links. HMS can operate with no knowledge about what the links are only knowing that the provider will provide those links. The same is true for new links. An existing provider can add new links and they will be provided when requested. The developer thus need not hand code the links into the system. In one illustrative embodiment the providers simply need to implement an interface known to HMS such as those described in the Appendix hereto.

In another illustrative embodiment the interface implemented by HMS derives from the interface implemented by the providers. Therefore each HMS can also be a provider and can thus be operably connected to another HMS .

Also HMS can be implemented both as an XML web service and as a class which can be called directly if client resides on the same server as HMS . The providers can also be either deployed remotely as XML web services or on the same server as HMS .

It can thus be seen that in accordance with one embodiment of the present invention the links are requested based on object types or object classes or specific object instances. The presentation of the nodes is decoupled from the nodes themselves. The nodes are instances of objects rather than presentation elements such as web pages. This allows client to process or handle the destination node of the link in any manner it wishes.

The information that defines these associations is captured in a metamodel or object model of the applications as they are being developed. This information is typically stored as metadata. For example depicts a relationship between an Order entity and a Customer entity that is modeled during the application development process.

There are known tools which can be run against object models generated during development of an application. Such tools compile the models into association metadata. In accordance with an illustrative embodiment of the invention this is done and the association metadata is stored.

The metadata associations developed during the application development process such as the information shown in which illustrates an association between an Order entity and a Customer entity is stored in metadata store . is a flow diagram illustrating the operation of system in accordance with one embodiment of the present invention and will be described in conjunction with .

It is assumed that metadata hypermedia provider has properly registered with HMS and its link and identification data resides in provider register . Client first generates a hypermedia request or link request specifying which objects are the source of the links sought and which categories of links are to be retrieved. This request is received by HMS . This is indicated by block in . HMS then forwards the request on to the appropriate providers which in this case will include metadata hypermedia provider . This is indicated by block .

Provider analyzes association information contained in metadata store . One illustrative design of metadata hypermedia provider is discussed in greater detail in the Appendix hereto. Briefly however provider examines each association in metadata store which has been requested and determines whether the user has rights to access the associated entities. Provider can determine whether the user has rights to access the associated entities by accessing a security subsystem or in any other suitable way. Accessing security does not form part of the present invention. Provider then creates a link for each association for which the user has access and places association information in the link. This is indicated by block .

Provider identifies using terminology defined by the Unified Modeling Language UML simple associations and composition associations these can have a variety of cardinalities such as 1 1 1 many or many many relationships. Provider also identifies inheritance associations. For each association located by provider provider creates a link between the source node and the associated node. This is indicated by block .

The links are returned from provider to HMS as indicated by block and HMS aggregates all returned links and forwards them on to client . This is indicated by block . In one embodiment provider does not return the associated node but instead returns a query whose results if executed include only the associated node.

Although the present invention has been described with reference to particular embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention.

