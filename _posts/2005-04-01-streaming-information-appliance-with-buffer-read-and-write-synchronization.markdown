---

title: Streaming information appliance with buffer read and write synchronization
abstract: An information appliance receives streaming information and includes a buffer, a writer module, a reader module and a synchronizer. The buffer has a plurality of storage locations, a logical head, a logical tail and a valid data area between the logical head and the logical tail. The logical head and the logical tail move sequentially through the plurality of storage locations in a first logical direction. The writer module has a write position at the logical head of the buffer. The writer module receives the streaming information and writes the streaming information to the buffer at the write position. The reader module is coupled to the buffer and has a first read position which is temporally movable with respect to the write position. The synchronizer is coupled to the writer module and the reader module and maintains the first read position within the valid data area.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07139868&OS=07139868&RS=07139868
owner: Microsoft Corporation
number: 07139868
owner_city: Redmond
owner_country: US
publication_date: 20050401
---
The present application is a continuation of and claims priority of U.S. patent application Ser. No. 10 827 619 filed on Apr. 19 2004 which is a continuation of U.S. patent application Ser. No. 09 286 808 filed Apr. 6 1999 now U.S. Pat. No. 6 748 481 issued Jun. 8 2004 the contents of both aforementioned applications are hereby incorporated by reference in their entirety.

The present invention relates to streaming information. More particularly the present invention relates to recording streaming information and retrieving the stored information for selective playback.

With advances in technology including faster processors improved graphics and so forth a desktop computer can easily receive and present streaming information to the user. Common examples of streaming information include streaming video and audio delivered over a wide area network such as the Internet. For instance television broadcast signals that would otherwise be transmitted wirelessly using satellites television transmitters etc. are encoded and made available for transmission to remote computer users via the Internet. Upon request by the desktop computer user the encoded data packets containing audio and video data are sent to the desktop computer user sequentially. Upon receipt the data packets are decoded and processed by the desktop computer in order to render the streaming information to the user in as close to real time as possible. After rendering or presentation the data packets are discarded.

Although processing streaming information in the manner described above is useful there exist a number of shortcomings. Currently streaming information is provided at the request of each desktop computer. Thus each user must form a separate connection with the source of streaming information in order to receive the desired streaming information. Once initiated the user is unable to control the manner in which streaming information is rendered. For instance the user cannot temporarily pause the incoming streaming information in order to perform another task and then resume viewing when desired. Likewise the user is unable to repeat a previously rendered portion since the data packets are discarded or skip ahead since the data packets have not been received.

There thus is an ongoing need to improve the manner in which streaming information is rendered. Although described above with respect to a desktop computer and streaming information received from the Internet the improved process should be applicable to other information appliances or computing devices and other forms of streaming information.

In one aspect of the present invention an information appliance receives streaming information and includes a buffer a writer module a reader module and a synchronizer. The buffer has a plurality of storage locations a logical head a logical tail and a valid data area between the logical head and the logical tail. The logical head and the logical tail move sequentially through the plurality of storage locations in a first logical direction. The writer module has a write position at the logical head of the buffer. The writer module receives the streaming information and writes the streaming information to the buffer at the write position. The reader module is coupled to the buffer and has a first read position which is temporally movable with respect to the write position. The synchronizer is coupled to the writer module and the reader module and maintains the first read position within the valid data area.

Another aspect of the present invention relates to a computer readable medium including instructions readable by an information appliance having a buffer with a fixed number of storage locations. When the instructions are implemented the instructions cause the information appliance to handle streaming information by defining a logical head and tail in the buffer and a valid data area between the logical head and tail which includes a portion of the storage locations. The information appliance writes the streaming information to the logical head of the buffer with a writer module. The information appliance moves the logical head and tail through the storage locations in a first logical direction while writing the streaming information. The information appliance reads the streaming information from a first read position within the valid data area with a first reader module wherein the first read position is temporally movable with respect to the logical head and tail. The information appliance synchronizes the writing and reading of the streaming information.

With reference to the first exemplary environment for the invention includes a general purpose computing device in the form of a conventional personal computer including processing unit a system memory and a system bus that couples various system components including the system memory to processing unit . System bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routine that helps to transfer information between elements within personal computer such as during start up is stored in ROM . Personal computer further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM or other optical medium. Hard disk drive magnetic disk drive and optical disk drive are connected to system bus by a hard disk drive interface magnetic disk drive interface and an optical drive interface respectively. The drives and the associated computer readable medium provide nonvolatile storage of computer readable instructions data structures program modules and other data for personal computer .

Although the exemplary environment described herein employs a hard disk a removable magnetic disk and a removable optical disk it should be appreciated by those skilled in the art that other types of computer readable medium which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges random access memories RAMs read only memory ROM and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on hard disk magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into personal computer through input devices such as a keyboard and pointing device mouse . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to processing unit through a serial port interface that is coupled to system bus but may be connected by other interfaces such as a sound card a parallel port a game port or a universal serial bus USB . A monitor or other type of display device is also connected to system bus via an interface such as a video adapter . In addition to monitor personal computers may typically include other peripheral output devices such as a speaker connected to a sound card and printers not shown .

Personal computer may operate in a networked environment using logic connections to one or more remote computers such as a remote computer . Remote computer may be another personal computer a server a router a network PC a peer device or other network node and typically includes many or all of the elements described above relative to personal computer although only a memory storage device has been illustrated in . The logic connections depicted in include a local are network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer network Intranets and the Internet.

When used in a LAN networking environment personal computer is connected to local area network through a network interface or adapter . When used in a WAN networking environment personal computer typically includes a modem or other means for establishing communications over wide area network such as the Internet. Modem which may be internal or external is connected to system bus via serial port interface . In a network environment program modules depicted relative to personal computer or portions thereof may be stored in the remote memory storage devices. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Streaming information can be received by computer using a number of known methods and technologies. Commonly a source of streaming information is a remote computer wherein computer is connected to the remote computer using a wired or wireless modem. This technique is used often when streaming information is provided through an intranet or the Internet typically in digital form. Digital streaming information can further comprise satellite signals received by a satellite receiver dish or the like.

However streaming information can also arrive as analog signals. For instance the streaming information can also comprise broadcast radio or television signals. In such cases computer includes a radio tuner and a television tuner to receive the broadcast signals and convert the analog signals to digital form for transmission over system bus .

It should be understood that the present invention can be used in other computing devices besides computer discussed above. is a block diagram of a mobile device which is another exemplary computing environment. Mobile device includes a microprocessor memory input output I O components a communication interface for communicating with for example computer . In a one embodiment the afore mentioned components are coupled for communication with one another over a suitable bus .

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is preferably allocated as addressable memory for program execution while another portion of memory is preferably used for storage such as to simulate storage on a disc drive.

Memory includes an operating system an application program as well as an object store . During operation operating system is preferably executed by processor from memory . Operating system in one preferred embodiment is a WINDOWS CE brand operating system commercially available from Microsoft Corporation. Operating system is preferably designed for mobile devices and implements database features which can be utilized by application through a set of exposed application programming interfaces and methods. The objects in object store are maintained by application and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to receive streaming information. The devices are similar to those discussed above with respect to computer and include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Streaming information is provided to entertainment appliance through a communications interface . Communications interface can be any of the devices and technologies described above with respect to the two previous environments.

At this point it should be noted that system can be operated in any of the computing environments described above or similar computing environments. Those skilled in the art will appreciate that delay filter rendering device encoder and decoder can be implemented in hardware software or combinations thereof. In one embodiment by way of example delay filter is embodied in the operating system. Higher level application programs or other portions of the operating systems can access functions of delay filter using application program interfaces APIs as is well known in the art.

In operation streaming information source provides an information stream to delay filter optionally through encoder . Generally the streaming information comprises digital data representing one or more channels of content information. For instance streaming information source can comprise an Intranet or the Internet available through the communication interfaces described above. Likewise streaming information source can comprise an analog or digital television tuner wherein separate audio video and data e.g. closed captioning information streams comprise a single channel. Other sources of streaming information include but are not limited to audio tuners satellite receivers and the like.

In the embodiment illustrated encoder receives the streaming information and encodes or compresses the streaming information into a known format such as MPEG AVI MOV Apple QuickTime and WAV although if used the present invention is not limited to any one particular encoding format.

Generally as discussed below delay filter includes a writer module a circular buffer and one or more reader modules . Writer module receives the streaming information provided by streaming information source and writes the streaming information into circular buffer . Circular buffer can comprise any of the storage devices described above for example hard disk or RAM memory. Reader module accesses circular buffer to retrieve the streaming information when the streaming information is to be rendered. If the streaming information stored in circular buffer is encoded or compressed decoder decodes or uncompresses the streaming information which is then provided to rendering device .

Streaming information and synchronization point information is provided to writer module . In one embodiment as illustrated writer module comprises a mux writer that receives multi stream streaming information for storage in circular buffer . As indicated above one or more reader modules herein labeled as and are provided to read the streaming information from circular buffer for rendering. Writer module stores synchronization information in an index . Reader modules may access index in order to locate a particular portion of the streaming information and properly render the streaming information. Operation of writer module circular buffer reader modules and index are discussed in detail below.

In the embodiment illustrated two separate playback reader modules and are illustrated having outputs that provide streaming information to separate video audio and data decoders and rendering devices . In general this illustrates that separate reader modules can be reading streaming information from circular buffer at different points in circular buffer and thus represents separate individuals accessing the data stored therein. In addition other reader modules such as indicated at can be implemented to archive and store the streaming information in circular buffer for later viewing. Generally in archiving system reader module provides streaming information to a mux formatter that in turn provides the information to a writer module for storage in any of the storage devices indicated above such as hard disk .

Referring back to circular buffer circular buffer has floating beginning and ending points which are referred to as a logical head and tail . Head corresponds to the logical head of valid data in circular buffer and tail corresponds to the logical tail of valid data in circular buffer . Writer module always writes to the head of buffer which moves circularly through the buffer in the direction of arrow . Buffer therefore always has a fixed maximum time quantum of data available for reading. For example when time shifting multimedia e.g. audio and video content writer module receives the streaming multimedia information and stores the information in circular buffer . The user views the stored multimedia content through one of the readers modules . The circular structure of buffer allows some portion of the streaming information to be available for the user to instant replay or pause on demand for example without allowing the buffer to fill up with time shifted data. Circular buffer can be implemented in volatile or non volatile memory such as random access memory RAM a hard disk a floppy disk or an optical disk. In one embodiment circular buffer is implemented in hard disk drive .

Since writer module and reader modules can operate independently of one another and at different data rates buffer IO layer synchronizes writer module and reader modules to maintain a predetermined temporal order between writing and reading. In one embodiment buffer IO layer prevents any reader from reading data that is not yet logically available and prevents writer module from overwriting data that is in the process of being read by one or more of the reader modules . In circular buffer a given physical position corresponds to multiple logical positions. Without synchronization a reader module that is trailing writer module by a distance that is close to the buffer size may be reading from the same physical area to which writer module is writing. Buffer IO layer also allows reader modules to follow writer module as close as possible to minimize latency.

Buffer IO layer implements a synchronization algorithm for writer module and reader modules . Each time writer module wants to pass data to buffer IO layer its corresponding application calls the synchronization algorithm. Similarly each time one of the reader modules wants to read data from buffer IO layer its corresponding application calls the synchronization algorithm. The synchronization algorithm can be implemented in hardware software or a combination of both as desired.

The synchronization algorithm uses blocking to 1 block a reader module that is trying to read data which has not yet been written and or 2 block writer module if it is trying to write to an area of circular buffer from which one of the reader modules is currently reading. In both cases one component is blocked until another component has completed the operation necessary to remove the offending condition. For example if writer module is blocked it remains blocked until all of the reader modules which who are reading from the area to be written have completed their reads. When a reader module is blocked it remains blocked until writer module has written all of the data requested by that reader module.

The synchronization algorithm uses a plurality of shared variables. Each client has its own set of variables which are shared with the other clients. In circular buffer is arranged along a linear time line from zero to infinity. The synchronization algorithm maintains a Tail Pointer which is an integer variable indicating the logical tail of valid data in circular buffer . A Head Pointer is an integer variable which indicates the logical head of valid data in circular buffer . For a read operation to succeed the logical read position within circular buffer must be greater than or equal to Tail Pointer and less than or equal to Head Pointer . Since buffer is circular the logical position of Tail pointer is also logically ahead of the logical position of Head Pointer .

When writer module issues a write command it specifies an area in buffer to be written starting at a present write position . A Writer Blocked On integer variable is used to identify the logical position corresponding to the end of the data to be written when all or part of the area to be written is blocked by one or more of the reader modules . The Writer Blocked On variable is set when one of the reader modules is currently reading from that area. For example a reader module may be presently reading from logical position which is in the area between positions and . A zero value for the Writer Blocked On variable indicates that writer module is not currently blocked by any of the reader modules .

A Currently Reading From integer variable is maintained for each reader module . The Currently Reading From variable is used to indicate that the reader module is currently performing a read that starts at this logical position in circular buffer . For example in a reader module is currently reading from logical position in circular buffer . The Currently Reading From variable is used to prevent writer module from overwriting the data in logical position while the reader module is reading from logical position . When a particular reader module is not currently reading from circular buffer its corresponding Currently Reading From variable is set to infinity.

A Writer Unblocked Event variable is used to wake up writer module when it can proceed with its desired write command. For example the Writer Unblock Event variable is set to an active state when writer module is not blocked and is reset to an inactive state when writer module is blocked. The Writer Unblock Event can be implemented as a Windows event a Win32 event or any other similar synchronization mechanism familiar to those skilled in the art.

A Reader Unblock Event variable is used for each reader module for waking up the reader module when the data it is requesting is available. For example the Reader Unblock Event variable is set to an active state when the corresponding reader module is not blocked and is reset to an inactive state when the corresponding reader module is blocked.

A Critical Section variable is used to protect access to each of the above shared variables. For example a Win32 Critical Section may be used or any other similar synchronization mechanism such as a mutual exclusion mutex object as is known to those skilled in the art.

Referring back to synchronization algorithm determines whether any of the Currently Reading From variables of readers is less than i.e. behind the Tail Pointer variable at step . For example in a reader module may have a Currently Reading From variable which is pointing to a logical position in circular buffer that is less than the logical position of the advanced Tail Pointer . If this is the case synchronization algorithm blocks or delays writer module so that the conflicting reader module can get out of the way . If none of the reader modules Currently reading From variable is less than the advanced Tail Pointer variable then synchronization algorithm proceeds directly to step shown in to write the data to circular buffer .

At step algorithm sets the Writer Blocked On variable to the value of the Tail Pointer variable . This indicates the largest logical position in circular buffer at which the reader modules must be clear of before writer module can write the data. Algorithm then blocks writer module by resetting the Writer Unblock event to the inactive state at step . Since writer module is blocked the Critical Sections are unlocked at step . At step algorithm waits for the Writer Unblock event variable to be activated by the synchronization algorithm for the conflicting reader that is accessing the area to be written. When the conflicting reader module activates the Writer Unblock event algorithm locks the Critical Section at step and then resets the Writer Blocked On variable to zero at step . Algorithm again unlocks the Critical Section at step and proceeds to step shown in .

At step buffer IO layer converts the starting logical address to a circular or physical address and writes the data in circular buffer beginning at that physical address. Once the data has been written algorithm locks the Critical Section for the variables used in steps and advances the Head Pointer variable to the logical position in circular buffer that corresponds to the end of the data written by writer module . In the example shown in Head Pointer is advanced from position to position which can also be viewed as being behind the advanced Tail Pointer . Advancing Head Pointer validates the newly written data between Head Pointer and Tail Pointer .

At step algorithm determines whether any of the Reader Blocked On variables for reader modules is less than the advanced Head Pointer variable . If not none of the reader modules were waiting for the data written by writer module and algorithm proceeds to step . If so one or more of the reader modules were waiting for writer module which has now validated the desired logical positions. Algorithm sets any such Reader Unblock event variables at step to unblock the corresponding reader module.

In the example shown in a reader module may be waiting to read data at logical position which was not yet available when Head Pointer was pointing to logical position . That reader module would have had a Reader Blocked On variable pointing to logical position as shown by arrow . Now that Head Pointer variable is pointing to logical position which is ahead of logical position the data in position is available for reading and algorithm sets the Reader Unblock event variable for that reader module to the active state thereby unblocking the reader module.

Referring back to the corresponding Critical Sections are unlocked at step and the algorithm completes at step .

At step algorithm determines whether the logical position corresponding to the beginning of the requested data is before the logical position of the Tail Pointer variable. If so the requested data is invalid since it has already been overwritten by writer module . In this case algorithm unlocks the Critical Section at step and fails the requested read operation at step . The failure can be passed to the corresponding reader module through a variety of mechanisms such as a status variable.

If the requested data starts at a logical position that is not before the Tail Pointer variable algorithm proceeds to step shown in . At step algorithm sets the Currently Reading From variable of the reader to the logical position at the start of the requested data. The Critical Section is unlocked at step and the starting logical address is converted to a circular or physical address for circular buffer shown in . At step buffer IO layer reads the requested amount of data beginning at the converted logical address and provides the data to the corresponding reader module at step . At step algorithm locks the Critical Section. At step the Currently Reading From variable for the reader is reset to infinity since the read operation has completed.

At step algorithm determines whether the Writer Blocked On variable points to a logical position in circular buffer that is greater than the read position. The read position is the logical position in circular buffer corresponding to the beginning of the data to be read. If the Writer Blocked On variable is not greater than this logical position then this reader module was not blocking writing module . Algorithm then unlocks the Critical Section at step and completes its function at step .

If the Writer Blocked On variable is greater than this position then this reader module was blocking writing module and algorithm proceeds to step to determine whether any other reader module is blocking writer module . If not algorithm sets the Writer Unblock event variable to unblock writer module at step . If there are other reader modules that are blocking writer module then algorithm proceeds to step without setting the Writer Unblock event variable.

The algorithm shown in can be modified in a variety of ways in alternative embodiments. For example it may not be desirable to block writer module . If the streaming information being provided to writer module may be lost if writer module is delayed by any significant period of time such as when writer module is coupled to a television tuner then it would not be desirable to delay writer module . In these embodiments algorithm is modified in to remove steps which serve to delay writer module . Algorithm proceeds from step directly to step . Similarly algorithm is modified in to remove steps and which serve to selectively unblock writer module .

In addition algorithm can be modified to perform steps validating the read operation either before or after the read is performed at step or both. Validating the read operation before the actual read operation avoids a wasteful read. However steps can be performed after step if desired. Steps can also be performed both before and after read step .

The synchronization algorithm shown in does not require a circular buffer such as that shown in . The synchronization algorithm can also be used with minor modification in a linear buffer having both logical and physical addresses that wrap around at a frequency based on the size of the buffer. However a circular buffer allows a reader module to be time shifted with respect to the writer module such that a portion of the streaming information is available to the user for instant replay on demand. A circular buffer allows the user to pause a program but does not allow the user to inadvertently fill up the buffer with time shifted data. The writer module is always writing to the beginning of the buffer which is point that moves circularly through the buffer.

The synchronization algorithm shown in also allows the user to fast forward through the data stored in the buffer. If the user has paused a reader module so that the writer module is considerably ahead of that reader the user or the application has the option of fast forwarding the reader module to catch up to the writer module. However the synchronization algorithm stops fast forwarding when the reader module catches up with the writer module. For example the reader module may initiate a DirectShow event or other appropriate event mechanism available to the software environment whenever the reader module is blocked by the writer module. The application detects this event and switches the state of the reader module from fast forward to normal play mode. If the writer module catches up to the reader module corruption by the writer module can be avoided by 1 blocking the reader until the data is available 2 blocking the writer until the reader is out of the way or 3 moving the reader ahead by unpausing or fast forwarding the reader.

In one embodiment delay filter shown in further includes a user operation permission checking and reporting mechanism which maintains consistent operating states in the filter. is a diagram illustrating a status register which is maintained by delay filter for each data stream or channel through the filter. Delay filter can maintain register in RAM for example or any other storage medium. Status register includes a plurality of fields with each field having one or more bits. In the example shown in bits of status register correspond to user operation fields UOP UOP respectively. Bits correspond to reserved fields. Bits correspond to a channel streamer ID field which identifies the particular data stream through writer module and reader modules to which status register is associated. Each user operation field UOP UOP has a binary value which indicates whether the corresponding user operation is permitted or prohibited. For example a binary one in the corresponding field would indicate that that user operation is permitted. A binary zero in a user operation field would indicate that that user operation is prohibited. is a table listing examples of user operations that correspond to user operation fields UOP UOP. Delay filter maintains the UOP fields for each stream or channel based on the state of its reader module. Delay filter updates the user operation bits whenever the state of the reader module changes.

Certain user operations might be permitted only in certain states of the delay filter. Use of a prohibited operation might lead to inconsistent states in the delay filter and user interface. For example assume that a reader module that is performing time shifting of multimedia content is paused at point X in the circular buffer . In the meantime writer module is still writing data into circular buffer . Depending on the size of the circular buffer and the time for which the reader module has been paused there is a possibility that writer module can catch up to the point X where the reader module is paused and try to overwrite the data. In this case delay filter can forcibly unpause the reader module and send a notification to the application that the paused reader module has been unpaused. There is a small time window between the time at which the reader is unpaused and the time at which the application receives the notification. During this time window the application might issue a prohibited user command such as a forward scan. The reader module will now be performing the forward scan at the time the application receives the notification that the reader module has been unpaused and is playing at normal speed. The application and the delay filter are therefore in inconsistent states.

To avoid this problem delay filter allows the application to check the user operation bits whenever a user operation is issued to check for validity of the operation. Also whenever the user operation bits change delay filter reports this change to the application. The application can therefore update its user interface to ensure that invalid user operations are not issued to the delay filter .

Another broad inventive aspect illustrated by the exemplary embodiment includes the concept of time shifting when streaming information is rendered. Generally an information appliance for receiving streaming information implements time shifting by including a buffer in a one embodiment circular buffer writer module which receives blocks of streaming information and writes blocks to the buffer and at least one reader module which selectively reads the blocks from the buffer.

Although all signal processing equipment inherently includes signal propagation delay time shifting as used herein is distinguishable for the reasons discussed below separately or in any combination. In the first instance the amount of time shifting i.e. the relative position of any one reader module with respect to the writer module in circular buffer is selective and adjustable. In a first mode of operation the user can rewind pause fast forward and play in any desired order thereby changing the relative reading position of an associated reader module with respect to a position of writer module in circular buffer . Hence rendered streaming information which begins with a reader module is delayed in time from the streaming information that is written by writer module .

In another mode of operation logic is provided to adjust the amount of time shifting based upon operation of the system and without user intervention. For instance if a reader module has been paused by a user thus maintaining the current position of reader module in circular buffer at some time it may be necessary to begin advancing the reader position in order that writer module can store new streaming information in circular buffer . This situation may require reader module to begin moving forward within circular buffer at a rate greater than or at least equal to the rate at which streaming information is being written to circular buffer .

Automatic adjustment of the position of a reader module in circular buffer can also be initiated by user commands not directly associated with movement of a position of reader module such as play pause rewind and fast forward . As probably best illustrated by example the source of streaming information to delay filter can be a multiple broadcast channel device such as a television tuner or the like. If the user begins rendering information pursuant to a selected broadcast channel pauses and then again resumes rendering information on the same broadcast channel the associated position of reader module will change position accordingly thereby increasing the relative distance of the position of reader module and the position of writer module in circular buffer . If the user then selects a different broadcast channel to be rendered for example a different television channel writer module will then record the streaming information associated with the new broadcast channel in circular buffer . However since the position of reader module is time shifted from the position of writer module by a delay in proportion to the amount of time the user had paused the user will not notice the new broadcast channel selection until reader module reaches the new streaming information in circular buffer provided by the change in broadcast channel. In order to obviate the problems presented by the foregoing the position of reader module is automatically advanced to a position in circular buffer adjacent the position of writer module . This technique reduces the amount of delay so that rendered streaming information substantially follows broadcast channel selection in a multiple broadcast channel environment.

Another distinguishing feature between time shifting as used herein and typical signal propagation delay is the medium used to record streaming information. In particular as discussed above circular buffer can be embodied using any of the storage devices described above such as RAM memory hard disk or the like. In addition the amount of memory present in circular buffer is sufficient to provide a perceptible delay to the user if desired. In one embodiment the extent of circular buffer provides at least five minutes of delay between writing and rendering of streaming information. In a further embodiment the extent of circular buffer is sufficient to provide at least 30 minutes of delay between writing and rendering streaming information. In yet a further embodiment the extent of circular buffer is sufficient to provide at least one hour of delay.

A further distinguishing feature of time shifting as used herein includes the presence of a single writer module and a plurality of independent reader modules .

In one embodiment any information received from streaming source is first recorded in circular buffer prior to rendering the streaming information to the user. In other words all information to be rendered to the user is read with an associated reader module from circular buffer wherein there exists no direct connection from streaming source to rendering devices . Although recording and reading from circular buffer prior to rendering streaming information may slightly increase propagation delay when the position of reader module in circular buffer is substantially adjacent to the position of writer module advantages of always writing to and reading from circular buffer include simplification in system design and operation which enhances system stability. Although a switching mechanism could be provided in the system to switch from substantially live streaming information and time shifted streaming information as provided by delay filter the switching mechanism whether software hardware or a combination thereof nevertheless necessitates another component in this system that must be designed and tested to operate with the remaining components of the system. Furthermore by eliminating a direct connection of the source of streaming information and the rendering devices and always reading from circular buffer prior to rendering the quality of rendered information is consistent. In other words there is no change in quality e.g. video quality or audio quality of rendered streaming information since all information must pass through the same system components. Furthermore by always writing to and reading from circular buffer the user need not remember to execute a particular command so that streaming information is recorded for example in order to provide instant replay. In this manner the user is also able to retrieve and save an entire segment of streaming information such as a television show even when the user has already rendered some of the streaming information. Thus if the user is viewing a show and then later decides to save the show he can invoke archive system to begin at the start of the show in circular buffer and transfer a copy of the streaming information to a more permanent file. The latter can be performed while still viewing the show with a separate reader module . However the user must initiate saving or archiving prior to writer module writing over any of the desired streaming information but in a preferred embodiment circular buffer is of sufficient length to provide many minutes if not hours of stored information.

In one embodiment a field is also provided in header portion . Field provides other information relevant to the streaming information. As used herein field is referred to as prefix field in view of its relation to the actual data or payload . In a one embodiment prefix field is of variable length thus the information need not be length restricted. If desired a field is also provided indicating the size of the prefix field . Typically field is also of fixed length like fields .

Prefix field can be used to store information such as synchronization indicators discussed below a pointer to the next data block pertaining to the same stream or other information as may be desired. As appreciate by those skilled in the art a format is specified for information to be contained in prefix field in order that relevant information can be decoded easily. However since prefix field can be of any length additional information can be stored as necessary thereby making data block extensible.

It should also be noted that prefix field can also include a selected amount of fill data. The fill data is used to adjust or increase the size of data block to a predetermined length which may be desirable for processing or storage in circular buffer .

Data or payload field stores digital data received from the source of streaming information which will be rendered.

In the embodiment illustrated tail or end portion includes two fields and . Field herein also referred to as suffix field is similar to prefix field in that it can be used to store information about data blocks that are successive or preceding in the same stream. In one embodiment suffix field is at a known location from the end of data block and stores a pointer indicating the location of the preceding data block corresponding to the same channel. This information is particularly useful when it may be necessary to perform a rewind operation upon the streaming information contained in circular buffer . Suffix field can also include other information present in the data block such as data associated with field and field . In a manner similar to prefix field a format for the information contained in suffix field is predetermined and known to the reader module in order that relevant information can be obtained therefrom. Suffix field can be of fixed length or can be of variable length wherein it may be desired to provide an additional field similar to field that indicates the length of suffix field . Suffix field can also be used to store fill data if desired.

Field provides the size of data block and as such is identical to field in header portion . Field is useful when a reader module progresses backward through the circular buffer . In this manner the reader module can ascertain the size of a data block by reading the value contained in field at which point the reader module has determined where the end of the preceding block is located. Without the presence of field the reader module would otherwise have to scan the data block in order to determine its size or beginning location which can consume processing time.

As indicated above prefix fields and suffix fields can be used to store pointers indicating preceding and succeeding data blocks in each of the stream streams. In the illustration of arrows represent that prefix fields of data blocks store pointers or addresses of the immediate succeeding data block in each of the stream respectively. Similarly arrows represent that suffix fields of each of data blocks stores pointers or addresses of the immediate preceding data block in each stream respectively. In one embodiment each of the prefix fields stores the address of the prefix field in the immediate succeeding data block while each of the suffix fields stores the address of the suffix field in the immediate preceding data block. In this manner reader module can quickly locate and process data blocks for a particular stream of streaming information.

It should be noted that field of each data block can be used to identify padding data blocks from other streaming information data blocks wherein writer module can generate padding data blocks as necessary during processing and formation of streaming information data blocks. Furthermore padding data blocks can be used in combination with fill data provided in prefix field or suffix field if desired. Mux formatter and writer module can also implement the use of padding data blocks and or fill data contained in prefix field or suffix field .

It may be desirable in some instances to allow a plurality of users to access the streaming information at any one time. This can be accomplished in any number of different ways. For example the streaming information could be duplicated and one reader module can be provided for each copy of the streaming information. However this requires a great deal of storage and may also require increased processing power for making multiple copies of the streaming information and for accessing the duplicate copies. Also once the predetermined number of copies of the streaming information are in use it can become very difficult to add new users.

In the illustrative embodiment shown in a plurality of users and are depicted coupled to interfaces respectively. In the embodiment illustrated users and are viewers or rendering applications for viewing or rendering streaming information stored in circular buffer while users and are data storage sites which are used for archiving the streaming information stored in circular buffer . also illustrates a separate application program separately coupled to interfaces .

Again it should be noted that is illustrative only and that any number of users or application programs can be coupled to any number of reader modules. Similarly the users can be any suitable type of users desirous of accessing the streaming information stored in circular buffer and may be accessing the information for reasons other than viewing or archival purposes as is depicted in . Similarly in accordance with this aspect of the present invention the buffered streaming information need not necessarily be stored in circular buffer but can be stored in a linear buffer or any other type of buffer. However circular buffer is illustrated for purposes of simplicity only.

In one illustrative embodiment reader modules are implemented as objects which conform to the COM object oriented programming model. Each reader module or reader object has independent access to the buffered streaming information. Each reader module is depicted as accessing the streaming information at a different location on circular buffer . This illustrates that reader modules can access the buffered information at different times in the buffered information stream. This allows the multiple users to independently employ all the features of time shifting mentioned above without interfering with the other users accessing the buffered information stream. One user for instance can archive the streaming information for later viewing while at the same time another user can view the information.

Similarly the archival user can store the buffered streaming information from a time or location in the data buffer which is different than the time or location in the data buffer which the viewer is accessing. For instance the archival user may simply be reading the information as it is recorded in circular buffer and storing it in archival storage. By contrast the viewer may be viewing the data but intermittently pausing to take breaks or perform other tasks. Therefore the reader module associated with the viewer may well be at a temporally displaced location in buffer than the reader module associated with the archival process.

Thus illustrates a system by which multiple reader modules can access the buffered streaming information. The system depicted requires only one writer module for buffering the streaming information and only a single copy of the streaming information. This greatly reduces the amount of storage required and also reduces the processing power required. Similarly since the reader modules in one illustrative implementation are simply objects configured to access the information in buffer virtually any number of objects can be added to the system limited only by the computational resources of the system. This can be accomplished by simply instantiating another reader object.

Since the streaming information written in circular buffer can be formed of one or more channels each having a plurality of streams e.g. audio video closed captioning etc. the output from each of the reader modules will likely have a plurality of effective output pins each pin carrying one of the streams of a given channel in the streaming information. Since system illustrates that a plurality of different reader modules can be used to access the same buffered streaming information this can present some obstacles which must be overcome.

For example in some streaming architectures the need may arise to group the pins associated with each reader module so that the user application or whatever other component is receiving the data from the reader module knows which pins are associated with that reader module. An example of a streaming architecture which can be used in accordance with the present invention is an architecture known as DirectShow services.

DirectShow services is an architecture which is commercially available and well known. However for a better understanding of certain aspects of the present invention a brief description of the DirectShow services system may be beneficial.

DirectShow services refers to a modular system of pluggable components known as filters arranged in a configuration known as a filter graph. A component referred to as a filter graph manager oversees the connection of these filters and controls the flow of the streaming information therethrough. An exemplary filter graph is composed of a collection of filters of different types.

1. Source filters take data from a source such as a disk file camcorders satellite feed internet server or VCR and introduce that data into the filter graph 

2. Transform filters process data and pass it along to other portions of the filter graph or out of the filter graph and

3. Rendering filters render data to a hardware device or to any location that accepts media input such as memory or a disk file .

In addition to these three types of filters there are other kinds of filters also. Examples of other filters include effect filters which add effects without changing the data type and parser filters which are configured to understand the format of the source data and know how to read correct bytes create time stamps and perform seek operations.

Further it is quite possible for some filters to represent a combination of filter types or functions. In the DirectShow architecture a filter is said to pass streaming information downstream to a next subsequent filter. An upstream filter refers to the filter which passes data to the downstream filter and a downstream filter refers to the next filter in line to receive the data. In one illustrative embodiment the filters are program modules written in any language which can generate objects adhering to component object model COM programming. Of course COM programming refers to the object oriented programming model which defines how objects interact with a single application or between applications. In COM client software accesses an object through a pointer to an interface e.g. API which has a related set of functions called methods on the object.

By way of example only a filter graph the purpose of which is to play back MPEG compressed video information from a file may take the form set out in . Filter graph includes source filter MPEG parser video decompression transform filter audio decompression transform filter video render filter and audio render filter . Source filter reads data from a disk and provides it as streaming information to MPEG parser . MPEG parser parses the streaming information into its audio and video streams. Transform filters and decompress the video and audio data in the corresponding streams. Render filters and act to display the video data on a screen and send the audio information to a sound card respectively.

It can thus be seen that when using certain streaming architectures such as the DirectShow architecture it can be important that applications or other programming modules which are to receive streaming information from any of reader modules know which output pins correspond to which of the reader modules. For example since the streaming information being read by each of the reader modules can include a channel having a plurality of streams it is important that a user or application program receiving information from any given reader receive all streams associated with that reader and no other reader. In other words it would be undesirable for an application program or a rendering filter for example to receive an audio stream from reader module but a video stream and closed caption stream from reader module . Reader module may well be reading the stream information from a different location in buffer than reader module . Therefore the audio and closed captioning streams would not correspond to the video stream.

In order to address this obstacle one feature of the present invention includes a new COM interface which allows an object outside of reader modules to enumerate the output pins which belong to that particular reader module. In other words in the embodiment in which reader modules are implemented as objects those objects are configured to expose methods through associated interfaces to the application or other external components which have contact with the reader modules which allow manipulation of the object. One exemplary method exposed by interfaces is referred to as IenumChannelStreamPin which when invoked by an outside object yields a value which represents an enumeration of the particular output pins belonging to the particular reader module which was queried. In this way an outside object can quickly and easily obtain an enumeration of the particular pins belonging to any of the given reader modules through its associated interface .

Interfaces also expose another method which allows any specific pin output by any of reader modules to be queried for its group s enumerator object. In other words an outside object can query any pin with which it has contact to obtain the identity of the particular enumerator corresponding to the group which includes that pin. In this way a user or application program which has only recently gained access to an output pin can query that output pin to find the enumerator associated with that output pin. The external component can then invoke the method exposed by the enumerator to obtain a complete enumeration of the pins corresponding to that channel. The external component can thus quickly and accurately obtain the identity of the pins associated with any given reader module or channel being output by system .

As discussed above indexer generates an index which contains index entries that are used for seeking. In other words each of reader modules can seek to any point in buffer which has a corresponding entry in the index. In some instances depending on the nature of the streaming information substantially any point in buffer can be indexed. However for other types of streaming information it may be desirable to index only certain points within the streaming information. Such points are referred to herein as sync points. In other words the nature of the streaming information may render it unreasonable or undesirable to seek to certain points within the streaming information and begin rendering the data at that point.

For example some video streaming information works on the well known MPEG2 video format. Such a format includes a number of different types of frames which are referred to as I frames B frames and P frames. I frames need no other information in order to be rendered while B and P frames are dependent frames which require information in a preceding I frame in order to be rendered. In such an example it may be undesirable to seek to a point within buffer which begins with a B or P frame. In fact many conventional video decoders may not even be able to decode data which is provided from a B or P frame without the necessary information contained in the preceding I frame. Therefore it may be highly desirable to index only I frames in such a video stream stored on buffer .

Similarly where the streaming information contains a stream such as written text for closed captioning it may be desirable to allow a user to seek to points which correspond to the beginning or ending of words the beginning or ending of sentences or the beginning or ending of paragraphs. The same is true for an audio stream. In other words it may be desirable to allow a user to only seek to certain spots in the audio stream. Such spots may correspond to sentence or word boundaries etc.

Therefore one illustrative feature of the present invention includes a stream analyzer such as that illustrated in . Stream analyzer is shown coupled to a source of streaming information and a sink of streaming information. Stream analyzer is configured to receive the streaming information from source which can be implemented as a software object .

In one illustrative embodiment stream analyzer embodies knowledge of the organization of the streaming information provided by source . Analyzer also illustratively embodies knowledge regarding the detection of logical boundaries in the information in order to obtain the location of those boundaries sync points . The location of the sync points can then be presented to any other software or hardware component which may desire the information in order to enable skipping forward or backward through the streaming information more practicable.

Stream analyzer illustratively provides an indication of the sync points in one of two ways. In a first embodiment stream analyzer embeds the location of the sync points within the streaming information itself as it is provided to information sink . This is referred to as in band communication of derived sync point information.

In an alternative embodiment stream analyzer can provide the sync point information as indicated by dashed arrow separately from the streaming information provided to sink . This is referred to as out of band communication of the derived sync point information.

In one illustrative embodiment stream analyzer is implemented in the C programming language using classes and communicating with other software objects using COM interfaces. However it should be noted that such an implementation is illustrative only and the present invention is not limited to this particular method of implementation.

The information sink can of course be a downstream filter downstream of stream analyzer an application program a rendering filter or other program component etc. Sink can use the derived sync point information itself or simply pass it on to other components which may wish to use the derived sync point information. In one illustrative embodiment the derived sync point information is provided to delay filter which uses it in generating an index as is described in greater detail below.

In another illustrative embodiment not only does stream analyzer analyze the incoming streaming information for logical boundaries which can be used as sync points but stream analyzer also analyzes the incoming streaming information for points of interest which may be desirable sync points. Such points of interest can be substantially any points which are deemed to possibly be of interest to the user. Therefore in such an embodiment stream analyzer embodies knowledge of the type and format of information in the incoming stream as well as knowledge of the types of events of interest to the user. Similarly stream analyzer is configured to contain knowledge of how to detect these points of interest in the incoming streaming information and is provided with a mechanism to report the location in the data stream which corresponds to these points of interest.

In stream analyzer includes point of interest POI analysis component point of interest interface component and streaming information interface component . The streaming information is provided from source to point of interest analysis component which calls on its base of knowledge regarding the type of information and the organization of information contained in the streaming information as well as its knowledge regarding points of interest to the user. POI analysis component then identifies points of interest in the streaming information and provides an output which is indicative of the location of the points of interest i.e. it is indicative of the sync points . Output is provided to POI interface which makes the information available to sink . Similarly POI analysis component passes the incoming streaming information on to streaming information interface such that the streaming information is separately available to sink .

Parsing component receives the streaming information at its input. In the embodiment illustrated the streaming information may include a plurality of streams although only a single stream may be processed as well such as a written textual stream e.g. closed caption information a video stream and an audio stream. Parsing component parses the incoming streaming information into its respective stream components and provides those components to appropriate analysis blocks and .

Analysis components and analyze the incoming streams identify potential points of interest and generate information indicative of the location of the those points of interest. The streaming information as well as the sync point information is then provided from each analysis component to integration component . In the embodiment illustrated integration component re integrates the streams into the original streaming information and also embeds the sync point information at appropriate locations within the streaming information. Thus the in band sync point information is provided in the data stream at the output of integration component .

It should be noted that the analysis components can look for substantially any desired points of interest. For example written language component can be configured to look for sentence boundaries or word boundaries. In looking for sentence boundaries the analysis component can simply be configured to look for periods in the incoming stream. To look for word boundaries component can be configured to simply look for spaces in the incoming stream. It should also be noted that language analysis component can be a more sophisticated analysis component such as a natural language processing or natural language analysis component in which case component can be configured to identify certain types of clauses surnames parts of speech etc. In any case information indicative of the written language points of interest to be identified by component is provided to component such that the desired points of interest can be identified in the incoming stream.

Similarly video analysis component can be used to identify any number of different points of interest. For example component can be configured to identify commercial breaks as well as to identify the I B and P frames mentioned above. In identifying commercial breaks in the incoming video stream video analysis component can simply be configured to look for a black screen which exists for a certain predetermined amount of time. Similarly in the MPEG2 video format the I B and P frames include markers identifying them as such or are preceded by a header identifying the frames. Therefore video analysis component can be configured to look for the identifying information in the stream.

Audio analysis component can also be configured to look for a wide range of points of interest. By way of example if the incoming stream is from a horror genre film a war genre film or an action genre film or television program audio analysis component can be configured to look for loud noises such as screams gun shots or car chase noises. In that instance component can simply be configured to look for amplitude information which exceeds a predetermined threshold. Similarly component can be a more advanced component such as a speech recognition or voice recognition component. In the instance in which component includes a speech recognition component it can be configured to look for sentence or word boundaries or it can be used to look for particular words or phrases. For example component can be used to identify words of profanity which can be marked for later deletion. Similarly where component includes a voice recognition component it can be configured to identify the voice of certain actors or actresses or any other entity which can be so identified.

It should again be mentioned that the point of interest analysis component can be configured to identify the location of substantially any point of interest which can be identified. Component simply needs to be provided with the information indicative of points of interest to be analyzed as well as information indicative of the type of information and format of information which will be received in the streams provided thereto. The specific embodiments mentioned above are simply provided as examples and are not to be viewed as limiting the application of this feature of the present invention.

Once the point of interest information is derived from the streams the streams are then reintegrated and the point of interest information is provided either in band or out out band along with the integrated streams. This is indicated by block . The data stream and the point of interest information is then transmitted to a downstream component such as delay filter for further processing. Again it should be noted that the point of interest information can either be provided in band or out out band. This is indicated by block in .

As described above reader modules in system are configured such that they can seek to any indexed point in buffer . For information streams which do not have sync points it is reasonable for the reader module to seek to substantially any sample within buffer . Therefore in such information streams any sample can be indexed. In such an embodiment indexer generates index entries which simply correspond to the desired granularity of the indexer. For instance it may be desirable in certain streams to index points which are temporally spaced by approximately 0.25 seconds. With other information it may be desirable to index points which are spaced by two seconds or more. In information streams which have no sync points indexer simply generates index entries identifying locations in buffer which are separated by the desired granularity of the indexer.

However as discussed in the previous section many data streams will be provided with sync points. In those cases it may be desirable for indexer to generate index entries which correspond only to sync points. It will of course be noted that if sync points occur more frequently than the desired granularity of the index generator every single sync point may not be indexed. However if sync points do not occur more frequently than the desired granularity of the index generator substantially every sync point may be indexed.

Under such an arrangement a problem can arise. For example in a given streaming architecture stream analyzer described above may not exist or it may not yet know whether the streaming information it is receiving contains any sync points. That being the case indexer may not know at the time it begins receiving streaming information whether it must simply begin indexing samples according to its granularity or whether it is to wait to index only sync points. is a flow diagram illustrating the operation of indexer in addressing this problem.

First indexer simply executes a query against stream analyzer to determine whether stream analyzer can provide information as to whether the incoming streaming information contains sync points. This is indicated by block . Stream analyzer may not even provide a response or it may provide a response indicating that it does not yet know whether the streaming information contains sync points. If analyzer provides a response indicating that information indicative of whether sync points exist is available a flag is set. The flag is referred to in as the Sync Point Info Is Authoritative flag. This is indicated by blocks and . If there is no information available that is indicative of whether sync points exist this flag is reset as indicated by blocks and .

Next if information as to the presence or absence of sync points is available it is determined whether any sync points are present. This is indicated by block . If stream analyzer has already identified sync points in the incoming streaming information it provides indexer with a response indicating that sync points do exist. In that case indexer sets a sync point flag to a value which indicates that the incoming streaming data does in fact contain sync points. This is indicated by block . However if stream analyzer does not respond or it has not yet located sync points in the incoming streaming information and provides an output indicative of that to indexer indexer assumes for the moment that there are no sync points in the incoming streaming information and resets the sync point flag. This is indicated by block . Indexer then receives a sample of the streaming information as indicated by block .

Upon receipt of the sample indexer analyzes the sample to see if the sample has been marked as a sync point. This is indicated by blocks and . If the sample has not been marked as a sync point indexer examines the sync point flag to see whether the sync point flag is set. This is indicated by block . If at block it is determined that the sync point flag is indeed set that indicates that the streaming information being processed does contain sync points and the present sample is not marked as a sync point. Therefore indexer does not index the sample under analysis but simply returns to processing at block .

If however at block it is determined that the sync point flag is not set indexer is still assuming that no sync points exist in the incoming streaming information. Therefore the indexer simply determines whether it should index the present sample under analysis based on the desired granularity of indexer . In other words if indexer is to index points no more often than every one half second for example indexer determines whether the present sample is temporally removed from the previously indexed sample by at least one half second. If so the present sample is indexed. If not processing simply returns to block . This is indicated by block .

If at block indexer determines that the present sample is marked as a sync point indexer then determines whether the sync point flag is currently set. This is indicated at block . If the sync point flag is currently set indexer simply continues processing at block and determines whether it has reached sufficient temporal displacement from the previous index entry to index the present sync point.

However if at block it is determined that even though the present sample is marked as a sync point the sync point flag is not set then indexer determines whether the Sync Point Info Is Authoritative flag is set at block . If not then indexer realizes that it has been assuming that no points exist in the streaming information under analysis but it also realizes that sync points do actually exist. Therefore indexer discards all the previous index entries since they corresponded to non sync point samples as indicated at block and sets the sync point flag as indicated by block . Processing then again continues with respect to block . Similarly if at block it is determined that the Sync Point Info Is Authoritative flag is set processing continues at block .

Therefore it can be seen that by using the algorithm illustrated in this feature of the present invention can be used to accurately index points in the streaming information regardless of whether the indexer currently knows whether the sync points are present in the streaming information. Where sync points are not present samples will be indexed according to the desired granularity of the indexer. When sync points are present only sync points will be indexed.

As described above the streaming information stored in buffer can include multiple streams. As is also describe above it may be desirable to allow reader modules illustrated in to seek to various points in the streaming information indexed by indexer . This presents some difficulty. It is difficult to decide at which particular file offset within buffer the particular reader module should begin reading after a seek is requested. This decision is made difficult by a number of factors.

For example the streams can be out of sync within the file located in buffer . In other words audio information can be stored before or after video information and in different size storage blocks such that the two do not directly coincide. Also the reader module may request to seek to a position in buffer to a sample with a particular time stamp for which no sync point has been indexed. In other words as set out above indexer does not index every single sample. Instead it only indexes based on its own granularity or based on sync points. Therefore a reader module may request to seek to a time stamp for which no index entry is available. Further some streams may contain sync points while others may not. In addition not all sync points may be indexed since they may occur more frequently than the desired granularity of the index. One illustrative feature of the present invention is directed to addressing these obstacles in seeking through a channel having multiple streams.

In order to address the obstacles identified above one illustrative embodiment of the present invention is a seek algorithm which is described with respect to . In the algorithm the particular reader module conducting a seek seeks to a highest file offset within buffer which is suitable to satisfy each of the stream s individual seeking requirements. The reader module then begins streaming information but drops information for each of the streams being read which is read before the first sample that should actually be played for that stream. In addition where no sync points with the exact time stamp have been indexed the nearest sync point before the desired seek position is provided as a potential starting point unless the nearest sync point before the desired seeking position is too far into the past. Since some streams contain no sync points the present invention assumes that in a stream with no sync points every sample is a sync point. Finally since not all sync points may be indexed the seeking algorithm first finds a nearest indexed sync point before and after the desired seek position and then determines the difference between the two indexed seek points to see whether there may be more sync points which are not indexed between the two. If so the data between the two indexed sync points is read to determine whether additional sync points and ones closer to the desired seek point exist.

More specifically is a flow diagram illustrating a seeking operation in accordance with one illustrative feature of the present invention. In order to seek to a position within buffer illustrated in the designated reader module first receives a seek request to seek to a position in buffer having a time stamp indicating time T. This is indicated by block . In the time stamp T corresponds to sample C. In the illustrative embodiment sample C is not indexed.

For the first stream a time variable T is set to the index entry with the highest time stamp before the desired seek time T. In it can be seen that sample A for the designated stream corresponds to the index entry T which has the highest time stamp before the desired seek time T. If no such index entry exists then T is set to T Z. In one illustrative embodiment Z 100. This basically causes T to be discarded as will be illustrated in later processing. This is indicated by block .

Next a time period T is set to an index entry for the selected stream with the lowest time stamp after the desired seek time T. It can be seen that sample D corresponds to a sample in the selected stream which is indexed and which has the lowest time stamp to the right of time T e.g. after time T . If no such index entry exists the presently selected stream is ignored for purposes of computing the file offset and a new stream is selected. This is indicated by block .

Thus after processing at block it can be seen that the two index entries which lie on either side of time T and which are closest to time T have been identified. Those index entries correspond to times T and T. The temporal displacement between the desired time T and the previously indexed time T is represented by X T T . The temporal displacement between the desired seek time T and the subsequent index entry T is represented by Y T T.

If both X and Y are greater than a predetermined time interval e.g. five seconds that indicates that both of the indexed samples T and T are too far from the desired seek position T to be helpful. This determination is indicated by block . If it is the case that X and Y are greater than the predetermined time interval then the present stream is simply ignored in computing FILEOFFSET. This is indicated by block . Processing then continues at block where it is determined whether additional streams exist. If so a next stream is selected at block and processing continues with respect to block . If no additional streams exist a seek is performed at block which is described in greater detail below.

If at block it is determined that both values X and Y are not greater than the predetermined time interval then it is determined whether either X or Y are greater than the predetermined time interval. For example at block it is determined whether value X which corresponds to T T is greater than five seconds. If so then the value Y must not be greater than five seconds and a variable FILE OFFSET THIS STREAM is set to index value T. This is indicated by block .

If at block it is determined that the value of X is not greater than five seconds then it is determined whether the value Y is greater than five seconds. If so then the value T can be ignored and the variable FILE OFFSET THIS STREAM is set to value T. This is indicated by blocks and .

Basically blocks determine whether either index values T or T are too far separated from the desired seek time T to be of help. If they are they are eliminated from further computing.

If however at block it is determined that the value Y is not greater than five seconds that means that both samples corresponding to values T and T are close enough to desired seek time T to be of interest. That being the case it is determined whether other sync points between T and T may exist. In other words if a distance between T and T is so small that no other sync points could have been indexed between them based on the desired granularity of the indexer then additional sync points may exist between samples T and T which are closer to the desired seek position T but which have simply been omitted from the index because the granularity of the indexer was not sufficient to accommodate an additional index entry.

Therefore a search algorithm is conducted in which the samples of the selected stream which reside between samples T and T are searched to determine whether they are in fact sync points. If so that would mean that those sync points are closer in time to the desired seek position T and are prior in time to that seek position. If that is true then the variable FILE OFFSET THIS STREAM is set to the value corresponding to that identified sync point. This is indicated by blocks and .

Therefore at this point in the processing the desired file offset for the stream under analysis has either been chosen to be T T or a value between T and T. Then for the stream under analysis the seek algorithm requests subsequent filters in the streaming process to ignore any data samples which are read out of buffer and have time stamps prior to that identified by the variable FILE OFFSET THIS STREAM. This is indicated by block .

Once the variable FILE OFFSET THIS STREAM has been derived it is determined whether that value is less than the current value of the variable FILEOFFSET. If this is the first selected stream the value will be less than the current value of FILEOFFSET which has been set to infinity. However if this was a second third or later selected stream then the file offset for the present stream under analysis will be used as the value for the variable FILEOFFSET only if it is further to the left or earlier in time than the current value for the variable FILEOFFSET. This has the effect of moving the seek point which will actually be used in seeking in buffer to a point far enough left in the buffer to satisfy every stream s individual seeking requirements. This is indicated by block .

Next processing continues at block where it is determined whether additional streams need to be analyzed. If so processing continues at block . If not processing continues at block . In block the selected reader module is commanded to seek to the sample identified by the variable FILEOFFSET and start streaming data from buffer at that point. Since in block a value has been set for each stream indicating that streamed data prior to the desired sync point for that stream is to be ignored the data streamed out of buffer will not be rendered for a given stream unless that data is coincident with or after the earliest sync point identified for that given stream and identified by the variable FILE OFFSET THIS STREAM .

Thus it can be seen that the algorithm illustrated in solves a number of problems. With respect to streams that can be out of sync in a file the algorithm seeks to the highest file offset suitable to satisfy every stream s individual seeking requirements. The reader module then begins streaming at that point but drops everything prior to the first sample that should actually be played for each given stream. Similarly where no sync point exists with the exact desired time stamp the desired seek position the seek position is set to the nearest sync point before the desired seek position unless the nearest sync point is too far to the left into the past . Also since some streams may contain seek points while others may not every sample in a stream without seek points is deemed to be a suitable seek point. Finally since not all seek points may be indexed the seeking algorithm first finds the nearest indexed seek points before and after the desired seek position and then looks at the difference between those indexed points to determine whether any sync points may reside between them. If so the samples to the left of the desired seek position are read to look for additional sync points.

Although the present invention has been described with reference to preferred embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention.

