---

title: Cluster-wide resource usage monitoring
abstract: An infrastructure including a cluster-global dispenser that evaluates resource consume requests against cluster-global resource management policies facilitates flexible and extensible monitoring and/or control of resource consumption for multiple and/or multi-component applications on a cluster of interconnected computers. Such an infrastructure facilitates application of comprehensive resource management to cluster computing, and compatibility with the level of abstraction offered by modern object-oriented languages. Such an infrastructure also maintains backwards-compatibility. Building on the foundation of a well-defined isolated component, the resulting resource management framework is capable of supporting a rich collection of resources and of defining policies. The notion of a cluster-global resource naturally captures the aggregation of node-local resource. This applies the familiar “single system image” attribute of cluster systems to the area of resource management. The ability to associate the multiple components (isolates) of a distributed application with a single resource domain (policy), dramatically simplifies resource accounting for cluster applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08392564&OS=08392564&RS=08392564
owner: Oracle America, Inc.
number: 08392564
owner_city: Redwood City
owner_country: US
publication_date: 20050620
---
The present invention relates to the field of computers. More specifically the present invention relates to resource management.

Software engineering considerations data protection multi vendor development the availability of extensible execution environments and other factors have been causing a shift in software development from large monolithic applications to application component federations. To date most research and commercial operating systems work has focused on managing resources available to a single application only or to a group of applications connected by the parent child relationship. Increasingly there is a need for mechanisms that enable defining resource policies applicable to arbitrarily grouped collections of components.

For instance enterprise applications are increasingly being built using type safe programming platforms and deployed over horizontally scalable systems. Crucial to horizontal scalability is the ability to monitor resource usage and to define and enforce resource management policies capable of guaranteeing a desired service level. However current safe language platforms have very limited support for resource management and their cluster enabled versions reflect this deficiency. The end result is that resource management capabilities typically reduce to coarse grained management of a single resource.

Cluster computing aims at capturing the promise of horizontal scalability offered by interconnected computers. Safe languages in conjunction with their associated component architectures such as the Java 2 Enterprise Environment J2EE architecture and .NET s managed components address the problem of the development of portable multi component applications. Numerous designs of the Java Virtual Machine JVM virtual machine enhanced for cluster computing reflect the importance of both safe language platforms and clusters of computers. However all of these system designs have at least one of the following shortcomings i lack of a well defined container mechanism with guarantees strong enough to enable effective performance isolation for cluster applications ii only coarse grain of resource management e.g. in the case of the processing time granularities often are the number of processors computers or whole machine load iii only mono resource management typically only processing time and or iv ability to monitor only without control exercising capabilities. To a large extent these deficiencies follow from weak support for resource management especially for defining and enforcing resource consumption policies in the Java platform. However the deficiencies are also present in many cluster programming environments not based on safe languages.

Although some of these deficiencies may not seem substantial in current applications failing to address the shortcomings ignores trends in computing. Coarse granularity may be sufficient in specialized settings e.g. long running processor intensive tasks but leads to inefficiencies when considered in conjunction with a trend toward applications consisting of a dynamic population of components that vary in their resource needs and lifetimes. Resource management oriented towards controlling processor usage is applicable to processor bound applications but is inadequate in situations where using network databases or memory dominates. Overall current cluster programming systems based on safe languages offer scant information on resource consumption and only rudimentary mechanisms for controlling a small set of resources. These limitations constrain what can be done with respect to load balancing and service provisioning. As clusters of computers become a more significant part of the modern computing landscape the need for resource management policy defining mechanisms that apply equally well to both a single computer and clusters of computers becomes more prominent.

It has been discovered that a centralized dispenser that monitors resource usage and performs bookkeeping of such resource use over a cluster of computers facilitates flexible extensible and efficient resource management. A cluster wide operating environment such as an architecture of federated virtual machines acting in concert to execute applications on networked computers may host numerous isolates to implement an application over the cluster. A cluster global dispenser would maintain accounting information and monitor resource consumption for the collection of isolates. A resource management policy is applied to isolates distributed over a cluster of nodes. Various techniques can be implemented to apply the policy over the cluster e.g. proxies intra cluster communications etc. . A cluster global dispenser is associated with the cluster global policy. Hence consume requests for the resource governed by the cluster global policy are submitted to the cluster global dispenser. The cluster global dispenser and cluster global resource management policies allow resource consumption to be viewed on a cluster wide level and enable expression of policies from such a perspective.

These and other aspects of the described invention will be better described with reference to the Description and accompanying Figures.

The description that follows includes exemplary systems methods techniques instruction sequences and computer program products that embody techniques of the present invention. However it is understood that the described invention may be practiced without these specific details. For instance reference is made to the Java programming language and JVM virtual machines to describe the invention. Although other virtual machines and programming languages can be utilized to realize the described invention the exemplary illustrations and code refer to the Java programming language to aid in understanding the described invention. In other instances well known protocols structures and techniques have not been shown in detail in order not to obscure the invention.

The following description uses several terms to describe the invention. These terms include computation resource isolate and resource management policy. A computation is one or more executing pieces of code that cause one or more tasks to be performed. Computations include entities that occupy an address space in system memory e.g. processes threads applications etc. . A resource is a measurable entity that one or more computations consume. Availability of a resource impacts performance such that a shortfall may negatively affect performance and an abundance may improve performance. Conventional examples of resources include heap memory the number of database connections or server threads in use and processor time.

An isolate is one or more computations that do not share state or objects with other computations i.e. the computations are encapsulated . Hence isolates do not share objects or state with other isolates. The described invention utilizes isolates as a unit of management. A resource management policy defines guidelines for consuming or unconsuming a resource such as availability of a resource for computations requesting the resource. Within a specific exemplary context of the Java programming language an isolate is a container for executing arbitrary applications written for the Java platform that provides the same guarantees of execution as those provided by executing an application with a JVM virtual machine. Since isolates do not share state among one another each consumed resource has precisely one owner. Owing to this property isolates can be asynchronously terminated and their resources cleanly reclaimed. Isolates communicate via data copying mechanisms sockets resource management interface etc. . Java Specification Request 121 entitled Application Isolation API Specification provides an exemplary guideline for implementation of an isolate. Isolate creation and life cycle management are the subject of the Application Isolation Application Programming Interface Isolate API the formal output of JSR 121. The Isolate API is fully compatible with existing applications and middleware. In particular applications that pre date JSR121 may be managed by the API without modification.

Programming with isolates bears similarities to programming with threads. Launching a new encapsulated computation amounts to specifying a main class and arguments and invoking a start method. The following is exemplary code for launching a new isolate 

A resource management interface includes mechanisms to express resource management policies and abstractions of resource implementations. An exemplary resource management interface may include mechanisms and abstractions such as resource domains and resource characterizations. Policy mechanisms include reservations constraints and notifications. A resource management interface can be extensible such as allowing new resource types that can be defined to better reflect the requirements of a given application. Although in many scenarios traditional resources such as processing time heap memory or amount of data transferred over the network sufficiently characterize an application s requirements there are cases where managing different resources offers more insight and abstracts away irrelevant details. For example controlling the number of SQL statements can be more useful than direct management of underlying lower level resources

Applications that need to control how resources are partitioned e.g. application servers can use the API for that purpose. Pro active programs can use the API to learn about resource availability and consumption to improve the characteristics most important to them response time throughput footprint etc. or to ward off denial of service attacks. One of the abstractions of a resource management interface is a resource domain which encapsulates a usage policy for a resource. All isolates bound to a given resource domain are uniformly subject to that domain s policy for the underlying resource. An isolate cannot be bound to more than one domain for the same resource but can be bound to many domains for different resources. Thus two isolates can share a single resource domain for say processing time but be bound to distinct domains for outgoing socket traffic.

The resource management API does not itself impose any policy on a domain policies are explicitly defined by programs. A resource management policy for a resource controls when a computation may gain access to or consume a unit of that resource. The policy may specify reservations and arbitrary consume actions that should execute when a request to consume a given quantity of resource is made by an isolate bound to a resource domain. Consume actions that are defined to execute prior to the consuming act as programmable constraints and can influence whether or not the request is granted. Consume actions defined to execute after the consume event can be thought of as notifications.

This slightly simplified exemplary code shows how to create a domain for heap memory with 32 MB reserved with a constraint that limits the use to no more than 32 MB and with a notification that gets triggered when the usage exceeds 30 MB.

The implementation of resources used by programs strictly encapsulates all interactions with the resource management API. Thus when requesting a resource e.g. opening a socket etc. clients are oblivious to the existence of the resource management interface and can be run under a particular resource management policy without any change to their code. Failures related to the enforcement of a particular policy are reported to the application as exceptions in accordance with the resource s implementation.

A dispenser is an intermediate computation s that handles resource requests and that allows for monitoring and control of resource consumption separate from an operating system environment. Most cluster programs can utilize a global and or local dispenser as it naturally applies to the cluster case and the platform takes care of placement of new isolates. However cluster global dispensers are employed for code such as load balancers application managers or applications that have very specific needs. Such applications may need to control or monitor resource usage at a cluster wide level regardless of whether a resource has single source of production or multiple sources of production.

The described invention allows an architecture for cluster computing in the Java platform. Resource consumption by tasks whose components span multiple computers can be monitored and controlled from any node. Performance of applications can be isolated from one another and within an application its components can execute under different policies. The architecture is backward compatible existing code can run unmodified . The infrastructure is well suited for the execution of enterprise multi component applications over cluster architectures. Rather than statically dedicating a subset of the nodes of the cluster to each of the applications it is possible to express multi application cluster wide policies and enforce them via the resource management API. Load balancers and application managers may need to directly control the distribution of isolates and to globally coordinate their node local resource policies. A simple example is a policy that manages five applications on three nodes in such a way that regardless of how many components if any of an application execute on a given node the application gets its equal share of processor and network resource of that node and each application gets at most of main memory available on all nodes.

Although various mechanisms and techniques can be applied to implement a cluster global dispenser examples are provided within the context of the aforementioned APIs which include an Isolate API and a resource management API to illustrate the described invention.

The ability to identify an isolate within a cluster that hosts numerous isolates is employed to monitor and or account resource usage on a cluster wide scale. To support cluster computing the Isolate API can be extended with the notion of an aggregate. Extending the Isolate API with the notion of an aggregate provides a convenient way of naming a cluster node and abstracts away the details of spawning an instance of an isolate enabled JVM virtual machine on a specific computer. Aggregates are exposed to programmers as objects whose methods control the life cycle of an aggregate creation activation and termination obtaining the current aggregate and obtaining all known aggregates. The Isolate class can be extended with a method for creating an isolate in a particular aggregate. To provide an example of programming with aggregates the following code fragment starts a new isolate on each aggregate 

As previously discussed various techniques may be employed to define cluster wide policies. Illustrating with resource domains cluster wide policies may be implemented with 1 remote creation of resource domains or 2 refining resource scope. The following line of code is an example code fragment for remotely instantiating a new resource domain. The code invokes the method for a new resource domain which identifies an aggregate i.e. a node within a cluster .

The result is the ability to programmatically control isolate creation and resource policy definition from any place in the cluster without resorting to writing local proxies that would handle such operations.

To illustrate when executed on a cluster each aggregate is implemented as an instance of a multi tasking virtual machine MVM . Code written against the exemplary resource management interface will not be aware of the cluster. However the code will enjoy the benefits of clustering as an MVM provides several load balancing strategies selected by a start up time option. Applications that need more control over isolate placement can utilize the exemplary resource management interface. Example applications include custom load balancers or code that exploits knowledge of the locality that may exist among the isolates that comprise an application e.g. frequency of inter isolate communication or accessing resources available on some aggregates only .

Aggregates are created in two ways i indirectly through a specified load balancing strategy that creates fresh aggregates and ii directly either by using the Isolate API or by manually starting a new instance of an MVM which will find the rest of the cluster through a group membership protocol. An exemplary implementation uses JGroups which is a toolkit for reliable communication written in the Java programming language with a flexible protocol stack architecture. JGroups allows creation of a group or processes whose members can communicate with each other. Upon start up an MVM reads a configuration file that contains the names and attributes of resources to be managed. An MVM can tolerate aggregate failures i.e. the remaining aggregates still function and delivers lifecycle events. Tolerating failures and delivering lifecycle events allows applications to acquire immediate feedback on failures and to take appropriate actions e.g. restart the failed isolates in the remaining aggregates re adjust resource usage controls to shed load gracefully terminate the remaining aggregates etc. . Due to the group membership protocol the set of participating aggregates is dynamic.

The second exemplary technique for implementing cluster wide policies refines the scope of a given resource implementation. Some resources have a source of manufacturing i.e. implementation specific to a given node we call such resources node local. Examples include processing time manufactured by processors specifically owned by a given computer and heap memory implemented on top of a virtual memory subsystem on a given machine. For node local resources each node has its own bookkeeping module such as a dispenser. A dispenser for a node local resource maintains information about consumption reservations constraints and notifications pertaining to its node only. All domains for a given resource transparently consult the same dispenser before granting the resource. Upon getting a consume request a dispenser invokes the consume actions set and reports their collective decision back to the requester.

Cluster managed resources generalize the notion of a single source of manufacture i.e. the resource s implementation to the whole cluster. Only one dispenser exists in the cluster for such resources. The cluster global dispenser maintains accounting information about a resource that is managed on a cluster wide scale cluster managed resource . Examples of cluster managed resources include traffic sent on inter aggregate links and the total number of isolates. They facilitate explicit programmatic control over the combined resource consumption of distributed isolates.

A resource is declared as either cluster managed or node managed. For node managed resources a binding of an isolate to a domain for such a resource will succeed if the isolate is created locally or remotely on a node where the resource s dispenser executes. Domains for cluster managed resources have cluster global scope and any isolate can be bound to such a domain regardless of where the isolate executes. Referring to the resource A is defined as cluster managed which allows the isolates and to be bound to the policy defined at node . The notions of node managed and cluster managed resources enable creation of application specific resource management policies that span node boundaries.

After creation cluster global domains are used in the same way as the node local domains. The exemplary resource management for managing resources on a cluster wide scale adds an ability to query a given aggregate for its resource consumption and availability. This functionality parallels queries that can be issued against a specific resource domain. For example a load balancer may need to verify that an aggregate has at least 1 GB of heap memory available for a memory intensive program 

Cluster global resource management policies provide control or management of a variety of resources in a cluster of nodes. For example cluster global resource management policies are useful in controlling the number of nodes a given application executes on or the number of isolates it has spawned as the scope of these resources is inherently cluster wide. To see the more general utility of cluster global policies consider a two component application consisting of isolates A and B. Referring to isolate A is isolate and isolate B is isolate . Further suppose that network traffic is deployed as a node local resource.

On a single node it is easy to control the combined usage of the network by both isolates. The isolates and would be bound to the same resource domain for the resource on the same node. When the application is deployed on a cluster with each component residing on a different node without a cluster global resource management policy the mutually remote isolates and could not be bound to a same resource management policy since the resource is node local. Thus isolates and would be subject to separate policies and there would be no correlation between the two policies unless explicitly programmed. Maintaining the accumulated count of usage of both components would require a custom application level protocol.

Characterizing the outgoing network traffic resource as cluster global instead of node local allows for global control of the resource. Since the resource is now a cluster global resource the total usage by a given group of isolates can be controlled regardless of how many nodes the groups spans even though there may be multiple sources of manufacture of the resource e.g. each node has its own network card . Hence isolates and are bound to a cluster global resource domain for the cluster global resource network traffic. Replacement of a collection of node local domains with a single cluster global resource domain allows for expression of various policies. For example a cluster global resource management policy may express the components of the application should never collectively exceed 1 MB s of out bandwidth. 

Although monitoring cluster wide resource usage can be performed with 1 a cluster global dispenser 2 characterization of a resource as cluster managed and 3 cluster global policies additional flexibility and efficiency can be achieved with techniques that characterize resources differently. Providing a dual view of a resource preserves the control achieved with local dispensers as well as allowing the cluster wide monitoring and accounting capabilities already discussed. In addition combining different resource types further enhances resource management within a cluster.

Logically viewing a resource as two distinct resources a cluster global resource and a node local resource provides both node local and cluster global control of the resource. When a node local resource is turned into a cluster global one expressing global policies becomes relatively easy but individual nodes lose the ability to control the resource locally. For example it is difficult to express a policy such as the following no component executing on this node can get more than 0.5 MB s of out bandwidth i.e. out bandwidth being bandwidth for outgoing network traffic . A related issue is that a policy that governs a resource on a global basis cannot detect shortages of resources locally which can lead to a severely mis balanced load.

To address these issues a resource management API allows each resource to be viewed in both ways as node local and as cluster global. Thus each resource can be exposed through the resource management API as two resource types. For example the resource NetworkTraffic may be exposed as ClusterGlobalNetworkTraffic and Node LocalNetworkTraffic. Physically there is only one source of manufacture for the resource on any given node but from the application perspective there are two distinct resources. Each instance of the resource is controlled by its own consumption policy possibly independent from the policy that controls the other.

The implementation of the resource e.g. classes in java.net on each aggregate i.e. node and transparently consults both dispensers upon request for the resource. The node local dispensers and have information about consumption on their respective aggregates and while the cluster global dispenser has a combined view of resource consumption on all the aggregates and but does not distinguish between individual aggregates.

This mechanism enables both node local and cluster global control over a given resource. The policies may but do not have to coordinate. For example the node local policy may express no more than 64 MB for any isolate while the cluster global policy may control memory allotments to groups of isolates expressing no application regardless of how many nodes its components execute on should get more than 1 GB of heap memory. Thus each isolate would be controlled by both policies and any request for the resource would be granted only if both policies agree. This dual view of a resource facilitates writing policies that apply both to the whole cluster as well as within the confines of a single node.

The following example illustrates control over a resource that can be expressed with a node local policy and a cluster global policy as applied to two different isolates and . The resource governed is outgoing network traffic. Isolate is allowed to consume up to 4 MB s of the resource and its usage varies over time. Isolate continually tries to send out as much data as possible. The consumption by isolate is subject to two policies i the node local policy which states that an isolate bound to the node local policy cannot send more than 4 MB s of network traffic and ii the cluster global policy which ties the isolate s allowed rate to the isolate s consumption and expresses that the sum of the consumption rates by both isolates and cannot exceed 5 MB s. For example when the consumption rate by the isolate is 0.5 MB s the cluster global dispenser will cap usage by the isolate at 4.5 MB s in accordance with the cluster global policy which is more than the limit enforced by the node local policy . Thus isolate will be allowed 4 MB s. When usage by the isolate of the network rises to 3 MB s the cluster global dispenser will determine a new limit value of 2 MB s in accordance with the policy lower than the one dictated by the node local policy . Hence the isolate will be able to use only 2 MB s. Finally when the isolate reaches 4 MB s the isolate should be obtaining 1 MB s. The following exemplary code sketch shows how constraining usage of network bandwidth by isolate is orchestrated wherein the isolate is referred to as isolate V and the isolate is referred to as isolate W 

The method arguments described above in the exemplary code are coded using pre defined constraints that maintain rolling usage rates. It should be understood that the example is not meant to be limiting upon the invention and that the described techniques can be applied to control and or manage a variety of resources within various operating environments from either or both of the node local and the cluster wide perspectives and a myriad of relationships between nodes and or isolates.

The illustration exemplifies that non trivial fine grained policies can be expressed with cluster global resource management infrastructure and with dual view of a resource. The required global and local behavior programmed in resource consumption policies can be accurately enforced. These and other scenarios can apply to other resources as well either in separate policies when only a single resource needs to be controlled or in multi resource policies.

It is important to note that explicit node local and cluster global policies act in conjunction with implicit physical local limits. For example typically there is a finite number L of file descriptors available on any given node. A cluster global policy applied to two mutually remote isolates that reserves 2L will guarantee that they together can use 2L but will not guarantee that either of the isolates can individually obtain more than L descriptors.

To provide dual view of a resource a corresponding implementation of the resource can be annotated with consume unconsume calls. For example a consume call for ClusterGlobalNetworkTraffic is accompanied by a consume call for LocalNetworkTraffic i.e. a code snippet for a first of the resource types will be duplicated for the counterpart resource type of the dual view resource .

The abstraction of a dispenser can also be used to combine resources with unrelated and different implementations into entities that appear to clients as any other resource. For example disk traffic and network traffic can be combined into a resource DiskOrNetworkTraffic. This hybrid resource type can be employed to limit the amount of data an application can send out through an external device whether it be to a storage device or a over a network. Combining different resource types allows resources with different functions and sources of manufacturing to be treated interchangeably as well as making programming such situations more convenient. In addition a combined resource type can be controlled as any other resource.

An exemplary implementation for combining resource types would define a resource domain for multiple different resource types such as disk traffic and network traffic. Each time either one of these resources is consumed the same resource domain is charged for the consumption. Assuming an isolate A is bound to a resource domain X for DiskOrNetworkTraffic when the isolate A requests consumption of disk traffic the resource domain X is charged. When isolate A or any other isolate bound to the resource domain X consumes network traffic its consumption is charged against resource domain X.

The described invention may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the present invention. A machine readable medium includes any mechanism for storing or transmitting information in a form e.g. software processing application readable by a machine e.g. a computer . The machine readable medium may include but is not limited to magnetic storage medium e.g. floppy diskette optical storage medium e.g. CD ROM magneto optical storage medium read only memory ROM random access memory RAM erasable programmable memory e.g. EPROM and EEPROM flash memory electrical optical acoustical or other form of propagated signal e.g. carrier waves infrared signals digital signals etc. or other types of medium suitable for storing electronic instructions.

While the invention has been described with reference to various realizations it will be understood that these realizations are illustrative and that the scope of the invention is not limited to them. Many variations modifications additions and improvements are possible. More generally realizations in accordance with the present invention have been described in the context of particular realizations. These realizations are meant to be illustrative and not limiting. Accordingly plural instances may be provided for components described herein as a single instance. Boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of claims that follow. Finally structures and functionality presented as discrete components in the exemplary configurations may be implemented as a combined structure or component. These and other variations modifications additions and improvements may fall within the scope of the invention as defined in the claims that follow.

