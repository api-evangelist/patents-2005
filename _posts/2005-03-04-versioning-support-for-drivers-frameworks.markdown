---

title: Versioning support for drivers frameworks
abstract: The subject invention relates to systems and methods that facilitate automatic version level updates of driver components in the context of an operating system framework. In one aspect, an automated computer versioning system is provided. The system includes a version library supplying various components of an operating system framework, wherein the version library defines revision levels and interfaces for the components of the operating system framework. A loader automatically distributes the interfaces in order to facilitate functional interactions with the operating system framework, whereby such distribution of the interfaces is based in part on a change in the revision levels.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689985&OS=07689985&RS=07689985
owner: Microsoft Corporation
number: 07689985
owner_city: Redmond
owner_country: US
publication_date: 20050304
---
The subject invention relates generally to computer systems and more particularly relates to systems and methods that enable automated updates to platform libraries while mitigating impacts on functioning drivers.

Operating system platforms have enabled the rapid growth of various technologies that are developed on such systems. Many of these platforms along with running many differing applications for developing the technologies also have become much easier to use when adding components such as hardware devices and associated drivers to the systems. For instance in one area some systems allow hardware or software components to be installed on the respective platforms whereby these components in essence can be plugged into the system with a high degree of confidence that they will also cooperate with the system and other devices components that have been previously installed. One common name for such technology is referred to as Plug and Play technology which enables devices or components to be easily integrated within an existing system.

Plug and Play technology generally relates to when a computer system automatically recognizes new devices and determines what driver software resource settings and so forth the device needs with very little or no interaction from the user. This technology also will typically only load a driver if it is needed since the hardware is currently detected as present. A driver is a software component that resides in between the operating system and the hardware and allows the operating system to communicate with the hardware. In some operating systems drivers are software modules that can be inserted into an operating system kernel allowing for support of specific hardware or for extension of the operating system or both. Generally drivers run in a fully trusted mode whereby any failure in these components can cause machine services to fail or a full system crash. Thus any successful effort to make drivers more resilient or fault tolerant usually causes greater system reliability and consequently customer satisfaction to increase.

One of the barriers to greater driver resilience is that a driver typically has to respond to many events generated by the operating system which may require the driver to initiate operations which can fail. For example these events may be file handle creation device insertion power being turned off statistics gathering and so forth. Most of the time the exact action that a driver should take in response to an internal failure is poorly defined. This is partly due to the operating system not always being designed to handle every conceivable set of failures partly due to external documentation not covering every situation and partly due to certain failures that involve a large amount of judgment on the part of the driver designer. Furthermore drivers are often constructed internally as large state machines wherein a response to an event can depend largely on which events have occurred in the past. After a failure occurs the driver designer often has to immediately turn around and handle new events even though the failure probably implies that new events are likely to fail as well.

In many situations when bugs are discovered or new features added in drivers and their associated operating system components software revisions are routinely sent out overtime to correct such problems. In many cases the revisions can be downloaded over the Internet with a few mouse clicks. Currently the drivers and operating system components exist in a tightly coupled relationship. In other words if a bug were discovered in the operating system components with no fault to the driver and a revision were to be required of the operating system then in many cases both the operating system and the driver would need to be updated. This type of arrangement is highly inefficient however. While the drivers may be perfectly operational and bug free they should not have to necessarily be upgraded merely due to problems that have been detected in other portions of the system. Conversely if a particular driver problem is discovered new revisions propagated to the driver should have minimal impact on the rest of the system.

The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.

The subject invention relates to systems and methods that facilitate versioning support for operating system components while mitigating impact on non versioned components of the system. In one aspect a software registration architecture is provided that decouples operating system requirements from essential or core functionality provided by related components such as drivers. Thus the subject invention moves operating system support functions that were previously operated by individual drivers of the system and shifts the functional support to framework components of the operating system. The drivers are then left to operate core functional aspects relating to the driver s specific domain of control. For example a sound card driver can focus resources on managing audio streams as opposed to also supporting sound and operating system overhead. By segmenting system driver functionality and providing automated processes to support substantially transparent versioning to the system and or the respective drivers the subject invention efficiently allows versioning to occur in one portion of the system while mitigating effects of the versioning with respect to other portions.

In one particular aspect of the subject invention a loader or agent is employed to intercede on behalf of driver components in view possible changes that may be occurring in framework or library components that are subject to the changes. Thus if a software change were to be required of the framework the change or version can be communicated and or integrated with the respective driver via the loader. This can include mapping of Application Programming Interfaces APIs in order for the driver to continue to be able to operate in context of the newly versioned or updated framework. Also version controls are provided to allow registration management and control of prospective changes to the collective system. Other aspects include support processes that allow major and minor versioning of the system. For instance if a major revision were to occur and a driver found it was no longer compatible with the framework or operating system automated procedures can be invoked to enable step back functionality to occur where the system regresses back to a previous software state in order to allow the components of the system to operate while incompatibilities were determined.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the invention may be practiced all of which are intended to be covered by the subject invention. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.

The subject invention relates to systems and methods that facilitate automatic version level updates of driver components in the context of an operating system framework. In one aspect an automated computer versioning system is provided. The system includes a version library supplying various components of an operating system framework e.g. event handlers interrupt processors library functions power down state handlers and so forth wherein the version library defines revision levels and interfaces for the components of the operating system framework. A loader automatically distributes the interfaces in order to facilitate functional interactions with the operating system framework whereby such distribution of the interfaces is based in part on a change in the revision levels. The version library can be updated or changed while mitigating affects on components that utilize the library such as drivers or other components.

As used in this application the terms component system object library driver and the like are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. Also these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems via the signal .

Referring initially to an automated versioning system is illustrated in accordance with an aspect of the subject invention. The system includes a version library that includes functional components of an operating system framework not shown . Such components in the library are utilized by one or more driver components or drivers in the operation of the driver and interactions of the driver with an operating system. In general the version library provides a level of service to the driver where actual code written for the driver is focused on those aspects that are peculiar to the functionality of the driver. In this manner version level updates can be made to the driver while mitigating code level changes to the driver. When a version level change is detected a loader component distributes updated functionality of the version library to the drivers by mapping one or more APIs and or other version level information to the drivers. For instance such mappings can include providing updated address or pointer tables that point to functions that are needed by the driver . A registration component can be employed to manage the version level changes and automatically trigger updates between components of the system upon detecting discrepancies between older and newer versions of the respective components.

In one aspect the system functions as a software registration architecture that decouples operating system requirements from essential or core functionality provided by the drivers . Thus operating system support functions that were previously supplied by individual drivers of the system are migrated to framework components of the operating system represented by the version library . The drivers are then left to operate core functional aspects relating to the driver s specific domain of control. For example a mouse driver can focus resources on managing user inputs as opposed to also supporting the mouse and operating system overhead. By segmenting system driver functionality and providing automated processes to support substantially transparent versioning to the system and or the respective drivers versioning can occur in one portion of the system while mitigating effects of the versioning with respect to other portions such as the drivers.

In one particular aspect the loader is employed to intercede on behalf of the drivers in view of possible changes that may be occurring in framework or the version library that are subject to the changes. Thus if a software change were to be required of the framework the change or version can be communicated and or integrated with the respective driver via the loader . This can include mapping of Application Programming Interfaces APIs in order for the driver to continue to be able to operate in context of the newly versioned or updated framework. Also version controls are provided by the registration component to allow registration management and control of prospective changes to the collective system . Other aspects include support processes that allow major and minor versioning of the system as will be described in more detail below. For instance if a major revision were to occur and a driver found it was no longer compatible with the framework or operating system automated procedures can be invoked to enable step back functionality to occur where the system regresses back to a previous software state in order to allow the drivers to operate while system incompatibilities were determined.

Referring now to an automated versioning process is illustrated in accordance with an aspect of the subject invention. While for purposes of simplicity of explanation the methodology is shown and described as a series or number of acts it is to be understood and appreciated that the subject invention is not limited by the order of acts as some acts may in accordance with the subject invention occur in different orders and or concurrently with other acts from that shown and described herein. For example those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events such as in a state diagram. Moreover not all illustrated acts may be required to implement a methodology in accordance with the subject invention.

Proceeding to of framework or operating system functionality is segmented from a driver s core functional aspects. Such functionality can be collected in a code version library for example. At the functional aspects of a respective driver are coded in the driver. For instance printer driver would code printer interface functionality and a video driver would supply code for video display devices. Other coding features include providing calls to system library capabilities that cooperate with an operating system for example. At API or interface mappings are provided for drivers and functional components of the framework defined at . These mappings allow the drivers to call operating system functionality without explicitly supplying or supporting the functionality within the drivers. At an automated agent is employed to communicate the mappings at to the individual drivers or components of the computing system. Upon distribution the drivers can call framework functionality as needed to support associated driver responsibilities.

Proceeding to a decision is made as to whether or not a framework version update or change is required. If not the process proceeds to perform other tasks before returning to to check for revision changes. If a version change is required at the process proceeds to to update the framework. At framework changes are automatically communicated to the drivers. Such changes can be communicated as function pointer mappings and so forth that redirect previous calls of the drivers to newer or updated versions of the framework. At after changes have been communicated at a determination is made as to whether or not a compatibility problem exists between the drivers and the framework. If no incompatibility exists at the process ends at . If an incompatibility is detected at the process can automatically step back to a previous revision level in order that detected problems can be resolved. This can include re loading an older version of the framework and re mapping the drivers back to the older or previous version that existed before a compatibility problem was detected at .

Before proceeding it is noted that illustrate one particular example of an automated versioning system in accordance with the subject invention. For instance many of the illustrated examples relate to a driver framework library e.g. Windows Drivers Framework WDF . It is to be appreciated that the versioning system of the subject invention can be provided according to various operating system platforms libraries and or frameworks e.g. Linux Virtual Execution environments managed code environments and so forth .

The WdfVersion structure identifies the WDF version which the respective driver was built and is expected to be dynamically bound to. This structure contains the major version number the minor version number and a build QFE number for example. In general the major and minor version numbers are used to bind to a WDF version library. The build number is the distribution build of the WDF libraries. The WdfFunctions table is an array of pointers to WDF API functions. This table can be filled as part of the registration of the client driver with the version library. The WdfDriverGlobals pointer references a client driver context area which should be passed on each WDF API call. This pointer is not specified or apparent to the driver developer and is set within each WDF API thunk. The following is a specific code example relating to the version information portion the driver entry portion the driver unload portion and the status portion of . Bolded item sections of this code will be described in more detail below.

At Section 3B1 above for the driver entry the following loading operations may occur. The kernel loader calls the driver s entry point EP as marked in the image header. This can be the first code to be executed in the driver image. The standard DriverObject and RegisteryPath pointers can be present. At code Section 3B2 above WdfDriverEntry calls the WdfVersionBind in the WDF Version Loader to request being bound to the WDF library specified in the driver s WdfVersion structure. Note the parameters to this call are a pointer to the driver s WdfVersion structure and a pointer to the driver s WdfDriverGlobals pointer. Internally the WdfVersion structure includes a pointer to the WdfFunctions table and its size. Upon successful completion of the WdfVersionBind call the WdfFunctions table can be filled with pointers to suitable API points within the WDF Version and the WdfDriverGlobals structure can be allocated and initialized.

At Section 3B3 above WdfDriverEntry indirectly calls the driver specific DriverEntry via GsDriverEntry. The GsDriverEntry provides a level of buffer overrun safety at minimal cost. At Section 3B4 above after the client DriverEntry has returned with a successful status the driver s unload routine is again checked and if it was displaced the unload routine is retained as the displaced unload routine. The WdfDriverUnload is inserted as the driver s unload routine.

At unload time kernel load unload services call the unload routine specified in the driver s DriverObject as shown in Section 3C above. This routine is WdfDriverUnload as illustrated. The WdfDriverUnload will first call any displaced unload routine then WdfDriverUnload will call the WDF Version Loader s WdfVersionUnbind routine to request disassociation with the specified version library. As illustrated in Section 3D above status can be returned regarding the drivers entry and unload operations.

At Section 4A1 above the WdfDriverEntry.lib imports the WdfVersionBind call via the WdfLdr.lib thereby linking to the Version Loader . The client side WdfDriverEntry calls WdfVersionBind passing a pointer to the client s WdfVersion structure and a pointer to a WdfDriverGlobals pointer. Note that WdfVersionBind is an exported API from the WDF Version Loader WdfLdr.sys for example. At Section 4A2 above WdfVersionBind calls ReferenceVersion passing the WDF VERSION INFO structure pointer Version and a pointer to receive a library handle Library .

At Section 4B1 above ReferenceVersion attempts to locate the Service Key associated with the version levels specified in the WDF VERSION INFO structure. This Service key is then used to retrieve the ImageName from the Service key. The ImageName identifies the actual file name for the library for example WdfDynamic.sys may be the image name. The ImageName is used to scan the list of already loaded version library modules as anchored by gLoadedModuleList. At Section 4B2 above if the version library module is already loaded e.g. it was located then no further processing is required and the version library module handle is returned.

At Section 4B3 above since the version library module was not found an attempt is made to load the version library . A new version library module structure is allocated and initialized. As version libraries are built as EXPORT DRIVER an attempt is made to load the version library via ZwLoadDriver for example. After the version library has been loaded a call to GetImageBase returns the image header pointer this is conceptually similar to a LoadLibray call in user mode . Finally the version library module is linked to the global list of loaded version library modules at gLoadedModuleList. At Section 4B4 above since the basic flow of initialization for version libraries is modeled after DLLs the next operation is to resolve the version library s DllInitialize exported API and call it.

At Section 4B5 above ReferenceVersion s last action is to set the version library module handle and return. At Section 4A3 above in the version bind section of WdfVersionBind can now resolve and call the version library s WdfRegisterClientDriver exported API. The parameters to this call are the WDF VERSION INFO structure pointer and the pointer to the WdfDriverGlobals pointer. The WdfRegisterClientDriver routine can fill the WdfFunctions table as referenced in the WDF VERSION INFO structure and also create and initialize a new WDF DRIVER GLOBALS structure and set its pointer in the pointer to WdfDriverGlobals.

At Section 5A1 above the client side WdfDriverUnload in the WdfDriverEntry.lib stub calls WdfVersionUnbind passing a pointer to the client s WdfVersion structure. Note that WdfVersionUnbind is an exported API from the WDF Version Loader WdfLdr.sys. At Section 5A2 above the WdfVersionUnbind calls DereferenceVersion passing the WDF VERSION INFO structure pointer Version .

At Section 5B1 above DereferenceVersion attempts to locate the Service Key associated with the version levels specified in the WDF VERSION INFO structure. This Service key is then used to retrieve the ImageName from the Service key. The ImageName identifies the actual file name for the library for example WdfDynamic.sys could be the image name. The ImageName is used to scan the list of already loaded version library modules as anchored by gLoadedModuleList. At Section 5B2 above if the version library module is not located a serious error has possibly occurred. Possible response could be to indicate a failure to unbind in the returned status or to BugCheck. If the version library module was found the version library module s reference count is decremented. If the version library module s reference count is non zero indicating there are still other drivers associated with this version library then return with a SUCCESS status is possible.

At Section 5B3 above the version library module s reference count is zero indicating there are not dependent client driver bound to this version library . The version library s DllUnload exported API routine is resolved and called. At Section 5B4 above the kernel API ZwUnloadDriver is called to unload the version library from memory. At Section 5B5 above the version library module is removed from the list of loaded version library modules and its resources released.

Generally there are not hard linkages to the version library either static or dll type. Typically versioning support API calls are conducted through a LoadLibray and GetProcAddress type mechanism. The WDF version library should be written as an EXPORT DRIVER e.g. it has both a DriverEntry and a DriverUnload routine and export the following APIs DllInitialize DllUnload and WdfRegisterClientDriver. Also the version library should be given a unique name which reflects the version it contains. An example might be WDF02051234.sys. This would be parsed as a WDF version library with major version number 02 minor version number 05 and build number 1234 for example.

Referring to Section 6A1 code example above since the version library is built as an EXPORT DRIVER and loaded when the WDF Version Loader calls ZwLoadDriver the version library s DriverEntry is called by the system loader. This DriverEntry will set its driver unload routine in its DriverObject. At Section 6A2 above the version loader calls this WDF version library s DllInitialize routine allowing it to perform any library wide initialization. This routine is called after the version library has been loaded. The DllInitialize routine wraps a call to the WDF routine FxDllGlobalsCommission which is packaged in the common WDF core static library.

At Section 6A3 above The WDF version loader calls this WDF version library s WdfRegisterClientDriver routine for each WDF client driver requesting to be bound to this WDF version library. At Section 6A4 above WdfRegisterClientDriver requests the WDF core routine FxAllocateDriverGlobals to create and initialize a new FX DRIVER GLOBALS structure for this client driver. Note that FxAllocateDriverGlobals does not return a pointer to the base FX DRIVER GLOBALS structure but rather to the contained Public field within the FX DRIVER GLOBALS structure. At Section 6A5 above WdfRegisterClientDriver fills the client s Wdfunctions table the array of this WDF version library s APIs. The simplest form is a copy of the version library s WdfVersion Function array into the client driver s FuncTable referenced in the client s WDF VERSION INFO pointer .

At Section 7A1 above the system loader calls WdfDriverEntry the image specified entry point. At Section 7A2 above he DllIinitialize function is called which wraps the WDF core FxDllGlobalsCommission. At Section 7A3 above WdfVersionBind is called with the same function signature as the dynamic side. At Section 7A4 above the WdfVersionBind calls the WdfRegisterClientDriver as there is generally no need to load the version library. At Section 7A5 above WdfRegisterClientDriver invokes the core FxAllocateDriverGlobals in the same manner as the dynamic side processing. At Section 7A6 above WdfRegisterClientDriver resolves the WDF APIs in the same manner as the dynamic side processing. At Section 7A7 above WdfDriverEntry calls the client drivers DriverEntry. At Section 7A8 above if the WdfDriverUnload routine was displaced then the displaying function address is retained and WdfDriverUnload is re established as the DriverObject s unload routine.

Referring to a dynamic element is shown at within an editor interface at where the dynamic element is then added to a tree structure for versioning support which is shown at .

It is noted that API header file such as WDFCOLLECTION.H in the example and WDFFUNCENUM.h are generated via a WdfStubs.exe dynacalls utility for example. Generally all APIs are specified as FORCEINLINE functions. This allows for an easy thunking process to include with the WdfDriverGlobals parameter for every API target function.

Regarding Section 10A1 the core library API should be named using the WDFEXPORT macro. This will decorate the API name with a common prefix which is currently imp  for example. Regarding Section 10A2 the common prolog to the API is retrieving the FX DRIVER GLOBALS pointer from the WDF DRIVER GLOBALS pointer passed as the first parameter. Regarding Section 10A3 the FX DRIVER GLOBAL pointer is the client working context and used on most significant internal function calls. The example shows how this FX DRIVER GLOBALS pointer FxDriverGlobals is used during the construction of a new FxCollection object.

With reference to an exemplary environment for implementing various aspects of the invention includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to 11 bit bus Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. illustrates for example a disk storage . Disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system which can be stored on disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the subject invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . Input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices that require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet IEEE 802.3 Token Ring IEEE 802.5 and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

