---

title: Template integration
abstract: A system and method are provided for integrating configuration templates. Usage-based configuration templates are created. The configuration templates are integrated into a configuration structure by assigning system instances to the configuration templates based on the usage of each of the system instances. The system instances are associated with one or more systems coupled with the configuration structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07954087&OS=07954087&RS=07954087
owner: SAP AG
number: 07954087
owner_city: Walldorf
owner_country: DE
publication_date: 20051230
---
Embodiments of this invention relate generally to installation and configuration of enterprise software and in particular but not exclusively relate to integrating configuration templates into a configuration structure in an enterprise environment.

Each AS instance may include one or more virtual machines VMs to interpret programs providing the presentation and business logic to service work requests . These VM may include JAVA VMs JVMs compliant with the JAVA 2 Platform Standard Edition J2SE etc. A VM is an example of a runtime system. A VM is an abstract machine that can include an instruction set a set of registers a stack a heap and a method area like a real machine or processor. A VM essentially acts as an interface between program code and the actual processor or hardware platform on which the program code is to be executed.

Web dispatcher implements a load balancing mechanism distributing work requests from client nodes among machines within cluster . Web dispatcher may be one of machines having the task of dispatching work requests among machines of cluster or a stand alone hardware node. Work requests are processed by machines and may subsequently be provided to database node . Database node offers up the requested data to machines which in turn process and format the results for display on client nodes . Each AS instance may further include its own dispatcher mechanism to distribute work requests assigned to it among its individual VMs .

Installation files for installing AS instances may be centrally stored within database . To deploy each AS instances installation files are copied from database node to each machine via a network link. Once copied installation files are installed generating a file system and establishing AS instances on each machine . When freshly installed each AS instance is deployed with a default configuration installation for VMs and the applications and services deployed therewith. AS instances may be operated using the default configuration installation however this does not guarantee that all available resources will be utilized optimally or that AS instances will function properly.

Typically once each AS instance is up and running with the default installation configuration a user manually configures each AS instance . Manual configuration generally requires a sophisticated knowledge about the hardware and OS platforms as well as the tasks to be performed by each AS instance . The user configuring a default installation configuration may need to determine and input a large number of parameters unique to each AS instance in a time consuming and error prone processes.

Furthermore the conventional configuration technique with the JAVA stack relies on system dependent information which is heavily and redundantly distributed across the entire cluster configuration tree. This for example makes it impossible to adjust the configuration when system settings e.g. JAVA home system name instance number host names etc. are changed. Also since system dependent settings are statically configured within the configuration database when the system environment changes e.g. due a system copy these settings are to be adapted manually which makes it impossible to move a configuration as is from one system to another. Further there is a high risk of inconsistent configuration of cluster nodes running on the same instance.

A system and method are provided for integrating configuration templates. In one embodiment usage based configuration templates are created. The usage based configuration templates are integrated into a configuration structure by assigning system instances to the configuration templates based on usage of each of the system instances. In one embodiment a system instance is associated with a system coupled with the configuration structure. In one embodiment the configuration structure includes several levels such as a default configuration level a configuration templates level and a system configuration level. Furthermore in one embodiment configuration templates are deployed and later activated to be used by users.

The above attributes may be implemented using a computer program a method a system or apparatus or any combination of computer programs methods or systems. These and other details of one or more embodiments of the invention are set forth in the accompanying drawings and in the description below.

Configuration architecture depicts a general cluster configuration structure which is presented here in three levels . In one embodiment the three levels include deployed components and default configuration level level configuration template level level and system configuration level level . Lower levels derive or inherit from higher levels and may overwrite settings. For examples from bottom up level includes instance configuration level which inherits from level which inherits from deployed components and default configuration . Level generally and or deployed components specifically may be referred to as global area or global. Customer side modifications may be made at level while the content delivered by the provider e.g. SAP AG may be kept separate from and independent of customer modifications.

In one embodiment default configuration level or level may provide a system independent default configuration that is abstract and derived from standard instance via deployed default component configuration . This configuration information is inherited at basic instance where the information from level is aggregated and further inherited at basic instance customized . Configuration information at basic instance customized may then be used to generate templates that are use or usage specific. Level may also include component binaries that are inherited at component binaries at level and aggregated at basic instance along with configuration information from component configuration . At basic instance a number of nodes the configuration of which may be abstract may also be assigned to basic instance .

Configuration template level or level may include predefined instance configuration for specific use cases and scenarios such as portal KM minimal instance JAVA 2 Platform Enterprise Edition J2EE developer etc. For example at level instances in communication with system include J2EE developer instances and portal KM instances that are provided via customized J2EE developer and customized portal KM respectively at customized layer further via templates J2EE and portal KM of templates at configuration template . Current instance may include a virtual instance that has a parameterized link to an instance running in a given system context e.g. containing the instance identification as parameter . During runtime configuration consumers access current instance that points to the right instance from instances during runtime. Stated differently at runtime current instance is assigned to a particular instance of instances that the component can access.

In one embodiment level contains a system independent configuration that is configured or provided via dynamic configuration that includes parameterized settings computed settings and or value links. This system independent configuration may be moved between different systems with ease. Further level and its contents are derived from default configuration and overwrite the settings according to each of the specific usages to which templates are assigned. Also instances are homogenously configured which means all server nodes e.g. virtual machines of instances may share the one and the same configuration.

Level contains several configurations such as instance layout configuration VM configuration kernel configuration service settings application configuration cluster file system configurations and runtime filter configuration etc. For example the instance layout may contain the configuration about the number of server nodes running on that particular instance. The instance layout may be configured via a simple numeric property which specifies the number of server nodes. This property is by default defined as an arithmetic expression dependent on the hardware available for the instance e.g. dependent on the number of processors and the amount of available memory . Thus the instance layout dynamically adapts itself to the environment on which the instance is running. In a high end environment an instance may include a higher number of server nodes where in a low end environment e.g. developer personal computer merely a single server node may be running on the instance.

Similarly a VM or JVM configuration may contain VM memory settings and parameters. These settings are specified in a system independent way via parameterized and computed configuration entries. The maximum heap size could for example be configured as an arithmetic expression dependent on the amount of physical memory and the number of server nodes running on a particular instance. These settings are dynamically adapted to a specific environment. A kernel configuration may contain system independent properties of the manager components of the engine. These settings are abstracted via parameterized and computed settings. Service settings may contain system independent service properties of each service component which is part of the installation. As with the VM and kernel configurations these settings are abstracted via parameterized and computed settings. An application configuration may contain system independent application configuration of each application which is part of the installation.

A cluster file system configuration may contain the system independent configuration of components that are deployed into the file system e.g. configuration tool visual administration etc. . The bootstrap process may be responsible for synchronizing this configuration along with components themselves to the file system. During synchronization a configuration manager may transparently substitute dynamic settings and thus in the file systems the settings may be static. A runtime filter configuration may contain the configuration to enable and disable components according to the use case scenario associated with templates . The installation may contain more components than those that are actually used in a specific use case and scenario. Those components that are not needed are disabled and those components that are needed are enabled via runtime filter configuration. For example in J2EE developer template the runtime filter configuration may disable every component except those components that are needed in a J2EE developer scenario.

In one embodiment configuration templates are derived from configuration basic instance which defines the basic structure of the instance configuration. Further this derivation may not be direct but instead another level basic instance customized may exist in between basic instance and configuration templates . Basic instance customized may belong to system configuration and is the place where system global configuration changes can be stored. While the deployment of templates occurs at level the modification or customization of templates can be performed at level via Application Programming Interfaces APIs and administrative tools. Minimal instance includes a template that is used during the instance installation and contains components that are needed to run the central configuration. A central configuration may be used to select and set the specific usage case template for instances to be configured.

In one embodiment a template configuration tool may be used to generate and configure templates and to provide functionalities for managing the general flow of the auto configuration process. For example the auto configuration process may activate an already existing template by assigning one or more of system instances to that template . Templates may include use or usage based templates that are system independent but they may include any combination of software platform dependent parameters hardware platform dependent parameters and or use case dependent parameters.

System configuration may contain an actual configuration such as a configuration of the actual instance belonging to a system. Each instance may be assigned a usage case scenario which is to be executed by the corresponding instance during runtime. Thus the instance configuration is derived from configuration templates associated with the corresponding use case and scenario. Further templates contain system dependencies dynamically e.g. via parameterized and computed settings so there is no need to overwrite these settings in the actual instance configuration. Various configurations may dynamically adapt themselves to an actual system environment. Therefore the engine runtime itself may not need any additional configuration so it is functional without overwriting any settings inherited from templates .

Some engine components e.g. configuring landscape connectivity etc. may however be configured at customizing layer associated with templates . For example when an instance for a specific configuration template is generated a customizing configuration for the template is created with system configuration . Further a customizing configuration is derived from an actual template while an instance configuration is derived from the customizing layer of a selected template . Any configuration changes at the level of customizing layer may be visible across instances that are associated with configuration templates . For example any configuration changes at the level of customized portal KM apply to all portal KM instances within the cluster.

In one embodiment when configuration changes in a single instance is needed such changes may be made to a particular instance at the instance level at system configuration . However in certain cases when changes in configuration settings are needed for the entire system such as system e.g. for all usages that are activated in system the changes may be made for all instances such as J2EE developer and portal KM instances in communication with system . In this case configuration changes may be made at the level of basic instance customized which are then inherited down to instances via templates and customizing layer . Also such configuration changes or settings may be visible globally as long as the settings are not locally overwritten. It is to be noted that for brevity and clarity merely the illustrated instances templates etc. are provided but many more and fewer instances templates and other components modules etc. may be employed. For example one or more of instances may be configured via the same configuration template.

In one embodiment installation provides an entire system database e.g. J2EE configuration and a complete file system environment which is needed. For example installation provides an instance installation that provides a file system environment for instances and prepares instances within the configuration database. For example the two based kinds of instance configuration may include 1 application instances and JMS instances that are optionally installed in case JMS services are separated from applications. When installing application instances a particular usage of the instance may not be defined at this point however the usage may be later defined during configuration . Thus during installation first minimal instance is configured as it contains all the necessary components needed to subsequently run central configuration . Minimal instance may be configured via an appropriate configuration template. Further the instance installation may be performed via a batch configuration tool provided by the engine to create the instance configuration in the database and assign it to minimal instance configuration template .

For installing JMS instances JMS instance configuration template may be used. JMS instance may be made available as part of the configuration database. During the installation of JMS instances the installation tool may use a batch configuration tool to create the instance configuration in the database and assign it to JMS instance configuration template .

Central configuration is performed via configuration tool that for example runs within the J2EE engine. Configuration tool may be used to manage the configuration of system landscapes via corresponding configuration templates . The management of configuration templates by configuration tool may not only merely include one or more of instances but also a landscape of several systems. For example J2EE configuration templates within the J2EE engine may also be configured based on usages. Configuration may be broader in scope than a typical J2EE configuration. For example configuration tool may help facilitate activation and or customization of templates . Various J2EE configuration templates may be made available in software delivery archive SDA that is deployed into the J2EE engine prior to installing and configuring J2EE instances. Configuration tool may use J2EE configuration templates during configuration by assigning each instance configuration to the appropriate J2EE configuration template. After the installation of templates configuration may also provide activation and or customization of templates .

As discussed previously during installation of application instances the usage of instances may not be known however during installation application instances are configured via minimal instance which may be sufficient to run central configuration . Subsequently during configuration application instances are to be configured for specific usages. During configuration a custom layer configuration e.g. the layer from which instance configurations are derived including custom application instance may be assigned to a configuration template e.g. portal KM according to a particular usage of the system . This custom configuration e.g. custom application instance may be derived from a selected configuration template e.g. portal KM while the instance configuration of application instances may be obtained from the custom configuration.

In one embodiment configuration templates provided within the J2EE engine are system independent e.g. obtained by configuring the system dependent settings via parameterized and arithmetic expressions and thus the settings are correct and do not need to be changed or reviewed during configuration . This is particularly necessary for certain settings modifications such as instance layouts VM configurations kernel configurations several system dependent application and service settings etc. The customizing of additional engine components e.g. configuring landscape connectivity etc. may still be performed. For example when certain settings are to be modified for all instances e.g. JMS instance thru JMS instance n of JMS instances using configuration tool configuration may involve modifying such settings by accessing custom configurations e.g. custom JMS etc. corresponding to those instances and making changes there. However when configuration settings of a particular instance e.g. JMS instance of JMS instances are to be changed such settings may be changed at the level of that particular instance such as by directly modifying configuration settings of a JMS instance .

Furthermore a J2EE configuration tool belonging to the J2EE engine core layer may be used for an offline configuration of the J2EE engine system. This configuration provides a configuration for instance layouts e.g. the number of nodes running on an instance VMs or JVMs according to VM types and platforms kernel e.g. manager properties service properties application properties e.g. sap.application.global.properties and runtime filters for activation and deactivation of components according to a particular usage etc. as described with reference to . Further a J2EE configuration tool may allow the modification of configuration at the following two levels 1 particular instance and 2 configuration template . For example when changing the configuration at the level of a particular instance e.g. instance of application instances the change is made merely to the specific instance. However when changing the configuration at the level of a configuration template e.g. JMS instance this configuration change may impact all those instances e.g. JMS instances that correspond to and are configured via that particular configuration template. The J2EE configuration tool may not provide the editing of configuration template but instead it may allow for the editing of custom templates for specific configuration templates . Using this technique customer settings are kept separated from the default settings provided by the provider e.g. SAP AG that are deployed into the system.

Configuration manager may include configuration resolver which further includes resolver handler parameter resolver value link resolver and expression calculator . Once the meta attributes from abstract configuration data are communicated to configuration manager based on these meta attributes e.g. parameterized link and or computed various resolvers are called for parameter resolver value link resolver and or expression calculator . Furthermore system context corresponds to the same configuration data e.g. due to system copy etc. and is communicated to configuration manager . A resolved configuration is then communicated to configuration consumer . System context defines system system name etc. having different areas of inputs in system context . Any relevant hardware information may be gathered automatically via an operating system. Although users may provide some installation settings e.g. system name instance name etc. during installation host names may be gathered from the operating system.

In one embodiment configuration manager allows the configuration to be dynamic and to adapt itself to a specific system environment. This is achieved by configuration manager by providing parameterized configuration entries and computed configuration entries. The dynamic configuration as provided by configuration manager permits the use of the parameterized settings rather than the static values. Stated differently configuration manager accesses a set of system parameters e.g. host names instance name number of processors available memory etc. which are defined during a startup time. Using configuration manager the configuration settings which depend on the system environment are not configured as static values but instead they reference those system parameters that are accessed by configuration manager . This is accomplished by configuration manager by providing various types of configuration settings such as parameterized settings value link settings computed settings and inherited settings.

The parameterized settings containing system parameters may be provided by configuration manager and are resolved via parameter resolver . These parameters may be transparently substituted during runtime. The parameterized settings may also be used for system dependent settings which can be resolved by a simple parameter substitution. Various computed settings include simple arithmetic expressions containing system parameters from a system profile provided within configuration manager . These computed settings are provided via expression calculator . During runtime the parameters are transparently substituted and the arithmetic expression is evaluated. The computed settings are used when a simple parameter substitution is not sufficient and the value needs to be calculated out of specific system parameters e.g. cache sizes heap size etc. . Settings containing a link to other settings e.g. value link are used when a setting is dependent on another setting which is stored elsewhere. During runtime the value link is transparently resolved and substituted. Value link settings are resolved via value link resolver . The settings containing value links may be combined with various features of computed values. Using these settings for example configuration manager allows J2EE engine components to adapt their configuration dynamically to the system environment in which they are running. The changing of the system environment which changes system parameters dynamically changes the configuration. Configuration manager and other components of abstract configuration architecture allow various components to define their configuration such that they are system independent.

Using the information inherited from the default configuration level also known as the global level various configuration templates are generated and or customized at the configuration template level at processing block . A template customization and or configuration tool may be used to customize configuration templates such as generate and or customize the configuration template. Examples of such templates include J2EE developer portal KM minimal instance etc. The information from these configuration templates is inherited at the customizing layer forming customized information at the system configuration level at processing block . For each active template the customizing system layer may contain a custom template which may by default be empty . For example a template J2EE developer at the templates layer may have a corresponding custom template J2EE developer at the system layer.

The customized information via customized developers is then used to configure default instances into new configured instances at the system configuration level at processing block . Stated differently customized configuration templates are applied to default instances to configure them into configured instances. Default instances may be configured via an instance configuration tool. Default and configured instances may include application server instances. Examples of instances include J2EE development instance portal KM instance etc. Further such instances are in communication with a system. At processing block a current instance which includes a virtual instance is provided to allow a parameterized link to a running instance of one of the instances. Also during runtime configuration consumers are provided access to the running instance via the current instance at processing block .

Abstract configuration data includes default configuration which includes abstract i.e. system independent default configurations. Abstract configuration data further includes configuration templates that are usage based templates that overwrite default settings according to the requirements of the specific usage. Configuration manager reads configuration data acquired from abstract configuration data as well as configuration data for the usage of attached usage context . The configuration data from usage context and abstract configuration data is communicated to configuration consumer . Stated differently the configuration for the usage of the attached usage context is returned at configuration consumer . The usage is determined and configuration templates are configured and customized according to the determined usage e.g. usage 1 template usage 2 template . . . usage n template . Further different usage contexts can be attached to the same configuration data e.g. J2EE developer Enterprise Portal etc. and communicated to configuration manager via usage context .

System configuration contains configuration of the actual system having system instances at an engine such as a J2EE engine. For example system configuration includes configuration of instances e.g. J2EE developer customized instance portal KM customized instance etc. belonging to the system. An instance may be assigned to a usage that is to be executed by the instance during runtime and is usage based. Stated differently configuration of instances are derived from configuration templates belonging to the corresponding usage. For example instance configuration of a J2EE developer customized instance at system configuration is derived from the corresponding configuration template of a J2EE developer at configuration templates via the J2EE developer customizing at the customizing layer at system configuration .

In one embodiment as each configuration template at configuration templates contains system dependencies in a dynamic way e.g. via parameterized and computed settings the need to overwrite these settings in the actual instance configuration is eliminated. The system dependent configuration dynamically adapts itself to the actual system environment and thus the engine runtime itself does not require any additional configuration. Furthermore engine runtime and instances at system configuration are already functional without overwriting any settings inherited from configuration templates . Nevertheless additional engine components e.g. configuring landscape connectivity etc. may be customized at a place within system configuration called customizing layer where each customizing component corresponds to a configuration template .

The configuration changes at system configuration may be visible across all instances that are assigned to their corresponding configuration templates at configuration templates . For example in the illustrated embodiment a change at the level of Portal KM Customizing configuration applies to and is visible across all Portal KM Customizing Instances n within the cluster at system configuration which corresponds to the Portal KM Template at configuration templates . However in those cases in which the change is to be made to merely a particular instance the configuration change may be made directly to that particular instance at the instance level of system configuration rather than making the change at the customizing layer level or to templates .

In one embodiment configuration templates are created at an archive including a template software delivery archive. Each of the configuration templates includes an Extensible Markup Language XML file. Configuration templates may be created using one or more template creation tools. Templates are deployed into the corresponding system via one or more deploy or deployment tools and customized via one or more configuration tools on top of a special JAVA API. Configuration templates are usage based e.g. they are configured based on a specific usage as it relates to an instance . Configuration templates are then integrated into configuration structure at configuration templates level via an integration tool such as a template integration tool. The integration of configuration templates into configuration structure includes assigning of instances to configuration templates based on their usage as configuration templates are usage based templates. The deployment and activation of configuration templates are further described below.

Server nodes indicate a number of server nodes running per instance. The number of server nodes is optionally specified in the template tag. The number of server nodes is calculated based on the number of processors and the available memory. VM parameters provides a flexible mechanism of VM settings which can be used to specify 1 general parameters for VM types and platforms 2 VM vendor specific parameters for platforms e.g. SUN IBM HP etc. and 3 VM vendor and platform specific parameters. There may be an inheritance mechanism between these three layers. The more specific parameters may overwrite the more general ones. Thus the vendor and platform specific parameters may overwrite the VM vendor specific parameters for all platforms. System parameters and system information may also be referenced. For example 1 the amount of memory and 2 the number of nodes per instance may be referenced to calculate the amount of memory per server node. Also the maxHeapSize on some platform may be limited to a certain amount of memory.

To set VM parameters to increase the ease of manipulating JAVA parameters the VM parameters may be separated into three groups such as I memory parameters 2 system parameters and 3 additional parameters. For example memory parameters include a predetermined set of parameters. The names of memory parameters and their values may be specified. The specified value may be calculated out of the total memory for the instance and the number of nodes. The VM parameter names however may not be specified but instead the predefined name that is mapped to the correct name of each VM may be used. The name and value for system parameters are specified since the system parameters are divisible into name value pairs. For additional parameters names and values may be specified.

An adjustment of component parameters may include adjusting the default configuration of applications services managers etc. The default configurations that require merely a few usage specific configurations may be provided however system specific values may not be specified. For system specific values references to the parameters that are provided in the system profile and system information are used. The configuration of a component is specified inside the configuration section of the template. The configuration section includes applications services and managers etc. while each of them can be specified multiple times and in any given order. Furthermore a property tag may be used to modify a property. For example the name and value attributes of the property are specified. The description attribute may explain why the value is set the way it is.

An application and service to be started and or stopped may be specified. These runtime filters are represented as start stop rules. Each of the rules has the same structure and attributes. For the component name and the component provider one can use as wildcard even in complex patterns such as portal xyz . The order in which runtime filters are specified may be significant as it may change the complete startup semantics. The evaluation mechanism is as follows filter lists followed up through the configuration inheritance hierarchy are appended and evaluated from the bottom to top e.g. the startup configuration at lower level overrides the one at a higher level . Also a component matching a stop filter may be stopped unless another component referring the first one is set to be started by a subsequent filter rule.

Once template SDA having templates is created templates may be deployed like any other SDA content via deployment tool . For example the following telnet command may be used add deploy deploy c zeroadmin template.sda version rule all . For merely changing the template.xml in template SDA version rule all may be specified to force a redeployment. Also since the server may be restarted the redeployment also works for offline deployments. Furthermore since no feedback is received if the deployment fails a DeployView plug in may be used as provided by SAP AG.

In one embodiment the deployment of templates as described with reference to may be performed at the time of installation while the activation of templates may be performed at anytime. For example the activation of templates includes changing the active templates which can be done anytime. Further a tool e.g. command line tool may be provided for certain users e.g. internal users to help list all available templates from which one or more templates may be selected for activation.

In one embodiment a configuration template may contain 1 instance layouts e.g. configurations relating to a number of server nodes running on the corresponding instance 2 VM configurations containing VM or JVM memory settings and parameters and 3 kernel configurations containing system independent properties of the manager components of an engine e.g. J2EE engine 4 service settings containing system independent service properties of each service component 5 application configurations having system independent application configurations of each application which is part of the installation and 6 runtime filter configurations including configurations for enabling and disabling components according to the assigned usage.

At processing block configuration templates are then deployed at the configuration database. In one embodiment the deployment of configuration templates is performed at the time of installation. Furthermore the deployment of templates includes the mapping of the templates residing at the archive to the configuration database. At the configuration database each system instance is assigned to a configuration template based on the usage of the corresponding instance as the configuration templates are activated at processing block . It is contemplated that the templates described here are used as examples of usage templates and that the actual templates are not limited to the examples described herein.

The illustrated embodiment of enterprise system includes one or more clients communicatively coupled to one or more application server AS instances which are in turn communicatively coupled to one or more database . User interface provides a GUI to enable users of clients to interact with databases e.g. submit queries input data etc. through AS instances .

AS instances may each include business components presentation components and integration components which together form subcomponents of an AS e.g. WebAS by SAP AG . Business components provide the business logic of AS instance enabling complex business processes to be implemented. In a J2EE environment business components may include one or more Enterprise JavaBean EJB containers each including one or more EJBs. EJBs are JAVA based software modules that contain the actual business logic while EJB container encapsulates the EJBs in a JAVA based runtime environment that provides a host of common interfaces and services to the EJBs.

Presentation components describe the specific manner in which the results of business components are formatted for display on user interface . The results may be formatted with aid of a web container that supports both servlets and JavaServer Pages JSPs . The servlets provide server side processing to generate the GUI and the JSPs are extensions of the JAVA servlet technology for providing dynamic content within the GUI. For example in WebAS the servlets may include SAP Enterprise Portal which provides a uniform and personalized access to various different back end systems via a browser Web Dynpro which uses JSPs to provide a development and runtime environment for Web applications or other presentation logic.

Integration components enable access to business functionalities from external resources. This is done using various services connectors middleware communication protocols and support for general data exchange formats e.g. extensible markup language . For example integration components may contain support for the following services JAVA Database Connectivity JDBC API the JAVA Naming and Directory Interface JNDI JMS the JAVA Transaction Service JTS the JAVA Transaction API JTA the J2EE Connector Architecture JCA and the like.

A template configuration tool may provide configuration of templates corresponding to any or all of the components of enterprise system described above including the business presentation and integration components. Furthermore template configuration tool may be used to configure the underlying engines that operate these components. These underlying engines may be various types of JVMs such as the J2EE engine. In one embodiments template configuration tool may be used to configure applications within clients various components of database a dispatcher for distributing work requests between AS instances or an internal dispatcher within each AS instance a message server and the like.

One or more modules within or associated with the architectures and methodologies discussed above may include hardware software and or a combination of these. In a case where a module includes software the software data instructions and or configuration may be provided via an article of manufacture by a machine electronic device hardware. An article of manufacture may include a machine accessible readable medium having content to provide instructions data etc. The content may result in an electronic device for example a filer a disk or a disk controller as described herein performing various operations or executions described. A machine accessible medium includes any mechanism that provides i.e. stores and or transmits information content in a form accessible by a machine e.g. computing device electronic device electronic system subsystem etc. . For example a machine accessible medium includes recordable non recordable media e.g. ROM RAM magnetic disk storage media optical storage media flash memory devices etc. as well as electrical optical acoustical or other form of propagated signals e.g. carrier waves infrared signals digital signals etc. etc. The machine accessible medium may further include an electronic device having code loaded on a storage that may be executed when the electronic device is in operation. Thus delivering an electronic device with such code may be understood as providing the article of manufacture with such content described above. Furthermore storing code on a database or other memory location and offering the code for download over a communication medium via a propagated signal may be understood as providing the article of manufacture with such content described above.

The architectures and methodologies discussed herein may be implemented with various types of computing systems such as an application server that includes a J2EE server that supports EJB components and EJB containers at the business layer and or Servlets and JSP at the presentation layer . Of course other embodiments may be implemented in the context of various different software platforms including by way of example Microsoft .NET Windows NT Microsoft Transaction Server MTS the ABAP platforms developed by SAP AG and comparable platforms.

Throughout the description for the purposes of explanation numerous specific details are set forth to provide a thorough understanding of the embodiments of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.

Numerous specific details such as logic implementations opcodes resource partitioning resource sharing and resource duplication implementations types and interrelationships of system components and logic partitioning integration choices are described herein to provide a more thorough understanding of various embodiments of the present invention. It will be appreciated however to one skilled in the art that the embodiments of the present invention may be practiced without such specific details based on the disclosure provided. In other instances control structures gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate functionality without undue experimentation.

As used herein references to one or more embodiments are understood as describing a particular feature structure or characteristic included in at least one implementation of the invention. Thus phrases such as in one embodiment or in an alternate embodiment appearing herein describe various embodiments and implementations of the invention and do not necessarily all refer to the same embodiment. However they are also not necessarily mutually exclusive. Descriptions of certain details and implementations follow including a description of the figures which may depict some or all of the embodiments described below as well as discussing other potential embodiments or implementations of the inventive concepts presented herein.

The processes explained above are described in terms of computer software and hardware. The techniques described may constitute machine executable instructions embodied within a machine e.g. computer readable medium that when executed by a machine will cause the machine to perform the operations described. Additionally the processes may be embodied within hardware such as an application specific integrated circuit ASIC or the like. The order in which some or all of the process blocks appear in the processes should not be deemed limiting. Rather one of ordinary skill in the art having the benefit of the disclosure will understand that some of the process blocks may be executed in a variety of orders not illustrated.

Similarly it should be appreciated that in the foregoing description of exemplary embodiments of the invention various features of the invention are sometimes grouped together in a single embodiment figure or description thereof for the purpose of streamlining the disclosure aiding in the understanding of one or more of the various inventive aspects. This method of disclosure however is not to be interpreted as reflecting an intention that the claimed invention requires more features than are expressly recited in each claim. Rather as the following claims reflect inventive aspects lie in less than all features of a single foregoing disclosed embodiment. Thus the claims following the detailed description are hereby expressly incorporated into this detailed description with each claim standing on its own as a separate embodiment of this invention.

In addition to what is described herein various modifications may be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

