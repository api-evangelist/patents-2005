---

title: Utilities for deriving values and information from within an interlocking trees data store
abstract: A method for accessing a KStore including at least one K path having at least one subcomponent node and at least one root node includes providing a utility routine and accessing the KStore using the utility routine. The accessing may include traversing the at least one K path. The at least one K path includes a further node and bidirectional links between the at least one subcomponent node and the further node. The method includes traversing between the at least one subcomponent node and the further node by way of the bidirectional links. The further node can be a beginning of thought node, an end of thought node, root node, or a subcomponent node. A location may be determined within the KStore. The K Store may be queried. Searches for information within the KStore may be performed. The KStore may be traversed to constrain and focus the KStore. The KStore may be updated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07676477&OS=07676477&RS=07676477
owner: Unisys Corporation
number: 07676477
owner_city: Blue Bell
owner_country: US
publication_date: 20051024
---
This invention relates to computing and in particular to the field of data structures such as interlocking trees datastores.

Practically in the field of computer programming utilities are programs that perform very specific tasks usually related to managing system resources but may perform other practical functions as well. Within the realm of traditional relational databases utilities used to query tables within databases in order to retrieve update or track data are fairly common in the art. For example U.S. Pat. No. 6 643 649 entitled Utility for cross platform database query teaches a utility for cross platform database query where the utility resides at an object server in a data system. The utility obtains a set of data items from a library server in the data system places the set of data items from the library server in a temporary table at the object server obtains each data item from the temporary table and the base object table and converts each data item from the temporary table and the base object table if a conversion is required such that each data item from the temporary table and the base object table may be compared.

Specifically in terms of retrieving data from within a database U.S. Pat. No. 5 129 082 entitled Method and apparatus for searching database component files to retrieve information from modified files teaches a method where each database component file contains information regarding the text contained in the source file which enables the user to quickly determine the frequency of occurrence of the specified text and the location of the specified text in the source file.

Updating data in traditional relational databases is addressed in U.S. Pat. No. 6 564 215 entitled Update support in database content management. This patent teaches a method for updating data objects that are maintained in data storage external to a database management system DBMS . Also U.S. Pat. No. 4 648 036 entitled Method for controlling query and update processing in a database system teaches a method of performing update transactions in a database system to preserve consistent logical data states at all times.

Determining locations within databases is another function of utilities. For example U.S. Pat. No. 6 697 797 entitled Method and apparatus for tracking data in a database employing last known location registers teaches a data tracking scheme that employs a last known location register as a part of a data block s ID.

While producing satisfactory results in traditional relational databases the methods cited above do not apply to KStore technology.

A method for accessing or updating a KStore also referred to herein as a K Store or just K including at least one K path having at least one subcomponent node and at least one root node includes providing at least one utility routine and accessing the KStore using the at least one utility routine. The accessing may include traversing the at least one K path. The at least one K path includes a further node and bidirectional links between the at least one node and the further node. The method includes traversing between the at least one node and the further node by way of the bidirectional links. The further node can be a beginning of thought node BOT an end of thought node EOT root node or a subcomponent node A location may be determined within the KStore. The K Store is queried. Searches for information within the KStore may be performed. The KStore may be traversed to constrain and focus the KStore. The K Store may be updated.

The KStore technology addresses the problems associated with traditional relational databases. As described in copending U.S. patent application Ser. Nos. 10 385 421 filed Mar. 3 2003 and entitled System and method for storing and accessing data in an interlocking tress datastore published as US Patent Application Publication No. 20040181547 A1 Sep. 16 2004 and for which U.S. Pat. No. 6 961 733 was granted Nov. 1 2005 and copending Ser. No. 10 666 382 filed Sep. 19 2003 and entitled System and method for storing and accessing data in an interlocking trees datastore published as US Patent Application Publication No. 20050076011 A1 Apr. 7 2005 and for which U.S. Pat. No. 7 158 975 was granted Jan. 2 2007 both by Mazzagatti the KStore structure eliminates the distinction between transactional data and stored relational data.

With the development of the KStore technology there is a need for utilities to access the unique interlocking trees datastore and provide information from within the K to other internal procedures for use in handling requests from external applications data sources and GUIs.

We have developed a system and various methods for creating and accessing interlocking trees datastores and various features of said interlocking trees datastores. We refer to an instantiation of these interlocking trees datastores that we have developed as a KStore or just K . In particular these structures and methods have been described in U.S. patent application Ser. Nos. 10 385 421 published as US Patent Application Publication No. 20040181547. A1 Sep. 16 2004 and for which U.S. Pat. No. 6 961 733 was granted Nov. 1 2005 and Ser. No. 10 666 382 published as US Patent Application Publication No. 20050076011. A1 Apr. 7 2005 and for which U.S. Pat. No. 7 158 975 was granted Jan. 2 2007 . Additionally we described a system in which such interlocking datastores could more effectively be used in unpublished U.S. patent application Ser. Nos. 10 879 329 filed on Jun. 29 2005 and entitled Functional operations for accessing and or building interlocking trees datastores to enable their use with applications software. While the system and method we describe in this patent relate with particularity to the specific interlocking trees datastores which inventor Mazzagatti hereof described in the above referenced patent applications it should be readily apparent that the system and methods described herein may also be applicable to similar structures.

The invention described herein below related to interlocking trees datastores a structure described in prior patent applications and can be readily used by and adapted to devices described in patent applications U.S. patent application Ser. No. 10 759 466 filed on Jun. 16 2004 and entitled Saving and restoring an interlocking trees datastore now published as US Patent Application Publication No. 20050165749 A1 which is for use with such interlocking trees datastores.

As explained in the above mentioned patent documents a KStore structure can be built within the memory of a computer system or computer systems. Depending on the amount of data loaded into K the KStore structure and the amount of computer memory used can be quite large. As well the more nodes there are in the data structure the more nodes will be searched during a query of the data. The more nodes searched the more time it takes to provide an answer to the query.

The invention described herein overcomes the inherent limitations associated with the prior art by providing a series of KStore utilities which are a group of programming routines or procedures or potentially hardware or some other as yet unidentified medium that are called and used repeatedly within KStore to access update traverse and search the structure resulting in the return of information from the structure to other routines for processing if required.

As taught in unpublished U.S. patent application Ser. No. 10 879 329 we have integrated KStore components into a system that is facile at handling data for nearly any desired use. While the above mentioned patent taught how the components of the KStore system integrate in order to understand the topic of this current invention a brief summary of the KStore system is presented below.

In a preferred embodiment data coming into KStore can be learned formed into an interlocking tree structure K and read into computer memory. Refer to . shows a block diagram representation illustrating the interaction of the main components that can be used in preferred embodiments of this invention. Generally the KStore interlocking trees datastore can be built into a relatively fixed structure within the memory of a computer system or computer systems although a memory of a computer system is not necessary. The K can be built using a resource called a K Engine which has a set of rules it applies to data that can be particalized for it and sent to it in order to support the K Engine task of recording the particalized data as events in the KStore. The KStore itself can be accessed to answer queries about the data preferably using resources such as the API Utility either directly or by way of the Utility . The API utility can be accessed by a user by way of the GUI and the applications of Layer . A user can also use the GUI and the data source applications of Layer in order to use the learn engine with the KEngine and the K directly or by way of the Utility . These procedures are described in more detail in the above referenced patent documents.

Additionally the KEngine can provide output according to the information received from the KStore . The output can be displayed on a graphical display device not shown . Furthermore input can be received and information can be determined by the KEngine simultaneously with the building or testing of the KStore . For example the KStore can be built from a data source . Any number of threads can be streamed simultaneously from the data source to the KStore by way of a learn engine within the KStore system . Additionally the data source can be another KStore a data repository storing data records from a dataset or another KStore or any other source of record sets suitable for storage in the KStore . In a preferred embodiment of the invention input from the application program interface utility and the learn engine can be received by the utility . The utility can include any routines useful for performing tasks within the KStore such as routines for receiving particles and traversing the interlocking trees datastore within the KStore

In addition to the set of routines to access the KStore structure and return information for processing taught in U.S. patent application Ser. No. 10 666 382 published as US Patent Application Publication No. 20050076011 A1 Apr. 7 2005 and for which U.S. Pat. No. 7 158 975 was granted Jan. 2 2007 many other utility routines that derive values and other information from within an interlocking trees datastore can be developed and programmed by those skilled in the alt. U.S. patent application Ser. No. 11 258 292 filed on Oct. 24 2005 entitled API to KStore interlocking trees datastore which is owned by the Assignee of the instant application teaches the application programming interface API which includes the API Utility and the Learn Engine . API enables user programmers to develop and execute multiple application programs without having to understand the processes required to traverse and return address locations within a KStore interlocking trees datastore. The present invention includes the utility routines that are not visible to end users. The present invention also includes utilities that are located anywhere in the KStore system whether they are visible to end users or not if they are used to access and derive K values or information from the KStore structure or perform other tasks upon the information in the KStore . In a preferred embodiment however utilities that are visible to end users never permit node locations or addresses or K location pointers out of level or layer . The utility tasks of the present invention can include for example querying accessing traversing searching or other tasks required for managing KStore resources.

In the field of computer programming a utility is a program that performs a specific task for example a task related to managing system resources. Operating systems contain a number of utilities for managing disk drives printers and other devices. Utilities differ from applications mostly in terms of size complexity and function. For example word processors spreadsheet programs and database applications are considered applications because they are large programs that perform a variety of functions not directly related to managing computer resources. In the current embodiment KStore utilities are a group of programming routines or procedures or potentially hardware or some other as yet unidentified medium that are called and used repeatedly when the KStore structure is accessed updated traversed and searched resulting in the return of information from the structure to other routines for processing if required. We have chosen to differentiate between those utilities visible to end users such as API utilities and those not visible to the end user such as the utilities described within this patent.

In the current embodiment we identify sets of utilities that perform different functions. It should be noted that these do not make up the complete set of potential utilities that will be integrated within KStore. Those skilled in the art will recognize that many other utilities can be programmed and integrated into the space identified in KStore system as Utility .

As mentioned above within the current embodiment there are sets groups of utilities. The main function that ties all of these utilities together is that they can all work to access a KStore datastore in order to derive values and information from within the structure and return information to other routines. The following are examples of utilities 

Each of these groups contains one or more utilities that function to perform a specific task. In the following discussion we will define what each group of utilities does.

The utilities in this group retrieve information from a K structure. This may be accomplished by traversing a KStore structure finding values or returning information to other system components and applications which may in turn supply the information to users. The utilities within this group can be further subdivided into at least the following sub groupings according to the functions they accomplish retrieve particle values and retrieve structure information.

The retrieve particle values sub group contains procedures to obtain values or particle sequences from within a KStore interlocking trees datastore. These procedures may retrieve particle values from single nodes. In the preferred embodiment these single nodes are the elemental root nodes of a K structure.

There are also procedures within this sub group that may return values for entire paths or from between sets of nodes on any level of a K by traversing the structure and returning the associated particle sequences. The structure may be traversed in any manner that is convenient to obtain the particle values.

An example of a procedure in this sub group is one that reconstructs a set of particle data that was previously inputted into K and learned. For example this procedure can obtain the value or particle sequence for end product node . Refer to . From end product node the procedure can traverse the Case path toward the BOT node to subcomponent node . The traversal can be performed by following the pointers of the bidirectional links between the nodes. The procedure can then obtain the particle value S from the elemental root node S through the Result path connection of the subcomponent node . The particle value which in this case is S can be written to a string buffer in memory.

Next the procedure can proceed toward the next node along the path to subcomponent node . As with the subcomponent node the procedure can determine the particle value of the elemental root node associated through the Result path of the subcomponent node . In this case the particle value is T from the elemental node . The procedure can write this value to a string buffer in memory as it did with the first node. This process can be continued at each node in the path between the end product node and the BOT node writing each value to the string buffer. In this way input can be reconstructed by traversing the Case path finding all of the values or particles of data for the path and writing them to string buffer memory. The particle sequence or values in the string buffer can then be presented to the user used in a calculation or any other process or procedure commonly used in computer operations.

The logic of this procedure is shown in . An end product node such as the end product node is found as shown in block . The procedure can traverse the Case path from the located end product node to reconstruct the particle values as shown in block . If a node located during the traversal is not the BOT node as determined in decision the value can be added to the string buffer as shown in block . If the node is the BOT node the procedure ends.

This procedure can be used to reconstruct multiple input sequences by starting at a higher level in K and traversing from higher to lower end product nodes using the Result bidirectional pointers. For example to reconstruct a multiple input sequence in the KStore of a traversal from the end product node toward the BOT node can be performed. The subcomponent nodes and can be traversed to reconstruct the particle sequence CATS ARE FURRY. The procedure traverses from the subcomponent nodes and to the end product nodes and respectively. The process can be continued from each end product node and toward the BOT node until all values or particle sequences are reconstructed. It should be noted that because the nodes are traversed from the end product node toward the BOT node letters or words are written to the string buffer in reverse order.

Note that particle values may be any digitized data. Digitized data may be returned as sound pixels or other like values.

The retrieve structure information sub group can find and return specific information about the interlocking trees structure. This may include but is not limited to the number of nodes in a specific asCase list or asResult list the location of nodes in relation to other nodes or information from additional fields that may be contained within the nodes. One of the procedures can return the value in the count field of each root node for the field values associated with a specific column within a K. For example assume that for the field salesperson in an exemplary data set there are two values Bill and Tom. The procedure can determine the count or the number of times each of these values has been recorded within the structure.

The utilities in this group can update individual nodes which may include fields information or counts or sets of nodes in a K structure. The utilities within this group are subdivided in the current embodiment into at least the following sub groupings according to the functions they accomplish updating K by adding removing and modifying nodes and update fields within nodes.

The update K sub group can provide a method to add change remove or rearrange nodes within an existing structure. Another example procedure in this sub group adds new nodes to the end of a path. A preferred method to update K is taught in U.S. patent application Ser. No. 11 258 296 filed on Oct. 24 2005 and published as 20070162508 on Jul. 12 2007 entitled Updating Information in an Interlocking Trees Data Store which is owned by the Assignee of the instant application.

Fields can be changed in any way for example by changing the values of fields changing Case Result asCase and asResult pointers. As well additional fields within nodes can be updated and changed.

To understand some of the importance of updating fields within nodes one must understand that all nodes of an interlocking trees data store may also include additional fields representing information associated with said nodes. As taught in U.S. patent application Ser. No. 10 666 382 published as US Patent Application Publication No. 20050076011 A1 Apr. 7 2005 and for which U.S. Pat. No. 7 158 975 was granted Jan. 2 2007 the nodes within an interlocking trees datastore may have additional fields. This may be illustrated using . The subcomponent and elemental root node fields are shown as fields in a block of fields for teaching purposes. An exemplary node is shown in . A node may contain a value elemental root node or a count field . The count field may be initialized and incremented with an intensity variable whose value can vary with conditions at times when the count field is being referenced. A simple example form of an intensity variable would be a single ordinal field value such as 1 to be used to increment or decrement count fields to record the number of times that a node has been accessed or traversed. In the current embodiment there are procedures to update and modify the numeric count within count fields . There can be many uses for additional fields and the nodes such as node need not be limited to one additional field .

There are other procedures to update information in individual nodes and others to update fields in a node. For example there are procedures to lock a node by setting a value in a lock field that can be provided within a node and procedures to reorganize lists pointed to by pointers from within a node. A preferred method for locking a node is taught in U.S. patent application Ser. No. 11 185 620 filed on Jul. 20 2005 and published as 20060101018 on May 11 2006 entitled Method for Processing New Sequence Being Recorded in an Interlocking Trees Datastore which is owned by the Assignee of the instant application.

Those with knowledge of the KStore interlocking trees datastore structure will recognize that there are many potential reasons to update and modify fields in nodes. One example is taught in application Ser. No. 11 258 296 filed on Oct. 24 2005 and published as 20070162508 on Jul. 12 2007 entitled Updating Information in an Interlocking Trees Data Store which is owned by the Assignee of the instant application.

This group of utilities can traverse and determine locations in a KStore known as K locations pointers. Location pointers are discussed in U.S. patent application Ser. No. 11 100 830 published as U.S. Patent Application Publication No. 20060074939 Apr. 1 2007 and entitled Facilitated reuse of k locations in a knowledge store. 

The utilities within this group can be further subdivided according to the functions they accomplish into at least the following sub groupings determine K locations from particle sequences and determine K locations from other nodes.

These utilities use particalized data and call the KEngine which returns locations in K. Routines in this sub group are used in different ways to find nodes associated with a given particle sequence. One example utility is called masking to permit locating structure within a KStore. The masking utility may be used to determine a set of K paths in a KStore that satisfies an input sequence including a plurality of particles. This method can include receiving the input sequence by the KStore processing the input sequence by the KStore and determining the set of K paths in accordance with the input sequence. The method can also include determining whether a selected particle of the plurality of particles is a mask. If the selected particle is a mask a mask type is determined and an initial set of K paths is determined in accordance with the mask type. Masking is taught in as yet unpublished U.S. Ser. No. 11 132 490 entitled Variable masking and filed on May 18 2005.

Given a node these routines can find other nodes based on certain criteria. For example one exemplary routine can search through a node s asCase list for a node with a specific Result pointer.

Another routine finds associated root or end product nodes at various levels in an interlocking trees structure which are associated with another node or set of nodes. Assume we have a root node for a field. We may then determine all record paths by end product nodes that contain pointers to that field.

Constraining utility groups determine K locations from particle sequences and determine K locations from other nodes. First the node associated with the particle sequence for the constraint can be found. Then using that root node all paths or record end product nodes associated with the constraint root node may be found. For example this routine could obtain the pointer location for the node for the variable Sold. Using this node the list of all end product node paths that contain the variable Sold can be located in the asResult list as shown in as the dotted lines leading from Sold node . The resulting list of end product nodes and of each record that contains Sold may then be used to sum a sales value column to obtain a total sales value. Additionally the set of Sold record end product nodes can be further reduced to the set of Sold end product nodes for a particular product Sofa by traversing the paths of each end product node and eliminating the paths that do not contain Sofa. 

