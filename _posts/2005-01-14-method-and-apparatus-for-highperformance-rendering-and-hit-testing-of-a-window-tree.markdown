---

title: Method and apparatus for high-performance rendering and hit testing of a window tree
abstract: A method and apparatus for high-performance rendering and hit-testing of a window tree is provided. A window tree may be rendered using an application programming interface provided by the present invention. The application programming interface provides support for world-transforms, enabling entire sub-trees of the window tree to be rotated and scaled during rendering. In order to quickly render and hit-test the transformed nodes of the window tree, a stack-based implementation of the “painter's algorithm” is utilized to achieve fast rendering. By storing all state information on a stack regarding each node in the window tree and building new data structures containing rendering information for each node and its children, any portion of the sub tree may be rendered on demand.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07453473&OS=07453473&RS=07453473
owner: Microsoft Corporation
number: 07453473
owner_city: Redmond
owner_country: US
publication_date: 20050114
---
This application is a continuation of U.S. application Ser. No. 09 885 350 filed Jun. 20 2001 the benefit of the filing date of which is hereby claimed under 35 U.S.C. 120. U.S. application Ser. No. 09 885 350 claims the benefit of U.S. Provisional Application No. 60 244 287 filed Oct. 30 2000 under 35 U.S.C. 119 which benefit is also claimed for this application. Both of these applications are expressly incorporated herein by reference.

This invention generally relates to the field of computing devices with graphical user interfaces. More specifically this invention relates to rendering and hit testing windows within a graphical user interface environment.

Graphical user interfaces typically employ some form of a window manager to organize and render windows. Window managers commonly utilize a window tree to organize windows their child windows and other objects to be displayed within the window such as buttons menus etc. To display the windows on a display screen a window manager parses the window tree and renders the windows and other objects in memory. The memory can then be displayed on a video screen. A window manager may also be responsible for hit testing input to determine the window in which input was received. For instance when a user moves a mouse cursor into a window and mouse clicks the window manager must determine the window in which the click was made and generate a message to that window.

Current window managers suffer from a number of drawbacks that limit their ability to manage a large number of windows and to perform advanced functions. For instance current window managers suffer from severe performance limitations when rendering thousands of windows children or other objects. Moreover these performance limitations impede current window managers from supporting advanced functions on windows such as alpha blending rendering composition and world transforms such as scaling and rotation of sub trees of the window tree.

Therefore in light of the above there is a need for a method and apparatus for rendering a window tree that is optimized to manage a large number of windows and child window objects. There is a further need for a method and apparatus for rendering a window tree that allows advanced functions such as world transforms to be applied to sub trees of the window tree without an impact on system performance.

The present invention solves the above problems by providing a method and apparatus for high performance rendering and hit testing of a window tree. According to an actual embodiment of the present invention an application programming interface API is provided through which a window tree may be rendered. The method and apparatus provides support for world transforms enabling entire sub trees to be rotated and scaled during rendering. This is accomplished by emulating the math done by the rendering component when computing both invalidation intersection and hit testing rectangles. Reusable user interface components otherwise known as Visual Gadgets are implemented without any special knowledge of the transforms. Moreover by programming in virtual pixels the present invention can translate these on demand into physical pixels at the point of rendering invalidation and hit testing.

The present invention also provides support for multiple rendering surfaces. The present invention supports a variety of rendering surfaces including but not limited to Graphics Device Interface GDI HDC s GDIplus Graphics DirectDraw Surfaces and Direct3D objects. By providing an extensible architecture that abstracts out the differences between surfaces the present invention can natively support a variety of different surfaces without requiring that they all support a common denominator. The surface is passed through the rendering pipeline customizing at key places for specific operations and is then passed in the callback to the surface type requested by a Visual Gadget. This allows the present invention to be utilized on platforms other than Microsoft Windows such as Linux or Macintosh which do not support any of these surface types.

The present invention also provides support for origin zeroing. A specific Visual Gadget may request that the present invention zero the origin on the rendering surface. This style may be dynamically changed on any Visual Gadget before and after creation. Although some window managers support either zeroing or not zeroing the origin the present invention supports both dynamically. This provides significant performance gains when zeroing the origin is not required by the Visual Gadget. The ease of programming when zeroing also greatly simplifies control rendering.

The present invention also provides support for trivial painting. Trivial painting allows the present invention to highly optimize the rendering of entire sub trees that meet certain criteria. By examining a single bit on each Visual Gadget when the tree is manipulated the present invention is able to detect trivialness at render time and use an optimized rendering path to render the child sub trees.

The present invention additionally provides stack based painting and read only callback. The present invention utilizes a stack based implementation of the painter s algorithm to achieve very fast rendering. By storing all state on the stack and building new data structures containing rendering information for the node and its children the present invention can render any portion of the sub tree on demand.

Because the present invention calls back to each control to render while traversing the window tree special precautions must be taken to ensure that the tree s state is not changed during the callback. To accomplish this the present invention is implemented in the user mode provided by Microsoft Windows in an actual embodiment of the present invention. This prevents the possibility that the tree s state may change if deadlocks were utilized in Microsoft Windows kernel mode. The present invention also marks the window tree Context as read only allowing only read only API functions to be called and failing any read write API functions. The present invention also does not release the window tree Context Lock preventing other threads from coming into the Context and failing because the Context is marked read only. This provides the added benefits of avoiding the overhead of continuously grabbing and releasing the critical section of the window tree reduces thread contention and improves rendering performance.

The present invention also provides a method computer controlled apparatus and a computer readable medium for providing high performance rendering and hit testing of a window tree.

The present invention is directed to a method and apparatus for providing high performance rendering and hit testing of a window tree. Aspects of the invention may be embodied in a computer executing an operating system capable of providing a graphical user interface. Referring now to the figures in which like numerals represent like elements an actual embodiment of the present invention will be described.

Referring now to an illustrative personal computer will be described. The personal computer comprises a conventional personal computer including a processing unit a system memory and a system bus that couples the system memory to the processing unit . The system memory includes a read only memory ROM and a random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the personal computer such as during start up is stored in ROM . The personal computer further includes a hard disk drive a magnetic disk drive e.g. to read from or write to a removable disk and an optical disk drive e.g. for reading a CD ROM disk or to read from or write to other optical media such as a Digital Versatile Disk DVD .

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage for the personal computer . Although the description of computer readable media above refers to a hard disk a removable magnetic disk and a CD ROM disk it should be appreciated by those skilled in the art that other types of media that are readable by a computer such as magnetic cassettes flash memory cards digital video disks Bernoulli cartridges ZIP disks and the like may also be used in the illustrative operating environment. A number of program modules may be stored in the drives and RAM including an operating system such as Windows 98 Windows 2000 or Windows NT from Microsoft Corporation. As will be described in greater detail below aspects of the present invention are implemented within the operating system in the actual embodiment of the present invention described herein.

Those skilled in the art should appreciate that the term computer readable media as defined herein may include any available media that can be accessed by the personal computer . By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other solid state memory technology CD ROM DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and that can be accessed by the personal computer .

A user may enter commands and information into the personal computer through input devices such as a keyboard or a mouse . Other input devices not shown may include a microphone touchpad joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via a display interface such as a video adapter . In addition to the monitor a personal computer may include other peripheral output devices such as speakers connected through an audio adapter or a printer not shown .

As described briefly above the personal computer may operate in a networked environment using logical connections to one or more remote computers through the Internet . The personal computer may connect to the Internet through a network interface . Alternatively the personal computer may include a modem and use an Internet Service Provider ISP to establish communications with the Internet . The modem which may be internal or external is connected to the system bus via the serial port interface . It will be appreciated that the network connections shown are illustrative and other means of establishing a communications link between the personal computer and the Internet may be used.

Referring now to additional aspects of the operating system will be described. According to the actual embodiment of the invention described herein the operating system comprises the Microsoft Windows 2000 operating system. The operating system comprises a number of components for executing applications and communicating with the hardware that comprises the personal computer . At the lowest level the operating system comprises device drivers for communicating with the hardware . The operating system also comprises a virtual machine manager an installable file system manager and a configuration manager . Each of these managers may store information regarding the state of the operating system and the hardware in a registry . The operating system also provides a 32 bit shell which includes user interface tools. An operating system core is also provided that provides low level functionality and hardware interfaces. According to the embodiment of the present invention described herein aspects of the present invention are implemented in the operating system core . The operating system core is described in greater detail below with respect to .

Turning now to an illustrative operating system core will be described. As mentioned above the Microsoft Windows 2000 operating system provides an illustrative operating environment for the present invention. The operating system core of the Microsoft Windows 2000 operating system comprises three main components the kernel the Graphical Device Interface GDI and the user component . The GDI is a graphical system that draws graphic primitives manipulates bitmaps and interacts with device independent graphics drivers including those for display and printer output devices. The kernel provides base operating system functionality including file I O services virtual memory management and task scheduling. When a user wants to start an application the kernel loads the executable .EXE and dynamically linked library DLL files for the application. The kernel also provides exception handling allocates virtual memory resolves import references and supports demand paging for the application. As an application runs the kernel schedules and runs threads of each process owned by an application.

The user component manages input from a keyboard mouse and other input devices and output to the user interface windows icons menus and so on . The user component also manages interaction with the sound driver timer and communications ports. The user component uses an asynchronous input model for all input to the system and applications. As the various input devices generate interrupts an interrupt handler converts the interrupts to messages and sends the messages to a raw input thread area which in turn passes each message to the appropriate message queue. According to the actual embodiment of the invention described herein each thread may have its own message queue.

In order to manage the output to the user interface the user component maintains a window manager . The window manager comprises an executable software component for keeping track of visible windows and other viewable objects and rendering these objects into video memory such as that provided by a video adapter . The present invention may be implemented as a part of the window manager or may be implemented in a manner so as to provide window manager functionality through an API. Also although the invention is described as implemented within the Microsoft Windows 2000 operating system those skilled in the art should appreciate that the present invention may be advantageously implemented within any operating system that utilizes a windowing graphical user interface.

Referring now to additional aspects of the window manager will be described. The window manager maintains a window tree to keep track of open windows and other visible objects. The window tree describes the window hierarchy in a tree like fashion. According to the actual embodiment of the invention described herein the operating system owns the root of the window tree and reserves the root for the desktop window. The branches and leaves of the window tree represent windows and the viewable objects that comprise the windows. The window tree is organized so that a correct window hierarchy will be rendered when the window tree is walked using the painter s algorithm. The painter s algorithm renders objects as a painter would depth first back to front. The painter s algorithm is well known to those skilled in the art.

Referring now to an illustrative Routine for rendering a window tree will be described. Generally described the Routine provides the beginning of the rendering pipeline. The Routine initializes all states necessary to walk the window tree and initiates a recursive descent of the window tree. More specifically described the Routine begins at block where a read only lock is placed on the window tree. The lock prevents other objects from modifying the window tree while the render is in progress.

The Routine continues from block to block where the rendering surfaces are prepared. This may include clipping to a specified invalidation rectangle to help improve performance by reducing unnecessary painting. This process includes identifying the portion of the screen that needs to be redrawn and limiting the redraw to that portion of the screen. Preparing the rendering surface may also include initializing a translation size. This process comprises determining the portion of the window tree that needs to be redrawn. More particularly this process includes calculating the appropriate node of the window tree at which to begin rendering. In this manner only a portion of the window tree needs to be rendered. Preparing the rendering surface may also include setting up palettes and initializing transformation routines. The Routine then continues from block to block .

At block the Routine determines whether invisible controls or Visual Gadgets should be drawn. If at block it is determined that invisible Gadgets are to be drawn the Routine branches to block where the Gadgets are made visible. The Routine then continues to block . If at block it is determined that invisible Gadgets are not to be drawn the Routine continues from block to block . At block the Routine calls the DRAW FULL routine. The DRAW FULL routine is recursively called for each node to render the sub tree to the given surface. The DRAW FULL routine will be described below with respect to .

From block the Routine continues to block where the visible state of the Visual Gadgets is restored. Routine then continues from block to block where a clean up procedure takes place that may include releasing unused memory etc. The Routine then continues to block where it ends.

Referring now to an illustrative Routine will be described for implementing the DRAW FULL routine described above. The DRAW FULL routine is recursively called for each node with exceptions for trivialness to render the sub tree to the given surface. The Routine begins at block where a determination is made as to whether the control or Visual Gadget at the current node in the window tree is visible. If the gadget is not visible it does not need to be painted. Therefore if the gadget is not visible the Routine branches to block where it returns. If the gadget is visible the Routine continues to block where a PAINT INFO data structure is created to maintain information about the sub tree of the current node in the window tree. The PAINT INFO data structure contains data describing aspects of each sub tree in the window tree. An illustrative PAINT INFO data structure is shown in Table 1 below.

The PRCCURINVALIDPXL element referenced in Table 1 comprises a pointer to a RECT structure for defining the coordinates of the upper left and lower right corners of a rectangle. The PRCCURINVALIDPXL element is utilized to store the coordinates of the invalidation rectangle fully transformed into coordinates relative to the current node of the window tree. As will be described in greater detail below these coordinates may be utilized by intersection calculations to determine whether the sub tree of the current mode needs to be repainted.

The PRCORGINVALIDPXL element referenced in Table 1 also comprises a pointer to a RECT structure. The PRCORGINVALIDPXL element is utilized to store the invalidation rectangle in coordinates relative to the current node. For instance if the Visual Gadget located at the current node has been transformed the PRCORGINVALIDPXL element is used to store the coordinates of the invalidation rectangle in a similarly transformed space. As will be described below a transformation matrix is utilized to transform PRCORGINVALIDPXL into PRCCURINVALIDPXL.

The PSRF variable referenced in Table 1 comprises a pointer to the current surface being rendered into. Each time a buffer is created a new surface is also created for that buffer to render into. The PMATCURINVALID matrix referenced in Table 1 is a matrix created using anti transformations and is utilized in transforming PRCORGINVALIDPXL into coordinates relative to the current node of the window tree. Similarly the PMATCURDC matrix referenced in Table 1 comprises a matrix created using regular transformations to determine the world transforms to be applied to the PSRF variable when rendering the sub tree of the current node. The FBUFFERED element comprises a Boolean variable specifying whether at least one buffer has been created. The FBUFFERED variable is used to determine when a double buffer has been set up.

The Boolean variable FDIRTY referenced in Table 1 is utilized when dirty state optimizations have been enabled to determine whether the current sub tree is dirty as the result of a dirty ancestor node. The variable SIZEBUFFEROFFSETPXL holds the current translation offset to factor in accounting for buffers set up by ancestors.

Still referring to the Routine continues from block to block where known values are copied into the PAINT INFO structure including the surface the original invalid rectangle and other buffering information. The PAINT INFO structure is then allocated on the stack. This allows fast rendering because memory does not have to be allocated while painting. Moreover this allows state information from a parent node to be inherited by the children of the node. This also advantageously provides a performance boost since this information does not have to be recreated at each child node.

The Routine then continues from block to block where a determination is made as to whether a new buffer will be utilized to render the sub tree. A buffer is an off screen memory area that may be modified and later painted into screen memory. Buffering allows flicker free drawing applying alpha for fading and applying bitmap transformations after rendering such as convolution filters. If a new buffer will be used the Routine branches to block where a new buffer is created. The Routine then continues from block to block where the contents of the portion of the screen memory corresponding to the buffer is copied into the buffer. The Routine then continues from block to block .

If at block it is determined that a new buffer will not be used the Routine continues from block to block . At block the bounds of the invalidation rectangle are computed in client coordinates. Although a window should be prepared to update the entire window whenever it receives the appropriate message it often only needs to update a smaller area. This area is most often a rectangular area within the client area. For example this portion of the client area may need to be repainted when the area is overlaid by a dialog box. Repainting is required when the dialog box is removed. This area is known as an invalidation rectangle. The presence of an invalid region in a client area is what prompts the operating system to transmit a message to the window indicating that a repaint is necessary. An illustrative Routine is described below with respect to for computing the bounds of the invalidation rectangle in client coordinates.

The Routine continues from block to block where the intersection between the Visual Gadget located at the current node and the transformed rectangle defined by the PRCCURINVALIDPXL variable is computed. The Routine then continues to block where a determination is made as to whether the gadget needs to be painted based on the results of the intersection. If the gadget does not need to be painted the Routine branches to block where it returns. If the gadget needs to be painted the Routine continues to block where a surface transformation matrix is created. The transformation matrix is utilized to transform the gadget by rotating scaling changing the center location or zeroing the gadget s origin. In this manner the window manager may provide support for world transforms enabling entire sub trees to be rotated and scaled while rendering. This is accomplished by performing the math done by the rendering component when computing both invalidation intersection and hit testing rectangles. The Routine then continues to block where a clipping region is prepared for the sub tree that will be inherited by the children of the current node.

The Routine continues from block to block where deep state information is stored on the stack. Deep state information comprises information that should be inherited only by children from a parent. The Routine then continues from block to block where the DRAW CORE routine is called. The DRAW CORE routine provides a common callback for both DRAW FULL and DRAW CORE to perform the actual rendering of a specific node. An illustrative DRAW CORE routine is described in detail below with respect to .

From block the Routine continues to block where a determination is made as to whether the current gadget is trivial. The trivialness of a gadget is determined by examining a bit associated with the gadget. The bit is set depending upon other properties of the gadget. So for instance the bit may be set if the gadget and its children do not require transformation. According to the actual embodiment of the invention described herein trivialness is defined as a gadget and any of its children having the GS ZEROORIGIN GS CLIPSIBLINGS GS BUFFERED and GS CACHED parameters set to off and not having any transforms applied. If the gadget is trivial the Routine branches to block where the DRAW TRIVIAL routine is called for each child of the current node. The DRAW TRIVIAL routine provides an optimized code path when rendering the children of trivial Visual Gadgets that eliminates the computationally expensive world transforms that are required to zero the origin. An illustrative DRAW TRIVIAL routine is described in greater detail below with respect to .

If at block it is determined that the gadget is not trivial the Routine branches to block where the DRAW FULL routine is called for each child of the current node. In this manner each node of a non trivial sub tree is recursively processed by the DRAW FULL routine. From blocks and the Routine continues to block where the original state information is restored. From block the Routine continues to block where a buffer if created is copied to the destination surface in video memory. From block the Routine continues to block where the buffer is released and the clipping region is cleaned up. At block the Routine returns.

Turning now to an illustrative Routine will be described for computing the bounds of an invalidation rectangle in client coordinates. As described briefly above with respect to in order to determine when a transformed Visual Gadget is within the bounds of an invalidation rectangle the invalidation rectangle must be transformed into coordinates relative to the Visual Gadget. In order to accomplish this task the Routine begins at block where a determination is made as to whether any transformations have been applied at the current node of the window tree. If no transformations have been applied at the current node the Routine branches from block to . At block the current contents of the PRCCURINVALIDPXL variable are utilized for the bounding box. Because no transforms have been applied to the Visual Gadget at the current node the invalidation rectangle for the parent node may be utilized. The Routine then branches to block where it returns to block shown in .

If at block it is determined that transformations have been applied at the current node of the window tree the Routine continues to block . At block the cumulative invalidation matrix PMATCURINVALID is updated using the antitransform of the transform applied to the Visual Gadget at the current node. The Routine then continues from block to block where the invalidation matrix is applied to the PRCORGINVALIDPXL variable to obtain the client coordinates of the new bounding polygon. The Routine then continues to block where a bounding rectangle of the computed bounding polygon is identified. The bounding polygon is then intersected with the bounding rectangle of the Visual Gadget at the current node in the window tree at block . This intersection defines the new invalidation rectangle for the Visual Gadget at the current node of the window tree and is stored in the PRCCURINVALIDPXL variable at block . From block the Routine returns to block shown in .

Turning now to an application of the Routine to an illustrative window tree will be described. As shown in the window tree comprises a root node A a child node B a child node C and a child node D . When the window tree is rendered the Visual Gadget corresponding to the root node A is first rendered. The Visual Gadget corresponding to the child node B is then rendered. Subsequently the Visual Gadget corresponding to the child node C is rendered. Finally the Visual Gadget corresponding to child node D is rendered. As shown in the Visual Gadget corresponding to child node D has been rotated 45 . As will be described in greater detail below the rotation of Visual Gadget must be taken into account when computing the bounds of an invalidation rectangle and when hit testing.

Once the Visual Gadgets shown in have been rendered they may be displayed. Subsequently a window or other Visual Gadget such as the window may be displayed over the top of all or a portion of the Visual Gadgets. For instance the window completely overlays the Visual Gadget and partially overlays the Visual Gadget . When the window is closed or otherwise removed it is necessary to determine a portion of the screen which should be redrawn. To make this determination the Routine described above with reference to is applied at each node of the window tree . With respect to the root node A the child node B and the child node C the bounds of the window may be utilized as the invalidation rectangle because no transformations have been applied to these nodes. However with respect to the child node D the bounds of the invalidation rectangle must be computed in coordinates relative to the Visual Gadget because the Visual Gadget has been rotated.

Although the Visual Gadget is shown visually as having been rotated the Visual Gadget is unaware of the rotation. Instead the Visual Gadget believes that it has been rendered in a normal orientation as shown in . Accordingly an antitransform of the transformation applied to Visual Gadget must be applied to the bounding box defined by the window . In order to accomplish this a cumulative invalidation matrix is created using each of the antitransforms applied at the current node and at any of its parent nodes. This invalidation matrix has been applied to the bounding box for the parent node to obtain the client coordinates of a new bounding polygon . Subsequently a bounding rectangle of the bounding polygon is obtained. The bounding polygon is then intersected with the bounding rectangle of the Visual Gadget to obtain the new invalidation rectangle for the current node. The results of this computation are then stored in the PRCCURINVALIDPXL variable and pushed on the stack. This invalidation rectangle may then be used by children of the current node in order to calculate the transformed invalidation rectangle at those children nodes. The invalidation rectangle may also be passed to the Visual Gadget to determine whether and what portion of the Visual Gadget should be rendered.

Referring now to an illustrative Routine will be described for implementing the DRAW TRIVIAL routine mentioned above. The Routine begins at block where a determination is made as to whether the current Visual Gadget intersects the invalidation rectangle. If the current Visual Gadget does not intersect the invalidation rectangle the Routine branches to block where it returns. If the Visual Gadget intersects the invalidation rectangle the Routine continues block where the clipping region is prepared for the sub tree. The Routine then calls the DRAW CORE routine to perform the actual rendering of the Visual Gadget of the specific node. The Routine then continues to block where the DRAW TRIVIAL routine is again called for each child of the node. At block the clipping region is cleaned up. At block the Routine returns.

Referring now to an illustrative Routine for implementing the DRAW CORE routine will be described. The Routine begins at block where the background is drawn as the intersection of the Visual Gadget bounds and the invalidation rectangle. From block the Routine continues to block where the control is called to perform the customized drawing of the gadget. The Routine then continues to block where it returns.

In addition to rendering the window tree the window manager also provides functionality for hit testing input. When movement of a mouse cursor or a mouse click is received a message is generated comprising the coordinates of the movement or click and transmitted to the window manager . In order to relay the message to the appropriate window and or Visual Gadget the window manager must make a determination as to which Visual Gadget should receive the message. Because the window manager provides for the translation and or transformation of nodes in the window tree that is unknown to the corresponding Visual Gadget the window manager must take these translations into account when determining which gadget should be notified of the input. The FIND FROM POINT routine described below with reference to provides this functionality. The window manager must also be able to convert container coordinates into client coordinates relative to another Visual Gadget. The DIRECT POINT routine provides this functionality and is described below with reference to . It may also be necessary to convert coordinates relative to one Visual Gadget into coordinates relative to another Visual Gadget. The MAP POINTS routine provides this functionality and is described below with reference to .

Referring now to an illustrative Routine will be described for implementing the FIND FROM POINT routine mentioned above. As discussed briefly above the FIND FROM POINT routine takes the coordinates of a point and returns the identity of the Visual Gadget in which the point is located taking transformations and translations into account. The Routine begins at block where the location of the input point is received in container coordinates. The Routine then continues to block where the CURRENT NODE variable is set to the node at the top of the window tree or sub tree. From block the Routine continues to block where a determination is made as to whether the point is in the Visual Gadget identified by the current node. If the point is not in the Visual Gadget identified by the current node the point is also not in any of the Visual Gadgets identified by the node s children so the Routine branches to block where it ends. If the point is in the Visual Gadget identified by the current node the Routine continues from block to block where any translation or transformation required at the node is applied to the input point. In this manner the input point is translated or transformed into the same space as the visual object identified at the current node.

From block the Routine continues to block where a determination is made as to whether the current node has children. If the current node does not have any children the Routine branches to block . Arrival at block indicates that the point must be in the current node and therefore the current node is returned. The Routine then continues to block to block where it ends.

If at block it is determined that the current node has children the Routine continues to block where a test is made of a child of the current node. The Routine then continues from block to block where a determination is made as to whether the point is located within the child of the current node. If the point is not located within the child the Routine branches to block where a determination is made as to whether the current node has additional children. If the current node has no additional children the Routine branches to block . Arrival at block indicates that the point is in the child node and the identity of the child node is returned. The Routine then continues from block to block where it ends. If at block it is determined that the current node has additional children the Routine continues to block where the next child is identified. The next child is then tested at blocks and in a similar fashion as that described above.

If at block it is determined that the point is within the child node the Routine continues to block where the CURRENT NODE variable is set to the child node. The Routine then returns to block where the child node is tested in a similar manner to its parent. In this manner the window tree is iteratively parsed to identify the child that contains the input point.

Referring now to an illustrative Routine will be described for implementing the DIRECT POINT routine. As mentioned briefly above the DIRECT POINT routine converts container coordinates that are in a known Visual Gadget into coordinates relative to the Visual Gadget. The Routine begins at block where the identity of the node containing the Visual Gadget and the container coordinates are received. From block the Routine continues to block where the window tree is traversed from the identified node to the root pushing each node on the stack. From block the Routine continues to block where the window tree is traversed from the root back down to the identified node. At each node the properties relating to the node are popped off of the stack and the coordinates of the point are converted into coordinates relative to the node. In this manner the container coordinates are converted into coordinates relative to the identified Visual Gadget. The Routine ends at block .

Referring now to an illustrative Routine for implementing the MAP POINTS routine will be described. As mentioned briefly above the MAP POINTS routine converts coordinates relative to one Visual Gadget in the window tree into coordinates relative to another Visual Gadget in the window tree. The Routine begins at block where the coordinates are received. The Routine continues to block where the window tree is traversed from the node identifying the Visual Gadget from which the coordinates are to be converted to the parent of the Visual Gadget to which the coordinates are to be converted. At each node any necessary translation or transformation is applied.

From block the Routine continues to block where the window tree is traversed from the nearest parent to the node identifying the Visual Gadget to which the coordinates are to be converted. At each node appropriate translations and transformations are applied. In this manner the coordinates of a point relative to one Visual Gadget in the window tree may be converted to coordinates relative to another Visual Gadget taking translations and transformations into account.

In light of the above it should be appreciated by those skilled in the art that the present invention provides a method apparatus and computer readable medium for providing high performance rendering and hit testing of a window tree. While an actual embodiment of the invention has been illustrated and described it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.

