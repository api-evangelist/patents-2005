---

title: Optimal program execution replay and breakpoints
abstract: A method of replaying a recorded sequence of execution steps of a computer program or system to a selected target step while taking a minimal number of execution breaks includes calculating, for each of the steps, a predecessor step that can be reached in a minimal number of execution breaks. The total calculation time for the entire execution is linear in the number of steps, and allows subsequent calculation of an optimal path to any selected step to be obtained in time linear in the length of the optimal path.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07644396&OS=07644396&RS=07644396
owner: Microsoft Corporation
number: 07644396
owner_city: Redmond
owner_country: US
publication_date: 20051129
---
When analyzing or debugging a computer program or system it is often necessary to restore the system to a state that it was in at an earlier point in time typically to examine that state or to change the subsequent behavior of the system. Two examples of diagnostic techniques that use this capability are backwards debugging and stateless search.

There are several well known methods for representing and restoring system states. One method is to explicitly save entire states or those parts of the state that are modified later in the execution . This makes restoration of the state relatively cheap but each saved state requires substantial time to record and memory space to store. A second method is to record the steps of the execution and how to undo each and to restore the system to a previous target state by undoing all intervening steps in reverse order. This makes restoration easy if the target state is not many steps from the current state. However gathering and storing the required information about each step is relatively expensive and restoring states from the distant past is inefficient. A third method is to represent a state by the computation needed to bring the program to that state. For example a state of a deterministic sequential program can be represented by the initial program state and the number of steps that have been executed to arrive at that state for a concurrent or nondeterministic program representing a state also requires recording all of the scheduling choices or nondeterministic choices made along the way. The process of re executing the program from an initial execution state to a desired target state is called replaying the execution.

The replay approach has several advantages. It requires gathering and storing only an initial state and relatively little information about the execution. However a disadvantage of the replay approach is that replaying a long execution can take substantial time. It is therefore important to make the replay as efficient as possible. One partial mitigation is to periodically checkpoint the state and to replay the execution from the latest checkpoint in this case more efficient replay allows these checkpoints to be taken less often.

The main challenge in efficient replay is stopping the execution precisely at the desired target step. The usual way to do this is to use preexisting facilities that allow the program to be interrupted when certain configurable conditions arise. For example some CPUs allow program execution to be single stepped causing execution to break into a monitor after every step of the execution. Unfortunately each break into the monitor is expensive in terms of execution time and so it is important to minimize the number of interrupts taken during replay. Thus the simplest solution to the replay problem single stepping the program for an appropriate number of instructions is usually too inefficient.

An alternative is to set more specific breakpoints causing execution to break into the monitor on more specific conditions. For example some CPUs provide hardware breakpoints that cause execution to break when a specified memory location or I O port is used for a specified operation such as a read write or instruction fetch. A more efficient alternative to single stepping is to set a breakpoint either on the code of the target step or on data accessed by the target step. But if the target step is in a tight loop or if it manipulates frequently accessed data the replay may still take many interrupts before arriving at the target step.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In one aspect of the invention an execution is preprocessed for subsequent replay by calculating two arrays as follows. The first array gives for every target step of the execution the earliest step of the execution for which there is some breakpoint setting that will cause execution starting at the earlier step to next break at the target step. The second array gives for each target step of the execution an optimal predecessor step of the execution that is both reachable in a shorter sequence of breaks than the target step and can reach the target step in a single break. Both arrays can be calculated in time linear in the length of the execution. Finally an optimal sequence of breakpoint settings to take control from the initial step to a target step other than the initial step is given by calculating the optimal sequence of breakpoint settings to get from the initial step to the optimal predecessor of the target step as given in the second array followed by a single additional breakpoint setting to get from the optimal predecessor to the target step.

One possible improvement to the concept of setting breakpoints in a system to replay to a particular state is to change breakpoint settings dynamically during replay. For example if the target step is in a tight loop it might be more efficient to first set a breakpoint on a step that occurs less often than the target step and switch to a breakpoint on the target step only when execution approaches the target step.

One aspect of the present invention is to compute given suitable information recorded from an execution an optimal strategy for dynamically changing breakpoints or control mechanisms with equivalent functionality to replay the execution to a desired target step. The calculated strategy is optimal in the sense that no other dynamic strategy of the same kind can result in fewer program breaks. The invention requires preprocessing time that is linear in the length of the recorded part of the execution and for each execution replay requires time linear in the length of the minimal length breakpoint strategy generated for that replay. It is thus also optimal in terms of computational effort.

According to an aspect of the current invention the first step in the construction of an optimal breakpoint strategy is to construct a suitable array of length N hereafter referred to as the breakpoint array where the i th element of the array includes a number l i where 0 l i 

A suitable breakpoint array can be constructed in several ways. In one embodiment of the invention the program is single stepped and a dictionary data structure such as a hash table is used to store for each breakpoint setting that would cause a break for a previous step of the execution the latest previous step at which the setting would cause such a break. After the i th program step each breakpoint setting that would cause a break at step i is looked up in the dictionary. If any of these breakpoint settings is not in the dictionary l i is set to 0 and b i is set to a breakpoint setting not in the dictionary otherwise b i is set to the breakpoint setting with minimum lookup value and l i set to the corresponding lookup value. Also for each of the looked up breakpoint settings the dictionary value for that setting is set to i. In another embodiment a set of suitable candidate breakpoint settings e.g. accesses to a chosen set of memory locations is chosen in advance and the program is run with breaks taken on all such breakpoints with calculations done as above. This embodiment can result in shorter breakpoint arrays at the cost of less optimal breakpoint path calculations. In another embodiment elements of b are sequences of breakpoint settings rather than individual breakpoints settings allowing a hierarchical calculation of breakpoint settings. Other embodiments may be devised by those skilled in the art.

Given a suitable breakpoint array the calculation of an optimal breakpoint strategy can be expressed as the following problem. For each i 0

One naive method to compute a suitable p is to calculate d and p together using an algorithm like the following given in the C programming language 

But this algorithm can in the worst case require the computation time quadratic in N. Similarly phrasing the problem as a shortest path problem yields an algorithm that is quadratic in N. One aspect of the present invention includes using an algorithm that is linear in N. In the present invention the array p is calculated with the following algorithm given in the C programming language for 1 for 1 0 

Here the computation of a predecessor array p requires execution time linear in N. Explicit calculation of d is not necessary.

Values for l i in column of may be precalculated. As noted above l i the earliest breakpoint for step i is the earliest step of the execution from which the i th step in one breakpoint. For example l 3 2 because starting at step and breaking on X would cause a break at step but starting at step and breaking on X would cause a break at step . Similarly l 4 0 because starting at step and breaking on Y would cause execution to break on step . Likewise l 5 3 because a breakpoint on variable X would cause execution started at step to next break at step .

Values for d i in column of are provided only for illustration since d is used only to describe the requirements of the algorithm employed. As noted above d i is the smallest number of breaks needed to get to step i starting from step . For example d 3 3 because the only way to get to step is to break three times successively on variable X while d 4 1 because breaking on Y takes only one step to get from step to step and d 5 2 because one can first break once on variable Y breaking at step and then break on variable X to get to step in two breaks.

Once the values of l i are calculated then the values of the array p i may be calculated using the above algorithm these values are given in column . The array p may then be used to choose an optimal sequence of breakpoint settings to bring the system to any desired step as described above. For example to bring the system to step the system is first brought to step then execution is continued with a breakpoint on X. To bring the system to step the system is first brought to step then execution is continued with a breakpoint on Y. To bring the system to step the system is simply initialized. Thus the complete calculated strategy to bring the system to step is to reset the state set a breakpoint on Y run the system until it hits a breakpoint at step reset the breakpoint settings to break on X and run the system until it hits a breakpoint at step .

Initially an execution trace of length N is constructed step . As described above this trace may be constructed by single stepping the system or by breaking on selected conditions. The breakpoint array including l i and b i is then calculated step l i being the earliest step into the trace where step i is only one breakpoint away and b i is the corresponding breakpoint setting. Next the array p is calculated step p i provides an optimal point at which to take the last break before breaking at the i th step.

To use the array p a target step is selected from the trace step . The target step is a specific i th step which may be selected either under program control or via a user interface. If i 0 step the system is reset to its initial state step and the process ends step . Otherwise the system is recursively first brought to the p i th step step the breakpoint is then set according to b i unsetting any previously set breakpoints step and the system is resumed. According to an aspect of the invention the system will then break at the i th step step . The process from step to may be repeated as often as needed with different selections of target i th step.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

Although not required embodiments of the invention can also be implemented via an operating system for use by a developer of services for a device or object and or included within application software. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs appliances lights environmental control elements minicomputers mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.

With reference to an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the form of a computer system . Components of computer system may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures.

Computer system typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to Random Access Memory RAM Read Only Memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disk Read Only Memory CDROM compact disc rewritable CDRW digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer system such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer system may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM CDRW DVD or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer system . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer system through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory not shown . In addition to monitor computer systems may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer system may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer system although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer system is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer system typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web enabled interface for applications and computing devices making computing activities increasingly Web browser or network oriented.

For example MICROSOFT s .NET platform available from Microsoft Corporation includes servers building block services such as Web based data storage and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device one or more portions of an embodiment of the invention may also be implemented via an operating system application programming interface API or a middle man object between any of a coprocessor a display device and a requesting object such that operation may be performed by supported in or accessed via all of .NET s languages and services and in other distributed computing frameworks as well.

As mentioned above while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any computing device or system in which it is desirable to implement a concurrent system execution replay method. Thus the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same similar or equivalent systems and methods achieved by embodiments of the invention.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention.

While aspects of the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the claimed invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

