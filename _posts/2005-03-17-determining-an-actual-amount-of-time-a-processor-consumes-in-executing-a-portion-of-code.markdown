---

title: Determining an actual amount of time a processor consumes in executing a portion of code
abstract: Systems and methods are provided that determine the actual amount of time a processor consumes in executing a code portion. The actual execution time of a code portion may be accurately determined by taking into consideration context switches and/or overhead time corresponding to the code portion. Determining the actual execution time of a code portion may include recording context switches and time values that occur during the execution of the code portion. This information along with overhead measurements may be used to generate the actual execution time of a code portion, as will be described in more detail below. For example, the switched-out intervals resulting from the context switches and the overhead time associated with the time measurements may be subtracted from the elapsed time to produce the actual execution time of a code portion.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774784&OS=07774784&RS=07774784
owner: Microsoft Corporation
number: 07774784
owner_city: Redmond
owner_country: US
publication_date: 20050317
---
Typically during the development of a software application performance tests are performed on one or more parts of the application. This testing often involves measuring an amount of time a processor spends i.e. consumes executing one or more portions of code e.g. a function a procedure or other logical component of the software application. For example such an amount of time may be determined by recording a time at which execution of the code portion begins and a time at which execution of the code portion ends. These times are often recorded by including probes at locations within the software application e.g. the beginning and end of the code portion the execution of which results in the time values being recorded.

Determining the amount of execution time based solely on the time at which execution of the code portion begins and ends is not an accurate representation of the actual amount of time a processor consumes in executing the code portion. Recording the time values itself consumes time including the time required to read the time value and the time required to write i.e. record the time value to a recording medium such as for example a volatile memory or a non volatile storage medium. The time consumed to acquire including reading and recording time values is referred to herein as overhead or overhead time. 

For example begin and end time measurements may indicate that a code portion consumed 800 processor cycles. However it may have taken three processor cycles to record the begin time. Accordingly the actual amount of time the processor consumed in executing the code portion assuming no other variables such as context switches discussed below is 800 3 797 processor cycles. It should be appreciated that the processor cycles consumed in acquiring the end time does not impact the accuracy of the measured execution time of the code portion. This is because the acquisition time for the end time occurs after the recorded end time itself.

Another problem arises in multi tasking operating systems OS . A multi tasking OS simulates concurrent operations of different processing threads on a processor e.g. a central processing unit CPU or microprocessor by alternating or interleaving execution of the different threads. After one thread has executed for a relatively short period of time often referred to as a quantum the OS interrupts the processor and adjusts its context to a different thread. Adjusting or switching the context of a processor from one thread to another is an event referred to herein as a context switch. The time values recorded for the begin and end time of the execution of a code portion do not take into account whether one or more context switches have occurred between the begin time and end time herein. If one or more context switches occurred during this interval then the interval is not an accurate representation of how much time the processor spent executing the code portion. That is the interval will reflect a longer period of time than was actually consumed by the processor in executing the code portion itself.

Applicants have recognized the need for a reliable system and method for determining the actual amount of time a processor consumes in executing a code portion particularly when executed on a multi tasking operating system.

Accordingly described herein are systems and methods that determine the actual amount of time a processor consumes in executing a code portion. As used herein the active time of a code portion is the actual amount of time a processor consumes in executing the code portion. The active time of a code portion may be accurately determined by taking into consideration context switches and or overhead time corresponding to the code portion.

As used herein the elapsed time of a code portion is the absolute time elapsed between the beginning and end times of the execution of the code portion i.e. the temporal interval defined by the recorded beginning and end time of the execution of the code portion . The elapsed time of a code portion may include time that the processor consumed during a switched out interval. As used herein a switched out interval is an interval that occurs during an elapsed time interval during which the processor executes a processing thread other than the processing thread corresponding to the code portion being measured. The elapsed time also may include overhead time resulting from the acquiring of the begin and end time values of the code portion. Further it should be appreciated that the code portion may include additional probes other than the probes resulting in the recording of the begin and end times. For example additional probes may have been placed at the beginning and ending of other code portions e.g. functions procedures or other logical components within the code portion being measured. The execution of these additional probes produces additional overhead time within the elapsed time.

Determining the active time of a code portion may include recording context switches and time values that occur during the execution of the code portion. This information along with overhead measurements may be used to generate the active time of a code portion as will be described in more detail below. For example the switched out intervals resulting from the context switches and the overhead time associated with the time measurements may be subtracted from the elapsed time to produce the active time of a code portion.

In an embodiment of the invention an actual amount of time consumed by a processor of a multi tasking operating system in executing a portion of code of a first processing thread is determined. First information is received indicative of a first temporal interval defining a begin time and an end time of execution of the code portion. Second information is received indicative of one or more second temporal intervals occurring within the first temporal interval during which the processor executed a processing thread other than the first processing thread. Based on the first and second information the actual amount of time consumed in executing the code portion is determined.

In an aspect of this embodiment a total combined time of the one or more second temporal intervals is subtracted from the first temporal interval.

In another aspect of this embodiment third information is received indicative of overhead time consumed in acquiring the first information during the first temporal interval. Determining the actual amount of time includes subtracting from the first temporal interval the overhead time and a total combined time of the one or more second temporal intervals.

In another aspect of this embodiment the second information includes a plurality of information elements. Each first information element specifies a particular time an old thread from which the processor switched context at the particular time and a new thread to which the processor switched context at the particular time. Determining the actual amount of time includes determining for each of the one or more second temporal intervals a begin time and an end time of the second temporal interval based on the information elements.

In yet another aspect of this embodiment the first information includes a plurality of first information elements each first information element specifying a time a processing thread and a type of event. Determining the actual amount of time includes an act of determining a begin time and an end time of the first temporal interval based on the plurality of first information elements.

In another aspect of this embodiment the second information includes a plurality of second information elements. Each second information element specifies a particular time an old thread from which the processor switched context at the particular time and a new thread to which the processor switched context at the particular time. Third information is received including one or more third information elements each third information element specifying time consumed in executing a type of event. Determining the actual amount of time includes determining for each of the one or more second temporal intervals a begin time and an end time of the second temporal interval based on the second information elements. Determining the actual amount of time further includes determining from the first and second information elements a total overhead time consumed by the processor in acquiring the first information and determining the actual amount of time consumed in executing the code portion.

In another aspect one or more of the above acts and or aspects of the above embodiment are performed on a computer system.

In another embodiment of the invention a computer program product is provided. The product includes a computer readable medium and computer readable signals stored on the computer readable medium defining instructions that as a result of being executed by a computer instruct the computer to perform the method of the embodiment of the invention described in the preceding paragraphs and or one or more aspects thereof described in the preceding paragraphs.

In another embodiment of the invention a system is provided for determining an actual amount of processor time consumed by a processor of a multi tasking operating system in executing a portion of code of a first processing thread. The system includes an actual time generator to receive first information indicative of a first temporal interval defining a begin time and an end time of execution of the code portion to receive second information indicative of one or more second temporal intervals occurring within the first temporal interval during which the processor executed a processing thread other than the first processing thread and to generate based on the first and second information the actual amount of processor time consumed in executing the code portion.

In an aspect of this embodiment the actual time generator is operative to subtract a total combined time of the one or more second temporal intervals from the first temporal interval.

In another aspect of this embodiment the actual time generator is operative to receive third information indicative of overhead time consumed in acquiring the first information during the first temporal interval and to subtract from the first temporal interval the overhead time and a total combined time of the one or more second temporal intervals.

In another aspect of this embodiment the second information includes a plurality of information elements. Each first information element specifies a particular time an old thread from which the processor switched context at the particular time and a new thread to which the processor switched context at the particular time. The actual time generator is operative to determine for each of the one or more second temporal intervals a begin time and an end time of the second temporal interval based on the information elements.

In yet another aspect of this embodiment the first information includes a plurality of first information elements. Each first information element specifies a time a processing thread and a type of event. The actual time generator is operative to determine a begin time and an end time of the first temporal interval based on the plurality of first information elements.

In another aspect of this embodiment the second information includes a plurality of second information elements. Each second information element specifies a particular time an old thread from which the processor switched context at the particular time and a new thread to which the processor switched context at the particular time. The actual time generator is operative to receive third information including one or more third information elements each third information element specifying time consumed in executing a type of event. The actual time generator is operative to determine for each of the one or more second temporal intervals a begin time and an end time of the second temporal interval based on the second information elements to determine from the first and second information elements a total overhead time consumed by the processor in acquiring the first information and to determine based on the determinations made in the acts C 1 C 3 the actual amount of time consumed in executing the code portion.

Other advantages novel features and objects of the invention and aspects and embodiments thereof will become apparent from the following detailed description of the invention including aspects and embodiments thereof when considered in conjunction with the accompanying drawings which are schematic and which are not intended to be drawn to scale. In the figures each identical or nearly identical component that is illustrated in various figures is represented by a single numeral. For purposes of clarity not every component is labeled in every figure nor is every component of each embodiment or aspect of the invention shown where illustration is not necessary to allow those of ordinary skill in the art to understand the invention.

The function and advantage of embodiments of the present invention will be more fully understood from the examples described below. The following examples are intended to facilitate a better understanding and illustrate the benefits of the present invention but do not exemplify the full scope of the invention.

As used herein whether in the written description or the claims the terms comprising including carrying having containing involving and the like are to be understood to be open ended i.e. to mean including but not limited to. Only the transitional phrases consisting of and consisting essentially of respectively shall be closed or semi closed transitional phrases as set forth with respect to claims in the United States Patent Office Manual of Patent Examining Procedures Eighth Edition Revision 2 May 2004 Section 2111.03.

Time axis shows that the timing diagram represents a period of time from 0 to 12 milliseconds ms . It should be appreciated that such a timing diagram may be illustrated using other units of time such as for example processor cycles. Graph illustrates the times that the processor was executing Thread from 1.5 3 ms and from 6 9 ms. Graph illustrates that timer reads indicating the begin and end execution times of a code portion acquired from 0.5 1.5 ms and from 9 10 ms. Thus graph represents overhead time in acquiring time values for the coded portion.

Graph illustrates a switched out interval during which the processor was executing one or more threads other than Thread .

Based on graphs and an elapsed time interval graph begins at 0.5 ms and ends at 9.0 ms producing an elapsed time of 8.5 ms. Timing diagram illustrates that based on graphs the active time graph of the coded portion is 3 1.5 9 6 4.5 ms. Embodiments of the invention for determining the active time for a code portion illustrated graphically in diagram will now be described in relation to .

In Act timer measurements are recorded for the code portion. For example the thread to which the code portion belongs may include probes at one or more locations including locations marking the beginning and the end of the code portion and possibly locations within the code portion e.g. beginnings and ends of other logical components . During execution of the code portion a timer measurement may be made at each location of a probe. These measurements may be recorded on a recording medium such as for example within a temporary buffer in local e.g. volatile memory or on a non volatile storage medium such as a disk. Examples of information units representing timer measurements are described below in relation to .

Digressing briefly from is pseudocode representing an example of a thread of code. Code is merely an example of a code thread and is not intended to limit the scope of the invention. Any of numerous other implementations of the code thread for example variations of thread are possible and are intended to fall within the scope of the invention.

Thread includes code portion which includes function F where F includes function G . Probes for recording the beginning and end of function F which is also the beginning and end of code portion may be placed at locations and within code portion . Further probes indicating the beginning and end of execution of the function G may be placed at locations and .

Each information element may include a time value field a thread ID field and an event field . The units of time used in field and fields and of tables and respectively are processor e.g. CPU cycles. However it should be appreciated that the units of time used in these fields may be any of a plurality of other types of units such as for example milliseconds. For example information element specifies that in thread at 900 processor cycles the function F was entered. Information element may result from the execution of a probe at location of code portion described above in relation to . It should be appreciated that although processor cycles are the time units used in several examples described herein other time units may be used.

As another example information element specifies that in thread at 1010 ms function S was entered. Further information elements and may result from probes located at locations and respectively of code portion .

Returning to in Act context switch events may be recorded. That is the switching of a context of the processor from one thread to another may be recorded. One of the threads to which the context is switched or from which context is switched may be the thread including the code portion and one or more threads to which the context switches or from which the context switches may be threads other than the thread including the code portion. On some operating systems e.g. Windows XP available from Microsoft Corporation an Application Programming Interface API may be provided that enables context switch events to be captured.

As used herein an application programming interface or API is a set of one or more computer readable instructions that provide access to one or more other sets of computer readable instructions that define functions so that such functions can be configured to be executed on a computer in conjunction with an application program. An API may be considered the glue between application programs and a particular computer environment or platform e.g. any of those discussed below and may enable a programmer to program applications to run on one or more particular computer platforms or in one or more particular computer environments.

For example a Microsoft XP OS includes an Event Tracking for Windows ETW API that provides a feature for recording context switch events. This feature may be enabled i.e. turned on so that it records context switch events e.g. into a local memory buffer or onto disk . Thus during the parallel execution of multiple threads on the OS context switch events including context switch events during the execution of the code portion may be recorded. Examples of information elements representing context switch events will now be described in relation to .

Digressing briefly from method is a block diagram illustrating an example of a table of information elements representing context switch events. Table is merely an illustrative embodiment of a table of information elements representing context switch events and is not intended to limit the scope of the invention. Any of numerous other implementations of such a table for example variations of table are possible and are intended to fall within the scope of the invention. For example table may include additional entries and or columns and the entries and columns may be organized in a different manner.

Each information element may specify a particular time value in the field a thread ID in old thread ID field of the thread from which context was switched and the thread ID of the thread to which context was switched in new thread ID field . For example information element indicates that at time 1000 processor cycles e.g. from a predefined starting time the context was switched from thread to thread whereas information element indicates that at 1028 processor cycles context was switched from thread thread .

In some embodiments instead of fields and each entry may include a single field specifying a thread ID and another field specifying a value e.g. a flag indicating whether the thread identified by the thread ID is being switched to i.e. switched in or switched from i.e. switched out . Other embodiments of entries may be used.

Returning to in Act overhead measurements for particular types of events e.g. function entry function exit and other types of events may be obtained. These measurements may be obtained from previous measurements made for different event types at an earlier time for example in a controlled testing environment. Alternatively overhead measurements may be measured and recorded during the execution of the code portion being measured. Examples of information elements representing overhead measurements will now be described in relation to .

Table may include information elements and where each information element has an event type field specifying an event type and an overhead time field specifying the overhead time associated with the event type. For example information element indicates that the function entry event type has an overhead time of 3 processor cycles and information element indicates that the function exit event type has an overhead of 2 processor cycles. Entries and assume a same amount of time consumed 3 and 2 processor cycles respectively every time a function is entered and exited respectively. However in some embodiments overhead may be measured and recorded each time a function is entered or exited and this information may be recorded in a different format than that shown in table .

Returning to in Act the actual time of the code portion may be determined based on the timer measurements context switch events and overhead measurements for example as described below in relation to . Method or portions thereof may be implemented using system described below in relation to .

Method may include additional acts. Further the order of the acts performed as part of method is not limited to the order illustrated in as the acts may be performed in other orders and or one or more of the acts may be performed in series or in parallel at least partially. For example one or more context switched events may be recorded as part of act in parallel or before the recording of one or more timer measurements as part of act .

In Act an interval representing the elapsed time of the code portion may be determined from the timer measurements. For example given a set of timer measurements e.g. those recorded in Act and a thread identifier an interval representing the elapsed time of a code portion of the identified thread may be determined.

For example using the information provided in table for which the thread having a thread ID of I represents thread illustrated in Act may include the following. The information elements of table not corresponding to thread e.g. information elements and may be removed and the remaining information elements may be sorted by time value field . The earliest time value and the latest time value represented by the sorted information elements are selected to define the begin time and the end time respectfully of the elapsed time interval. For example applying Act to the information elements of table may result in an elapsed time interval of 900 1550 . Act may be performed by elapsed time interval generator described below in relation to .

In Act a set of intervals representing the overhead of the timer measurements may be determined from timer measurements and overhead measurements such as for example the timer measurements and overhead measurements recorded and obtained in Acts and respectively. That is the overhead time associated with each timer measurement corresponding to the thread in question may be determined and represented as an interval. Using the example of and Act may include first removing information elements of table that do not correspond to thread and the remaining information elements may be sorted by time value field . For each information element corresponding to thread the overhead associated with the event identified in event field may be determined from table . For example information element corresponds to the event of entering function F which is a function entry event type. Information element of table indicates that the overhead associated with the function entry event type is three processor cycles. An overhead interval then may be defined as time value time value plus overhead time . Thus for information element an overhead interval of 900 903 may be produced.

As another example information element specifies an exit function G event which has an event type of function exit. Information element of table indicates that a function exit event type has an overhead of two processor cycles. Accordingly Act may include producing an overhead interval of 1500 1502 from information element . It should be appreciated that Act may not include determining an overhead interval for the time measurement information element specifying a latest time of the times specified by the sorted information elements i.e. the information elements corresponding to the thread in question . This information element may be excluded from act because the overhead time associated with this time of measurement does not add any overhead to the actual time the processor consumes in executing the code portion. That is this last time measurement indicates the end of the elapsed time so the overhead in acquiring this end time measurement occurs after the recorded end time itself and thus does not effect the active time.

Thus performing Act on the information elements of tables and may result in a set of overhead intervals of 900 903 1200 1203 1500 1502 .

In Act a set of switched out intervals may be determined from context switch events such as for example the context switch events recorded in act . The switched out intervals represent the intervals of time during the elapsed time during which the processor is executing a thread other than the thread of the code portion. For example in the timing diagram of graph indicates a switched out interval from 3 ms to 6 ms.

Using the example of table of to determine a set of switched out intervals of thread information elements of table that do not refer to thread in either fields or are removed. The remaining context switched information elements may be sorted by time field . Each context switch event corresponding to the switching from switch to another thread i.e. a switch out event may be identified e.g. the context switch events represented by information elements and . For each of these switch out events a corresponding context switch event that switches back into thread i.e. a switch in event may be identified. For the switched out events represented by information elements and the corresponding switch in events may be identified as those represented by information elements and . Each switched out event switched in event pair may define a switched out interval. Thus performing Act on the context switch events represented in table may result in a set of switched out intervals of 1000 1190 1225 1411 .

In Act the actual amount of time consumed by the processor in executing the code portion may be determined from the elapsed time the set of overhead intervals and the set of switched out intervals. For example the cumulative time defined by all of the overhead intervals and all of the switched out intervals may be subtracted from the elapsed time to produce the active time of the code portion. That is the active time equals the elapsed time minus overhead intervals plus switched out intervals .

Using the example results from acts and described above the active time of the code portion of thread 

Thus applying method to the information provided in results in a value of 266 processor cycles as the actual time the processor consumes in executing the code portion .

Method may include additional acts. Further the order of the acts performed as part of method is not limited to the order illustrated in as the acts may be performed in other orders and or one or more of the acts may be performed in series or in parallel at least partially. For example any of Acts may be performed before after or in parallel to one another.

Methods and acts thereof and various embodiments and variations of these methods and these acts individually or in combination may be defined by computer readable signals tangibly embodied on or more computer readable media such as for example non volatile recording media integrated circuit memory elements or a combination thereof. Computer readable media can be any available media that can be accessed by a computer. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices other types of volatile and non volatile memory any other medium which can be used to store the desired information and which can accessed by a computer and any suitable combination of the foregoing.

Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection wireless media such as acoustic RF infrared and other wireless media other types of communication media and any suitable combination of the foregoing.

Computer readable signals embodied on one or more computer readable media may define instructions for example as part of one or more programs that as a result of being executed by a computer instruct the computer to perform one or more of the functions described herein e.g. method method or any acts of the foregoing and or various embodiments variations and combinations thereof. Such instructions may be written in any of a plurality of programming languages for example Java J Graphical Basic C C or C Fortran Pascal Eiffel Basic COBOL other programming languages or any of a variety of combinations thereof. The computer readable media on which such instructions are embodied may reside on one or more of the components of any of systems and described herein may be distributed across one or more of such components and may be in transition therebetween.

The computer readable media may be transportable such that the instructions stored thereon can be loaded onto any computer system resource to implement the aspects of the present invention discussed herein. In addition it should be appreciated that the instructions stored on the computer readable medium described above are not limited to instructions embodied as part of an application program running on a host computer. Rather the instructions may be embodied as any type of computer code e.g. software or microcode that can be employed to program a processor to implement aspects of the present invention discussed above.

It should be appreciated that any single component or collection of multiple components of a computer system for example the computer system described in relation to that perform the functions described herein can be generically considered as one or more controllers that control such functions. The one or more controllers can be implemented in numerous ways such as with dedicated hardware and or firmware using a processor that is programmed using microcode or software to perform the functions recited above or any suitable combination of the foregoing.

System may include any of Processor recording medium active time generator and other components. Processor may be capable of multi thread execution and may be configured to receive one or more threads and in parallel. Each of threads and may include one or more probes and respectively. Thread may include a code portion which may include one or more of probes for which an active time of execution may be determined.

The processor may be configured to execute probes and and in response record time measurements for example as described above in relation to Act of . Further processor may be configured to generate context switch events representing a switch of context between a plurality of threads including any of threads and . Processor may record context switch events in response to processing one or more API calls for example as described above in relation to act in . For example processor may be controlled by a Windows NT operating system which records context switch events by using the ETW API as described above. The recording medium also may have overhead measurements recorded thereon.

Active time generator may generate the active time of a given thread based on timer measurements context switch events and overhead measurements . Active generator may include any of elapsed time interval generator switched out intervals generator overhead intervals generator active time engine and other components.

Elapsed time interval generator may be configured to receive timer measurement and a thread ID and generate elapsed time intervals for example as described above in relation to act .

Switched out intervals generator may be configured to receive thread ID and context switch events and generate switched out intervals for example as described above in relation to act of .

Overhead intervals generator may be configured to receive thread ID timer measurements and overhead measurements and generate overhead intervals for example as described above in relation to act .

Active time engine may be configured to receive elapsed time intervals switched out intervals and overhead intervals and generate active time representing the actual time the processor consumed in executing code portion . Active time engine may be configured to generate active time as described above in relation to act .

System and components thereof may be implemented using any of a variety of technologies including software e.g. C C C Java or a combination thereof hardware e.g. one or more application specific integrated circuits firmware e.g. electrically programmed memory or any combination thereof. One or more of the components of system may reside on a single device e.g. a computer or one or more components may reside on separate discrete devices. Further each component may be distributed across multiple devices and one or more of the devices may be interconnected.

Further on each of the one or more devices that include one or more components of system each of the components may reside in one or more locations on the system. For example different portions of the components of these systems may reside in different areas of memory e.g. RAM ROM disk etc. on the device. Each of such one or more devices may include among other components a plurality of known components such as one or more processors a memory system a disk storage system one or more network interfaces and one or more busses or other internal communication links interconnecting the various components. System and components thereof may be implemented using a computer system such as that described below in relation to .

Various embodiments according to the invention may be implemented on one or more computer systems. These computer systems may be for example general purpose computers such as those based on Intel PENTIUM type processor Motorola PowerPC Sun UltraSPARC Hewlett Packard PA RISC processors any of a variety of processors available from Advanced Micro Devices AMD or any other type of processor. It should be appreciated that one or more of any type of computer system may be used to implement various embodiments of the invention.

A general purpose computer system according to one embodiment of the invention is configured to perform one or more of the functions described above. It should be appreciated that the system may perform other functions and the invention is not limited to having any particular function or set of functions.

For example various aspects of the invention may be implemented as specialized software executing in a general purpose computer system such as that shown in . The computer system may include a processor connected to one or more memory devices such as a disk drive memory or other device for storing data. Memory is typically used for storing programs and data during operation of the computer system . Components of computer system may be coupled by an interconnection mechanism which may include one or more busses e.g. between components that are integrated within a same machine and or a network e.g. between components that reside on separate discrete machines . The interconnection mechanism enables communications e.g. data instructions to be exchanged between system components of system . Computer system also includes one or more input devices for example a keyboard mouse trackball microphone touch screen and one or more output devices for example a printing device display screen speaker. In addition computer system may contain one or more interfaces not shown that connect computer system to a communication network in addition or as an alternative to the interconnection mechanism .

The storage system shown in greater detail in typically includes a computer readable and writeable nonvolatile recording medium in which signals are stored that define a program to be executed by the processor or information stored on or in the medium to be processed by the program. The medium may for example be a disk or flash memory. Typically in operation the processor causes data to be read from the nonvolatile recording medium into another memory that allows for faster access to the information by the processor than does the medium . This memory is typically a volatile random access memory such as a dynamic random access memory DRAM or static memory SRAM . It may be located in storage system as shown or in memory system not shown. The processor generally manipulates the data within the integrated circuit memory and then copies the data to the medium after processing is completed. A variety of mechanisms are known for managing data movement between the medium and the integrated circuit memory element and the invention is not limited thereto. The invention is not limited to a particular memory system or storage system .

Aspects of the invention may be implemented in software hardware or firmware or any combination thereof. Further such methods acts systems system elements and components thereof may be implemented as part of the computer system described above or as an independent component.

Although computer system is shown by way of example as one type of computer system upon which various aspects of the invention may be practiced it should be appreciated that aspects of the invention are not limited to being implemented on the computer system as shown in . Various aspects of the invention may be practiced on one or more computers having a different architecture or components that that shown in .

Computer system may be a general purpose computer system that is programmable using a high level computer programming language. Computer system also may be implemented using specially programmed special purpose hardware. In computer system processor is typically a commercially available processor such as the well known Pentium class processor available from the Intel Corporation. Many other processors are available. Such a processor usually executes an operating system which may be for example the Windows 95 Windows 98 Windows NT Windows 2000 Windows ME or Windows XP operating systems available from Microsoft Corporation MAC OS System X available from Apple Computer the Solaris Operating System available from Sun Microsystems Linux available from various sources or UNIX available from various sources. Any of a variety of other operating systems may be used.

The processor and operating system together define a computer platform for which application programs in high level programming languages are written. It should be understood that the invention is not limited to a particular computer system platform processor operating system or network. Also it should be apparent to those skilled in the art that the present invention is not limited to a specific programming language or computer system and that other appropriate programming languages and other appropriate computer systems could also be used.

One or more portions of the computer system may be distributed across one or more computer systems not shown coupled to a communications network. These computer systems also may be general purpose computer systems. For example various aspects of the invention may be distributed among one or more computer systems configured to provide a service e.g. servers to one or more client computers or to perform an overall task as part of a distributed system. For example various aspects of the invention may be performed on a client server system that includes components distributed among one or more server systems that perform various functions according to various embodiments of the invention. These components may be executable intermediate e.g. IL or interpreted e.g. Java code which communicate over a communication network e.g. the Internet using a communication protocol e.g. TCP IP .

It should be appreciated that the invention is not limited to executing on any particular system or group of systems and that the invention is not limited to any particular distributed architecture network or communication protocol.

Various embodiments of the present invention may be programmed using an object oriented programming language such as SmallTalk Java J J Sharp C Ada or C C Sharp . Other object oriented programming languages may also be used. Alternatively functional scripting and or logical programming languages may be used. Various aspects of the invention may be implemented in a non programmed environment e.g. documents created in HTML XML or other format that when viewed in a window of a browser program render aspects of a graphical user interface GUI or perform other functions . Various aspects of the invention may be implemented as programmed or non programmed elements or any suitable combination thereof. Further various embodiments of the invention may be implemented using Microsoft.NET technology available from Microsoft Corporation.

Having now described some illustrative embodiments of the invention it should be apparent to those skilled in the art that the foregoing is merely illustrative and not limiting having been presented by way of example only. Numerous modifications and other illustrative embodiments are within the scope of one of ordinary skill in the art and are contemplated as falling within the scope of the invention. In particular although many of the examples presented herein involve specific combinations of method acts or system elements it should be understood that those acts and those elements may be combined in other ways to accomplish the same objectives. Acts elements and features discussed only in connection with one embodiment are not intended to be excluded from a similar role in other embodiments. Further for the one or more means plus function limitations recited in the following claims the means are not intended to be limited to the means disclosed herein for performing the recited function but are intended to cover in scope any equivalent means known now or later developed for performing the recited function.

Use of ordinal terms such as first second third etc. in the claims to modify a claim element does not by itself connote any priority precedence or order of one claim element over another or the temporal order in which acts of a method are performed but are used merely as labels to distinguish one claim element having a certain name from another element having a same name but for use of the ordinal term to distinguish the claim elements.

