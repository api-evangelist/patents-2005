---

title: Uniform resource discovery
abstract: An input including information specifying criteria for selecting computer resources is processed to produce an output comprising one or more function instances associated with computer resources satisfying the criteria. Included in each of the one or more function instances are metadata and information that specifies a mechanism for accessing a computer resource associated with the function instance.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07653916&OS=07653916&RS=07653916
owner: Microsoft Corporation
number: 07653916
owner_city: Redmond
owner_country: US
publication_date: 20050218
---
This application claims the benefit of U.S. Provisional Application 60 546 671 filed Feb. 20 2000 which is hereby incorporated herein by this reference.

This application is related to U.S. patent application titled Uniform Resource Discovery and Activation U.S. Patent Application Ser. No. 11 061 268 filed Feb. 18 2005 U.S. patent application titled Uniform Resource Discovery and API Layering U.S. Patent Application Ser. No. 11 060 913 filed Feb. 18 2005 and U.S. patent application titled Uniform Resource Discovery Provider U.S. Application Ser. No. 11 061 291 filed Feb. 18 2005 each of which is hereby incorporated by this reference.

The technology described herein relates generally to the uniform discovery and use of various types of computer resources.

Described herein are various technologies and techniques directed to the discovery and use of computer resources. More particularly described herein are among other things systems methods and data structures that facilitate the discovery of and access to computer resources in manner that is uniform across disparate types of resources.

Included in the various technologies and techniques described herein is a unique discovery module that enables applications to retrieve information about various resources and access these resources in a uniform manner. In these implementations the application uses the discovery module to request information about or access to one or more resources. In response to the request the application receives one or more function instances each of which is associated with a single resource that satisfies the request.

Function instances may have various forms and formats. For example in some implementations a function instance is an object that includes or references metadata about its associated resources. In some implementations a function instance also includes or references some information or mechanism by which its associated resource may be activated. As used herein activation refers to creating or making available a programmatic mechanism such as an API or the like by which an application may access or use a resource.

Regardless of the particular form or format of function instances in accordance with the various implementations described herein function instances will in general have uniform fields which may contain references to resource metadata and activation data and a uniform API enabling users of function instances to interact with function instances in the same manner regardless of the resources represented by the function instances.

In some implementations function instances are created using function instance providers. In these implementations each function instance provider is associated with a given set or type of resources. In these implementations function instance providers also include appropriate mechanisms to enumerate and create function instances for the set or type of resources associated therewith. For example and without limitation one function instance provider may enumerate and create function instances for Universal Plug and Play resources another function instance provider may enumerate and create function instances for Web Service Discovery resources yet another function instance provider may enumerate and create function instances for Simple Service Discovery Protocol resources etc.

In some implementations the determination as to which function instance provider is appropriate for which kinds of requested resources is made by a provider management module. In general the provider management module keeps track of the available function instance providers. When a request for function instances is received by the provider management module for example from the discovery module the provider management module then selects an appropriate function instance provider to satisfy the request and sends a request for function instances to the selected function instance provider. The function instance provider then enumerates its associated resources or otherwise queries its resources for information creates one or more function instances to represent resources that satisfy the request and returns the function instances to the provider management module.

In accordance with some implementations a particular type of function instance provider referred to herein as a mapped function instance provider presents function instances from multiple other function providers in a uniform manner using configurable categories. Function instances provided by a mapped function instance provider may be referred to more specifically as mapped function instances.

As noted above in some implementations each function instance includes or references metadata for its associated resource. In some implementations applications may access this metadata to obtain an API with which they can interact and control the resource associated with the function instance.

In some implementations each function instance enables an application to obtain an API for the resource in a manner independent of the resource and function instance. In one such implementation an application may request that a function instance activate a specific API. If the function instance supports activating the requested API a programmatic entity e.g. a factory object or the like is then created which uses data associated with the function instance to create the requested API.

In some implementations in the case where a particular mapped function instance represents another mapped function instance a function instance provider may present function instances that support activating multiple APIs. In this implementation a mapped function instance that represents other mapped function instances may support activating APIs for the function instance it represents and also support activating APIs for the underlying function instances.

Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Tasks performed by the program modules are described below with the aid of block diagrams and operational flowcharts.

Those skilled in the art can implement the description block diagrams and flowcharts in the form of computer executable instructions which may be embodied in one or more forms of computer readable media. As used herein computer readable media may be any media that can store or embody information that is encoded in a form that can be accessed and understood by a computer. Typical forms of computer readable media include without limitation both volatile and nonvolatile memory data storage devices including removable and or non removable media and communications media.

Communication media embodies computer readable information in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communications media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media.

Turning now to in its most basic configuration the computing device includes at least one processing unit and memory . Depending on the exact configuration and type of computing device the memory may be volatile such as RAM non volatile such as ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line . Additionally the computer system may also have additional features functionality. For example the system may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by the removable storage and the non removable storage .

The computer device may also contain communications connection s that allow the device to communicate with other devices. The computer device may also have input device s such as keyboard mouse pen voice input device touch input device etc. Output device s such as a display speakers printer etc. may also be included in the computer system .

Those skilled in the art will appreciate that the technologies described herein may be practiced with other computing devices other than the computing device illustrated in . For example and without limitation the technologies described herein may likewise be practiced in hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like.

The technologies described herein may also be implemented in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

While described herein as being implemented in software it will be appreciated that the technologies described herein may alternatively be implemented all or in part as hardware firmware or various combinations of software hardware and or firmware.

Turning now to illustrated therein is a system in which uniform resource discovery may be carried out. Included in the system are an application a function discovery module and a number of resources . Generally the application may be any program process or the like that is operable to interact with or control the function discovery module and or one or more resources. In general a resource may be any hardware software or combination of hardware and software that provides functionality to the application.

In accordance with one implementation the application is a program that displays a graphical representation of available resources. However those skilled in the art will appreciate that the application can be any process that is operable to communicate with or make use of any resources for any purpose.

Included in the function discovery module is a discovery interface module a provider management module a number of providers and a mapped function instance provider . Also included in the function discovery module are mapped function instance provider data and provider management data .

In general the discovery interface module is a programmatic entity that provides functionality to receive requests from an application and also includes various routines operable to handle the requests. In some implementations the discovery interface module is operable to communicate with the provider management module to retrieve function instances in response to application requests.

For example and without limitation in accordance with one implementation the discovery interface module comprises an API that includes methods that enable an application to request function instances for specified resources. In response to such a request the discovery interface module communicates with the provider management module to retrieve function instances that represent the requested resources.

In general the provider management module is a programmatic entity that accepts requests for function instances from the discovery interface module . In some implementations as described below the provider management module uses the provider management data and the one or more providers and to retrieve function instances which the provider management module then returns to the discovery interface module .

For example and without limitation in accordance with one implementation the provider management module comprises executable code that responds to requests from the discovery interface module by identifying a provider using information such as the provider management data and the information included with the request. If a provider that can service the request is found the provider management module requests that the identified provider supply a set of function instances according to the request from the discovery interface module .

In general in one implementation the providers are programmatic entities that receive requests for function instances from the provider management module . In response to a request from the provider management module a provider enumerates or queries the resources with which it is associated and creates and returns corresponding function instances to the provider management module. In some implementations providers might also support activation of application programming interfaces.

In accordance with various implementations described herein each provider is associated with a predefined set or type of resource. For example and without limitation one function instance provider may be associated with Universal Plug and Play resources another function instance provider may be associated with Web Service Discovery resources yet another function instance provider may be associated with Simple Service Discovery Protocol resources etc.

The particular manner in which a provider module enumerates and creates function instances may be dependent on the type of resources with which it is associated. For example in the case where a provider module is associated with Plug and Play resources upon receipt of a request for a function instance or function instances the provider module may use a Plug and Play specific API to enumerate its associated Plug and Play resources. The provider module may then create and return function instances that represent the Plug and Play resources.

In some implementations the providers and can be supplied by parties other than the party or parties providing the function discovery module .

In general the mapped function instance provider is a particular implementation of a provider that supports the creation of mapped function instances. As used herein a mapped function instance is a function instance that is associated with at least one other function instance.

The mapped function instance provider receives requests for function instances from the provider management module . In response it creates and returns mapped function instances and in some implementations does so using data from the mapped function instance provider data . In some of these implementations the mapped function instance provider data defines mapped function instances and specifies categorization and activation information for such mapped function instances.

For example and without limitation in accordance with one implementation the mapped function instance provider provides a category that supplies a single set of function instances for resources that output audio but are of different underlying types. For example and without limitation this category could include Plug and Play audio hardware and Universal Plug and Play media renderer devices. In some implementations this category information is associated with the mapped function instance provider data .

In general the mapped function instance provider data contains data associated with the mapped function instance provider . For example and without limitation in accordance with one implementation the mapped function instance provider data may include a hierarchical set of nodes in a configuration data store e.g. the registry in various versions of the Windows operating system from Microsoft Corporation of Redmond Wash. . In addition the mapped function instance provider data may include one or more Extensible Markup Language XML fragments in particular nodes where the nodes represent mapped function instance categories and the XML fragments contain information associated with mapped function instances.

In general the provider management data contains data associated with the provider management module . For example and without limitation in accordance with one implementation the provider management data is a set of XML fragments that contain information associated with function instance requests and providers .

It will be appreciated by those skilled in the art that the discovery interface module the provider management module and the various providers and may be implemented using various object oriented or non object oriented technology. The selection of one or another type of object oriented or non object oriented technology is a matter of choice and is often determined by such things as the underlying operating system etc.

However in accordance with some implementations one or more of the discovery interface module the provider management module and the various providers and are implemented as objects that conform to the Microsoft Component Object Model COM specification. The COM specification defines binary standards for objects and their interfaces which facilitate the integration of software components into applications.

Turning now to shown therein is a generalized representation of a function instance . The following description of is made with reference to the system of . However it should be understood that the function instance described with respect to is not intended to be limited to being used by or interacting with elements of the system .

In general a function instance represents a resource either directly e.g. by referencing the resource directly or indirectly e.g. by referencing another function instance . Function instances may be used throughout the system to represent and transfer resource and other function discovery information. For example the provider management module may retrieve function instances from providers and provide function instances to the discovery interface module which provides function instances to the application .

A function instance may be implemented as an object in an object oriented environment and embodied in a computer readable medium or media. However it should be understood that the functionality described herein with respect to a function instance object can also be implemented in a non object oriented fashion and can be implemented on many types of systems both object oriented and non object oriented.

As shown the function instance includes a unique identification field a resource metadata field and an activation data field . Additionally in some implementations the function instance implements a function instance interface . The interface defines a set of methods that any function instance object may implement.

In the implementation of the function instance shown in these methods implemented include a method to retrieve data stored in the unique identification field a method to retrieve resource metadata and a method to activate the function instance .

It should be understood that in some implementations the information returned by the methods may be made available directly by means such as and without limitation public object properties. In such implementations the corresponding method may not be necessary. For example if the unique identification field can be retrieved by accessing the field directly then the get unique identifier method would not be necessary. Additionally the methods may be made available directly and without the use of an interface.

The unique identification field contains data that in some implementations uniquely identifies the function instance in a system on which the function discovery module is executing. Furthermore the unique identification field remains constant even when the function discovery module or system is stopped and restarted. Therefore once an application retrieves the unique identification value for a particular function instance the value can be stored and later used to locate that function instance and thereby a particular resource.

The resource metadata field contains data specific to the particular resource represented by the function instance. In one implementation the metadata may comprise a key value table . In this table the keys contain identifiers that identify the information in a particular key value pair. For example and without limitation keys could be Friendly Name or Manufacturer . The value associated with a particular key contains the information described by the key. For example and without limitation the value associated with the Friendly Name key could be Primary sound card while the value associated with the Manufacturer key could be Company Name Inc. 

Regardless of the way in which the resource refers to a particular piece of metadata in some implementations the resource metadata field identifies the metadata in a consistent manner through the use of standard keys . For example a particular resource may make its friendly name accessible using a resource specific property called Name while another resource may make its friendly name accessible using a method called GetMyCommonName. In both cases the resulting metadata could be represented in the function instance resource metadata using the same key for example and without limitation using Friendly Name .

It should be noted that the metadata represented by the key value table is not limited in any way to particular data. Furthermore the key value table can be implemented using many data structures. Finally the key value table does not necessarily comprise the entirety of the resource metadata accessible using the function instance.

When called the get resource metadata method returns the data represented by the resource metadata field . As discussed previously this method may not be necessary or required if the resource metadata is available through other means such as through the use of a public property.

The activation data field includes or references information used by the function instance when an application requests activation of the function instance. In one implementation the activation data includes or references a table of application programming interfaces or interfaces that can be requested by an application and corresponding factories that can create entities that implement the requested interface . When an application requests activation from a function instance it submits with the request an interface that the entity returned by the function instance may support.

In one implementation the activation data included in or referenced by the field may be examined for an entry that contains the requested interface . If the interface exists the corresponding factory is used to create an entity that supports the requested interface. This entity is then returned to the application that requested the activation. For example an application may request an activation and specify the Foo interface . If the Foo interface exists in the activation data the corresponding Foo factory is used to create an entity that implements the Foo interface.

It should be understood that while the terms interface and factory are often associated with object oriented environments the functionality enabled by the activation data field is not limited to any particular environment or system and can also be implemented in non object oriented systems. Furthermore the activation data table can be implemented using many data structures. Finally the activation data table does not necessarily comprise the entirety of the activation data used or maintained by the function instance .

The activate method uses the activation data to create a factory that in turn may create an entity that supports the requested application programming interface. As discussed previously this method may not be necessary or required if the activation data included in or referenced by the activation data field is available through other means such as through the use of a public property.

Turning now to shown therein is a generalized representation of an API layer . In some implementations an API layer may be a data structure embodied in a computer readable media or medium. The following description of is made with reference to the system of the function instance object and the activation data table of and the tree structure of . However it should be understood that the API layer described with respect to is not intended to be limited to being used by or interacting with elements of the system the function instance object and the activation data table or the tree structure .

In accordance with some implementations the mapped function instance provider uses some number of API layers and a tree structure such as the tree structure to enable enhanced categorization and activation of function instances. An API layer represents the information that may be used by the mapped function instance provider to retrieve function instances in a particular category and also to enable activation of the retrieved function instances. In one implementation the API layers and tree structure are stored in the mapped function instance provider data .

The API layer illustrated in includes a category of underlying function instance s field a subcategory of underlying function instance s field a filter criteria field a supported interface field and a factory field .

The category and subcategory of underlying function instance s fields and represent the category from which the function instances returned by this API layer originate. The mapped function instance provider might not create any function instances that directly reference a resource . Instead the mapped function instance provider may create function instances that map to other function instances including function instances created by a provider or function instances created by the mapped function instance provider .

The category and subcategory of underlying function instance s fields and specify the base set of function instances returned using the API layer before any filtering performed using the filter criteria field . For example and without limitation an API layer called Audio Endpoints Local might contain the necessary category and subcategory to specify a set of function instances that directly map to sound hardware on the local computer system.

The filter criteria field may contain or reference data by which the set of function instances returned using the API layer is filtered. For a function instance to be specified by an API layer it may be identified by the category and subcategory and and may also meet the filter criteria specified in this field if any filter criteria information is provided.

Filter criteria can include for example and without limitation particular values of resource metadata properties as well as supported application programming interfaces. For example filter criteria for audio hardware might indicate that a resource metadata property named Device Type has the value Audio Hardware and that the function instance supports the Audio application programming interface.

The supported interface field may contain the application programming interface supported by the function instances returned using this API layer . Alternatively the supported interface field may contain no supported application programming interface in which case the API layer does not in and of itself support activation. In some implementations the data in or referenced by the supported interface field populates a portion of the interface column of the activation data table referenced by a function instance object .

In these cases because the data exists in or is referenced by the interface column during activation in some implementations the data originating in the supported interface field is used as part of the process that determines if the function instance supports a requested interface.

The factory field may identify a factory entity that creates entities that support the interface specified in the supported interface field . Alternatively if no such factory exists the factory field may not identify a factory. As with the data in or referenced by the supported interface field in some implementations the data in or referenced by the factory field populates a portion of the activation data table referenced by a function instance object .

In some implementations the data in or referenced by the factory field populates a portion of the factory column of the activation data table . Because the data exists in or is referenced by the factory column during activation the data originating in the factory field is used as part of the process that determines the factory entity that can create an entity that supports the requested interface.

Turning now to shown therein is a generalized representation of a tree structure which specifies categories and subcategories used by the mapped function instance provider . The following description of is made with reference to the system of the function instance object and the activation data table of and the API layer of . However it should be understood that the tree structure described with respect to is not intended to be limited to being used by or interacting with the system the function instance object and the activation data table or the API layer .

The tree structure represents a conceptual model of the category and subcategory relationships that can be used by the mapped function instance provider . The tree structure includes a root category associated with the mapped function instance provider and some number of subcategories .

The subcategories may be organized in a hierarchical manner as is shown in the diagram but are not limited to this structure and may be organized in any other structure including but not limited to a flat list. If the subcategories are organized in a hierarchical manner a single subcategory may commonly be referred to using a notation such as but not limited to the following Subcategory A Subcategory B Subcategory C. This notation would locate subcategory C as a descendant of subcategory B which is in turn is a descendant of subcategory A.

When an application requests function instances from the discovery interface module and specifies the mapped function instance provider the mapped function instance provider uses any provided subcategory information to locate the specified node in the tree structure . Once the specified node has been located the function instance provider uses any API layers associated with that node to generate function instances .

A node may have zero or more API layers . If no API layers exist for a given node then in some implementations no function instances are returned when that node is specified in a request for function instances. A node may have multiple API layers . If multiple API layers are specified then in some implementations the set of function instances returned consists of function instances from all specified API layers.

An application may request that function instances should be returned from the node specified by the subcategory information as well as all nodes descended from the specified node. In this case the API layers in the specified node and all descendant nodes are used to create function instances.

Turning now to shown therein is a generalized operational flow including various operations that may be performed in a process that retrieves function instances. The following description of is made with reference to the system of . In particular the description of is made with reference to the function discovery module the provider management module and a provider . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the function discovery module the provider management module or the provider . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

As shown in one implementation of operation the discovery interface module of function discovery module receives a request for a set of function instances . This request may include but is not limited to a category a subcategory a tree enumeration flag that defines if only the subcategory identified by the category and subcategory information should be searched or if all descendant subcategories should also be searched and filter criteria that specifies how the returned function instances should be filtered.

In some implementations the function discovery module dispatches the request to the provider management module . In one implementation of operation the provider management module uses the specified category to identify a provider to service the request for function instances .

The provider management data may contain information that maps categories to providers . A provider generally corresponds to a particular type of resource. For example and without limitation a single provider may correspond to any of the following types of resources Plug and Play resources Universal Plug and Play resources Web Service Discovery resources Simple Service Discovery Protocol resources and software components. Providers may also correspond to any other type of resource.

In one implementation of operation the provider selected in operation creates and returns function instances identified in the request. The steps taken by the provider to obtain the information necessary for it to create function instances vary by provider. For example a provider for Plug and Play resources may use an application programming interface specific to interaction with Plug and Play resources to enumerate the resources and retrieve resource metadata information about the resources.

In the case of Plug and Play resources this application programming interface may be the SetupDi application programming interface. SetupDi is an API included with certain versions of the Windows operating system from Microsoft Corporation of Redmond Wash. The SetupDi API enables accessing Plug and Play hardware. In some implementations the mapped function instance provider may use the tree structure and API layer data stored in the mapped function instance provider data to create function instances.

Finally in operation in some implementations the function instances created by the provider are returned to the provider management module then to the function discovery module then to the discovery interface module and finally to the application .

It should be noted that the provider might create the function instances and return them to the provider management module or it might return the data necessary to create the function instances and leave the actual creation of the function instances to the provider management module or to the function discovery module .

Turning now to shown therein is a generalized operational flow including various operations that may be performed by a provider to service a request for function instances. In particular the operational flow illustrates operations that may be performed by a provider to carry out the determination operation of operational flow .

The following description of is made with reference to the system of . In particular the description of is made with reference to the provider management module the providers and resources . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the provider management module the providers or the resources . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

In one implementation of operation a provider receives a request for function instances. The request may include but is not limited to a subcategory that identifies a particular set of resources on which the returned function instances should be based a tree enumeration flag that defines if only the specified subcategory should be searched or if all descendant subcategories should also be searched and filter criteria that specifies how returned function instances should be filtered.

In one implementation of operation the provider enumerates the resources with which it s associated and retrieves any information required to create function instances for such resources. The enumeration can in some cases be limited by the specified subcategory information and in the same or other cases can be limited by the specified filter criteria information.

The manner in which the provider enumerates resources varies depending on the nature of the resources with which the provider interacts. In some cases the provider may enumerate the resources and obtain information necessary to create function instances by using an application programming interface that is operable to manage the resources. For example and without limitation a provider for Plug and Play resources may use the application programming interface known as SetupDi. Similarly a provider for Simple Service Discovery Protocol resources may use a Universal Plug and Play application programming interface to find information about the available Universal Plug and Play or Simple Service Discovery Protocol resources etc.

The mapped function instance provider may use the tree structure and API layer data stored in the mapped function instance provider data to create function instances. For example if the mapped function instance provider is given a subcategory of Subcategory A Subcategory B it may traverse the tree structure to the node associated with subcategory B and then return function instances defined by the API layer s associated with the node associated with subcategory AB.

Using the information retrieved in operation one implementation of operation maps the information to the organization and naming required by the function instance. This operation ensures that applications using function instances can retrieve the same information with a single name even if the underlying resources name that information differently. For example and without limitation information about the manufacturer of the resource could be represented by the resource specific application programming interface using a data field called ManufacturerName. This same information the manufacturer may be referred to in function instance resource metadata as Manufacturer. Operation transforms resource data retrieved from the resource so that it has the organization and name expected in function instance resource metadata .

In one implementation of operation the provider creates function instances for each resource identified by the request. The provider may create function instances using among other things the resource metadata containing mapped information generated in operation any activation information known or retrieved about the resource and any other information required to create function instances.

Finally in one implementation of operation the function instance s the provider has created are returned to the provider management module . It should be noted that the provider might create the function instances and return them to the provider management module or it might return the data necessary to create the function instances and leave the actual creation of the function instances to the provider management module to the function discovery module or to some other module. Also the provider might return function instances or data asynchronously from the request for function instances. In addition not all of the information necessary to create a full and valid function instance might be provided by the provider . In such cases the function instances created by the provider might not be immediately usable by a requesting application . For example the provider might not specify the unique identification value this information might instead be provided by the provider management module by the function discovery module or by some other module.

Turning now to shown therein is a generalized operational flow including various operations that may be performed by a mapped function instance provider to service a request for function instances . In particular the operational flow illustrates operations that might be performed by a provider to carry out the determination operation of operational flow . The following description of is made with reference to the system of the function instance object of and the API layer of . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the system the function instance object and the API layer . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

In one implementation of operation a mapped function instance provider receives a request for function instances. The request may include but is not limited to a subcategory that identifies a particular set of resources on which the returned function instances should be based a tree enumeration flag that defines if only the specified subcategory should be searched or if all descendant subcategories should also be searched and filter criteria that specifies how returned function instances should be filtered.

In one implementation of operation the mapped function instance provider first locates the appropriate node in the tree structure maintained in the mapped function instance provider data . For example a request with subcategory information Subcategory A Subcategory B may define a node that is located at the end of the tree path starting with the root node continuing through the node for subcategory A and terminating with the node for subcategory B. Once this node is located the mapped function instance provider retrieves all of the API layer data associated with the node.

Then for each API layer retrieved in operation the mapped function instance provider executes operation which retrieves the function instances specified in the API layer . The mapped function instance provider locates the function instances using the category of underlying function instances field and subcategory of underlying function instances field .

Additionally the function instance provider may filter the returned function instances by specified resource metadata property values or by the returned function instances by supported activation interfaces or by some other data. For example a subcategory named Audio Hardware Local might have an API layer with the category field Plug and Play the subcategory field DevNode and a filter on a particular Plug and Play property so that only function instances that reference audio resources are returned.

In some implementations operation may be executed multiple times when there are multiple API layers associated with the node . In this case the set of retrieved function instances may consist of all of the function instances returned as a result of the data in each API layer. This enables a single category to contain function instances that represent similar resources even if the underlying function instances come from different providers different categories or different subcategories.

Next one implementation of operation creates a new function instance for each function instance retrieved in operation . This new function instance may contain a new unique identifier that is different from the identifier of the underlying function instance on which it is based. While the new function instance is based on the underlying function instance it is not the same function instance and so in some implementations warrants its own unique identifier.

The new function instance also contains resource metadata that comprises both the resource metadata of the underlying function instance and the resource metadata from the API layer and mapped function instance provider. For example and without limitation the resource metadata of the new function instance may contain a Manufacturer entry with information from the underlying function instance as well as a Subcategory entry that contains the subcategory where the API layer is located. The underlying function instance contains no information about the subcategory information associated with an API layer but the mapped function instance provider can add this information when it creates the new function instance.

Finally the new function instances created in operation also contain activation data included in or referenced by the activation data field and retrieved from the API layer . For example and without limitation suppose an API layer with a supported interface field that contains Foo Interface and a corresponding factory field that defines an entity that can in turn create another entity that supports the Foo interface based on the information in the function instance. Function instances created based on this API layer contain activation data field entries that denote that the function instance supports the Foo interface and define how to create an entity that implements the Foo interface.

The activation data created in operation may also contain activation information in the form of specific interface and factory entries from underlying function instances. This enables API layering where an API is defined in terms of another API. For example and without limitation suppose that an API layer contains category subcategory and filter criteria information that specifies that the underlying function instances also provided by the mapped function instance provider support the Complex Interface. 

The API layer that uses these underlying function instances could then contain a supported interface field that denotes that the resulting function instances support the Simple Interface. In this case function instances returned as a result of data in this API layer contain activation data that indicates that they support both the Simple Interface and the Complex Interface.

Turning now to shown therein is a generalized operational flow including various operations that may be performed by a function instance in response to an activation request. The following description of is made with reference to the system of the function instance object of and the API layer of . However it should be understood that the operational flow described with respect to is not intended to be limited to being performed by the system the function instance object and the API layer . Additionally it should be understood that while the operational flow indicates a particular order of operation execution in other implementations the operations may be ordered differently.

In one implementation of operation a function instance receives an activation request for an object that supports a specified application programming interface. This request may include but is not limited to an interface that specifies the application programming interface the returned object supports and a set of additional data that if provided can be used by function instance to control or modify the activation.

In operation the function instance determines if it supports activation for the requested interface. In one implementation this test can be performed by examining the activation data for the presence of the requested interface which if supported will exist in the interface column . In this implementation if the interface does not exist in interface column the function instance does not support activation for the specified application programming interface.

If it is determined in operation that the function instance supports activation for the requested application programming interface the operational flow continues to operation described below. If it is determined in operation that the function instance does not support activation for the requested application programming interface operational flow proceeds to operation .

In operation the provider of the underlying resource represented by the function instance is queried to determine if the provider supports activating the requested application programming interface. If it is determined in operation that the provider supports activating the requested application programming interface the provider creates an entity that implements the requested application programming interface. The operational flow then continues to operation described below. If it is determined that the provider does not support activation for the requested application programming interface operational flow proceeds to operation .

In operation the activation request indicates that the specified application programming interface is not supported by the function instance or provider .

If the function instance supports activation for the requested application programming interface operational flow continues to operation where in one implementation the function instance creates a factory associated with the specified application programming interface. In an implementation using the activation data the factory column contains an identifier for a factory that creates entities that implement the requested interface. For example and without limitation the factory column in a COM based system could contain a CLSID that uniquely identifies a COM object that can create instances of another COM object that actually implements the requested interface. Alternatively and again without limitation in a .NET or Java based system the factory column could contain a fully qualified object or path hierarchy that identifies a .NET or Java object that can create another object that implements the specified interface. In a non object oriented system the factory column could contain an identifier that specifies how to create some entity that can in turn create another entity that implements the requested application programming interface.

In one implementation of operation the factory created in operation is used to create an entity that implements the requested interface. The factory has access to the data associated with the function instance like the resource metadata as well as possibly to other data like additional parameters included in the activation request. Using this data the factory can create an entity that implements the requested interface.

For example and without limitation suppose a function instance represents Plug and Play audio hardware such as a sound card and suppose that the activation data denotes that the function instance supports an Audio COM interface. In one implementation a factory object that supports creating COM objects that implement the Audio interface might use the Plug and Play SetupDi API to create an object that implements the Audio interface. Such a factory object could use the resource specific information in the function instance like an identifier that specifies which audio hardware the function instance represents to assist in creating the object that implements the Audio interface.

It should be noted that while this description refers to a factory and to factories creating entities which in turn create other entities that implement the requested application programming interface that the function instance could refer directly to the entity that implements the application programming interface. In addition the same entity that implements the factory may also implement the application programming interface.

Finally in operation the entity implementing the requested application programming interface is returned to the requestor. Continuing with the example introduced in the previous paragraph and without limitation the COM object that implements the Audio interface would be returned to the application which could then use it to control and interact with the audio hardware to for example play audio or control volume.

Although some particular implementations of systems and methods have been illustrated in the accompanying drawings and described in the foregoing Detailed Description it will be understood that the systems and methods shown and described are not limited to the particular implementations described but are capable of numerous rearrangements modifications and substitutions without departing from the spirit set forth and defined by the following claims.

