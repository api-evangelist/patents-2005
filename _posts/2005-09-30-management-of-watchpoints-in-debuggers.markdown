---

title: Management of watchpoints in debuggers
abstract: Provided are a method, system, and article of manufacture, wherein a first application requests an operating system to monitor a memory address, and wherein the operating system generates a signal in response to an operation that affects the memory address. A second application receives the generated signal. The second application determines whether to forward the signal to the first application. The first application processes the signal, in response to the signal being forwarded by the second application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07765526&OS=07765526&RS=07765526
owner: Intel Corporation
number: 07765526
owner_city: Santa Clara
owner_country: US
publication_date: 20050930
---
A debugger is a software program that allows a user to debug other software programs. A user may initiate a debug session by starting up the debugger with the program being debugged where the program being debugged may be referred to as the debuggee. The user may then set one or more breakpoints in the debuggee. A breakpoint is a mechanism to pause the debuggee when at least one condition associated with the breakpoint becomes true.

After setting the one or more breakpoints the user may continue with the execution of the debuggee. When the debuggee is paused at a breakpoint the user may check the debuggee s internal state such as register values memory values and the call stack to determine the cause of one or more bugs in the debuggee where a bug is a defect in the debuggee. The user may set additional breakpoints continue the execution of the debuggee and check the debuggee s internal state in an attempt to determine the cause of the one or more bugs.

A watchpoint is a breakpoint that is triggered when the content of a specified memory address changes. A watchpoint may be implemented by changing the access protection of the page in which the specified memory address is located. For example if the user sets a watchpoint to monitor writes to a variable the page where the variable resides would be set to read only protection. When the page is written into the operating system may deliver a fault signal that indicates a page access violation. As a result the debuggee may be paused. The page access violation may be referred to as a segmentation violation SEGV . The debugger may receive the fault signal and determine the memory address where the write failed. The debugger may then change the protection of the page back to write allowed and single step the instruction that resulted in the fault signal. When the single stepping completes whether the single stepping succeeds or not the debugger may reset the protection on the page to read only to identify additional subsequent writes to the memory address. If the single stepping succeeds the debugger either notifies the user of a watchpoint hit if the address falls within the memory address corresponding to a watchpoint or resumes the debuggee if the address falls outside the memory address corresponding to any watchpoints. If the single stepping fails then the debugger may report that a program error has occurred. A debugger that uses memory protection to handle watchpoints may be referred to as an SEGV debugger .

In the following description reference is made to the accompanying drawings which form a part hereof and which illustrate several embodiments. It is understood that other embodiments may be utilized and structural and operational changes may be made.

A runtime is a software module that defines an application programming interface API where the runtime may be linked to a user program. Certain runtimes install a signal handler to receive SEGV signals from the operating system and modify page protections. Such runtimes may cause problems for a debugger that uses page protections for watchpoints. A runtime that installs signal handlers for SEGV signals may be referred to as a SEGV runtime .

An interface library loaded into the debugger s address space may be used when debugging a program using a runtime to provide an interface through which the runtime and the debugger interact. A SEGV debugger may not work properly with a SEGV runtime because they both expect to receive all SEGV signals. Furthermore if either the debugger or the runtime changes protections on a page without considering protections set by the other the operation of the other may be affected. Certain embodiments allow a SEGV debugger to debug an application that is executed within a SEGV runtime.

The computational platform includes an operating system a first application comprising a debugger and a second application comprising a runtime and a third application comprising a debuggee application also referred to as a debuggee.

The operating system may be any suitable operating system including those presently known in the art such as MICROSOFT WINDOWS UNIX etc. The debugger is any application that may be used to debug the debuggee wherein debugging the debuggee may include determining the causes of faults traps and other errors caused by the execution of the debuggee in the runtime . In certain embodiments the runtime is a SEGV runtime and the debugger is a SEGV debugger.

Certain embodiments illustrated in allow the debugger to debug the debuggee application that executes within the runtime .

In certain embodiments the operating system included in the computational platform stores pages where each page may include a plurality of memory addresses. An operating system page permission table includes indicators that indicate the protections on the pages . For example a page X may be indicated as having the protection Read Only . In such a case if an instruction attempts to execute a write operation on any memory address included in the page X a segmentation violation signal may be generated by the operating system .

In certain embodiments the debugger includes a debugger page permission table and the runtime includes a runtime page permission table . The debugger page permission table includes indicators that indicate the protections on one or more of the pages as set by the debugger . For example the debugger may set a watchpoint corresponding to a memory address included in page X and indicate in the debugger page permission table that the page X has the protection Read Only .

The runtime page permission table includes indicators that indicate the protections on one or more of the pages as set by the runtime . For example the runtime may indicate the protection of the page X to be Read Write in the runtime page permission table .

In certain embodiments the debugger executes the debuggee in the execution environment provided by the runtime . The debugger sets watchpoints to debug the debuggee . In certain embodiments a copy of the runtime page permission table is maintained in the debugger and a copy of the debugger page permission table is maintained in the runtime . In certain alternative embodiments instead of maintaining the copies interfaces that read the debugger page permission table from the runtime and interfaces that read the runtime page permission table from the debugger may be implemented.

In addition to the data structures illustrated in additional data structures that allow the debugger to interface with the runtime and the debuggee and the runtime to interface with the debugger and the debuggee may also be present. In still other embodiments data structures that are different from tables may be used to implement the operating system page permission table the debugger page permission table and the runtime page permission table . Additionally in certain embodiments a fewer or a greater number of tables may include the information maintained in the operating system page permission table the debugger page permission table and the runtime page permission table .

In certain embodiments illustrated in the operating system page permission table includes for a page the more restrictive of the protection indicated for the page by the debugger and the runtime .

In certain embodiments illustrated in a certain page maintained by the operating system is referred to as page in the debugger page permission table and is referred to as page in the runtime page permission table .

The debugger may set protection for the page where the protection is indicated in the debugger page permission table . The runtime may set protection for the page where the protection is indicated in the runtime page permission table .

The actual protection of the page as indicated in the operating system page permission table is set to the more restrictive of the protections set by the debugger and the runtime i.e. the more restrictive of the two protections is set as the protection of the page maintained by the operating system .

Certain embodiments illustrated in show how the more restrictive of the protections for a page as set in the debugger page permission table and the runtime page permission table is set as the protection for the page by the operating system .

In certain embodiments protection for a page may be implemented by an indicator that indicates protections that apply to the page. For example a page may be indicated as being protected against reads and writes. Alternatively in certain embodiments protection for a page may be implemented by an indicator that indicates permissions granted for performing operations on the page. For example a page that is protected against reads and writes may be indicated as having no access permission. In the exemplary page protections have been shown to be implemented by indicating permissions that apply to a page. Other embodiments may implement protections for a page via different indicators or by indicators that explicitly indicate the protections.

In certain embodiments the exemplary possible page protections implemented for a page may include No Access Read Only and Read Write . If a page protection for a page is indicated as No Access then neither read nor write operations may be performed on the page i.e. the page is protected against reads and writes. If a page protection for a page is indicated as Read Only then read operations may be performed on the page but no write operations may be performed on the page i.e. the page is protected against writes. Additionally if a page protection for a page is indicated as Read Write then both read and write operations may be performed on the page i.e. the page is not protected against either reads or writes. Therefore in the exemplary possible page protections No Access indicates a more restrictive protection than Read Only and Read Only indicates a more restrictive protection than Read Write .

A page maintained by the operating system may be referred to as the page within the debugger page permission table and the as the page within the runtime page permission table . The debugger page permission table may indicate the page to be Read Only and the runtime page permission table may indicated the page to be Read Write . In such a case the more restrictive protection for the page is the Read Only protection. The page corresponding to pages is indicated to have the more restrictive of the Read Only and the Read Write protections. The protection for page is indicated as Read Only in the operating system permission table .

Certain embodiments illustrated in indicate how the more restrictive of the page protections for a page set by the debugger and the runtime is maintained for the operating system . In case a page protection is violated the operating system may generate a signal such as a SEGV signal.

Control starts at block where the debugger starts the debugging of the debuggee application by initiating an execution of the debuggee application within the runtime environment provided by the runtime . The debuggee application may execute by using the runtime libraries provided by the runtime . When a signal such as a segmentation violation signal is generated during the execution of the debuggee application the signal is transmitted by the operating system to the debugger and the runtime . A signal is an indication of a fault trap violation or other error that is caused during the execution of a computer program.

The debugger sets at block a flag to avoid processing segmentation violation signals that are received by the debugger directly from the operating system . In certain embodiments the flag may be set to ignore segmentation violation signals received directly by the debugger from the operating system . In certain embodiments data structures that are different from a flag may be used to avoid processing segmentation violation signals that are received by the debugger directly from the operating system .

Additionally the debugger sets at block a breakpoint in the runtime where the triggering of the breakpoint may cause the runtime to send the debugger a notification of a segmentation violation signal received from the operating system where the segmentation violation signal may require further processing by the debugger . For example the debugger may set a breakpoint in a function named inform debugger of segv event in the runtime . When the runtime receives a segmentation violation signal from the operating system the breakpoint in the function named informed debugger of segv event may be triggered allowing the runtime to send to the debugger the segmentation violation signal.

Control proceeds to block where the debugger may allow the monitoring of one or more memory addresses by the operating system via one or more watchpoints set by a user. For example a user may set a watchpoint while debugging the debuggee application where the watchpoint is for monitoring a memory address. Subsequently the user may delete the watchpoint.

From block control may proceed either to block or to block . At block the debugger determines whether a watchpoint has been set by a user. If so the debugger sets protection for the page on which the memory address corresponding to the watchpoint is located. The protection is set in the debugger page permission table . The debugger or the runtime may then cause an update at block of the copy of the debugger page permission table in the runtime . The operating system page permission table is maintained at block such that the protection for the page on which the memory address corresponding to the watchpoint is located is set to the more restrictive of the protections set by the debugger and the runtime . From block control returns to block for further monitoring of memory addresses by the debugger .

If the user deletes at block a watchpoint then the debugger changes the protection for the page on which the memory address was located. The change in protection is made in the debugger page permission table . In certain embodiments the debugger may remove a page from the debugger page permission table if the page does not include at a memory address associated with at least one watchpoint. The copy of the debugger page permission table is updated at block and the operating system page permission table is maintained at block such that protection for the page is set to the more restrictive of the protections set by the debugger and the runtime . From block control returns in to block for further monitoring of memory addresses by the debugger .

If a watchpoint is not set at block or a watchpoint is not deleted at block then control returns to block for further monitoring of memory addresses by the debugger .

Certain embodiments illustrated in allows a user to set or delete a watchpoint by a debugger that is being used to debug a debuggee application . When a watchpoint is set or deleted the debugger page permission table in the debugger the copy of the debugger page permission table in the runtime and the operating system page permission table are updated such that the protection for the page corresponding to the memory address for which the watchpoint is set or deleted is the more restrictive of the protections set by the debugger and the runtime . While blocks are being executed the runtime may also set protections on various pages and store the protections in the runtime page permission table where a copy of the runtime page permission table is maintained in the debugger . The setting and deletion of watchpoints illustrated in may be performed before during or after the processing of segmentation violations by the runtime and the debugger .

Control starts at block where the operating system generates and sends a segmentation violation signal for a page to the debugger and the runtime in response to the execution of the debuggee application . The segmentation violation signal may be generated by the operating system in response to an operation violating the protection that has been set for the page. In certain embodiments the protection for the page may have been set either by the debugger or by the runtime or by both the debugger and the runtime .

Control proceeds in parallel to blocks and where in block the debugger receives the segmentation violation signal and avoids processing the signal because the flag to avoid processing directly received segmentation violation signals was set in the debugger at block of . After the debugger receives at block the segmentation violation signal directly from the operating system and avoids processing the signal control returns to block where additional segmentation violation signals may be generated by the operating system .

The runtime receives at block the segmentation violation signal for a page from the operating system . The runtime determines at block whether the signal could have been caused because of the protection on the page set by the runtime . If so the runtime processes at block the segmentation violation signal and if necessary changes the protection on the page for the runtime and if necessary the protection on the page for the operating system such that the protection on the page for the operating system is the more restrictive of the protections set by the debugger and the runtime for the page. The copy of the runtime page permission table that is maintained on the debugger may also be updated.

The runtime determines at block whether the segmentation violation signal could have been caused because of the protection on the page set by the debugger. If so then the breakpoint set at block of by the debugger in the runtime is triggered and the runtime forwards at block the segmentation violation signal to the debugger for processing and may also optionally send an indication that the debugger set protections could have caused the segmentation violation signal. When the runtime communicates the segmentation violation signal to the debugger the debuggee application stops because of the triggering of the breakpoint set at block of by the debugger .

The debugger receives at block the forwarded segmentation violation signal from the runtime and initiates the processing of the segmentation violation signal to determine at block whether a watchpoint set by the user has been hit. In certain embodiments on receiving the forwarded segmentation violation signal the debugger may call a function to process the breakpoint set in the runtime by the debugger and the function called by the debugger processes the segmentation violation signal. The function may report an error in the debuggee application if the address that generated the segmentation violation signal is not on a page that is being watched or if a segmentation violation occurs when the debuggee application is being single stepped by the debugger . Otherwise the instruction being processed is a potential hit on a watchpoint i.e. the segmentation violation may have been caused by a violation of the protection set by the debugger .

If a determination is made at block that a potential watchpoint has been hit then the debugger removes at block the protection for the page previously set by the debugger where the page corresponds to the memory address monitored via the watchpoint. The removal of the protection for the page previously set by the debugger causes the debugger page permission table to be updated in the debugger . The copy of the debugger page permission table is updated at block in the runtime and if necessary the operating system page permission table is updated to set the more restrictive of the debugger and the runtime set protections for the page. The debugger completes the handling at block of the potential watchpoint hit by setting up a single stepping breakpoint and single steps through the breakpoint to handle the watchpoint hit. Control returns to block to handle the next segmentation violation signal. If a determination is made at block that a potential watchpoint has not been hit then a segmentation violation signal is reported at block to a user and control returns to block to handle the next segmentation violation signal.

If at block the runtime determines that the segmentation violation signal could not have been caused because of the protection on the page set by the runtime then control proceeds to block where the runtime forwards the signal to the debugger for processing. Additionally if at block the runtime determines that the segmentation violation signal could not have been caused because of the protection on the page set by the debugger then control returns to block .

In certain embodiments that have not been fully illustrated in the debuggee application may also raise a segmentation violation signal that is not caused by the protections set by the debugger or the runtime . In such a case the segmentation violation signal raised by the debuggee application is processed by the debugger . For example in certain embodiments when the runtime receives a segmentation violation signal corresponding to an access to a page the runtime may check to determine if the runtime s own protections would have caused the segmentation violation signal. If so the runtime may handle the segmentation violation signal and change the protection of the page but not to a value that is less protected than the protection set by the debugger for the page. If the protection set by the debugger would have caused the segmentation violation signal or neither the runtime s nor the debugger s protection would have caused the segmentation violation signal the runtime may call a function inform debugger of segv event with the faulting address the instruction pointer and the runtime permissions for the page. When the runtime calls the function inform debugger of segv event the debuggee application would stop because of a breakpoint set earlier. The debugger may then call a function handle event to process the breakpoint which in turn may call a function handle SEGV . The function handle SEGV may report an error in the debuggee application if the faulting address is not on a page that is being watched or if a segmentation violation occurs when the debuggee application is single stepping an instruction. Otherwise the current instruction may be a potential watchpoint hit. To handle a potential watchpoint hit the debugger may remove the protection for the watchpoint by changing the protection of the page to the protection of the runtime set up a single stepping breakpoint and single step to handle the watchpoint.

Certain embodiments described in include a debugger a runtime and an interface library that couples the debugger to the runtime . Certain embodiments allow the debugger to debug a program such as the debuggee application where the debuggee application is executed in an environment provided by the runtime .

In certain embodiments the debugger ignores all segmentation violation signals received directly from the operating system . The runtime receives all segmentation violation signals from the operating system and determines the reason for the occurrence of the segmentation violation signal. If the segmentation violation signal is caused by a protection on a page set by the runtime then the runtime processes the segmentation violation signal. If the segmentation violation signal could also have been caused by the debugger the runtime forwards the segmentation violation signal to the debugger . Additionally if the signal is not caused by a protection set by the runtime then the segmentation violation signal is forwarded to the debugger for processing. In certain embodiments any protection applied to a page by the operating system is the more restrictive of the protections for the page set by the debugger and the runtime .

The runtime of certain distributed shared memory systems may install a segmentation violation handler to maintain the consistency of the shared memory model. Certain embodiments allow an application that executes in a runtime that has a segmentation violation handler to be debugged by a debugger that sets watchpoints that cause segmentation violations.

Certain embodiments allow watchpoints to be used in a debugger to debug a distributed shared memory application within a runtime that includes a segmentation violation handler. In certain embodiments both the runtime and the debugger are implemented such that both are aware about the protections that the other has put on any pages that are monitored by both.

In alternative embodiments that may be implemented in certain operating systems such as LINUX or MICROSOFT WINDOWS the debugger may see a segmentation violation signal before the runtime sees the segmentation violation signal. The debugger can then determine whether the debugger is ignoring the segmentation violation signal so that the runtime can see the segmentation violation signal or catching the segmentation violation signal so that the runtime never sees the segmentation violation signal .

The described techniques may be implemented as a method apparatus or article of manufacture involving software firmware micro code hardware and or any combination thereof. The term article of manufacture as used herein refers to program instructions code and or logic implemented in circuitry e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc. and or a computer readable medium e.g. magnetic storage medium such as hard disk drive floppy disk tape optical storage e.g. CD ROM DVD ROM optical disk etc. volatile and non volatile memory device e.g. Electrically Erasable Programmable Read Only Memory EEPROM Read Only Memory ROM Programmable Read Only Memory PROM Random Access Memory RAM Dynamic Random Access Memory DRAM Static Random Access Memory SRAM flash firmware programmable logic etc. . Code in the computer readable medium may be accessed and executed by a machine such as a processor. In certain embodiments the code in which embodiments are made may further be accessible through a transmission medium or from a file server via a network. In such cases the article of manufacture in which the code is implemented may comprise a transmission medium such as a network transmission line wireless transmission media computer accessible signals propagating through space computer accessible radio waves computer accessible infrared signals etc. Of course those skilled in the art will recognize that many modifications may be made without departing from the scope of the embodiments and that the article of manufacture may comprise any information bearing medium known in the art. For example the article of manufacture comprises a storage medium having stored therein instructions that when executed by a machine results in operations being performed. Furthermore program logic that includes code may be implemented in hardware software firmware or any combination thereof. The described operations of may be performed by a processor or circuitry where circuitry refers to either hardware or software or a combination thereof. The circuitry for performing the operations of the described embodiments may comprise a hardware device such as an integrated circuit chip a PGA an ASIC etc. The circuitry may also comprise a processor component such as an integrated circuit and code in a computer readable medium such as memory wherein the code is executed by the processor to perform the operations of the described embodiments.

Certain embodiments illustrated in may implement a system comprising a processor coupled to a memory wherein the processor is operable to perform the operations described in .

Certain embodiments may be implemented in a computer system including a video controller to render information to display on a monitor coupled to the system where the computer system may comprise a desktop workstation server mainframe laptop handheld computer etc. An operating system may be capable of execution by the computer system and the video controller may render graphics output via interactions with the operating system. Alternatively some embodiments may be implemented in a computer system that does not include a video controller such as a switch router etc. Also some embodiments may be implemented in a computer system where the video controller does not have the capability of rendering graphics output but has the capability of rendering text output. Furthermore in certain embodiments the device may be included in a card coupled to a computer system or may be on a motherboard of a computer system.

Certain embodiments may be implemented in a computer system including a storage controller such as a Small Computer System Interface SCSI AT Attachment Interface ATA Redundant Array of Independent Disk RAID etc. controller that manages access to a non volatile storage device such as a magnetic disk drive tape media optical disk etc. Certain alternative embodiments may be implemented in a computer system that does not include a storage controller such as certain hubs and switches.

The terms certain embodiments an embodiment embodiment embodiments the embodiment the embodiments one or more embodiments some embodiments and one embodiment mean one or more but not all embodiments unless expressly specified otherwise. The terms including comprising having and variations thereof mean including but not limited to unless expressly specified otherwise. The enumerated listing of items does not imply that any or all of the items are mutually exclusive unless expressly specified otherwise. The terms a an and the mean one or more unless expressly specified otherwise.

Devices that are in communication with each other need not be in continuous communication with each other unless expressly specified otherwise. In addition devices that are in communication with each other may communicate directly or indirectly through one or more intermediaries. Additionally a description of an embodiment with several components in communication with each other does not imply that all such components are required. On the contrary a variety of optional components are described to illustrate the wide variety of possible embodiments.

Further although process steps method steps algorithms or the like may be described in a sequential order such processes methods and algorithms may be configured to work in alternate orders. In other words any sequence or order of steps that may be described does not necessarily indicate a requirement that the steps be performed in that order. The steps of processes described herein may be performed in any order practical. Further some steps may be performed simultaneously in parallel or concurrently.

When a single device or article is described herein it will be apparent that more than one device article whether or not they cooperate may be used in place of a single device article. Similarly where more than one device or article is described herein whether or not they cooperate it will be apparent that a single device article may be used in place of the more than one device or article. The functionality and or the features of a device may be alternatively embodied by one or more other devices which are not explicitly described as having such functionality features. Thus other embodiments need not include the device itself.

The data structures and components shown or referred to in are described as having specific types of information. In alternative embodiments the data structures and components may be structured differently and have fewer more or different fields or different functions than those shown or referred to in the figures.

Therefore the foregoing description of the embodiments has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Many modifications and variations are possible in light of the above teaching.

