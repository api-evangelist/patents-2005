---

title: Object-oriented processing of markup
abstract: An application-specific client for object-oriented processing of markup includes a model object and a plurality of element objects. The model object is configured to respond to client requests including construct-element, accept-root-element, and accept-root-text. The element objects are configured to respond to client requests including accept-attribute, accept-element, and accept-text. Responses to requests contain application-specific processing as necessary. A driver generates client requests in response to processing of XML markup. An RSS client processes markup describing syndicated web content to HTML markup.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07844956&OS=07844956&RS=07844956
owner: 
number: 07844956
owner_city: 
owner_country: 
publication_date: 20051123
---
This application claims the benefit of Patent Provisional Application Ser. No. 60 631 291 filed on Nov. 24 2004.

This invention relates to application specific object oriented processing of markup including but not limited to the Extensible Markup Language XML .

Object oriented programming has been embraced by many programmers seeking to enhance their productivity. A useful introduction to object oriented programming may be found in the book Object Oriented Analysis and Design with Applications 2nd Edition by Grady Booch Benjamin Cummings 1994 ISBN 0 8053 5340 2. Another useful object oriented programming text is Design Patterns Element of Reusable Object Oriented Software by Erich Gamma Richard Helm Ralph Johnson and John Vlissides Addison Wesley 1995 ISBN 0 201 63361 2. For the language programming language C which will be utilized in this disclosure a useful reference is The C Programming Language 3rd Edition by Bjarne Stroustup Addison Wesley 1997 ISBN 0 201 88954 4. Each of these reference is incorporated herein by reference.

In object oriented programming an object encapsulates both data and operations. An object is an instance of one or more classes. A class defines data and operations which are available for objects which are instances of the class. An element of data defined in a class is denoted a member. Each distinct object from a class has its own distinct instance of each member except where members are explicitly denoted as class members in which case all class instances share the same data instance. An operation defined for an object from a class is denoted a member function. A member function may be invoked for an object which is an instance of the class in which it is defined the member function may make use of the member data which is specific to the particular object for which the member function was invoked.

An object oriented programming language includes facilities for class definition as well as facilities for creating objects invoking operations on objects and destroying objects. Some popular object oriented programming languages are C Java and C .

An application is a computer program that carries out some useful task on behalf of a user. Applications are oriented towards such fields as business engineering entertainment and media production. An object oriented application uses application specific classes to represent entities that are meaningful in the context of the application. Thus a business application might use application specific classes to represent customers purchase orders inventory items and shipments. In an object oriented application class facilities are used to instantiate application specific objects which are then utilized to carry out operations which are meaningful in the context of the application.

Among the important characteristics of application specific objects are associations which represent relationships between application specific objects. For example in a business application an application specific object representing a purchase order might be associated with an application specific object representing a customer. Similarly a customer object could be associated with a plurality of purchase order objects. Such associations may be realized by use of pointer or references members. For example a purchase order object could contain a pointer member which indicates the subject object. A collection of application specific objects configured to represent application specific relationships is denoted an application specific object oriented data structure. An application specific object oriented data structure is a useful component in an application. Indeed an application is often most easily understood as a process in which an application specific object oriented data structure is created from an stored representation operations reflecting meaningful activities in the application context are performed on the data structure and a stored representation is written. The stored representations which are read and written by an application are often in the form of markup.

An application specific data structure typically includes numerous application specific objects organized according to one or more schemes that reflect the requirements of the application. It is often convenient to encapsulate the application specific object oriented data structure in a single model object. The model object s class or classes may define one or more members which reference application specific objects singly or in collections and one or more member functions which facilitate random access to particular application specific objects. For example a model class in a business application might define a member function in which a customer object is provided in response to a textual customer number. Such a model class might further provide the entire collection of customers or a collection of purchase orders which have been received but not yet shipped. The particular members and member functions of a model class are designed to facilitate the performance of the tasks that are the purpose of the application.

The stored representations which are read and written by applications are often in the form of markup. Of particular importance for markup is XML which is in wide use. A useful reference for XML is the book XML In a Nutshell 3rd Edition by Elliotte Rusty Harold and W. Scott Means published by O Reilly 2004 ISBN 0 596 00764 7 incorporated herein by reference. Many applications are required to read or write XML or other markup languages.

Markup consists of hierarchically organized tagged elements. A tagged element typically consists of a start tag an optional body and an end tag. Where the body is absent the start tag and end tag may be combined into a single tag. The start tag includes a textual tag name and optional attributes. The tag name describes the tagged element. Each attribute includes a textual key and a textual value. Attributes may provide additional descriptive information about the tagged element. The body of the tagged element may contain both instances of textual content and nested tagged elements. The end tag concludes the tagged element.

The hierarchical organization of markup is reflected in the nesting of tagged elements. The body of a tagged element may contain nested tagged elements as well as textual content. The containing tagged element is denoted the parent. The nested tagged element is denoted the child. A tagged element which lacks a parent is denoted a root. In XML a well formed document is required to contain exactly one root tagged element.

An application programming interface APT specifies an interface to computational services. An API permits decomposition of a programming task between the provider of the API and the consumer of the API. As long as clients and providers adhere to the API diverse clients may make use of a single provider. Likewise providers may be freely interchanged without affecting clients. APIs are available which facilitate markup processing. Although markup may be processed by any programming language object oriented languages including Java and scripting languages includes Perl and Python have been most widely used. However C and especially C are also well suited to markup processing. The aforementioned XML book covers Java programming interfaces. A reference for C programming interfaces may be found in the book C XML by Fabio Arciniegas published by New Riders 2002 ISBN 0 7357 1052 X incorporated herein by reference.

The oldest XML API is the Document Object Model DOM . DOM processes markup to a tree like data structure. DOM is a W3C standard which is documented online at . DOM presents markup as an object oriented data structure however the objects of the presentation faithfully reflect the structure and properties of the markup. DOM does not provide application specific objects for business engineering entertainment or artistic applications.

An alternative API to DOM is SAX the Simple API for XML. SAX processes markup to a series of event notifications where the event notifications correspond to particular subelements of the processed markup. Expat is a open source implementation of the SAX API originally written by James J. Clark with contributions by David Megginson and David Brownell. Expat is in wide use. Expat materials may be found online at the official Expat website http sax.source forge.net . Expat does not provide object oriented facilities for markup processing other than the SAX processor itself the operation of which is controlled using an object oriented interface.

SAX and DOM are of limited benefit to a programmer who desires an application specific object oriented data structure consisting of application specific objects interconnected to reflect properties and associations that are natural to the application. To build an application specific object oriented data structure from SAX notifications a programmer must maintain complex context to interpret the events in terms of the ongoing construction of the desired structure. In DOM the programmer must systematically traverse a complex tree structure generating a parallel structure consisting of application specific objects. In both SAX and DOM the programmer must invest significant additional effort to construct the desired application specific object oriented data structure.

Thus it would be advantageous to reduce the effort required for the construction of an application specific object oriented data structure from markup. It would also be advantageous to maximize flexibility in the structure and function of the application specific objects which are constructed corresponding to tagged elements.

An application specific client for object oriented processing of markup includes a model object and a plurality of element objects. The model object is configured to respond to client requests including construct element accept root element and accept root text. The element objects are configured to respond to client requests including accept attribute accept element and accept text. Responses to requests contain application specific processing as necessary. A driver generates client requests in response to processing of XML markup. An RSS client processes markup describing syndicated web content to HTML markup.

An instance of the model encapsulates the application specific object oriented data structure which is produced by processing the markup. The model instance corresponds to the totality of the processed markup including one or more documents. The model instance responds to a request construct element which is requested when a start tag is detected in the markup. The model instance responds to a request accept root element which is requested when a root instance of the element has been successfully processed from markup. The model instance responds to a request accept root text which is requested when root textual content is detected in the markup.

An instance of the model responds to the request construct element . The construct element is requested when a start tag is detected in the markup. The construct element is supplied with an argument name a instance of text which indicates the tag name. The construct element responds with a newly constructed instance of the element unless the request is invalid in which case the construct element returns null.

An instance of the model responds to the request accept root element . The accept root element is requested when a root element has been successfully processed from markup. In XML a single root element is permitted in a document but the interface permits the model to enforce or relax that requirement. The accept root element is supplied with an argument element an instance of the element . The accept root element returns a boolean value indicating whether the supplied element was acceptable to the responsive instance of the model . The responsive model instance assumes responsibility for the eventual deletion of the supplied element .

An instance of the model responds to the request accept root text . The accept root text is requested when root textual content is processed from the markup. Root text is textual content which is outside of any tagged element. Often such text is ignored but the model instance may enforce any policy. The accept root text is supplied with an argument text a instance of text representing the root textual content. The accept root text returns a boolean value indicating whether the supplied text was acceptable to the responsive model instance.

An instance of the element corresponds to a tagged element. A tagged element includes a start tag optional attributes an optional body containing nested tagged elements and text and an end tag. The element instance responds to a request accept attribute which is requested when an attribute is detected in the start tag of the corresponding tagged element. The element instance responds to a request con which is requested after all the attributes in the start tag have been processed but before any text or tagged elements have been processed from the body of the corresponding tagged element. The element instance responds to a request accept element which is requested when a nested tagged element has been successfully processed from the body of the corresponding tagged element. The element instance responds to a request accept text which is requested when textual content has been processed from the body of the corresponding tagged element. The element instance responds to a request commit which is requested when the end tag of the corresponding tagged element has been detected.

An instance of the element responds to the request accept attribute . The accept attribute is requested when an attribute is detected in the start tag of the corresponding tagged element. The accept attribute is provided with an argument key of text representing the attribute key. The accept attribute is provided with an argument value of text representing the attribute value. The accept attribute is provided with an argument model an instance of the model encapsulating the application specific data structure. The accept attribute returns a boolean value indicating whether the attribute was successfully processed. The responsive element instance may use the return value to indicate. whether a supplied attribute is recognized or whether any externalities implied by the supplied attribute have been satisfied.

An instance of the element responds to the request con. The con is requested after all the attributes in the start tag have been detected but before any text or tagged elements have been processed from the body of the corresponding tagged element. The con is provided with an argument model an instance of the model encapsulating the application specific data structure. The con returns a boolean value indicating whether the previously supplied attributes if any are satisfactory for the purposes of the responsive element instance. The responsive element instance may use this request to determine whether any required attributes have been provided.

An instance of the element responds to the request accept element . The accept element is requested when a nested tagged element has been successfully processed from the body of the corresponding tagged element. The accept element is supplied with an argument element an instance of the element corresponding to the nested tagged element which is subject to acceptance. The accept element is supplied with an argument model an instance of the model encapsulating the application specific data structure. The accept element returns a boolean value indicating whether the supplied element is satisfactory for containment by the responsive instance of the element . The responsive element instance assumes responsibility for the eventual deletion of the supplied element .

An instance of the element responds to the request accept text . The accept text is requested when textual content has been processed from the body of the corresponding tagged element. The accept text is supplied with an argument text an instance of text representing the textual content. The accept text is supplied with an argument model an instance of the model encapsulating the application specific data structure. The accept text returns a boolean value indicating whether the supplied text is satisfactory for containment by the responsive element instance.

An instance of the element responds to the request commit . The commit is requested when the end tag of the corresponding tagged element has been detected. The commit is supplied with an argument model an instance of the model encapsulating the application specific data structure. The accept text returns a boolean value indicating whether the responsive element instance is in a satisfactory condition for ending. The responsive element instance may use this request to determine whether any required subelements have been provided.

A first line of markup presents a start tag of a root tagged element. The start tag is processed to generate the request construct element which is requested to a demo model . The demo model is an instance of the model . The request returns a demo item an instance of the element . For simplicity the demo item and subsequent returned elements from the construct element are shown here as if they were assigned to variables. More typically the newly constructed elements would be pushed onto a stack. There are no attributes to be supplied to the demo item so the con is requested of the demo item providing a notification to the demo item that all attributes have been processed.

A second line of markup presents a start tag of a nested tagged element. The start tag is processed to generate the request construct element which is directed to the demo model . The request returns a demo title an instance of the element . There are no attributes to be supplied to the demo title so the con is requested of the demo title 

A third line of markup presents textual content. The textual content is processed to generate the accept text which is directed to the demo item .

A fourth line of markup presents an end tag of a nested tagged element. The end tag is processed to generate the request commit which is directed to the demo title . The demo title fully processed is now presented to the containing element. A request accept element directed to the demo item presents the demo title .

A fifth line of markup presents a start tag of a nested tagged element including an attribute. The start tag is processed to generate the request construct element which is directed to the demo model . The request returns a demo link an instance of the element . The attribute href is presented to the newly constructed demo link in a request accept attribute . The con is then requested of the demo link . The end tag is immediately detected a request commit is directed to the demo link following which a request accept element is directed to the demo item presenting the demo link .

A sixth line of markup presents an end tag of the root tagged element corresponding to the demo item . A request commit is directed to the demo item and the demo item is presented to the demo model in a request accept root element .

The xml driver is partitioned between an abstract xml driver and a generic xml driver . The abstract xml driver interfaces directly with expat. The abstract xml driver is independent of particular client implementations of the model and the element . The abstract xml driver specifies pure virtual notification methods which its specializations must provide to respond to expat notifications.

The generic xml driver specializes the abstract xml driver . The generic xml driver is a template class which is parameterized by client implementations of the model and the element . The generic generic xml driver specializes the virtual member functions of the abstract xml driver which represent the expat notifications the expat notifications are converted to client requests in the interface specialized to the particular client implementations of the model and the element by which the generic xml driver is parameterized.

Before plunging into the details of the abstract xml driver and the generic xml driver there is a technicality pertaining to expat notifications. Expat makes extensive use of the XML Char typedef throughout its programmer s interface which may be a 16 or 8 bit encoded datum. In case the data is encoded using UTF 8 the XML Char is defined to be the usual C char. Conceptually in the various notifications expat provides there are names attributes and buffers. Expat interfaces simply use variants of the indirect references to XML Char for all these elements. In the particular embodiment the names attributes and buffers are distinguished for clarity.

A member parser is provided by the abstract xml driver . The parser is of type XML parser. The XML parser is defined by expat the parser is an opaque pointer to the expat parser.

A boolean member failed is provided by the abstract xml driver . The member failed represents the parse status if any failure has been detected the failed will be true.

A constructor is provided by the abstract xml driver . The constructor initializes the parser to null and the member failed to false.

A member function parse is provided by the abstract xml driver . The parse directs the abstract xml driver to process XML markup from a supplied file handle. The parse is supplied with a file handle representing the file from which the markup shall be read. The parse returns a boolean value indicating the success of the parse. The parse is considered in detail below.

A class function start tag handler is provided by the abstract xml driver . The start tag handler receives expat notifications indicating the start tag of a tagged element. The start tag handler is a class member hence a global function as distinguished from a member function . It is thus invoked without a responsive instance of the abstract xml driver . The start tag handler is supplied with a first argument of pointer to void representing arbitrary client data. The start tag handler is supplied with a second argument of type expat name representing the tag name. The start tag handler is supplied with a third argument of type expat attributes representing the tag attributes if any. The start tag handler returns void expat does not accept any returned information from a notification. The start tag handler is considered in detail below.

A class function end tag handler is provided by the abstract xml driver . The end tag handler receives expat notifications indicating the end of a tagged element. The end tag handler is a class member hence a global function as distinguished from a member function . It is thus invoked without a responsive instance of the abstract xml driver . The end tag handler is supplied with a first argument of pointer to void representing arbitrary client data. The end tag handler is supplied with a second argument of type expat name representing the tag name. The end tag handler returns void expat does not accept any returned information from a notification. The end tag handler is considered in detail below.

A class function characters handler is provided by the abstract xml driver . The characters handler receives expat notifications indicating the receipt of textual content. The characters handler is a class member hence a global function as distinguished from a member function . It is thus invoked without a responsive instance of the abstract xml driver . The characters handler is supplied with a first argument of pointer to void representing arbitrary client data. The characters handler is supplied with a second argument of type expat buffer a buffer holding the parsed textual content. The characters handler is supplied with a third argument of type int indicating the length of the supplied buffer. The characters handler returns void expat does not accept any returned information from a notification. The characters handler is considered in detail below.

A pure virtual member function start tag is provided by the abstract xml driver . The start tag must be provided by specializations of the abstract xml driver . The start tag is the indirect recipient of the expat notification of the start tag of a tagged element. The start tag receives a first argument of type expat name indicating the tag name. The start tag receives a second argument of type expat attributes indicating the tag attributes if any. The start tag returns void.

A pure virtual member function end tag is provided by the abstract xml driver . The end tag must be provided by specializations of the abstract xml driver . The end tag is the indirect recipient of an expat notification of the end of a tagged element. The end tag receives an argument of type expat name indicating the tag name. The end tag returns void.

A pure virtual member function characters is provided by the abstract xml driver . The characters must be provided by specializations of the abstract xml driver . The characters is the indirect recipient of an expat notification of textual content. The characters receives a first argument of type expat name a buffer holding the parsed textual content. The characters receives a second argument of type int indicating the length of the supplied buffer. The characters returns void.

A member function fail is provided by the abstract xml driver . The fail provides a convenient mechanism for reporting parse failure. The fail receives an argument of type text which may be used to formulate a status message. The fail sets the failed to nonzero indicating the failure status of the parse. The fail returns zero to indicate failure.

An unbounded loop is designated to encompass the reading of arbitrary length markup. The standard C library service fread is invoked to read into the buffer from the supplied file handle . The number of bytes actually read is captured in a bytes read . The standard C library service ferror is invoked to determine whether the supplied file handle has become invalid. Should the file handle have reported an error read failure is reported and the loop is broken. The end of file status on file handle is determined using the standard C library service feof . The end of file status is captured in an integer done which is used by expat and consulted below regarding termination of the loop. The expat service XML Parse is invoked for the parser the buffer and the done . If the XML Parse indicated failure the error is reported and the loop is broken. If any failure has been indicated e.g. by one of the expat client notifications the failure is noted and the loop is broken. The loop is broken if the done indicates that end of file has been reached.

After the loop the parser is freed using the expat service XML ParserFree . The parser is assigned null reflecting that after being freed the parser is no longer valid. The parse returns the inversion of the member failed indicating the success of the parse.

The generic xml driver provides several data members. A member model is provided by the generic xml driver . The model is of type . The model is a client implementation of the model . A member stack is provided by the generic xml driver . The stack is stack of instances of the . The stack is a well known data structure which manages a sequence in last in first out order providing push pop and top operations which respectively add a last element to the stack remove the last element from the stack and access but not remove the last element from the stack.

The generic xml driver provides two factory member functions. A constructor is provided by the generic xml driver . The constructor receives an argument of which serves to initalize the model . A destructor is provided by the generic xml driver . The destructor is empty.

The generic xml driver provides specializations of the pure virtual expat notifications defined by the base abstract xml driver . A member function start tag is provided by the generic xml driver . The start tag processes expat notifications indicating the start tag of a tagged element. The start tag specializes the start tag . The start tag receives a first argument of expat name indicating the name of the tagged element. The start tag receives a second argument of expat attributes representing the attributes of the tagged element. The start tag is considered in detail below.

A member function end tag is provided by the generic xml driver . The end tag processes expat notifications indicating the end of a tagged element. The end tag specializes the end tag . The end tag receives an argurment of expat name indicating the name of the tagged element. The end tag is considered in detail below.

A member function characters is provided by the generic xml driver . The characters processes expat notifications indicating textual content. The characters receives a first argument of expat buffer containing the textual content. The characters receives a second argument of type int indicating the amount of data in the supplied expat buffer . The characters is considered in detail below.

A member function push is provided by the generic xml driver . The push receives an argument of . The supplied is pushed onto the stack .

A member function pop is provided by the generic xml driver . The pop removes and returns the topmost from the stack .

A member function top is provided by the generic xml driver . The top is of type . The pop returns the topmost from the stack but does not change the stack .

A member function is empty is provided by the generic xml driver . The is empty returns a boolean value indicating whether the stack is empty.

A string is initialized to the attribute array . While the string is non zero the next attribute key value pair is indirectly visited from the attribute array via the string . An attribute of tagged element has been detected. A key is obtained. A value is obtained. The accept attribute is requested of the element with arguments key value and model . If the accept attribute request fails the failure is noted the element is deleted and the member function returns.

When all the attributes have been processed hence the absence of additional attributes has been detected the con is requested of the element with argument model . If the con fails the failure is noted the element is deleted and the member function returns. Otherwise the configured element is pushed onto the stack using the push . The stack maintains an association between the markup element which is being processed and the element object to which requests shall be directed.

The presence of an element on the stack is determined via the top . If there s an element on the stack the accept element is requested of the top with arguments the element and the model . An element object corresponding to a parent markup element is top most on the stack and the recently popped element object corresponds to a child markup element. If the accept element fails the failure is noted the element is deleted and the end tag returns.

Otherwise in the case where there s no element on the stack the popped corresponds to a root tagged element. The accept root element is requested of the model with argument the element . If the accept root element invocation fails the failure is noted the element is deleted and the end tag returns.

Otherwise there s no topmost stack element so a root instance of textual content has been detected and hence the supplied text is directed to the model. The accept root text is requested of the model with argument the text . If the accept root text invocation fails the failure is noted and the characters returns.

In some subsequent figures depicting classes the C keyword struct is used in class definitions. This usage indicates that all of the depicted members and member functions have public scope by default members of a C class declared as a struct have public scope . In an alternative embodiment the class keyword could be used in which case by default members would have private scope. The struct convention is used here to avoid cluttering the depictions with access member functions. In an alternative embodiment members would be private with public member functions provided to get and set those data members where necessary. Most member functions would remain public but certain member functions could be made private where their access is not required outside the class implementation.

The trivial module is useful as a validator of markup structure. The trivial module is also useful as a cut and paste starting point for a more elaborate implementation of the client . In languages which do not provide facilities for generic programming templates the trivial module may provide base classes suitable for deriviation by a non trivial implementation of the client . In an alternative embodiment in C which avoids templates an implementation of the driver would direct requests to instances of the trivial module . A non trivial client would derive from the classes of the trivial module with specialized member functions responsive to the requests of the interface .

The advantages of the interface may be illustrated by an example of a simple but useful application processing RSS a family of popular syndication markup languages. RSS is used by many web content providers to summarize and promote their web offerings. The RSS family of languages is defined by several standards of varying specificity for distribution of syndication information. A useful RSS reference is the book Developing Feeds with RSS and Atom by Ben Hammersley O Reilly 2005 ISBN 0 596 00881 3. In RSS a feed includes one or more channels. A channel includes one or more items. Each of the items may include a title a link a description and many other descriptive elements. A very common RSS application is to process one or more RSS feeds and produce an HTML summary page which incorporates descriptions and links to the syndicated content. Such an application may conveniently ignore many of the elements in the feed.

A class model specializes the model . An instance of the model encapsulates an application specific object oriented data structure representing one or more RSS feeds. A class element specializes the element . An instance of the element corresponds to an individual tagged element. The element provides a generalized base class from which classes corresponding to specific tagged elements are derived.

A class field inherits from the element . An instance of the field represents a unit of descriptive information pertaining to a channel or an item. A class title inherits from the field . An instance of the title represents the title of a channel or an item. A class link inherits from the field . An instance of the link represents a link associated with a channel or an item. A class description inherits from the field . An instance of the description represents a description assocated with a channel or an item.

A class composite inherits from the element . An instance of the composite represents a composite element of a feed including a channel or an item. A class item inherits from the composite . An instance of the item represents an item in a channel. A class channel inherits from the composite . An instance of the channel represents a channel in a feed. A class feed inherits from the element . An instance of the feed represents an entire feed.

A class html writer provides a transformation from RSS to HTML. A instance of the html writer processes an instance of the model writing an HTML file which summarizes the RSS represented by the model instance.

A member factory an instance of the factory constructs instances of the element in response to tag names. A sequence member feeds accumulates instances of the feed which have been detected in processing markup.

A destructor is responsible for deletion of the accumulated instances of the feed which are collected in the feeds .

A member function construct element provides the construct element . The construct element uses the factory to attempt to construct an instance of the element corresponding to the supplied text. If the factory fails an instance of the field is constructed.

A member function accept element provides the accept root element . The accept element attempts to accumulate the supplied element to the feeds the accumulation only succeeds if the supplied element is an instance of the feed . If the accumulation fails the supplied element is deleted.

A member function accept text provides the accept root text . The accept text always succeeds ignoring the supplied root textual content.

A member function put model feed provides a mechanism by which an instance of the model may attempt to accumulate an instance of the feed in the model s feeds . The model requests the put model feed of an instance of the element providing itself as the argument. By default an instance of the element may not accumulate itself thus the default implementation shown here returns zero indicating failure. However if the supplied element instance specializes to an instance of the feed the specialized feed instance may accumulate itself. The class feed provides a specialization of the put model feed which performs the accumulation. This is a convenient type safe method of achieving a downcast i.e. a run time specialization it s an example of the object oriented technique of double dispatch a valuable discussion of which may be found in the book More Effective C by Scott Meyers Addison Wesley 1996 ISBN 0 201 63371 X pp. 228 251.

A member function put feed channel provides a mechanism by which an instance of the feed may attempt to accumulate an instance of the channel . A double dispatch technique as described above is used. A member function put channel item provides a mechanism by which an instance of the channel may attempt to accumulate an instance of the item . A double dispatch technique as described above is used. A member function put field provides a mechanism by which an instance of the composite may attempt to accumulate an instance of the field . A double dispatch technique as described above is used.

A member function accept element provides the accept element . The accept element invokes the put feed channel which if successful will accumulate a channel to the channels . Failing the put feed channel the suppled element is deleted.

A member function put model feed successfully specializes the double dispatch of the put model feed resulting in the accumulation of the feed into the supplied instance of the model .

The class composite specializes the element . A member title an instance of the title represents the title element in a composite element. A member link an instance of the link represents the link element in a composite element. A member description an instance of the composite represents a description element in a composite element. A destructor disposes of the field members.

The class channel specializes the composite . A sequence member items accumulates instances of the item .

A member function accept element provides the accept element . The accept element invokes the put channel item which if successful will accumulate an item to the items . Failing the put channel item the accept element invokes the put field which if successful set one of the field members of the composite . Failing the put field the supplied element is deleted.

A member function put feed channel successfully specializes the double dispatch of the put feed channel resulting in the accumulation of the instance of the channel into the channels of the supplied instance of the feed .

The class item specializes the composite . A member function accept element specializing the accept element invokes the put field which if successful will set one of the field members of the composite .

A member function put channel item successfully specializes the double dispatch of the put channel item resulting in the accumulation of the instance of the item to the items of the supplied instance of the channel .

The class title specializes the field . A member function put field specializing the put field successfully resolves a double dispatch in which a specialized instance of the title is made available to an instance of the composite the instance of the title is assigned to the title of the supplied instance of the composite .

The class link specializes the field . A member function put field specializing the put field successfully resolves a double dispatch in which a specialized instance of the link is made available to an instance of the composite the instance of the link is assigned to the link of the supplied instance of the composite .

The class description specializes the field . A member function put field specializing the put field successfully resolves a double dispatch in which a specialized instance of the description is made available to an instance of the composite the instance of the description is assigned to the description of the supplied instance of the composite .

The member function view feed invokes a member function view channel for each instance of the channels .

The member function view channel writes a HTML header and anchor hyperlink from the title and the link of the supplied instance of the channel . An HTML paragraph is written from the description of the supplied instance of the channel . The member function view channel invokes a member function view item for each instance of the items .

The member function view item writes a HTML header and anchor hyperlink from the title and the link of the supplied instance of the item . An HTML paragraph is written from the description of the supplied instance of the item .

A local model an instance of the model is constructed. A local driver is constructed. The driver is an instance of the generic xml driver parameterized by the model and the element . The driver is initialized with the model . Each command line argument in the argv array is processed a file handle is opened for the argument. This is a fallible invocation. The parse is requested of the driver with the file handle as an argument. This is also fallible invocation. The file handle is closed after parsing. A text file sink is constructed. The text file sink and the model are supplied to the construction of a local writer an instance of the html writer . The writer writes the product HTML to the supplied sink. A successful outcome is indicated by a zero return code.

