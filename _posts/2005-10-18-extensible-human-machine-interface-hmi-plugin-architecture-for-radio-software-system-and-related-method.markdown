---

title: Extensible human machine interface (HMI) plugin architecture for radio software system and related method
abstract: A software-defined radio includes an executable radio software system operable with a radio circuit and conforming to the software communications architecture (SCA) specification and defining an operating environment that allows a waveform application to operate with a radio circuit for transmitting and receiving voice and data. An extensible Human-Machine Interface (HMI) plugin module is operable for allowing a selected waveform application to integrate with the radio circuit and provide an HMI user interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08498629&OS=08498629&RS=08498629
owner: Harris Corporation
number: 08498629
owner_city: Melbourne
owner_country: US
publication_date: 20051018
---
The present invention relates to a software communication architecture SCA for radios and other applications.

With advances in processing capabilities and programming technologies software defined mobile wireless communications devices e.g. radios continue to increase in popularity. Rather than relying upon hardware and circuitry components to perform tasks such as frequency modulation bandwidth security functions and waveform requirements these functions are performed by software modules or components in a software radio. That is with a software radio analog signals are converted into the digital domain where the above noted functions may be performed using digital signal processing.

Because most of the functions of the radio are controlled by software software radios may typically be implemented with relatively standard processor and hardware components. This may not only reduce device hardware costs but is also provides greater flexibility in upgrading the device since new communications waveform modules can be uploaded to the device relatively easily and without the need to interchange new hardware components.

One particular class of software radio which takes advantage of the above described advantages features is the Joint Tactical Radio JTR . The JTR radio includes relatively standard radio and processing hardware along with the appropriate waveform software modules for the communication waveforms the radio will use. JTR radios also utilize operating system software that conforms with the Software Communications Architecture SCA specification see www.JTRS.saalt.mil which is hereby incorporated by reference in its entirety. The SCA is an open architecture framework that specifies how hardware and software components are to interoperate so that different manufacturers and developers can readily integrate their respective components into a single device.

Still another class of mobile wireless communications devices that increasingly use software components for communicating using different waveforms or protocols are cellular communication devices. That is many cellular devices are now designed to operate with more than one of the numerous cellular standards that are used throughout the world such as the Global System for Mobile Communications GSM and Personal Communications Services PCS for example.

The Joint Tactical Radio System JTRS Software Component Architecture SCA defines a set of interfaces and protocols often based on the Common Object Request Broker Architecture CORBA for implementing a Software Defined Radio SDR . In part JTRS and its SCA are used with a family of software re programmable radios. As such the SCA is a specific set of rules methods and design criteria for implementing software re programmable digital radios.

The JTRS SCA specification is published by the JTRS Joint Program Office JPO . The JTRS SCA has been structured to provide for portability of applications software between different JTRS SCA implementations leverage commercial standards to reduce development cost reduce development time of new waveforms through the ability to reuse design modules and build on evolving commercial frameworks and architectures.

The JTRS SCA is not a system specification as it is intended to be implementation independent but a set of rules that constrain the design of systems to achieve desired JTRS objectives. The software framework of the JTRS SCA defines the Operating Environment OE and specifies the services and interfaces that applications use from that environment. The SCA OE comprises a Core Framework CF a CORBA middleware and an Operating System OS based on the Portable Operating System Interface POSIX with associated board support packages. The JTRS SCA also provides a building block structure defined in the API Supplement for defining application programming interfaces APIs between application software components.

The JTRS SCA Core Framework CF is an architectural concept defining the essential core set of open software Interfaces and Profiles that provide for the deployment management interconnection and intercommunication of software application components in embedded distributed computing communication systems. Interfaces may be defined in the JTRS SCA Specification. However developers may implement some of them some may be implemented by non core applications i.e. waveforms etc. and some may be implemented by hardware device providers.

The SCA however does not specify the architecture for a Human Machine Interface HMI control and configuration management. It is necessary then to form an extensible architecture to allow dynamically loaded waveform specific interfaces to be implemented with a way to connect several HMI and waveform configuration management components. It is desirable to tie a configuration of a waveform to a radio wide configuration. Previous radio human machine interfaces were statically built into the radio firmware and thus not dynamically upgradable.

In view of the foregoing background it is therefore an object of the present invention to provide a software defined radio that includes an executable radio software system operable with a radio circuit and conforming to the SCA specification that allows a human machine interface.

In accordance with one aspect a non limiting embodiment of the present invention a software defined radio includes a radio circuit an executable radio software system operable with the radio circuit and conforming to the SCA specification and defining an operating environment that allows a waveform application to operate with a radio circuit for transmitting and receiving voice and data. An extensible Human Machine Interface HMI plug in module is operable for allowing a selected waveform application to integrate with the radio circuit and provide an HMI user interface.

In yet another aspect a system controller ASCII engine and Front Panel engine are included. The HMI plugin module includes a waveform plugin shared object that is operable with a selected waveform application and has plugin components for the system controller ASCII engine and Front Panel engine. The waveform plugin shared object can be formed as an ASCII plugin a System plugin and Front Panel plugin. The Front Panel plugin is operative for providing screens for configuring and operating the waveform application and providing a user interface.

In yet another aspect the ASCII plugin is operative for providing remote control commands for configuring and operating the waveform application. The Front Panel and ASCII plugins communicate directly with the System plugin for relaying information to the waveform application. The System plugin can also be operable for maintaining a configuration of a selected waveform application.

In yet another aspect a System Preset is linked to a selected waveform application for selecting a radio configuration. The System Precept can include a unique identifier and waveform name and waveform preset number for selecting and configuring a waveform application.

Different embodiments will now be described more fully hereinafter with reference to the accompanying drawings in which preferred embodiments are shown. Many different forms can be set forth and described embodiments should not be construed as limited to the embodiments set forth herein. Rather these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the scope to those skilled in the art. Like numbers refer to like elements throughout and prime notation is used to indicate similar elements in alternative embodiments.

A extensible HMI plugin architecture in one non limiting example of the present invention uses run time loaded dynamically linked libraries. Factory implemented design can be used to construct different components for a Front Panel remote control and system database control. Loadable components can use a common radio element to provide a consistent user interface and CORBA can be used between user interfaces and the system database control. Radio configurations can be selected using a System Preset that is linked to a waveform name and a waveform configuration.

In one non limiting embodiment of the invention an arbitrary number of waveforms can be inserted into a unified radio Human Machine Interface HMI . The system provides waveform software that updates independent of radio wide software and facilitates third party waveform development. The waveforms and operating environment can be integrated into a common field similar to a windows application environment. The operating environment can provide the infrastructure widgets database and rules while waveforms provide content. Thus the software communications architecture SCA that does not provide predefined mechanisms for the radio user interface is solved and can be incorporated into other radios that are using the SCA.

The extensible HMI and plugin architecture can be used for any type of radio software communications architecture as used on mainframe computers with an added transceiver such as to be used in large military installations or in a portable wireless communications device as illustrated in . The portable wireless communications device is illustrated as a radio that can include a handheld housing with an antenna and control knobs. An LCD can be positioned on the housing in an appropriate location for display. The various internal components including dual processor systems for red and black subsystems and software that is conforming with the software communications architecture platform is operative with the illustrated radio.

An extensible HMI plugin architecture as shown in at which provides a definition that allows a waveform to integrate with the system controller and include Human Machine Interface HMI components. Each waveform provides a Waveform Plugin Shared Object that contains plugin components for the System Controller the Ascii Engine and the Front Panel Engine . The Front Panel Plugin provides the necessary screens for configuring and operating the waveform . These screens are integrated into the built in set of screens in the radio to provide a seamless user interface. The Ascii Plugin provides remote control commands that extend the built in set of commands for configuring and operating the waveform. The Front Panel 32 and Ascii Plugins communicate directly to the System Plugin for relaying the information to the waveform. This System Plugin is also responsible for maintaining the configuration for the waveform. This configuration typically uses a global waveform configuration and one or more waveform configuration sets called waveform presets. When the waveform is instantiated one of these sets is passed down to the waveform to provide its operating parameters.

A JTRS radio can contain multiple waveforms each of which has multiple sets of configuration that determine how the waveform should operate when instantiated. In order to facilitate selecting a waveform and a particular configuration set a global System Preset system was created and an example is shown abstractly at in . In addition to a unique identifier for the System Preset i.e. System Preset Number the System Preset also contains a Waveform Name and the Waveform Preset Number for selecting and configuring the waveform to be instantiated e.g. selected created or initialized corresponding such as when a particular object type of the waveform is created. The Waveform Name matches the unique name given to the Waveform Application installed in the radio. The Waveform Preset Number is a unique identifier that selects a configuration set within the waveform. Using the Waveform Name the SCA architecture is informed to load the appropriate Waveform Application. The Waveform Preset Number is used by the Waveform System Plugin to retrieve the appropriate configuration set which is passed down to the Waveform Application when it is configured.

A plugin requires the waveform designer to develop a shared library and a pair of CORBA servants associated with the library. A plugin is a single term used to refer to this combination of a shared library and a CORBA servant.

An exemplary software operating environment specification for a radio includes a radio system control process the Human Machine Interface HMI processes Ascii and Front Panel which typically execute on the red command general purpose processor GPP of the radio instead of the black data general purpose processor. A Plugin shared library allows the waveform designer to extend the Ascii command shell and a Front Panel menuing system and provide a published Interface Definition Language IDL interface to the waveform s application specific behavior.

The shared library defined by a waveform s plugin is dynamically linked into the radio processes for any system control any Ascii command shell and any Front Panel menus. The class structure for a shared library typically has specialized dual inheritance hierarchy. One hierarchy provides base classes for any shared library plugins and another set of base classes for any factories which build the plugin classes. A factory class hierarchy is a well known design pattern for creating application specific components of a common base class type. This pattern is especially useful when the waveform designer adds application specific behavior to a radio in a predefined class hierarchy.

In addition to a dual class hierarchy a waveform designer defines a CORBA servant which implements a black box interface for the waveform application corresponding to the interface used by waveform HMI clients. These clients obtain a reference to the black box interface by using a CORBA Naming Service that is internal to the radio. All of the waveform interface objects are activated and run within the system control process of the radio.

A class hierarchy is shown in at and shows the classes that can be implemented by the waveform s plugin. A Plugin Factory is operative as a Plugin Record Plugin Interface and Ascii Factory Plugin Front Panel Factory Plugin and Base System Plugin .

The plugin factory is a first class in the framework that typically is implemented. It is used by the framework interface as a central starting point for a component to the appropriate plugin s features from a waveform s plugin factory.

Any IDL definition that specifies the CORBA communication between the plugin components namely between the Ascii or Front Panel plugin and the System plugin as shown in could be broken up into two files one that defines the enumerations constants structures etc. and 2 another that defines the interfaces. Both IDL files could declare the same module whose name is the current waveform name.

The Ascii Shell is the set of clients for the radio s central Ascii command server. There can be multiple command shells open to the radio at a given time and they can be provided over ttys TCP IP sockets files and or any radio external serial ports.

The Ascii Server centralizes the handling of calls coming from Ascii shells radio clients and provides Ascii output.

The Ascii Engine handles translation of the input received from shell clients and parses a main Ascii shell command table to dispatch a correct command instance. Each Ascii command that is processed by the radio can be implemented as a distinct class.

The Ascii Factory Plugin provides the base class from which each waveform Ascii command shell plugin is derived. The Ascii factory plugin uses the waveform s Ascii Factory Plugin to add each waveform specific command to the radio.

The Ascii Command provides the base class from which each waveform specific command is derived. It contains the tables for each specific command a way to handle the command when it is requested and a way to handle the response that is returned. These plugin classes use the black box CORBA interface to the waveform to execute specific commands.

Ascii Waveform Interface installs commands from the plugins by calling the Ascii Factory Plugin for each waveform installed. Instances of the commands are stored in a table of commands and the main table structure for each command is stored in a vector in the Ascii Waveform Interface.

Screens and other Front Panel components can register for and receive notification of via a CORBA interface status events that can result in an event for that screen or component.

Screens and other Front Panel components can create timers and will receive notification when those timers expire. The keypresses are from a Keypad and Display Driver KDPROC that screens can process and act upon. The Plugin Manager is a repository of all Front Panel plugins and holds references to each plugin s Event Handler which receives and processes any incoming events for example status events timers or keypresses. The Screen Manager maintains and manages a screen stack of instantiated screens. A screen is a layout and behavior of information to be displayed to the user. The Display Context is an abstraction of the Keypad and Display Driver which provides rules used to display the screens properly. The API corresponds to the interface functions to the Keypad and Display Driver to draw screens. As noted before the Keypad and Display Driver controls the LCD and handles interrupts from the keypad.

The Front Panel Plugin represents the portion of a waveform plugin devoted to the Front Panel and loaded in by the Plugin Manager . A System Plugin is operative with the IDL as an Interface Definition Language and operative with the Event Handler and screen . The Ascii Plugin is also illustrated and operative as a plugin.

Throughout this description the term widgets is used. Widgets can be used to display different kinds of information. Some non limiting examples of widget types are 

In one non limiting example a radio platform can provide each waveform with the facilities to define a database used to store information that is needed by the waveform each time the waveform is selected instantiated . This database is preserved in a non volatile storage of the radio platform. It is expected that the waveforms that are added to a platform may use this database facility to store preset configuration and other waveform specific settings. The database interface also has the facilities to store non persistent data in volatile memory. This allows the waveform to use a consistent interface to access configuration data that it defines regardless if the information needs to be persistent.

An exemplary radio database API uses many of the advanced features of C to facilitate automatic type conversion on input queries and on the results returned on database method invocations. This frees the waveform developer from having to concern themselves about wrapping variables in functions that provide type conversion.

When a waveform is initialized the system searches its plugin directory for a defaults.sql file. If one is found its version is checked and if the versions differ between a database file and SQL file the SQL file is evaluated. When a waveform is first installed no database file will exist and the defaults.sql file will be used by the system to provide the starting database. The defaults.sql is defined with a version tag which is used to determine when to perform a version upgrade of the database. A reference to the radio database API such as for a Falcon III radio is provided to the waveform through the base plugin class that each waveform must derive their plugin from. Once the waveform database is defined in the system the waveform may access the database using this reference to the API and Standard Query Language SQL commands. Once the default database is created for each plugin it is instantiated as dbase . This will be used to access configuration data created by a defaults.sql when the plugin was initialized. Custom user databases can be created by instantiating another DatabaseAPI class. If the filename specified is memory the database will be stored only in local memory and not in the file system.

As noted before the radio architecture includes provisions to allow a waveform to extend the current functionality of the radio by providing the plugins to the HMI Ascii and Front Panel and the System Command and Database components as shown in . The plugins and associated with the waveform are stored in a shared library object called plugin.so in one non limiting example which is loaded by the software either at power up or when the waveform is installed. When the plugin.so object is loaded each component is extracted by the process that is responsible for maintaining that plugin component. If the waveform that owns the plugin.so file is currently instantiated the plugins will have control over the radio i.e. the Front Panel will display the top level screen specific to the waveform as provided by the Front Panel plugin and the System plugin is allowed to configure the waveform so it can receive or transmit. If the waveform is not instantiated then a smaller subset of the plugin functionality is still active i.e. the waveform can be configured in program mode through the Front Panel and Ascii and the system plugin can receive programming commands from any HMI plugins.

Further details of the Ascii command shell and related operating details shown in are now explained with reference to with the arrows between functional components indicative of various calls as explained in the call legend .

As shown in an Ascii Server Process includes an Ascii Server with basic functional components of an Execute and Command operative with a Process and Response and a Process Input Line . The Process Response is operative with an Output which in turn is operative with an Ascii Status Handler . The Output and Process Input Line are operative with an Xlate function which is operative with an Ascii Waveform Interface and a Main Parse Table . The Execute Command of the Ascii Server is operative with an Ascii Plugin that includes an Ascii Factory Plugin and Ascii Command having a CORBA interface to a System Plugin. The Ascii Process is operative with an Ascii Stream Client which in turn is operative with the Process Input Line and Output as indicated.

The Ascii Command Shell creates a shell for user input parses it and executes a corresponding command. It allows waveforms to install waveform specific commands through a plugin.

The Ascii Stream Client is the client for the Ascii Server . It handles communication over ttys sockets files and the serial port. Any number of clients may be used for a single server. The Ascii Server handles calls from any registered clients and handles any output that needs to be sent back to the clients. The Ascii Server receives the raw data from the Ascii Stream Client and processes the data. This could include for example removing extra white spaces the carriage return and the line feed. The data is translated and executed within an Ascii Command and the data to be displayed is returned to the Ascii Server . This data is passed to a Process Response which takes the data it receives and determines the proper output.

The Output Functions take the data call Xlate to translate it to the proper output format and pass the output data to the Stream Clients to process and output to the screen. The Waveform Interface installs all commands from the plugins by calling the Ascii Factory Plugin for each installed waveform. Instances of the commands are stored in a table of commands and the main table structure for each command is stored in a vector in the Ascii Waveform Interface. Xlate translates data from Ascii to binary and binary to Ascii. Xlate uses the main parse table in the Ascii Waveform Interface to do the translation. Registers for all statuses are thrown from a notification service. The Status Handler takes the statuses that have been thrown and outputs the text representation to the screen. The Utilities contain a list of all the Ascii commands which allows the Execute Command function to get a reference to a command that needs to be called. An Ascii Factory Plugin is inherited by each waveform and contains an instance of every command for that waveform. The Factory Plugin adds each command to the table vector that is passed into it. Ascii Command is inherited by each command in a waveform. It contains the tables for the specific command a way to handle the requested command and a way to handle the returned response. It uses a CORBA call to the System Plugin to execute the requested command. The Ascii Server Class architecture includes a file e.g. an AsciiClientList which contains a list of all the instantiated classes that are in the Ascii Server Process and inherited from the base class AsciiClient. The AsciiClient base class handles command processing and tracking while the child classes contain the implementation for outputting.

The plugin architecture has two base classes as shown in i.e. the AscFactoryPlugin class and the AsciiCommand . Waveforms typically will contain a single AscFactoryPlugin but will have an AsciiCommand for every implemented command. The AsciiFactoryPlugin typically will contain the instantiation of every AsciiCommand typically in that waveform. Every AsciiCommand contains a pointer to the next command. The AscFactoryPlugin is the interface between the Ascii engine and the plugin while the AsciiCommand is the implementation for each Ascii Command.

The Front Panel would typically be the main user interface to the radio. It typically includes a display an alphanumeric keypad buttons and knobs that allow an operator to manage the radio and view its current state. The buttons could include a volume and squelch control. A handheld radio typically also has a Push to Talk PTT button for performing voice transmissions without a separate handset. The knobs provide a quick method for selecting a predefined shortcut as well as specifying the cipher mode PT CT . Additional functions provided by the knobs are loading keys and part of the procedure for performing a hardware zeroize.

A Front Panel Engine is described relative to and also includes in conjunction therewith a Keypad and Display Driver that institutes keypresses to be operative with various components of the Front Panel Engine .

The Front Panel Engine includes a Front Panel Platform that includes a Key Translator that could be platform specific. A Widget Factory includes a subfunction as a pop up Message Handler . The Front Panel Platform also includes a Display Context that typically is platform specific. A Front Panel Factory Plugin Manager includes various functions including an optional program Menu Producer and Event Handler . A Front Panel Factory Plugin includes a Lockout Manager and String Factory and Status Cache and operative with various screen widget objects. The Front Panel Factory Plugin Manager includes a Global Cache and Global String Factory . Not only are the keypresses operative with the Key Translator that receives platform specific information from the Key Translator but Timers and Status are operative with an Event Producer and Timer Manager . Front panel events from the Event Producer are sent to the Event Handler Optional Program Menu Producer and the Front Panel Factory Plugin . Also events are sent to a Screen Function that includes a Screen Manager that has a paint operation that receives information and data from the Display Context . Front panel events are also sent to a Screen Stack having Screens that are also operative with a Persistent Screen Repository .

The Front Panel is controlled by several software components each of which have specific tasks for updating the display and receiving keypresses The Keypad Display Driver the Front Panel Engine and the Waveform Front Panel Plugins. The Keypad Display Driver is typically responsible for monitoring for keypresses and providing a simple abstraction of the display. The Front Panel Engine is responsible for managing the screens provided by the Waveform Front Panel Plugins and distributing events keypress status timers etc. to each of the plugins components. These plugins work in conjunction with the Front Panel Engine to provide screens and control that are specific to that waveform. They are able to interoperate with the Front Panel Engine by employing a Front Panel Framework that provides a foundation for all the Front Panel components provided by that plugin.

The Front Panel Engine The Engine has four main responsibilities 1 event distribution 2 screen display 3 Waveform Front Panel Plugin management and 4 plugin isolation. The Front Panel Engine receives events from several sources including Status Events Timers and keypresses . Some of these events are distributed as is while others such as the Timers and the keypresses have to be interpreted before being passed to the Front Panel components. The Front Panel Engine maintains a list of screens that are to be displayed and allows the screens in this list to be drawn in priority order. This list typically has screens provided by the Operating Environment and the Waveform Front Panel Plugin for the active waveform. The Front Panel Engine is responsible for managing the Front Panel Plugins provided by the Operating Environment and all installed Waveforms. When a waveform is instantiated the Front Panel Engine ensures the appropriate plugin for that waveform is activated and available for use by the waveform before the instantiation operation has completed. Plugin isolation ensures that each Plugin is its own separate entity and cannot be affected by another Plugin.

The Front Panel Framework can be a set of interfaces which provides common access to the features provided by the Engine. These interfaces include required components that the Front Panel Engine needs to operate with the plugin as well as basic screen implementations that aid in producing consistent looking screen designs. It is up to the plugin to customize these interfaces to produce components that are applicable to its waveform.

A Plugin Manager can handle all aspects of a waveform s Front Panel Plugin. The Plugin Manager provides access to the plugin s screen navigator lockouts initialization destruction cache string management widgets key management screen management and provides an interface to the plugin that the Engine can use to interface with the plugin. It also allows the Engine to retrieve any menu items associated with given buttons for that waveform so that they may be loaded into the main menu hierarchy. A display context abstraction allows components of the Front Panel Engine to draw text and graphics on the LCD Display. The display context is needed so that the Screen Manager may paint the screen and individual widgets may paint a representation of themselves.

An Event Producer receives external events creates Front Panel events and distributes the events to registered Front Panel clients. A Key Translator maps incoming keypresses based on the current state of the Front Panel and provides them to the Engine for distribution. The Timer Manager controls timer events that can occur in the Front Panel Engine. It allows timers to be started stopped restarted removed and ticked. The Timer Manager also provides the capability of distributing timer events throughout the Front Panel Engine. The Widget Factory allows the Front Panel Engine to create widgets and containers for widgets screens . The Widget Factory also provides access to any enunciator widgets which allows waveform plugins to populate them with meaningful information. A Navigator Manager allows the Front Panel Engine to interface with the FpNavigator object of a waveform s Front Panel Plugin. This will allow the Engine to follow the correct screen flow provided by the plugin and to retrieve screen titles from the plugin when available .

The Front Panel Engine is responsible for extending the display e.g. an LCD and keypad to the waveforms installed in the radio giving preference to the currently instantiated waveform. In doing so the engine is able to receive and handle keypresses and send draw commands to the Keypad. Each waveform provides a Front Panel plugin component that is pulled into the engine.

The Front Panel Engine maintains the Screen Stack as well as the Persistent Repository . Additionally the Front Panel Engine handles timer and status events passing them to the appropriate screens in the stack.

Referring again to there is shown how the Front Panel Plugin component is retrieved from the waveform s plugin.so shared library with system plug and Ascii plugin and placed into the Plugin Manager that is responsible for maintaining references to the Front Panel Plugins that are retrieved from installed waveforms at powerup. The Plugins provide various components including an Event Handler and Screens that drive what is displayed on the screen. The Front Panel Plugin communicates with the waveform s System Plugin and the waveform itself through means of an IDL Interface that is exposed as part of the System Plugin.

Referring again to the engine block diagram in there is shown the Screen Manager as a class responsible for maintaining a list of current screens and the current screen in focus. Functionality is provided to activate and deactivate screens. The Front Panel Factory Plugin Manager is responsible for installing loading and maintaining all of the Front Panel plugins for the installed and active waveforms. A Front Panel Factory Plugin is a Front Panel waveform plugin object that creates screen and event handler objects. The Event Handler is a class provided by a plugin that receives events and is instantiated all the time. For example an Event Handler could be used to catch the Call button keypress event and display a waveform specific Call Screen.

The Widget Factory provided by the Front Panel Platform creates platform specific screen and widget objects that are used by the plugins to create the screens and any displayed individual text and graphic items. The Display Context provided by the Front Panel Platform provides an abstraction of the Display Driver for drawing text and graphics on a LCD display. A Key Translator provided by the Front Panel Platform receives the raw keypress values from the Keypad and Display Driver KDPROC and translates to an appropriate value. It is also operative with the Key Translator as a general function. The Timer Manager keeps track of timers that are created within the Front Panel process and provides a notification when each timer expires.

The Event Producer receives Option and Program keypresses and displays any top level Option and Program menu screens. Each plugin provides a list of items to be added to each menu screen. The Screen Stack is a list of active screens ordered by screen priority and the order in which the screen was added to a stack. A Persistent Screen Repository is the list of screens that were taken off the Screen Stack and did not want to be deleted. If a screen is activated that currently resided in this repository the screen object will be retrieved from here instead of requesting it from the plugin. By providing this repository a screen is able to maintain state after being deactivated. The Front Panel Platform is a platform specific class that provides the DisplayContext WidgetFactory and KeyTranslator that are compatible with the current hardware on which the Front Panel process is running.

As shown in every Screen contains a Screen Implementer which contains a list of Widgets for that screen. A Screen is defined by the functionality contained in the Screen Implementer which is responsible for creating Widgets using the Front Panel Widget Factory and controlling their layout on the screen as also defined by the Front Panel Plugin . The operation of the Screen is also controlled by a combined effort of the Widgets and the Screen Implementer . The Widgets have their own unique operation specific to the widget type i.e. scrolling for a ScrollingTextWidget editing for an EditTextWidget etc. . The Screen Implementer provides the additional operation that ultimately defines how the screen responds to keypresses not handled by the widgets and Status and Timer Events that are intended for that screen. The operation of the Screen is event driven meaning that all the functions within the Screen Implementer are intended to execute and exit quickly and are called when a specific event occurs in the Front Panel Process timer expires a screen is deactivated a screen is activated a key is pressed a status is thrown etc. .

A Front Panel component provides a mechanism for receiving system event notifications from a notification service and display updates from an analog hardware management device. The Front Panel registers for status types with a notification service through a predefined port whenever a screen or plugin registers with the Front Panel to receive status notifications. A Front Panel plugin component only receives status notifications for which it has previously registered. The Front Panel remembers which status events it has already registered with the notification service so registration for each status type occurs only once. The analog hardware management device provides updated values to the Front Panel through a predefined port that allows the battery receiver signal strength meter and transmitter transmit power meter to be updated. Since these updates can occur rather frequently and are generally only handled by the Front Panel a separate port can be provided as a means of updating these values instead of distributing them via the notification service.

The System Process is shown in provides a context in which commands are received queued and executed by a radio platform. The majority of system process is executed with plugins either a waveform plugin or the platform s plugin. The system also controls session and waveform selection and coordinating events such as power up and handling of statuses. Key components as illustrated include the SQL Database and System Plugins Platform having a Servant Implementation Command Machine with Queue Database Access and System Global Configuration Waveform Selector Operations System Configuration Session Manager and Waveform Selector . Function calls are shown by the solid arrows and CORBA interfaces by the dashed arrows.

The System Plugin class diagram shown in is an aggregate of system servant implementations. System plugins are of two varieties e.g. a WaveformSystemPlugin or a DeviceServiceSystemPlugin . These classes are both subclasses of the BaseSystemPlugin which defines functionality common to both and is generically accessed through a base class. The Device Service System Plugin is operative with the System Configuration API . The Base System Plugin is operative with the Database API Global Cfg API and Job Control . Waveform System Plugin is operative with Waveform Selector Plugin . Each type of plugin waveform or device service gives functionality specific to its applicable purpose.

Referring again to encapsulated within each system plugin are implementations of CORBA interfaces. These CORBA servants are registered with the naming service to be used by other interfaces. The HMI interfaces Ascii and Front Panel will retrieve the reference from the naming service and call it into a system component. The majority of functional code is resident within these servants such as calls into the database system configuration and other plugin functionality.

A system configuration component is responsible for providing an interface to a system plugin to request sessions and waveforms. These session changes provide an overall system state to the radio platform and ensure operations are consistent across the radio platform. Only devices services and the platform are allowed to request these state changes and as such are only made available to any deviceservice plugins. This component also controls the power up system state and is responsible for shortcut selection and throwing handling of system statuses such as an opmode and power up.

The Command Machine contains the Command Queue in which system jobs would be queued. This type of job queue ensures that only one job is executed on the system s context at once. Due to the nature of CORBA there will be multiple threads used by servants that require access to shared data and interfaces. The Command Queue ensures that only one thread has access to system resources at one time. The Command Machine also ensures that the system is in a proper state to accept the job and can enforce concepts such as a program mode.

Each system plugin as shown in is given access to their own SQL Database through the DatabaseApi . The plugin also provides functionality to reload the database from defaults if it does not exist or the table structure changes.

A System Global Configuration module provides a cache of parameters to be commonly used across all waveforms devices and services. This allows the platform to provide access to specific parameters without exposing the entire database.

A Waveform Selector Component is responsible for providing an interface between a waveform plugin and the waveform application. This functionality is typically available only to waveform plugins. The Waveform Selector will construct a new application instance if required and give it to the plugin and request commands to start stop configure etc. It will also deactivate old waveforms when a new one is selected. The operations in the plugin allow it to retrieve configuration parameters from the database when configuring.

An example of a database system operative as part of the HMI plugin architecture is shown in . A Database API includes a Query Handler that is operative with a Cache Subsystem that includes an SQLite memory . The Query Handler is operative with a Disk Writing Queue that is also operative through a Queue Data Notification Event with a Disk Processing Thread that includes a Disk Writer and SQLite disk . The SQLite memory is operative with Database Results that are operative with a Results List and Stream Base Type Conversion . A System plugin receives a data from the stream based type conversion that in turn is operative with the Query Handler through an SQL Query .

The DatabaseAPI provides a thread safe C interface to an SQL database backend. The interface is designed such that type conversion is done automatically and a developer does not have to use wrapper function to convert from the database internal format strings to the desired C C type. When the database is instantiated the current database structure on disk is loaded into memory if a cache is used. Subsequent reads are done from memory while writes are done to memory and disk. All set and get queries are initiated with the query function. This function will send the query string to a sister thread that performs all disk writes. The main thread will query only the memory for the result.

Results are stored in a dbResult class. This class uses overloaded C operators to perform automatic type conversion from the internally represented type to the desired user type. SQL files are automatically rolled into the target image as part of the build process.

The DatabaseAPI is configured once upon instantiation. There is typically no mechanism to reconfigure the properties once the database is running. The configurable options include the filename of the database the mode of the database file and whether caching is enabled. Upon instantiation of a databaseAPI if the cache is enabled any tables existing on the filesystem are first copied into memory. All future reads are done strictly from the database stored in memory.

All queries are queued to write to the disk when resources are available. A flushCache call can be used to ensure that all queued commands are flushed. This function will block until the process completes. All queries can be done with a query function. This function will either take an SQL query as a string or no parameters at all. In either case a dbResults class is returned. This class stores any results from the query which are extracted using a C operator and can optionally take input via the C 

Many modifications and other embodiments of the invention will come to the mind of one skilled in the art having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore it is understood that the invention is not to be limited to the specific embodiments disclosed and that modifications and embodiments are intended to be included within the scope of the appended claims.

