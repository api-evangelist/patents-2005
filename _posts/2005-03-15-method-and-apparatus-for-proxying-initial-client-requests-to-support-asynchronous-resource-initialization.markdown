---

title: Method and apparatus for proxying initial client requests to support asynchronous resource initialization
abstract: A set of programs allows a server computer that does not have an application installed to temporarily hand off a client request for the application to a peer server until the application is installed on the first server. The hand off is transparent to the client and temporary to the peer server. The server asynchronously starts the application, and when the application is ready for use, the first server stops sending requests to the peer server, and begins serving the requests. Since the first server has full session knowledge, it will be transparent to the client that the server servicing those requests temporarily changed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07685289&OS=07685289&RS=07685289
owner: International Business Machines Corporation
number: 07685289
owner_city: Armonk
owner_country: US
publication_date: 20050315
---
The disclosures made herein relate generally to computer networks and computer implemented methodologies configured for improving server response time and more particularly to transparent proxying of requests to a peer server during the period of time in which the requesting server gets a needed application running.

The World Wide Web provides opportunities for the sharing of resources on an almost unlimited scale. Many software products support the creation of grids of interconnected resources. In conjunction with the grids the software products enable businesses to access more computer capacity over the Internet on demand. The goal of developers for such software products is to provide users with a seamless flow of information and business processing.

One group of such software products is IBM s WebSphere . WebSphere encompasses tools for developing e business applications and middleware for running Web Applications. WebSphere Application Server WAS software deploys integrates executes and manages e business applications hereafter applications from a network of application servers. WAS runs on a web server a software program capable of servicing Hypertext Transfer Protocol HTTP requests. WAS is a Java 2 Platform Enterprise Edition J2EE and its core components are Enterprise Java Beans EJBs Java Server Pages JSPs Java servlets and interfaces linking databases.

WAS deploys applications from a network of application servers. Typically the network of application servers consists of peer servers where each of the servers in the network communicates with each other at the same level. These peer servers may include one or more clusters of application servers. A server cluster consists of a group of servers that are typically on different machines and have the same applications configured within them but operate as a single logical server. Application servers in a cluster are configured to act as backup servers for user session data. Memory to memory replication of data is performed using Java Message Service JMS . A server cluster may be a group of clone servers where each server is an identically configured copy of an application server that may be used for workload management purposes.

WAS deploys applications over the Internet responsive to a request sent from a user s remote client computer using the client s web browser. The request contains the user s unique internet protocol IP address. When the client s web browser sends the request to the network of servers one of the servers will run the application and make the application available to the remote client computer. The application may consist of a single resource or it may be a bundle of resources such as Java 2 Platform Enterprise Edition J2EE application with numerous servlets and Enterprise Java Beans EJBs .

WAS also manages the workload created by client requests. Load balancing is the monitoring of application servers and management of the workload on the servers. If one server exceeds its workload requests are forwarded to another server with more capacity. One method by which WAS allocates requests among the peer servers on the network is through an intelligent workload router IWR that employs rules to decide which server receives a request. IBM s Network Dispatcher component Content Based Routing CBR is one example on an IWR.

In order for the user to access the application from the remote client computer the user s browser makes a protocol request to a WAS application server and the server parses the protocol request to determine whether it has the application requested by the browser. When the server has the necessary application installed there is no problem. However a problem arises when a request is sent to an application server that does not have the necessary application running. The server must first install the application and may have to fetch the application before it can be installed. Methods to start up applications asynchronously and remotely are known. However the period of time that it takes to deploy the application causes an undesirable delay in the response time of the application server. Therefore it is desirable to eliminate delay in commencement of the user session.

A solution to this problem is for the server receiving a request but not having the necessary application running to act as a proxy and to send the request to a peer server that has the application installed. Knowledge of which server has the necessary application installed may be obtained from a registry showing the applications that are installed on each of the servers. A registry is a repository that contains access and configuration information for users systems and software and the use of such repositories is known. Such a registry may be provided by a central registry service which maintains peer servers and the resources available on those servers. In addition proxying among peer servers is also known.

In addition to finding a peer server with the application running the client request could be proxied to a peer server only for as long as necessary for the requesting server to install the required application. Once the requesting server has the necessary application installed it could then process requests for the client throughout the remainder of the session. The temporary handing off to the peer server would be transparent to the client and to the IWR. The ability to proxy requests off and to alter the session information to have the client send requests back to the proxy is known. In addition the ability to replicate connection session information across multiple servers is known.

When WAS makes an application available to the user s browser on the remote client computer an HTTP session is established. Connection information is created during the HTTP session which helps the server to maintain information about the remote client computer s requests. In WAS a session is a series of requests to a servlet originating from the same user at the same browser. The servlets are Java programs that run on a Web server and extend the server s functionality by generating dynamic content in response to requests. A WAS Web server plug in supports the Web server in communicating requests for the servlets to the application server. In J2EE a session is an object used by a servlet to track a user s interaction with a Web application across multiple HTTP requests. An important component of the connection information is establishment of server affinity so that all requests during the session will go to the server that is providing the application from the user s initial access until the user exits the application.

Server affinity is important because many applications encountered on the Internet today including shopping carts and home banking applications require that the current status of the application or state be maintained during the session. In other words each request for a new web page in an application may require knowledge of the previous pages. Programmers have made provisions for maintaining state during a session in various ways including application programming interfaces APIs and cookies. The passing of the session information and the shifting of subsequent requests from the user to the computer that received the session information is known as affinity. Thus when the request is sent to a server the affinity information in the session information will ensure that the client will connect to the same server for all transactions during the session. However once a server is assigned to the request for those applications requiring that state be maintained server affinity must be maintained during the time that the user at the remote client computer accesses the requested application until the user exits the application.

Server affinity is maintained by making a unique server identifier a component of the session information. Some options available to maintain application state based on server affinity by making a unique server identifier part of session information are 1 stickyness to source IP address 2 SSL session identifiers cookies and URL rewriting. The suitability of each will be discussed below.

Stickyness to a source IP address is enabled by configuring the clustered port to be sticky. In doing so all subsequent connections from the same source IP address are dispatched to the same server until the session ends or until a configurable timeout period expires. This affinity strategy has some disadvantages. Some Internet Service Providers ISPs use proxies which collapse many client connections into a small number of source IP addresses. A large number of users who are not part of the session will be connected to the same server. Other proxies use a pool of user IP addresses chosen at random even for connections from the same user invalidating the affinity. These disadvantages weigh against using stickiness for the proposed proxy solution.

If clients are using Secure Sockets Layer SSL connections to the Web Server then an SSL session identifier may be used. The SSL session identifier is generated from the SSL session information and is defined by the connection between the browser and Web server. Connecting to another Web server will reset the SSL connection and a new SSL session identifier will be generated. If the web server crashes the user will lose the session. The session will continue to exist in the application server but the user will not have the correct SSL session identifier. If the application server crashes then as long as persistent sessions are in use the session will not be lost to the user. The disadvantages of the SSL session identifier weigh against its use for the proposed proxy solution.

Cookies have the advantage that the browser can be connected to any web server and there will be no effect on the session. A session identifier in the cookie is used by a server to locate the corresponding session. Cookie session identifiers will survive a web server crash and provided persistent sessions are enabled will also survive unavailability of the application server. The session lifetime is governed by the cookie lifetime. Once the session identifier in the cookie is set a browser will send the cookie for all subsequent requests until the cookie expires. Cookies are the preferred way to communicate session information and meet the requirements of the proposed proxy solution.

In WebSphere URL rewriting or URL encoding does not require users to enable cookies in their browsers and yet still allows management of sessions. The process of setting up URL rewriting is not transparent to the Web application. It requires a developer to include specific commands to append the session information to the end of any HTTP link that will be used from the Web browser. Rewriting the URLs can only be done on dynamic HTML that is generated within WebSphere . Session information will be lost if static HTML links are accessed restricting the flow of site pages to dynamic pages only. From the first page the user receives a session identifier and the Web site must continue using dynamic pages until the completion of the session. The only situation in which URL encoding excels over cookies is when users have not enabled cookies in their browsers and in such a situation URL encoding would be a suitable option for the proposed proxy solution.

In WAS session affinity is maintained by appending a unique server identifier to the session identifier. When an HTTP session is created its session identifier is passed back to the browser as part of a cookie or URL encoding. When the browser makes further requests the cookie or URL encoding will be sent back to the Web server. The Web server plug in examines the HTTP session identifier in the cookie or URL encoding and extracts the unique server identifier of the server handling the session and forwards the request. The affinity information is stored in the session information object ties the user to that particular server and gives subsequent requests from that user to the proxy server.

In WAS a client cookie has four parts a cache identifier a session identifier a separator and a server identifier. For example a client cookie may be written as 

The first four characters are used to identify the cache. When using cookies or URL rewriting the characters before the are used for the session identifier. The is the separator. The last section after the separator is used to point to the server which holds the session the server identifier . Session information may comprise the session identifier the last accessed time the creation time and the session tracking mechanism.

However when the request is sent to the peer server the session information is also sent to the peer server and when the request is returned to the proxy the session information will contain affinity information that will cause follow on requests to continue to go to the peer server rather than to the requesting server. Therefore the peer server will continue to get requests from the client web browser in addition to all of the requests that it would normally receive from the intelligent workload router. Such a routing will interfere in workload management. For example the proxy server will receive the requests allocated to it by the IWR and in addition will receive the requests sent to it because the requesting server did not have the application running. Because the handover is a permanent handover for that session the requesting server interferes in the workload management of the IWR.

Therefore a need arises for a way to balance the resources by handing off a request to a peer server when necessary but getting the session back to the originating server when it is ready to handle the request so that subsequent requests from the user will go to the originating server as soon as it is able as though no handing off had taken place. With such a capability the originating server would only pass off a request to a peer server until it had the application loaded and was able to process further requests and at that time requests would no longer be sent to the proxy server. In such a situation a need exists for a way to make a temporary and transitory handoff to a peer server without losing affinity to the requesting server.

The invention that meets the needs described above is a set of programs that allows a server computer that does not have an application installed to temporarily hand off a client request for the application to a peer server until the application is installed on the first server. The hand off is transparent to the client and temporary to the peer server. The server asynchronously starts the application and will begin to process requests within a session when the application is running.

The set of programs comprise a proxy request generator program and a proxy request response program stored in each of a plurality of peer servers. The proxy request generator program interacts with a registry to determine which peer server to hand off the request. The proxy request response program responds to the request and passes back the response and a session identifier to the first server. The proxy request generator program further modifies the affinity portions of the session information so that server affinity for the client request remains with the server and client request will continue to be routed to the first server by the intelligent workload routers. The first server asynchronously sets up session replication for that specific session between the peer server who serviced the request and the first server.

The first server continues to receive subsequent requests for the application and to route them to the peer server until the first server has the application prepared for use. When the application is ready for use the first server stops sending requests to the second server and begins serving the requests. Since the first server has full session knowledge it will be transparent to the client that the server servicing those requests temporarily changed. The session identifier is changed slightly so that when the session information is replicated for high availability two servers will not own the same session identifier.

Sessions are stored in a cache in one of two ways. First sessions are stored in a central cache. Second sessions are stored where each node keeps an in memory cache and synchronizes with each other.

The principles of the present invention are applicable to a variety of computer hardware and software configurations. The term computer hardware or hardware as used herein refers to any machine or apparatus that is capable of accepting performing logic operations on storing or displaying data and includes without limitation processors and memory the term computer software or software refers to any set of instructions operable to cause computer hardware to perform an operation. A computer as that term is used herein includes without limitation any useful combination of hardware and software and a computer program or program includes without limitation any software operable to cause computer hardware to accept perform logic operations on store or display data. A computer program may and often is comprised of a plurality of smaller programming units including without limitation subroutines modules functions methods and procedures. Thus the functions of the present invention may be distributed among a plurality of computers and computer programs. The invention is described best though as a set of computer programs that configure and enable one or more general purpose computers to implement the novel aspects of the invention. For illustrative purposes the inventive computer programs will be referred to below as the Proxy Request Generator PRG and the Proxy Request Processor PRP .

Additionally the Proxy Request Generator and the Proxy Request Processor programs are described below with reference to an exemplary network of hardware devices as depicted in and . A network comprises any number of hardware devices coupled to and in communication with each other through a communications medium such as the Internet. A communications medium includes without limitation any physical optical electromagnetic or other medium through which hardware or software can transmit data. For descriptive purposes exemplary network has only a limited number of nodes including workstation computer workstation computer server computer connected by the Internet to a network of server computer s and and persistent storage through server computer . Server computer may contain software to act as an intelligent workload router for the server computer s connected by network . Network connection comprises all hardware software and communications media necessary to enable communication between network nodes and application server . Network connection comprises all hardware software and communications media necessary to enable communication between network nodes .

Alternatively network depicts an exemplary network which in the same manner as exemplary network has only a limited number of nodes. In network workstation workstation and server are connected to application servers and persistent storage by the Internet. Network connection comprises all hardware software and communications media necessary to enable communication between network nodes . Unless otherwise indicated in context below all network nodes use publicly available protocols or messaging services to communicate with each other through network connection .

Proxy Request Generator PRG program and Proxy Request Processor PRP are typically stored in a memory represented schematically as memory in . The term memory as used herein includes without limitation any volatile or persistent medium such as an electrical circuit magnetic disk or optical disk in which a computer can store data or software for any duration. A single memory may encompass and be distributed across a plurality of media. Thus is included merely as a descriptive expedient and does not necessarily reflect any particular physical embodiment of memory . As depicted in though memory may include additional data and programs. Of particular import to TMP memory may include cache and registry . Alternatively cache and registry may be centrally located in persistent storage such as persistent storage .

Next PRG accesses the central registry to find a peer server that has the application installed . PRG then determines whether the peer server or any peer server with the application installed is available . If not PRG waits for the application to be installed pursuant to step and when the application is installed proceeds to step . If the identified peer server is available PRG proxys the request to the identified peer server . PRG receives the response and session identifier and modifies the session identifier . See for discussion of the modification of the session identifier. PRG replicates the session information . Alternatively the session information may be replicated by the peer server that sent the response and session identifier. In either case replication may be configured as needed for a desired level of availability. PRG sends the response and saves the session information with the modified session identifier . PRG determines whether there is another request . If so PRG goes to step . If not PRG stops .

Sessions are stored in a cache in one of two ways. First sessions are stored in a central cache. Second sessions are stored where each node keeps an in memory cache and synchronizes with each other.

In the preceding detailed description reference has been made to the accompanying drawings that form a part hereof and in which are shown by way of illustration specific embodiments in which the invention may be practiced. These embodiments and certain variants thereof have been described in sufficient detail to enable those skilled in the art to practice the invention. It is to be understood that other suitable embodiments may be utilized and that logical mechanical and electrical changes may be made without departing from the spirit or scope of the invention. For example functional blocks shown in the figures could be further combined or divided in any manner without departing from the spirit or scope of the invention. To avoid unnecessary detail the description omits certain information known to those skilled in the art. The preceding detailed description is therefore not intended to be limited to the specific forms set forth herein but on the contrary it is intended to cover such alternatives modifications and equivalents as can be reasonably included within the spirit and scope of the appended claims.

