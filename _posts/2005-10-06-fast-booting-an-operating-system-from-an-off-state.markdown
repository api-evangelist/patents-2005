---

title: Fast booting an operating system from an off state
abstract: Described is a fast boot mechanism that generally operates by persisting static data and/or code for a system component, and then providing the system component with access to the static data and/or code during a subsequent device boot. For example, the static data and/or code of one or more components may be restored from non-volatile memory to volatile memory, whereby subsequent reboots need not have the components re-compute their persisted static data, making subsequent reboots faster. A fast boot infrastructure may include an interface set, and provides first mechanism that persists static data and/or code for a system component, and a second mechanism that provides the system component with access to the static data and/or code. The fast boot infrastructure may also provide the component with a way to invalidate static data and/or code, along with a background mechanism that collects static data and/or code from the system component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07409537&OS=07409537&RS=07409537
owner: Microsoft Corporation
number: 07409537
owner_city: Redmond
owner_country: US
publication_date: 20051006
---
As mobile devices become more popular the demand for longer battery life and instant accessibility increases. With the complexity of a full operating system such as a Microsoft Windows based operating system it is a significant challenge to meet that demand. For example a typical mobile personal computer boots from an off state e.g. corresponding to an S5 state according to the ACPI standard in about twenty to forty seconds which is clearly not considered to be an instantly accessible device.

Various mechanisms have been attempted to get a computer system back into operation more quickly. For example an ACPI S3 Standby sleep state has been defined in which system state is essentially suspended in the system memory whereby reasonable instant on performance is achieved. However the S3 state consumes battery power which is a concern to many users and device manufacturers and for at least that reason makes using the S3 state a poor solution for many users. There is also a concern among some users and manufacturers that the S3 state may degrade over time which is likely due to the various drivers and services which are obtained from various development sources and that may be part of the critical resume code path.

An S4 Hibernate sleep state is also defined which in general transfers system memory to a hard disk file to allow a system to wake somewhat more quickly while also preserving data in the case of a power outage. The S4 sleeping state has the advantage of not consuming any power but it shares the same stability and potential data loss concerns voiced for the S3 state. Further an S4 resume still takes approximately fifteen seconds on the average which also falls short of being considered Instant On solution.

Even with desktop computer systems that are not battery powered a quick power on experience is becoming a much sought after requirement. For example as many computer systems are evolving towards providing entertainment particularly home computer systems there is an increased need to have computing devices act more like consumer electronics devices in order to sell computing products in the competitive computer and consumer electronics marketplace. For example unlike the aforementioned time of twenty to forth seconds for a cold boot sequence typical consumer electronic devices can be turned on and become functional within a few seconds.

In general a faster boot from a fully off state is desirable for computer systems. Such a faster boot should be independent of and complimentary to other e.g. S3 and S4 types of resume operations because those sleep states preserve system states that are important in some user scenarios.

Briefly various aspects of the present invention are directed towards a fast boot mechanism that generally operates by persisting static data for a system component and then providing the system component with access to the static data during a subsequent device boot. For example after setup or installation a fastboot image comprising the static data and possibly code of one or more components may be restored from non volatile memory to volatile memory e.g. RAM for example putting the boot code path into non volatile memory has the advantage of bypassing the relatively slow spin up time of rotating media e.g. a typical hard disk spin up time can be as much as about five seconds. Upon subsequent reboots each system component that persisted static data is provided with access to its corresponding static data whereby much of the data need not be re enumerated during each boot making subsequent reboots faster.

A fast boot infrastructure is exemplified including a first mechanism that persists static data and or code for a system component at a first time and a second mechanism that provides the system component with access to the static data at a second time that is after the first time and during a boot of the system device. The fast boot infrastructure may include an interface set by which the system component client may persist the static data and or code obtain access to the static data and invalidate the static data e.g. upon a change . The fast boot infrastructure may also employ background mechanism that collects the static data and or code from the system component such as following system boot.

Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices tablet devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures and so forth which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in local and or remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

The computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media and removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media described above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers herein to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a tablet or electronic digitizer a microphone a keyboard and pointing device commonly referred to as mouse trackball or touch pad. Other input devices not shown in may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . The monitor may also be integrated with a touch screen panel or the like. Note that the monitor and or touch screen panel can be physically coupled to a housing in which the computing device is incorporated such as in a tablet type personal computer. In addition computers such as the computing device may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface or the like.

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Various aspects of the technology described herein are directed towards technology that quickly boots a computing device from an off state which includes quickly rebooting the computing device. In one example implementation part of the technology may read data from a solid state non volatile RAM storage device which is faster than retrieving data from a disk particularly when the disk needs to spin up from an off state. However as will be understood the fast boot technology described herein will also ordinarily provide a much quicker booting experience relative to current boot times from a hard disk. As such any of the examples mentioned herein are non limiting and the present invention may be used various ways that provide benefits and advantages in computing in general.

In general on every boot to a full operating system a computing machine performs much of the same initialization over and over again. Some of these repeated initializations can be relatively time consuming. A fast boot mechanism described herein attempts to reduce the number of these the time consuming initializations by having at least part of the initializations done only once e.g. during initial setup of the computing machine and then persisting the resulting initialized states in a non volatile form. By quickly restoring these persisted states in subsequent boots rather than re computing them each time a large portion of the boot time is eliminated.

It should be noted that components used during boot have both dynamic data and static data wherein as used herein static refers to data that is not usually changed between boots although it may be occasionally changed. As can be readily appreciated capturing and restoring state data that is dynamic would result in a corrupted system. For example the file system contains metadata such as cluster bitmaps as the system is booted and used new files are created and old files are deleted whereby a previously captured cluster bitmap is incorrect as to the current state.

In general the fast boot technology described herein allows components that operate at boot time to preserve and restore their static data while letting them enumerate their dynamic data as before. Because the individual components know what their static and dynamic states are the components can identify their static states and perform dynamic initialization enumeration on dynamic state data while simply restoring their static state data during a fast boot procedure. In this manner much of the repetitive initialization that occurs during a slow boot sequence is eliminated.

Some components may be legacy components that are not written to identify and or preserve static data or may choose to not participate in a given fast boot scheme for other reasons. In order to allow mixing of participating and non participating components an API mechanism is provided such that only those components that are aware of the fast boot will participate by calling the API while non participating legacy components and the like will ignore the provided functionality.

Further because components may have inter dependencies initialization takes place in multiple passes such multi phase initialization is already structured in Windows based operating systems. For example in an NT kernel various kernel components e.g. object security process PnP executive kernel memory management registry and so forth have initialization entry points that are called in different initialization phases. In each initialization phase a component decides what to initialize according to dependencies on the initialization of other components in the previous phases.

To participate in fast boot in each of the initialization phases a component can determine which of its initializations take time and or whether the initialization work can be done once and the results saved. This information can be provided to a fast boot infrastructure at various times such as when a new component is installed or when a computer operating system and its components are setup for the first time. To this end a device installer or the like enumerates kernel components for fast boot state information and calls memory manager file system components to save the state information in non volatile form.

For example as generally represented in each kernel component e.g. may be called by a setup component associated with or including a device installer of the fast boot infrastructure at the end of the operating system setup. In one implementation the call provides the component with data identifying an entry point or points e.g. an application program interface API to an API library . Via the entry point the component may specify the memory locations that contain code and or static states that can be saved whereby these memory locations can be restored in subsequent fast boot sessions. Alternatively the component can directly provide the data e.g. in a data structure understood by the component in response to such a call. The memory locations and or code or the data itself is represented in by the static data blocks labeled as transferred and as persisted . The static code and or data comprising a fast boot image are maintained in some non volatile storage such as NVRAM or alternatively may be maintained in whole or part in another type of storage medium such as a hard disk.

Once this data has been persisted in subsequent boots when each kernel component is called to initialize e.g. in different phases these memory locations or the data itself is available for the component to use. As a result at least certain portions of each participating component s time consuming initialization can be skipped. Note that for non participating components conventional initialization cannot be skipped whereby that component will consume as much time as it does in a regular long boot.

In one implementation new interfaces for the kernel components and some new supporting infrastructure in various components are provided. One kernel component interface is provided to allow each kernel component to be called so that it can return a list of memory blocks that contain code and or data or the code data itself . These memory blocks will be saved in the non volatile storage which can comprise a fast boot state image file on a hard disk in contemporary computing devices or NVRAM storage or the like in future computing devices.

To build the fast boot state image this interface for persisting the static data may be called by the device installer such as initiated by the operating system setup program. The interface may also be called whenever a new component is installed. It is the responsibility of each participating component to determine what data needs to be saved in order to benefit the boot time of subsequent fast boots. For example during development each participating component may perform code profiling on its initialization code path to identify boot bottlenecks.

Another interface is provided to allow the component to receive the list of memory blocks that the component has asked to be persisted e.g. on a per phase basis. Note for example that this interface may correspond to a modified version of the existing phase initialization interface already present in Windows based operating systems. The ability to retrieve static state data allows the component to skip some portion of its time consuming initializations. A supporting interface is also provided whereby a component can find out if fast boot is in progress. This interface is provided so that the component can know when to use or not use the cached information from the saved fast boot state information. Further kernel components such as a memory manager component and possibly other components may export new utility APIs that facilitate the identification and or the saving of the fast boot state memory blocks. For example existing memory allocation APIs may be extended to allow tagging memory allocations that contain fast boot state information.

Each component e.g. is called in turn such as once per phase and those that participate can thus retrieve access to their static data and enumerate their dynamic data. This is generally represented in via the data for phase of the component being accessed in RAM by the component upon retrieval from the non volatile storage . Fast boot infrastructure code may process the retrieval upon a call to the API library . Those e.g. legacy components that do not participate in the fast boot scheme will not call back as may components that do not have data cached for a particular phase although such fast boot aware components can alternatively return a no data needed for this phase response or the like.

Turning to another example interface in the API library is provided by which a component e.g. may notify the fast boot infrastructure code to invalidate some or all of its saved state image because its typically static state has changed. For example a user may change a component s normally static data via control panel and or registry interaction. The component is responsible for detecting changes to its data. In one implementation the invalidated data will not be returned whereby the component will need to enumerate the static data as well as the dynamic data on the next boot as if in a slow boot operation and cache valid data again.

Alternatively as represented in by new static state data being transferred and persisted state data the invalidation of cached fast boot data may initiate a state recapture operation such as via a silent background thread e.g. which for example may operate similarly to the state capture performed by the operating system setup process as described above. In any alternative when a change to usually static data occurs at least the changed portion of the previously cached state data will no longer be used.

Such a background operation generally represented in need not only be run when a component detects a change but instead may be run at other times. For example part of the current boot time is because of delaying to look for devices e.g. IDE hard drives that may have been added by the user each such device a computer with two IDE channels may have from one to four installed is given about one second to respond when queried. However internal drives are not often added or removed and thus instead of giving each a chance during boot to respond any change can be detected by a subsequent background operation .

Further it is possible that a component will not be written properly and may not correctly detect a change to its static data. A background thread process that occasionally requests e.g. on a random or round robin basis that each component re enumerates its static data may be used to eliminate data corruption due to a missed change. Further any or all of the components may be occasionally subject to a full slow boot enumeration instead of a fast boot and a user or other mechanism such as a utility may request a slow boot if static data corruption is suspected e.g. from a component s failure to invalidate changed data.

As described above the fast boot state information may be stored in some form of solid state non volatile storage such as NVRAM. For such devices a new standardized BIOS interface may be established to specify how the BIOS will retrieve and restore any needed fast boot state information from the NVRAM to the main memory e.g. before the operating system takes control.

Step represents the hard disk boot which begins by loading and running the loader process e.g. NTLDR. The loader checks for a valid hibernation file at step and if present resumes from hibernation ACPI S sleep state . If not present the loader continues to step where it checks for the presence of a persisted fastboot image.

If not found at step the system will perform a slow normal long boot. Note that it is still possible to fast boot next time such as by obtaining fast boot information from participating components in a background operation as described above. For example this may occur if the fast boot image has been deleted for some reason.

If instead at step the boot loader process looks for and finds the fast boot image it restores the fast boot state information e.g. using a BIOS call to load the image to memory.

Step represents decompressing or otherwise transferring the image to its final location in RAM . Note that for future machines that have NVRAM as at least some of their persistent storage the BIOS operates at step and to perform the loading without requiring steps . At step the fastboot code e.g. a dispatcher then calls each system component to initialize it as generally described above with reference to .

In theory with a fast boot state image stored in NVRAM and most or all kernel components participating the fast boot time from an off state may approach S3 resume time typically time to restore the image from the NVRAM plus S3 resume time plus additional dynamic state initialization . With existing technology this may be on the order of five seconds assuming 64 MB of NVRAM directly on the PCI bus which takes under one second to retrieve the entire content to RAM .

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

