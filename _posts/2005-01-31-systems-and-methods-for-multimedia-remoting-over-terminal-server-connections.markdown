---

title: Systems and methods for multimedia remoting over terminal server connections
abstract: Techniques relating to managing multimedia transmissions in terminal services scenarios are described. In one instance, a method sends a user-interface component from a server to a remote client. The method further streams a media component for presentation on the remote client in combination with the user-interface component and wherein the media presentation is tracked but not displayed by the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07590750&OS=07590750&RS=07590750
owner: Microsoft Corporation
number: 07590750
owner_city: Redmond
owner_country: US
publication_date: 20050131
---
This application claims priority to U.S. Provisional Application Ser. No. 60 608 786 filed Sep. 10 2004 entitled System and Method For Multimedia Remoting Over Terminal Services Connections to Abdo et al. the disclosure of which is incorporated by reference herein.

In general the present invention relates to computer software and communication networks and in particular to a system and method for managing multimedia transmissions to terminal services connections.

Terminal Services provides for a desktop remoting experience where a client such as a thin client or a rich client can connect remotely over a network to another computer which functions as a server computer to achieve a remote desktop experience. In this scenario the applications run on the server remoting just their output i.e. graphics or user interface to the client over the network.

Previously if the user tried to play media such as videos or music over a terminal server connection they experienced a degraded user experience. For instance video was transferred over from the server to the client very inefficiently as a sequence of bitmaps which do not compress very well. This resulted in huge bandwidth consumption and very slow playback e.g. a 24 FPS frames per second video may play back as a 2 FPS video over a relatively fast network connection such as digital subscriber line DSL if played in the existing terminal services scenario. Another factor which contributed to the degraded user experience is that no provisions are made for synchronizing the audio and the video stream at the client device resulting in visible problems such as loss of lip sync in videos involving talking . The graphics are traditionally remoted over a remote desktop protocol RDP . Some existing techniques utilized a minimal audio remoting solution in RDP but did not produce a desired user experience. For example prior solutions had a set configuration with which streaming had to conform thereby affecting various performance parameters and system applications.

The methods and systems described below relate to managing multimedia transmissions in terminal services scenarios. In one instance a method sends a user interface component from a server to a remote client. The method further streams a media component for presentation on the remote client in combination with the user interface component. The media presentation is tracked but not displayed by the server.

The methods and systems described below relate to managing multimedia transmissions in terminal services scenarios.

One terminal services scenario involves a first computing device networked to a second computing device such that the first computing device functions as a server and the second computer functions as a client. A user on the client is able to see a representation of a desktop hereinafter remote desktop of the server on the client via a terminal services session. The terminal services session allows a user at the client to see and interact with the remote desktop as though the user was sitting in front of the server and viewing the server desktop. User commands at the remote desktop are relayed to the server where the commands can cause various actions to be taken at the server.

For instance and by way of example consider . illustrates an operating environment which includes server coupled to a client via a network . A server desktop can be displayed on server . Similarly a client desktop can be displayed on client . A terminal services session can allow a remote desktop representing the server desktop to be generated on the client s desktop .

Assume that a user at client device wants to see a media presentation and clicks on a media player icon on the remote desktop. The terminal services session then relays the user s command to the server. As illustrated in responsive to the user command the media player application is opened and media player window corresponding to the media player icon is opened on the server desktop . The updated server desktop is transmitted such as in a bit map format to the client which then updates remote desktop .

A user may issue a media presentation command such as by clicking on a play button on remote desktop . The presentation command is sent back to server . Upon detecting the presentation command the server may locate media associated with the presentation command. Rather than processing the media to create an image on the server s desktop the server transmits the media to the client device in an unprocessed or only partially processed form.

As can be appreciated from the client processes the media and generates a media presentation on the remote desktop . In this instance the media presentation corresponds to a media presentation window or video render window which is situated within the media player window. The server meanwhile tracks the media presentation but does not generate the associated images on the server desktop. In some instances the server may be thought of as creating a placeholder which corresponds to the media presentation window on the client and which can be tracked relative to the remainder of the remote desktop. Tracking provides a notification system for actions and or events which affect the media presentation .

Geometry tracking is a feature of terminal services that provides a notification system for window geometry changes. Whenever a window s geometry changes events containing the new geometry will be generated and sent to notification sinks at the source. In this instance the client acts as the source. Window geometry can change when a window is moved minimized maximized or clipped by another window.

Geometry tracking is used in scenarios where an application or framework is made aware of a terminal services session and is distributed across the client and server. One such scenario can occur when an application decides to render media on the client instead of transmitting a pre rendered bitmaps from the server. In order to do this the application creates a window on both the server and client ends. The server window acts as a placeholder and is able to accept all input and the actual media would be rendered and painted by the application on the client end. The client window is painted right over the server window for the distribution to be transparent to the user. Since all input actually acts upon the server window geometry changes will be reflected at the server. The application tracks these changes to the server window and updates the client window accordingly for both windows to be geometrically synchronized.

The above implementation generates a remote desktop by bifurcating data delivery relating to the remote desktop. Relatively low data intensive components of the server desktop are processed on the server and then transmitted to the client. Relatively highly data intensive components are transmitted to the client in an unprocessed or less processed form. The processing is then completed by the client and combined with the low data intensive components to create the remote desktop. Events which affect the media presentation are tracked at the server so that a relative relationship of the media presentation to other portions of the remote desktop can be maintained. In this example media presentation is a relatively dynamic relatively highly data intensive component while the remainder of the remote desktop is a relatively static relatively low data intensive component. Streaming the media component to the client in a compressed and unprocessed form creates an enhanced user experience and or saves system resources to name but a few potential advantages.

The above implementations described in relation to are but examples of potential implementations. Other exemplary implementations are described below. Further for purposes of explanation the server desktop is illustrated as being displayed as a visual image in . In many implementations the server desktop may not actually be displayed e.g. the implementations would work satisfactorily even if the server altogether lacked a display means.

The concepts described above and below can improve a user experience involving a remote desktop experience involving media playback and or other similar high data consumption actions by allowing the media infrastructure on the system e.g. such as a Media Foundation API set or other media platform to detect that the media infrastructure is running in a terminal services session and to efficiently stream the compressed media to the client before it is decompressed at the server. This results in the following advantages among others. First the bandwidth savings are dramatic a 300 Kbps media stream consumes about 300 Kbps to stream as it is sent down before decompressing. Previously the resulting decompressed sequence of bitmaps may have taken several megabits to stream. Second audio video sync is maintained as timing information that allows the media playback components at the client to preserve synchronization remain in the streams. This allows for excellent synchronization of audio and video. Third this technique works for both AV audio video streams or streams that consist of just audio or just video.

Several techniques are described in more detail below. For instance various implementations allow transparent efficient media streaming in terminal services without changing the media application. The applications do not need to be aware of the terminal services session or associated processes. Instead the applications run as they would if there was no remote desktop. Further general applications such as media players can gain access to the uncompressed stream down in the media playback infrastructure. In contrast to prior scenarios various techniques described below allow for transparent media streaming with any application running in a terminal server session as long as the application uses appropriate Media API s e.g. media foundation or other media platforms .

Various implementations described below further allow geometry synchronization. For instance these implementations allow seamless integration of a media stream playing back at the client with the rest of the RDP display surface. For instance a media stream s target window can be moved around clipped or have a size of the target window changed on the server and still result in a seamless integration. Past solutions have been more limited in scope e.g. only allowing the media window to take on one or two valid positions. In some implementations of this solution any transforms of the media window are allowed.

The implementations described above and below are described in the context of a computing environment as commonly encountered at the present point in time. Various examples can be implemented by computer executable instructions or code means such as program modules that are executed by a computer such as a personal computer or PC. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types.

Various examples may be implemented in computer system configurations other than a PC. For example various embodiments may be realized in hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers cell phones and the like. Further as technology continues to evolve various implementations may be realized on yet to be identified classes of devices. For example as the cost of a unit of processing power continues to drop and wireless technologies expand computing devices resembling today s cell phones may perform the functionalities of today s PC video camera cell phone and more in a single mobile device. This single device may in one scenario act as a server and in another scenario act as a client. This is but one of many existing and developing examples for the described implementations.

Various examples may be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices. Further the terms server and client as used herein do not connotate any relative capabilities of the two devices. The client may have more less or equal processing capabilities than the server. Rather in this document the names server and client describe the relative relationship of the two components. For example a computing experience of a first or server device is remoted to a second or client device. Further for ease of explanation the examples provided in this document relate to a single server and a single client. However this is but one potential configuration. For instance other implementations may have one server and multiple clients. Further in some implementations a first computer may act as a server for a second computer which then acts as a server for a third computer.

Although the various implementations may be incorporated into many types of operating environments as suggested above a description of but one exemplary environment appears in in the context of an exemplary general purpose computing device and which is described in more detail later in this document under the heading Exemplary Operating Environment .

User interface component includes graphics and images that typically compose a user interface. User interface component includes icons host audio background images and applications such as word processing applications spreadsheet applications database applications media applications and so forth. Virtually any components that are not media components are part of user interface component . When compared to the media component the user interface component is relatively static and relatively low data intensive.

Media component includes media rich or bandwidth intensive elements that compose a media presentation or media event. The media component is relatively dynamic and relatively highly data intensive when compared to the user interface component. The following is a non exhaustive list of exemplary media components a streaming media presentation including a video and or audio presentation a television program including a cable television CATV satellite pay per view or broadcast program a digitally compressed media experience a radio program a recorded media event sourced by a VCR DVD player CD player Personal Video Recorder and the like a real time media event and a camera feed.

The data for the remote desktop is sent from server to client over network . The remote desktop data is bifurcated at the server with data relating to user interface component transmitted over user interface channel and data relating to media components transmitted over media channel .

User interface channel communicates user interface component to client . Terminal Server and Terminal Client Services offered by Microsoft Corporation of Redmond Wash. provide an exemplary user interface channel . Any remotable protocol can be used to transmit data through user interface channel . Exemplary protocols and data formats include remote desktop protocols RDP the T 120 series protocol or HTML hypertext markup language and its many variations among others.

Media channel is separate from user interface channel . Media channel is used to transmit bandwidth intensive experiences such as video and others listed above. Media channel provides a communications conduit for media component to flow separately from user interface component . Thus the media component is sent out of band with respect to the user interface component but synchronized. An exemplary protocol to transmit data through media component includes but is not limited to Transmission Control Protocol TCP and a virtual channel over an RDP connection.

In each of the scenarios mentioned above user interface component is combined with media component to generate remote desktop at the client . A user at client can remotely operate server by interacting with remote desktop . For instance the user can move his her mouse cursor over an application on the remote desktop and open an application by clicking on a corresponding icon. Similarly the user can issue commands to an application through the remote desktop. For instance in relation to a media application the user may utilize mouse clicks to play stop fast forward and rewind. Further the user can minimize an application window move the window or open a second application over the first application. Such changes are tracked by the geometry tracking feature described above and below.

For purposes of explanation the examples described above include an easily discernable user interface component and an easily discernable media component. Such however need not be the case. For instance in one example the media component may occupy the entire client display such that the user does not perceive the user interface component. Alternatively or additionally the user interface component may be visible to the user on the client display only intermittently. For instance the media component may occupy the entire client display until such time as the user enters a command such as pause . The word pause and or an associated symbol may then appear in combination with the media component so that the word pause appears superimposed over the media component to the user. The skilled artisan should recognize these examples as illustrations of many possible configurations.

A media platform operates on server and similarly a version of media platform operates upon client . The media platform exists as part of an operating system of an individual device such as server and or client to allow playback of media such that applications such as media player that interact with the operating system may control playback of media without knowing the particular details of the media formats. The media platform running on the server may be identical to the media platform running on the client. In other instances the media platform on the server may be a different product and or version than the media platform operating on the client.

In this instance media platform running on server can detect that the media platform is running in a terminal server session via a destination component or destination . The destination is an object that defines where a presentation is to be presented e.g. a window disk file and the like and what happens to the presentation. Further the source s media platform determines that the source is connected to a client that has the capabilities to render media locally. In this instance a distribution manager component or distribution manager determines that the source s media platform is connected to client that has the capabilities to render media locally. Distribution manager further establishes terminal services policies to enable remoting media to the client . Distribution manager establishes a virtual channel connection with a multimedia client plugin or multimedia component . The virtual channel connection allows for the exchange of control information relating to the terminal services session between the source and the client .

Communications over the virtual channel connection between the distribution manager and the multimedia component allow supported media formats to be negotiated between the source and the client. Further utilizing the virtual channel connection allows the distribution manager and the multimedia component to establish a distributed topology. Examples of such techniques are described in more detail in a patent application of the present assignee titled Resolving a Distributed Topology To Stream Data filed on Jul. 11 2003 and which is incorporated by reference herein.

The distributed topology performs various functionalities. For example the distributed topology can insert a network transmitter at the server side and a network receiver at the client side. The network receiver is connected in turn to audio and or video renderers at the client side. In this particular configuration a video transmitter and an audio transmitter are illustrated on server while a corresponding video receiver and an audio receiver are illustrated on the client side.

During a remote desktop media presentation scenario media can be directed to the client in an unprocessed or partially processed form which is streamed to client . For instance at server media foundation can intercept media that would otherwise be processed at the server such as by server video decoder server video effect server video renderer server audio decoder server audio effects and server audio renderer . The media is redirected to the respective video and audio transmitters for streaming to client . Streaming may be over various channels. For instance the media may be streamed in band with the RDP over a virtual channel. Such a configuration re uses the existing RDP connection and allows RDP to handle various details of punching thru firewalls and establishing a secure authenticated context among other tasks. Alternatively or additionally the media may be streamed over a side band user datagram protocol UDP or transmission control protocol TCP connection. In some instances an out of band configuration may be more performant. For instance in a particular configuration an out of band connection may be available with greater bandwidth than is available in that particular instance through the RDP.

On the client side the streamed media is received at the multimedia component which in turn passes it to video and audio receivers . The video and audio receivers pass the media to the client side transforms and sinks which in this illustrated configuration comprise client video decoder client video effect client video renderer client audio decoder client audio effects and client audio renderer . The media is then decoded and rendered at the client. Since the audio and video are streamed in their encoded form any synchronization tools contained in the encoded media will be available at the client to maintain proper audio video synchronization. For ease of explanation unprocessed media is streamed from the server to the client in this example. However some processing of the media may occur in other implementations. For instance assume that consistent with the above described remote desktop scenario a user requests to play media which is encoded at the source in hypothetical codec AA . Assume further that the source contains the components to decode hypothetical codec AA but the client does not but that both the source and the client have codec capability for a second hypothetical codec format BB . In such an instance the source may decode the media and then recode the media into BB format before streaming the media to the client. This is but one example which represents various levels of processing to the media which may occur at system components consistent with the concepts described above and below.

A geometry tracking component or geometry tracker can register and track any changes relating to a target window of the terminal services session. For instance geometry tracker can register a unique identifier for a target window and track the target window on the remote desktop described above. The geometry tracker tracks changes relating to clipping of the target window by another window position of the target window and size of the target window at the server side. These changes are then relayed to the client side by the remote desktop protocols where the changes are directed to the client side multimedia component .

So for example any geometry changes or updates to the client media presentation window such as media presentation window described above in relation to which are relayed to the client multimedia component are applied to the client media presentation window at the remote desktop. For example relaying the geometry updates allows a user to click drag the media player window in the terminal services session and have the resultant movement be accurately reflected at the client by the video presentation moving around to follow the media player window on the remote desktop. Such an example is illustrated and described above in relation to . A more detailed example of geometry tracking is described below under the section titled geometry tracking . The above described scheme can be repeated for multiple player applications on the server playing within one terminal services session to a terminal services client. In such a case a single terminal services client multimedia component services the requests of multiple server side applications.

Also within the user mode process boundary are a media source a directx media object DMO and a net sink . Media engine serves as a central focal point for media player to participate in a media presentation. A terminal server application program interface also resides within user mode process boundary . The terminal server application program interfaces provide geometry tracking virtual channels as are discussed in more detail in relation to a section below under the heading geometry tracking . In a kernel mode of the operating system occurs terminal services drivers . Specifically the terminal services drivers relate to a remote desktop display device RDPDD and a remote desktop winstation driver RDPWD . An exemplary system configuration which can support the above described components is described below in relation to .

Computing environment includes a variety of computer readable media which can be any media that is accessible by server and includes both volatile and non volatile media removable and non removable media. The system memory includes computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . A basic input output system BIOS maintains the basic routines that facilitate information transfer between components within server such as during start up and is stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently operated on by one or more of the processors .

Server may include other removable non removable volatile non volatile computer storage media. By way of example a hard disk drive reads from and writes to a non removable non volatile magnetic media not shown a magnetic disk drive reads from and writes to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive reads from and or writes to a removable non volatile optical disk such as a CD ROM digital versatile disk DVD or any other type of optical media. In this example the hard disk drive magnetic disk drive and optical disk drive are each connected to the system bus by one or more data media interfaces . The disk drives and associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for server .

Any number of program modules can be stored on the hard disk magnetic disk optical disk ROM and or RAM including by way of example an operating system one or more application programs other program modules and program data . Each of such operating system application programs other program modules and program data or some combination thereof may include an embodiment of the systems and methods described herein.

A user can interface with server via any number of different input devices such as a keyboard and pointing device e.g. a mouse . Other input devices not shown specifically may include a microphone joystick game pad controller satellite dish serial port scanner and or the like. These and other input devices are connected to the processors via input output interfaces that are coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port and or a universal serial bus USB .

A monitor or other type of display device can be connected to the system bus via an interface such as a video adapter . In addition to the monitor other output peripheral devices can include components such as speakers not shown and a printer which can be connected to server via the input output interfaces .

Server can operate in a networked environment using logical connections to one or more remote computers such as remote client device or client . By way of example the remote client can be a personal computer portable computer a server a router a network computer a peer device or other common network node and the like. The remote client is illustrated as a portable computer that can include many or all of the elements and features described herein relative to server .

Logical connections between server and the remote client are depicted as a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. When implemented in a LAN networking environment the server is connected to a local network via a network interface or adapter . When implemented in a WAN networking environment the server typically includes a modem or other means for establishing communications over the wide area network . The modem which can be internal or external to server can be connected to the system bus via the input output interfaces or other appropriate mechanisms. The illustrated network connections are exemplary and other means of establishing communication link s between the computing devices and can be utilized.

In a networked environment such as that illustrated with computing environment program modules depicted relative to the server or portions thereof may be stored in a remote memory storage device. By way of example remote application programs are maintained with a memory device of remote client . For purposes of illustration application programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the server and are executed by the processors of the server.

An example of but one implementation of a geometry tracking technique for use in managing multimedia transmissions to terminal services connections is described below.

Geometry tracking consist of three different components. There is a server side component the RDP Display Device RDPDD driver and a client side component.

The server component is responsible for the registration of window tracking. The RDPDD driver is responsible for detecting geometry changes and transmitting new geometry information to the client. The client component is responsible for delegating geometry change notifications to geometry notify sinks.

The TSGeoTrack static library provides the server side geometry tracking component. It provides the necessary classes to register a window with geometry tracking. Distributed media foundation DMF should statically link to this library. DMF is an example of a media platform remoting technology such as can be employed by the Media Foundation media platform. The library is published cross depot in the termsrv depot so getting access to it should not be a problem.

The RDPMM plugin is the multimedia plugin for the terminal services TS client. The RDPMM plugin receives geometry change notifications from the RDPDD driver and propagates them to the appropriate notification sink on the DMF client. The RDPMM plugin will be statically linked to the TS client.

The multimedia MM plugin is a sink plugin for RDPMM. The MM plugin will host the geometry notify sinks. It has to be implemented as a DLL and registered in an appropriate manner. RDPMM will automatically load this DLL when multimedia capabilities are required. The MM plugin dynamic link library DLL has to implement a specific entry point method in order for RDPMM to initialize it.

Media foundation MF can use the MM plugin to the DMF client within the TS Client Core. MF has to register itself as an MM plugin and implement the required entry point method.

RDPDD.DLL is the RDP Display Device driver library. Provides the facility of generating geometry change events and transporting them to the client.

The DMF client will provide geometry notify sinks that will be registered with the RDPMM plugin. This component will actually be seen by RDPMM as the MM plugin.

Table 1 describes the communication sequence involved in registering for track events of a window. DMF plays an important role in this process as it transmits the track ID of the window from its server component to its client component and register a sink for it. This entire process must be repeated in order to track another window.

Table 2 describes the communication sequence involved when a window that is registered for geometry tracking changes its geometry.

ITSServerGeometryTracker is the server side geometry tracking interface. It provides the methods that are needed to initialize geometry tracking and register windows for tracking.

TSGEOTRACK.LIB provides an implementation of this interface through CTSServerGeometryTracker. User s of geometry tracking should use CTSServerGeometryTracker through the ITSServerGeometryTracker interface.

ITSServerGeometryTracker is an interface that provides the necessary methods to start and stop geometry tracking and register allow the registration of windows to be tracked. This interface should only be used to track server side windows.

The StartGeometryTracking method registers a window for geometry tracking. This method registers the given window with the RDPDD driver for geometry tracking notifications. This method will return a track ID to the caller. The track ID is a unique identifier for the particular registration that can be used to register a notification sink for geometry events from the window and to stop tracking itself.

The EndGeometryTracking method unregisters a window for geometry tracking. This method unregisters the given window with the RDPDD driver for geometry tracking notifications.

The CTSServerGeometryTracker class provides the implementation of window tracking registration. CTSServerGeometryTracker also implements the IUnknown interface to provide reference counting. When windows are registered for geometry tracking the CTSServerGeometryTracker class registered the given window with the RDPDD driver.

fInitialized is a flag that keeps track if an instance of CTSServerGeometryTracker is initialized. No operations will be allowed to be performed on an instance of CTSServerGeometryTracker until it has be initialize by calling the Initialize method.

The SendToDriver method is used to register and unregister for geometry tracking events with the RDPDD driver. The SendToDriver method is written in a generic way and can be used to send other commands to the RDPDD driver.

In order to be a multimedia plugin on the TS client the ITSMultimediaPluginHost interface must be implemented.

ITSMultimediaPluginHost is an interface implemented on the client side that provides the necessary methods to register and unregister a geometry tracking notification sink and to get to a handle to the renderer s parent window.

SetGeometryTrackerNotifySink registers the given geometry tracker notification sink. Whenever notifications with the given track ID arrive at the RDPMM plugin they will be forwarded to the registered sink. If a track ID is registered more than once this method will return an error.

RemoveGeometryTrackerNotifySink unregisters the given geometry tracker notification sink. Whenever notifications with the given track ID arrive at the RDPMM plugin they will be forwarded to the registered sink.

CRDPMMWindowInformation is a utility class that stores information regarding a window. CRDPMMWindowInformation holds a pointer to the corresponding notification sink track ID the latest clipping region and rectangle. This class has no relationship with ITSWindowInformation.

 spGeomtryNotifySink is a smart pointer to the geometry tracking notification sink corresponding to the particular window.

 fWindowVisible is a flag that specifies whether the window is visible or not. If the window is visible this value will be TRUE otherwise it will be false.

Note this value does not set the visibility of the window but holds the value of the current state of the window.

GetGeometryNotifySink returns a pointer to the geometry notification sink for this particular window. If there is no sink associated the particular window this method will return NULL.

SetGeometryNotifySink sets the geometry notification sink for the particular window. Setting the notify sink to a value of NULL means the window has no sink associated to it.

CRDPMultimediaPlugin is the implementation of the RDP Multimedia plugin. It implements ITSClientPlugin so it can be a TS Client plugin ITSMultimediaPluginHost so that it can handle geometry tracking. This class provides mechanism for the DMF client to register geometry notify sinks.

 spCoreApi is a pointer to the TS Core API. The Core API is needed to register for notifications of all types .

spOnPluginInitialized is a pointer to the plugin initialization notification sink. The OnPluginnitialized event handler will be called when the MF plugin is initialized.

spOnShellInformation is a pointer to the shell information notification sink. The OnShellInformation event handler will be called when a shell information event is received. Window information events can be geometry tracking events.

mapWindowInformation is a hash table that maps a track ID to window information about the corresponding window. This structure can be used to look up a sink for a given track ID. The current window properties will also be stored.

spMFPluginNotifySink is pointer to the plugin notification sink for the MF plugin. Notifications generated by the MF plugin will arrive at this sink.

NotifyGeometryChange is a utility method that accepts the geometry information of a window and generates a geometry tracking notification at the appropriate sink. This method uses the track ID sink map to find the appropriate sink given a track ID of the window.

IsPolicyMMEnabled is a utility method that determines whether the MF plugin should be loaded. The MF plugin will be loaded if the EnableMedia policy is set. This method checks with the registry to determine if EnableMedia policy is set.

Please refer to the registry section of this document to find the necessary keys that need to be set.

InitializeMMPluginDLL is a utility method that loads the MF plugin. The MF plugin must be registered as the MM plugin in the registery.

Please refer to the registry section of this document to find the necessary keys that need to be set.

TerminateMMPluginDLL is a utility method that unloads the MF plugin. This method also removes all geometry notification sinks that have been registered. The plugin notification sink is also removed.

The geometry notify sink interface should be implemented by anyone that wants to receive geometry change notifications. The MF plugin should have an implementation of this interface.

OnNotifyGeometryChange is a method that is invoked when a windows geometry changes. The windows new geometry rectangle and clipping region will be given to this method.

OnNotifyEndTracking is a method that is invoked when the server requests that the window no longer be tracked. No further events will be passed to this sink once this method has been called.

All geometry change notifications will occur on the RDPMM thread. The RDPMM plugin notifies the MM plugin of geometry changes by directly invoking the methods defined in the ITSMultimediaGeometryNotifySink interface.

The RDPMM will manage geometry notifications through a map containing CRDPMMWindowInformation objects. The entries in the map can be partially filled meaning that they only contain partial information regarding the window. Either the notification sink or the window s geometry information could be missing. The notification sink could be missing because the MM plugin has yet to register a sink for the window. The geometry information could be missing if RDPMM has yet to receive any geometry information for the window.

The following algorithm is followed during when the MM plugin registers a notification sink with RDPMM 

MF plays an important role in transporting the track ID from the DMF server to the DMF client. In order to register a window for tracking it must be registered with the server side geometry tracker and then a notification sink must be set up with the RDPMM which lives on the client.

The server side geometry tracker will return a track ID to the DMF server upon registration. In order for the DMF client to set up the notification sink with RDPMM the DMF server must communicate the track ID to the DMF client. This should be done through virtual channels.

The geometry tracking system can tolerate a delay between window registrations on the server side and sink registrations client side. RDPMM will maintain updates from a window that has no sink associated so that when the sink is eventually registered the latest information will be immediately available.

The above sequence of table 9 describes the object communication flow during geometry tracking and notification sink registration.

The above sequence of Table 10 describes the object communication flow during geometry change notification when the visibility of the window does not change.

The above sequence of table 11 describes the object communication flow during geometry change notification when visibility of the window changes from invisible to visible.

The above sequence of table 12 describes the object communication flow during geometry change notification when visibility of the window changes from visible to invisible.

A global method is provided to get a reference of the geometry tracker. This method is responsible for the construction and the destruction of the geometry tracker.

This section provides but one example for achieving geometry tracking of a media presentation consistent with the concepts described above and below.

At block on the server side the method sends a user interface component of a server desktop during a terminal services session. In one instance the user interface component simply comprises an application window such as media player window. In another instance the user interface comprises a server desktop. For instance a server desktop may include one or more icons and one or more toolbars superimposed over a background image. One or more windows may be open on the server desktop. The user interface component is sent over a network channel established by the terminal services session.

At block the method receives the user interface component at the client side during the terminal services session.

At block on the server side the method streams media to the client. The media is streamed responsive to receiving from the remote client a media presentation request for a media application on the user interface component. The media can be streamed over a separate network channel from the interface component. The network channel utilized for streaming the media can be established by the terminal services session or can be established by the method outside of the terminal services session. The media is streamed in a compressed or only partially processed format to the client. In some instances the method negotiates between the server and the client to determine what media formats are supported by the client. If the media is accessed in a format which is not supported by the client then the method may decode the media and re encode the media into a format supported by the client before streaming the media to the client.

At block on the client side the method accepts the media stream corresponding to the media presentation request. The media can be processed such as by one or more transforms before being rendered on the client. In at least some methods the components at the source which process the media need not be aware of the terminal services session to achieve their functionalities.

At block on the client side the method generates a remote desktop experience by combining a media presentation with the user interface component. The media presentation is generated from the streamed media. In some instances the media may be presented in a window within an application window. For instance the media may be presented in a media presentation window within a media player window.

At block on the server side the method tracks presentation of the media on a remote desktop at the remote client without presenting the media on the server desktop. Note that in at least some instances any changes at the remote desktop are first reflected at the server. The changes to the user interface are reflected when an updated user interface is sent to the client. Changes to the media presentation are tracked separately since the media is not actually being presented at the server. The method can assign a unique identifier to a region which acts as a placeholder for the media presentation on the server. In one instance the unique identifier is assigned to the media presentation window where the media presentation window is represented by the placeholder at the server. Any actions affecting the media presentation window can then be tracked. Such actions can include the user at the remote desktop clicking and dragging the media player window across the remote desktop the user reducing or enlarging the size of the media player window and or other actions. For instance another window may be opened which clips the media presentation window. Such actions can be tracked at the server and relayed to the client so that the remote desktop can be updated accordingly.

At block on the client side the method acquires geometry updates regarding the media presentation relative to the remote desktop. For instance if the user clicked and dragged the media player window then the geometry updates can cause the client to move the media presentation accordingly so that its media presentation window follows the media player window to its new location. In configurations where the server creates a placeholder on the server desktop the client presents the media on the remote desktop over the placeholder wherever the placeholder moves on the remote desktop

Although embodiments relating to managing multimedia transmissions to terminal services connections have been described in language specific to structural features and or methods it is to be understood that the subject of the appended claims is not necessarily limited to the specific features or methods described. Rather the specific features and methods provide examples of implementations for the concepts described above and below.

