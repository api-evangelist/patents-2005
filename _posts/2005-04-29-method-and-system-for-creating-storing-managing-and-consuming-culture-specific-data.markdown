---

title: Method and system for creating, storing, managing and consuming culture specific data
abstract: A localization platform is used to localize data to one or more distinct markets. A matching component receives data to be localized and accesses different localization components and returns localized data corresponding to the input data. A data gathering component receives localized content from an input source that is external to the localization platform along with metadata that identifies the particular input source that provided the localized content. The data gathering component then only allows the particular input source that provided the localized content to modify that localized content.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07774195&OS=07774195&RS=07774195
owner: Microsoft Corporation
number: 07774195
owner_city: Redmond
owner_country: US
publication_date: 20050429
---
The present application is based on and claims the benefit of U.S. provisional patent application Ser. No. 60 659 616 filed Mar. 8 2005 the content of which is hereby incorporated by reference in its entirety.

Localization is a process of modifying products or services to account for differences in distinct markets. A very common example of localization occurs when an application is authored in a source language and is introduced into a market that uses a target language different from the original one. For instance if an application were authored in the English language and then introduced into China it would be localized by translating the various English language strings and UI elements menus icons etc. software components and user assistance in the application into Chinese. The UI layout and style including font type size control positions etc. will also likely be changed to suit the target language. Of course the concept of localization is broader than simply modifying language. Markets that use the same language may be distinct for other reasons. For instance a software application may be localized for different age groups. It may have one set of language and appearance for adults and another for children or teens. Thus localization illustratively accommodates for a wide variety of differences in distinct markets.

Although as described above localization involves many more things that just translating strings to facilitate the reading of the document we will concentrate the description on that scenario. In a similar way most of the examples are taken from the software localization field but the invention is not limited to software localization. Similarly while much of the present discussion focuses on localizing a product the invention is not so limited and is just as applicable to services and thus the term product includes services for the sake of this description. In the past there has not been a system level attempt to provide localization but instead localization has been performed using individual components to solve individual problems. For instance a localizer may be augmented with certain machine translation techniques to improve localization speed accuracy and consistency. However a different localizer may use just translation memories in order to increase the recycle rate by reusing previous translations hence providing a more consistent result at a higher speed than she would without tools.

Also this has all been done conventionally in an offline way. In other words the author creates an entire application or a large portion of a component and that component or application is provided to a localizer for localization. The usual process is such that the localizer s interaction with the original author is minimal or non existent. This makes it hard to introduce changes in the original content that would ease its localization. In fact in many cases localization is not performed until well after the entire product has been developed and a strategic marketing decision has been made to expand that product into a different market that uses a different language or is distinct in another way. In all of these cases there is typically very little up front work done in developing an application with localization in mind or even optimizing for localization. Similarly there is very little support in the development authoring stage for developing an application or other product service which will be relatively easy to localize even though authoring a product or service which is easily localizable is no more difficult than authoring one that is not easy to localize.

Therefore products services and applications have traditionally been translated into different languages or otherwise localized through a complex manual and labor intensive process. The cost for this localization of software products and the translation of product related content represents a significant hurdle which must be overcome in order to enter new markets. This is especially true for small to mid size independent software vendors or content authors.

The problem of localization also scales depending on the particular location in which the software is developed. For developers that are authoring software in locations that have large markets localizing the software to different and likely smaller markets is less of a need. However if a developer authors in a location and using a language which has a relatively small market the entire viability of the product may depend on the ability to localize that product into languages used in larger markets. This requires the manufacturers to spend an inordinately high amount of resources on localization. This often detracts from the resources available for development.

Another problem associated with prior localization efforts is that there has not been a good way to draw on the work of a variety of other localization sources. For instance a wide variety of vendors localize their products for various markets. Similar applications developed by different vendors may likely be localizing the same or very similar strings or software for the same markets. However there is currently no expedient way for the two to draw on or share the efforts of one another. Therefore there is a great deal of duplicated effort in localizing products.

Furthermore there are many different programming models such as Win32 CLR and WEB scripting with different types of resource managers resource formats and data stores. They require different parsers and tool sets to handle localization which results in complex and costly processes and inconsistencies in localization quality.

The present invention provides an operating system with an integrated localization platform or a localization platform which has components closely operable with the operating system although not fully integrated. The present localization platform can also be provided as a service that is requested by the operating system. The present invention utilizes the localization platform to localize content and software. The present invention can also be used during the development of products or services implementing practices which enable quicker and more efficient localization of the product or service. The present discussion will proceed primarily with respect to translation during the localization process but the invention is not so limited and localization includes a wide variety of other accommodations for distinct markets as well. Prior to describing the present invention in more detail one embodiment of an environment in which the present invention can be used will be described.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention is designed to be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules are located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

System itself includes resource manager layout engine translation memory TM matcher download manager translation memory TM data service machine translation MT system filters certificate system and a plurality of different data stores. The data stores shown in include application rules data store local and private stores and respectively term base data store and term base translation data store ontology store translation memory and common UI elements data store . In general application rules are used in the resources to specify application related rich data while filters are used to ensure that entities or input sources contributing to data are only able to modify the data they contributed and that all data added are filtered based on certain rules. Of course the data stores can be grouped merged or split differently in any desired way. The detailed operation of system is described later in the specification with respect to . However a brief discussion of the operation of system and the items shown in will now be undertaken.

During runtime resource manager loads the resources associated with application into cache memory similar scenarios can be found for content and other type of localizable data . Resource manager also receives calls from application for resources. Resource manager in response first loads a string in a language that is associated with the locale currently selected by platform . Resource manager decides which version of the resource to load based on a variety of criteria such as availability confidence level user settings etc. Resource manager may decide to invoke TM matcher . To do so resource manager calls TM matcher to obtain a translation or localization of a specified resource. TM matcher may also have pre populated resource data to prevent run time delays in resource loading the pre populated information will be tagged with relevant information such as whether it came from MT system or TM matcher its confidence source etc. This is discussed in greater detail below. If TM matcher does not return a match for the resource resource manager cascades through resource fallbacks so that translation can be provided in a different fallback language. This is also described in greater detail below. Also in one embodiment both resource manager and TM matcher have fallbacks. They can be different from one another and although the results of TM matcher can influence resource manager resource manager can decide to fallback without calling TM matcher .

It is not uncommon that changes made by localization on strings forces changes on the display items containing those strings. Common examples include the need for more space longer strings changes on the flow of a dialog right to left languages vs. left to right languages etc. The adjustment process can happen at localization time at rendering time or both. The most common case is that rearrangement and resizing of the items in a dialog is needed and the process is referred to as auto layout. The amount and correctness of the information provided during the authoring process will influence the results produced at runtime.

TM matcher is situated between various sources of translations and resource manager which requests content to be matched or translated into another language or otherwise localized . TM matcher searches the available sources and those sources which are trusted by the application to find a translation which has the highest confidence score associated with it.

Again a more detailed discussion of the operation of TM matcher is set out below with respect to . Briefly however TM matcher accesses rules associated with application or content in application rules data store to ensure that whatever localization is provided back to resource manager does not cause application to malfunction. TM matcher first searches local data store and private data store to see if a localization already exists. Local data store holds translations or other localizations of resources which have already been localized in case the request being made by resource manager is one which has been made before.

TM matcher also invokes TM data service . TM data service accesses translation memory which contains translations or other localizations of a wide variety of different things such as common user interface UI elements stored in store as well as defined terms stored in term base and ontology store provides context information for application and an associated domain.

If no localizations already exist either locally on store or or remotely on store TM matcher can access an optionally available machine translation MT system or one of a plurality of available MT systems to perform machine translation on the content to be localized. The decision by TM matcher to invoke MT system can be based on user preferences the availability of a translation the quality of available translations and MT provided translations etc. Machine translation system in one embodiment is any commercially available MT system and is illustratively only utilized for translations if there were no matches with a higher confidence level from any of the other memory sources such as TM data service and the local and private data stores and . The fact that MT system can be substantially any MT system or any system capable of using the data in the different stores e.g. previous translations to produce translations greatly enhances the extensibility of the system because new or different MT systems can easily be utilized by TM matcher .

Of course the MT system extensibility is not the only extensibility in the system but is only one example. Some other examples of system extensibility include content authoring editors language parsers third party translation memories community editors development authoring environments connection to web services etc. Extensibility in these areas and others is supported by the APIs in platform .

In any case each of the translation resources called upon by TM matcher will illustratively provide TM matcher with a confidence score or translation rate recycle rate or other similar measure indicative of the confidence or re use rate associated with the localization being requested. TM matcher can then select the localization or translation from the trusted source which provides the translation associated with the highest score. The translations are then downloaded by download manager to local store if they are not already stored there.

In one illustrative embodiment a wide variety of input sources can provide translation inputs to the various memories in system . For example vendors or software manufacturers that develop operating systems that incorporate localization platform will illustratively provide trusted terms to the various memories. However in one embodiment input sources can include the community at large and the development community. The community at large allows anyone that performs localization services using system to provide a suggested localization of a piece of content to the appropriate memory through data gathering component . The input sources may also include the development community which will as opposed to the community at large store translations provided only by developers officially recognized as such. Thus it can be seen that platform allows the localization process to be opened up for community involvement on a very large scale as well as adjusted at a granular level e.g. user decides what to trust and what not to meet the user s needs and expectations.

Further data gathering component can dynamically during set up runtime configuration etc. intermittently collect new data from a variety of input sources . The new data can of course be new resource data as well as pre localized data or translation memory data to support new applications new domains and to perform self turning of a running operating system. This embraces adaptability and accuracy of the system.

However a particular application developer system administrator or user may desire that only certain localization content be trusted. The developer may for instance not wish to trust localization content from the community at large or the development community but only from vendors and OS manufacturers. This allows a developer or user to set the extent to which the platform opens the localization tasks to different sources. This can be set even on a string by string basis.

In one such embodiment system includes certificate system which attaches certificates to content provided by certain sources. In that instance the developer of application may desire that only localization content with an attached certificate be trusted. For instance developers and other contributors might be able to obtain the right to sign their content which is relative to the tier they are in in relation to their application. That means that a certificate of the developer of an application puts that developer in the developer tier for that specific application and all other contributors are one tier down in the other ISV community or user tier. The certificates can be trusted relative to the tier of the contributor. For instance a given manufacturer might always have the highest tier but from that tier on down the user can determine a trusted tier and within a tier trusted sources. The indication as to which localization content is to be trusted by any given application or by any user may be stored in the application rules data store . The certificates help to establish a trust system for translations.

The user or developer can also choose hierarchical trusted sources. For instance based on the origin of the localization content a user can determine whether to trust only the OS manufacturer and if none is available then to trust independent software vendor translations and if those are not available only then to trust the development community and so on. In one illustrative embodiment this hierarchy is established by default but a user can simply accept or override it with personal settings. Such settings can be implemented in the application rules associated with each application or with an individual machine running the application.

Also it should be noted that private store is similar to local store in that it resides on a user s data store. However local store is illustratively a system wide store while private store is a store which can be used to indicate trusted localization content corresponding to an individual user including data entered by the user for their own private use. Therefore each individual user may identify different trusted localization content. That content is identified to that particular user in private store . This allows an individual user to customize the localization process even further than that associated with an individual application. For instance the user can make changes to his or her own applications as needed and allowed by the application. The user can also share local or private stores back to the community.

In addition certain translations can be locked so that they are not modified. This can be critically important for avoiding potentially malicious translations. For instance one of the input sources might provide a malicious translation which would translate the term Click here to format your hard drive as Click here to continue. 

Once TM matcher obtains a desired localization for the request from resource manager it applies filters and application rules from store . Filters illustratively define terms which are not to be placed in any localization content in any given language. For instance some users may desire to filter obscene terms or any other objectionable content. Therefore filters are applied prior to using the localized content requested by resource manager . It will be noted that applying filters as well as any other type of validation is one step in localization and can be applied at many steps in the process such as editing downloading using etc.

For instance validation in general occurs whenever two components exchange data unless the components completely trust one another and the channel used to communicate is also trusted such as against surreptitious activity . Therefore for instance if resources are downloaded from a trusted source and the resources contain a valid signature no other validation other than validating the signature needs to be done. If the source is trusted but the file is not signed then the channel used to transport the information is evaluated to determine whether it is also trusted. For example an unsigned file that has been downloaded from the internet is more likely to be tampered with than an unsigned file that a user copied from another folder in the same computer. Depending on several factors it may decide to undertake a quick functional validation or some additional content validation may be conducted such as checking for offensive words or to ensure terms in the original resource are present on the target resource e.g. so menu is not translated as folder .

Application setup configuration component is used during setup and post setup configuration. During setup application registers its resources with local resource store . Component illustratively exposes a user interface which allows the user to localize the application to a target language supported by the platform if it is not already localized. The user interface can allow the user to explicitly select the target language. On demand localization component passes these requests to resource manager and also possibly to TM matcher .

Legacy application represents applications that were developed and are not aware of platform . Compatibility layer supports existing resource interfaces used by application and redirects calls to resource manager .

In the background the operating system and in particular the localization platform begins translating the resources in cache to the desired language. In doing so platform implements the application rules associated with application and the trust model i.e. the trusted localization sources associated with application or the user whichever apply . Resource manager invokes TM matcher for the resources stored in cache to obtain their localized value. Localization of the resources loaded into cache in the background is indicated by block in .

It should also be noted that populating the localized resources for an application need not wait until runtime. Instead it can be done during set up or at another time. In addition some parts of localization can be run at run time while others can be done at setup or another time. For instance some of the more computationally expensive or time consuming tasks can be performed in the background during setup or at another time while the quicker tasks may be performed at runtime. In still another embodiment the tasks can be assigned by the user to be performed at any specific time and the status of those tasks can be displayed as well.

As the resources are localized in the background not only are the localized values stored in cache but they are also placed in local store . Therefore the next time that application is launched the localization process will be much quicker because all of those resource values that have been localized will already be located in local store . Thus TM matcher need not search TM data service or have the values translated using machine translation system because the localizations will be remembered by the system. Instead they can simply be retrieved from local store . Storing the translations in local store is indicated by block in . Also on demand entire translations can be loaded into local store using download manager .

Of course the present system can also check for updates. For instance a non ideal translation might initially be chosen because none better can be located. Later however a better translation might be loaded into one of the memories by one of the sources . The resource can then be periodically updated to accommodate this.

Similarly code updates might make previously localized resources invalid. Therefore in one embodiment code changes trigger re localization of some or all of the resources.

As the resource translations are made layout engine identify certain translations that will require modifications to the layout of the display for the application. In addition the fonts used in the source language in the application are mapped to the fonts in the target language. This can be done by layout engine or other components at runtime or at a previous time. Layout and font mapping is indicated by block in .

In this way localization platform in the operating system continues to localize the resources associated with the application and stored in cache . It may happen however that the application makes a request for a resource that has not yet been localized in the background. Such a request is indicated by block in . Resource manager first determines whether the requested resource has already been localized and stored in cache . This is indicated by block in . If so the localization of the requested resource is simply returned from cache memory to the application . This is indicated by block .

However if the resource has not yet been localized in the background and stored in cache then resource manager requests localization of the resource from TM matcher . TM matcher then requests localization of the resource from the various sources which it has access to and returns the localization of the requested resource. Invoking the TM matcher is indicated by block in . The operation of TM matcher is described in more detail with respect to .

By localizing the resources in cache in the background localization platform departs significantly from prior systems. Prior systems load the cache with the resources. However this leads to significant disadvantages in localization. If the localization platform waits for the application to request a resource in order to localize it on the fly by invoking MT this likely results in an undesirable delay in the operation of application or the results will be limited by the set of algorithms that can be used in such a constrained environment performance requirements can limit accuracy . Current machine translation technology requires approximately one half a second to translate a sentence. While on the fly translation and other localization is certainly contemplated by the present invention translating all of the resources on the fly using machine translation system likely results in an undue delay in the operation of the application. Of course if a substantial number of the resources had been localized before and are stored in local store or private store or if they were stored in translation memory and only a relatively small portion of the resources needed to be translated by MT system then localization of cache in the background is not as important to avoid compromising the operation of application .

In any case TM matcher continues to localize the values in cache either in the background and or on the fly. TM matcher continues until all the resources are localized.

In general TM matcher can work against one or more data stores. It can optionally integrate with other recycle engines such as TM matchers or MT systems . It can optionally take advantage of terminologies along with their translations and relationships ontologies . It can use metadata to decide which pieces of data in the stores are supposed to constitute the search space such as domain area author approval status or other metadata . It can look at restrictions application rules filters on the string itself and take advantage of those to produce a better match or a match that will be more readily validated. Of course these features are all optional and more may be added or these can be changed or deleted from the TM matcher operation as desired.

TM matcher then illustratively requests localizations of the resource from all trusted localization sources but may do so in a given order. The order and the number of sources checked illustratively varies depending on the circumstances such as whether the localization is taking place at run time setup time in batch processing etc. . This is indicated by block . In other words in one embodiment TM matcher does not even request a translation from non trusted sources. In that instance assume that the user does not wish to trust translations from the community at large or from the development community in input sources . TM matcher will only ask for localization content which originated from trusted sources and will thereby exclude all of the localization content provided by the community at large and development community. Of course the TM matcher will modify the sources from which localization results are requested based upon the trusted sources given the present context.

In response to the request from TM matcher the various sources which have been requested for localization content return their associated confidence scores. For instance it is very common for translation results to have an associated confidence level indicative of how likely it is that the translation is correct given the input in the source language. It is not important for purposes of the present invention what particular measure is used to indicate the confidence associated with a translation or other localization. In the illustrative embodiment the scores from all sources either use the same measure or measures which are correlated to one another so that TM matcher can determine the relative magnitude of the scores. Returning the confidence scores associated with the translations or localization content is indicated by block in .

TM matcher then obtains the localized content e.g. the translation from the highest scoring trusted source. This is indicated by block . Also TM matcher can select localized content based on other or additional criteria as well such as the time required to obtain the localized content how close the localized content is to the target market validation criteria or other criteria or any combination of criteria. In addition the TM matcher can retrieve localization content from multiple sources and combine them.

Once the translation is received TM matcher applies the filters and other validation to ensure that the localization content or translation is appropriate given the application and context and any filters or validation criteria desired by the user. Applying the filters and other validation is indicated by block in . TM matcher also illustratively applies the application rules such that the localization content retrieved for the given resource will not inhibit operation of the application or cause improper operation or otherwise crash the application. It should also be noted that some of the filtering and validation processing can be pre computed rather than waiting to perform all necessary steps at this point in the process.

Once this is done TM matcher returns the result to resource manager . This is indicated by block . It will be appreciated that this process will be performed anytime TM matcher is invoked by resource manager . Thus the process will be performed when the resources in cache are being localized in the background and it will be performed when an application makes a call for a not as yet localized resource.

In either case TM matcher may find that there is no translation available in the desired language or the confidence scores returned are below a given threshold but that a translation must be undertaken using machine translation system . At that point in one embodiment resource manager is notified and may request TM matcher to look for a translation in a fallback language. For instance if the target language is Catalan application may request translation of a resource but one may not be available in Catalan. However resource manager may be configured such that Spanish is a first fallback language to Catalan. In that case TM matcher returns to resource manager indicating that no translation is available in Catalan and that machine translation system must be invoked to obtain such a translation alternatively MT system can be called on the first call by TM matcher . Resource manager may instead of taking the performance penalty associated with on the fly machine translation simply request TM matcher to return a translation of the requested resource in Spanish. If one is available it is returned by TM matcher .

Of course as indicated above the fallback locales languages may be hierarchally cascaded to any desired degree such that various locales are fallbacks for various other locales the ultimate fallback of which may be the source language. Thus if the ultimate fall back is reached instead of providing a translation of the requested resource resource manager simply returns to the application the requested resource in an ultimate fallback which is ensured by the platform so the application will not crash or lose an interaction point with the user because of the platform.

The user can also illustratively set how the fallback hierarchy works. For instance the user can indicate that displaying a group of resources together e.g. a dialog with several strings can show parts of the dialog in one language or localized to one market and parts in another e.g. in the fallback . Other users may indicate that the displayed group of resources is to all be in one language or localized to the same market .

It will also be noted that the user need not launch the application to have it translated by platform . The user can simply select an application or other software component for localization and platform can localize it in the background. For instance in one embodiment the user right clicks on an application and from a menu selects Localize . Platform then begins localizing the application in the background storing the localized content in the local store. Content can also be localized in the background. In one embodiment the user right clicks on a document that is stored in the file system or on a server and chooses Localize . The localization platform will localize the document in the background. The same applies to documents that are downloaded from the internet.

In addition when an application is installed or at a later time the user can select a plurality of different languages for installation. These languages are then loaded into the local data store . The translations can be stored on the product compact disc or other medium.

Build component uses the information provided by the localization platform and or assistance platform or any other content authoring tool that can access the localization platform through the APIs and the application rules in data store and builds application as well as content documents.

It will also be noted that the present discussion of proceeds generally with respect to the developer developing an application or an author authoring content. However the system can be used for a variety of things regardless of the type of content or software the developer is developing or the author is authoring.

In accordance with one embodiment of the present invention there are two ways for a developer or author respectively to use development component to develop software or assistance platform to develop content. The first is to use a feature in her authoring development environment that through a platform application programming interface API or other similar mechanism determines whether any similar content or software has already been developed and is stored in any of the memories in platform . The second way is for the developer to simply develop the software or content original or not . In the latter case platform simply acts to provide the developer with feedback as to the recycle rate e.g. the amount of content software which can be translated into different languages in platform given previous translations of the content software and to suggest practices that will likely increase the recycle rate and also to suggest practices that will inhibit the application from malfunctioning after localization.

In accordance with the first embodiment the content author provides an input through assistance platform and assistance platform calls an API or other similar mechanism to author a resource. This is indicated by block in . Assistance platform then invokes TM matcher to access local store and returns all types of resources that already have translations. This is indicated by block in . For instance the developer platform may invoke an API indicating that the content developer wishes to author a resource. In response the platform returns an indication of all of the different classes of resources which are contained in platform and which already have translations into a variety of different languages. Assume for example that the result from the platform and presented to the user by the developer platform are the classes menus and error messages .

Through the exposed functionality in the API the developer can choose the error message classes and assistance platform requests this information of platform it may be store in any memory then returns all of the different classes of error messages which are contained in platform . The developer then selects one of the classes of error messages and platform returns all of the specific error messages associated with that class. The user can then simply select one of the error messages which has already been authored and for which localization will already be highly efficient e.g. because it has already been translated into a variety of different languages or otherwise localized . The developer selecting the type class and specific resource if available is indicated by block in .

It will also be appreciated of course that the specific exact message which the developer wishes to author may not be already available. In that case the user can select a very close message and modify it. The modified message will likely in many cases be able to be localized quite efficiently because the majority of it was already in existence in localization platform . In any case choosing a similar not identical message will result in a confidence penalty. Modifying a chosen resource is indicated by block in .

This type of recycling provides the author with a high degree of flexibility relative to a prior art localizer that occurs after development. For instance the author can change the number of placeables on a software string while a traditional localizer is far more restricted. Also the author can entirely replace a source sentence assuming the key terms are maintained while a traditional localizer may not be able to. Consider the sentence for an error message file 0 does not exist. The author can change this to file 0 on drive 1 could not be found. whereas a conventional localizer cannot use the translation of the first sentence as a translation for the second one because without access to the code the conventional localizer is not able to change the underlying assumptions in the code regarding the number of placeables. The recycling may not only be done with respect to text found in messages but can also be done with respect to common UI elements in data store . Reusing prior UI elements also enhances the recycle rate and localization of the product.

During development the developer may also wish to provide ontology to ontology store . Ontology is a specification of a conceptualization and describes the relationships between terms which allows semantic encoding of content and strings. One embodiment of an ontology is set out in U.S. Pat. Nos. 6 253 170 and 6 098 033. Another description of ontology is set out in Gruber A TRANSLATION APPROACH TO PORTABLE ONTOLOGIES Knowledge Acquisition 5 2 199 220 1993 .

In general words are translated differently depending on context. Specifically words or terms can be translated differently depending on application context in software localization. The localization platform has access to semantic data in the form of ontology data store that describes the relationship between terms. Ontologies can be generated manually by entering semantic information together with the word or term or automatically by applying algorithms that are able to determine the semantic context by the proximity of a words or term to other words or terms. The data store is illustratively populated by structures and application context derived from the resource format. The type of semantic encoding in ontology store allows platform to disambiguate the semantics for the resources to be translated while also providing powerful search capabilities because it allows for query disambiguation as well. Translation platform determines whether disambiguation is required at block in . If so ontology store can be accessed to obtain disambiguating semantic information or assistance platform can request the disambiguating semantic information from the author the same way the development component can do the same to the developer. This is indicated by block in .

As the developer continues developing the product each of the authored resources is subjected to a localization rate estimate by translation platform in platform . In estimating the localization rate of the authored resources translation platform identifies the percentages of those resources which have already been translated or otherwise localized and which reside somewhere on platform . Translation platform also accounts for the requirement to subject the resources to machine translation by system and also takes into account the confidence scores associated with each of the translations residing on platform . These items are combined to provide a recycle rate which is a measure of how easy the product being authored will be to localize into markets operating under different languages. Providing the running overall recycle rate is indicated by block in .

It will be noted that the recycle rate can be used in a wide variety of different ways. For instance if the developer is only developing a component of an entire system the component may be required to meet a certain recycle rate threshold before it is allowed to be checked in. Similarly the recycle rate may well be indicative of the value of the product given how likely it is that the product will be introduced into other markets. Of course this recycle rate can be used in a wide variety of other ways as well.

It should also be noted that the system can calculate the recycle rate for code which is not developed on the platform. The code can simply be provided to platform and TM matcher can calculate the recycle rate for the code as a whole and return it as desired. This can be used in deciding whether to roll a product out into new markets or even whether to purchase rights in the product.

The discussion now proceeds with respect to the embodiment in which the developer is not choosing already existing resources. Assuming that the developer does not wish to select from pre authored resources the developer can author original resources or content. This is indicated by block in . In that case the developer simply authors a portion of the content and assistance platform calls TM matcher to determine a recycle rate for the authored content. This is indicated by block in . TM matcher then accesses its localization sources and returns a recycle rate for the newly authored resource or content. This is indicated by block in .

At this point platform can also be used to notify the author as to practices which may help the author improve the recycle rate of the product under development or to alert the author to certain practices which may cause the application to malfunction once it is localized. Returning these hints is indicated by block in . In one embodiment these hints are provided even if the source of the product is being re used. The fact that it is being re used may of course mean that some of the checks have already been performed.

Some examples of practices that might affect recycle rate or application function include for instance writing long strings. Long strings are not just harder to understand they are also more difficult to translate. In addition software presents the risk of a buffer overrun that would crash the application. Other practices that may affect recycle rate or application function include the use of special characters or the use of improper or informal grammar. Using proper grammar constructs leads to a great increase in the ability to translate the text. TM matcher thus provides a real time feedback as to the recycle rate of the code and practice tips.

Also platform can take certain actions to reduce a negative affect of these problem areas in the content under analysis. These actions will reduce the likelihood that an application will crash after undergoing localization. Platform can alert the user that these remedial actions will be taken.

A number of other items should be noted with respect to the present invention. First it illustratively provides hot key automation. Translation platform illustratively tracks hot keys that are displayed on any given UI in order to avoid two functions being assigned to the same hot key on a given UI. Translation platform can be invoked to select a hot key automatically or it can be simply invoked to check to ensure that no hot key duplication is undertaken on a given UI. In order to be able to select or suggest a hotkey to the user the platform needs information regarding which items are available to the user simultaneously so it can avoid repetitions. That information is closely related to the one needed to render the information into the user s computer.

The present invention can also provide validation and simulation of a runtime environment. Once the developer has authored the component the developer can invoke an API on development platform and platform will simulate a runtime environment under which localization is required. The runtime simulation allows the developer to physically see the display on the display screen after it has been localized. This allows the developer to scan for bugs gauge the aesthetic appeal of the displays and to make changes as desired.

The present invention thus enhances the ability of a developer to reuse already developed content. This significantly enhances the recycle rate and localization of the product.

Further the present invention provides a system that intelligently combines localized content from the operating system applications the community and third parties and from machine translation. The resource manager loads resources of an application by returning requested resources according to needed language or other cultural or market criteria from a variety of sources or data stores also referred to as localization content components .

In addition the localization platform can be used to provide localized data to a wide variety of requesting entities such as applications browsers search engines resource loaders authoring tools etc.

Also by allowing the community and community at large to suggest localization alternatives the present invention allows community standard localization to be defined and at times enables localization into some very small markets. For instances the present invention allows a user to localize an English language application for Swahili. The user may provide this localization back to platform as a suggested translation of the various resources in the application. Other South African users can choose to trust this localized content and download it in Swahili or to localize it themselves or modify the localization and provide their own localization back to platform . In this way the application can be localized and revised and made available in a market where it might otherwise not be due to small market size.

In one embodiment when an input source provides data data gathering component also records metadata such as origin usage context information such as resource versioning confidence level attributes machine translation hints etc. Other data can be collected and sorted as well. Also in one embodiment only the input source that provided data can change that data.

The present invention not only provides for downloading translations from a community but uploading them as well. In addition source strings can be uploaded downloaded in a similar manner.

It will also be noted that third party companies and communities can add new source and translation memories to platform . In one illustrative embodiment platform provides a web page or web service that enables the addition of a new source term and its metadata. The users will illustratively be authenticated so that platform can determine the source of each newly added item.

In addition platform will illustratively work according to a published schema such as an XML schema which enables users to upload several strings at once. Again the source of each string is known since every operation may require authentication. Such source strings can illustratively be added with one or more translations. The platform operates similarly with respect to terms in the term databases.

Also in accordance with one embodiment communities are able to provide translations to the source strings in platform . When editing translations the metadata present in the source is illustratively available to the translator and the metadata is enforced prior to accepting the translation. This can be done over a simple web interface. These translations can be used by other people if the user chooses to share his or her translations with the community.

The present invention also illustratively allows the community to review translations that already exist on platform . This allows a source of translations to determine how many times his or her translations have been chosen by other users. This will enable input sources in the community to build a name for themselves based on the quality of work and this drives input sources to do a better job so as to become more valued in the community.

In accordance with yet another embodiment of the present invention when a developer uploads an application for translation the developer is provided with an opportunity to enable end users to download their own localized version of the product. If that option is enabled the user can log into platform and pick which language engines and translations to use in order to generate a personal version of the product.

For example the user can ask for the xyz version of a product while specifying only exact matches of translation engines using translation memories that the community or a specific user has approved. This process can be periodically repeated to obtain a higher percentage of resource translation. Platform can also provides for notifications to users via mail or other alert services when new translations are available.

In accordance with another embodiment a third party can add a new source verification or translation engine to platform . As discussed above a developer can submit an application to platform to determine whether an application is highly localizable. Third parties can write new engines to support this. When a third party develops an engine that meets the criteria to perform source verification e.g. when it implements a desired interface then the third party can upload it to platform and charge back for users to download the engine. As with the other parts of the processes described with respect to the present invention signing and authentication are illustratively used to ensure that the source of the engine is known and the user has decided to trust that source.

Translation engines can be added in a similar way but may illustratively run on the server implementing platform with steps taken to ensure that the translation engine does not corrupt any already existing translation data. In addition the present invention performs globalization and linguistic checks to assist authors. The present invention also allows the community to help an author. For instance the community can be asked for a source string on a dialog box in a certain domain where the source string can be easily localized. This assists the author at the outset in authoring highly localizable content.

It should also be noted that while certain functions are assigned to certain components in the embodiment described that need not be the case. The functions could be performed by different components and so some components could be deleted modified or added all within the scope of the present invention.

It can thus be seen that the present invention consolidates data for localization from past localizations of a wide variety of products and a wide variety of input sources. Instead of each application or product having its own memory of translations which are not accessible by other products the platform makes this information available as desired by the developer or user to subsequent localization of different products. It also changes the localization process such that end users have access to a wider degree of options to customize localize their computer experience. It also enables community participation into the process. As a consequence the localization task itself becomes product independent only linked to the product through the application context. Other applications can access the localized strings at any time if the trust model and application context allow for that.

Although the present invention has been described with reference to particular embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention.

