---

title: System for defining and activating pluggable user interface components for a deployed application
abstract: Maintaining a plurality of application component catalogs describing user experiences associated with particular application programs. The invention includes an extensible schema for the application component catalogs and a method for matching user experiences within the application component catalogs to particular user requests. The invention provides an extensible and scalable infrastructure for customizing a user interface experience.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07793260&OS=07793260&RS=07793260
owner: Microsoft Corporation
number: 07793260
owner_city: Redmond
owner_country: US
publication_date: 20050425
---
Embodiments of the present invention relate to the field of user interfaces. In particular embodiments of this invention relate to an infrastructure for customizing components of a user interface for a particular application program.

Some server deployed web based mail application programs give users access to their centrally located mailboxes. These application programs also provide the ability to send and receive electronic mail email schedule appointments and perform other personal information management PIM tasks from a network such as the Internet. Some of these application programs execute in a browser and are a companion to other PIM application programs. In existing systems many aspects of the user interfaces for the server deployed application programs and other application programs are hard coded. The barrier to changing the user experience in these applications in a significant way is significant. For example every change to the infrastructure that is used to select rendering for folders items and extensions to the user preferences user interface requires re validating many aspects of the application programs to prevent regressions. Further many aspects of the application programs e.g. navigation pane user preferences and hypertext markup language forms based authentication need to segment selectively. The existing systems lack a scalable model or infrastructure for tailoring a user interface for a particular application program.

Accordingly a system for defining and activating pluggable user interface components is desired to address one or more of these and other disadvantages.

Embodiments of the invention include an application component catalog an application element data store or the like that allows developers to extend a user interface override the user interface and or tailor the user interface. The application component catalog describes the user experiences and application element mappings for an application and for a user. In an embodiment the invention includes a method for loading the application component catalog and a method for activating application elements and selecting user interface experiences based on incoming requests.

The invention includes a model that is easy to use flexible and supportable. The invention allows modular construction and definition of user experiences with an application program. For example the invention allows definition of a user interface or a portion thereof to render when dealing with data representation metaphors such as folders and items sections of user options and elements exposed in a navigation page. The invention sustains a broad set of user interface customization without affecting the supportability or integrity of the application.

In accordance with one aspect of the invention a system includes a computer readable medium storing a data structure representing a schema defining user experiences associated with various application program. The data structure includes a plurality of experience fields each storing an experience value representing a user interface experience associated with an application program. The data structure also includes a plurality of application element fields for each of the plurality of experience fields. Each of the plurality of application element fields stores an application element value representing an application element associated with the experience value stored in the experience field. The data structure also includes an element class field for each of the plurality of application element fields. The element class field stores an element class value representing an action state or form associated with the application element value stored in the application element field. The system further includes a processor configured to execute computer executable instructions for receiving a request for data from the application program identifying one of the plurality of experience fields in the data structure as a function of the application program identifying one of the plurality of application element fields associated with the identified experience field as a function of the requested data and providing to the application program the requested data via the element class value associated with the application element value in the identified application element field.

In accordance with another aspect of the invention a computerized method provides a user interface experience upon request. The computerized method includes receiving a request for data from software. The received request identifies a user associated with the request. The computerized method also includes identifying an application component catalog from a plurality of application component catalogs as a function of the user. The application component catalog includes a plurality of user interface experiences. The computerized method further includes identifying one of the plurality of user interface experiences in the identified application component catalog as a function of the software. The identified user interface experience has a plurality of application elements associated therewith. The computerized method further includes identifying one of the plurality of application elements as a function of data in the request. The computerized method also includes providing the requested data via the identified application element.

In accordance with yet another aspect of the invention one or more computer readable media have computer executable components for providing a user interface experience upon request. The components include a communications component for receiving a request for data from software. The received request identifies a user associated with the request. The received request has an action value and a state value. The components also include a user mapping component for identifying an application component catalog corresponding to the user. The application component catalog includes a plurality of user interface experiences. The components also include an experience mapping component for identifying one of the plurality of user interface experiences in the identified application component catalog based on the software. The identified user interface experience has a plurality of forms associated therewith. The components also include a user interface mapping component for identifying one of the plurality of forms in the identified user interface experience as a function of the action value and the state value. The communications component provides the identified form to the software.

In an embodiment the invention includes an application component catalog such as shown in that defines a set of user interface experiences for an application program e.g. a web browser operation system or the like. The application component catalog defines the way in which a user interacts with the application program . In particular the invention includes a plurality of application component catalogs such as application component catalog through N. The application component catalog defines the actions supported for each type of data and the business logic associated with each supported action. In one example the application program has default user interface behavior that may be overridden or extended by adding entries into the application component catalog . The entries define an action state form or business logic to be associated with a particular user experience. Customization of the application component catalog in such a manner allows an application to be modified after deployment without having to rewrite the entire application.

The invention includes computer executable instructions software or the like e.g. executing on a server for connecting a requesting application to the application component catalog to select and activate a user interface experience. The software maps a user request to an action by selecting one or more experiences that apply to the user in a particular context. The server performs the action and returns data to the user . In one embodiment the server delivers business logic e.g. a script applet to the requesting application for execution by the requesting application to generate the requested data.

In one embodiment there is one application component catalog for the most basic form of the application and one application component catalog for each additional experience of the application. Attributes associated with each application component catalog define a base minimum experience for the application. Within an application component catalog multiple more specific experiences can be added to provide a more targeted experience for certain client application. An application component catalog can optionally inherit from another application component catalog. In one embodiment there may be about one hundred application component catalogs and about one hundred forms within each application component catalog . However the number of application component catalogs is not limited in any way. It can be expanded as necessary.

Referring again to an exemplary block diagram illustrates a client application program requesting data from the server e.g. a processor accessing the application component catalog . The system of includes a memory area or other computer readable medium storing the application component catalog . The application component catalog comprises a data structure representing a schema defining user experiences associated with various application programs. The user transmits a data request to the server via the application program . The data request e.g. sent as a uniform resource locator includes an application identifier identifying the requesting application program an action in the user interface of the requesting application program and a state of the user interface of the requesting application program . The application program comprises a server deployed client application in one embodiment communicating with the server over a network such as the Internet.

The memory area further comprises computer executable components for providing a user interface experience upon request. The components include a communications component a user mapping component an experience mapping component and a user interface mapping component . The communications component operates to receive a request for data from software. The received request identifies the user associated with the request. The received request has an action value and a state value. In one embodiment the application program is composed of a plurality of user interface components or modules. In such an embodiment the communications component receives the request from one of the plurality of user interface components or modules. The user mapping component identifies an application component catalog corresponding to the user . The application component catalog includes a plurality of user interface experiences. The experience mapping component identifies one of the plurality of user interface experiences in the identified application component catalog based on the software. The identified user interface experience has a plurality of forms associated therewith. The user interface mapping component identifies one of the plurality of forms in the identified user interface experience as a function of the action value and the state value. The communications component provides the identified form e.g. form to the software.

Referring next to an exemplary block diagram illustrates the structure of one of a plurality of application component catalogs such as application component catalog in . The application component catalog includes a plurality of experience fields such as experience field through A. Each experience field stores an experience value representing a user interface experience associated with an application program such as application program in . The application component catalog further includes a plurality of application element fields such as application element field through N and application element field through M respectively for each of the plurality of experience fields . Each of the plurality of application element fields stores an application element value representing an application element associated with the experience value stored in the experience field . The application component catalog further includes an element class field for each of the plurality of application element fields . As shown in application element field in experience field includes one or more element class fields such as element class field through element class field B. Similarly application element field N in experience field includes one or more element class fields such as element class field through element class field C. Application element field in experience field A includes one or more element class fields such as element class field through element class field D. Similarly application element field M in experience field A includes one or more element class fields such as element class field through element class field E. The element class field stores an element class value representing an action state or form associated with the application element value stored in the application element field . In one embodiment not shown the application component catalog further comprises a user scope field storing a property for determining if the application component catalog applies to the user.

Customization of the application component catalog is within the scope of the invention. For example the processor is further configured to execute computer executable instructions for receiving from the application program an element class value or application element value associated with the application program and storing the element class value or application element value respectively in the data structure. In one example a new form can be added to an application for a new item type by modifying the application component catalog to include an entry for that particular item type and the action being performed as shown below. In one embodiment the application component catalog is written in extensible markup language XML .

In one implementation an exemplary application component catalog includes one or more databases of elements or portions of an application that are to be applied contextually to present a user experience for a particular client application in a specific application scenario. The databases are XML files in one embodiment each located in a separate directory along with related active server page files e.g. ASPX local assemblies for controls and text resources.

Each application component catalog or application component catalog extensions may be scoped based on attributes of the requesting application and attributes of the user. Inheritance allows the administrator to base an application component catalog off another one if specific functionality is desired for a different set of users.

The Catalog element and BaseExperience attribute specify the base experience for this application component catalog . In one embodiment an optional attribute called InheritsFrom allows the application to be deployed with a default set of functionality and then augmented or have default functionality overridden by a custom pluggable component.

The Experience element has one or more client elements there within. The client element is the set of variables that maps a particular client of the application to a specific set of experiences within the application component catalog . It is possible to have multiple experiences per application component catalog as seen in this example. For example clients that identify themselves as being version 9 or greater and having a detectable installed extension that adds new capabilities get a different set of mappings for certain application elements. If no match exists in this more specific experience then the base experience mappings would apply.

The ApplicationElement is the predefined pluggable entry point to the application. In this example there is a pluggable point called Item and another called PreFormAction. In one example the Item pluggable point is a file name that refers to an aspx page which will be instantiated. In another example the PreFormAction is the name of a binary and a class name which implements a specified interface that allows the client to do certain processing of a request before activating an aspx page.

Referring next to an exemplary flow chart illustrates operation of a server performing user experience matching based on a request from a client application program. Prior to performing user experience matching the invention performs some initialization functions. When a user logs in the invention knows the client information and the application component catalogs or form mappings available for that user. At login time the invention builds a list of experiences available to the user so that at form lookup time the invention does not have to look at client information again. The invention the experiences e.g. a set of forms that are valid for the user and uses this information when making a lookup.

When an application is initialized the application component catalogs are loaded into memory and verified to be correct. Loading the application component catalogs includes parsing the catalogs resolving dependencies e.g. since an application component catalog can inherit from another one the invention validates inheritance references once the application component catalogs have been parsed throwing an exception if an application component catalog reference does not exist generating base experiences e.g. a sorted list of base experiences are used for quick matching of users to application component catalogs and sorting the application component catalog experiences.

In one embodiment the invention includes a computerized method for providing a user interface experience upon request. The computerized method includes receiving a request for data from software at . The received request identifies a user associated with the request. The method identifies an application component catalog as a function of the user at . The application component catalog includes a plurality of user interface experiences. The method further identifies one of the plurality of user interface experiences in the identified application component catalog as a function of the software at . The identified user interface experience has a plurality of application elements associated therewith. The method further includes identifying one of the plurality of application elements as a function of data in the request e.g. an action value and a state value at and providing the requested data via the identified application element at . In one embodiment one or more computer readable media have computer executable instructions for performing the computerized method illustrated in .

In a particular embodiment when a client connects to the application a lookup is done in the application component catalog to find the set of experiences that apply to that particular client s capabilities. During experience matching the invention looks for the most specific applicable application component catalog by looking at the base experience for each application component catalog. The most specific application component catalog will provide the richest client experience given the capabilities of the client. A collection that contains the base client experience mappings in the application component catalogs is pre sorted least specific to most specific to allow for binary searching. In the event of multiple matches an application component catalog that inherits from another one is more specific than one that does not inherit. If there are still multiple matches the first one is selected though other rules are within the scope of the invention.

The variables used from the client to do the matching include in one example application version platform and client extensions e.g. S MIME Control . The invention is not limited to these variables. The system is extensible to allow for additional criteria for experience matching. Once the experience matching is complete this information can be cached to allow for faster application element matching.

The following describes how to generate the list of matching experiences. Throughout the generation of this list a separate list of matching experience names is maintained.

After identifying the appropriate application component catalog the invention performs a lookup into the application component catalog with the following pieces of information application element element class action and state. The application component catalog lookup algorithm includes logic for certain variables having precedence over other ones and reverting to wildcard matches when no exact match exists.

After a successful lookup into the application component catalog the appropriate action is taken based on the returned value. In one example the mapping value is the file name of an ASPX page that will be instantiated by a runtime engine. The PreFormHandler is a class name that gets instantiated.

Referring next to an exemplary schema for an application component catalog of the invention is shown. The application component catalog is managed by a FormsCatalogManager class. At application startup the FormsCatalogManager is initialized and loads the application component catalogs from the file system. Calls to lookup forms are done via APIs exposed by the FormsCatalogManager and the FormsCatalog.

In the ClientControl class is an enumeration that makes up part of the definition of a client. The Experience class defines an experience and the application component catalog to which it belongs. In one embodiment a collection of these is held by every user and used every time a form lookup is done to prevent having to determine the set of valid forms for the user every time. The ClientMapping class provides a mapping of a Client to an Experience. This is used by the FormsCatalogManager and FormsCatalog to provide mappings of clients to forms catalogs and experiences. The FormsCatalogManager includes all the application component catalogs and all the logic for matching users with an application component catalog experiences and doing form lookups. The FormsCatalog is a hash table of all the forms application component catalogs keyed off of the application component catalog name. The value is a FormsCatalog object.

The computer typically has at least some form of computer readable media. Computer readable media which include both volatile and nonvolatile media removable and non removable media may be any available medium that may be accessed by computer . By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that may be used to store the desired information and that may be accessed by computer . Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Those skilled in the art are familiar with the modulated data signal which has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media are examples of communication media. Combinations of any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of removable and or non removable volatile and or nonvolatile memory. In the illustrated embodiment system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. For example illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media. also shows a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that may be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive and magnetic disk drive and optical disk drive are typically connected to the system bus by a non volatile memory interface such as interface .

The drives or other mass storage devices and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components may either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into computer through input devices or user interface selection devices such as a keyboard and a pointing device e.g. a mouse trackball pen or touch pad . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to processing unit through a user input interface that is coupled to system bus but may be connected by other interface and bus structures such as a parallel port game port or a Universal Serial Bus USB . A monitor or other type of display device is also connected to system bus via an interface such as a video interface . In addition to the monitor computers often include other peripheral output devices not shown such as a printer and speakers which may be connected through an output peripheral interface not shown .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. LAN and or WAN may be a wired network a wireless network a combination thereof and so on. Such networking environments are commonplace in offices enterprise wide computer networks intranets and global computer networks e.g. the Internet .

When used in a local area networking environment computer is connected to the LAN through a network interface or adapter . When used in a wide area networking environment computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in a remote memory storage device not shown . By way of example and not limitation illustrates remote application programs as residing on the memory device. The network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of computer are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described herein.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized however that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

Although described in connection with an exemplary computing system environment including computer the invention is operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An interface in the context of a software architecture includes a software module component code portion or other sequence of computer executable instructions. The interface includes for example a first module accessing a second module to perform computing tasks on behalf of the first module. The first and second modules include in one example application programming interfaces APIs such as provided by operating systems component object model COM interfaces e.g. for peer to peer application communication and extensible markup language metadata interchange format XMI interfaces e.g. for communication between web services .

The interface may be a tightly coupled synchronous implementation such as in Java 2 Platform Enterprise Edition J2EE COM or distributed COM DCOM examples. Alternatively or in addition the interface may be a loosely coupled asynchronous implementation such as in a web service e.g. using the simple object access protocol . In general the interface includes any combination of the following characteristics tightly coupled loosely coupled synchronous and asynchronous. Further the interface may conform to a standard protocol a proprietary protocol or any combination of standard and proprietary protocols.

The interfaces described herein may all be part of a single interface or may be implemented as separate interfaces or any combination therein. The interfaces may execute locally or remotely to provide functionality. Further the interfaces may include additional or less functionality than illustrated or described herein.

In operation computer executes computer executable instructions such as those illustrated in to implement the invention.

The following exemplary user scenarios further illustrate the invention. In one scenario User A uses her laptop and starts a browser to connect to a web mail client over an intranet. After authenticating User A s browser shows the Basic hypertext markup language HTML experience where User A can access mail and calendaring items and can browse through the address book. In another scenario User A uses a web kiosk to check for mail messages and upcoming meetings. When User A connects to the mail server User A is presented with a login screen that allows User A to choose the Basic or Premium experience and the starting page. User A types in credentials and selects an experience which is subsequently rendered to User A.

In still another scenario User A chooses an experience that best suits the browser on a wireless telephone. Alternatively experience selection may be performed automatically via the application component catalog when the client application identifies itself as a wireless phone based browser. In yet another scenario a service provider may host custom forms and a custom starting page. For example the electronic mail message form is replaced by a new form that integrates with a database on another server. When reading electronic mail messages from customers a preview pane and read note form display information integrated with live data from the database. The context menu for unmodified items also includes two new options Add sender to customer contacts which launches an application on the server with no additional UI and Add recipients to customer contacts which launches a custom form on the mail server.

The following flattened selection Table 1 below is created from the exemplary application component catalog shown above. A Catalog column and a Control column have been removed from Table 1 below for clarity.

The order of execution or performance of the methods illustrated and described herein is not essential unless otherwise specified. That is elements of the methods may be performed in any order unless otherwise specified and that the methods may include more or less elements than those disclosed herein. For example it is contemplated that executing or performing a particular element before contemporaneously with or after another element is within the scope of the invention.

When introducing elements of the present invention or the embodiment s thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

In view of the above it will be seen that the several objects of the invention are achieved and other advantageous results attained.

As various changes could be made in the above constructions products and methods without departing from the scope of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

Attributes of an exemplary application component catalog schema are shown below. The exemplary schema is written in extensible markup language XML path syntax.

Describes the application component catalog for purposes of the person viewing the application component catalog XML file. This name matches the folder in which the application component catalog XML document is located.

The relative path to the directory containing the application component catalog XML file and its Catalog Name value. Specifying this will allow an application component catalog in another directory to inherit an existing Experience.

The name of the base Experience for the application component catalog. All additional Experience s in this application component catalog are more specific than the specified base Experience.

If this application component catalog is inheriting from another application component catalog the BaseExperience specified in the parent Application component catalog is the BaseExperience for this application component catalog. In this case the BaseExperience attribute is ignored and all Experiences defined in this application component catalog should be as specific as or more specific than the BaseExperience of the parent application component catalog.

Node which describes the filter applied to scope the application experience to a particular browser client type.

Node used to scope the form application component catalog to a set of users based on attributes of their particular configuration. Limited to one property and value match per experience. This value is not inherited from a parent application component catalog if one exists. UserScope UserScope Provider Attribute String

Property name of user s object to retrieve and perform match. Forms application component catalog logic will need to add this to the list of attributes requested when a user connects to the application.

Value of property to perform match. Blank attributes are permitted. A missing Value attribute in a UserScope node indicates a null value meaning that in order to match the attribute should not exist on the user s object.

Rule to apply when comparing the UserScope Property of a user s object to the UserScope Value for a particular application component catalog.

This element is used in an application component catalog to define the experience for a particular set of clients. If this is the BaseExperience as specified in the Catalog BaseExperience then it defines the baseline set of clients and forms for the experience.

This element can also be used to extend or override a particular experience for a more specific client extension e.g. S MIME control is installed on the client or the browser supports additional features such as editing HTML.

Name of experience e.g. Premium XHTML . Should be unique for an application component catalog for the Catalog BaseExperience to function.

Node defining which Client application characteristics to use when attempting to provide a mapping to a form. The scope of the Client is the Experience in which it is contained. This element should appear before any ApplicationElement

Client operating system or device platform. One way to configure a wildcard match is to remove this attribute from a mapping.

Minimum application version for experience. Can be single number or complete version. One way to configure a wildcard match is to remove this attribute from a mapping. Any special client matching logic that needs to be done at a service pack or other level not defined in this spec should be handled outside the forms application component catalog. Experience Client MaximumVersion Attribute String Default wildcard Maximum application version for experience necessary to scope experience to earlier versions of a particular client application. Especially useful to scope exceptions or the set of forms that only render when a client extension such as the S MIME control is installed on the client. One way to configure a wildcard match is to remove this attribute from a mapping. Experience Client Control Attribute String Default wildcard Keyword for client controls that extend the browser application and allow for different user experience. Option for third party to enable new user experience by adding controls such as a new control to support digital rights management functionality or to use this to pick off keywords in the client identification information such as the User Agent string. ApplicationElement ApplicationElement Name Attribute String

Name of resource in resource libraries that describes the application element. If TextResource ResourceLibrary is defined then the string will be obtained from that resource library.

For example these strings will map to a localized resource akin to User Options Navigation Pane Forms Based Authentication Components 

Filename of third party library or .resx file that contains the resource identified by the value of TextResource

Node defining the set of associations to forms or controls of a particular application element class.

Class of item to match against the Item.Class property of an data item. One way to configure a wildcard match is to remove this attribute from a mapping.

URI stem of the image associated with the element class. This is not the icon used in views a separate mapping table should exist for that purpose.

Name of resource that describes the element class. If TextResource ResourceLibrary is defined then the string will be obtained from that resource library.

For example these strings will map to a localized resource akin to E mail message Meeting request Non delivery report 

Filename of third party library or .resx file that contains the resource identified by the value of TextResource

Name of the action available for a mapping. Case insensitive. One way to configure a wildcard match is to remove this attribute from a mapping.

Flags enumeration of state of item required to match for a mapping. Not used for generic workflow state. One way to configure a wildcard match is to remove this attribute from a mapping.

Name of form control or other component used to bind to render and present the appropriate user experience and application logic for a mapping. The form should be in the same directory structure as the application component catalog.

URI stem of the image associated with the mapping. In general this will be the icon presented in a context menu or toolbar associated with the element class.

For mapping status codes to user experience elements. This is the alternative to overloading Mapping State. Useful for error handling and forms based authentication scenarios.

Name of resource that describes the mapping action . If TextResource ResourceLibrary is defined then the string will be obtained from that resource library.

For example these strings will map to a localized resource akin to Post reply in this folder Create new message Configure Mobile Browse settings 

Filename of third party library or .resx file that contains the resource identified by the value of TextResource

The purpose of this API is to determine which application component catalog should be used for the duration of the session. This will cut down on the time it takes to do a form lookup later on.

If a user can not be mapped to at least one user experience then the user will be redirected to the error form with appropriated information.

The FormsCatalog stores information about the experiences within it inherited application component catalog. When a user logs in the first thing that is done is to find which FormsCatalog the user will use for the duration of their session. Within that forms application component catalog we also want to know which specific experiences apply to that user. We can look this information up at login time then cache it on the user context object so that we don t have to lookup this information for every request.

List of all the forms in the application component catalog keyed off of FormKey. The value in the hash table is the name of the form e.g. foo.aspx 

This returns a unique list of all the experiences the provided information matches. The results will be ordered most specific to least specific.

