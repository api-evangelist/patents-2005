---

title: Node-to-node communication pipelines
abstract: Node-to-node communication pipelines may include code modules that are configured and assembled across a protocol according to dynamically input module-specific parameters. The parameters may be input to a service into which the modules are registered, and one or more appropriate pipelines may be dynamically assembled.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07634578&OS=07634578&RS=07634578
owner: Microsoft Corporation
number: 07634578
owner_city: Redmond
owner_country: US
publication_date: 20050714
---
Applications programs functions and other assemblage of programmable and executable code may be modularized. That is code associated with the aforementioned assemblies may be divided into code modules that may be independently generated and regenerated i.e. new versions generated by different parties and at different times. Examples of such code modules include add ins which may be added into an application at runtime by an end user.

At runtime such code modules may become interrelated or such an interrelationship may be otherwise revealed. However runtime may also reveal versioning and or compatibility issues exist among the code modules. Versioning issues may refer to changes made to one or more portions of the aforementioned generated and add in applications programs functions and other assemblages of programmable and executable code and compatibility issues may arise due to even subtle changes in any portion thereof.

More particularly the example implementations described herein relate to node to node communication pipelines that include code modules that may be configured and assembled according to dynamically input module specific parameters. The parameters may be input to a service into which the modules are registered and one or more appropriate pipelines may be dynamically assembled.

More particularly dynamic node to node communication pipelines as described herein may relate to fixed stage node to node pipelines that may be assembled in variably specified orders. Further dynamic node to node communication pipelines may be implemented in one or more devices or nodes in a network environment whereby the node configuration may include a peer to peer configuration or a host to client configuration.

 Pipelines as described herein may include at least one or more node application programming interfaces hereafter API one or more adapters and at least one protocol. Such pipelines may include the aforementioned APIs adapters and protocols in varying quantities and combinations and need not necessarily include all of the aforementioned pipeline elements.

 API as described herein may refer to a set of routines used by an application program function and other assemblage of programmable and executable code to direct the performance of procedures therefore by a corresponding execution environment such as an operating system or runtime execution environment. Adapters as described herein may refer to modules or objects that are capable of communicatively adapting one API to another API and may be linked serially or via a protocol. Protocol as described herein may refer to a specification or contract through which objects of which an API is a non exclusive example may communicate.

Therefore as described herein a pipeline may further refer to a chain of code modules or objects that flow from a host API adapter to an add in API adapter via a protocol to thereby connect a first node application e.g. a host application to a second node application e.g. an add in application .

Client device may represent at least one of a variety of conventional computing devices including a desktop personal computer PC workstation mainframe computer Internet appliance set top box and gaming console. Client device may further represent at least one of any device that is capable of being associated with network by a wired and or wireless link including a mobile i.e. cellular telephone personal digital assistant PDA laptop computer etc. Further still client device may represent the client devices described above in various quantities and or combinations thereof. Other device may also be embodied by any of the above examples of client device .

Server device may represent any device that is capable of providing any of a variety of data and or functionality to client device or other device in accordance with at least one implementation of dynamic node to node communication pipelines . The data may be publicly available or alternatively restricted e.g. restricted to only certain users or only if an appropriate subscription or licensing fee is paid. Server device may be at least one of a network server an application server a blade server or any combination thereof. Typically server device may represent any device that may be a content source and client device may represent any device that may receive such content either via network or in an off line manner. However according to the example implementations described herein client device and server device may interchangeably be a sending node or a receiving node in network environment . Other device may also be embodied by any of the above examples of server device .

 Other device may represent any further device that is capable of implementing dynamic node to node communication pipelines according to one or more of the examples described herein. That is other device may represent any software enabled computing or processing device that is capable of implementing module initialization for an application program function or other assemblage of programmable and executable code in at least a managed execution environment. Thus other device may be a computing or processing device having at least one of an operating system an interpreter converter compiler or runtime execution environment implemented thereon. These examples are not intended to be limiting in any way and therefore should not be construed in that manner.

Network may represent any of a variety of conventional network topologies and types which may include wired and or wireless networks. Network may further utilize any of a variety of conventional network protocols including public and or proprietary protocols. Network may include for example the Internet as well at least portions of one or more local area networks also referred to individually as a LAN such as 802.11 system or on a larger scale a wide area network i.e. WAN or a personal area network i.e. PAN such as Bluetooth.

Computer architecture in at least one of devices and has typically been defined computing platforms in terms of hardware and software. Software for computing devices has been categorized into groups based on function which may include a hardware abstraction layer alternatively referred to as a HAL an operating system alternatively referred to as OS and applications.

A runtime execution environment may refer to an isolated space between an OS and an application in which the application may execute specific tasks on at least one of processing device or . More particularly a runtime execution environment may enhance the reliability of the execution of applications on a growing range of processing devices and including servers desktop computers laptop computers and mobile processing devices by providing a layer of abstraction and services for an application running on such processing devices and further providing the application with capabilities including memory management and configuration thereof.

A runtime execution environment may serve as at least one of an application programming and application execution platform. As an application programming platform a runtime execution environment may compile targeted applications which may be written in one of multiple computing languages into an intermediate language hereafter IL . IL is typically independent of the platform and the central processing unit hereafter CPU executes IL. In fact IL is a higher level language than many CPU machine languages. As an application execution platform a runtime execution environment may interpret compiled IL into native machine instructions. A runtime execution environment may utilize either an interpreter or a compiler e.g. just in time alternatively JIT compiler to execute such instructions. Regardless the native machine instructions may then be directly executed by the CPU. Since IL is CPU independent IL may execute on any CPU platform as long as the OS running on that CPU platform hosts an appropriate runtime execution environment. Examples of runtime environments to which implementation of dynamic node to node communication pipelines may pertain include Visual Basic runtime environment Java Virtual Machine runtime environment that is used to run e.g. Java routines or Common Language Runtime CLR to compile e.g. Microsoft .NET applications into machine language before executing a calling routine. However this listing of runtime environments provides examples only. The example implementations are not limited to just these managed execution environments. More particularly the example implementations are not just limited to managed execution environments for one or more examples may be implemented within testing environments and or unmanaged execution environments.

An application compiled into IL may be referred to as managed code and that is why a runtime execution environment may be alternatively referred to as a managed execution environment . It is noted that code that does not utilize a runtime execution environment to execute may be referred to as native code applications.

In at least one managed execution environment a unit of isolation or isolation construct for a process may be referred to as an application domain. Such terminology is provided as an example only. That is the example implementations described herein are not limited to application domains or even to managed execution environments as stated above but rather may be applied within various other isolation construct implementations in various execution environments.

Isolation constructs e.g. application domains may enable the code to be executed therein to be loaded from a specified source an isolation construct may be aborted independent of other such isolation constructs and processing within an isolation construct may be isolated so that a fault occurring therein does not affect other isolation constructs within the process. In other words the effects of processing within an isolation construct are not visible to concurrently running constructs until the overall process is made permanent. For the sake of consistency the discussion hereafter may refer to applications and processes both of which may encompass any one of at least software programs and applications either singularly or in combination.

According to at least one example implementation runtime execution environment may facilitate execution of managed code for a computing device platform. Managed code may be considered to be part of a core set of application development technologies and may further be regarded as an application program function or other assemblage of programmable and executable code that is compiled for execution in runtime execution environment to provide a corresponding service to the computing device platform. In addition runtime execution environment may translate managed code at an interpretive level into instructions that may be proxied and then executed by a processor. A framework for runtime execution environment also provides class libraries which may be regarded as software building blocks for managed applications.

Runtime execution environment may provide at least partial functionality that may otherwise be expected from a kernel which may or may not be lacking from a computing device platform depending upon resource constraints for the particular one of devices and see . Thus at least one example of runtime execution environment may implement the following input output hereafter I O routine management memory management compiling and service routine management. Thus runtime execution environment may include I O component compiler at least one memory management component service routine manager and execution component . These components which are to be described in further detail below are provided as examples which are not intended to be limiting to any particular implementation of runtime execution environment and no such inference should be made. Thus the components may be implemented in examples of runtime execution environment in various combinations and configurations thereof.

I O component of runtime execution environment may provide asynchronous access to data sources i.e. processor and peripherals associated with the computing device platform. More particularly I O component may provide runtime execution environment with robust system throughput and further streamline performance of code from which an I O request originates.

Compiler may refer to a module within runtime execution environment that may interpret compiled IL into native machine instructions for execution in runtime execution environment . Further in accordance with at least one example implementation of module initialization compiler may dynamically analyze for various purposes the behavior of code modules associated with an application program function or other assemblage of programmable and executable code that may be loaded into runtime execution environment . Such analysis may include determining a version and protocol compatibility of a compiled code module. Further still the analysis may be performed without touching or affecting an executable portion of the code modules. The analysis may be performed at compile time initial runtime or at any time thereafter during execution of an executable portion of the code modules.

Memory management component may be regarded as a garbage collector . Garbage collection may be regarded as a robust feature of managed code execution environments by which an object is automatically freed i.e. de allocated if an object is no longer used by any applications upon a sweep or scan of a memory heap. Further functions implemented by memory management component may include managing one or more contiguous blocks of finite volatile RAM i.e. memory heap storage or a set of contiguous blocks of memory amongst the tasks running on the computing device platform allocating memory to at least one application running on the computing device platform freeing at least portions of memory on request by at least one of the applications and preventing any of the applications from intrusively accessing memory space that has been allocated to any of the other applications.

Service routine manager may be included as at least a portion of an application support layer to provide services functionality for processors and peripherals. Example implementations of services associated with dynamic node to node communications pipelines may be managed by service routine manager though not exclusively. For example service routine manager may enable an application to register with a service modules including but not limited to API adapters and protocols. Further to such example implementations service routine manager may enable the configuration and assembly of node to node communication pipelines comprising various combinations of the adapters and protocols registered with the service based on parameters and constraints input to the service.

Execution component may enable execution of managed code for the computing device platform. More particularly with regard to implementation of dynamic peer to peer communication pipelines execution component may serve as an exemplary component within runtime execution environment that may determine one or more parameters including e.g. a protocol constraint to be satisfied by a dynamic node to node communication pipeline. Such parameters may be input to the service into which modules and protocols are registered as described above with regard to service routine manager . Further execution component may submit such parameters to a service for implementation .

More particularly example implementations of node to node communication pipeline may include a dynamically assembled succession of modules that communicatively connect two objects. Non limiting examples of such objects according to at least one implementation of pipeline include a host application and an add in application. Even more particularly node to node communication pipelines may enable inter protocol communication from one adapter to another.

Module may represent a host view object which may be regarded as an abstract interface or class of an API for a host application.

Module may represent at least one adapter that is capable of interfacing with module . That is module may adapt an API i.e. module of one node object for compatible communication with an API of another node object.

Module may represent a protocol referring to a specification or contract through which modules of which an API is a non exclusive example may communicate. Protocol may be rigidly defined and therefore invariant so that intra protocol modules may communicate with each other. According to at least one example implementation of pipeline protocol may represent any one of at least an inter execution environment protocol an inter isolation construct protocol i.e. within a particular execution environment crossing from one isolation construct to another an inter process protocol and an inter machine protocol. Accordingly protocol may represent a communication bridge e.g. isolation constructs processes and machines specifications for modules i.e. APIs . Module may represent at least one an adapter that is capable of interfacing with module . Module may adapt an API i.e. module of one node object for compatible communication with an API i.e. module of another node object.

Module may represent an add in view object. According to the present example module may be regarded as an abstract interface or class of an API for an add in application.

More particularly as a non limiting example the description of processing flow may refer to enabling compatible communication between multiple versions of module e.g. host view object and multiple versions of module e.g. add in view object .

Block may refer to at least one of service routine manager see a host application and an add in application registering multiple versions of modules and into service . That is service may have registered therein multiple adapters that may be capable of interfacing with one of module module or at least one other adapter module for interfacing with either module or module . As an example service may have registered therein multiple versions of host to protocol adapter module each of which may communicatively interface between a different version of module and a different protocol . Similarly service may also have registered therein multiple versions of protocol to add in adapter module each of which may communicatively interface between a different protocols and different versions of module .

Block therefore may further refer to at least one of service routine manager a host application and an add in application registering multiple protocols into service . The multiple protocols registered into service may be specified as constraints on communication between modules including for example an inter execution environment protocol e.g. between a managed execution environment and an unmanaged execution environment an inter isolation construct protocol an inter process protocol and an inter machine protocol.

Block may refer to at least one of a host application and an add in application specifying or otherwise defining parameters upon which one or more node to node communication pipelines are to be configured and assembled. For instance a host application may specify at least one host view module one or more constraints and at least one add in view module upon which one or more implementations of node to node communication pipeline are to be configured and assembled. The one or more constraints in conjunction with host view module and add in view module may be sufficient to identify an appropriate one of protocol . More likely though the host application may specify a partial combination of one or more of modules and as described above. Thus as an example block may more particularly refer to a host application specifying or otherwise defining one or more host view modules and a protocol upon which one or more node to node communication pipelines are to be configured and assembled.

Further to the parameters specified or defined for service at block one or more constraints may be specified for any of host view module protocol and add in view module upon which one or more implementations of node to node communication pipeline are to be configured and assembled. The constraints are parameters that may include any user defined property to be fulfilled by a protocol between the nodes on the node to node communication pipeline. For instance the constraints may specify or otherwise define permissions required to run and an isolation boundary to be supported by the specified or defined protocol on a configured and assembled implementation of node to node communication pipeline . Examples of such isolation boundary may refer to local boundaries shared isolation constructs private isolation constructs or other processes.

Service may include any one of a database registry and file system disposed in an execution environment corresponding to either of the host application or add in application. Alternatively service may be disposed in any device or network based location so long as service is accessible to configuring and assembling pipeline . As set forth above service may serve as a repository for registered modules parameters and constraints for configuring and assembling a multitude of implementations of node to node communication pipelines .

Block may refer to any one of compiler service routine manager or execution module either singularly or in various combinations configuring and assembling one or more implementations of node to node communication pipeline . More particularly pipeline may be configured by chaining together combinations of one or more host to protocol adapters protocol and protocol to add in adapters as specified or otherwise defined by the parameters and any constraints input to service at block .

As described so far with regard to the example of processing flow a three stage pipeline may be configured and assembled at block . However particularly in view of the multitude of possible versions of host view object and add in view object alternative implementations of node to node communication pipelines may contemplate one or more host to protocol adapters or one or more protocol to add in adapter . Thus hundreds of permutations of three stage or four stage pipelines may be contemplated. Although the present implementations may support five or more stage pipelines the number of potential permutations based on modules registered and parameters and constraints specified may increase exponentially. So while possible the resource consumption required by such pipelines may weigh against such implementations.

Block may refer to service routine manager or execution module either singularly or in various combinations activating one or more of pipelines configured and assembled at block . More particularly when host view object determines that at least one implementation of node to node communication pipeline satisfies the parameters and any constraints specified or otherwise defined for service an isolation boundary may be created for communication processing over pipeline . Such isolation boundary may include a separate isolation construct i.e. application domain or process.

Upon activation the modules of pipelines may be loaded. That is metadata representative of the modules that have been retrieved from service may be loaded. Such load deferral may be considered to be a security measure since add ins may be provided by a third party and therefore a layer of trust may be missing.

By the description above pertaining to module initialization for a runtime execution environment may be configured in accordance with data associated with executable code loaded therein. However the example implementations described herein are not limited to just the environment of the components of or the process of . Module initialization see may be implemented by various combinations of the components described with reference to as well as in various orders of the blocks described with reference to .

Further the computer environment for any of the examples and implementations described above may include a computing device having for example one or more processors or processing units a system memory and a system bus to couple various system components.

The computing device may include a variety of computer readable media including both volatile and non volatile media removable and non removable media. The system memory may include computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM or flash RAM. It is appreciated that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage random access memories RAM read only memories ROM electric erasable programmable read only memory EEPROM and the like can also be utilized to implement the example computing system and environment.

Reference has been made throughout this specification to an example alternative examples at least one example an implementation or an example implementation meaning that a particular described feature structure or characteristic is included in at least one implementation of the present invention. Thus usage of such phrases may refer to more than just one implementation. Furthermore the described features structures or characteristics may be combined in any suitable manner in one or more implementations.

One skilled in the relevant art may recognize however that code module initialization may be implemented without one or more of the specific details or with other methods resources materials etc. In other instances well known structures resources or operations have not been shown or described in detail merely to avoid obscuring aspects of the invention.

While example implementations and applications of the code module initialization have been illustrated and described it is to be understood that the invention is not limited to the precise configuration and resources described above. Various modifications changes and variations apparent to those skilled in the art may be made in the arrangement operation and details of the methods and systems of the present invention disclosed herein without departing from the scope of the invention as both described above and claimed below.

