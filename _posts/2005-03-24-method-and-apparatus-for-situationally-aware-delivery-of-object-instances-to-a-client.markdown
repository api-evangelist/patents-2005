---

title: Method and apparatus for situationally aware delivery of object instances to a client
abstract: A situation object instantiator (SOI) receives a request from a client including a typekey. Available situations are retrieved. For a retrieved situation, a call to an evaluator is made. If the situation is active a check is made to see if an instantiator exists for the typekey and situation. If so, the object instantiator is called, it returns an instance to the SOI, and the SOI returns the instance to the client. If not, more situations are retrieved until the situations are exhausted, and such is communicated to the client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07984418&OS=07984418&RS=07984418
owner: International Business Machines Corporation
number: 07984418
owner_city: Armonk
owner_country: US
publication_date: 20050324
---
The present invention relates to code maintainability within an object oriented environment and more specifically the present invention relates to creating instances of code which may be executable based on an apparent database of situations that may be applicable to the function of a program code of a client.

Dynamic software systems such as those commonly used in object oriented programming may need to deal with fairly ad hoc arrangements of hardware and operating systems among other things. Thus a well defined class of objects may accomplish essentially the same function in instances specific to each of several situations. A specialization is an implementation of a software component designed for a specific focused case or situation. For example for a class the general that accomplishes a rendition of text in a string there may be a situation where the only display available is a graphical user interface with an active window allocated to producing text. Another situation may be a simple line based terminal. Still another situation could be a speaker connected to a voice synthesis device.

Under such circumstances to make the class able to handle rendering the string under all situations the existing methods would for example provide a number of alternative tracts of code within interpreted or machine executable software. This existing method created the problem that the complexity of program code became rather cluttered and often lead to duplicating code throughout the software system. Often this would increase the costs of maintaining such code e.g. as would become necessary when a new form factor for display emerged among manufactured devices.

Thus it became evident that there is a need for a software system to identify a software component in a flexible manner without unnecessary redundancy of code.

The present invention provides a method apparatus and computer program product for creating an instantiation that is responsive to the specific situation that a code is executing in is disclosed. First a request is received form the client with some uniquely defined key that corresponds to one program function. The key may have one or more situations for which code exists or for which a class may be is sufficiently well defined to create code or an instance and each situation may be looked up up to a point. A determination is made that a situation is active or inactive with respect to the client s running code. In case the given situation is active it is further determined if an object instantiator exists that can provide an instance for the situation and key or typekey . If so an object is requested from the object instantiator and finally delivered to the client for execution.

An embodiment of the invention may within the confines of a software system identify a software component in a flexible manner without unnecessary redundancy of code.

With reference now to the figures and in particular with reference to a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. A computer is depicted which includes system unit video display terminal keyboard storage devices which may include floppy drives and other types of permanent and removable storage media and mouse . Additional input devices may be included with personal computer such as for example a joystick touchpad touch screen trackball microphone and the like. Computer can be implemented using any suitable computer such as an IBM eServer computer or IntelliStation computer which are products of International Business Machines Corporation located in Armonk N.Y. Although the depicted representation shows a computer other embodiments of the present invention may be implemented in other types of data processing systems such as a network computer. Computer also preferably includes a graphical user interface GUI that may be implemented by means of systems software residing in computer readable media in operation within computer .

With reference now to a block diagram of a data processing system is shown in which the present invention may be implemented. Data processing system is an example of a computer such as computer in in which code or instructions implementing the processes of the present invention may be located. Data processing system employs a peripheral component interconnect PCI local bus architecture. Although the depicted example employs a PCI bus other bus architectures such as Accelerated Graphics Port AGP and Industry Standard Architecture ISA may be used. Processor and main memory are connected to PCI local bus through PCI bridge . PCI bridge also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus may be made through direct component interconnection or through add in connectors. In the depicted example local area network LAN adapter small computer system interface SCSI host bus adapter and expansion bus interface are connected to PCI local bus by direct component connection. In contrast audio adapter graphics adapter and audio video adapter are connected to PCI local bus by add in boards inserted into expansion slots. Expansion bus interface provides a connection for a keyboard and mouse adapter modem and additional memory . SCSI host bus adapter provides a connection for hard disk drive tape drive and CD ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add in connectors.

An operating system runs on processor and is used to coordinate and provide control of various components within data processing system in . The operating system may be a commercially available operating system such as WINDOWS XP which is available from Microsoft Corporation. An object oriented programming system such as JAVA may run in conjunction with the operating system and provides calls to the operating system from JAVA programs or applications executing on data processing system . JAVA is a trademark of Sun Microsystems Inc. Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as hard disk drive and may be loaded into main memory for execution by processor .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash read only memory ROM equivalent nonvolatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the present invention may be applied to a multiprocessor data processing system.

For example data processing system if optionally configured as a network computer may not include SCSI host bus adapter hard disk drive tape drive and CD ROM . In that case the computer to be properly called a client computer includes some type of network communication interface such as LAN adapter modem or the like. As another example data processing system may be a stand alone system configured to be bootable without relying on some type of network communication interface whether or not data processing system comprises some type of network communication interface. As a further example data processing system may be a personal digital assistant PDA which is configured with ROM and or flash ROM to provide non volatile memory for storing operating system files and or user generated data.

The depicted example in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system also may be a kiosk or a Web appliance. The processes of the present invention are performed by processor using computer implemented instructions which may be located in a memory such as for example main memory memory or in one or more peripheral devices .

With reference now to a block diagram illustrates the relationship of software components operating within a computer system that may implement the present invention. JAVA based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. JVM is one software application that may execute in conjunction with the operating system. JVM provides a JAVA run time environment with the ability to execute JAVA application or applet which is a program servlet or software component written in the JAVA programming language. The computer system in which JVM operates may be similar to data processing system or computer described above. However JVM may be implemented in dedicated hardware on a so called JAVA chip JAVA on silicon or JAVA processor with an embedded pico JAVA core.

At the center of a JAVA run time environment is the JVM which supports all aspects of JAVA s environment including its architecture security features mobility across networks and platform independence.

The JVM is a virtual computer i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example all JVMs must execute JAVA bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.

The JVM is the name of a virtual computer component that actually executes JAVA programs. JAVA programs are not run directly by the central processor but instead by the JVM which is itself a piece of software running on the processor. The JVM allows JAVA programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. JAVA programs are compiled for the JVM. In this manner JAVA is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating systems architectures. To enable a JAVA application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format the compiled code is executable on many processors given the presence of the JAVA run time system. The JAVA compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the JAVA compiler and executed by a JAVA interpreter. A JAVA interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecodes may be translated into native code by a just in time compiler or JIT.

A JVM loads class files and executes the bytecodes within them. The class files are loaded by a class loader in the JVM. The class loader loads class files from an application and the class files from the JAVA application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is a just in time compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the JAVA bytecodes are executed natively. JVMs usually interpret bytecodes but JVMs may also use other techniques such as just in time compiling to execute bytecodes.

When an application is executed on a JVM that is implemented in software on a platform specific operating system a JAVA application may interact with the host operating system by invoking native methods. A JAVA method is written in the JAVA language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.

With reference now to a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM includes class loader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. JVM also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine may be for example JAVA interpreter or just in time compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example the JAVA Native Interface JNI .

Runtime data areas contain native method stacks JAVA stacks Program Counter PC registers method area and heap . These different data areas represent the organization of memory needed by JVM to execute a program.

JAVA stacks are used to store the state of JAVA method invocations. When a new thread is launched the JVM creates a new JAVA stack for the thread. The JVM performs only two operations directly on JAVA stacks it pushes and pops frames. A thread s JAVA stack stores the state of JAVA method invocations for the thread. The state of a JAVA method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. JAVA stacks are composed of stack frames. A stack frame contains the state of a single JAVA method invocation. When a thread invokes a method the JVM pushes a new frame onto the JAVA stack of the thread. When the method completes the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values any JAVA instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the JAVA instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and JAVA stack. If the thread is executing a JVM method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined.

Native method stacks stores the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some JVM implementations native method stacks and JAVA stacks are combined.

Method area contains class data while heap contains all instantiated objects. The constant pool is located in method area in these examples. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap each of which is shared by all threads running inside the JVM such as JVM . When JVM loads a class file it parses information about a type from the binary data contained in the class file. JVM places this type of information into the method area. Each time a class instance or array is created the memory for the new object is allocated from heap . JVM includes an instruction that allocates memory space within the memory for heap but includes no instruction for freeing that space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

The following definitions will be used in the description of the steps used by an embodiment of the present invention.

Active means the external or internal factors and conditions which define the Situation are evaluated to be present or true. For example two execution paths may exist for an application which runs headless or in a graphical mode. Depending on the code path executed or the entry point of the program code the Evaluator could determine if the code path relevant to it was followed. Another way to detect that a situation is active is to look for specific classes to be available in the environment. Another way in the context of checking for a Console or GUI an embodiment of the invention may check to see if a graphical window is open or not. If no window is open then it must be the console or headless situation is active.

A Class is a combination of methods and data that are encapsulated in a file that defines how data are stored and accessed. A class may form a template by which instances of running code may be created or instantiated.

A client is an executing program that relies on other entities or software to access or process data for the client. In some cases the data to be processed may be a fully qualified class name and the result returned may be an instance itself software.

A code object is code that may be interpreted JVM compiled i.e. bytecodes or machine language. It may be an example of a class once instantiated for a specific purpose.

A key may be a fully qualified class name and sometimes is called a typekey. Alternatively a key may be a client defined value.

Object Instantiator or ObjectInstantiator is a program or class that creates and instance of an object. The object created by the Object Instantiator conforms to the concept of an object as defined by Object Oriented Programming OOP but in general will be an encapsulated representation of actions and data which may or may not inherit from or allow its action and data to be inherited by other objects. The concept of ObjectInstantiator includes object creator or ObjectCreator.

A server is an executing program that acts as a resource to a client. The server may execute on a common computer with the client or operate on a different computer. The server executes code to provide an output direct to the client or produce an output or action of the computer or other resources of the server.

A situation is any set of factors external or internal to program code that affects how the program code executes at a given moment and includes 

So long as there are varying levels of priorities for each situation multiple situations may be active simultaneously. However in the context where there are no variations in priority each situation however defined cannot be active simultaneously with other situations defined by the known situations stored within the SituationalObjectInstantiator. For example a console interface cannot be active simultaneously as the GUI interface for the client in cases where console interface and GUI interface have an identical priority.

As a point of nomenclature for readability purposes objects may be capitalized with a first letter or intermediate letter to improve readability. Thus for example SitutationalObjectInstantiator is the same as situtationalobjectinstantiator.

A preferred embodiment shows a computer program product for creating an instantiation that is responsive to the specific situation that a code is executing. Only the active situation or the situation having the highest priority is used to select an objectinstantiator.

However if the situations are exhausted before an active situation step is found or otherwise created processing continues to cause SOI to return a null to the client step .

An example of a typekey sometimes called a fully qualified class name may be Display which may be a software component that outputs a string using a device controlled by the client. The SOI may have a database of two situations Console a monochrome text oriented display or Graphical UI a more powerful color display having higher resolution and features for providing e.g. windows and dialog boxes. The situation may be this the client is enabled to operate only a Console and the Console is configured and active and the evaluator will indicate that is so. Thus an operation of the client requiring an instance from the SOI would proceed as follows 

Client makes a request providing a typekey that includes the string Display . SOI receives the request and looks at the first situation it can retrieve Graphical UI . The Graphical UI situation is retrieved in step and its details are provided to Evaluator step . Only the Situation is relevant to Evaluator the typekey will be relevant at the step of calling the ObjectInstantiator step if reached.

Prior to the call to ObjectInstantiator an Instantiator is determined to exist step . If the Instantiator is determined not to exist step operation continues to consider if there are more situations step . In some cases for a given typekey an Instantiator may exist for one situation and not exist for another situation.

Prior to a client requesting an object a client may execute a step of sending a definition of an ObjectInstantiator applicable to a key e.g. a typekey and optionally a situation. The SOI responds by receiving a definition and encapsulating such a definition within an ObjectInstantiator. During this step the client sends and the SitutationObjectInstantiator receives a definition of at least one new object. The definition or definitions may define or create at least one object definition for a subset of all situations applicable to a typekey.

Evaluator gives an inactive result to SOI step and more situations are looked up step . The Console situation is retrieved step . SOI calls Evaluator passing it a parameter that includes the string Console step . Evaluator shows the situation of Console is active step . SOI calls to ObjectInstantiator passing it the Console and the typekey Display step . ObjectInstantiator returns a code object or instance step to SOI. SOI further returns the code object step to the client. Client then has a code object to produce the desired effect on the devices that are attached.

The client may have prior access to the one or more ObjectInstantiators to define and add to the scope and extent of objects that may be created as compared to the universe of typekeys.

An absence of an available ObjectInstantiator at step may mean that a database if that is the implementation does not have the ObjectInstantiator defined for the current Situation.

The step of determining the next Situation step may operate in one of two ways. Either the step may examine all priorities of the set of available Situations and select the highest first until the final Situation selected is the one with the lowest priority. Alternatively the Situations may be stored such that retrieval step automatically is in an order of Situations priority.

It is important to note that while the present invention has been described in the context of a fully functioning data processing system those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable type media such as a floppy disk a hard disk drive a RAM CD ROMs DVD ROMs and transmission type media such as digital and analog communications links wired or wireless communications links using transmission forms such as for example radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. For example although the depicted embodiment is directed towards processing bytecodes in JAVA the processes of the present invention may be applied to other programming languages and environments that process instructions which are nonspecific to a computer on which the instructions are to be executed. In such a case a virtual machine on the computer may interpret the instructions or send the instructions to a compiler to generate code suitable for execution by the computer on which the virtual machine is located.

The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

