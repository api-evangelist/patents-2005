---

title: Method and system for coordinating device setting between a communications client and its host device
abstract: A system and method for propagating device settings to a data communications client from a host on a mobile device, the system having at least one host application adapted to operate on the mobile device host and further adapted to change device settings on the mobile device; a notification means adapted to notify the data communications client of device settings changes on the mobile device; a mode setting at the data communications client, the mode setting adapted to indicate whether client applications on the data communications client should use device settings from the host; and a client settings application adapted to receive a notification from the notification means and change device settings for the client applications if the mode setting indicates the client applications should use device settings from the host.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07603447&OS=07603447&RS=07603447
owner: Research In Motion Limited
number: 07603447
owner_city: Waterloo
owner_country: CA
publication_date: 20050726
---
The present application deals with the coordinating device setting between a data communications client and its host device in particular to the propagation of settings from the host to the data communications client when a client mode is set to adopt the host settings.

In a host wireless device it is sometimes desirable to add a client onto the host to perform functionality that the host normally would not include. The host is typically certified with its software and hardware to communicate over a wireless network whereas a client typically would not be. Further certification could occur prior to the client being added especially in the case that the client is integrated after market onto the wireless device.

It is further desirable that the client is able to communicate with the native applications on the host and that the host applications are able to communicate with client applications. This communication preferably includes controlling a user interface on the host device from a client application including registering inputs to the host device for the client application and displaying or outputting from the client application.

In some cases it is also desirable to be able to use device settings from the host environment in a client setting. Examples of this could include locale information time zones display themes date format time format or backgrounds. The automatic propagation of a change in host device setting would be preferable in some situations.

In one embodiment it is also desirable to have symbol inputs to a client correspond with symbol inputs to a host. It is further desirable that the input of symbols be simplified.

It is further desirable to be able to upgrade or downgrade the provisioning of a client directly from a host device without having to load new software on the host device.

The present system and method provides a divided architecture for integrating a client into a host wireless device. One key to the present system is that the host is recognized as the dominant determinant in a divided architecture due to the fact that device type certification efforts Global Certification Forum CGF PCS Type Certification Review Board PTCRB may happen prior to the client being integrated onto the host. This necessitates that the host and tightly tied applications to the host remain unfettered.

The present system and method provides a virtual machine that is started upon start up of the host device and is used to run client applications. The virtual machine communicates through a client OS that would normally send client application commands and functions to host dependent features such as hardware software firmware or communications networks. However since the host dependent features are certified and controlled by the host device the operating system instead communicates with abstraction layers. The abstraction layers have a native interface for communicating with host applications allowing client applications to use the host dependent features by utilizing host applications.

Device setting such as locale time zone display themes date format time format and backgrounds can be set using a binary variable. In one mode the client settings are adapted to automatically adjust when host device settings are changed. This change is propagated by either having a listener at the host to signal a change in device settings or polling when a graphical interface of a client is brought to the foreground. In the other mode the client settings can be fixed at the client and changes at the host device are ignored.

A client application accesses the user interface of a host device using a host native application a platform abstraction layer and a host independent engine communicating between the user interface and a client application. The host independent engine is platform independent and relies on the platform abstraction layer to translate and or map function calls. The host native application depends on the user interface and host device and is used to control actions and updates to the user interface.

One example of an input for the host native application is the input of symbols. In a system for inputting symbols to a client where the host has a native system for inputting symbols from a host symbol table by navigating a host cursor to move between adjacent symbols displayed within a host grid and the host further has a keyboard the keyboard can be taken advantage of to map symbols to one keystroke. A client symbol table is created conforming to the host symbol table and a grid is made where the indicia of at least one keyboard key is associated with a symbol such that when a user actuates a key in the keyboard the cursor jumps to the corresponding symbol.

Provisioning of the device can be accomplished from software that is already loaded onto the device. By following steps from a client application on a host device provisioning of the client can be changed. A host device user is thereby enabled to upgrade or downgrade client service i.e. to provision the data client

The present application therefore provides a system for propagating device settings to a data communications client from a host on a mobile device said system comprising at least one host application adapted to operate on the mobile device host and further adapted to change device settings on the mobile device a notification means adapted to notify the data communications client of device settings changes on the mobile device a mode setting at the data communications client said mode setting adapted to indicate whether client applications on the data communications client should use device settings from said host and a client settings application adapted to receive a notification from the notification means and change device settings for said client applications if said mode setting indicates said client applications should use device settings from said host.

The present application further provides a method for propagating device settings to a data communications client from a host on a mobile device said method comprising the steps of changing device settings on the mobile device using at least one host application notifying the data communications client of device settings changes on the mobile device checking a mode setting at the data communications client to determine whether device settings changed at the host should be propagated to the data communications client and if the checking step determines changes should be propagated changing device settings for said data communications client.

The present system and method is directed to a divided architecture for a client on a host device. One example of such an arrangement would be a data enabled cellular telephone with a data device client running on top of the host telephone environment. Other examples of clients running on host environments would however be known to those skilled the art and the above is not meant to limit the scope of the present method and system. The examples below will use a host that is a cellular telephone and a client that is a data device client merely for illustration purposes.

A host device will require certification prior to being released for sale and use in a given market. Examples of certification include GSF and PCS type certification review board PCTRB certifications. These certifications are for the hardware and tightly tied applications to this hardware.

In order to include a client that has communications capabilities without having to certify the client the integration of the client requires a divided architecture in which the phone and the tightly tied applications to the phone remain unaltered.

One example of an architecture to accomplish this is illustrated in . shows a method and system for a divided architecture which includes client applications running on top of a virtual machine .

Client applications can be any application that is designed to run on a virtual machine . In the example of these could include a messages application for viewing messages that have been received a contacts application which presents an address book including phone numbers e mail addresses or other contact information for individuals or companies calendar application for scheduling appointments and managing time a browser application for browsing the internet or other network a compose message application to compose messages for SMS or e mail a save messages application to view messages that have been saved a search messages application to search for a particular message a lock application to lock the keyboard and screen of the mobile device and a set up application to change the set up configuration for client . Other applications could also exist as part of client applications and the above listed applications are not meant to be limiting. Further other clients besides client could exist on the host device and these other clients could have applications which could be invoked from application .

Virtual machine is preferably started at power up of the host device and stays running no matter what. In one preferred embodiment the virtual machine is a JAVA virtual machine and client applications are JAVA applications.

All client applications use virtual machine to invoke instances of objects created by client applications .

A feature call such as a hardware call on system from client applications would normally go through client OS . Client OS includes a number of primitives for interacting with hardware. However in the case that client applications are built onto a host device and because the host device has acquired certification for its host dependent features such as hardware software and firmware it is preferable that instead of interacting with the features directly client OS interacts with a host abstraction layer . Host abstraction layer converts calls from client applications to host calls through a native interface . Native interface invokes host applications in order to use the host dependent features on the host device.

Because host applications invoke the features of the host device rather than client applications directly utilizing the features the above architecture provides that client applications can run on a host environment and use the features of the host device without having to re certify. This enables the client to be added to the host device after certification including an after market addition to the host device.

One example of a client application using the above includes the making of a telephone call when the host device is a cellular telephone. When in the host environment this simply involves using host applications to create the telephone call where these host applications use certified hardware firmware and software to connect through the wireless system. However when in a client application the above architecture requires the invoking of a host application in order to make the phone call. A client application could be an address book or contact application that includes phone numbers for individuals. A user may wish to select a phone number from the address book and have the wireless device phone that person. In order to accomplish this a user may select the phone number and select an option to phone that phone number. In this case contact application indicates through virtual machine to OS that it needs to make a phone call. Instead of using the host dependent feature directly from OS a notification is sent to host abstraction layer which through native interface invokes the correct host application to make the phone call. In the example of this would be phone application . Phone application then starts the phone call and the user proceeds as if the phone call was started from client application .

Similarly client application could give a user the option instead of phoning the phone number to use a short message service or a multi media message service to contact the individual. In each of these cases a different host application is invoked but this is done similarly through the host abstraction layer and native interface . In the example of these host applications include SMS application or MMS application .

An alternative example of a client application could be an e mail message that includes a phone number within it for example in messages application . Messages application could give a user the option to contact the phone number with the message. A phone related application short message service SMS application or multi media message service MMS application is started within host applications . This is done through the client OS to the host abstraction layer where the request is converted with a native interface for a host application .

As one skilled in the art will realize data is supplied between the applications and host applications . In the example above the phone number would be supplied to host application including phone application SMS application and MMS application .

It is further desirable that a client application can be activated from a host application . Reference is now made to . shows a screen capture of a host application. The host application lists a series of client applications that can be activated. As used herein activated can mean to both start a client application or to bring an already started client application to the foreground. In order to activate a client application the user scrolls to the client application that s he desires and selects the client application. Reference is made again to . When an application is selected in the host environment a client application selection application uses a set of application programming interfaces APIs by which the host operating system can request a client application to activate.

Client application selection application uses a client abstraction layer to activate an application within client applications . Client application selection application calls a function that is translated in client abstraction layer . Client abstraction layer then uses virtual machine to activate a client application .

Client abstraction layer in alternative embodiments can either inject the client OS event into virtual machine which causes the selected client application to become active or alternatively performs a reverse native call either through client OS or via client connect to manipulate the native representation of some client object which causes the selected client application to become active.

Client connect can be used for network features for client applications. This enables for example client to communicate using a specific protocol that was not originally supported on the host device. Client connect involves a protocol stack to perform this messaging and thereby increase and improve client functionality.

An example of the above is a client calendar application as illustrated in the screen capture or a client e mail application as illustrated in the screen capture . Requests for a client application to be activated are converted into function calls through native interface which in turn makes calls on client applications . These applications are then brought into the display foreground.

Alternatively client application selection application may communicate directly with virtual machine in order to activate a client application . This may occur for example in the case where client application selection application knows the code or a hook to start client application .

Once virtual machine receives a message to activate an application either from the client application selection application directly or through client abstraction layer a client application is activated and needs to assume control of the host user interface. In order to do this client application makes a call back to client application selection application indicating that client application needs the user interface. Client application selection application then uses host code to take over the UI and thus becomes a portal between client application and the host. Client application selection application adapts all of the host inputs to events for the client and takes over control of the user interface. Client application selection application is an uncertified embodiment of a host native application described in more detail below. As will be appreciated by one skilled in the art other embodiments could by certified.

If the host requires control of the user interface back client is notified through client application selection application of this.

It is further desirable when using a host and a client that the device settings be synchronized in certain situations. Device settings could include locale settings time zone settings date format settings time format settings or theme settings. Locale as described herein includes various settings such as the language of the interface for example English or French or Spanish. It could also include the keyboard configuration e.g. QWERTY AZERTY QWERTZ or DVORAK. Theme settings could include color patterns and background images.

In setup application referred in a user can choose between a mode that allows the user to use host settings for the device settings or custom settings. As one skilled in the art will appreciate a different mode setting could be used for theme locale and time zone or these could be all included in one mode setting.

If the mode is set to the host settings the device settings for the client are synchronized with the host s device settings. Any changes in the host s device settings are propagated to the client and the client s device settings are therefore also changed. For example if a user changes the language from French to English in a host application this is propagated to client and client applications will use English.

In the case where the client display is set to mimic the host display propagation of changes in the host display is accomplished by having a listener application monitoring the host device settings. Upon a change in the host device settings the host listener will notify setup application that a change has been made to the host device settings and this change will be reflected in the client device settings.

Alternatively propagation of a change in the device settings could include polling every time a graphical user interface from the client takes over. This polling involves comparing the host device settings with the client device settings and thereby determining if a change has been made. If a change has been made the client device settings are updated.

Thus if the mode is automatic or host settings changes in the host device settings are pushed to the client either through a listener or by polling as described above.

If conversely the mode is set to manual or client settings the user can update the device settings in the client and client applications will use these display setting instead of the host device settings. If the mode is set to client settings changes to the host s device settings will be ignored by client applications .

The above is better seen with reference to . A mobile device includes a data communications client on a host communication device having a certified portion for communications with the network. Host device includes host applications which include a device setting application allowing the user to change device settings. As described above these settings can be various things including time zone settings theme settings locale date formats time formats or other settings that the user may wish to have both on the host and the client side. For example the user may wish to use a 24 hour format rather than a 12 hour format for time display and may change this in device setting application .

As will be appreciated host applications run on a host operating system and the host device includes storage .

Once a user changes a device setting in device setting application this information is propagated to a device setting application located on data communications client . Device setting application would then propagate the change to the applications that the change affects. As will be appreciated by those skilled in the art the update step from device setting application may be a global message sent to all applications or may be sent to selected applications for example through a registration means where applications indicate to device setting application that they are interested in certain parameters. The change notification is sent through abstraction layer and native interface as described above and applications run on virtual machine .

In one embodiment the user has the option of telling the data communications client to ignore changes made on the host environment. In this case the user through settings user interface application indicates to the client that changes made on the host environment should be ignored. In this case device setting application will first check with settings user interface application to determine whether the change should be propagated to applications . As will be appreciated by those skilled in the art instead of device setting application checking with settings user interface application device settings application could check a flag which is persisted preferably in non volatile storage and indicates whether it should propagate the changes to applications and this flag could be set based on settings user interface application .

In order to propagate changes from host applications device setting application could send a message to device setting applications . This could be a periodic message or instigated whenever device setting applications is changed. Further a listener could be employed to monitor when device setting application changes are made in which case they will notify device setting application .

Based on the above changes made in the host applications can be reflected in client applications in order to provide a user with a consistent environment to operate in.

A further consideration for the above will be referred to herein as conflict resolution. In some instances device settings that may be set in the host environment may not have an equivalent in data communications client . For example if the user sets the device language to Swahili in the host environment using device setting application this would get propagated to device setting application . However device setting application may not have a Swahili language setting for applications . In this case a conflict resolution scenario needs to be employed.

A first option for conflict resolution is an automatic mapping. In this case the device will have a set of pre programmed options that are available at the host which are not also available at the data communications client . The list of exceptions further include alternatives that the data communications client should employ should the user select one of the non supported options on the host side. Thus for example if the user selects a language such as Swahili that the data communications client does not support device setting application may choose to proceed with English as the alternative language setting.

Alternatively device setting application may prompt the user for a decision when an unsupported option is selected at the host side. Using the above example if the user selects a language not supported by the data communications client device setting application may prompt the user for an alternative language for data communications client or may ask whether the alternative that the device setting application has chosen is suitable.

As will be appreciated by those skilled in the art exceptions will exist outside of language settings and may include for example time zone settings in certain parts of the world unsupported theme settings or other options known to those skilled in the art. The above is not meant to be limiting and the present application could include all of these conflict situations among others.

Reference is now made to . In order to interact with a user of a host device client applications need to provide a user interface . On a host device having one or more input devices such as a keypad keyboard roller wheel scrollstrip touch pad d pad or other navigation device and a screen a user must be able to input actions for client applications and the results of the input and client applications operations need to be displayed on the screen. In order to accomplish this three components are provided within the I O architecture of the present system. These are a host native application HNA platform abstraction layer PAL and a host independent engine HIE .

HIE is a platform independent component. Since PAL contains the host abstraction layer HAL and the client abstraction layer CAL translation between the client and the particular host is performed in it. In a preferred embodiment PAL is a C function interface.

HIE includes both virtual machine and client OS . These are used to activate start or call instances of objects in client applications when client is object oriented or call functions in client when it is not.

HNA resides beyond PAL and thus can adapt user interface to conform and adapt to a particular host on behalf of client applications . HNA can take radically different forms depending on the design of the host application infrastructure and the user interface requirements of the host operating system. For example it is envisaged that in alternate embodiments a keyboard and display user interface are required or alternatively a radically different voice only interface can be provided. HNA is responsible for creating the framework necessary to receive input and update output when a user brings a client application to the foreground. In a keyboard display embodiment this may involve creating windows buttons or graphics widgets of any kind. In a voice only host embodiment this may involve speech recognition and voice synthesis.

For input HNA is responsible for passing user actions to HIE through platform abstraction layer . Inputs can include button presses keystrokes stylus inputs roller wheel motions scrollstrip motions touch pad motions d pad motions voice commands accelerometer motions or other inputs that would be known to those skilled in the art. These inputs are translated and or mapped as received from the host operating system and fed through the input function of the platform abstraction layer .

For output HNA may receive screen updates from HIE at any time including when client application is not in the foreground. These updates must be stored and memory is used by HNA to maintain a complete frame buffer copy separate from the application display area. If HNA is in the foreground when receiving an update from HIE then the application display area must be updated as well as the frame buffer so that the display on the host device reflects the screen change immediately. Whenever HNA transitions into the foreground it must update the application display area with the complete contents of the frame buffer.

Other output types envisaged include audio tones voice and signals to actuate host specific features such as an offset motor or led for discrete notification or indication.

In a preferred embodiment HNA uses a framework that updates the user by simply displaying a graphic image provided by PAL and processes user actions by adapting them to be sent down as events to PAL . This greatly reduces the complexity of HNA thus enhancing the portability of the client to other host devices.

Reference is now made to which illustrate a specific example of how HNA adapts user actions and provides a user interface on behalf of client applications adapted to the semantics of a particular host.

First a system for symbolic input on a particular host is shown in . The system employs a particular semantic for symbolic input that the users of traditional application on the host will expect to be valid on all applications utilized on the host.

Operationally host graphical user interface element offers a 9 6 symbol table to a user. Cursor is moved along a 9 4 grid in order to select a symbol. Since the number of rows of the grid is smaller than that of the table the symbols are offered on two pages 

Referring now to the user may manipulate any number of input devices on a particular host including a keypad a 4 directional D pad rocker switches as well as a QWERTY keyboard provided in two portions a left keyboard portion L and a right keyboard portion R. Most notably the host semantics for symbolic input on this particular host require that cursor be moved on the grid by manipulating D pad to select a particular symbol.

In this particular example HNA preserves the semantics of symbolic input on the host while adapting actions a client application user is likely to desire for symbolic input given the data centric features of client applications .

Referring now to operationally client graphical user interface element offers a slightly different 9 6 symbol table on two pages wherein symbols can still be selected by operation of d pad thus preserving the host symbolic input semantics. Cursor is now moved however on a 9 3 grid instead of a 9 6 grid. This grid height is preferable in order to be able to map one row of each of the letter rows of the keyboard of to one of the symbol rows of the grid. The width of the grid is maintained the same as in the host graphical user element to allow a traditional host application user to quickly learn the layout of the symbol table while utilizing client applications and to continue to contemporaneously support the use of the d pad for selecting a symbol.

Thus a user is enabled to directly input one of 27 symbols using one keystroke instead of having to resort to using the d pad D while still accepting input using d pad D.

Note that the embodiments of deliberately do not use the right most key of the top row of a standard keyboard i.e. in the case of the embodiment of the key marked by the P indicia in right keyboard portion R since the topmost rows of the three standard keyboards shown herein contains 10 keys. This has been shown above to provide advantages and thus should not be considered a limitation. Nonetheless it is envisaged that the techniques taught herein could be adapted to other keyboard layouts and grid sizes on a per host basis by those of skill in the art and thus those adaptations are also within the scope of this application.

In alternate embodiments the unused keys can remain unutilized or they can be assigned a function to further enhance symbolic input such as toggling between the various symbol pages. It is also envisaged that toggling between symbol pages can be accomplished by use of any one of the many other keys available on the particular keyboard available on the host keyboard.

To summarize the example for input HNA adapts keystrokes by mapping each grid location on the 9 3 grid onto a key on the keyboard graphical user interface element shown as QWERTY AZERTY and QWERTZ variants in FIGS. and respectively. For output HNA enhances the display by showing the indicia of a corresponding alphabetic key directly below each symbol.

Referring to the drawings is a block diagram illustrating a host mobile station including preferred embodiments of the techniques of the present application. Mobile station is preferably a two way wireless communication device having at least voice and data communication capabilities. Mobile station preferably has the capability to communicate with other computer systems on the Internet. Depending on the exact functionality provided the wireless device may be referred to as a data messaging device a two way pager a wireless e mail device a cellular telephone with data messaging capabilities a wireless Internet appliance or a data communication device as examples.

Where mobile station is enabled for two way communication it will incorporate a communication subsystem including both a receiver and a transmitter as well as associated components such as one or more preferably embedded or internal antenna elements and local oscillators LOs and a processing module such as a digital signal processor DSP . As will be apparent to those skilled in the field of communications the particular design of the communication subsystem will be dependent upon the communication network in which the device is intended to operate. For example mobile station may include a communication subsystem designed to operate within the Mobitex mobile communication system the DataTAC mobile communication system GPRS network UMTS network EDGE network or CDMA network.

Network access requirements will also vary depending upon the type of network . For example in the Mobitex and DataTAC networks mobile station is registered on the network using a unique identification number associated with each mobile station. In UMTS and GPRS networks and in some CDMA networks however network access is associated with a subscriber or user of mobile station . A GPRS mobile station therefore requires a subscriber identity module SIM card in order to operate on a GPRS network and a RUIM in order to operate on some CDMA networks. Without a valid SIM RUIM card a GPRS UMTS CDMA mobile station may not be fully functional. Local or non network communication functions as well as legally required functions if any such as 911 emergency calling may be available but mobile station will be unable to carry out any other functions involving communications over the network . The SIM RUIM interface is normally similar to a card slot into which a SIM RUIM card can be inserted and ejected like a diskette or PCMCIA card. The SIM RUIM card can have approximately 64K of memory and hold many key configuration and other information such as identification and subscriber related information.

When required network registration or activation procedures have been completed mobile station may send and receive communication signals over the network . Signals received by antenna through communication network are input to receiver which may perform such common receiver functions as signal amplification frequency down conversion filtering channel selection and the like and in the example system shown in analog to digital A D conversion. A D conversion of a received signal allows more complex communication functions such as demodulation and decoding to be performed in the DSP . In a similar manner signals to be transmitted are processed including modulation and encoding for example by DSP and input to transmitter for digital to analog conversion frequency up conversion filtering amplification and transmission over the communication network via antenna . DSP not only processes communication signals but also provides for receiver and transmitter control. For example the gains applied to communication signals in receiver and transmitter may be adaptively controlled through automatic gain control algorithms implemented in DSP .

Network may further communicate with multiple systems not shown . For example network may communicate with both an enterprise system and a web client system in order to accommodate various clients with various service levels.

Mobile station preferably includes a microprocessor which controls the overall operation of the device. Communication functions including at least data and voice communications are performed through communication subsystem . Microprocessor also interacts with further device subsystems such as the display flash memory random access memory RAM auxiliary input output I O subsystems serial port keyboard speaker microphone a short range communications subsystem and any other device subsystems generally designated as .

Some of the subsystems shown in perform communication related functions whereas other subsystems may provide resident or on device functions. Notably some subsystems such as keyboard and display for example may be used for both communication related functions such as entering a text message for transmission over a communication network and device resident functions such as a calculator or task list.

Operating system software used by the microprocessor is preferably stored in a persistent store such as flash memory which may instead be a read only memory ROM or similar storage element not shown . Those skilled in the art will appreciate that the operating system specific device applications or parts thereof may be temporarily loaded into a volatile memory such as RAM . Received communication signals may also be stored in RAM .

As shown flash memory can be segregated into different areas for both computer programs and program data storage and . These different storage types indicate that each program can allocate a portion of flash memory for their own data storage requirements. Microprocessor in addition to its operating system functions preferably enables execution of software applications on the mobile station. A predetermined set of applications that control basic operations including at least data and voice communication applications for example will normally be installed on mobile station during manufacturing. A preferred software application may be a personal information manager PIM application having the ability to organize and manage data items relating to the user of the mobile station such as but not limited to e mail calendar events voice mails appointments and task items. Naturally one or more memory stores would be available on the mobile station to facilitate storage of PIM data items. Such PIM application would preferably have the ability to send and receive data items via the wireless network . In a preferred embodiment the PIM data items are seamlessly integrated synchronized and updated via the wireless network with the mobile station user s corresponding data items stored or associated with a host computer system. Further applications may also be loaded onto the mobile station through the network an auxiliary I O subsystem serial port short range communications subsystem or any other suitable subsystem and installed by a user in the RAM or preferably a non volatile store not shown for execution by the microprocessor . Such flexibility in application installation increases the functionality of the device and may provide enhanced on device functions communication related functions or both. For example secure communication applications may enable electronic commerce functions and other such financial transactions to be performed using the mobile station .

In a data communication mode a received signal such as a text message or web page download will be processed by the communication subsystem and input to the microprocessor which preferably further processes the received signal for output to the display or alternatively to an auxiliary I O device . A user of mobile station may also compose data items such as email messages for example using the keyboard which is preferably a complete alphanumeric keyboard or telephone type keypad in conjunction with the display and possibly an auxiliary I O device . Such composed items may then be transmitted over a communication network through the communication subsystem .

For voice communications overall operation of mobile station is similar except that received signals would preferably be output to a speaker and signals for transmission would be generated by a microphone . Alternative voice or audio I O subsystems such as a voice message recording subsystem may also be implemented on mobile station . Although voice or audio signal output is preferably accomplished primarily through the speaker display may also be used to provide an indication of the identity of a calling party the duration of a voice call or other voice call related information for example.

Serial port in would normally be implemented in a personal digital assistant PDA type mobile station for which synchronization with a user s desktop computer not shown may be desirable but is an optional device component. Such a port would enable a user to set preferences through an external device or software application and would extend the capabilities of mobile station by providing for information or software downloads to mobile station other than through a wireless communication network. The alternate download path may for example be used to load an encryption key onto the device through a direct and thus reliable and trusted connection to thereby enable secure device communication.

Other communications subsystems such as a short range communications subsystem is a further optional component which may provide for communication between mobile station and different systems or devices which need not necessarily be similar devices. For example the subsystem may include an infrared device and associated circuits and components or a Bluetooth communication module to provide for communication with similarly enabled systems and devices.

A mobile communications device such as a phone is typically formed of software firmware and hardware adapted to provide communications services over a wireless communications network. This process of forming the relationship between the mobile communications device and the service is known in the art as provisioning. Typically a network operator provisions the mobile via a subscription to a service contract. Thus once the mobile has been provisioned the user of the mobile is often referred to as a subscriber.

In a voice and data network such as GSM Global System for Mobile Communication and GPRS General Packet Radio System CDMA Code Division Multiple Access or various other third generation networks such as EDGE Enhanced Data rates for GSM Evolution or UMTS Universal Mobile Telecommunications Systems both voice and data services may be available to mobile communications devices. Example voice services include voice calling and Short Messaging Service SMS . Example data services include Internet browsing email and Multimedia Messaging Service MMS .

Although many services may be available on a given network only those subscribers that use mobile communications devices that have been provisioned for those services will be able to benefit from them. This may present problems for the subscriber and the network operator alike. On one hand the subscriber may desire an existing service he does not have i.e. an upgrade or desire disabling a service i.e. a downgrade. On the other hand the operator may want to offer a new service but may hesitate if subscribers cannot benefit from them.

One known solution is to provide an out of band communications link such as a Universal Serial Bus on the mobile communications device and enable the subscriber to load new software onto the mobile via the out of band communication link using a personal computer thus re provisioning the device. This may be an unacceptable solution to both the subscriber and the operator as there is a significant risk that the mobile by error receives a wrong or incomplete load and may require servicing. Furthermore this solution may be unacceptable to the subscriber who does not have access to a personal computer.

However since mobile station is a host communications device that hosts client client may be provisioned directly by a user of mobile station .

Thus the host device user is enabled to upgrade or downgrade client service i.e. to provision the data client.

The embodiments described herein are examples of structures systems or methods having elements corresponding to elements of the techniques of this application. This written description may enable those skilled in the art to make and use embodiments having alternative elements that likewise correspond to the elements of the techniques of this application. The intended scope of the techniques of this application thus includes other structures systems or methods that do not differ from the techniques of this application as described herein and further includes other structures systems or methods with insubstantial differences from the techniques of this application as described herein.

