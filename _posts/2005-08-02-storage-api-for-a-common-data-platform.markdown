---

title: Storage API for a common data platform
abstract: An application program interface (API) for a data platform. The API includes a generic data access component that exposes at least one of stores, sessions, transactions, and query services of the data platform, which data platform is associated with a data store. A data classes component of the API provides canonical, application-independent classes that expose types and relationships of a data model of the data platform. The API includes a domain data classes component of application-specific and framework-specific classes that expose domain-specific properties and behaviors of the data platform. The data platform can be a common data platform that interfaces to the data store to provide data services accessible by a plurality of disparate application frameworks, which data services allow a corresponding application of the different frameworks to access the data store.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07685561&OS=07685561&RS=07685561
owner: Microsoft Corporation
number: 07685561
owner_city: Redmond
owner_country: US
publication_date: 20050802
---
This application claims the benefit of U.S. Provisional Patent Application Ser. No. 60 657 522 entitled STORAGE API FOR A COMMON DATA PLATFORM and filed Feb. 28 2005. This application is related to U.S. Provisional Patent Application Ser. No. 60 657 556 entitled PLATFORM FOR DATA SERVICES ACROSS DISPARATE APPLICATION FRAMEWORKS and filed Feb. 28 2005 U.S. patent application Ser. No. 11 171 905 entitled PLATFORM FOR DATA SERVICES ACROSS DISPARATE APPLICATION FRAMEWORKS and filed Jun. 30 2005 U.S. Provisional Patent Application Ser. No. 60 657 295 entitled DATA MODEL FOR OBJECT RELATIONAL DATA filed on Feb. 28 2005 and U.S. patent application Ser. No. 11 228 731 entitled DATA MODEL FOR OBJECT RELATIONAL DATA and filed Sep. 16 2005. The entireties of the above noted application are incorporated by reference herein.

Data has become an important asset in almost every application whether it is a Line of Business LOB application framework utilized for browsing products and generating orders or a Personal Information Management PIM end user application used for scheduling a meeting between people. Applications perform both data access manipulation and data management operations on the application data. Typical application operations query a collection of data fetch the result set execute some application logic that changes the state of the data and finally persists the data to the storage medium.

Traditionally client server applications relegated the query and persistence actions to database management systems DBMS deployed in the data tier. If there is data centric logic it is coded as stored procedures in the database system. The database system operated on data in terms of tables and rows and the application in the application tier operated on the data in terms of programming language objects e.g. Classes and Structs . The mismatch in data manipulation services and mechanisms in the application and the data tiers was tolerable in the client server systems. However with the advent of the web technology and Service Oriented Architectures and with wider acceptance of application servers applications are becoming multi tier and more importantly data is now present in every tier.

In such tiered application architectures data is manipulated in multiple tiers. In addition with hardware advances in addressability and large memories more data is becoming memory resident. Applications are also dealing with different types of data such as objects files and XML eXtensible Markup Language data for example.

In such hardware and software environments the need for rich data access and manipulation services well integrated with the programming environments is increasing. One conventional implementation introduced to address the aforementioned problems is a data platform. The data platform provides a collection of services mechanisms for applications to access manipulate and manage data that is well integrated with the application programming environment. However such a conventional architecture falls short in many respects. Some key requirements for such a data platform include complex object modeling rich relationships the separation of logical and physical data abstractions query rich data model concepts active notifications better integration with middle tier infrastructure. Thus there is a substantial unmet need in the art for an improved data platform.

The following presents a simplified summary in order to provide a basic understanding of some aspects of the disclosed innovation. This summary is not an extensive overview and it is not intended to identify key critical elements or to delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.

The innovation disclosed and claimed herein in one aspect thereof comprises an application program interface API for a data platform. The API includes a generic data access component that exposes at least one of stores sessions transactions and query services of the data platform which data platform is associated with a data store. A data classes component of the API provides canonical application independent classes that expose types and relationships of a data model of the data platform. The API includes a domain data classes component of application specific and framework specific classes that expose domain specific properties and behaviors of the data platform. The data platform can be a common data platform that interfaces to the data store to provide data services accessible by a plurality of disparate application frameworks which data services allow a corresponding application of the different frameworks to access the data store.

In another aspect the API includes five core classes. A TableSet class can be generated from a data model schema and provides strongly typed access to tables defined within the schema. A StorageDomain class defines the store over which the rest of the classes operate. A StorageContext class provides a context for the session. The StorageContext class defines the scope for identity management change tracking and concurrency conflict handling with methods for refreshing or saving changes to objects within the current context. StorageSearcher classes are used to build composable object based queries against the data store. A StorageView class provides a rich application view over a set of results. StorageView classes support operations such as filtering sorting scrolling grouping sectioning expanding collapsing sections etc.

To the accomplishment of the foregoing and related ends certain illustrative aspects of the disclosed innovation are described herein in connection with the following description and the annexed drawings. These aspects are indicative however of but a few of the various ways in which the principles disclosed herein can be employed and is intended to include all such aspects and their equivalents. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings.

The innovation is now described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding thereof. It can be evident however that the innovation can be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate a description thereof.

As used in this application the terms component and system are intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component can be but is not limited to being a process running on a processor a processor a hard disk drive multiple storage drives of optical and or magnetic storage medium an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers.

While certain ways of displaying information to users are shown and described with respect to certain figures as screenshots those skilled in the relevant art will recognize that various other alternatives can be employed. The terms screen web page and page are generally used interchangeably herein. The pages or screens are stored and or transmitted as display descriptions as graphical user interfaces or by other methods of depicting information on a screen whether personal computer PDA mobile telephone or other suitable device for example where the layout and information or content to be displayed on the page is stored in memory database or another storage facility.

A novel common data platform CDP is comprised of a common data model CDM that describes objects and how they are related and a persistent store and services for working with in memory representations of those objects. The CDP provides an innovative platform for working with persistent data as application objects. The CDP includes a novel application programming interface API that is custom tailored to the underlying data model and services defined as part of the platform. The functionality of the CDP is exposed through a set of classes. The definition of those classes including their public members e.g. methods and properties comprises the API for working with the objects within the CDP.

Referring initially to the drawings illustrates a storage API of a data platform e.g. the CDP in accordance with an innovative aspect. The API provides the programming interface for applications using the data platform e.g. the CDP in the form of classes interfaces and static helper functions. Database programming language integration e.g. C sequence operators is also part of this API layer. In support thereof the API includes a CDM data classes component which is a set of canonical application independent classes that expose CDM concepts such as Entity Relationship Extension etc. A generic data access component is provided as part of the API to expose stores sessions transactions e.g. StorageContext query services e.g. StorageSearcher and CRUD services e.g. SaveChanges . CRUD Create Retrieve Update and Delete services are the basic processes that are applied to data. The API also includes a domain data classes component which are application framework specific classes such as Contact Message PurchaseOrders that conform to the CDM but expose domain specific properties and behaviors.

The storage API consists of the following core classes and illustrates the relationships between the StorageDomain StorageContext TableSet StorageSearcher and StorageView. Additional classes can be defined in support of these core classes.

TableSet A TableSet class can be generated from a data model schema and provides strongly typed access to tables defined within the schema. A TableSet instance wraps one or more StorageContext instances and uses the underlying StorageContext class and associated StorageDomain class for querying navigating and updating the objects. Additional methods can be added to the generated TableSet class for schema specific or framework specific functionality.

StorageDomain A class that defines the store over which the rest of the classes operate. Different types of stores implement their own specific StorageDomain classes. The StorageDomain may be used directly or in conjunction with a TableSet.

StorageContext A class that provides a context for the session. The StorageContext class defines the scope for identity management change tracking and concurrency conflict handling with methods for refreshing or saving changes to objects within the current context. The StorageContext class uses a StorageDomain class in order to communicate with the store for example in refreshing data or persisting changes . The StorageContext may be used directly or in conjunction with a TableSet.

StorageSearcher StorageSearcher classes are used to build composable object based queries against the data store. The StorageSearcher class generates a StorageExpression class which is executed by a StorageDomain typically within a StorageContext. The StorageSearcher supports enumerating results in a forward only streamed fashion or construction of a rich scrollable StorageView.

StorageView A StorageView class provides a rich application view over a set of results. StorageViews support operations such as filtering sorting scrolling grouping sectioning expanding collapsing sections etc.

Referring now to there is illustrated a methodology of providing a storage API for a data model. At a data platform e.g. a CDP is received for utilization over a data store. At an API is provided that includes base classes which represent CDM concepts such as for example entity relationship extension. Underlying functionality of the data platform can be exposed to overlying applications and application frameworks via common CDM data classes defined in the API of the subject invention. At a class is provided that defines the data store over which other API classes operate. At a class is provided which is used to build object based queries against the data store. At a class is provided that defines a session context and includes identity management change tracking conflict handling etc. At a class is provided that generates from a schema and provides typed access to tables of the schema. At a class is provided that facilitates a view of the result set s . At a set of domain specific classes are defined in order to represent the specific entities and relationships described by an instance of a CDM schema.

The following sections detail the class and member definitions that make up the API for a common data model.

StorageDomain Class. The StorageDomain class is used to encapsulate store information such as server authentication mapping and so forth. A base storage domain class is derived from for each type of store to provide store specific information. The base StorageDomain type can be defined as follows 

A WinFSDomain constructor can take information to specify the store and scope within the store for example through a UNC universal naming convention share name. Alternatively a default constructor can use default store information for example to the root of the default store. The UNC is a standard for identifying servers printers and other resources in a network which originated in the UNIX community. A UNC path uses double slashes or backslashes to precede the name of the computer.

SqlStorageDomain Class. An example of a StorageDomain against a relational store e.g. SQL database can look like the following 

The SqlStorageDomain constructor can take connection information for example in the form of a connection string containing connection and mapping information or a named configuration containing such information. Alternatively the constructor can take a connection object along with mapping information in the form of a mapping file or an object that implements a standard mapping interface. Alternatively a default constructor may use default connection or mapping information for example from a configuration file.

A TableSet is generally constructed with the name of the set of tables within the Schema. Alternatively the set of tables within the schema can be determined through an alternate mechanism for example through default naming a configuration file etc. A StorageContext can be provided to the TableSet in order to associate the TableSet with an existing StorageContext. Alternatively a StorageDomain can be provided to the TableSet to associate the TableSet with a StorageDomain. Alternatively still the TableSet can be provided a common state manager.

At a SaveChanges method can be provided to save the data objects associated with the table set. An asynchronous version of this method may also be provided. At a GetTable method can be provided for constructing and returning an object representing a table in schema e.g. a Table based on the name provided. At a GetTableSetReference method can be provided to return a TableSetReference.

A WinFSData constructor can be constructed with an existing StorageContext or may create a StorageContext using specified information such as a UNC share or default information for example the root of a default store . Additionally a tableset Name can be specified to associate the WinFSData class with a particular named tableset instance.

At a GetRootItem method can be provided to return the root of the domain. An asynchronous version of this method can also be provided. At a GetItemByPath method can be provided in order to return an item given its path. An asynchronous version of this method can also be provided.

At Items ItemExtensions and ItemFragments properties can be provided to return objects representing Items ItemExtensions and ItemFragments tables. At a Links property can be provided to return an object representing the Links table. At methods are provided for copying moving and deleting items. A CopyItem method can be provided to copy the specified item to another location within a store. A MoveItem method can be provided to move the specified item within a store. A DeleteItem method provides deletion of the specified item from a store. At methods are provided for importing and exporting items. An ExportItem method can be provided to export the specified item from a store. An ImportItem method can be provided to import the specified item into a store. Asynchronous versions of the CopyItem method MoveItem method DeleteItem method ExportItem method and ImportItem method can also be provided.

The Table class can be constructed with information that specifies the StorageContext or StorageDomain along with the name of the corresponding table in the schema. At a Context property can be provided in order to return the StorageContext associated with the Table class. At a Domain property can be provided in order to return the StorageDomain associated with the Table class. At a Searcher property can be exposed in order to return a StorageSearcher against the corresponding table in the store. At methods are provided for adding removing and clearing objects. An Add method can be exposed in order to add an object to the table. A Remove method can be exposed in order to specify an object to be removed from the table. A Clear method can be exposed in order to clear the table. At a Contains method can be exposed in order to return whether or not the table contains a specified object. At a Count method can be exposed in order to specify the total number of objects within the table. At a method is provided that copies objects into a table. At a property is provided that exposes if a table is read only. A CopyTo method can be exposed in order to copy the specified objects into the table. An IsReadOnly property can be exposed in order to return whether or not the table can be added to or removed from.

The StorageContext is constructed given a StorageDomain which provides store information. Alternatively a StorageContext can be constructed with no StorageDomain and obtain store information from a default source such as a configuration file.

At a method is provided that returns an object via a key. GetObjectByKey method can be provided to return the object within the StorageContext associated with a particular key. This method could alternatively be broken out into a separate StateManagement object. An asynchronous version of this method may also be provided. At a GetObjectKey method can be provided to return the key associated with a particular object within the StorageContext. This method can alternatively be broken out into a separate StateManagement object. At a SaveChanges method can be provided to save additions deletions or modifications to object within the StorageContext. An asynchronous version of this method may also be provided.

At a Refresh method can be provided to refresh the objects within the StorageContext with the current store values. An explicit set of objects to refresh can be specified for example through an enumerator or as parameters. Additional options can be specified to control how change conflicts are handled. An asynchronous version of this method can also be provided. At an Add method can be provided to associate a new object with the StorageContext. This method could alternatively be broken out into a separate StateManagement object. At a MarkForDeletion method can be provided to mark an object within the StorageContext to be deleted when SaveChanges is called. This method can alternatively be broken out into a separate StateManagement object. At a StorageDomain property can be provided to return the StorageDomain associated with the StorageContext.

A StorageSearcher can be constructed with a StorageContext or StorageDomain to specify the context or store to which the StorageSearcher is bound. Additionally a query expression can be specified to initialize a StorageSearcher either as a string or StorageExpression object tree.

At a Query method can be provided to construct a new StorageSearcher that encapsulates an arbitrary query expression. At filter methods are provided. A Filter method can be provided to construct a new StorageSearcher that encapsulates a filter over the query results that would be produced by the input searcher. A FilterByType method can be provided to construct a new StorageSearcher that encapsulates a filter over the query results that would be produced by the input searcher. A TreatAsType method can be provided to construct a new StorageSearcher that treats the query results that would be produced by the input searcher as a different type.

At Sort Project Group and Union methods are provided. A Sort method can be provided to construct a new StorageSearcher that encapsulates a sort of the query results that would be produced by the input searcher. A Project method can be provided to construct a new StorageSearcher that encapsulates a projection of the query results that would be produced by the input searcher. A Group method can be provided to construct a new StorageSearcher that encapsulates a grouping of the query results that would be produced by the input searcher. A Union method can be provided to construct a new StorageSearcher that encapsulates the union of the query results that would be produced by two input searchers. The above are only examples and are not to be construed as limiting. Additional methods can be provided on the StorageSearcher to represent additional query operations. In other words query operations can be exposed as methods on the StorageSearcher class that returns new StorageSearchers.

At a GetEnumerator method can be provided to return an enumerator that can be used to access query results. An asynchronous version of this method can also be provided. At methods are provided that return a first result of a query. Asynchronous versions of these methods can also be provided. A GetFirst method can be provided to return the first result. An asynchronous version of this method can also be provided. GetCount method can be provided to return a count of the results. An asynchronous version of this method can also be provided. At CreateView method can be provide to create a StorageView from the StorageSearcher query. The CreateView method may take a StorageViewDefinition with or without additional options to specify information specific to the view.

The StorageRecord class is used as the result type of a searcher when the query will return data that doesn t correspond to any particular application defined type. For example the result of a Project or Group operation is a collection of StorageRecord objects.

At a CopyDefinition method can be provided to create a new instance of the StorageViewDefinition. An ApplyDefinition method can be provided to apply the specified StorageViewDefinition to the current StorageView. An asynchronous version of this method may also be provided. At methods are provided for finding records returning record counts and a current record. A FindRecord method can be provided to find a StorageViewRecord within the current StorageView according to the specified filter relative to a specified position or bookmark. An asynchronous version of this method may also be provided. A Count method can be provided to return the number of records within the current StorageView. An asynchronous version of this method may also be provided. A Current method can be provided in order to return the current StorageViewRecord within the StorageView.

At an indexed accessor e.g. this can be provided in order to return the StorageViewRecord for a given Bookmark. An asynchronous version of this method may also be provided. At methods are provided for moving position and refreshing a view. A MoveCurrentPosition method can be provided in order to move the current position within the StorageView according to a specified position or bookmark and offset. An asynchronous version of this method may also be provided. A Refresh method can be provided in order to refresh the data within a static StorageView with the current values from the store. An asynchronous version of this method may also be provided. At methods are provided to get bookmarks and binary representation thereof. A GetBookmarkFromBinary method can be provided in order to get a bookmark from a persistent binary representation. A GetBinaryFromBookmark method can be provided in order to get a persistent binary representation from a Bookmark.

At methods are provided for expanding collapsing sections levels and fields. A CollapseAllSections method can be provided in order to collapse all sections defined within the StorageView. An asynchronous version of this method may also be provided. An ExpandAllSections method can be provided in order to expand all sections defined within the StorageView. An asynchronous version of this method may also be provided. An ExpandSectionLevel method can be provided in order to expand all sections up to and including the specified level. An asynchronous version of this method may also be provided.

At a method is provided for extending fields of records. A SetExtendedFields method can be provided in order to define extended fields associated with a set of StorageViewRecords. At methods are provided for saving and loading state of expanded sections. A LoadSectionExpandState method can be provided to load the state specifying the set of sections that are expanded. An asynchronous version of this method may also be provided. A SaveSectionExpandState method can be provided in order to save the state specifying the set of sections that are expanded. The StorageView may expose a ViewChanged event for notifying the listener when the StorageView has changed.

At a Sort property can be provided to get or set the sort criteria for the StorageView. At properties are provided for altering and expanding sections. A Sections property can be provided in order to alter the list of Sections defined within the StorageView. A SectionExpandLevel property can be provided in order to expand the sections up to and including the specified level. At a property and a method are provided for filtering operations. A Filter property can be exposed in order to filter the StorageView to expose only those StorageViewRecords matching the specified filter condition. A SetFilter method can be exposed in order to filter the StorageView to expose only those StorageViewRecords matching the specified filter condition using the specified parameters. At a property and a method are provided that limit exposed fields. A Fields property can be exposed in order to limit the fields exposed by the StorageView to those Fields specified. A Fields method can be exposed in order to limit the fields exposed by the StorageView to those Fields specified using the specified parameters.

At a collection is provided that lists parameters utilized by filter sort and sections. A Parameters collection can be exposed listing the parameters used by the filter sort and sections specifications. At a Boolean AutoRefresh property can be exposed in order to specify whether or not the StorageView is automatically kept in sync with changes to the store. At a PageSize property can be exposed in order specify the number of StorageViewRecords to be retrieved at a time from the store.

At an IsSectionRecord property can be exposed in order to return whether or not the StorageViewRecord represents a section header record in the StorageView. At properties are provided for section information. A SectionLevel property can be exposed in order to return the level of the StorageViewRecord within the StorageView. A SectionName property can be exposed in order to return the name of the section within the StorageView. An IsSectionExpanded property can be exposed in order to return whether or not the section is expanded. At a Bookmark property can be exposed in order to return a bookmark for the current StorageViewRecord. At a SetValueinRecord method can be exposed in order to set the value of the specified field within the StorageViewRecord. The field can be specified by name or by ordinal.

The StorageViewSection can be constructed specifying the field within a StorageView on which the section is being defined. A Field property can be exposed to return the field within the StorageView on which the section is defined. An AggregateFields property can be exposed in order to get or set the aggregates to calculate for the section. A Sort property can be exposed in order to specify an ordering for the StorageViewRecords within the section. A Having property can be exposed in order to restrict the StorageViewRecords according to the Aggregate fields specified. A SetHaving method can be exposed in order to restrict the StorageViewRecords according to the Aggregate fields specified along with a set of parameters.

A StorageCollection class is used to represent a strongly typed collection of objects whose population can be deferred. For example a StorageCollection can be used in a collection property of a parent object. The StorageCollection can be populated explicitly or implicitly when its content is accessed.

The StorageCollection can be constructed with information specifying the StorageContext or StorageDomain parent object and role associated with the StorageCollection for example if the StorageCollection represents the objects within a collection property of a parent object.

A Context property can be provided in order to return the StorageContext associated with the StorageCollection. A Domain property can be provided in order to return the StorageDomain associated with the StorageCollection. A Fill method can be provided in order to add objects to the collection. The fill method can take an IEnumerable or a StorageSearcher or can use the parent and role properties along with a StorageDomain or StorageContext in order to generate a request to populate the StorageCollection. An IsFilled property can be exposed in order to return whether or not the StorageCollection has been populated. A Reset method can be exposed in order to reset the StorageCollection.

A Searcher property can be exposed in order to return a StorageSearcher against the store corresponding to definition of the collection. A GetEnumerator method can be exposed in order to return an enumerator over the contents of the StorageCollection. An Add method can be exposed in order to add an object to the StorageCollection. A Remove method can be exposed in order to remove an object from the StorageCollection. A Clear method can be exposed in order to clear the StorageCollection. A Contains method can be exposed in order to return whether or not the StorageCollection contains a specified object instance. A Count method can be exposed in order to specify the total number of objects within the StorageCollection. A CopyTo method can be exposed in order to copy the specified objects into the StorageCollection. An IsReadOnly property can be exposed in order to return whether or not the StorageCollection can be added to or removed from.

The CDP runtime component is a layer that implements the various features exposed in the public API layer . It implements the common data model by providing object relational mapping and query mapping enforcing data model constraints etc. More specifically the CDP runtime includes a common data model component implementation a query processor component a sessions and transactions component an object cache which can include a session cache and an explicit cache a services component that includes change tracking conflict detection and eventing a cursors and rules component a business logic hosting component and a persistence and query engine which provides the core persistence and query services. Internal to persistence and query services are the object relational mappings including query update mappings. The CDP also includes the constraint security engine which provides for applying constraints against the data store and security policies for example role based security.

Referring now to there is illustrated a block diagram of a computer operable to execute the disclosed API architecture. In order to provide additional context for various aspects of the subject invention and the following discussion are intended to provide a brief general description of a suitable computing environment in which the various aspects of the invention can be implemented. While the invention has been described above in the general context of computer executable instructions that may run on one or more computers those skilled in the art will recognize that the invention also can be implemented in combination with other program modules and or as a combination of hardware and software.

Generally program modules include routines programs components data structures etc. that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations including single processor or multiprocessor computer systems minicomputers mainframe computers as well as personal computers hand held computing devices microprocessor based or programmable consumer electronics and the like each of which can be operatively coupled to one or more associated devices.

The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules can be located in both local and remote memory storage devices.

A computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer and includes both volatile and non volatile media removable and non removable media. By way of example and not limitation computer readable media can comprise computer storage media and communication media. Computer storage media includes both volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital video disk DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the computer.

Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

With reference again to the exemplary environment for implementing various aspects of the invention includes a computer the computer including a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various commercially available processors. Dual microprocessors and other multi processor architectures may also be employed as the processing unit .

The system bus can be any of several types of bus structure that may further interconnect to a memory bus with or without a memory controller a peripheral bus and a local bus using any of a variety of commercially available bus architectures. The system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS is stored in a non volatile memory such as ROM EPROM EEPROM which BIOS contains the basic routines that help to transfer information between elements within the computer such as during start up. The RAM can also include a high speed RAM such as static RAM for caching data.

The computer further includes an internal hard disk drive HDD e.g. EIDE SATA which internal hard disk drive may also be configured for external use in a suitable chassis not shown a magnetic floppy disk drive FDD e.g. to read from or write to a removable diskette and an optical disk drive e.g. reading a CD ROM disk or to read from or write to other high capacity optical media such as the DVD . The hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The interface for external drive implementations includes at least one or both of Universal Serial Bus USB and IEEE 1394 interface technologies. Other external drive connection technologies are within contemplation of the subject invention.

The drives and their associated computer readable media provide non volatile storage of data data structures computer executable instructions and so forth. For the computer the drives and media accommodate the storage of any data in a suitable digital format. Although the description of computer readable media above refers to a HDD a removable magnetic diskette and a removable optical media such as a CD or DVD it should be appreciated by those skilled in the art that other types of media which are readable by a computer such as zip drives magnetic cassettes flash memory cards cartridges and the like may also be used in the exemplary operating environment and further that any such media may contain computer executable instructions for performing the methods of the invention.

A number of program modules can be stored in the drives and RAM including an operating system one or more application programs other program modules and program data . All or portions of the operating system applications modules and or data can also be cached in the RAM . It is appreciated that the invention can be implemented with various commercially available operating systems or combinations of operating systems.

A user can enter commands and information into the computer through one or more wired wireless input devices e.g. a keyboard and a pointing device such as a mouse . Other input devices not shown may include a microphone an IR remote control a joystick a game pad a stylus pen touch screen or the like. These and other input devices are often connected to the processing unit through an input device interface that is coupled to the system bus but can be connected by other interfaces such as a parallel port an IEEE 1394 serial port a game port a USB port an IR interface etc.

A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor a computer typically includes other peripheral output devices not shown such as speakers printers etc.

The computer may operate in a networked environment using logical connections via wired and or wireless communications to one or more remote computers such as a remote computer s . The remote computer s can be a workstation a server computer a router a personal computer portable computer microprocessor based entertainment appliance a peer device or other common network node and typically includes many or all of the elements described relative to the computer although for purposes of brevity only a memory storage device is illustrated. The logical connections depicted include wired wireless connectivity to a local area network LAN and or larger networks e.g. a wide area network WAN . Such LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise wide computer networks such as intranets all of which may connect to a global communications network e.g. the Internet.

When used in a LAN networking environment the computer is connected to the local network through a wired and or wireless communication network interface or adapter . The adaptor may facilitate wired or wireless communication to the LAN which may also include a wireless access point disposed thereon for communicating with the wireless adaptor .

When used in a WAN networking environment the computer can include a modem or is connected to a communications server on the WAN or has other means for establishing communications over the WAN such as by way of the Internet. The modem which can be internal or external and a wired or wireless device is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computer or portions thereof can be stored in the remote memory storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.

The computer is operable to communicate with any wireless devices or entities operatively disposed in wireless communication e.g. a printer scanner desktop and or portable computer portable data assistant communications satellite any piece of equipment or location associated with a wirelessly detectable tag e.g. a kiosk news stand restroom and telephone. This includes at least Wi Fi and Bluetooth wireless technologies. Thus the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices.

Wi Fi or Wireless Fidelity allows connection to the Internet from a couch at home a bed in a hotel room or a conference room at work without wires. Wi Fi is a wireless technology similar to that used in a cell phone that enables such devices e.g. computers to send and receive data indoors and out anywhere within the range of a base station. Wi Fi networks use radio technologies called IEEE 802.11 a b g etc. to provide secure reliable fast wireless connectivity. A Wi Fi network can be used to connect computers to each other to the Internet and to wired networks which use IEEE 802.3 or Ethernet . Wi Fi networks operate in the unlicensed 2.4 and 5 GHz radio bands at an 11 Mbps 802.11a or 54 Mbps 802.11b data rate for example or with products that contain both bands dual band so the networks can provide real world performance similar to the basic 10BaseT wired Ethernet networks used in many offices.

Referring now to there is illustrated a schematic block diagram of an exemplary computing environment in accordance with the subject invention. The system includes one or more client s . The client s can be hardware and or software e.g. threads processes computing devices . The client s can house cookie s and or associated contextual information by employing the invention for example.

The system also includes one or more server s . The server s can also be hardware and or software e.g. threads processes computing devices . The servers can house threads to perform transformations by employing the invention for example. One possible communication between a client and a server can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and or associated contextual information for example. The system includes a communication framework e.g. a global communication network such as the Internet that can be employed to facilitate communications between the client s and the server s .

Communications can be facilitated via a wired including optical fiber and or wireless technology. The client s are operatively connected to one or more client data store s that can be employed to store information local to the client s e.g. cookie s and or associated contextual information . Similarly the server s are operatively connected to one or more server data store s that can be employed to store information local to the servers .

What has been described above includes examples of the disclosed innovation. It is of course not possible to describe every conceivable combination of components and or methodologies but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly the innovation is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims. Furthermore to the extent that the term includes is used in either the detailed description or the claims such term is intended to be inclusive in a manner similar to the term comprising as comprising is interpreted when employed as a transitional word in a claim.

