---

title: System and method for external override of annotations
abstract: A deployable application component can be configured via external annotation overrides at runtime without having to restart the component. An annotation/manifest can be populated to the corresponding application component at build time. The application component can then be configured and changes can be saved as annotation override into an external descriptor in XML format at deploy time. Such external descriptor can then be distributed, parsed, and validated at runtime to configure/update the deployed application component upon receiving notification of deployment changes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07607126&OS=07607126&RS=07607126
owner: BEA Systems, Inc.
number: 07607126
owner_city: San Jose
owner_country: US
publication_date: 20050520
---
This application claims priority from the following applications which are hereby incorporated by reference in their entireties 

U.S. Provisional Patent Application No. 60 573 747 entitled SYSTEM AND METHOD FOR CONTROLS by Kyle Marvin et al. filed May 21 2004.

This application is related to the following co pending applications which are each hereby incorporated by reference in their entirety 

U.S. application Ser. No. 11 041 588 entitled SYSTEMS AND METHODS FOR CONTROLS Inventor Kyle Marvin et al. filed Jan. 24 2005.

U.S. application Ser. No. 11 088 173 entitled SYSTEMS AND METHODS FOR DESCRIPTOR CLASSES Inventor Erick Halpern filed Mar. 23 2005.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

This invention relates to the field of external override of annotations on a software component such as control.

An enterprise application component deployable at runtime such as control can support a set of properties associated with it and corresponding configuration mechanisms to operate on the properties. Here the application component can be but is not limited to a Java bean an enterprise Java bean EJB a class a J2EE module and other suitable concepts based on Java C C and other suitable object oriented programming language. The properties of the component can be configured via annotations manifest which describes the invariant state of a plurality of annotations on the fields types and methods of the component set at the build design time. Since such annotations configuration values may reflect configuration that is specific to a targeted deployment environment of the component they may need to be overridden revised externally at runtime and it is desirable that such annotation override will not require 1 modifying the application component or its packaging and 2 re start re deploy the application component.

The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to an or one or some embodiment s in this disclosure are not necessarily to the same embodiment and such references mean at least one.

Various embodiments of the present invention provide an external configuration framework that supports the external override of annotations attribute property definitions used to extend configure an application component at deployment runtime. Such external override of annotations may include steps to identify those annotations that can be overridden represent those annotations and their constraints for an instance of an application module via a persistent file such as XML include those annotations as an extension to the standard JSR88 configuration process and integrate the overridden values into an application module at runtime. It does not require change to the source code of the component or the re start or re deployment of the component. A console which can be an Integrated Design Environment IDE or an administrative tooling environment such as Jython scripting or other web based administrative application can also be used so that defining and configuring of the annotation overrides can be a property or wizard driven process and the definition of customized and pre configured views operations can be managed transparently on behalf of the client.

In some embodiments the external configuration framework can be implemented in Java programming language based on Java beans in accordance with standard configuration process such as JSR88 and the metadata annotations can be defined based on the extensible model of JSR 175 annotations and an external configuration file in XML format in addition to a deployment distribution and runtime mechanisms. Java EJB and control component will be used to illustrate the various embodiments of the invention in the following context.

Referring to the annotation manifest can be populated as a build artifact in each application software component module at build time wherein the manifest may contain definition of annotations and their constraints. The configuration of the application components can be accomplished without being connected to the runtime environment by loading the application components into a deployment configuration manager which allows configuration actions of the annotations to take place. When all changes are complete the changes can be saved as annotation overrides to an external descriptor in a separate XML file in addition to a deployment plan via application programming interfaces API such as JSR88 APIs provided by the deployment configuration manager. The configuration of the annotations can be guided by their constraints to insure that the values of the annotation overrides are consistent with the definition of the overridden annotations. An administrative application such as a console may display annotation overrides through the deployment configuration manager and allow users to interactively edit the annotation overrides under validated by the annotation constraints via console editors associated with specific annotation types. A deployment manger can be used to interact with an active runtime environment to distribute and start stop update the application component. As part of the standard application deployment the deployment plan and the external descriptor corresponding to the annotation overrides can be distributed at runtime to a descriptor framework which can then parse and or validate the annotation overrides into descriptor beans via a descriptor manager . These descriptor beans can be organized as descriptor bean trees or graphs. A customized configuration module may listen to deployment and or update event at runtime respond to those events by invoking the descriptor framework to parse and or validate the external descriptor if it is changed and generate a notification of deployment changes to be delivered to a container. Finally the container can configure update the deployed application component with the annotation overrides upon receiving a notification of deployment changes from the custom module. Note also that the deployed application can be updated configured without re starting and or redeploying the application container at runtime as long as the changes do not include those that require application or sever to restart.

Referring to an annotation manifest can be defined and populated to the corresponding application software component at build time at step wherein the annotation manifest can represent a specific scope of the component. For a non limiting example the annotation manifest can be associated with a module or application in J2EE environments. In other environments other structures could be supported in similar ways. At step the application component can be configured i.e. values of annotations can be specified under their constraints without being connected to a runtime environment and changes in annotations can be saved as annotation overrides into an external descriptor in XML format together with the deployment plan of the application at step . Such external descriptor and deployment plan can then be distributed parsed and validated in a descriptor framework at runtime at step . Finally the deployed application component can be configured updated with the annotation overrides read from the descriptor framework upon receiving notification of deployment and or deployment changes at runtime without having to restart the component at step .

In some embodiments three key roles can be defined for the configuration of a deployable component such as control 

In some embodiments a control author may mark annotations as externally configurable using the externalConfig member of the PropertySet annotation. For example the following is an example of an annotation that allows external override of all property values 

This approach will force control authors to organize their annotations based in part on requirements for external override and simplifies the representation in the manifest.

In some embodiments the run time external configuration is exposed to the consumer of a control as a set of properties. The shape of the properties may be defined by JSR175 annotations that by convention are nested in the public interface of the control. The concept of exposing runtime configuration via properties is important for a number of reasons 

In some embodiments overriding can take several forms as described by the non exhaustive scenarios A D below. It is possible that external configuration results in the removal of a value and optional setting of another value. Membership Optional Required rules must be re evaluated in any case where membership is changing i.e. not just a value replacement . For example changing the URL on a ServiceControl from HTTP to JMS. The ServiceControl defines the at least one membership rule so the removal of one value implies the need to add another value. These constraints will have to be enforced by the console or other administrative client application.

This is the simplest form of replacement. The value of a member is replaced by a new value. This is indicated by the existence of a non empty element.

Removing a value has implications for user model. The absence of a value in the external overrides is not sufficient to indicate user intent i.e. it could mean the replacement value is empty or there is no replacement value . From a configuration standpoint there should an explicit action that marks the target value as removed or deleted . If marked any existing value should be cleared and protected from input i.e. you can t provide a replacement value for a deleted property . An empty value should be considered no value. An empty value is an empty string or a value made up of only white space characters. Since JSR175 does not support the concept of NULL annotation values there is a need to provide a mapping of empty to NULL.

Same principals apply as single value. An explicit action to remove the array will be exposed through the UI or other administrative client application. There will not be a mechanism to remove part of an array. Removing values will essentially be creating a new array with the unwanted values missing.

In some embodiments JSR 175 defines a specific set of valid types that can be used as members in an annotation definition in metadata. There are some types where it does not make sense to support external override such as class and class byte and byte etc. For these cases where external override is not meaningful a user could 

In some embodiments the process of populating the deployment descriptor plan may depend on information about annotations and the annotated code contained in the resource being deployed. Such information can be provided by creating external configuration annotations manifest and referencing the manifest during the deployment configuration process. This is necessary to drive the interaction during deployment. There are two approaches to providing this information to the deployment configuration infrastructure 

In some embodiments the manifest can be organized to include what can be and what is with regard to annotations . This can provide a context for expressing the runtime annotation overrides in terms of explicit add change or remove actions. The manifest can also be organized to only describe what is with regard to annotations . The runtime annotation overrides are then assumed to have add if absent replace if present semantics. This may limit the tooling support to overriding existing custom annotations while permitting the addition of only common or component specific annotations. A full override add experience for application deployers can be supported under an IDE based administrative tool. However with console based deployment which implies a less interactive tooling environment a module that only includes custom annotations that exist in the manifest along with enough information to support adding policy based annotations is more likely.

In some embodiments a custom module can be added to configure the application during deployment. That configuration module may build a cache of external configuration data and make that data available via application properties. Containers can then use a finder API to get the current set of overrides which provides 

In some embodiments the custom module will use timestamps from the deployment plan to determine of any of the modules for that application had annotation changes during an update. For the modules that did have changes the customized configuration module will 

In some embodiments the control container may make use of a delegation model to resolve requests for property values at runtime. The data from external overrides is inserted into the chain behind calls to the control API but in front of calls to the JSR175 API. For a non limiting example the control container holds a cache of override values that are used to support consistent results. When an external update occurs a new version of the cache is built and new requests use the new cache.

In some embodiments a mechanism can be utilized to support external override of annotations by taking an annotation instance in a runtime context and finding any relevant annotation override values. An important part of that mechanism is being able to define an annotation identity. Such an annotation can be uniquely identified by constructing a path that includes the type and location of the annotation. Since annotations can be nested there is no fixed structure for the path. The path can be built via one or more of the following 

In some embodiments a control implementation class that asks for annotation values should get the same result from subsequent requests within the same onAcquire onRelease invocation i.e. repeatable read semantics . If an implementation wants a stable value for annotations during the life of the instance then they should only request annotation values during the onCreate event.

In some embodiments member values properties that contain security sensitive information should be encrypted instead of stored in clear text. An annotation may be provided to mark a property as needing encryption and two member values can be defined in a descriptor framework one that was clear text and one that was encrypted. The annotation will only be valid on the member of an annotation that is marked as externally configurable. Then a transient property would be used by clients and implemented via a customization of the descriptor bean. The customizer would look at metadata about the member and determine which property to delegate the get setOverrideValue call to. The customizer is operable to conditionally encrypt decrypt values based on metadata and the benefit is a somewhat easier to understand schema. In both cases there is a single get setOverrideValue API for clients e.g. the console and the customer module to use. The implementation choice is how many properties to store and where to put the encryption logic.

In some embodiments the values of the annotations can be encrypted during the build process via the following options 

In some embodiments the build of a module should fail if any annotations that are marked as externally configurable include member types locations or structures that are not supported. The control container should trap any type related runtime failures and raise them as a configuration error. This indicates that an incorrect value made its way into the deployment plan. An appropriate log message should also be generated to give the administrator sufficient information to locate the value in the deployment plan e.g. the path to the element associated with the failed request and the expected data type .

In some embodiments the manifest may have a structural representation that follows the annotated code. The structure of the manifest expresses the structure of the annotated code for a non limiting example annotated type annotated field annotation as well as the structure of any annotations e.g. annotation nested annotation . This approach seems to make tooling more straightforward and may make it easier for users that use schema aware tools to directly edit the override document.

In some embodiments the manifest may have a collapsed form that uses a key into to the code to collapse annotation overrides into simple linear list and bind a path expression to each annotation. The path would express the location of what the annotation annotates and would also express the structure of the annotation itself. There may be other in between approaches that further separate the notion of what is annotation from the annotation structure itself.

In some embodiments additional type constraints can be used to define user customized types such as Date. For a non limiting example a member of type String can be annotated as a Date with optional min max value s . The external form of the annotations manifest needs to carry enough information to present validation hints to the user. Such basic type membership constraints in the manifest allows the UI of the console to shape the user interaction.

In some embodiments the set of constraint types can be aligned with XML Schema types for two reasons 1 they are common familiar 2 existing ways can be found to express the constraints via XML e.g. xsi type or a variant of XForms where the XForms specification can also be used to address the problem of how to have types in an instance documents constrained declaratively e.g. via binding rules rather than by explicit schema reference although the model document can be associated with a schema .

In some embodiments a configuration module deployed as part of the application can configure the application at deployment time via a descriptor associated with the application by applying annotation overrides from descriptor beans in the descriptor framework note that in some embodiments the descriptor can be part of a deployment plan . This module can be customized to provide services that include but are not limited to 

In some embodiments the descriptor bean framework may support non dynamic properties via a mechanism to indicate whether a property changes requires restart of the application. If the property is not marked as requiring restart then the change will take effect as soon as the target module processes the update. Since dynamic changes within a cluster are not atomic old and new values may be in use at the same instant in time until all modules have processed the change.

One embodiment may be implemented using a conventional general purpose or a specialized digital computer or microprocessor s programmed according to the teachings of the present disclosure as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits or by interconnecting an appropriate network of conventional component circuits as will be readily apparent to those skilled in the art.

One embodiment includes a computer program product which is a machine readable medium media having instructions stored thereon in which can be used to program one or more computing devices to perform any of the features presented herein. The machine readable medium can include but is not limited to one or more types of disks including floppy disks optical discs DVD CD ROMs micro drive and magneto optical disks ROMs RAMs EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs or any type of media or device suitable for storing instructions and or data. Stored on any one of the computer readable medium media the present invention includes software for controlling both the hardware of the general purpose specialized computer or microprocessor and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include but is not limited to device drivers operating systems execution environments containers and applications.

The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Particularly while the concept component is used in the embodiments of the systems and methods described above it will be evident that such concept can be interchangeably used with equivalent concepts such as module resource method type interface class object model and other suitable concepts. While the concept interface is used in the embodiments of the systems and methods described above it will be evident that such concept can be interchangeably used with equivalent concepts such as bean class method type component object model and other suitable concepts. While the concept instance is used in the embodiments of the systems and methods described above it will be evident that such concept can be interchangeably used with equivalent concepts such as object and other suitable concepts. While the concept annotation is used in the embodiments of the systems and methods described above it will be evident that such concept can be interchangeably used with equivalent concepts such as metadata manifest attribute property variable member field element and other suitable concepts. Embodiments were chosen and described in order to best describe the principles of the invention and its practical application thereby enabling others skilled in the art to understand the invention the various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents.

