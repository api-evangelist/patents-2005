---

title: Playlist structure for large playlists
abstract: Enabling efficient navigation of a playlist of media files stored on a computer-readable medium. Aspects of the invention define a playlist structure to have one or more playlist units. Each playlist unit identifies one or more media files in the playlist and includes metadata for the media files. A consumer electronic device retrieves the playlist units and displays the metadata contained therein to a user to enable navigation of the playlist. Aspects of the invention reduce the memory requirements of the consumer electronic devices and reduce the quantity of disk seek operations needed for playlist navigation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07668842&OS=07668842&RS=07668842
owner: Panasonic Corporation
number: 07668842
owner_city: Osaka
owner_country: JP
publication_date: 20050628
---
This application is a continuation in part of co pending U.S. patent application Ser. No. 10 273 415 filed Oct. 17 2002 entitled Navigating Media Content via Groups within a Playlist hereby incorporated by reference which claims the benefit of U.S. Provisional Patent Application Ser. No. 60 418 973 filed Oct. 16 2002 entitled COMPRESSED MEDIA FORMAT SPECIFICATION now abandoned.

Due to recent advances in technology computer users are now able to enjoy many features that provide an improved user experience such as playing various media and multimedia content on their personal or laptop computers. For example most computers today are able to play compact discs CDs so users can listen to their favorite musical artists while working on their computers. Many computers are also equipped with digital versatile disc DVD drives enabling users to watch movies.

In some multimedia environments a computer has access to a computer readable medium storing compressed media files such as Moving Picture Experts Group audio layer 3 MP3 files and WINDOWS MEDIA technologies audio WMA files. When the media files are rendered on a computer the computer typically has access to a database storing metadata describing albums artists genres years or the like for the media files. The computer typically organizes the media files into playlists based on the metadata when the compressed media files are played on the computer. For example in the case of audio media files the files may be organized by album artist genre year or some user specified selection and ordering. This allows users to easily have access to all of their content regardless of whether or not the users manually created a playlist.

However when compressed media files are transferred from the computer to an optical format such as CD or DVD for playback on a portable CD player car receiver DVD player or other consumer electronic devices having a low power processor limited memory and often limited display and user input capabilities the media files traditionally lose much of the functionality offered by metadata databases hosted on devices with greater computing power. The playlists revert to nothing more than a sequential list of files to be played.

Further a playlist having a large number of files is difficult for a low powered device to navigate. For example some existing systems store metadata separate from media files on a computer readable medium. To render the media files and display metadata associated with the media files the existing systems have to seek to at least two separate areas of the computer readable medium. If the rendering device has a limited buffer for disk seek and find operations then such rendering devices cannot navigate large playlists. For example a rendering device such as a low end portable CD player only contains an 8 bit 1 MHz processor with 100 kilobytes of working memory with a five second seek time.

Other systems store the metadata within the media files. To obtain the metadata for the media files the existing systems have to open each media file in the playlist to obtain and display the metadata. Opening every media file in a playlist is slow and increases complexity. The existing systems fail to provide a playlist structure that supports an unbounded number of media files and is capable of playback on even the lowest power devices.

Accordingly a system for enabling efficient navigation of large playlists is desired to address one or more of these and other disadvantages.

Embodiments of the invention include a playlist structure in which references to content within the playlist are stored along with metadata associated with the content in self contained easy to parse fixed size playlist blocks chunks units or other discrete elements. Metadata is preserved when storing playlists on a computer readable medium for access by a consumer electronic device having a low power processor limited memory and limited display and user input capabilities. The playlist units have a size that is aligned to a sector size of the computer readable medium e.g. CD or DVD to enable efficient loading by the consumer electronic device. A low end rendering device or software need only load one or more playlist units into memory to acquire and process the complete metadata and playlist. In one embodiment the metadata stored in the playlist units includes file and directory information for the media files metadata for each of the media files and specific playlist data for rendering those files.

By storing the metadata and the media file references in easy to load playlist units aspects of the invention reduces the number of disk seek and find operations. These aspects of the invention also enable rendering devices with low power or limited memory to process and navigate large playlists.

Referring first to a block diagram illustrates an exemplary media environment in which the invention may be implemented. A system has one or more computers coupled to one or more consumer electronic devices providing media content including audio data video data and or still image data. For example the devices may include a compact disc CD player a camcorder or a camera . Additionally the devices may include other personal computers removable hard drives network shares a Moving Picture Experts Group audio layer 3 MP3 player an audio system in an automobile a personal digital assistant a cellular telephone or the like. The consumer electronic devices may include any suitable rendering filter or media player or device e.g. a portable media device that is configured to render digital media so that the user can experience the content that is embodied on the consumer electronic device . For example suitable media player applications include a compact disc CD media player and a digital versatile disc or digital video disc DVD media player. The computer also has rendering capability including a processor and rendering software e.g. a media player .

One aspect of the present invention enables the user or particularly enables a media player program executing on computing device to access retrieve and display for the user so called metadata. Those skilled in the art are familiar with metadata which is simply information about data. In the context of the illustrated embodiment metadata includes information related to specific content of a digital media file being played on the media player. Basic metadata includes but is not limited to title performer genre track number and the like. Extended metadata includes but is not limited to cover art composer description of content performer biographies reviews ratings related performers where to buy similar items upcoming concerts ticket sales URLs to other related experiences including purchase opportunities studio director and the like. In one embodiment extended metadata may be organized into two main categories metadata retrieved or downloaded and metadata computed from the media file e.g. digital signal processing of the file stream . The metadata may be stored within the media file or stored in another file accessible and known to the media file.

In one example additional metadata is available from the metadata provider via a data communication network . The computer and metadata provider are coupled to the data communication network . While the network includes the Internet in one example the teachings of the invention may be applied to any data communication network. Data communication network may support for example client server communications or peer to peer connections.

The consumer electronic devices or computer may have access to one or more computer readable media e.g. memory area . While the memory area is illustrated to be part of any of the consumer electronic devices in the memory area may be separate from the consumer electronic devices yet accessible to the consumer electronic devices for example via a network. In one embodiment memory area includes one or more computer readable media for storing playlists . In a playlist has playlist units such as playlist unit through playlist unit N. Each of the playlist units includes a content entry field not shown such as a content entry field in for each of the media files associated with the playlist unit and a metadata field not shown such as an offset to text field in for each content entry field. The content entry field stores a media file reference identifying a location of the media file. The metadata field stores metadata associated with the media file associated with the content entry field. The playlist structure is described in further detail with reference to below.

In one embodiment the consumer electronic devices e.g. a portable media device are configured to execute computer executable instructions for navigating the playlist having a plurality of media files associated therewith. The computer executable instructions may be organized into one or more components. For example the consumer electronic devices may store a playlist component a parser component a user interface component and a playback component . The playlist component retrieves obtains or otherwise receives one of a plurality of playlist units stored in memory area . The playlist units collectively represent the playlist . The parser component obtains metadata stored within the playlist unit retrieved by the interface component. The metadata describes a media file associated with the playlist . The user interface component displays to a user the obtained metadata or a portion thereof to enable user selection of a media file associated with the displayed metadata. The user interface component receives a media file selection from the user. The playback component renders the selected media file to the user via the media file reference associated with the media file selection. In one embodiment each of the playlist units has a size derived from a sector size associated with the memory area.

The computer or other device or software also has one or more exemplary modules or components for implementing aspects of the invention. For example the computer may have computer executable instructions for creating playlist which has an efficient structure described herein to enable efficient navigation of the playlist . Such computer executable instructions are described in .

Those skilled in the art will note that the invention software may be implemented with any number and organization of components or modules. That is the invention is not limited to the specific configuration of the playlist component the parser component the user interface component the playback component and the computer executable instructions executed by computer but may include more or less components having more or less individual functionality than described herein. Further the invention may be embodied in hardware software or a combination thereof in a media player operating system DVD recorder CD recorder video camera hard drive flash drive personal digital assistant wireless device e.g. cellular telephone or the like.

Referring next to an exemplary block diagram illustrates a playlist structure. In one embodiment each playlist is represented as a unique .HMT file such as nnnnnnnn.HMT file where nnnnnnnn is an upper case string representation of a hexadecimal number without leading zeros that represents a playlist identifier. The playlists may contain one or more of the following media files audio files video files image files along with the minimum duration an image should be displayed as well as transitions to use between each image and parallel images e.g. an image slideshow with background audio . Further in one embodiment each playlist may be organized into groups. There are four different types of playlist groups an audio playlist group a video playlist group a timed image playlist group and a parallel image audio playlist group. Audio playlist groups have one or more audio files. Video playlist groups have one or more video files and support the ability to specify the starting and ending point to use when playing a video file. Timed image playlist groups have one or more image files and support the ability to specify the minimum duration an image should be displayed as well as transitions to use between each image. Parallel image audio playlist groups allow for an image slideshow with background audio.

The playlist structure in generally includes a file header an offset group table a group name table and playlist unit data. Playlists that are created on rewritable media also include padding to allow for future edits. For example the padding may be after an offset group table as well as after the group name table. In one embodiment the size of the padding is a minimum of 2 048 bytes for each padding section. If the playlist authoring software of the invention expects a large number of edits to be made to the playlist an increased padding size may be warranted.

The offset group table includes a list of one or more offset group entries. The offset group entries in the offset group table are listed in the playback order of the groups in the playlist file. An exemplary offset group entry is shown in the table below.

The group name table includes a list of one or more group name entries. Each group name entry includes a group name using the following exemplary format.

Playlist units are fixed size blocks that reference one or more media files. In one embodiment 10 15 media files are referenced in a single playlist unit. In an embodiment in which the playlist is further organized into playlist groups a playlist unit may include one or more groups. Further one playlist group may span multiple playlist units. Each of the playlist units includes data to render all or part of a playlist group. This data lowers the memory required for a player to render very large playlists. A player only needs to have enough memory to hold at least one playlist unit in memory at any given time.

An exemplary playlist unit includes a playlist unit header a directory table a content table group data and the file names of the content as shown below. Empty playlist units may be in the playlist file. An empty playlist unit only contains a playlist unit header where all fields are zero except for the previous and next playlist unit index fields. Offsets inside a playlist unit are relative to the beginning of the playlist unit. This allows each playlist unit to be a self contained unit that can be interpreted without any other information. For DVD media the playlist unit size is 2 048 bytes corresponding to the sector size of a DVD medium. In addition the playlist units are in playback order. While the playlist units have equal sizes in one embodiment the invention is operable with playlists of differing sizes e.g. multiples .

The directory table in a playlist unit as shown below only contains the directories that are referenced in the content table of the same playlist unit for memory storage optimization. The exemplary directory table below stores one or more directory paths associated with the media files in the playlist unit.

The content table includes a list of content entries. There is one content entry for each unique file referenced in a playlist unit. An exemplary content entry is formatted as defined in the table below.

In one embodiment metadata associated with each media file is organized into fields such as text1 text2 text3 text4 and text5. The metadata in each of the text fields may represent a particular metadata such as album artist and movie title depending on the type of media file associated with the metadata. The offset to text1 field is a 2 byte entry representing the offset from the beginning of the current playlist unit to the text data for Text 1 data. The offset to text2 field is a 2 byte entry representing the offset from the beginning of the current playlist unit to the text data for text2 data. The offset to text3 field is a 2 byte entry representing the offset from the beginning of the current playlist unit to the text data for text3 data. The offset to text4 field is a 2 byte entry representing the offset from the beginning of the current playlist unit to the text data for text4 data. The offset to text5 field is a 2 byte entry representing the offset from the beginning of the current playlist unit to the text data for text5 data. The offset to file name field is a 2 byte entry representing the offset from the beginning of the current playlist unit to the text data structure which contains the file name of the current media file.

An exemplary mapping of metadata to the text fields in a content entry is outlined in the following table.

Referring next to an exemplary flow chart illustrates operation of playlist creation software. The invention includes playlist creation software playlist authoring software or the like to populate a playlist structure such as illustrated in . The playlist authoring method of the invention allocates playlist unit space between metadata and content e.g. media files . For example a playlist unit may include one media file reference and all metadata. In one embodiment all of the playlist units have equal sizes derived from a sector size of the computer readable medium storing the playlist units. For example the playlist unit size may be 2048 bytes for a DVD medium.

The invention includes a computerized method for enabling efficient navigation of the playlist of media files as shown in . The computerized method aids user selection of the media files prior to rendering the media files. The computerized method includes identifying one or more media files associated with a playlist at and defining media file references for the identified media files at . In one embodiment defining the media file references includes defining pointers to each of the identified media files. The computerized method also includes retrieving metadata e.g. via the defined media file references corresponding to each of the identified media files at . The computerized method also includes storing the defined media file references and the retrieved metadata in one or more playlist units at . For example the computerized method populates the playlist data structure of with the defined media file references and the retrieved metadata. The playlist units collectively constitute the playlist.

The invention is not limited to a particular playlist authoring method. Various playlist authoring methods are within the scope of the invention. In a particular example the playlist authoring method of the invention populates two playlist unit data structures simultaneously. When the size of one of the playlist unit data structures exceeds the playlist unit size the method considers the other playlist unit to be a full playlist unit.

Another example of a playlist authoring method of the invention includes determining a quantity of playlist units to store the media file references and the retrieved metadata as a function of the size of each playlist unit. The method stores the media file references and the retrieved metadata in the determined quantity of playlist units. Another exemplary method for storing the media file references and the retrieved metadata includes successively storing at least a portion of the media file references and the retrieved metadata corresponding thereto in a first playlist unit until the playlist unit size has been reached. The method closes the first playlist unit opens a second playlist unit and successively stores at least a remaining portion of the media file references and the retrieved metadata corresponding thereto in the opened second playlist unit.

In one embodiment one or more computer readable media have computer executable instructions for performing the computerized method illustrated in .

Referring next to an exemplary flow chart illustrates creation of the playlist unit in one embodiment. At a media file number and a playlist unit unit number are set to one. The method in one embodiment obtains metadata strings for the media file corresponding to the current media file number at . For each metadata string the method determines if the metadata string is already stored in the current playlist unit at . If so then the location of the stored metadata string in the current playlist unit is noted and subsequently stored at . If the obtained metadata string is not already stored in the current playlist unit at then the metadata string is added to the metadata to be added to the current playlist unit e.g. at . If the playlist entry data and the metadata to be added to the current playlist unit will fit in the current playlist unit at the method writes the playlist entry data and the metadata to the current unit at . The media file number is incremented at and a determination is made at as to whether more files are to be processed. If more files are not to be processed the method writes the last unit at . If more files are to be processed metadata is obtained at for the next media file to be processed. If the playlist entry data and the metadata to be added to the current playlist unit will not fit in the current playlist unit at the method in this embodiment writes the unit at e.g. to the computer readable medium increments the unit number at and then proceeds at .

Referring next to an exemplary flow chart illustrates playlist playback using the playlist unit in one embodiment. The playlist unit number is set to one at . The media file number is set to one within the current unit at . The media file corresponding to the current media file number is rendered e.g. played back at . If there are more media files in the current playlist unit to play back at the media file number is incremented at and the next media file is played back at . If there are no more media files in the current playlist unit to play back at and there are no more units in the playlist at the method in one embodiment returns to the playlist menu at . If there are more units in the playlist at the unit number is incremented at and the method proceeds to reset the media file number to one for the current unit at .

The computer typically has at least some form of computer readable media. Computer readable media which include both volatile and nonvolatile media removable and non removable media may be any available medium that may be accessed by computer . By way of example and not limitation computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that may be used to store the desired information and that may be accessed by computer . Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. Those skilled in the art are familiar with the modulated data signal which has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media are examples of communication media. Combinations of any of the above are also included within the scope of computer readable media.

The system memory includes computer storage media in the form of removable and or non removable volatile and or nonvolatile memory. In the illustrated embodiment system memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. For example illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media. also shows a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that may be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive and magnetic disk drive and optical disk drive are typically connected to the system bus by a non volatile memory interface such as interface .

The drives or other mass storage devices and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components may either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into computer through input devices or user interface selection devices such as a keyboard and a pointing device e.g. a mouse trackball pen or touch pad . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are connected to processing unit through a user input interface that is coupled to system bus but may be connected by other interface and bus structures such as a parallel port game port or a Universal Serial Bus USB . A monitor or other type of display device is also connected to system bus via an interface such as a video interface . In addition to the monitor computers often include other peripheral output devices not shown such as a printer and speakers which may be connected through an output peripheral interface not shown .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. LAN and or WAN may be a wired network a wireless network a combination thereof and so on. Such networking environments are commonplace in offices enterprise wide computer networks intranets and global computer networks e.g. the Internet .

When used in a local area networking environment computer is connected to the LAN through a network interface or adapter . When used in a wide area networking environment computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external is connected to system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to computer or portions thereof may be stored in a remote memory storage device not shown . By way of example and not limitation illustrates remote application programs as residing on the memory device. The network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Generally the data processors of computer are programmed by means of instructions stored at different times in the various computer readable storage media of the computer. Programs and operating systems are typically distributed for example on floppy disks or CD ROMs. From there they are installed or loaded into the secondary memory of a computer. At execution they are loaded at least partially into the computer s primary electronic memory. The invention described herein includes these and other various types of computer readable storage media when such media contain instructions or programs for implementing the steps described below in conjunction with a microprocessor or other data processor. The invention also includes the computer itself when programmed according to the methods and techniques described herein.

For purposes of illustration programs and other executable program components such as the operating system are illustrated herein as discrete blocks. It is recognized however that such programs and components reside at various times in different storage components of the computer and are executed by the data processor s of the computer.

Although described in connection with an exemplary computing system environment including computer the invention is operational with numerous other general purpose or special purpose computing system environments or configurations. The computing system environment is not intended to suggest any limitation as to the scope of use or functionality of the invention. Moreover the computing system environment should not be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics mobile telephones network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include but are not limited to routines programs objects components and data structures that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An interface in the context of a software architecture includes a software module component code portion or other sequence of computer executable instructions. The interface includes for example a first module accessing a second module to perform computing tasks on behalf of the first module. The first and second modules include in one example application programming interfaces APIs such as provided by operating systems component object model COM interfaces e.g. for peer to peer application communication and extensible markup language metadata interchange format XMI interfaces e.g. for communication between web services .

The interface may be a tightly coupled synchronous implementation such as in Java 2 Platform Enterprise Edition J2EE COM or distributed COM DCOM examples. Alternatively or in addition the interface may be a loosely coupled asynchronous implementation such as in a web service e.g. using the simple object access protocol . In general the interface includes any combination of the following characteristics tightly coupled loosely coupled synchronous and asynchronous. Further the interface may conform to a standard protocol a proprietary protocol or any combination of standard and proprietary protocols.

The interfaces described herein may all be part of a single interface or may be implemented as separate interfaces or any combination therein. The interfaces may execute locally or remotely to provide functionality. Further the interfaces may include additional or less functionality than illustrated or described herein.

In operation computer executes computer executable instructions such as those illustrated in the figures to implement the invention.

The invention includes means for creating the playlist unit and means for populating the data structure. Hardware and software such as a data structure a user interface an application program an application programming interface API computer executable instructions firmware and the like such as illustrated in the figures constitute means for creating the playlist unit and means for populating the data structure.

In the examples described herein the media content of the digital media file is described in the context of content embodied on a CD or a DVD. It is to be appreciated and understood that the media content may be embodied on any suitable media and that the specific examples described herein are given to further understanding of the inventive principles. For convenience a digital media file refers to one or more files representing for example a single song track or a collection of tracks such as would be found on an audio CD. The media content may include without limitation specially encoded media content e.g. audio video or still images in the form of an encoded media file.

The exemplary media file operations illustrated in the drawings and described herein are merely exemplary. Other variations of these file operations are within the scope of the invention. Alternatively or in addition other media file operations not described herein yet embodying the invention are also within the scope of the invention.

The order of execution or performance of the methods illustrated and described herein is not essential unless otherwise specified. That is elements of the methods may be performed in any order unless otherwise specified and that the methods may include more or less elements than those disclosed herein. For example it is contemplated that executing or performing a particular element before contemporaneously with or after another element is within the scope of the invention.

When introducing elements of the present invention or the embodiment s thereof the articles a an the and said are intended to mean that there are one or more of the elements. The terms comprising including and having are intended to be inclusive and mean that there may be additional elements other than the listed elements.

In view of the above it will be seen that the several objects of the invention are achieved and other advantageous results attained.

As various changes could be made in the above constructions products and methods without departing from the scope of the invention it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.

An exemplary group data field in the playlist structure and the playlist group objects therein in one embodiment of the invention are described below.

Group Data includes a list of one or more Playlist Group Entries as defined below. Each Playlist Group Entry in the Group Data has different Group ID s and the Playlist Group Entries are stored in the Group Data in playback order.

This 2 byte entry contains the byte offset from the beginning of the Playlist unit to the previous Playlist Group Entry in this Group Data. A value of zero indicates that this Playlist Group Entry is the first Group Entry in this Group Data.

This 2 byte entry contains the byte offset from the beginning of the Playlist unit to the next Playlist Group Entry in this Group Data. A value of zero indicates that this Playlist Group Entry is the last Group Entry in this Group Data.

This 2 byte summarizes the special attributes of this Playlist Group Entry. The following table illustrates the format of this field.

The continued flags allow players to easily find the starting and ending Playlist units for a Playlist Group without having to reference the Offset Group Table. Exemplary continued flags are shown below.

This 2 byte entry contains the byte offset from the beginning of the Playlist unit to the Text Data which contains the Group Name of the Playlist Group. Each Playlist Group Entry has a valid Text Entry for the Group Name.

This variable size entry contains all or part of the Playlist Group data. A Playlist Group is represented as the aggregate of one or more Playlist Group Objects. In the case that one Playlist Group includes more than one Playlist Group Object the information for concatenating the Playlist Group Objects within the Playlist Group are indicated by the Group Flags. If a Playlist Group includes more than one Playlist Group Object then the Playlist Group spans Playlist units. The number of Playlist Group Objects is equal to the number of Playlist units that contain Playlist Group Objects for this Playlist Group. Therefore only one Playlist Group Object for a given Playlist Group is allowed in an individual Playlist unit in one embodiment.

This 4 byte entry is the number of Audio Files Indexes that are listed in this Playlist Group Object.

There is one 4 byte entry for each Audio File Index in this Playlist Group Object. The value is the Index of the Content Entry which references this Audio File in the Content Table. A value of one indicates the first Content Entry listed in the Content Table.

This 4 byte entry is the number of Video File Indexes that are listed in this Playlist Group Object contained in this Playlist unit.

There is one 4 byte entry for each Video File Index in this Playlist Group Object. The value is the Index of the Content Entry which references this Video file in the Content Table. A value of one indicates the first Content Entry listed in the Content Table.

There is one 4 byte entry for each Video File in this Playlist Group. The value is the offset in milliseconds to the starting time of the starting frame. The offset shall correspond to an I frame within the Video File.

There is one 4 byte entry for each Video File in this Playlist Group. The value is the offset in milliseconds to the starting time of the next frame of the ending frame. A value of zero indicates that the Video File should be played to the end of the file. When two sequential Video File Indexes in a Video Playlist Group indicate the same Video File this is a special case intended for uninterrupted playback. Entries such as this allow chapters to be created within a single Video File allowing the user to skip by chapter. During normal playback the video plays without interruption as each chapter end where the next begins. Uninterrupted playback is only mandatory in one embodiment for chapters contained within a single Playlist unit. Interruptions are allowed when a chapter spans Playlist unit boundaries.

There is one 8 byte entry for each Video File in this Playlist Group. The value is the offset from the beginning of the Video File to the location a player may use to start reading the file. This offset is used with the Starting Point of Video field. If the Starting Point Video field is zero then this field is zero in which case the player will locate the first packet to read by examining the File Header. If the Starting Point of Video field is non zero then this field contains the nearest location in the file to start decoding in order to reach the video starting time.

There is one 8 byte entry for each Video File in this Playlist Group. The value is the offset from the beginning of the Video File to the location a player may use to stop reading the file. This offset is to be used with the Ending point of Video field. If the Ending Point of Video field is zero then this field is zero in which case the player will need to decide for itself where to stop reading the file. If the Ending Point of Video field is non zero then this field contains the nearest location in the file to end reading to ensure all necessary data has been read.

This 2 byte entry defines the initial transition to be used to display the first image in this Playlist Group Object. Exemplary values are CUT and FADE IN.

This 2 byte entry defines the final transition to be used to end the display of the last image in this Playlist Group Object. Exemplary values are CUT and FADE OUT.

There is one 4 byte entry for each Image File Index in this Playlist Group Object. The value is the Index of the Content Entry which references this Image file in the Content Table. A value of one indicates the first Content Entry listed in the Content Table.

This 4 byte entry is the duration to display the image in milliseconds after the image has been decoded a value of zero represents infinity. In one embodiment the minimum image duration in a Timed Image Playlist Group is 3 seconds 3000 milliseconds and the maximum value is 0x001FFFFF.

This 2 byte entry defines the type of transition to use when the player changes to the next Image File. A value of zero is defined as CUT. A list of exemplary transitions is defined in the following table.

A Parallel Image Audio Playlist Group contains a list of Audio Files followed by a list of Image Files with transition and duration information. The list of Audio Files fits within the first Playlist that contains the Parallel Image Audio Playlist Group. The Audio section e.g. the list of Audio Files and corresponding Content Entries and File Name Text String data does not span playlist units. The Images are considered the dominant files within this combination determining most aspects of playback while the audio us considered an accompaniment with no synchronization to the images.

This 2 byte entry is the offset from the beginning of this playlist unit to the first Image File Index. This value is zero if the first Image File Index is stored at the beginning of the next Playlist unit.

This 2 byte entry defines the initial transition to be used to display the first image in this Playlist Group Object. Exemplary values are CUT and FADE IN.

This 2 byte entry defines the final transition to be used to end the display of the last image in this group Object. Exemplary values are CUT and FADE OUT.

This 4 byte entry is the number of Audio File Indexes that are listed in this Playlist Group Object. This field is zero in all Playlist units except for the first one that contains this Parallel Image Audio Playlist Group.

This is one 4 byte entry for each Audi File Index in this Playlist Group Object. The value is the Index of the Content Entry which references this Audio File in the Content Table. A value of one indicates the first Content Entry listed in the Content Table.

There is one 4 byte entry for each Image File Index in this Playlist Group Object. The value is the Index of the Content Entry which references this Image file in the Content Table. A value of one indicates the first Content Entry listed in the Content Table.

This 4 byte entry is the duration to display the image in milliseconds after the image has been decoded a value of zero represents infinity. In one embodiment the minimum image duration in a Timed Image Playlist Group is 3 seconds 3000 milliseconds and the maximum value is 0 001FFFFF.

This 2 byte entry defines the type of transition to use when the player changes to the next Image File. A value of zero is defined as CUT.

