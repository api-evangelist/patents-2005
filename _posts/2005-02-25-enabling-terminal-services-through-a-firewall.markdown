---

title: Enabling terminal services through a firewall
abstract: Systems and methods are described that provide terminal services through a firewall. In one implementation, data is wrapped with an RPC-based protocol, wherein the data to be wrapped is configured according to a stream-based protocol consistent with establishing a server/client relationship. The RPC-based protocol is then layered over HTTPS. The wrapped data is then passed through the firewall.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07810148&OS=07810148&RS=07810148
owner: Microsoft Corporation
number: 07810148
owner_city: Redmond
owner_country: US
publication_date: 20050225
---
The present disclosure generally relates to systems and methods for establishing a terminal server terminal server client relationship through a firewall and more particularly to layering a protocol adapted for terminal services on top of a protocol adapted for traversing a firewall.

Within a firewall it is relatively easy to configure server and client computers wherein the client is able to access applications and data contained on a server. Protocols which are not resistant to attack if exposed to the Internet can be utilized effectively in such an environment which is typical of corporate intranets. Unfortunately such a configuration does not provide for utilization of server resource outside the firewall.

Putting the server on the Internet is not an option since it would be vigorously attacked with disastrous consequences. As a result it is common for corporate employees to utilize VPN virtual private network technology to traverse the firewall and access the server from remote sites such as from home or travel. While VPN technology provides a workable solution in many applications VPN connections are hard to setup and maintain.

Accordingly there is a need to provide alternate systems and methods that provide users with access to server resources inside the firewall without compromising those resources to attack.

Systems and methods are described that provide terminal services through a firewall. In one implementation data is wrapped with an RPC based protocol wherein the data to be wrapped is configured according to a stream based protocol consistent with establishing a server client relationship. The RPC based protocol is then layered over HTTPS. The wrapped data is then passed through the firewall.

The following discussion is directed to systems and methods that enable terminal services through a firewall. In one implementation data configured as RDP remote desktop protocol is wrapped with an RPC based remote procedure call protocol. The RPC data is therefore adapted for use with an RPC API allowing it to be wrapped again using an HTTPS protocol. The RDP RPC HTTPS wrapped data is passed through the firewall thereby allowing establishment of a terminal server client terminal server session on opposites sides of a firewall.

Within the left most boxes show the client system mstsc mstscax and plug ins which generate the RDP SSL and RPC data. The middle section of shows the RPC over HTTP proxy that lives on IIS in a Microsoft embodiment which proxies the RPC traffic. The right most portion of shows the RDP data forwarding in this example using an RPC re constructor that unwraps the RPC data and forwards the RDP SSL data to the terminal server.

A rules engine is typically located on the server wherein the RPC re constructor is resident. The proxy will govern what capabilities are allowed for each remote typically Internet user. In one example of the rules engine within an enterprise a user may be allow to redirect his devices. A systems administrator may want to disable this capability when such redirection results in access to resources over the Internet. Accordingly the rules engine may require that this capability be disabled.

The forwarder re constructor is a DLL that can live on the TS machine typically having the socket connection to TS configured as a loop back connection. In a TS farm where the terminal servers are load balanced forwarder re constructor can live outside the farm.

Note that the configuration seen in avoids a problem data sent to an incorrect location that may arise when the proxy is co located on the final terminal server itself. In particular the problem is avoided because the proxy has to open only one channel from itself to the terminal server rather than two channels. Where co location is employed e.g. in the configuration of the terminal server load balancer can send different packets RPC calls to different terminal servers thereby possibly misdirecting data. To help alleviate this problem a separate computer set up in front of the TS farm may be configured to make one call to a terminal server in the farm to get the IP address of the machine. Assuming this IP address is visible outside the farm all packets RPC calls now are explicitly sent to this IP address directly.

The send method is easily understood. Data is sent to the terminal server via the RPC server whenever there is data that needs to be sent from client to server. There will be as many send calls as there are packets. The second method is used to receive data from terminal server. One parameter that is of interest in this method is the sequenceNumber. This parameter is used to indicate to the client the sequence number of the packets in the current packet order in which the packets are sent. Since packets may be delivered in an out of order sequence by RPC run time on the client side the sequencing of the packets must be tracked. Other parameters are self explanatory.

The client makes multiple calls on the send method. Each call is associated with a distinct RPC asynchronous handle that the server tracks to send data back. The client ensures that there are at least a few outstanding calls to the server to receive data in order to reduce latency.

The outPipe is created by the RPC run time on the server side. The RPC server uses the outPipe and pushes data as it becomes available from the terminal server. There will be as many push calls as the number of packets. The advantage to this method is that it does not require multiple request calls to be made by the client in order to receive data and therefore overhead is reduced. This method is well suited to terminal server implementations. In some applications this implementation requires an update to the RPC runtime library on both the client and server.

The client and server can negotiate whether to implement the embodiment of or the embodiment of . The result of this negotiation typically depends on whether an updated RPC runtime is available. If an updated rpcrt.dll is available on both client and server they can choose to use the implementation of since this implementation is typically more efficient. If one of the ends do not have an updated rpcrt then can negotiate to use multiple asynchronous implementation of .

To perform the negotiation the client first determines if an updated rpcrt.dll is available on the client side. If it does not it always implements multi asynchronous which would be supported by the server. If an update is available the client makes an RPC call to the server to get a list of supported models and picks pipes if pipes is supported otherwise uses the multi asynchronous implementation.

Irrespective of the mechanism used by the RPC re constructor all data sent to client and received from client is typically performed in an asynchronous way so that RPC threads are not blocked and latency is reduced. To do this the RPC server uses I O completion ports supported by the RPC runtime. A dedicated thread for RPC I O completions is started by the RPC server at startup. This thread handles all send and receive complete notifications from RPC and acts accordingly. The RPC re constructor has an interface pointer to the TS forwarder whenever a new client connects. This pointer is used as long as the client is connected. When data is sent from the client the re constructor forwards it to the forwarder through the pointer. Similarly when it completes sending data to the client it notifies the forwarder that a send to client has been completed. When the re constructor encounters any errors such as client disconnecting it dispatches a disconnect call to the forwarder which disconnects the session.

The data is sent and received using I O completion ports similar to the RPC re constructor. The RPC server starts an I O completion thread at start up. This thread handles all the I O completion callbacks for all socket connections. If needed a thread pool can be used to do these operations.

The forwarder has an interface pointer to the RPC re constructor when a new client connects. This pointer is used as long as the client is connected. When data is received from the terminal server the forwarder forwards it to the re constructor through the pointer. Similarly when it completes sending data to the terminal server it notifies the re constructor that a send to terminal server has been completed. When the forwarder encounters any errors such as in sending receiving it dispatches a disconnect call to the re constructor which disconnects the client.

Continuing to refer to an overview on the class methods is revealed. The CClientProxyTransport includes several methods including Connect Disconnect SendData OnProxyDataAvailable and ReadData. Connect establishes a channel to the proxy authenticates and completes authorization. Disconnect notifies CProxyRawTrans to disconnect from the proxy. SendData forwards data from the transport stack to CProxyRawTrans object. OnProxyDataAvailable is called when data is available from the proxy. ReadData is called when transport stack needs RDP data. CProxyRawTrans includes several methods including CreateConnection ReadData WriteData and OnDataAvailable. CreateConnection establishes a secure HTTP connection to the proxy. ReadData is called when internal cache is depleted and transport stack is informed that data is available at the network layer. WriteData is called when transport needs to forward data to the proxy. OnDataAvailable called when network layer notifies the channel that data is pending to be read. CloseConnection is a proxy initiated action when terminal server disconnects.

Some performance optimizations are available for use in the multiple asynchronous model. For example eliminating the response bytes for the requests and piggy backing on them to receive data may increase performance. However this will increase code complexity. Additionally modifying the RPC runtime so that one asynchronous request can specify multiple asynchronous requests that the server will clone may increase performance. Further modifying the interface methods to eliminate returning error status and modifying some of the semantics of the asynchronous calls may increase performance.

There are there are three basic classes of solutions to the problem associated with TS farms. In one solution the RPC Re constructor Forwarder Service is moved in front of the TS Farm s load balancer. This solution will typically accommodate small to medium sized businesses. In a second solution each machine in the TS Farm is made addressable by the RPC HTTP proxy and a simple load balancing mechanism is created for proxy connections. In a third solution an attempt may be made to perform load balancing as a general feature to RPC HTTP.

In the implementation of the Get and Put channels are now reconstructed before the stream gets to the TS Farm and the TS Farm s load balancer is simply getting a standard RDP connection. A possible downside to moving the RPC Re constructor Forwarder service off the target Terminal Server is that the traffic must be forwarded through yet another machine.

More particularly shows an implementation wherein the RPC re constructor Forwarder is running on the same box as an RPC HTTP Proxy. The advantage to this solution is that it works in all configurations of the TS Proxy. The disadvantage is that one of the HTTPS channels must make an extra hop. 

One way to accomplish this is to create a new HTTP RPC Service that runs on the TS Session Directory. Thus the Session Directory in addition to each machine within the TS Farm must be addressable by the Proxies.

The TS Client would first connect directly to the Session Directory machine through HTTP RPC. This is easy to setup as the RPC HTTP proxy can allow machine name translation from a farm s virtual IP to the specific machine that the Session Directory is running on through the RPC HTTP Redirector facility . The new service would have a method to query to which machine a reconnection should be made. The logic for this service would simply be to look up the user s existing sessions in the farm and if there is no session to do a simple round robin load balancing.

Once the TS Client discovers the name of the particular machine to which to connect it fully disconnects and reconnects to the discovered machine and begins the session.

The advantage to this solution is that the RPC Re constructor Forwarder runs on the target Terminal Server so that performance is maximized because the Get and Put channel do not need to be forwarded to a separate machine . The disadvantage is that it potentially requires a company to change the way that their TS Farm is configured by making the individual Terminal Servers addressable by the Proxies.

With respect to the third solution an attempt may be made to perform better load balancing as a general feature to any RPC HTTP implementation.

In one implementation the URI will specify the location of the RPC proxy. RDP fields that are pertinent to the proxy client plug in are seen in the below table.

In order to specify the RPC mode of communication mulitple asynchronous asynchronous pipe or one RPC one must set a regkey in order for the client and server to instantiate the appropriate class. On the client machine set

Additional information may be useful when configuring computers for RPC over HTTP. To use HTTP as a transport protocol for RPC RPC Proxy running within Internet Information Server IIS must be configured on the server program s network. The following passage describes configuration options.

In a Windows environment IIS must first be installed on the machine running the RPC Proxy. Once IIS is installed the RPC Proxy is installed. Both IIS and the RPC Proxy can be installed simultaneously from Add Remove Windows Components in the Control Panel. RPC Proxy is installed from Networking Services and is called RPC over HTTP Proxy in Windows setup. If both IIS and RPC Proxy are installed at the same time Windows ensures they are installed in the proper order.

After installation of the RPC Proxy some additional configuration tasks must be performed. First open the IIS MMC snap in and configure the RPC Proxy virtual directory to require security as explained in RPC over HTTP Security. This step is required only if you plan to use RPC over HTTP v2. Second if IIS does not have a certificate installed a valid certificate must be obtained and installed for that computer in order to use SSL when communicating with the RPC Proxy. This step is relevant only for RPC over HTTP v2. Third set the ValidPorts key as described in RPC over HTTP Security. When these configuration tasks are completed the RPC over HTTP proxy is ready to forward requests from the RPC over HTTP client to the RPC over HTTP server.

The HTTPS Dual Channel solution is a preferred embodiment. However the dual channel HTTPS introduces a difficult problem at some point in the chain after the proxies the Get and Put channels need to be reconstructed into a single full duplex stream. If the Get and Put channels always arrived at the same exact proxy server this would not be difficult. However as soon as the two channels are split onto separate proxy servers reconstructing the two channels implies inter machine communication forwarding of the traffic .

Get and Put may be sent to different proxy servers because a corporation or other entity can definitely deploy more than one proxy for scalability reasons behind their firewall . The problem with this is with the load balancer logic that sits in front of the proxies. If it is doing simple round robin load balancing then the Get and Put channels are not guaranteed to arrive at the same proxy.

A simple work around to this could be to require IP affinity to be turned on at the load balancer such that all client connections with the same IP address are routed to the same proxy. This has two problems. First turning on IP affinity is not acceptable for many corporate deployments that do not use IP affinity today. The second issue is that IP affinity will only help if the IP address of the client is the same for the Get and Put channels. It is not the same in the case shown by .

A second work around besides IP affinity would be to serialize the connection of the two channels. For instance the Get channel could fully connect through the load balancer to a particular proxy server. Then a special message could be sent back on this channel to the client contain the IP address of the particular proxy rather than the load balancer IP address . The client could then initiate the connection for the Put channel and make it directly to the proxy IP address. This work around is unacceptable in some applications since it would require all proxy servers to have their IP addresses visible to the Internet not good because of the cost of additional IP addresses and the information disclosure .

Because the Get and Put channels cannot be forced to arrive on the same proxy server the traffic needs to be merged from the two channels in some fashion by forwarding the traffic from both channels to a particular server. As seen in the above discussion the RPC re constructor forwarder server can perform the merging. The RPC re constructor forwarder can be configured as the target terminal server one of the proxy servers or a new server. In operation the RPC HTTP server deals with dual channels by reconstructing the RPC at the target service.

Referring to an exemplary embodiment of a system configured for enabling terminal services through a firewall is seen. A client machine uses a network such as the Internet to communicate with a proxy server behind a firewall . The proxy server routes data to and from a terminal server on which the client machine has an open session. In the exemplary embodiment of the system a second firewall is between the proxy server and the terminal server . Accordingly the proxy server is located in a DMZ between firewalls and .

The client machine has a terminal server client process running. The terminal server client is configured to include a client plug in . The plug in is configured to wrap RDP remote desktop protocol that is native to the terminal server client with RPC remote procedure call . In a non Windows environment a client protocol could be used in place of RDP. The plug in is configured to access the RPC API and to pass and receive RPC wrapped data.

In response to the plug in the RPC API accesses the Win HTTP API . The Win HTTP API is configured to wrap or unwrap when reading data the RDP RPC with HTTPS. The resultant RDP RPC HTTPS is configured to move over the network through the firewall and to the proxy server .

The proxy server has an Internet information service configured to strip off the HTTPS protocol from the incoming data configured as RDP RPC HTTPS. An RPC HTTP infrastructure is configured to strip off the RPC protocol leaving the in coming data configured in an RDP protocol. The RDP wrapped data is passed to the service .

The RPC re constructor forwarder service is configured to re construct the incoming packets i.e. to organize them in their appropriate order. The service could be constructed according to and in particular with respect to the discussion of . The service also forwards data to a correct terminal server from among those available. Accordingly the client plug in and service allow the terminal server client to open a session on the terminal server and to access data and utilize applications according to the user s permissions. In a preferred embodiment the service is configured to send and receive data according to an asynchronous pipe mechanism although another mechanism such as a multiple asynchronous mechanism could be substituted.

Data transmitted from the terminal server to the terminal server client follows the reverse of the above described path. Data leaving the terminal server is received by the service which is in communication with the client plug in running on the terminal server client . The data moves to the RPC HTTP infrastructure where it is wrapped in RPC protocol. The data is then wrapped in HTTPS protocol at the Internet information service . Configured according to RDP RPC HTTPS the data moves through the firewall and over the network . Arriving in the client machine the HTTP API removes the HTTPS protocol. The RCP API communicates with the client plug in which strips off the RPC protocol allowing the terminal server client to process data in its native RDP protocol.

Exemplary methods for implementing terminal services through a firewall will now be described with primary reference to the flow diagrams of . The methods apply generally to the operation of exemplary components discussed above with respect to and particularly to . The elements of the described methods may be performed by any appropriate means including for example hardware logic blocks on an ASIC or by the execution of processor readable instructions defined on a processor readable medium.

A processor readable medium as used herein can be any means that can contain store communicate propagate or transport instructions for use by or execution by a processor. A processor readable medium can be without limitation an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or propagation medium. More specific examples of a processor readable medium include among others an electrical connection having one or more wires a portable computer diskette a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a rewritable compact disc CD RW and a portable compact disc read only memory CDROM .

At block data is wrapped with an RPC protocol. In the example of the plug in is configured to wrap the native RDP remote desktop protocol of the terminal server client with RPC remote procedure call protocol thereby resulting in data configured as RDP RPC.

At block the wrapped data is passed through a firewall. In a typically implementation seen in the client plug in will call a Win HTTP API to wrap the RDP RPC data as RDP RPC HTTPS so that it can traverse the firewall.

At block the RPC based protocol is removed from the data and the packets are re configured according to their intended order. Referring again to if the data is moving from the client the service is configured to remove the RPC based protocol revealing the underlying RDP protocol. The service also reconfigures the packets in their correct order. If the data is moving from the server the client plug in removes the RPC based protocol.

At block where the data is moving from the terminal server client to the terminal server the data is routed within the stream based protocol to an appropriate server. Alternatively at block if the data is moving from the terminal server to the terminal server client then the data is displayed as screen information on the client machine.

At block terminal server protocol is layered over RPC HTTPS protocol. In the example of block the terminal server protocol is RDP remote desktop protocol . At block the plug in and a service communicate. The communication assists in the transfer of data between the terminal server client and the terminal server . At block the communication is configured as an asynchronous pipe mechanism. At block the screen data is moved between the terminal server client and a proxy server located inside the firewall using the RPC API.

At block data sent between the client plug in and the service is wrapped with a first layer of protocol to provide access to tools and a second layer of protocol to provide security. In one example wrapping the data with RPC allows the client plug in to access the RPC API and avail itself of the tools provided by that resource. At block the API could be utilized to wrap the terminal server protocol in RPC HTTPS. This second layer of protocol provides security as the data moves through the firewall at block . Once on the inside of the firewall the packets constituting the data are reconstructed in their intended order. This is typically performed by the service .

At block the commands used to move the data such as Get and Put commands are sent according to an asynchronous pipe mechanism. At block in the asynchronous pipe mechanism a singe packet of data is associated with each send call but a receive call is associated with a plurality of packets.

At block the Get and Put channels that do not arrive on the same proxy server are merged such as by operation of the service e.g. service of on the proxy server. At block the packets sent through the firewall are reconstructed. The reconstruction may be performed by the service on the proxy server.

While one or more methods have been disclosed by means of flow diagrams and text associated with the blocks of the flow diagrams it is to be understood that the blocks do not necessarily have to be performed in the order in which they were presented and that an alternative order may result in similar advantages. Furthermore the methods are not exclusive and can be performed alone or in combination with one another.

The computing environment includes a general purpose computing system in the form of a computer . The components of computer can include but are not limited to one or more processors or processing units a system memory and a system bus that couples various system components including the processor to the system memory . The system bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus a Peripheral Component Interconnect PCI bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures.

Computer typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer and includes both volatile and non volatile media removable and non removable media. The system memory includes computer readable media in the form of volatile memory such as random access memory RAM and or non volatile memory such as read only memory ROM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently operated on by the processing unit .

Computer can also include other removable non removable volatile non volatile computer storage media. By way of example illustrates a hard disk drive for reading from and writing to a non removeable non volatile magnetic media not shown a magnetic disk drive for reading from and writing to a removable non volatile magnetic disk e.g. a floppy disk and an optical disk drive for reading from and or writing to a removable non volatile optical disk such as a CD ROM DVD ROM or other optical media. The hard disk drive magnetic disk drive and optical disk drive are each connected to the system bus by one or more data media interfaces . Alternatively the hard disk drive magnetic disk drive and optical disk drive can be connected to the system bus by a SCSI interface not shown .

The disk drives and their associated computer readable media provide non volatile storage of computer readable instructions data structures program modules and other data for computer . Although the example illustrates a hard disk a removable magnetic disk and a removable optical disk it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes or other magnetic storage devices flash memory cards CD ROM digital versatile disks DVD or other optical storage random access memories RAM read only memories ROM electrically erasable programmable read only memory EEPROM and the like can also be utilized to implement the exemplary computing system and environment.

Any number of program modules can be stored on the hard disk magnetic disk optical disk ROM and or RAM including by way of example an operating system one or more application programs other program modules and program data . Each of such operating system one or more application programs other program modules and program data or some combination thereof may include an embodiment of a caching scheme for user network access information.

Computer can include a variety of computer processor readable media identified as communication media. Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

A user can enter commands and information into computer system via input devices such as a keyboard and a pointing device e.g. a mouse . Other input devices not shown specifically may include a microphone joystick game pad satellite dish serial port scanner and or the like. These and other input devices are connected to the processing unit via input output interfaces that are coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB .

A monitor or other type of display device can also be connected to the system bus via an interface such as a video adapter . In addition to the monitor other output peripheral devices can include components such as speakers not shown and a printer that can be connected to computer via the input output interfaces .

Computer can operate in a networked environment using logical connections to one or more remote computers such as a remote computing device . By way of example the remote computing device can be a personal computer portable computer a server a router a network computer a peer device or other common network node and the like. The remote computing device is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer system .

Logical connections between computer and the remote computer are depicted as a local area network LAN and a general wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet. When implemented in a LAN networking environment the computer is connected to a local network via a network interface or adapter . When implemented in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the wide network . The modem which can be internal or external to computer can be connected to the system bus via the input output interfaces or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link s between the computers and can be employed.

In a networked environment such as that illustrated with computing environment program modules depicted relative to the computer or portions thereof may be stored in a remote memory storage device. By way of example remote application programs reside on a memory device of remote computer . For purposes of illustration application programs and other executable program components such as the operating system are illustrated herein as discrete blocks although it is recognized that such programs and components reside at various times in different storage components of the computer system and are executed by the data processor s of the computer.

Although aspects of this disclosure include language specifically describing structural and or methodological features of preferred embodiments it is to be understood that the appended claims are not limited to the specific features or acts described. Rather the specific features and acts are disclosed only as exemplary implementations and are representative of more general concepts.

