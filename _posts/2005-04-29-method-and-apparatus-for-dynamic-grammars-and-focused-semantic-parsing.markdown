---

title: Method and apparatus for dynamic grammars and focused semantic parsing
abstract: The present invention provides a dialogue system in which semantic ambiguity is reduced by selectively choosing which semantic structures are to be made available for parsing based on previous information obtained from the user or other context information. In one embodiment, the semantic grammar used by the parser is altered so that the grammar is focused based on information about the user or the dialogue state. In other embodiments, the semantic parsing is focused on certain parse structures by giving preference to structures that the dialogue system has marked as being expected.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07555426&OS=07555426&RS=07555426
owner: Microsoft Corporation
number: 07555426
owner_city: Redmond
owner_country: US
publication_date: 20050429
---
The present application is a divisional of and claims priority from U.S. patent application Ser. No. 09 934 313 filed on Aug. 21 2001 and entitled METHOD AND APPARATUS FOR DYNAMIC GRAMMARS AND FOCUSED SEMANTIC PARSING.

The present invention relates to methods and systems for parsing text. In particular the present invention relates to semantic parsing of text.

Nearly all modern computer interfaces are based on computer driven interactions in which the user must follow an execution flow set by the computer or learn one or more commands exposed by the computer. In other words most computer interfaces do not adapt to the manner in which the user wishes to interact with the computer but instead force the user to interact through a specific set of interfaces.

New research however has focused on the idea of having a computer user interface that is based on a dialogue metaphor in which both the user and the computer system can lead or follow the dialogue. Under this metaphor the user can provide an initial question or command and the computer system can then identify ambiguity in the question or command and ask refining questions to identify a proper course of action.

Note that during the refinement the user is free to change the dialogue and lead it into a new direction. Thus the computer system must be adaptive and react to these changes in the dialogue.

The performance of such systems is dependent on the system s ability to quickly determine the user s goal. The longer it takes the system to understand the user s goal the more frustrating it is for the user.

One obstacle to quickly understanding the user s goal is the richness of human language which can cause strings of text to be associated with a large number of different semantic tags. This makes it difficult to identify the goal of the user because often there will be ambiguity about the semantic meaning of what the user has said. Thus improvements are needed in dialogue systems to reduce the ambiguity associated with performing semantic parses of text especially speech based text.

The present invention provides a dialogue system in which semantic ambiguity is reduced by selectively choosing which semantic structures are to be made available for parsing based on previous information obtained from the user. In one embodiment the semantic grammar used by the parser is altered so that the grammar is focused based on information about the user or the dialogue state. In other embodiments the semantic parsing is focused on certain parse structures by giving preference to structures that the dialogue system has marked as being expected.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral. Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is preferably allocated as addressable memory for program execution while another portion of memory is preferably used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is preferably executed by processor from memory . Operating system in one preferred embodiment is a WINDOWS CE brand operating system commercially available from Microsoft Corporation. Operating system is preferably designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device within the scope of the present invention.

Under one embodiment of the invention the components of are located within a personal computer system such as the one shown in or a mobile device such as the one shown in . In other embodiments the components are distributed across a distributed computing environment and connected together through network connections and protocols. For example the components could be distributed across an intranet or the Internet.

In the dialogue system receives speech input from the user through a speech interface . Speech interface converts the speech signal into a set of digital values that represent the speech signal. These digital values are provided to a speech recognition engine which uses one or more models to identify a set of text that is most likely represented by the speech signal. Such speech recognition engines and models are well known in the field of speech recognition.

Those skilled in the art will recognize that although a speech input is shown in the present invention is not limited to speech inputs and may be used with direct text inputs.

The text generated by recognition engine is provided to a dialogue manager which is responsible for interacting with the user to identify the user s goal. In particular the text is provided to a spoken language understanding SLU unit within dialogue manager .

SLU constructs semantic parse structures from the text using a context free grammar and a semantic description language SDL grammar . SDL is a language independent grammar used to define the domain knowledge of entity relationship. An entity in SDL may correspond to several non terminals in the semantic context free grammar. The CFG non terminals define the linguistic expressions for the entity. Under one embodiment context free grammar consists of non terminals that are invoked by one or more rules. Each rule consists of a series of one or more non terminals and or words. Initially SLU uses context free grammar to identify surface semantics for the text by identifying non terminals that are fully represented by the text. These non terminals are then abstracted by the parser according to the semantic description language to build the language independent semantic entity structure which provides descriptions of possible semantic structures that can be built from the surface semantic non terminals.

The word in the candidate list is popped or removed from the candidate list by a rule engine . Rule engine uses the popped word to access context free grammar to identify non terminals that are activated by the promoted word. A non terminal is said to be activated by a word or other non terminal when the word or other non terminal is the first child node in the definition of the non terminal. In a left to right parser the first child node is the left most child. For example the non terminal is defined as where is the left most child node and is the right most child node.

If the activated non terminal is only partially defined by the current word a partial parse of the non terminal is formed and is added to a chart . If the activated non terminal is fully defined by the current word the non terminal is placed in the chart and candidate list .

The word from the candidate list is also compared to partial parses in chart to determine if the partial parses can be extended by the popped word. Partial parses that can be extended but not completed by the word are extended to generate new partial parses that are placed in chart . Partial parses that are completed by the word result in full parses that are placed in the chart and candidate list .

Under many embodiments before a non terminal is placed in candidate list it is scored by a metric calculator based on some scoring metric. Under one embodiment the scoring metric is based on the number of words covered by the non terminal the number of levels of non terminals formed beneath the non terminal and the total number of non terminals beneath the non terminal. The score provided to a non terminal is used to order the non terminals in candidate list so that non terminals that are more likely to appear in the final parse are popped before other non terminals.

Rule engine removes the non terminals placed in the candidate list one at a time. For each non terminal rule engine determines if another non terminal is activated by the popped non terminal according to context free grammar . Rule engine also determines if any partial parses in chart can be extended based on the popped non terminal. It then updates the chart and candidate list. This continues until all of the non terminals have been removed from the candidate list. At that point the next word in the text segment is added to the candidate list.

During this process if a non terminal is popped from the candidate list and it does not activate another non terminal or extend a partial parse it is marked as a full parse. When all of the words of the text segment have been processed the full parses with the highest score that have been popped from the candidate list are mapped to semantic structures in the semantic description language grammar . These SDL structures are then provided to a discourse engine as the semantic markup of the text.

In order to cover the different phrases a user may utter context free grammar includes a large number of non terminals. Because of this a number of different semantic parse structures can be generated from a single speech utterance. Embodiments of the present invention provide means for controlling the construction and selection of semantic parse structures so that the complexity of parsing is reduced. These techniques are discussed further below.

The semantic parse structures generated by SLU are used by discourse engine to extend past partial semantic structures if any that were formed from previous text segments. Discourse engine then attempts to collapse the semantic structures from the bottom up. To begin to collapse a discourse semantic structure discourse engine looks at each bottom level semantic non terminal to determine whether it has enough information about the non terminal to identify a single entity that can replace the non terminal. In this context an entity is an entry in one of a set of domain tables that are accessed by one or more domain experts . The domain experts identify which table needs to be accessed and updated and handle the overhead and protocols associated with accessing the tables.

For example to collapse a Person non terminal which is a general representation of a person discourse engine attempts to find a single person that meets the values parsed beneath the Person non terminal. To do this discourse engine passes the values parsed for the Person non terminal to a domain expert that specializes in identifying people from such values. For example domain expert can access a domain table that lists people and certain attributes associated with those people. It then locates all people who satisfy the values for the person non terminal. If only one such person is found the Person non terminal is collapsed and replaced by a unique identifier for the person. This identifier then becomes a value for the non terminal located above the person non terminal. If more than one person is found an ambiguity is established that must be clarified by dialogue manager .

After the semantic structures have been collapsed as far as possible the semantic structures and ambiguities identified by discourse engine are passed to a rendering engine which applies the semantic structures and the ambiguities to a behavior model . Behavior model determines the cost of taking various actions given the current set of semantic structures and ambiguities.

The cost of different actions can be calculated based on several different factors. For example since the usability of a dialogue system is based in part on the number of questions asked of the user one cost associated with a dialogue strategy is the number of questions that it will ask. Thus an action that involves asking a series of questions has a higher cost than an action that asks a single question.

A second cost associated with dialogue strategies is the likelihood that the user will not respond properly to the question posed to them. This can occur if the user is asked for too much information in a single question or is asked a question that is too broadly worded.

Based on the calculated costs rendering engine selects an action. Often times this involves sending a response to the user through a user output interface .

As mentioned above the present invention reduces the complexity of generating semantic structures for user input. Under one embodiment this is achieved by parsing with focus.

When parsing with focus SLU gives preference to a semantic structure that has been previously identified as being likely given the current dialogue state. In particular SLU gives preference to a semantic structure path stored in a parse focus by discourse engine .

For example if a user first utters I want to schedule a meeting dialogue manager will not know when to schedule the meeting. Therefore rendering engine will have to ask a follow up question such as On what date Since the answer to this question will likely be a date discourse engine sets the semantic path stored in parse focus to . This path indicates that a token or semantic class that satisfies the or semantic classes without providing excess information should be parsed only as part of the semantic class.

For example if the user responds with on Tuesday the semantic class will be satisfied with Tuesday s date. However the semantic class can be used in a large number of semantic structures such as 

To avoid this SLU uses the parse focus to limit the structures it returns to discourse engine . As such SLU would only return the parse structure 

Note that parsing with focus can accommodate additional information provided by the user. Thus if the user responds with on Tuesday at 3 pm with John rule engine will generate a list of satisfied non terminals that includes on Tuesday at 3 pm with John . Since these additional non terminals are alternative child non terminals for the non terminal rule engine will return 

Thus by focusing the parse based on a past dialogue state the present invention reduces ambiguity in the parse and thus improves the performance of the dialogue system by reducing the number of questions that must be posed to the user to identify the user s goal.

In other embodiments the complexity of the semantic parse is reduced by making the SDL grammar and the CFG grammar dynamic. In such embodiments applications of are able to activate deactivate add and or remove entire non terminals or individual rules for non terminals. When working with an entire non terminal the dialogue system treats any child non terminals that are unique to the non terminal as being part of the non terminal. Thus when a parent non terminal is removed by an application child non terminals that are unique to that parent non terminal are automatically removed by the dialogue system. When working with individual rules the dialogue system affects the rule without having to remove or add a non terminal. Thus the dynamic grammar of the present invention gives applications a great deal of power and flexibility to change the SDL grammar and CFG grammar so that the semantic parsing is more efficient.

For example an application can make semantic parsing more efficient by changing the grammar based on the tasks that the user is likely to be performing. For instance if a user is composing a new e mail the application can change the rules associated with the non terminal so that the rules only include names that the user can specify as recipients i.e. names for which the application has an e mail address . However if the user is adding names to a contact list the rules associated with the non terminal should be expanded to include common first and last names.

Similarly the SDL grammar and CFG grammar can be altered based on the user. For example different users can have different contact lists. As such the rules of the non terminal can be changed so that they include the names of the current user s contact list.

Under some embodiments of the present invention a set of Application Programming Interfaces API s are provided that allow applications to request changes in the SDL and or CFG grammars. API s include methods that allow applications to activate and deactivate individual rules associated with a non terminal activate deactivate methods to insert and delete non terminals insertNonTerminal deleteNonTerminal a method to remove all rules for a non terminal clearNonTerminalRules methods to insert and remove individual rules for a non terminal insertNonTerminalRule removeNonTerminalRule a method to import non terminals from a different grammar importGrammar a method to import a grammar while first voiding non terminals in the original grammar if similarly named non terminals appear in the imported grammar importNreplaceGrammar and a method of forming a new grammar by merging two grammars together merge .

The activate and deactivate methods take a non terminal as an argument and activate or deactivate the rules associated with that non terminal.

The insertNonTerminal method takes the name of the non terminal to be created and returns a pointer to the newly created non terminal object. The deleteNonTerminal method takes the name of the non terminal to be removed as input and deletes the non terminal. In some embodiments deleteNonTerminal also deletes any rules or child non terminals that are unique to the target non terminal. For example for a non terminal which is defined as 

The clearNonTerminalRules method takes a pointer to a NonTerminal object as input. This pointer can be obtained using a GetNonTerminal method which returns a pointer to a NonTerminal object based on a name for the nonterminal. Using the clearNonTerminalRules method all of the rules defined below the non terminal are removed from the definition of the non terminal. However the non terminal remains in the grammar. The clearNonTerminalRules method is a simple method for resetting a non terminal before redefining the non terminal.

If the application does not want to remove all of the rules associated with a nonterminal it can use the removeNonTerminalRules method which takes a pointer to the nonterminal object and a string representing the rule to be removed as input. For example removeNonTerminalRules NAMES Joe would cause the rule Joe to be removed from the non terminal defined above without affecting the Peter or Bill rules. The insertNonTerminalRule method allows applications to insert a single rule for a non terminal. To insert a rule the application provides a pointer to the nonterminal object and a text string representing the rule to be inserted.

The importGrammar method and the importNreplaceGrammar method both take a filename containing the grammar to be imported as input. In some embodiments an additional boolean input value is provided to indicate whether the imported grammar is of a particular format. The merge method takes a pointer to a CFG grammar object as input and combines it with the grammar that makes the merge call.

Although the present invention has been described with reference to preferred embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention. In particular although the invention has been described above with reference to tree structures any suitable data structure may be used and the invention is not limited to a tree based structure.

