---

title: Methods and apparatus for digital data processing with mutable inheritance
abstract: A method of automated workflow processing includes transforming an object, A1, which is of class X, into an object which is of class Y. The method includes the steps of separating existing data elements of A1 from the object itself, generating new data elements corresponding to class Y, inserting the new data elements into object A1, and computing values for the new data elements, possibly based on values of the old data elements. Other objects that referred to A1 before the transformation continue to do so afterwards. Values of data elements prior to transformation can be preserved, e.g., to facilitate review, to facilitate further transformation, and/or to facilitate back transformation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07711919&OS=07711919&RS=07711919
owner: Pegasystems Inc.
number: 07711919
owner_city: Cambridge
owner_country: US
publication_date: 20050812
---
This application is a continuation of U.S. patent application Ser. No. 10 430 693 filed May 6 2003 now U.S. Pat. No. 6 976 144 entitled Methods and Apparatus for Digital Data Processing With Mutable Inheritance the teachings of which are incorporated herein by reference.

The invention pertains to digital data processing and more particularly to methods and apparatus for implementation of object oriented programming OOP objects. The invention has application by way of non limiting example in the design and implementation of Business Process Management BPM systems including by way of non limiting example workflow applications

The popularity of languages like C and Java and of programming design methodologies like Booch and UML is in large part due to the object oriented programming paradigm supported by these systems. Of late these methodologies have been extended from more conventional programming languages to mark up languages such as XML which permit ready definition of structured documents that are easily transmitted over networks such as the Internet and that can contain object like data.

Objects are a very natural and intuitive way to model complex systems they correspond closely to the way human domain experts think about a particular application. In general objects typically correspond to nouns the relevant things for a particular application. Attributes of the objects correspond to adjectives that provide details about the objects and methods of the objects correspond to verbs that change the state of the object. This sort of correspondence supports rapid development of complex systems often by individuals who are domain experts more than they are programmers.

An example domain area where the object oriented paradigm has been used extensively is workflow applications where work items resources and constraints are modeled as objects. Workflow applications typically require modeling complex business processes. Such modeling requires sophisticated data structures in order to adequately represent all the relevant information. Such applications are characterized by large numbers of classes deep class hierarchies and intricate links between associated object instances.

One important characteristic of workflow applications is that they are very dynamic the information associated with a work item changes significantly as the work item is passed from operation to operation in the business process. Such information changes can be frequent as the business process may be very detailed and many enterprises have near real time performance of such transactions as a goal.

Typically a work item is represented using a very simple object that contains information like the work item s ID its due time etc. All other information e.g. pertaining to the work item s ever changing states is represented in objects that are related to the work item. This is a perfectly valid approach under the object oriented programming paradigm. However it does lead to a lot of complexity as there may be a large number of objects related to the work item in intricate or indirect ways. This can present a problem for a programmer attempting to model the work item and the workflow of which it is a part.

In view of the foregoing an object of this invention is to provide improved methods and apparatus for digital data processing and more particularly for example for modeling and processing workflows.

A related object of the invention is to provide methods and apparatus for improved implementation of object oriented programming OOP objects.

A further object is to provide such methods and apparatus as can be implemented in any variety of programming languages and or on any variety of platforms.

A still further object is to provide such methods and apparatus as simply the modeling of workflows or other processes that utilize items of changing state.

The foregoing are among the objects attained by the invention which provides in one aspect methods of transforming an object A1 which is of class X into an object which is of class Y. The methods automatically maintains appropriate relations of object A1 with referring objects so that those objects that referred to A1 before the transformation still refer to it afterwards. The methods further include updating of data attributes of A1 during the transformation based on data attribute values before the transformation and based on the class definitions of X and Y.

Such a method according to one aspect of the invention comprises instantiating an object A of class X by i allocating memory for a header of object A and ii allocating memory for one or more data elements inherited from class X that are associated with object A and or one or more method members inherited from class X and associated with object A. The method further includes responding to an object transformation request by allocating memory for one or more data elements inherited from of class Y which are absent from class X and associating those data elements with said header of object A.

Related aspects of the invention provided such a method that includes the step of defining values for said data elements inherited from class Y as a function of any of one or more values of data elements of object A inherited from class X and or one or more default values. A transformation function can be employed for generating values for the data elements inherited from class Y as a function of one ore more values for the data elements inherited from class Y as a function of one or more values of data elements of object A inherited from class X.

Such a transformation function can be implemented by utilizing procedural programming techniques. Alternatively or in addition it can be implemented using declarative rules i.e. rules mapping from a set of input variables to an output variable. Thus for example a transformation function according to one aspect of the invention can include one or more such declarative rules each of which provides a mapping from one or more data elements of object A from class X to a data element inherited from class Y.

Other aspects of the invention provide methods for automatically reclaiming memory originally allocated for data attributes of class X that are no longer needed after A1 is transformed into an object of class Y.

Still other aspects of the invention provide methods as described above in which class Y multiply inherits from classes Y Y where m is an integer greater than or equal to one. The object A1 is transformed into an instance of class Yand subsequently modified to inherit from each of classes Y YAccording to still other aspects of the invention the class X multiply inherits from classes X X where n is an integer greater than or equal to 0 . The method further includes removing from object A1 inheritance from any class X Xthat is not in Y Y.

Further aspects of the invention provide methods of modeling workflow paralleling the above. According to these methods the class of an object corresponding to a work item is transformed e.g. from Class X to Class Y and so forth in order to model changing states of the work item itself.

In other aspects the invention provides a method of transforming an object A1 of class X to an object of class Y in which the values of data elements associated with object A1 prior to transformation are preserved. This preserved data can be employed for review purposes by a workflow architect i.e. the business process management professional who models the workflow e.g. using systems and methods according to the invention or others. The preserved data can also be utilized to facilitate further transformations of object A1 e.g. from class Y to class Z. The preserved data can also be used for reverse transformations of the object. For example in a reverse transformation of object A1 form class Y to class X the preserved data can be employed to re create original data values of A1 and or to generate new such values e.g. as combinations of the original values and the current values i.e. those values that A1 has when it is of class Y .

These and other aspects of the invention are evident in the drawings and in the description that follows.

Illustrated processing center represents a service provider or other entity that utilizes work item routing. Non limiting examples include retailers mail order houses professional service providers counseling centers and help bureaus and so forth. While work item typically refers to tasks processed by the resources or to which resources may be allocated as used herein the term refers to tasks products customer or other things for processing by the resources or to which resources may be allocated.

With continued reference to the illustrated work items comprise customer requests that require routing or assignment to employee agents of the processing center . More generally the illustrated agents represent any resource to which the work items may be allocated. This can include human resources business resources environmental resources energy resources consumable resources or otherwise. The illustrated work items here customer requests are subject to intake processing e.g. by intake processing personnel and then are passed to digital data processor A for routing to the agents or other resources .

Digital data processor A as well as any other digital data processors in the illustrated embodiment or otherwise implements OOP objects to model work items. One such object labeled as object is shown by way of example in . The object is defined instantiated and used in the conventional manner known in the art as modified in accord with the teachings below. That object may be utilized in any module that forms part of the illustrated workflow application or in any other application. One such module labeled as processing module is shown by way of example in . Though the module and the object are referred to in the singular it will be appreciated that one or more such modules and objects may be utilized in systems and method according to the invention. Moreover though the discussion focuses on modeling of work items it will be appreciated that the teachings hereof are applicable to other OOP objects whether they model other entities or otherwise

Illustrated object changes class as the work item it models transitions from state to state during routing and or processing by the service center . This permits the object to efficiently accommodate additional or different information relevant to each state. For example on intake the module may instantiate object from a class Intake. The object inherits from that class data and method members necessary to model the intake process. This includes data members like customer I.D. problem description etc. and method members like display intake screen generate routing etc.

Once intake processing is completed the object is transformed to a class that reflects the specific type of the work item and that contains data and method members appropriate to its processing. This may be for example the class Service Request that too has customer I.D. and problem description data members but that also has a service technician I.D. and return authorization code data members. During transformation of the object values for the first two members may be based on e.g. copied or computed from the same named members of the prior class while values for the new data members are assigned default values. The new data members may also take values based on data members of the prior class and or on external data e.g. data input from the user records in a database or otherwise . As a consequence of transformation the object also inherits method members appropriate to processing of a service request like assign service technician problem knowledgebase lookup etc.

If the service request is resolved by the technician the object may be transformed to a Request Satisfied class. This too might have customer I.D. service technician I.D. and problem resolution data members values which are copied on transformation from the Service Request class object. It may also have a problem resolution data member. Method members inherited from the new class may include enter problem resolution and close  matter the former which facilitates entry of the problem resolution into a knowledge database and the latter which creates and archives entry for the object.

In the illustrated embodiment each class from which a mutable object may be instantiated or otherwise inherit is provided with a method that is not known in the art and that is referred to here as a transformation constructor. As the object transforms from class to class the constructor populates data members of each new class the to class based on values of corresponding variables from the prior class the from class . Where necessary the constructor also updates run time references to the from class form of the object i.e. references made by other runtime objects in the workflow application to the from class form of the object to refer to the to class form.

The transformation constructor can be implemented as a method of the to class taking as a parameter the object which is an instantiation of the from class . In alternative embodiments the constructor is implemented as a member of the from class taking as an input parameter an identifier of the to class and returning a pointer variant object or otherwise representing the transformed object. Those skilled in the art will appreciate that transformation is merely label and that constructors named otherwise may be used instead. Moreover those skilled in the art will appreciate that the functionality ascribed herein to the transformation constructor may instead or in addition be implemented in other method members of the subject object s in subroutines or functions or otherwise.

Continuing the above example transformation constructors provided for each of the Service Request and Request Satisfied classes can effect transformations of the object to each of those respective classes as illustrated in the pseudo code sequence below 

Advantages of the illustrated embodiment are readily evident in the excerpt above. For example notwithstanding that the object s type changes with each call to the transform object method it may continually be referred to in the source code by the same name here work item Moreover relevant data is carried forward with the object even as it changes form. Still further run time references are automatically updated so that other runtime objects that referred to the from class form of the object refer to the to class form without need for source code intervention.

In a typical object oriented programming language like Java or C when a method is called the method definition code is found by searching the inheritance tree beginning with the class for the instance on which the method is called and walking up to successive super classes in the inheritance tree until the method definition is found. Thus the most specific method defined for the instance will be used.

The situation is more complicated with a transformation constructor because there are two relevant classes the current class of the object instance and the new class into which the instance will be transformed. To accommodate this the transformation constructors use a table as defined below to determine a sequence of transformations in going from the current class to the new class 

The rows of the table correspond to the from class and the columns to the to class. The cells indicate the transform constructor definition if there is one. The diagonal is always blank as no transformation is necessary for going to the same class. Other cells may be blank as well e.g. if transformation for that combination of from and to classes is not permissible.

The table can be accessed directly by the transformation constructor source code though preferably it is executed through code incorporated by a compiler or pre compiler. Moreover while the illustrated table is intended for use at runtime other implementations may make use of such a table at compile time and or may implicitly represent the table e.g. in overloaded methods of the to and or from classes.

Where there is an inheritance hierarchy among the classes identified in the table e.g. as shown in the transformation constructors traverse in order to find the most specific match. Such a hierarchy can be represented in tables generated by the compiler runtime environment or otherwise in the usual manner. Traversal is also accomplished in the usual manner.

where E1 is an instance of class E. The above table does not indicate a definition for a transform constructor from classes E to F but it does indicate one for transformation from classes E to C. Since C is the parent of F in the class hierarchy as shown in it can be applied in a manner similar to the way that inherited methods are applied in ordinary object oriented programming.

However because two classes are involved there is potential for confusion in determining the correct transform constructor to apply in a particular situation. For example suppose that module calls for transformation of object E1 of class E to an object of class F and no transform constructor is defined for E to F but ones are defined from B to F and from E to C. To determine which of these transformations to use code included in the transformation constructors of the illustrated embodiment impose the following additional precedence rules 1 when searching the class hierarchy for a transform constructor to apply begin by searching up the class hierarchy from the from class 2 use the most specific transform constructor found in this search that has a to class that is an ancestor of the required to class. Thus the transformation from B to F is used.

Operation of the transformation constructors may be further appreciated by introducing a computational model that describes system behavior. Such a computational model is not specific to any implementation language it specifies behavior and requirements for a more detailed implementation. The following description of the computational model is preceded by a set of definitions of common terms.

The following definitions are based on standards and conventions used in most popular object oriented programming languages such as Java or C but they do not suggest or require any specific implementation. These definitions will be used in the subsequent presentation of the computational model.

Class a type specification for a structured data collection called an object. The type specification is represented as a set of elements. A class has a unique name that distinguishes it from other classes and objects.

Element a class member that has a name as well as information associated with that name. There are two types of elements data elements and methods. A data element contains a data type specification and a data value. For elements that are part of a class specification this value is a default value the initial value for the element when an object of the class is instantiated . A method element contains a reference to a function as well as type specification information for the parameters of the function and the values returned by the function. Object a structured data collection containing a set of elements and some other information. An object is created or instantiated according to a specification from a particular class. A possible implementation of such an instantiation would be to simply copy the elements of the class to the object. An object maintains a reference to its associated class. An object is also given a unique name its name is different from that of any other object regardless of class. The object is given the name when it is instantiated. An object may also be deleted at which time its resources memory used and unique id are recycled to pools from which they may be re used. Inheritance A class may define its own elements. A class may also optionally have a superior class from which it inherits elements. Thus when an object of the class is instantiated it will have elements defined by its associated class as well as elements inherited from the class superior class if such a superior class exists. If an element defined for a class has the same name as an element inherited by the class the element defined for the class is used and the inherited element is ignored. Multiple Inheritance An extension of inheritance is multiple inheritance. Here a class may have one or possibly multiple superior classes. The class inherits elements from all of these. Element name conflicts are resolved according to the order of specification of superior classes. Computational Model Data access and set methods

An object can be created instantiated using a global create method that takes as parameters the class and the name for the object. Optionally data element name value pairs can be included as parameters to this method for the purpose of initializing the named data elements to the values as long as these values are consistent with the class specified data types for the data elements. Also optionally constructor methods that take zero or more arguments can be specified at the class level. The constructor methods are invoked after memory for the object is allocated and its data elements are initialized to their default values.

An object can be deleted using a global delete method that takes as parameter the name of the object. When an object is deleted its resources allocated memory and unique id are recycled to pools from which they may be re used. It is the responsibility of the developer to delete any outstanding references to this object from other objects for example .

The capabilities described so far in connection with the above summary definitions are typical of most object oriented programming systems. The following are transformation capabilities taught by the present invention 

Transform object is a method that can be defined for any class. It is a static method in that it is associated with the class and not with a particular instance. It takes a single parameter namely an object to be transformed. The method can be overloaded based on its signature based on the from class . For example 

is a method that converts an object of class WorkItem into an object of the more specific class SalesWorkItem. Similarly 

converts an object of class WorkItem into an object of class TechSupportItem. The transformation is often from a general class in an inheritance hierarchy to a more specific class but this is not necessarily always the case. For example the following overloading of the Transform object method for SalesWorkItem provides for transformation of a TechSupportItem into a SalesWorkItem. SalesWorkItem.Transform object TechSupportItem WI1 

This would be useful for example if the tech support department determines that the problem can be solved by buying a particular new component.

In preferred embodiments of the invention a Transform object method according to the teachings of the invention can perform the following computations for transforming an object of a given class to an object of a different class 

 a In an initial step the method generates a separate copy of the element set of the object to be transformed. This copy is bound to a local variable old instance element set whose scope is local to the Transform object method. A local context is also set up so that within the scope of the Transform object method elements from this set can be accessed using the syntax old instance.. This also means that any rules invoked within the context of the Transform object method can make such references. Note that in this embodiment old instance is a reserved word.

To better illustrate the above step a performed by a Transform object method consider an exemplary object shown schematically in having a header which includes among other attributes an object identification field that contains information for uniquely identifying the object. In addition to the header the exemplary object further includes an element set that contains a plurality of data elements and method members associated with the object . By way of example the data elements associated with the object can provide pointers each index by an attribute name that refer to selected data corresponding to a customer. For example the illustrated data elements which relate to a customer named John Smith provide information regarding the customer s age address assets liabilities and employer. The data elements indexed by attribute names Asset and Liabilities refer to sub objects while the data element index by the attribute name Employer refers to a related object. It should be understood that a variety of data structures known in the art e.g. arrays linked lists can be employed for representing the data elements associated with an object.

With reference to a Transform object method operating on the above exemplary object generates a copy of the data elements associated with the object sub objects are copied while references to related objects and not the related objects themselves are copied and binds the copy to the local variable old instance element set.

 b Subsequently the Transform object method reclaims memory allocated for the element set of the object to be transformed. In other words the method deletes the element set of the object to be transformed but not the object itself and recycles memory allocated for this element set. Note however that the object itself is not deleted. In fact it retains its name and its reference to its original class. Thus references to it are still valid. The object simply happens to have an empty element set.

For example with reference to the memory associated with the original data elements of the above exemplary object is reclaimed while the memory allocated for the object s header and the association of the object with its header are preserved.

 c The Transform object method then creates a new element set for instance based on a new class. The new element set can be created in exactly the same way as a new element set for a new object of the new class. For example default values specified by the new class for selected data elements can be used. This element set can be bound to a local variable new instance element set whose scope is local to the Transform object method. A local context is also set up so that within the scope of the Transform object method elements from this set can be accessed using the syntax new instance. . This also means that any rules invoked within the context of the Transform object method can make such references. Note that in this embodiment new instance is a reserved word.

For example referring to in the case of the above exemplary object the Transform object method generates a new element set and associates the object with this new element set.

 d The Transform object method then executes workflow architect defined code that forms the body of the method. Such code would typically use old instance and new instance references to assign appropriate data values to data elements of the new instance based on data values from appropriate data elements in the old instance. For example typical data element transformations might be

For example referring to the Transform object method defines values for the new data elements associated with the above exemplary object as a function of a one or more default values or b one or more values of the copied data elements of object inherited from the original class which are bound to the local variable old instance element set. In some embodiments a set of pre defined transformation procedures and rules can be employed to define values of one or more new data elements as a function of the copied data elements.

 e On exit the Transform object method can delete the element set referred to by the local variable old instance element set. Memory used for this element set can then recycled.

There are a number of important differences between a transform object method of the invention as described above and a copy constructor utilized in C or Java. For example a transform object method of the invention does not actually create a new object even though it reclaims memory for the object s old data attributes and allocates memory for the new ones. Also a copy constructor in Java does not create an instance of a new class it creates an instance of the same class as its argument.

In some embodiments of the invention the values of data elements corresponding to an object of a class that is transformed are preserved to facilitate review e.g. by the workflow architect to facilitate further transformations and or to facilitate reverse transformations e.g. transformation of a transformed object back to a previous class.

For example the data values of an object of class A that is transformed into an object of class B can be preserved to facilitate transformation back from class B to class A. This allows information from a previous incarnation of an object that is data from an instance of the object corresponding to a previous class to be re used if it is transformed back into the previous class. Thus suppose that class B does not include a superset of all properties of class A. In this case a transformation of an object of class A to an object of class B can result in destruction of some data associated with the object prior to its transformation. In embodiments according to this aspect of the invention that information is preserved.

By way of example class A may represent TechnicalSupportWorkItem and class B may represent SalesWorkItem . The transformation of TechnicalSupportWorkItem to SalesWorkItem may be effected by a technical support expert who may decide that a problem can be solved by buying a new component. Subsequently it may however turn out that the new component is not available or that it does not fix the problem in which case the SalesWorkItem is transformed back to a TechnicalSupportWorkItem. Here the embodiment facilitates the transformation back to TechnicalSupportWorkItem by utilizing the original values and or generating further values as a function of the original preserved and current values.

The preserved values can be employed in a direct or indirect back transformations e.g. from Class A to Class B and back to class A or from class A to class B to class C and back to class A.

As described above a transformation constructor has access to the element vector of an object that is being transformed see . Such access can be provided via a special variable old instance which can be for example a reserved word. Whereas in the embodiments described above the element vector is destroyed after the transformation constructor is completed in embodiments that support preserved data values an element vector corresponding to a class of the object prior to transformation is preserved e.g. cached. For example rather than destroying an element vector associated with a class the system binds it to a local variable e.g. a variable named class name PreviousInstance and destroys any previous binding. The class name PreviousInstance can e.g. point to this preserved information vector for a class identified by the variable class name.

This element vector can be utilized in a number of different ways. For example when an instance of a present class is transformed back to an instance of a previous class an element vector associated with the new instance of the previous class can be populated with values from the preserved element vector. Alternatively it can be populated with default values current values i.e. values of the object instance prior to back transformation or a combined function of the preserved default and or current values.

Consider the class hierarchy illustrated in modeling a work item as it moves through steps necessary to process a customer service call and particularly a technical support call. Initially the object modeling the work item is of class Customer Contact Event. This class has basic attributes and methods for collecting initial information about the customer and the nature of the problem. Once the nature of the problem is known object transforms into an instantiation of a class appropriate for diagnosing the problem. For example if it becomes clear that the problem has to do with a CD ROM object transforms into an instantiation of class CD ROM Problem Diagnosis which has methods for various tests and data attributes for representing test results. Once testing is complete the object transforms so that its class corresponds to the appropriate problem resolution operation e.g. Re install Driver Software or Replace CD ROM Drive.

This example illustrates two aspects of typical workflows and the objects e.g. object used to model them a information related to a work item grows monotonically as the work item moves from operation to operation in a business process and b it is convenient to think of a work item becoming more and more specialized as it gains information by moving from operation to operation in a business process. Correspondingly the object begins as a generic class then transforms into successive subclasses.

Note also that transformation of object from one class to another is useful when the two classes involved have significant overlap in their data attributes. This is the case when one class is a sub class of the other as in the above example and is advantageous because it allows for much of the information in the original object to be retained through the transformation.

Now consider the class hierarchy illustrated in used to model business products namely bank loans that are the subject of a business process namely soliciting information from a customer about loan preferences.

To the processing center agent or other resource such as an automated web site wizard as more information becomes available from or about the customer it becomes clearer what product is best for the customer. Initially all that is known is that the customer may be interested in a loan. At this stage basic information about the customer credit rating net worth income and about the customer s needs are gathered in a newly instantiated object of class Generic Loan. Later it becomes clear to the agent or resource that the customer is interested in and or qualifies for a motor vehicle loan. The object correspondingly is transformed to the class Motor Vehicle Loan and whence to either class Motorcycle Loan or Auto Loan depending upon further information gathered by the agent or resource.

As with the previous example the object instance transforms into a more specialized class as more information is gathered. Note however that whereas the hierarchy in the previous example was for work items the hierarchy in this example is for products.

Consider the class hierarchy shown in used to model the object or beneficiary of various business process in this case a bank customer. Here object is an instance of a Bank Customer class which transforms to one of the sub classes e.g. Middle Class as circumstances in the customer s life change. This example is for a longer term business process than the ones in the previous examples. For such longer term business processes the processing module and or the application in which it is contained uses a conventional object oriented database or other means to persist the objects.

This example also illustrates that transformation is not necessarily always from a class to a sub class the transformations may have to be done across the class hierarchy. Consider for example the case where object initially an instance of class Bank Customer has been changed to an instance of class Single. Suppose now that customer that this object models gets married. The object would then be transformed into a Young Family instance. Because this transformation is across the hierarchy there is potentially less overlap of data attributes than there would be in a class sub class transformation. The corresponding transformation constructors accordingly may require more information than readily supplied by the prior object instance thus necessitating collection of data from the agent or other sources. Moreover additional data transformations may be necessary e.g. to map data from prior to current object instances. For example the transformation from Young Family to Retired might involve a transformation of dependent children of the Young Family instance being transformed into adult children of the Retired instance . Finally note that whereas in the previous examples the classes represented work items or products in this example they represent customers.

Multiple inheritance is a feature of a number of object oriented programming languages. This feature allows for more than one parent of any class. Thus instead of inheriting data and methods from a single class it becomes possible for a class and by extension any instance of that class to inherit from several classes. This feature is useful when modeling an object from several perspectives each of which may have a rich class hierarchy.

For example in the technical support call application it might be desirable to have two high level classes Problem Diagnosis and Problem Resolution. Both of these inherit from the class Customer Contact Event. Problem Diagnosis has data and method members concerning tests to perform. Problem Resolution has data and method members concerning required resources and service call scheduling. These classes form part of a hierarchy as shown in . Illustrated object e.g. modeling a work item for replacing a CD ROM drive inherits from both Problem Diagnosis and Problem Resolution and more directly from respective subclasses Replace Drive Diagnosis and Replace Drive Resolution . Similarly in the bank customer application it might be desirable to have one hierarchy for economic categorization and another representing customer interests and hobbies. An instance of a bank customer could then inherit from classes in both hierarchies.

Various object oriented programming languages take different approaches to implementing multiple inheritance. C supports it directly. Java only supports single inheritance. However a Java class can provide multiple Java interfaces which can be used to provide the illusion of multiple inheritance. In Java the information from the additional parent classes is stored as related sub objects and accessed via the interface methods. The interface can be given an appropriate signature so that to the user of the class it appears that it has inherited from other classes.

The illustrated embodiment supports object transformation in applications where an object is the subject of the multiple inheritance case. Unlike single inheritance discussed above transformation is no longer from one class to another because multiple classes are involved. Instead each class from which a mutable object may be instantiated or otherwise inherit is provided with an augmentation constructor augmentation destructor and transformation constructor as defined below

Using these operations any instance that inherits from any combination of primary and secondary classes can be transformed into an instance that inherits from any other combination of primary and secondary classes. Note that the indexing retrieval of augmentation constructors is accomplished in a manner similar to that for transformation constructors.

Described above are methods and systems meeting the desired objects. It will be appreciated that the illustrated embodiment is merely an example of the invention and that other embodiments incorporating changes therein fall within the scope of the invention. Thus it will be appreciated that the classes discussed in the preceding section are merely examples of how the invention is implemented and that appropriate modifications to those examples might be employed for implementation in a variety of possible languages. Further it will be appreciated that the transformation constructors shown in the above examples can be implemented in a variety of languages and still achieve the same benefit of easing modeling of workitems that are subject to transformation.

