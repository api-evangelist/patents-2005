---

title: Tracking file access patterns during a software build
abstract: Those files accessed by tools during a build process are invisibly tracked in such a way that the information can then be used to drive an incremental build of just enough files to bring the build fully up to date. The tracking information includes the association between distinct tool processes. Each build tool has its own file activity tracked, each thread of operation within tools are tracked separately and a tracking log is associated with a chain of tool processes so that when the tracking logs are interpreted the context in which they were created is preserved.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07721272&OS=07721272&RS=07721272
owner: Microsoft Corporation
number: 07721272
owner_city: Redmond
owner_country: US
publication_date: 20051212
---
This application claims priority to U.S. patent application Ser. No. 11 299 414 filed on Dec. 12 2005 entitled USING FILE ACCESS PATTERNS IN PROVIDING AN INCREMENTAL SOFTWARE BUILD the disclosures of which are incorporated in their entirety by reference herein.

A portion of the disclosure of this patent document may contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent files or records but otherwise reserves all copyright rights whatsoever. The following notice shall apply to this document Copyright 2005 Microsoft Corp.

A software build is the process of creating the software application binaries for a software release. They are done in a periodic manner by build teams to provide baseline binaries build outputs for daily work of software developers. Build processes involve many tools that process build inputs. These build inputs may be files such as source code and content files for example. These files may reference invisibly to the build process other files based solely on their content. Incremental builds for software faces a significant challenge that comes in two forms determining which files are accessed for read and or write by a tool during a build and deciding which parts of a build to re run when one or more files are changed in order to bring build outputs up to date. The problem with previous implementations is that they either resulted in an approximation at best of the actual dependencies of part of a build process through scanning the file content or the mechanism was entirely specific to the build tool itself.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

For several embodiments tracking file access patterns during a software build involves determining which files are accessed for read and which files are accessed for write by a software build tool resulting from the build. These indications are then recorded. These may be recorded in a separate list for each thread of a build tool that caused the access such that each separate list is associated with a particular thread of a build tool. These accesses may be tracked by redirecting calls that would normally go to the operating system to a file access tracker and then determining by the file access tracker which of those calls are requests by a build tool to read write or delete files during the build.

Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the invention. Certain well known details often associated with computing and software technology including software development are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the invention. Further those of ordinary skill in the relevant art will understand that they can practice other embodiments of the invention without one or more of the details described below. Finally while various methods are described with reference to steps and sequences in the following disclosure the description as such is for providing a clear implementation of embodiments of the invention and the steps and sequences of steps should not be taken as required to practice this invention.

Referring to shown is a block diagram representing an exemplary computing device suitable for use in conjunction with implementing the processes described above. For example the computer executable instructions that carry out the processes and methods for incremental software builds using file access patterns may reside and or be executed in such a computing environment as shown in . The computing system environment is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment . For example a computer game console may also include those items such as those described below for use in conjunction with implementing the processes described above.

Aspects of the invention are operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices and the like.

Aspects of the invention may be implemented in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. Aspects of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices.

An exemplary system for implementing aspects of the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through an non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies. A user may enter commands and information into the computer through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through a output peripheral interface .

The computer may operate in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs that may implement or utilize the processes described in connection with the invention e.g. through the use of an API reusable controls or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and combined with hardware implementations.

Although exemplary embodiments may refer to utilizing aspects of the invention in the context of one or more stand alone computer systems the invention is not so limited but rather may be implemented in connection with any computing environment such as a network or distributed computing environment. Still further aspects of the invention may be implemented in or across a plurality of processing chips or devices and storage may similarly be effected across a plurality of devices. Such devices might include personal computers network servers handheld devices supercomputers or computers integrated into other systems such as automobiles and airplanes.

Referring next to shown is an exemplary networked computing environment in which many computerized processes may be implemented to perform the processes described above. For example parallel computing may be part of such a networked environment with various clients on the network of using and or implementing incremental software builds using file access patterns. One of ordinary skill in the art can appreciate that networks can connect any computer or other client or server device or in a distributed computing environment. In this regard any computer system or environment having any number of processing memory or storage units and any number of applications and processes occurring simultaneously is considered suitable for use in connection with the systems and methods provided.

Distributed computing provides sharing of computer resources and services by exchange between computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for files. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may implicate the processes described herein.

This network may itself comprise other computing entities that provide services to the system of and may itself represent multiple interconnected networks. In accordance with an aspect of the invention each entity and may contain discrete functional program modules that might make use of an API or other object software firmware and or hardware to request services of one or more of the other entities and .

It can also be appreciated that an object such as may be hosted on another computing device . Thus although the physical environment depicted may show the connected devices as computers such illustration is merely exemplary and the physical environment may alternatively be depicted or described comprising various digital devices such as PDAs televisions MP3 players etc. software objects such as interfaces COM objects and the like.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems may be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks. Any such infrastructures whether coupled to the Internet or not may be used in conjunction with the systems and methods provided.

A network infrastructure may enable a host of network topologies such as client server peer to peer or hybrid architectures. The client is a member of a class or group that uses the services of another class or group to which it is not related. In computing a client is a process i.e. roughly a set of instructions or tasks that requests a service provided by another program. The client process utilizes the requested service without having to know any working details about the other program or the service itself. In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the example of any entity and can be considered a client a server or both depending on the circumstances.

A server is typically though not necessarily a remote computer system accessible over a remote or local network such as the Internet. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects may be distributed across multiple computing devices or objects.

Client s and server s communicate with one another utilizing the functionality provided by protocol layer s . For example HyperText Transfer Protocol HTTP is a common protocol that is used in conjunction with the World Wide Web WWW or the Web. Typically a computer network address such as an Internet Protocol IP address or other reference such as a Universal Resource Locator URL can be used to identify the server or client computers to each other. The network address can be referred to as a URL address. Communication can be provided over a communications medium e.g. client s and server s may be coupled to one another via TCP IP connection s for high capacity communication.

In light of the diverse computing environments that may be built according to the general framework provided in and the further diversification that can occur in computing in a network environment such as that of the systems and methods provided herein cannot be construed as limited in any way to a particular computing architecture. Instead the invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

Referring next to shown is a diagram illustrating example dependencies between files involved in an incremental software build using file access patterns. Build processes involve many software build tools i.e. tools that process build inputs i.e. files . These files may reference invisibly to the build process other files based solely on their content. For example the input file Y.cpp references the file XY.h which in turn references the file AA.h . These references are made for example using the include language within the contents of the referencing file. In order to decide which parts of a build to re run when one or more input files are changed so as to bring build outputs up to date which input files are accessed for read and or write by a tool during a build is determined. This is accomplished by discovering raw file access information by tools during a build process. The raw file access information is discovery is not tied to any one build tool. The dependencies and associations between input files are determined in order to tell which input files are dependent on those being accessed and thus may be involved in the parts of a build to re run when one or more input files are changed.

Referring next to shown is a diagram illustrating a process showing an example of how file access patterns are tracked for use in an incremental software build. The process of invisibly tracks those files accessed by tools during a build process in such a way that the information can then be used to drive an incremental build of just enough files to bring the build fully up to date. The tracking information includes the association between distinct tool processes . Since one tool may invoke others in order to perform processing each and every tool MIDL.exe MIDLC.exe CL.exe and RC.exe for example has its file activity tracked . However the tracking logs are associated with a chain of tool processes so that when the tracking logs are interpreted the context in which they were created is preserved. In the example provided in the tracking logs gave a .tlog file name extension and thus are referred to as .tlogs. or tracking logs .

Multi threaded tools are becoming more prevalent so each thread of operation within tools are tracked separately. This is to preserve not only the information about what files are being accessed but the pattern of that access. If all threads were tracked together this pattern would be lost. The pattern of file accesses is then interpreted in order to determine the associations between individual files in the build.

Each one of these build tools MIDL.exe MIDLC.exe CL.exe and RC.exe for example is typically an executable application in its own right. Typically the build process without the tracker will just be provided the input files and run the appropriate tools on them. With the tracker instead of the build process stating that a particular tool should be invoked the tracker is actually invoked instead. The full command that would normally be used to start this tool say MIDL.exe for example is given to the tracker . This is accomplished by redirecting calls that would normally go to the operating system to the tracker itself. Whenever a tool using MIDL.exe as an example in the build process requests to open a file it actually asks the tracker to open it for it. The tracker then remembers that it has been asked to open a file and asks the operating system to actually do it. One way of implementing this procedure is by using the Microsoft Detours 2.0 software available at http research.microsoft.com sn detours . Detours is a library for instrumenting arbitrary Win32 functions on x86 machines. Detours intercepts Win32 functions by re writing target function images. Thus Detours can be used to hook file access application programming interfaces APIs to track what they do and provides a generalized way of getting between the application and the operating system.

As the tool executes the tracker holds onto a number of lists i.e. .tlogs all the files that were read all the files that were written and then at some point all the files that were deleted during the build process. When this tool finishes its work these .tlogs exist on disk.

In order to prevent the case of the tool having multiple threads of activity that occur inside it concurrently and the tracker having no way of knowing which thread of activity caused the read and write to happen every time the tracker records a file it keeps it in a separate list depending on the thread. The MIDL.exe toll may have for example two threads of activity within it. Each thread is reading and writing files at the same time but they are actually two separate pieces of work that need to be tracked. As the call is intercepted the tracker inquires with the operating system what thread the tracker is on and the tracker puts it into a different list. Thus there are potentially many lists resulting for each tool one for each thread of activity within the tool . This is important in order to prevent those threads of activity from polluting each other in the tracking block and to know in sequence each activity that goes on in the tool i.e. what its read and writes were independently of anything else it might be doing.

Notice with MIDL.exe there s a chain of tools that gets invoked. In this case the tracker has also intercepted the operating system call for starting the next process so that it can automatically pass itself on to every tool that gets invoked in a chain. Then each one of these tools can write out to its log files which will be named appropriately according to the tool in the chain that was invoked. The RC.exe tool operates in a similar fashion except it does not have this chain of events so the mechanism used for MIDL.exe works well for RC as well. Both of those tools have a characteristic that they can only accept one primary file at a time. This means that every invocation is completely separate. However CL.exe is different in that it can be passed as many primary files as desired and it will just systematically jump through them. Therefore when the tracker is invoked it is handed a list of all of the files i.e. primary files that are going to be processed by the CL.exe tool . As CL.exe opens files the tracker looks up the file that it is opening in that list of primary files. If the tracker finds the file it writes a marker into the log alongside the file that it has just written. Then all the files that are then opened between that and the next primary file are associated with that primary file. As a result in the log appears a long list of files and every so often a marker appears that indicates that a primary file had gone past. This indicates that that all of the files that follow the primary marker are associated with that primary file. The above works because the tool CL.exe opens the primary file and then goes on to write from the others. This also applies to the operation of the RC.exe tool. It opens the primary file and then goes on to open the secondary files or the in order files .

In the instance where there is a chain of tools such as in the case of MIDL.exe MIDLC.exe and CL.exe the downstream tools MIDLC.exe and CL.exe don t actually open these primary files themselves. They open intermediate files that have been written by the prior tool. The association is therefore lost. It is no longer known by looking in the log of MIDLC.exe that it was originally processing the particular file. However the mechanism described above for telling the tracker what the primary files are works just as well because the tracker passes on that primary file information as each tool is invoked. Therefore in the logs for all of these downstream tools is this primary file reference due to the tracker having explicitly written it. The tracker puts the primary file information in the tracking log regardless of whether the tool actually opens it or not. Therefore the correct associations can be made even where there is a chain of tools such as in the case of MIDL.exe MIDLC.exe and CL.exe .

Referring next to shown is diagram illustrating example contents of a log file generated in connection with implementation of the process shown in of how file access patterns are tracked in an incremental software build. Due to the tracker being invoked on many different tools all the tracking information is not housed in the same file. Otherwise it would be difficult to tell which tools resulted in which tracking information. Thus the tracking logs are named along the lines of the tool used when creating the tracking log . For example shows midl.read..tlog . The first part of the name indicates the name of the tool. The example tracking log in has midl as is the name of the tool. This is associated with the tool MIDL.exe of . The second portion indicates whether the log is the read write or delete log file. Thus midl.read..tlog is a read tracking log . The third portion is the thread identification. Thus midl.read..tlog is a read tracking log associated with the first thread of the MIDL.exe tool and midl.read..tlog is a read tracking log associated with the second thread of the MIDL.exe tool . This information identifying each log file can go alternatively into a database. The fact that in the present example it is written to a log file on disk does not indicate that it must be stored this way.

Within the tracking logs names of the files that are accessed appear in a list . A root marker depicts the set of files known to be processed by the task e.g. all the .cpp files for the CL.exe task . For example this could appear as X.cpp Y.cpp Z.cpp in a tracking log to indicate the files X.cpp Y.cpp Z.cpp as the set of files known to be processed by the CL.exe task . Also a primary source marker indicates a single file from the root file set. For example this could appear as Z.cpp in a tracking log for CL.exe. In the example of A.idl indicates a single file from the root file set for MIDL.exe in the tracking log midl.read..tlog .

Referring next to shown is flow diagram illustrating an exemplary process of an incremental software build using file access patterns tracked according to the process of . Once the tracker are creates and collects the tracking logs. They are used in deciding which parts of a build to re run to drive incremental build of just enough files to bring the build fully up to date. This is done by using the tracking logs to determine which files that have been changed and thus need to be involved in the build in order to bring build outputs up to date. Once the build is started the interpretation process of the tracking logs begins. First it is determined whether any tracking logs are present. If not every part of the build process must be re run and the tracker is invoked to start creating the tracking logs . If there are tracking logs present then the tracking logs are interpreted by building a dependency graph based upon the files in the tracking logs which is then queried for out of date files those that have been changed since the last build . This is accomplished by reading all of the tracking information in and associating all the inputs with all the outputs using the read tracking files and write tracking files . The association is made that that while reading particular files the build process also wrote a set of particular files. A determination is then made as to whether any of these files that the build process read are newer than any of the files that it wrote. If any of these files that the build process read are newer than any of the files that it wrote then an indication is provided that the part of the build associated with those out of date files must be re run. If there are not any out of date files then the build does not have to be re run . Otherwise the tracking logs are compacted to remove unneeded entries and a resulting subset of files i.e. those that are out of date is provided to the tracker to continue the build process and track new entries re running only the portion of the build the CL.exe tool for example required to be completed due to the out of date files. A determination is made as to whether there is an error in the build process e.g. a compiler error . If so the tracking logs are compacted and the build fails . Otherwise the build continues on to the link stage creating the resulting application at which point the process is completed .

It is noted that the foregoing examples have been provided merely for the purpose of explanation and are in no way to be construed as limiting of the present invention. While the invention has been described with reference to various embodiments it is understood that the words which have been used herein are words of description and illustration rather than words of limitations. Further although the invention has been described herein with reference to particular means materials and embodiments the invention is not intended to be limited to the particulars disclosed herein rather the invention extends to all functionally equivalent structures methods and uses such as are within the scope of the appended claims. Those skilled in the art having the benefit of the teachings of this specification may effect numerous modifications thereto and changes may be made without departing from the scope and spirit of the invention in its aspects.

