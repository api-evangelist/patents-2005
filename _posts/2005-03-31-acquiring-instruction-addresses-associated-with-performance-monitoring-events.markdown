---

title: Acquiring instruction addresses associated with performance monitoring events
abstract: Systems, methodologies, media, and other embodiments associated with acquiring instruction addresses associated with performance monitoring events are described. One exemplary system embodiment includes logic for recording instruction and state data associated with events countable by performance monitoring logic associated with a pipelined processor. The exemplary system embodiment may also include logic for traversing the instruction and state data on a cycle count basis. The exemplary system may also include logic for traversing the instruction and state data on a retirement count basis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07747844&OS=07747844&RS=07747844
owner: Hewlett-Packard Development Company, L.P.
number: 07747844
owner_city: Houston
owner_country: US
publication_date: 20050331
---
Processors e.g. microprocessors in computers may include performance monitoring components e.g. hardware firmware software that are configurable to detect and count occurrences of various events. For example performance monitoring components may count occurrences of instruction cache misses data cache misses events associated with instruction dependencies events associated with resource conflicts and so on. Upon detecting and counting an event the performance monitoring components may capture and record information related to the event. For example information like the address of an instruction retiring at the time the counted event occurred may be acquired and written to a data store. This information may facilitate understanding why and or how a processor is performing in a certain manner.

Processors may have a pipelined architecture. For example early processors may have had a two stage pipeline where the next instruction to be executed was fetched while the current instruction to execute was executed. Thus an event to be counted may have been associated with either the fetching of an instruction or execution of an instruction. Later processors may have had pipelines with more stages e.g. fetch decode execute retire . Events to be counted may have occurred as a result of an instruction located at various stages in the pipeline. For example an instruction retiring may have been an event to be counted. When counted an instruction pointer and other information associated with the retiring instruction may have been saved.

Processors may also have a parallel architecture. For example a processor may have two or more pipelines through which sets of instructions may progress. Thus events to be counted may have occurred as a result of an instruction being processed in various pipelines. Pipelined architectures and or parallel architectures may interact with multiple execution units. For example a processor may have two integer processing units and two floating point processing units. Thus various instructions at various stages of various pipelines may be dispatched to various execution units. Clearly this impacts the efficacy and complexity of performance monitoring systems and methods. Thus while some useful information could conventionally be acquired from performance monitoring logic by capturing information associated with retiring instructions other information may have been ignored or considered unobtainable due to complexities associated with multiple pipeline stages parallel architectures multiple execution units and so on.

Example systems and methods described herein may facilitate acquiring e.g. capturing and locating the address of an instruction associated with an event counted by performance monitoring logic in a microprocessor. When an event is counted information like the address of an instruction associated with e.g. causing the event may be captured and stored in hardware. By way of illustration a captured instruction address may be associated with an event like an instruction cache miss a data cache miss a stall caused by a data cache miss a structural hazard a data dependency hazard a control hazard and the like. By way of further illustration if an instruction references data that is not located in an on chip data cache then the processor may have to go to memory to acquire the data. Going to memory may consume a relatively long period of time and thus may be an event the performance monitoring logic is configured to count. Therefore the address of the instruction and other related state information may be stored by the performance monitoring logic in the performance monitoring logic and or other hardware. While recording the information is itself valuable selectively navigating through the information using different navigation techniques e.g. cycle based retirement based facilitates acquiring data like the address of an instruction executing at an identified pipeline stage when a counted event occurred.

Conventional performance monitoring logic in a processor may have included hardware that is configured to match specified patterns of instruction opcode address cache hit miss status branch mispredictions and so on. The matched signals may have been combined for example using an on chip state machine to detect specific sequences of events. Additionally the state machine may have caused an event counter s to increment. The event counter s may have been configured to increment based on control signals that indicate what a processor was doing at a given time. This conventional logic may be augmented with additional logic to facilitate acquiring different information and or processing it in different manners.

Microprocessors may employ one or more pipelines that allow multiple instructions to execute substantially concurrently. With pipelines processor instruction execution may be broken down into a sequence of sub instruction phases known as pipeline stages or pipestages. The pipestages may be buffered so that in an N stage pipeline N stages from N instructions may execute substantially concurrently. Multi issue processors may fetch multiple instructions per clock cycle and dispatch multiple instructions to multiple pipelines per clock cycle. Thus in one example countable events may be associated with instructions being executed at different stages in different pipelines. Conventional performance monitoring logics may only have acquired and or made available information associated with an instruction retiring from a pipeline. Thus information concerning an instruction executing at an earlier stage in a pipeline may not have been collected. Even if such data was collected it may have been difficult if possible at all to navigate to such data. It may be difficult if possible at all to collect a larger piece of data like the instruction address associated with a variety of events for at least two reasons. First the signal that indicates that the event occurred may not be co located with the larger piece of data e.g. instruction address . Therefore logic and time may be required to associate the signal with the proper larger piece of data. Second the larger piece of data may need to be conveyed to a storage area in for example the performance monitoring unit. For a large piece of data e.g. 60 bits it is not feasible to provide interconnecting wires and intermediate storage devices from every possible event to an associated location in the performance monitoring unit storage device.

Pipeline performance may be limited by conditions known as hazards that may occur during program execution. Hazards may include structural hazards data dependency hazards control hazards and so on. The occurrence of a hazard may lead to a pipeline stall where the pipeline may not be able to accept new instructions during the pendency of the hazard. Hazards may be caused by instructions executing at different pipeline stages. A structural hazard stall may occur for example if multiple instructions contend for limited hardware resources. A data dependency hazard stall may occur for example if instructions read and or write from the same data location in a manner that may produce a race condition. A control hazard stall may occur for example when a branch interrupt exception or the like modifies program control flow. Understanding how and why such hazard stalls occur facilitates improving processor performance. Thus performance monitoring logic may be configured to count events that lead to such stalls. Additionally and or alternatively performance monitoring logic may be configured to count other events of interest like data and or instruction cache misses. Example systems and methods described herein may facilitate capturing and navigating to data like instruction addresses and data addresses associated with event causing instructions regardless of the pipestage at which the instruction was executing.

The following includes definitions of selected terms employed herein. The definitions include various examples and or forms of components that fall within the scope of a term and that may be used for implementation. The examples are not intended to be limiting. Both singular and plural forms of terms may be within the definitions.

As used in this application the term computer component refers to a computer related entity either hardware firmware software stored in a computer readable storage medium a combination thereof or software in execution by a processor. For example a computer component can be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and a computer. By way of illustration both an application running on a server and the server can be computer components. One or more computer components can reside within a process and or thread of execution and a computer component can be localized on one computer and or distributed between two or more computers.

 Computer communication as used herein refers to a communication between two or more computing devices e.g. computer personal digital assistant cellular telephone and can be for example a network transfer a file transfer an applet transfer an email a hypertext transfer protocol HTTP transfer and so on. A computer communication can occur across for example a wireless system e.g. IEEE 802.11 IEEE 802.15 an Ethernet system e.g. IEEE 802.3 a token ring system e.g. IEEE 802.5 a local area network LAN a wide area network WAN a point to point system a circuit switching system a packet switching system combinations thereof and so on.

 Computer readable medium as used herein refers to a storage medium that stores instructions and or data. A computer readable medium may take forms including but not limited to non volatile media and volatile media. Non volatile media may include for example optical or magnetic disks and so on. Volatile media may include for example optical or magnetic disks dynamic memory and the like. Common forms of a computer readable medium include but are not limited to a floppy disk a flexible disk a hard disk a magnetic tape other magnetic media a CD ROM other optical media other physical media with patterns of holes a RAM a ROM an EPROM a FLASH EPROM or other memory chip or card a memory stick and other media from which a computer a processor or other electronic device can read.

 Data store as used herein refers to a physical and or logical entity that can store data. A data store may be for example a database a table a file a list a queue a heap a memory a register and so on. A data store may reside in one logical and or physical entity and or may be distributed between two or more logical and or physical entities.

 Event as used herein refers to a processor microarchitecture event including but not limited to instruction cache misses data cache misses retired branches hazard stalls and other related events.

 Logic as used herein includes but is not limited to hardware firmware software stored in a computer readable storage medium and or combinations of each to perform a function s or an action s and or to cause a function or action from another logic method and or system. For example based on a desired application or needs logic may include a software controlled microprocessor discrete logic like an application specific integrated circuit ASIC a programmed logic device a memory device containing instructions or the like. Logic may include one or more gates combinations of gates or other circuit components. Where multiple logical logics are described it may be possible to incorporate the multiple logical logics into one physical logic. Similarly where a single logical logic is described it may be possible to distribute that single logical logic between multiple physical logics.

An operable connection or a connection by which entities are operably connected is one in which signals physical communications and or logical communications may be sent and or received. Typically an operable connection includes a physical interface an electrical interface and or a data interface but it is to be noted that an operable connection may include differing combinations of these or other types of connections sufficient to allow operable control. For example two entities can be operably connected by being able to communicate signals to each other directly or through one or more intermediate entities like a processor operating system a logic software or other entity. Logical and or physical communication channels can be used to create an operable connection.

 Signal as used herein includes but is not limited to one or more electrical or optical signals analog or digital signals data one or more computer or processor instructions messages a bit or bit stream or other means that can be received transmitted and or detected.

 Software as used herein includes but is not limited to one or more computer or processor instructions that can be read interpreted compiled and or executed and that cause a computer processor or other electronic device to perform functions actions and or behave in a desired manner. The instructions may be embodied in various forms like routines algorithms modules methods threads and or programs including separate applications or code from dynamically and or statically linked libraries. Software may also be implemented in a variety of executable and or loadable forms including but not limited to a stand alone program a function call local and or remote a servelet an applet instructions stored in a memory part of an operating system or other types of executable instructions. It will be appreciated by one of ordinary skill in the art that the form of software may depend for example on requirements of a desired application the environment in which it runs and or the desires of a designer programmer or the like. It will also be appreciated that computer readable and or executable instructions can be located in one logic and or distributed between two or more communicating co operating and or parallel processing logics and thus can be loaded and or executed in serial parallel massively parallel and other manners.

Suitable software for implementing the various components of the example systems and methods described herein may be produced using programming languages and tools like Java Pascal C C C CGI Perl SQL APIs SDKs assembly firmware microcode and or other languages and tools. Software whether an entire system or a component of a system may be embodied as an article of manufacture and maintained or provided as part of a computer readable storage medium as defined previously.

 User as used herein includes but is not limited to one or more persons software computers or other devices or combinations of these.

Some portions of the detailed descriptions that follow are presented in terms of algorithms and symbolic representations of operations on data bits within a memory. These algorithmic descriptions and representations are the means used by those skilled in the art to convey the substance of their work to others. An algorithm is here and generally conceived to be a sequence of operations that produce a result. The operations may include physical manipulations of physical quantities. Usually though not necessarily the physical quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated in a logic and the like.

It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like. It should be borne in mind however that these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise it is appreciated that throughout the description terms like processing computing calculating determining displaying or the like refer to actions and processes of a computer system logic processor or similar electronic device that manipulates and transforms data represented as physical electronic quantities.

To provide context illustrates two views of an example execution pipeline for a microprocessor. The pipeline is illustrated at both a high level of abstraction right side A and a more detailed level left side B . While the example execution pipeline borrows from the Itanium series of processors it more generally describes a multiple stage pipeline. It is to be appreciated that example systems and methods described herein are not limited to a processor having this example execution pipeline.

The pipeline B includes ten stages. The ten stages can more abstractly be considered as four higher level stages as illustrated in pipeline A. Three stages instruction pointer generation IPG fetch and rotate form a front end stage of pipeline A. The front end stage may include fetching and delivering an instruction to a decoupling buffer that facilitates having the front end operate independently from the remainder of pipeline A. An instruction cache miss may occur for example during processing performed by the front end .

Two stages expand rename form an instruction delivery stage in pipeline A. The instruction delivery stage may include actions like register renaming dispersal and the like. Similarly two stages wordline decode register read form an operand delivery stage in pipeline A. The operand delivery stage may include actions like accessing register files delivering data after processing predicate control and so on. A data cache miss may occur for example during processing performed in the operand delivery stage . Similarly a data dependency hazard stall may occur for example during processing performed in the operand delivery stage .

Three stages execute exception detection write back may form an execution and retirement stage in pipeline A. The execution and retirement stage may include actions like parallel execution exception management and retirement. A data dependency hazard may occur for example during the execution and retirement stage . Similarly a control hazard and or a structural hazard may occur during the execution and retirement stage .

Thus the example pipelines illustrated in facilitate understanding that instructions may be executed in various pipestages and that countable events may be associated with instruction execution at the various pipestages. Typically instruction pointer data e.g. address of an instruction is captured when an instruction is retired from a pipeline. However it may be desired to acquire and or examine instruction pointer data associated with an instruction located at a different pipestage if that instruction caused or was associated with a countable event. Therefore example systems and methods described herein may facilitate acquiring instruction addresses associated with performance monitoring events where those events may be associated with instructions executing at an identified stage in an execution pipeline.

While the term record is employed in connection with data store it is to be appreciated that more generally data store stores data e.g. addresses operands validity bit values state values concerning instructions processed by a pipelined processor. Thus the use of the term record is not intended to limit the discussion to conventional tables and records. Rather the term record is intended to convey the concept of a related collection of data that may be addressed in the aggregate and or that may have its constituent members e.g. fields be addressed. In one example the data store is a first in first out FIFO data structure where each entry stores address and state information. The state information may include the number of cycles performed by the pipelined processor since a previous write to the data store . In one example data stored in records written to the data store may include data like an instruction pointer field a cycle count field an instruction pointer validity field a pipeline flush status field and a data store freeze status field.

A pipelined processor may include an execution pipeline that includes various execution phases. In one example the execution pipeline may include a fetch stage a decode stage an execute stage a write back stage and a retirement stage. While five stages are described it is to be appreciated that execution pipelines with greater and or lesser number of stages may be employed. The number of stages in the execution pipeline may be stored in the acquisition logic . The pipelined processor may be for example a microprocessor. In one example the execution pipeline is associated with an in order machine that does not reorder instructions.

The acquisition logic may also include a performance monitoring logic that is configured to detect an event caused by an instruction in the execution pipeline . The event may be caused for example by an instruction cache miss a data cache miss a pipeline hazard a pipeline instruction recirculate operation and so on. While four types of events are described it is to be appreciated that other types of events may also be monitored by detected and or counted by the performance monitoring logic .

The performance monitoring logic may also be configured to store state and address information associated with instructions and events. For example the performance monitoring logic may be configured to collect and store information about a processor state when an event occurred. The information may be stored in the data store or elsewhere in the acquisition logic . Additionally the performance monitoring logic may be configured to write information concerning retiring instructions to the data store . Furthermore the performance monitoring logic may be configured to write information concerning an instruction to the data store on the cycle before the data store is frozen regardless of whether the instruction has retired. In one example the performance monitoring logic may be configured to write the value of a state bit e.g. valid bit whenever the data store is written.

The performance monitoring logic may also be configured to selectively suspend the writing of records to the data store upon the occurrence of an identified event. This may be referred to as freezing the data store . The data store may be frozen to facilitate preserving information associated with an instruction related to a particular event and or information associated with instructions temporally related to the occurrence of the particular event. Freezing may be necessary since the data store may have a finite size.

There may be a delay between the occurrence of an event and the freezing of the data store . This delay may be referred to as a minimum freeze delay. A data value may store the minimum freeze delay in the acquisition logic . The minimum freeze delay accounts for a delay arising because an event may occur and be substantially instantaneously handled by the performance monitoring logic while the data store may not be frozen as quickly. In different examples the events may not be substantially instantaneously handled by the performance monitoring logic . Thus the minimum freeze delay may include time that passes between the event and the handling by the performance monitoring unit as well as time that passes between when the event is counted and the freezing of the data store .

There may also be a delay between the occurrence of an event and the retirement of the instruction that caused the event. The length of the delay between occurrence and freezing measured in cycles may be stored in a variable in the data store . There may also be a delay between the point at which an instruction retires and the point when a record concerning the retiring instruction is written to the data store . This delay may be referred to as a write delay. Additionally in one example a user may configure the performance monitoring logic to continue gathering data and writing records to the data store for a number of cycles after the occurrence of an event. This delay may be referred to as a programmed freeze delay.

Storing information concerning the various delays facilitates determining how many cycles to count back in collected data to locate a first record associated with an instruction that was retiring at the time an event occurred. In one example while moving back through data various status identifiers may be examined to determine the likelihood that valid data identifying the address that caused the event will be found. These identifiers may include for example an IP validity status field a flush status field a freeze status field and so on.

The acquisition logic may also include an instruction location logic that is configured to navigate through data e.g. records in the data store to facilitate determining the address of an instruction associated with the identified event. While instruction location logic is illustrated in acquisition logic it is to be appreciated that in some examples instruction location logic may be implemented in software and not in the acquisition logic . In one example the instruction location logic may process cycle based data to locate a first record associated with an instruction that was retiring from the pipelined processor when the identified event occurred. The various delays described above may factor into how far back in time this cycle based counting reaches. Then the instruction location logic may process retirement count data to locate a second record associated with the instruction that was executing at a desired pipeline stage when the identified event occurred. Having collected data concerning events and instructions retiring from the execution pipeline the acquisition logic may attempt to locate an instruction address associated with a particular event. Thus the acquisition logic may include the instruction location logic . In one example the instruction location logic may include a cycle counting logic not illustrated that is configured to locate the first record in the data store by examining cycle count data. Similarly the instruction location logic may include a retirement counting logic not illustrated that is configured to locate the second record in the data store by examining retirement data.

The performance monitoring logic may include various logics or perform certain actions that capture a variety of data that facilitates cycle and or retirement counting to locate an instruction address associated with a performance monitoring event. For example the performance monitoring logic may include an instruction pointer capturing logic that is configured to acquire the address of an instruction retiring from the execution pipeline and to store the address in the data store . The address may be aggregated with other state information in a record as described above.

The performance monitoring logic may also include a cycle counting logic that is configured to count the number of cycles that occur between writes to the data store . This information may be stored in the data store . In one example the cycle count information may be aggregated with an instruction address captured by the instruction pointer capturing logic and written as a record to the data store . Knowing the number of cycles that occurred between writes to the data store and thus knowing the number of cycles that occurred between instruction retirements facilitates navigating the stored address and state information to locate an instruction that was retiring at the time an event occurred.

The performance monitoring logic may also include an instruction pointer validity logic that is configured to capture a validity data concerning whether an instruction whose address is captured by the instruction pointer capturing logic was retired from the execution pipeline when the data store was frozen. The instruction pointer validity logic may store the validity data in the data store as for example part of a record aggregating the address information and cycle count information. In one example the instruction pointer validity logic writes a first value e.g. one to the record written to the data store if there is a valid instruction retiring when the data store is frozen. If the data store is frozen at a time when there is not a valid instruction retiring then a second value e.g. zero may be written by the instruction pointer validity logic to an instruction pointer validity field in the data store . When moving back through records on a cycle basis encountering a certain value e.g. second value zero in an instruction pointer validity field may indicate that it may not be possible to acquire an instruction address associated with a certain performance monitoring event.

The performance monitoring logic may also include a flush status logic that is configured to capture a flush status data concerning whether the execution pipeline was flushed between writes to the data store . The flush status logic may also be configured to store the pipeline flush status data in the data store as for example part of a record associated with a retiring instruction. In one example the flush status logic may write a first value e.g. one to a flush status field in the record to indicate that a pipeline flush occurred since the previous write to the data store. The flush status logic may for example employ a one bit counter that is cleared after each write to the data store . If the execution pipeline is flushed the counter may be incremented. When moving back through records on a cycle basis encountering a certain value e.g. first value one in a flush status field may indicate that it may not be possible to acquire an instruction address associated with a certain performance monitoring event.

The performance monitoring logic may also include a freeze status logic that is configured to capture a freeze status data concerning whether writing to the data store was suspended before a programmed overflow delay expired. The freeze status logic may be configured to store the freeze status data in the data store as for example a field in a record associated with a retiring instruction. In one example the freeze status logic may write a first value e.g. one to a freeze status field in a record if writing to the data store was frozen before a delay whose value is stored in a freeze delay counter could occur. This early freeze may occur for example due to a context switch an interrupt a branch or the like which may prevent an instruction from proceeding to the retirement stage in the execution pipeline . While counting back through records on a cycle basis encountering a certain value e.g. first value one in a freeze status field may indicate that it may not be possible to acquire an instruction address associated with a certain performance monitoring event.

The performance monitoring logic may also include an event counting logic that is configured to count a number of selected events. For example a user may not be interested in the first occurrence of a data cache miss but may be interested in the one thousandth occurrence. Thus the event counting logic may be configurable to count events. Similarly the performance monitoring logic may include an overflow logic that is configured to determine whether a pre determined number of selected events have occurred. For example the overflow logic may be programmed to generate a signal when the event counting logic has counted a pre defined number of events. While the event counting logic and the overflow logic are illustrated as separate logics it is to be appreciated that these two logics and other logics in the performance monitoring logic may be combined into single logics.

As described above writing data records to the data store may be selectively halted. Thus the performance monitoring logic may include a freeze logic that is configured to selectively suspend the writing of records to the data store . In one example the freeze logic may be configurable to freeze the data store after the occurrence of a pre determined number of cycles after the occurrence of a selected event.

In one example if there is no delay from the writing of the instruction address for the retirement event causing the freeze and the freeze itself and if the event that caused the FIFO to be frozen was retiring at the time it caused the event then the address of the instruction that caused the event can be retrieved from the last record written to the FIFO . However the retiring instruction may not have been the instruction that caused the event. Or in other words the instruction that caused the event that caused the FIFO to be frozen might not have been in the retirement stage of an execution pipeline. However information concerning the stage at which the instruction that caused the FIFO to be frozen was executing may be available. Furthermore information concerning the number of cycles associated with the various delays described above may be available.

Thus in one example the total number of cycles between the event causing the freeze and the actual freeze of the FIFO may be known and or determinable. Similarly the number of cycles that occurred between each write to FIFO may be known and or determinable because that count may be stored in each record written to the FIFO . Thus it may be possible to logically move back in time through the various records stored in FIFO to locate the record that was retiring at the time the event occurred. This may be referred to as cycle based movement. In the cycle based movement is illustrated beginning at Location the last record written to the FIFO and moving back through previous records to the record stored at Location . By counting cycles and accounting for the various delays described above Location can be identified as storing the record associated with the instruction that was retiring at the time the FIFO freezing event occurred.

Having established which instruction was at the last stage the retirement stage of an execution pipeline when the FIFO freezing event occurred example systems and methods described herein may then logically move forward in time through records stored in the FIFO to locate the record associated with an instruction at a desired pipestage. In one example this logical forward movement can cover enough records to match a number of retirements equal to the number of pipestages in the execution pipeline minus the pipestage at which the event occurred. In the instruction may have been executing two pipestages from the end of the execution pipeline and thus a second location Location that is two locations ahead of the first location Location may be identified as storing data associated with the instruction that caused the particular event. As described above a location may store a record and a record may store an address pointer and thus by locating an appropriate record in FIFO the address of the instruction that caused a particular performance monitoring event may be retrieved. Again while records are described the locations in FIFO may be other aggregates of data. Similarly while a FIFO is illustrated other data stores may be employed.

Example methods may be better appreciated with reference to the flow diagrams of . While for purposes of simplicity of explanation the illustrated methodologies are shown and described as a series of blocks it is to be appreciated that the methodologies are not limited by the order of the blocks as some blocks can occur in different orders and or concurrently with other blocks from that shown and described. Moreover less than all the illustrated blocks may be required to implement an example methodology. Furthermore additional and or alternative methodologies can employ additional not illustrated blocks.

In the flow diagrams blocks denote processing blocks that may be implemented with logic. The processing blocks may represent a method step and or an apparatus element for performing the method step. A flow diagram does not depict syntax for any particular programming language methodology or style e.g. procedural object oriented . Rather a flow diagram illustrates functional information one skilled in the art may employ to develop logic to perform the illustrated processing. It will be appreciated that in some examples program elements like temporary variables routine loops and so on are not shown. It will be further appreciated that electronic and software applications may involve dynamic and flexible processes so that the illustrated blocks can be performed in other sequences that are different from those shown and or that blocks may be combined or separated into multiple components. It will be appreciated that the processes may be implemented using various programming approaches like machine language procedural object oriented and or artificial intelligence techniques.

Method may also include at determining that a particular performance monitoring event has occurred. In one example determining that a particular performance monitoring event has occurred may include receiving a signal that an event counter has reached a pre determined count. For example a user may be interested in tracking the Nth occurrence of an event and thus upon the occurrence of that Nth event a performance monitoring logic may generate a signal that method may receive and interpret as indicating that a desired event has occurred. The performance monitoring event may be for example an instruction cache miss a data cache miss a pipeline recirculate event and so on. In one example the event may be associated with the non retirement of an instruction. For example some instructions may need to be recirculated through a pipeline and thus not retired. Therefore in one example instructions associated with recirculation causing events may be identified. The determining will be performed in hardware.

Method may also include at analyzing the data stored at on a processor cycle basis to locate a first performance monitoring data location. The first performance monitoring data location may be associated with an instruction that was retiring from the pipeline in the pipelined microprocessor when the particular performance monitoring event occurred. The first location may store for example a record or other aggregation of address and state information.

In one example analyzing the performance monitoring data on a processor cycle basis may begin by identifying the last performance monitoring data that was stored and accessing a variable e.g. data value that stores a count of processor cycles that occurred between the last performance monitoring data being stored and the particular performance monitoring event occurring. Then starting from the last performance monitoring data stored the analysis may include moving logically backwards in time through performance monitoring data until an amount of data sufficient to account for the count of processor cycles has been traversed. Having accounted for the appropriate number of processor cycles the analysis may include establishing the location in the performance monitoring data as the first performance monitoring data location.

Method may also include at analyzing the performance monitoring data relative to the first performance monitoring data location on a retirement event basis to locate a second performance monitoring data location. The second performance monitoring data location may be associated with an instruction that was executing at an identified pipeline stage in the pipelined microprocessor when the particular performance monitoring event occurred. The second location may store for example a record or other aggregation of address and state information.

In one example analyzing the performance monitoring data relative to the first performance monitoring data location on a retirement event basis may include accessing a variable e.g. data value that stores a count of the number of retirement events that occurred between the last performance monitoring data being stored and the particular performance monitoring event occurring and accessing a data value that identifies a pipeline stage with which the particular performance monitoring event is related. Then starting at the first performance monitoring data location identified at moving logically forwards in time through the performance monitoring data until an amount of performance monitoring data sufficient to account for the number of retirement events is traversed. Having accounted for the appropriate amount of data the analysis may include establishing the location as the second performance monitoring data location. Since the second performance monitoring data location stores a record associated with the instruction that caused the particular performance monitoring event the address of that instruction may then be retrieved from the second location.

At a determination may be made concerning whether another cycle of collecting performance monitoring data and acquiring an address associated with a particular performance monitoring event is to occur. If the determination is Yes then processing may return to otherwise processing may conclude.

In one example methodologies may be implemented as processor executable instructions and or operations provided on a computer readable medium. Thus in one example a computer readable medium may store processor executable instructions operable to perform a method associated with acquiring the address of an instruction associated with causing a performance monitoring event. The method may include storing data concerning instructions and or performance monitoring events related to a pipelined microprocessor and determining that a particular performance monitoring event has occurred. The method may also include moving through the performance monitoring data on a processor cycle basis to locate a first performance monitoring data location associated with an instruction that was retiring from the pipeline in the pipelined microprocessor when the particular performance monitoring event occurred and then analyzing the performance monitoring data relative to the first performance monitoring data location on a retirement event basis to locate a second performance monitoring data location associated with an instruction that was executing at an identified pipeline stage in the pipelined microprocessor when the particular performance monitoring event occurred. The method may also include retrieving an address of an instruction associated with the particular performance monitoring event from the second performance monitoring data location.

While the above method is described being provided on a computer readable medium it is to be appreciated that other example methods described herein can also be provided on a computer readable medium.

Thus method may include selectively recording instruction and state data for instructions as they retire from a pipeline in a pipelined microprocessor. Additionally and or alternatively method may include selectively recording instruction and state data only upon the occurrence of an event. The instruction and state data may be stored in a hardware based data store.

Thus method may include at counting an event occurring as a result of an instruction being processed at a stage in the pipelined microprocessor. At a determination may be made concerning whether the event is an event for which instruction and state data is to be collected. If the determination at is No then processing may jump ahead to otherwise processing may continue at . The determining will be done in hardware.

Method may include at selectively collecting address data associated with an instruction retiring from the pipeline and at selectively collecting cycle count data concerning the number of cycles since a previous address data was collected. Method may also include at selectively collecting an instruction pointer validity data that identifies whether an instruction for which address data was collected successfully retired from a pipeline in the pipelined microprocessor and at selectively collecting a flush status data that identifies whether the pipeline was flushed after the recording of the previous data entry and prior to retirement data being recorded for the instruction identified by the address data. Similarly at data concerning whether a freeze status data that identifies whether recording of performance monitoring data was suspended before retirement data was recorded for the instruction identified by the address data can be collected.

Collecting the instruction pointer data at facilitates locating the address of a particular instruction. Collecting the cycle count data at facilitates determining which record s may be associated with different instructions executing at different pipestages. Collecting cycle count data facilitates determining which record was associated with the retirement stage at the time of the event occurrence. Collecting the pipestage validity information the flush status information and the freeze status information facilitates determining whether the address of a particular instruction is available.

At a determination is made concerning whether another round of counting events and collecting information is to be performed. If the determination at is Yes then processing may return to otherwise processing may conclude.

The processor can be a variety of various processors including dual microprocessor and other multi processor architectures. The memory can include volatile memory and or non volatile memory. The non volatile memory can include but is not limited to ROM PROM EPROM EEPROM and the like. Volatile memory can include for example RAM synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM and direct RAM bus RAM DRRAM .

A disk may be operably connected to the computer via for example an input output interface e.g. card device and an input output port . The disk can include but is not limited to devices like a magnetic disk drive a solid state disk drive a floppy disk drive a tape drive a Zip drive a flash memory card and or a memory stick. Furthermore the disk can include optical drives like a CD ROM a CD recordable drive CD R drive a CD rewriteable drive CD RW drive and or a digital video ROM drive DVD ROM . The memory can store processes and or data for example. The disk and or memory can store an operating system that controls and allocates resources of the computer .

The bus can be a single internal bus interconnect architecture and or other bus or mesh architectures. While a single bus is illustrated it is to be appreciated that computer may communicate with various devices logics and peripherals using other busses that are not illustrated e.g. PCIE SATA Infiniband 1394 USB Ethernet . The bus can be of a variety of types including but not limited to a memory bus or memory controller a peripheral bus or external bus a crossbar switch and or a local bus. The local bus can be of varieties including but not limited to an industrial standard architecture ISA bus a microchannel architecture MSA bus an extended ISA EISA bus a peripheral component interconnect PCI bus a universal serial USB bus and a small computer systems interface SCSI bus.

The computer may interact with input output devices via i o interfaces and input output ports . Input output devices can include but are not limited to a keyboard a microphone a pointing and selection device cameras video cards displays disk network devices and the like. The input output ports can include but are not limited to serial ports parallel ports and USB ports.

The computer can operate in a network environment and thus may be connected to network devices via the i o interfaces and or the i o ports . Through the network devices the computer may interact with a network. Through the network the computer may be logically connected to remote computers. The networks with which the computer may interact include but are not limited to a local area network LAN a wide area network WAN and other networks. The network devices can connect to LAN technologies including but not limited to fiber distributed data interface FDDI copper distributed data interface CDDI Ethernet IEEE 802.3 token ring IEEE 802.5 wireless computer communication IEEE 802.11 Bluetooth IEEE 802.15.1 Zigbee IEEE 802.15.4 and the like. Similarly the network devices can connect to WAN technologies including but not limited to point to point links circuit switching networks like integrated services digital networks ISDN packet switching networks and digital subscriber lines DSL . While individual network types are described it is to be appreciated that communications via over and or through a network may include combinations and mixtures of communications.

The image forming device may receive print data to be rendered. Thus image forming device may also include a memory configured to store print data or to be used more generally for image processing. The image forming device may also include a rendering logic configured to generate a printer ready image from print data. Rendering varies based on the format of the data involved and the type of imaging device. In general the rendering logic converts high level data into a graphical image for display or printing e.g. the print ready image . For example one form is ray tracing that takes a mathematical model of a three dimensional object or scene and converts it into a bitmap image. Another example is the process of converting HTML into an image for display printing. It is to be appreciated that the image forming device may receive printer ready data that does not need to be rendered and thus the rendering logic may not appear in some image forming devices.

The image forming device may also include an image forming mechanism configured to generate an image onto print media from the print ready image. The image forming mechanism may vary based on the type of the imaging device and may include a laser imaging mechanism other toner based imaging mechanisms an ink jet mechanism digital imaging mechanism or other imaging reproduction engine. A processor may be included that is implemented with logic to control the operation of the image forming device . In one example the processor includes logic that is capable of executing Java instructions. Other components of the image forming device are not described herein but may include media handling and storage mechanisms sensors controllers and other components involved in the imaging process.

Referring now to information can be transmitted between various computer components and or logics associated with performance monitoring as described herein via a data packet . The data packet includes a header field that includes information like the length and type of packet. A source identifier follows the header field and includes for example an address of the computer component and or logic from which the packet originated. Following the source identifier the packet includes a destination identifier that holds for example an address of the computer component and or logic to which the packet is ultimately destined. Source and destination identifiers can be for example a globally unique identifier GUID a uniform resource locator URLs a path name and the like. The data field in the packet includes various information intended for the receiving computer component and or logic. The data packet ends with an error detecting and or correcting field whereby a computer component and or logic can determine if it has properly received the packet . While five fields are illustrated in a certain order it is to be appreciated that a greater and or lesser number of fields arranged in different orders can be present in example data packets.

Referring now to an application programming interface API is illustrated providing access to a system for acquiring data like the address of an instruction associated with e.g. causing a performance monitoring event. The API can be employed for example by a programmer and or a process to gain access to processing performed by the system . For example a programmer can write a program to access the system e.g. invoke its operation monitor its operation control its operation where writing the program is facilitated by the presence of the API . Rather than programmer having to understand the internals of the system the programmer merely has to learn the interface to the system . This facilitates encapsulating the functionality of the system while exposing that functionality.

Similarly the API can be employed to provide data values to the system and or retrieve data values from the system . For example a process that performs performance monitoring analysis may receive status data from the system via the API by for example using a call provided in the API . Thus in one example of the API a set of application programming interfaces can be stored on a computer readable medium. The interfaces can be employed by a programmer computer component logic and so on to gain access to a system for acquiring data like the address of an instruction associated with a performance monitoring event. The interfaces can include but are not limited to a first interface that communicates an instruction pointer data a second interface that communicates an event count data and a third interface that communicates a status data. The instruction pointer data may for example identify an instruction that caused a performance monitoring event to be counted. The event count data may for example identify the number of performance monitoring events for which instruction pointer data is available. The status data may for example identify whether valid instruction pointer data is likely to be available in the system .

While example systems methods and so on have been illustrated by describing examples and while the examples have been described in considerable detail it is not the intention of the applicants to restrict or in any way limit the scope of the appended claims to such detail. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the systems methods and so on described herein. Additional advantages and modifications will readily appear to those skilled in the art. Therefore the invention is not limited to the specific details the representative apparatus and illustrative examples shown and described. Thus this application is intended to embrace alterations modifications and variations that fall within the scope of the appended claims. Furthermore the preceding description is not meant to limit the scope of the invention. Rather the scope of the invention is to be determined by the appended claims and their equivalents.

To the extent that the term includes or including is employed in the detailed description or the claims it is intended to be inclusive in a manner similar to the term comprising as that term is interpreted when employed as a transitional word in a claim. Furthermore to the extent that the term or is employed in the detailed description or claims e.g. A or B it is intended to mean A or B or both . When the applicants intend to indicate only A or B but not both then the term only A or B but not both will be employed. Thus use of the term or herein is the inclusive and not the exclusive use. See Bryan A. Garner A Dictionary of Modern Legal Usage 624 2d. Ed. 1995 .

To the extent that the phrase one or more of A B and C is employed herein e.g. a data store configured to store one or more of A B and C it is intended to convey the set of possibilities A B C AB AC BC and or ABC e.g. the data store may store only A only B only C A B A C B C and or A B C . It is not intended to require one of A one of B and one of C. When the applicants intend to indicate at least one of A at least one of B and at least one of C then the phrasing at least one of A at least one of B and at least one of C will be employed.

