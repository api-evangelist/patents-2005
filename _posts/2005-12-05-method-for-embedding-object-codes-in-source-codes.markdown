---

title: Method for embedding object codes in source codes
abstract: Methods for embedding codes executable in a first system having a first microprocessor into codes executable in a second system having a second microprocessor are described herein. In one aspect of the invention, an exemplary method includes providing first codes having a routine, the first codes being compilable to be executed in the first system, and compiling the first codes, resulting in second codes; the second codes comprising opcodes of the routine executable by the first system, which convert the second codes into third codes automatically, the third codes being compilable to be executed by the second system; this is followed by compiling the third codes, resulting in the fourth codes being executable in the second system, and linking the fourth codes, generating an executable image and executing the executable image in the second system. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694289&OS=07694289&RS=07694289
owner: Apple Inc.
number: 07694289
owner_city: Cupertino
owner_country: US
publication_date: 20051205
---
This application is a continuation application of U.S. patent application Ser. No. 10 011 342 filed Nov. 12 2001 now U.S. Pat. No. 6 976 249.

The present invention relates generally to computer systems and more specifically to a method of embedding an object code executable in one architecture into a source code compilable to be executed in another architecture.

When a new computer processor is developed existing applications or programs herein applications which executed properly on a prior computer processor may not execute properly on the new computer processor. These old or in other words non native applications are typically ported i.e. rewritten or translated to run on the new processor. Usually until an application is ported it is unable to take advantage of any beneficial features in the new processor. Depending on the amount of effort required to port the application there may be a substantial amount of time lost before an application can benefit from the new processor.

Typically a computer system having the new computer processor will have a separate environment for running old applications written for the old processor. This environment is called a compatibility box. In these systems there is substantially no interaction between the compatibility box and the new processor environment otherwise known as the native environment. Thus old applications cannot take advantage of performance benefits and other advantageous features available in the native environment. It is often difficult to execute arbitrary old code from the native environment as well.

Some computer systems have emulators which permit the computer system to execute code which is written for a processor other than the processor which is native to the computer system. Typically these emulators assume a single runtime environment that is to say they assume that the conventions for invoking program procedures and performing stack manipulations are common to both the native and non native or emulated code. These emulators typically just alter the instructions set and are not structured to handle two different types of program object code which have different routine calling and stack manipulation conventions.

However the process to embed the object codes in a new source code is quite labor intensive. For instance the assembly instructions executable by Motorola s 680x0 microprocessor in a Macintosh computer cannot be executed directly by a PowerPC processor of a PowerPC computer. shows an example of assembly instructions written in Motorola s 680x0 assembly language. In order for the codes being able to execute in PowerPC computer the assembly instructions may required to be translated into PowerPC instructions or into a language which can be compiled into PowerPC instructions e.g. C language such as one shown in . In some cases it is impractical to rewrite the routine in C for example function SETSTATUSREGISTER may not possibly be implemented because there is no direct analogy in the PowerPC instruction set as to what is being done. Therefore it is necessary to embed the object code of the routine in the source code of the PowerPC computer in order to allow the emulator to perform the execution.

One method to embed an object code such as the object code of the routine of in a source code of PowerPC is to compile the routine with a 680x0 compatible assembler create corresponding code resources for the routine in a resource file and calculate an offset of the routine and then place this code in a resource where it can be loaded later. At runtime the resource would be loaded in memory the entry point of the routine would be calculated and the routine would be called by telling the emulator to begin execution of this calculated code address.

There are some disadvantages of this method. One of the disadvantages is that the resource may not be loaded successfully due to numerous reasons e.g. not enough memory etc. another disadvantage is that the entry point may not be valid e.g. nil pointer . Thus there is no guarantee of having the routine available at runtime. In addition this process involves intense manual calculations which post inconvenience and poor efficiency to the software development. Therefore a method to automatically embed an object code in a source code is highly desired.

Methods for embedding codes executable in a first system having a first microprocessor into codes executable in a second system having a second microprocessor are described herein. In one aspect of the invention an exemplary method includes providing first codes having a routine the first codes being compilable to be executed in the first system and compiling the first codes resulting in second codes the second codes comprising opcodes of the routine executable by the first system which convert the second codes into third codes automatically the third codes being compilable to be executed by the second system this is followed by compiling the third codes resulting in the fourth codes being executable in the second system and linking the fourth codes generating an executable image and executing the executable image in the second system.

In one particular exemplary embodiment the method includes opening an input file containing the second codes detecting the routine automatically converting the routine into a data structure compatible with the second system and writing the data structure to an output file. Further the method includes extracting the opcodes from the routine defining the data structure using the name of the routine the data structure being compilable to be executed by the second system and adding the opcodes into the data structure as constants.

The present invention includes apparatuses which perform these methods and machine readable media which when executed on a data processing system cause the system to perform these methods. Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.

The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of the present invention. However in certain instances well known or conventional details are not described in order to not unnecessarily obscure the present invention in detail.

As shown in the computer system which is a form of a data processing system includes a bus which is coupled to a microprocessor and a ROM a volatile RAM and a non volatile memory . The microprocessor which may be a G3 or G4 microprocessor from Motorola Inc. or IBM is coupled to cache memory as shown in the example of . The bus interconnects these various components together and also interconnects these components and to a display controller and display device as well as to peripheral devices such as input output I O devices which may be mice keyboards modems network interfaces printers and other devices which are well known in the art. Typically the input output devices are coupled to the system through input output controllers . The volatile RAM is typically implemented as dynamic RAM DRAM which requires power continuously in order to refresh or maintain the data in the memory. The non volatile memory is typically a magnetic hard drive a magnetic optical drive an optical drive or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically the non volatile memory will also be a random access memory although this is not required. While shows that the non volatile memory is a local device coupled directly to the rest of the components in the data processing system it will be appreciated that the present invention may utilize a non volatile memory which is remote from the system such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus may include one or more buses connected to each other through various bridges controllers and or adapters as is well known in the art. In one embodiment the I O controller includes a USB Universal Serial Bus adapter for controlling USB peripherals.

A computer such as computer system of normally comprises hardware and software executed by a processor such as microprocessor . shows an architecture of a computer system. The software includes applications operating system and the hardware . The applications communicate with the operating system through a set of application programming interfaces APIs . The operating system OS includes a plurality of managers such as window manager menu manager event manager mixed mode manager code fragment manager exception manager process manager and other managers. The OS also includes a 68LC040 emulator and a nanokernel . The hardware includes a PowerPC microprocessor.

The mixed mode manager is the part of the Macintosh Operating System that allows PowerPC processor based Macintosh computers to cooperatively run 68k applications PowerPC applications 68k system software and PowerPC system software. It provides a number of capabilities including transparent access to 68k based system software from PowerPC applications and transparent access to PowerPC processor based system software from 68k applications. The mixed mode manager provides methods which are independent of the instruction set architecture of calling an external piece of code. The methods include transparent access to PowerPC code by 68k applications system support for calling 68k code from PowerPC code and system support for calling PowerPC code from 68k code.

The mixed mode manager is intended to provide both PowerPC processor based and 68k based code transparent access to code written in another instruction set. It does this by keeping track of what kind of code is currently executing and when necessary switching modes. For example if some PowerPC code calls a Macintosh operating system routine that exists only in 68k form the mixed mode manager translates the routine s parameters from their PowerPC arrangement into the appropriate 68k arrangement. The mixed mode manager is an integral part of the system software for PowerPC processor based Macintosh computers. It is designed to hide as much as possible the dual nature of the operating environment supported on PowerPC processor based Macintosh computers running the 68k emulator e.g. 68LC040 emulator .

The 68k emulator is the part of the PowerPC system software that allows 68k based applications and other software to execute on PowerPC processor based Macintosh computers. Emulator provides an execution environment that is virtually identical to the execution environment found on 68k based Macintosh computers. shows an operation of the 68k emulator . Referring to when the emulator receives a 68k application it converts 68k instructions into PowerPC instructions issues those instructions to the PowerPC microprocessor and updates the emulated environment in response to the operations of the PowerPC microprocessor .

Code fragment manager is the part of the Macintosh system software that loads fragments into memory and prepares them for execution. A fragment can be an application an import library a system extension or any other block of executable code and its associated data. The code fragment manager is the operating system loader for executable code and data that are contained in fragments. The code fragment manager provides loading and preparation of fragments for execution automatic resolution of imported symbols by locating and loading import libraries used by a fragment automatic execution of a fragment s initialization and termination routines and support for updated version of import libraries.

Now referring to when an application is loaded to execute by the code fragment manager the processor manager such as processor manager of examines the application. Typically it examines the header of the application to determine whether the application is a 68k based application. If the application is a 68k application it examines whether the application needs communicate with PowerPC code e.g. switch mode if so the mixed mode manager is invoked to provide transparent access to the PowerPC system software and thereafter the application is executed by the PowerPC microprocessor through the nanokernel . If the 68k application does not need to communicate with PowerPC system software it is executed through a 68k emulator and thereafter to the PowerPC processor through nanokernel .

The PowerPC application is also examined to determine whether it needs to communicate with 68k system software if so the mixed mode manager is invoked to switch from PowerPC environment to 68k environment and provides transparent access to the 68k system software . The 68k code is executed through the 68k emulator and thereafter to the PowerPC processor through nanokernel . If the PowerPC application does not need to call 68k system software it communicates directly with PowerPC system software and thereafter to the PowerPC processor through nanokernel .

Further detail concerning mixed mode operation can be found in U.S. Pat. No. 5 452 456 entitled Apparatus for Executing a Plurality of Program Segments Having Different Object Code Types in a Single Program or Processor Environment filed by Jean Charles d. Mourey et al. issued Sep. 19 1995 and assigned to the same Assignee as the present invention. Such patent is hereby incorporated by reference.

As described above much of the Macintosh OS consists of native PowerPC code but some parts are still 68k code that executes inside the emulator which is part of the system software. It is occasionally necessary to execute small pieces of 68k code to perform some tasks which cannot be done from PowerPC code. Typically in a conventional method these pieces of code are constructed by hand once and stored in the system file in a resource and therefore making any change to them is tedious error prone and difficult.

The present invention introduces a method that uses a set of scripts which are run from a MAKE file such as the MAKE file shown in which uses the existing tools to assemble compile and automatically insert these pieces of 68k code into the native code fragment. Several scripts such as scripts shown in and a utility e.g. StreamEdit are used which are run during the make phase. A 68k code such as the codes shown in which needs to be called from a native code is written in a file exactly as if it were to be linked in and called directly. The 68k codes are assembled using the existing 68k assembler but the actual object codes generated are not used. Instead a StreamEdit script e.g. scripts shown in processes the textual output of the assembler as shown in and creates a file as shown in which can be compiled by a C C compiler such as MrC PowerPC compiler. The file shown in contains C structure definitions which contain the opcodes for the matching 68k code. This newly created .c file is then compiled by a native compiler e.g. MrC PowerPC compiler and linked in with the rest of the PowerPC codes. Within the native code mixed mode calls use the addresses of these C structures e.g. the C structure shown in as the code addresses to execute. Thus native code is able to call 68k code without requiring significant extra work on the part of the programmer e.g. create code resource hand calculate offsets of each routine at runtime load lock and error check each resource and calculate each entry point etc. .

A conventional method uses an exiting 68k assembler to assemble the 68k assembly codes. The 68k assembler generates an object file. Next code resources are generated based on the object file. Then these code resources are included in a place where they may be retrieved later at runtime. One of the disadvantages of this method is that the offsets of the routines have to be calculated by hand. The types and Ids of all such code resources need to be tracked administratively by the software developers. This posts significant burdens on a large scale project. At runtime the application loads the code resources from the appropriate system resource file and calculates the entry points of the routines. For example an application needs to call routine of s68kInstructionsForDisableThunk such as one shown in . The application retrieves and calculates the entry point of that by calling 

Referring to the method starts with receiving a 68k assembly codes. An example of the 68k assembly codes are shown in . The 68k assembly codes may be specifically written to be executed by a 680x0 compatible Macintosh computer. The 68k assembly codes are then assembled with an existing 68k assembler. Output of the 68k assembler includes an object file e.g. .o file containing object code and a listing file e.g. .lst file . shows an example of the listing file corresponding to the assembly codes shown in . The listing file contains opcodes of the assembly instructions. For instance hex value of 0x7000 is the opcode of instruction moveq 0 d0 as described in . The opcodes of the 68k assembly instructions may not be executed directly by a PowerPC processor. They may however be executed through an emulator e.g. 68LC040 emulator . Next the listing file containing opcodes of the 68k assembly codes is processed by a set of scripts and a StreamEdit utility automatically. shows an example of the scripts used in one embodiment of the present invention. The StreamEdit utility converts the opcodes listed in the listing file into C C compatible data structures as shown in . The data structures shown in may be compiled by a native C C compiler e.g. MrC PowerPC compiler dedicated to the PowerPC processor generating an object file containing the opcodes of the assembly codes. Then the newly created object file is linked with the rest of the native codes to generate a final executable image which may be executed by a PowerPC processor. As a result the opcodes of the 68k assembly codes are embedded in the data section of the native codes executed in a PowerPC computer. Since the object codes of the 68k assembly codes are located in the data section of the executable image they are accessible anytime as global variables from the rest of the native codes. This method provides advantages over the conventional approach. The conventional approach loads the opcodes through code resources stored in system resource files at runtime. The codes may not be loaded successfully at all times for a variety of reasons. As a result additional attempts and error checking must be followed. The present invention presents this unique method of embedding 68k opcodes in native codes automatically. One of the advantages of the present invention is that the 68k routines are embedded in the static data section of the final native executable image. The routines are treated as static global variables which are always available. The calling routine does not need to invoke the system resources. Instead the native calling routine can call the 68k routine directly 

where CallUniversalProc is an API to the mixed mode manager. shows an example of a main routine calling the embedded object code. The caller does not need to check if this code is available because the 68k opcode resides in the static data section of the native code. They are always available once the native executable image is loaded. The entire processes are performed automatically without involving a great burden on a programmer. In one embodiment the entire processes are typically configured by a MAKE file such as the MAKE file shown in .

Referring to the method opens an input which may be the listing file generated from the compilation of the 68k assembly codes such as the assembly codes shown in . An example of the listing file is shown in . A line is then read from the listing file. Next the method scans the line read from the input file for the starting of a routine. The start of a routine normally contains a token indicating the starting of the routine such as PROC shown in . If a routine is detected a data structure is created using the name of the routine detected e.g. name of the routine s68kInstructionsForDisableThunk . The data structure is C C compatible in general. Once the data structure is created it continues to read a next line from the input file. Then it scans the line and extracts the opcode e.g. hex number 0x7000 of from the line and adds the opcode in the data structure. An example of the data structure is shown in . If the end of the routine is detected e.g. endproc is detected the data structure is completed and the method starts to process a next routine. If the end of file EOF is detected it writes all data structures created during the processes to an output file and the processes end. In another embodiment the method opens an output file simultaneously and writes the data structure to the output file once the data structure is completed.

It is important to note that the present invention is not limited to embed 68k assembly codes in a C C source code. The present invention may be used to embed one architecture s codes such as Java bytecodes in another architecture s codes e.g. data section of an executable image . Although the 68k assembly codes are put into a separate file according to an embodiment of the invention it would be appreciated that the 68k codes may be embedded inline with an original C C code.

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

