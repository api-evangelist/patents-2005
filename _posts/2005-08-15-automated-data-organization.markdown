---

title: Automated data organization
abstract: A system for automating data processing is presented. The system comprises an end-user programming module that is integrated with an underlying file system and that maps an event of a computing system to at least one automatic action that is defined by an end user. The system also includes an event handler that responds to events and causes the at least one automatic action to be performed. Methods of using the system are also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07565663&OS=07565663&RS=07565663
owner: Microsoft Corporation
number: 07565663
owner_city: Redmond
owner_country: US
publication_date: 20050815
---
This is an application claiming benefit under 35 U.S.C. 119 e of U.S. Provisional Patent Application Ser. No. 60 657 519 entitled AUTOMATED DATA ORGANIZATION and filed on Feb. 28 2005. The entirety of the aforementioned application including all attachments or exhibits thereto is hereby incorporated by reference.

Modern computing systems can include many software processes active at any one time in various states of execution. These processes can be initiated by an operating system can monitor or service processes that are initialized at start time or upon launching a user application or can be a user application itself. Many if not most of these processes or features of these processes are beyond the ability of a user to control directly. Therefore if functionality offered by these processes is to be accessed at all such access usually typically must be accomplished by another software process.

Software applications manage information on behalf of end users. The number of software applications or processes running on a computing system is generally a function of the amount of data the system must process and the number of tasks the system is called upon to perform. The least efficient parts of these computing duties are the ones that require human interaction. Despite increasingly powerful machines end users typically have to manually process a great deal of computerized information.

One major component of a general computing system is a storage device such as a hard disk drive which is commonly used for persistent storage of electronic information such as data files and executable programs. To organize electronic information so that it can be located and retrieved in a usable form a file system can be employed. Many file systems exist but generally all provide a conceptual organizational layer for the format and location of information on a storage device.

The conceptual organizational layer provided by a file system can be employed by software processes like those of an operating system to create access retrieve delete and otherwise manage information stored on the storage device. To protect integrity of the file system and ensure adherence to the format of the file system generally only certain privileged software processes like input output processes of an operating system are allowed direct access to the file system. Applications and users that access a file system generally must do so through functions provided by the operating system. These functions are usually hidden from the view of end users who may not even know of the existence of these functions. Commonly this restricted access results in an inability of a user to fully exploit features of the file system to make computing tasks easier for example by using attributes of the file system to automate tasks such as file organization or location.

Generally an end user manages information on his her computer according to an information life cycle. During that life cycle the end user usually creates information or obtains information from some source and the information is then stored in a file system. At some point the end user retrieves the information and takes action based on that information this cycle can be repeated many times. Current systems do no provide for an end user to automate portions of this life cycle in ways that are efficient and personalized to the needs of the end user.

The following presents a simplified summary in order to provide a basic understanding. This summary is not an extensive overview. It is neither intended to identify key critical elements nor to delineate scope. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description later presented. Additionally section headings used herein are provided merely for convenience and should not be taken as limiting in any way.

An end user programming module provides a capability for end users of a computing system to identify events that can serve as triggers for one or more user defined actions. The end users can by using the module define data processing tasks to be automatically performed upon the occurrence of a chosen event. These data processing tasks can include file organization and file filtering for attributes or content among other tasks. Performance of such tasks may be performed by one or more components of the computing system. Thus by way of the end user programming module users can generate customized end user programs that aid in storage and organization of data.

End user programs created with an end user programming module can be created from one or more basic types which can be combined to form complex entities that can be used to perform tasks. Basic types can be further combined with other components to perform more complicated tasks. The actions to be performed can be triggered automatically by a preselected event without the need for the end user to initiate the actions or interact with a computing system while the tasks are being performed. Therefore rather than being forced to review data and make decisions regarding where to store such data a user can through utilization of the aforementioned basis types cause such data to be automatically filtered and stored in a desirable location. Furthermore actions can be automatically undertaken upon occurrence of an event such as receipt of data . In one example the user can specify that each time an email message from a particular individual is received an instant messaging application will be invoked and an instant message will be delivered to a particular contact. Thus it can be discerned that specified actions can occur across disparate applications through utilization of the basic types or combination of basic types . In another example the actions defined by a user can be explicitly invoked by a command from an end user.

To aid usability an end user programming system can be integrated with a file system to provide a uniform interface to information stored on a computing system. Integration between the end user programming module and the file system provides an ability for an end user to define rules and actions to be taken on stored data wherein rules can be applied and actions taken on the data with or without user interaction. This type of end user programming system can provide an end user with the ability to manage data using functions of the underlying file system that otherwise would be hidden and which the end user would be prohibited from accessing.

The disclosed and described components and methods comprise the features hereinafter described and particularly pointed out in the claims. The following description and the annexed drawings set forth in detail certain illustrative aspects. These aspects are indicative however of but a few of the various ways in which the disclosed components and methods can be employed. Specific implementations of the disclosed and described components and methods can include some many or all of such components methods and their equivalents. Variations of the specific implementations and examples presented herein will become apparent from the following detailed description when considered in conjunction with the drawings.

As used in this application the terms component system module and the like are intended to refer to a computer related entity such as hardware software for instance in execution and or firmware. For example a component can be a process running on a processor a processor an object an executable a program and or a computer. Also both an application running on a server and the server can be components. One or more components can reside within a process and a component can be localized on one computer and or distributed between two or more computers.

Disclosed components and methods are described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the disclosed subject matter. It may be evident however that certain of these specific details can be omitted or combined with others in a specific implementation. In other instances certain structures and devices are shown in block diagram form in order to facilitate description. Additionally although specific examples set forth may use terminology that is consistent with client server architectures or may even be examples of client server implementations skilled artisans will appreciate that the roles of client and server may be reversed that the disclosed and described components and methods are not limited to client server architectures and may be readily adapted for use in other architectures specifically including peer to peer P2P architectures without departing from the spirit or scope of the disclosed and described components and methods. Further it should be noted that although specific examples presented herein include or reference specific components an implementation of the components and methods disclosed and described herein is not necessarily limited to those specific components and can be employed in other contexts as well.

Artificial intelligence based systems for example explicitly and or implicitly trained classifiers can be employed in connection with performing inference and or probabilistic determinations and or statistical based determinations as in accordance with one or more aspects of the subject invention as described hereinafter. As used herein the term inference refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can be employed to identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources. Various classification schemes and or systems for example support vector machines neural networks expert systems Bayesian belief networks fuzzy logic and data fusion engines among others can be employed in connection with performing automatic and or inferred action in connection with the components and methods disclosed and described herein.

An end user programming EUP module can provide a component that can be operated by an end user to define an action such as a user defined action to be taken upon the occurrence of the event . It should be noted that the user defined action can be a single task or can be a group of tasks to be performed. The EUP module can provide an interface to system functions that can be operated manually or previously could only be accessed by other software components such as but not limited to an operating system or a service component.

In operation an end user accesses the EUP module to identify an event such as the event that can be used to trigger a user defined action. The end user also defines an action or group of actions that the end user wants the system to execute automatically upon the occurrence of the identified event. The event is then bound to the user defined action in other words upon occurrence of the event the operating platform performs the user defined action.

For example an end user can identify reception of an email message from a particular person as a triggering event. The end user can then create an action so that upon receipt of such an email message the message is transferred to a defined mailbox folder a reply verifying receipt of the message is sent to the sender a document is retrieved from a file server and opened in an appropriate program and an audible alert sounds to notify the user that the document is ready on the computer. These steps can be performed automatically without user intervention through utilization of the system .

In operation the user interface provides access to the event handler and the rules data store to an end user who can identify an event to be used as a trigger event and cause binding of that event to a user defined action. The user defined action can then in turn be stored within the rules data store . The operating platform creates an event that is detected by the event handler which can access the rules data store to determine whether a user defined action is bound to the detected event. If so the event handler accesses the processing subsystem to direct the performance of the user defined action.

Rules to be applied during creation or execution of end user defined tasks can be in accordance with a rules algebra. Details of an appropriate rules algebra that can be used can vary greatly according to a specific implementation of an EUP module. One exemplary rules algebra is presented and described in more detail below. The exemplary rules algebra can include various logic components that can be integrated to form a rules platform. Among those components are basic terms that can serve as building blocks for other terms and expressions. Terms and expressions that have been built from other terms or expressions can themselves be used as building blocks to create more complex terms or expressions. In this manner increasingly complex rules can be created to be applied during execution of an end user defined task.

A Property T can describe a property of an end user type T. An end user can use a property or properties to describe another logic component such as a filter or an action. A property can be some general descriptor of an end user type T. When applied to different types such as T or T prime the same descriptor can be used. In this manner Property T and Property T prime can both be used as descriptors and can be different components. A rule that has an input item type T and output type O can be defined as a property of type O over type T.

A Filter T can be a Boolean function that can be used as a filter over items of type T. Specifically a Filter T can be a rule that returns a Boolean type as a processing result of the execution of the rule. A Filter T rule that is applied to a set of items can filter items that do not meet a condition of the rule by examining a value for the Boolean type returned following execution of the Filter T over an individual item in the set. An item that meets a condition of the Filter T rule can prompt the applied Filter T rule to return a value of TRUE for the Boolean type returned.

In a similar manner an item that does not meet a condition of the applied Filter T rule can prompt the Filter T rule to return a value of FALSE for the Boolean type returned. The Filter T rule can be iteratively applied to each item in a set to obtain subsets of items that either meet or fail to meet the condition of the applied Filter T rule. In this manner inclusive or exclusive subsets can be created. An inclusive subset can have items that meet a condition of the applied Filter T rule and which prompt a returned Boolean value of TRUE resulting in those items being described as included. An exclusive subset can have items that fail to meet a condition of the applied Filter T rule and which prompt a returned Boolean value of FALSE resulting in those items being described as excluded. Either subset can be used in further processing.

An Action T can be created as a method of an item of type T wherein the method can have some desired side effect that creates a result. Typically an Action T can use or require other parameters. A rule having an input type T and outputting a closed set can define an action over items of type T. A Set T is a grouping of items of type T.

An Event T can be used to define some occurrence of interest and is typically associated with an item of data for instance the event data of type T. An Event T can be used to define a simple event or can be used as a building block to create a more complex event by using a binary algebraic operation. When combined with a Filter T an Event T can be used to create a derived Event T . In algebraic terms DerivedEvent Event Filter . Generally a derived event can be created by applying a filter to an event. Other constructs can also be formed using algebraic principles. For example two filters over complementary item types e.g. two types that are both subtypes of the same parent type can be combined as follows Filter Filter1 1 Union Filter2 2 .

A batch can define a set oriented task to be performed by a program module. Semantics of a batch can be defined to result in execution of some predefined action upon each item in a set. As with other modules a batch can be executed upon a manual command or upon automatic occurrence of some event. A batch can be created by combining a set with an action as follows Batch Set Action . An agent can define some action to be performed upon occurrence of a predefined event where the predefined event can serve as a trigger that can activate execution of the agent and performance of the action associated with the agent. In algebraic terms Agent Event Action .

Rules can be created using a variety of conditions that can be connected in some logical fashion. Within each rule conditions can be composed a variety of ways. For example items having a specified property can be described using 

Individual EUP logic components can be evaluated within an application. Such evaluations can be performed as background tasks and therefore be invisible to a user. Additionally or alternatively these tasks can be explicitly executed subject to a command input by a user. Generally several types of programs can be used as a core group of programs. For example a core type such as a derived set can be a complete end user program. When a derived set is activated or executed commands associated with the logic of the set definition can be executed and results of that execution displayed. Additionally derived sets can be used in algebraic operations. For example two derived sets can be combined as follows Set Set1 Union Set2 . As another example agents can be created to perform specified actions upon the occurrence of predefined events. As previously defined an Agent is an Event T combined with an Action T . Upon occurrence of the event portion of the agent the processing steps of the action portion of the agent can be performed. In this manner execution of an agent can be triggered without any intervention from an end user.

An EUP algebra can be accessed through an application programming interface API which can provide a means to access object types and operations prescribed by the rules algebra. Additionally the API can provide a group of predefined components such as previously constructed EUP logic components that can be accessed directly as an alternative to constructing such components from basic terms.

The rule event component can be a base type for all the event types used by rules platform agents created by end users and can be conceptually abstract and serve to provide a common type that can be referenced by each agent. An agent can refer to an instance of a rule event component such as the rule event component that can notify the agent when to execute or trigger such execution. The rule event component can for instance be or be associated with a basic event such as basic event or a derived event such as the filtered event . In one example the basic event can be derived from the rule event component . A basic event type such as the basic event can act as a hook point for an application to submit an input item to a rules system to represent the firing of a logical event. For example a basic event can represent such events as an item being added to a data store or an item of a data store being modified among others. Submitting an input item through an event item can communicate the fact that the event has occurred and begin a process that can result in firing another event.

The filtered event can also be derived from the rule event component . The filtered event can include a reference to another rule event and a reference to an instance of a filter logic type to use to filter firings of the event. The filtered event can fire based upon firing of its source rule event component such as the rule event component . Upon firing of the source event the filtered event can take an input item upon which the source event was fired and evaluate an instance of its filter logic component over the input item. The filtered event will fire if and only if the filter logic evaluates to TRUE. In this example a filtered event such as the filtered event cannot be raised directly using an API function call but rather only can be raised when its source event is fired and its filter logic evaluates to TRUE for the input item on which the source event fired.

The rule logic component can be described as a rule in the sense that the rule logic component can have defined processing steps that can cause one or more computing tasks to be performed by a component that uses or is otherwise associated with the rule logic component . The rule logic component can be or be associated with a filter logic a property logic an action logic and an association logic . The filter logic property logic action logic and association logic can be used to create rule logic. The filter logic can define rule logic that filters a given item instance of the input type. The output type for the filter logic can be a Boolean value or a null value. The property logic can also define a rule. The defined rule can calculate a value of a specified type when given a specific item instance and therefore can act as a computed property. To support this concept an output type of the property logic can be represented as a property type.

The action logic can define a rule that can generate a sequence of actions to perform when given a specific item instance of a specified input type. Output of the action logic can be an object that is enumerable and that encodes the sequence of actions to be performed. The association logic can be derived from a rule definition and can define a rule that can generate a set of items of a specified targeted type when given a specific item instance of a source type. Output of the association logic can be an instance of an enumerable item that constitutes the item set.

One class of terms described by this exemplary rules algebra includes executable components. These executable components do not themselves include logic statements but rather are wrapper programs that can be authored by an end user and serve to tie together rule logic definitions with input collections. One executable component can be the rule program . The rule program can form a common base type for end user program types. A primary function of the rule program can be to allow all instances of end user program types such as batches and agents to persist to be able to be retrieved and to be able to be filtered based upon such a common input type.

The rule program can be or be associated with other components such as a query an agent and a batch . The query can represent a computed result set of items that are able to be evaluated in accordance with strictures of a query. The agent can represent an action or actions to be performed upon the firing of an event or occurrence of some happening. The batch can represent an action or actions to be performed over a collection of items. An end user can combine these components in a wide variety of ways to create an executable rule program.

The end user programming system includes a user interface which can be any appropriate user interface such as a graphical user interface a web based interface a text based interface or a command line interface among others. The user interface is coupled to a rules layer and an end user programming module . The rules layer can include all predefined components of an EUP system including end user created agents batches and other components.

The end user programming module provides a mechanism by which an end user can define components such as agents. The end user programming module along with the user interface can provide many if not all of the functionality that an integrated development environment can provide to a traditional software developer. Such functions can include the ability to reuse components version components build components by dragging and dropping graphical widgets or by scripting actions among other approaches.

The file system layer can provide a conceptual representation of how data items are stored on some physical medium such as a hard disk or an optical disk among others. In this specific example a file system that draws heavily upon object oriented design concepts is presented. More specifically the file system layer can provide a framework within which items can be stored as part of an overall expression wherein the expression can be accessed through an API and evaluated to produce some desired result. The file system layer can also include a set of inline types that can be used for persistence only and that are not used as parameters or results of methods.

The file system layer can include a group of logical operators such as not and and or. Additionally the file system layer can provide robust programming constructs such as conditional operators arithmetic operators aggregation operators date time and string operators and type casting among others. Also methods and abilities to invoke such methods are also provided. For example various constructors destructors value accessors and value setters can be accessed through an API.

Among the support functions that the file system layer can provide are infrastructure functions for managing naming sharing storing synchronizing and searching for data. The file system layer can provide all these capabilities to the rules layer and the end user programming module so that an end user can access all the capabilities the file system can offer as part of constructing an end user program. In the examples presented herein the schema of the rules must conform to a type system supported by the file system. Also the entire API surface for end user programming concepts follows standard models of file system APIs. One side effect of these design choices is that generic user interface applications that work against file system items will work against end user programming items as well.

Logically there can be two schema levels in the file system layer . At the first level there can be a schema for developer code. This developer code schema can define types of items and behavioral aspects of those items. By using this level of schema developers share data abstractions with a common frame of reference. At the second level there can be a schema for end user logic. This end user logic level can be used to provide a framework for end user rules.

Type systems for both end users and the file system also can be closely aligned. Specifically in this example a type hierarchy of end user types can be a simplification of a type hierarchy of file system types. Some types in the file system hierarchy can potentially be omitted because they are irrelevant to end users. Additionally a mapping or binding can be created from every end user type to an underlying file system type. Mappings or bindings can be used to bridge a gap between the end user level and the file system level. Bindings can serve multiple purposes including the ability to localize names of end user schema elements. Specifically in this example a binding can be a rule. In a trivial exemplary case the binding can be a rule with a single statement whose condition is always true and whose result is a specific underlying property on the developer type.

Bindings can also provide a level of indirection between the developer level schema and the end user level schema. Various access control policies can be applied here depending upon a specific implementation. For example file system developers can be allowed to define which properties of types the developers create will be accessible to end users. Alternatively end users can be given the ability to decide which properties of developer created types the end user desires to access. Some combination of these two approaches is also possible.

The end user programming system includes a user interface which can be any appropriate user interface such as a graphical user interface a web based interface a text based interface or a command line interface among others. Also possible are specialized interfaces such as Braille interfaces for the blind and audio interfaces among others. The user interface is coupled to an application layer which can include such end user controlled applications such as email clients word processors spreadsheet programs and web browsers among others. Additionally or alternatively the application layer can include so called system processes that provide services to other executing computer programs such as domain name system DNS lookups and networking capabilities among others.

A rules layer is coupled to the application layer . The rules layer provides end user programming components and support to the application layer and can be implemented in a similar fashion as the rules layer of . Also an end user programming module is coupled to both the rules layer and the user interface . The end user programming module can provide access to the rules layer and the ability to create new rules much as the end user programming module of .

A file system can provide a storage framework upon which rules of the rules layer and other end user programs that can be created by the end user programming module can be accessed or otherwise used by the application layer . Any suitable file system can be used or adapted for use in this context. A file system that has an API that can be integrated with or mapped to an API for end user programming functions is especially suited for this use.

In operation an end user can interact with the end user programming system through the user interface . The end user can use the end user programming module to create rules agents or batches among other things that can be added to the rules layer . The end user can also access applications of the application layer through the user interface .

When an event or some other triggering object causes a rule to activate messages can be passed between the application layer and the rules layer . Depending upon specifics of rule activation these messages can be synchronous or asynchronous. Whichever rule or rules were activated can then execute in accordance with their design and make whatever modifications are appropriate at the file system level by using mapped or bound portions of the file system API.

The end user programming system includes an end user programming module that can provide access to end user programming support functions such as rule creation or modification and event definition. The end user programming module specifically can be implemented as any of the end user programming modules previously described in conjunction with other figures. End user programs created using the end user programming module can execute automatically as with an event driven program or can be invoked by a specific command from the end user.

A human computer interface can provide access to functions and features of the end user programming module . A variety of components can be used to implement the human computer interface depending upon specific implementation needs and desires. For example the human computer interface can be implemented as a graphical user interface such as a graphical user interface of an operating system. Alternatively the human computer interface can be based upon a web browser can be a text based interface such as a command line can be a Braille touch based interface or can be a speech based interface among others.

A rules platform can include the end user defined programs created using the end user programming module . Additionally building block components that can be used to create end user programs can be included in the rules platform . The end user programming module and the human computer interface can both access the rules platform to allow an end user to create modify delete and invoke execution of end user programs in the rules platform .

The rules platform is coupled to the file system . The file system can be implemented as any appropriate file system that can support data organization and retrieval tasks. Specifically the file system along with an API that provides access to functions of the file system can be mated with an API of the rules platform so that functions of the rules platform can be mapped or bound to functions of the file system . Integration of the rules platform with the file system in this manner effectively exposes functions of the file system to an end user so that the end user can use file system functions for various computing tasks including information organization and automated processing tasks among others. Access to functions of the file system by the end user is through the rules platform providing a layer of protection for the file system from inadvertent or malicious actions that can corrupt or otherwise damage the file system. For example a specific function such as moving a file from one physical location on a storage device to another location without changing a logical location of the file can remain unmapped or unbound to a function of the end user programming module or the rules platform preventing the end user from accessing that function.

The file system can impose a logical file organization scheme on one or more persistent storage devices PS . The persistent storage devices can be hard disk drives optical drives flash memory devices or other appropriate storage devices and can operate independently as separate disks that each use a file system. Additionally or alternatively the persistent storage devices can be logical partitions on one or more physical disk drives. In this configuration an end user can be aware of the fact that there are multiple disks or partitions providing storage space. The persistent storage devices can also be integrated as part of a single logical storage volume as with a redundant array of independent disks RAID . When configured as a RAID array the persistent storage devices can be accessed as a single entity using a single file system. Also the persistent storage devices can be part of a storage area network SAN or some other storage system.

In operation the end user programming system can function as follows. An end user can access the end user programming module through the human computer interface to create an end user program. The end user program resides on the rules platform until execution is invoked by a command from the end user or upon occurrence of a specific or predefined event. The rules platform sends a message to the file system that requests that the file system perform some information manipulation task on the persistent storage devices . Upon successful completion or failure of the requested task and in a synchronous messaging environment the file system sends a message to the rules platform to inform the end user program of the result of the requested task. Alternatively as with an asynchronous messaging system the file system can perform or attempt to perform the requested task without sending a reply message to the rules platform . Information about the requested action is displayed on the human computer interface for viewing by the end user.

A rules platform can include the end user defined programs created using the end user programming module . Additionally building block components that can be used to create end user programs can be included in the rules platform . The end user programming module and a user interface can both access the rules platform to allow an end user to create modify delete and invoke execution of end user programs in the rules platform . The rules platform can also provide networking or other communication functions such as message passing between end user programs or other components of the rules platform and a file system . To do so the rules platform can use a network . The network can be any appropriate wired or wireless network can be a local area network LAN a wide area network WAN an intranet or the Internet among others. Consistent with this implementation the rules platform can include networking components such as communications stacks like a transfer control protocol Internet protocol TCP IP stack among others. Alternatively the rules platform can merely have access to such functions provided by another component such as an operating system or a networking application.

The file system can impose an organizational hierarchy upon a remote storage device . The remote storage device can be a persistent storage device such as a disk drive or any other type of persistent storage device specifically including types disclosed and described in conjunction with other figures. Additionally or alternatively the remote storage device can be a database or another type of data store that can provide access and manipulation features in a manner similar to that of a file system.

In operation the networked end user programming system can function as follows. An end user can access the end user programming module through the user interface to create one or more end user programs. These end user programs reside on the rules platform until execution is invoked by a command from the end user or upon occurrence of a specific or predefined event. The rules platform uses the network to pass a message to the file system requesting the file system to perform some information related task in connection with the remote storage device . Upon successful completion or failure of the requested task the file system uses the network to pass a message to the rules platform to inform the end user program of the result of the requested task. Information about the result is displayed on the user interface for viewing by the end user.

With reference to flowcharts in accordance with various methods or procedures are presented. While for purposes of simplicity of explanation the one or more methodologies shown herein for example in the form of a flow chart are shown and described as a series of acts it is to be understood and appreciated that neither the illustrated and described methods and procedures nor any components with which such methods or procedures can be used are necessarily limited by the order of acts as some acts may occur in a different order and or concurrently with other acts from that shown and described herein. For example those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events such as in a state diagram. Moreover not all illustrated acts may be required to implement a methodology or procedure.

A determination is made whether all processes successfully completed at decision block . If yes a general success indicator is created at . If no a general error message is created at process block . Processing concludes from both process block and process block at END block . Similarly if the determination made at decision block is no processing concludes at END block .

Properties and relationships can be assigned values in at least two different ways. Actual values can be materialized and maintained with the item data. Additionally or alternatively values can be computed from other data upon demand. In this case a definition of the computation to be performed to obtain the data can be stored as metadata. Computed mechanisms for data organization are appropriate when rules for data organization are well defined easily expressible and based entirely on available information. Computed mechanisms also scale well to deal with large volumes of data. Materialized mechanisms are appropriate when data organization logic cannot easily be expressed or is based upon information that cannot be easily captured such as content or context information. End user programs can define computed properties and relationships. Such programs can also be used to automatically maintain materialized properties and relationships.

A store phase can indicate that a user is saving an item of information in a persistent format that can be accessed later. Persistent formats that can be used include files and objects among others. Details of such persistent formats can vary according to particular details of a file system within which the persistent format is stored. For example both a hard disk drive and an optical disk can be used as persistent storage devices. However file system formats for the hard disk drive vary greatly from file system formats such as ISO 9660 that can be used on optical disks.

A find phase can indicate a period when an end user desires to retrieve information stored in some persistent format. The term find can include any activity that can cause an item to be identified as available for the end user to act upon. There are at least three ways in which an end user can find data. In the first the end user can browse or navigate to the data. In this manner the end user begins at some starting point such as a home or reference directory. Relationships between or among data items can provide pathways to browse or traverse items in a data store. One specific example is navigating through a hierarchical directory tree.

In the second approach the end user can execute a query. A query defined by an end user can describe a subset of items in a data store that can match some declarative description. Using the third approach an event can be used by the end user to find an item. An event of this type can be used to draw attention to some specific item. For example addition of a file to a directory can be an event that draws attention to the added file.

Each of these approaches has strengths and weaknesses. Query based mechanisms can be used when logic used to find items is well defined and easily expressed in terms of concepts modeled in the data store. Execution of queries can be scalable and efficient however query execution can also be computationally intensive even when a relatively efficient query mechanism is used. Navigational mechanisms can be used to provide flexibility but require more user involvement than queries. Additionally navigational mechanisms do not necessarily scale as well as query mechanisms to deal with large sets of data.

Event driven mechanisms are suited for instances when a goal is to find appropriate data at an appropriate point in time without direct user involvement. There are at least two basic kinds of events. First an application event can be caused by execution of a specific application or set of applications. Second a data change event can be caused by any activity that changes data independent of the application that caused the change in data. A data change event can be raised by a data management system. Particular types of events can be raised either synchronously or asynchronously. For synchronous events an application or system expects a response to the event before continuing. For asynchronous events no such response is needed before the raising application can continue processing its tasks.

A use phase can indicate that the end user has found and retrieved the data and is ready to use it or otherwise act upon the data. Basic actions on items can be provided by applications that expose the items to an end user. Some actions can be intrinsic to an item type. For example an action can be used to set a property of an item. Other actions can be intrinsic to the application that can use the item. An example here is an action to display text of a message item in a specific color.

Computed actions can be constructed from other actions using at least one of the following mechanisms. First actions on relationships can be used. In this scheme an action on an item can be defined to include actions on targets or the relationships of the items. For example when a relationship is used to define a set of items such as a folder group computed actions can specify uniform actions on all members of the set. This process can be referred to as a batch. Conditional actions can also be used. Existing actions can be combined with conditional logic to define a conditional computed action. For example if a document is marked as confidential a priority flag can be set to indicate high priority. If the document is not marked as confidential a priority flag can be set to indicate that the document has a normal priority. Further an action sequence can be created such that multiple actions are placed on a list that must be executed sequentially. For example an action sequence can be used to print a document and then delete the document. Actions such as these can have side effects that may create situations where order of actions must be deterministic in order for the defined behavior to be sensible.

In order to provide additional context for implementing various aspects of the subject invention and the following discussion is intended to provide a brief general description of a suitable computing environment within which various aspects of the subject invention may be implemented. While the invention has been described above in the general context of computer executable instructions of a computer program that runs on a local computer and or remote computer those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally program modules include routines programs components data structures etc. that perform particular tasks and or implement particular abstract data types.

Those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations including single processor or multi processor computer systems minicomputers mainframe computers as well as personal computers hand held computing devices microprocessor based and or programmable consumer electronics and the like each of which may operatively communicate with one or more associated devices. The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. However some if not all aspects of the invention may be practiced on stand alone computers. In a distributed computing environment program modules may be located in local and or remote memory storage devices.

Furthermore the disclosed and described components or processes may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed and described components or processes. The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. For example computer readable media can include but are not limited to magnetic storage devices for example hard disk floppy disk and magnetic strips among others optical disks such as compact disks CDs and digital versatile disks DVDs among others smart cards and flash memory devices like card stick and key drives among others. Additionally it should be appreciated that a carrier wave can be employed to carry computer readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network LAN . Of course those skilled in the art will recognize many minor modifications may be made to this configuration.

It should also be appreciated that although specific examples presented may describe or depict systems or method that are based upon searches of contents of file systems on a personal computer application is not limited to that domain. For example the disclosed and described components and methods may also be employed on an intranet a private network or the Internet. Additionally or alternatively the disclosed and described components and methods can be used as part of a storage area network SAN . Those of ordinary skill in the art will readily recognize that the disclosed and described components and methods can be used to search for and manipulate other types of information including web pages database queries photograph information and audio or video information among others.

End user programming EUP can be described as an ability of an end user to control each and every aspect of behavior of an information centric software application. EUP principles and components can be used to tailor and personalize automated information processing tasks performed by a software application or multiple applications under control of an end user. At least three interrelated ways exist for EUP principles and components to assist users.

In the first way a potentially large number of processing steps that an end user normally would have to perform manually can be automated according to specific needs or desires of an end user. For example an end user working with a large collection of digital images stored at a very high resolution can desire to create low resolution versions of these images for use in a web page. To do so manually the end user typically would have to open each individual image in an editing program create a low resolution copy according to various program settings and save the low resolution version with a new file name or in a new location. An EUP module can be created to perform these tasks automatically upon addition of a new image to a specified directory.

In the second way of employing EUP principles an EUP module can perform a significant amount of computation for the end user. For example many search tasks are very computationally intensive and an EUP module can automatically perform searches and other computationally expensive tasks and report results of the searches to the end user. Additionally or alternatively an EUP module can perform such tasks when specifically invoked or executed by an end user. In the third way an EUP module can function automatically without intervention from the end user thereby allowing an end user to focus attention on other tasks instead of on a specific computing task. This automatic functioning can increase productivity of an end user by freeing the end user from manually performed time intensive tasks such as sorting electronic files and grouping such files into logical collections.

The EUP concepts and components presented herein provide a generalized and flexible platform upon which a wide variety of implementations can be created. Some possible implementations can provide a robust platform that can be used to support end user programming tasks across an entire platform such that every user application can access and benefit from end user programming functions. Other possible implementations can support such functionality for only a single application and other implementations will fall somewhere between these two extremes. Those of ordinary skill in the art will readily recognize from reading this disclosure that many alterations and variations are possible.

End user programs can define all forms of computed actions presented in the examples herein as well as other instances. One notable form includes association of an action with an event and can be referred to as an agent. An agent that involves synchronous events can include two special cases of interest. In the first case such an agent can provide application customization by performing actions that can be intrinsic to the application. For example a mail application can raise a synchronous event prior to sending a mail message. A resulting agent action can be to append a signature file to the message. When the action of the agent is a conditional action the agent can choose the signature file based upon properties of the message. In the second case constraints on data are involved. A data constraint agent can act to accept or deny a change to data that caused an event to be raised. For example a change in ownership of a file can cause an event to be raised. The raised event can trigger an action of an agent that evaluates the ownership change. Based upon criteria such as identities of the present owner of the file the new owner of the file and the user effecting the change the data constraint agent can accept or deny the change in ownership information.

More complex evaluations are possible with use of more sophisticated components. Such components can include various artificial intelligence components that can identify or match patterns or perform various classification tasks. Appropriate artificial intelligence components that can be used include neural networks and support vector machines among others. The disclosed and described components e.g. an agent created to perform filtering or management tasks can employ these various artificial intelligence based schemes to carry out programmed tasks. For instance identification of a complex data pattern and a classification of a new datum as belonging to a data set that has the complex data pattern can be carried out by a neural network a rules based processing component or an SVM.

A classifier is a function that maps an input attribute vector X x x x x . . . x to a confidence that the input belongs to a class that is f X confidence class . Such a classification can employ a probabilistic and or statistical based analysis for example factoring into the analysis utilities and costs to prognose or infer an action that a user desires to be automatically performed. In the case of an end user programming system data items can be classified by examining attributes of those data items. A support vector machine SVM is an example of a classifier that can be employed. The SVM operates by finding a hypersurface in the space of possible inputs which hypersurface attempts to split the triggering criteria from the non triggering events. Intuitively this makes the classification correct for testing data that is near but not identical to training data. Other directed and undirected model classification approaches include for example na ve Bayes Bayesian networks decision trees and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also includes statistical regression that is utilized to develop models of priority.

As will be readily appreciated from the subject specification components disclosed or described herein can employ classifiers that are explicitly trained for example by a generic training data as well as implicitly trained for example by observing user behavior receiving extrinsic information . . . . For example SVMs are configured by a learning or training phase within a classifier constructor and feature selection module. Thus the classifier s can be used to automatically perform a number of functions including but not limited to determining whether a device should be sent data.

One possible means of communication between a client and a server can be in the form of a data packet adapted to be transmitted between two or more computer processes. The system includes a communication framework that can be employed to facilitate communications between the client s and the server s . The client s are operably connected to one or more client data store s that can be employed to store information local to the client s . Similarly the server s are operably connected to one or more server data store s that can be employed to store information local to the servers .

With reference to an exemplary environment for implementing various aspects of the invention includes a computer . The computer includes a processing unit a system memory and a system bus . The system bus couples system components including but not limited to the system memory to the processing unit . The processing unit can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .

The system bus can be any of several types of bus structure s including the memory bus or memory controller a peripheral bus or external bus and or a local bus using any variety of available bus architectures including but not limited to Industrial Standard Architecture ISA Micro Channel Architecture MSA Extended ISA EISA Intelligent Drive Electronics IDE VESA Local Bus VLB Peripheral Component Interconnect PCI Card Bus Universal Serial Bus USB Advanced Graphics Port AGP Personal Computer Memory Card International Association bus PCMCIA Firewire IEEE 1394 and Small Computer Systems Interface SCSI .

The system memory includes volatile memory and nonvolatile memory . The basic input output system BIOS containing the basic routines to transfer information between elements within the computer such as during start up is stored in nonvolatile memory . By way of illustration and not limitation nonvolatile memory can include read only memory ROM programmable ROM PROM electrically programmable ROM EPROM electrically erasable ROM EEPROM or flash memory. Volatile memory includes random access memory RAM which acts as external cache memory. By way of illustration and not limitation RAM is available in many forms such as synchronous RAM SRAM dynamic RAM DRAM synchronous DRAM SDRAM double data rate SDRAM DDR SDRAM enhanced SDRAM ESDRAM Synchlink DRAM SLDRAM and direct Rambus RAM DRRAM .

Computer also includes removable non removable volatile non volatile computer storage media. For example illustrates a disk storage . The disk storage includes but is not limited to devices like a magnetic disk drive floppy disk drive tape drive Jaz drive Zip drive LS 100 drive flash memory card or memory stick. In addition disk storage can include storage media separately or in combination with other storage media including but not limited to an optical disk drive such as a compact disk ROM device CD ROM CD recordable drive CD R Drive CD rewritable drive CD RW Drive or a digital versatile disk ROM drive DVD ROM . To facilitate connection of the disk storage devices to the system bus a removable or non removable interface is typically used such as interface .

It is to be appreciated that describes software that acts as an intermediary between users and the basic computer resources described in the suitable operating environment . Such software includes an operating system . The operating system which can be stored on the disk storage acts to control and allocate resources of the computer system . System applications take advantage of the management of resources by operating system through program modules and program data stored either in system memory or on disk storage . It is to be appreciated that the subject invention can be implemented with various operating systems or combinations of operating systems.

A user enters commands or information into the computer through input device s . The input devices include but are not limited to a pointing device such as a mouse trackball stylus touch pad keyboard microphone joystick game pad satellite dish scanner TV tuner card digital camera digital video camera web camera and the like. These and other input devices connect to the processing unit through the system bus via interface port s . Interface port s include for example a serial port a parallel port a game port and a universal serial bus USB . Output device s use some of the same type of ports as input device s . Thus for example a USB port may be used to provide input to computer and to output information from computer to an output device . Output adapter is provided to illustrate that there are some output devices like monitors speakers and printers among other output devices which require special adapters. The output adapters include by way of illustration and not limitation video and sound cards that provide a means of connection between the output device and the system bus . It should be noted that other devices and or systems of devices provide both input and output capabilities such as remote computer s .

Computer can operate in a networked environment using logical connections to one or more remote computers such as remote computer s . The remote computer s can be a personal computer a server a router a network PC a workstation a microprocessor based appliance a peer device or other common network node and the like and typically includes many or all of the elements described relative to computer . For purposes of brevity only a memory storage device is illustrated with remote computer s . Remote computer s is logically connected to computer through a network interface and then physically connected via communication connection . Network interface encompasses wire and or wireless communication networks such as local area networks LAN and wide area networks WAN . LAN technologies include Fiber Distributed Data Interface FDDI Copper Distributed Data Interface CDDI Ethernet Token Ring and the like. WAN technologies include but are not limited to point to point links circuit switching networks like Integrated Services Digital Networks ISDN and variations thereon packet switching networks and Digital Subscriber Lines DSL .

Communication connection s refers to the hardware software employed to connect the network interface to the bus . While communication connection is shown for illustrative clarity inside computer it can also be external to computer . The hardware software necessary for connection to the network interface includes for exemplary purposes only internal and external technologies such as modems including regular telephone grade modems cable modems and DSL modems ISDN adapters and Ethernet cards.

What has been described above includes illustrative examples of certain components and methods. It is of course not possible to describe every conceivable combination of components or methodologies but one of ordinary skill in the art will recognize that many further combinations and permutations are possible. Accordingly all such alterations modifications and variations are intended to fall within the spirit and scope of the appended claims.

In particular and in regard to the various functions performed by the above described components devices circuits systems and the like the terms including a reference to a means used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component for example a functional equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated examples. In this regard it will also be recognized that the disclosed and described components and methods can include a system as well as a computer readable medium having computer executable instructions for performing the acts and or events of the various disclosed and described methods.

In addition while a particular feature may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes and including and variants thereof are used in either the detailed description or the claims these terms are intended to be inclusive in a manner similar to the term comprising. 

