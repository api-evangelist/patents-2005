---

title: Method, apparatus and program storage device for providing light weight system calls to improve user mode performance
abstract: A method, apparatus and program storage device for providing light weight system calls to improve user mode performance is disclosed. A range of system call code for the light weight system calls is provided in a system call table. The light weight system calls skip the code for saving and restore processor context.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08010963&OS=08010963&RS=08010963
owner: International Business Machines Corporation
number: 08010963
owner_city: Armonk
owner_country: US
publication_date: 20051201
---
This invention relates in general to a computer operating systems and more particularly to a method apparatus and program storage device for providing light weight system calls to improve user mode performance.

A thread is a sequence of instructions. Multiple threads can be executed in parallel on many computer systems. Multithreading generally occurs by time slicing where a single processor switches between different threads or by multiprocessing where threads are executed on separate processors. Threads are similar to processes but differ in the way that they share resources. Many modern operating systems directly support both time sliced and multiprocessor threading with a process scheduler. The operating system kernel allows programmers to manipulate threads via the system call interface. Some implementations are called kernel threads or lightweight processes.

Operating systems generally implement threads in one of two ways preemptive multithreading or cooperative multithreading. Preemptive multithreading allows the operating system to determine when a context switch should occur. The term context simply refers to all the information that completely describes the process s current state of execution e.g. the contents of the CPU registers the program counter the flags etc. The process of saving the currently executing process s context flushing the CPU and loading the next process s context is called a context switch. A context switch for a full fledged multithreaded process will obviously take a lot longer than a context switch for an individual thread within a process. So depending on the amount of hardware support for context switching and the type of context switch a context switch can take a decent amount of time thereby wasting a number of CPU cycles. Cutting back on context switches improves execution efficiency and reduces waste as does the extensive use of multithreading since thread switches are usually faster than full sized process switches.

Cooperative multithreading on the other hand relies on the threads themselves to relinquish control once they are at a stopping point. This can create problems if a thread is waiting for a resource to become available. The disadvantage to preemptive multithreading is that the system may make a context switch at an inappropriate time causing priority inversion or other bad effects which may be avoided by cooperative multithreading.

In multithreaded operating systems all threads in a task share the same address space and are usually sharing large amounts of data. Context switching between two threads in the same task may take much less time than context switching between two threads in different tasks. After a context switch in a multithreaded system a new thread will be running and perhaps a new task.

The kernel mode is a privileged mode in which only the kernel runs and which provides access to all memory locations and all other system resources. Context switches can occur only in kernel mode. Other programs including applications initially operate in user mode but they can run portions of the kernel code via system calls. A system call is a request by an active process for a service performed by the kernel such as input output I O or process creation.

Many current computer systems employ two privilege levels a most privileged level or kernel privilege level and a less privileged level or application program privilege level. The privilege level at which a process executes determines the total range or ranges of virtual memory that the process can access and the range of instructions within the total instruction set that can be executed by the processor on behalf of the process.

The privilege concept is used to prevent full access to computing resources by application programs. In order to obtain services that employ resources not directly available to application programs application programs need to call operating system routines through the operating system interface. Operating system routines can promote the current privilege level to a higher privilege level to allow access to resources to carry out a task requested by an application program and then return control to the application program while simultaneously demoting the current privilege level. By restricting application program access to computer resources an operating system can maintain operating system only accessible data structures for managing many different concurrently executing programs in the case of a single processor computer and on a multi processor computing system many different concurrently executing application programs a number of which execute in parallel. Privilege levels also prevent the processor from executing certain privileged instructions on behalf of application programs. For example instructions that alter the contents of the process status register may be privileged and may be executed by the processor only on behalf of an operating system routine running at a high privilege level. Generally restricted instructions include instructions that manipulate the contents of control registers and special operating system specific data structures.

As an example of the use of privilege levels consider concurrent execution of multiple processes representing multiple application programs managed by the operating system in a single processor computer system. The processor can execute instructions on behalf of only a single process at a time. The operating system may continuously schedule concurrently executing processes for brief periods of execution in order to provide over time a fraction of the total processing bandwidth of the computer system to each running application program. The operating system schedules a process for execution by removing the process control block corresponding to the process from the process queue and writing the contents of various memory locations within the process control block into various control registers and operating system data structures. Similarly the operating system removes a process from the executing state by storing the contents of control registers and operating system data structures into the corresponding process control block and re queuing the process control block to the process queue.

As described above operating system routines are invoked through system calls faults traps and interrupts during the course of execution of an application program. By maintaining the process queue in memory accessible only to routines executing at the highest privilege level and by ensuring that some or all instructions required to store and retrieve data from control registers are instructions that have access to the highest privilege level the architecture of the computing system ensures that only operating system routines can schedule application processes for execution. Thus an application program may not manipulate the process queue and control registers in order to monopolize system resources and prevent other application programs from obtaining computing resources for concurrent execution.

The operating system as part of providing an application programming environment provides both application specific and application sharable memory to application programs. An application program may store private data that the application wishes to be inaccessible to other application programs in private memory regions and may exchange data with other application programs by storing date in sharable memory. Access to memory is controlled by the operating system through address mapping and access privileges associated with memory pages each memory page generally comprising some fixed number of bytes. Because the instructions and operating system data structures necessary for memory mapping and access privilege assignment include instructions and memory accessible only to routines executing at the highest privilege level an application program executing at a lower privilege level may not remap memory or reassign access privileges in order to gain access to the private memory of other application programs.

Issuing system calls typically involves running a sequence of instructions to save the current context expecting for a process context switch. With the popularity of the Linux operating system many controller applications have moved from kernel space in non open source operating systems to user mode programs under Linux. With this move calling privileged instructions become much more expensive than before because of the probability of a context switch needing to be made. Usually an application program does not expect a context switch when calling privileged instructions. Nevertheless system calls that perform the privileged instructions require that the processor context be saved and restored during a system call.

It can be seen then that there is a need for a method apparatus and program storage device for providing light weight system calls to improve user mode performance.

To overcome the limitations in the prior art described above and to overcome other limitations that will become apparent upon reading and understanding the present specification the present invention discloses a method apparatus and program storage device for providing light weight system calls to improve user mode performance.

The present invention solves the above described problems by providing a range of system call code for the light weight system calls in a system call table. The light weight system calls skip the code for saving and restore processor context.

A system call table in accordance with an embodiment of the present invention includes an entry point for identifying at least one light weight system call code block located within a range of addresses allocated in memory for light weight system call code blocks wherein the light weight system call performs privileged instructions without saving and restoring processor context.

In another embodiment of the present invention a memory for providing a library of system calls is provided. The memory includes a plurality of addresses wherein a range of the plurality of addresses is allocated for at least one light weight system call code block.

In another embodiment of the present invention a program storage device that includes program instructions executable by a processing device to perform operations for providing light weight system calls to improve user mode performance is provided. The operations include allocating a range of addresses in memory for light weight system call code blocks to perform privileged instructions and adding within the range of addresses at least one light weight system call code block for performing a privileged instruction.

These and various other advantages and features of novelty which characterize the invention are pointed out with particularity in the claims annexed hereto and form a part hereof. However for a better understanding of the invention its advantages and the objects obtained by its use reference should be made to the drawings which form a further part hereof and to accompanying descriptive matter in which there are illustrated and described specific examples of an apparatus in accordance with the invention.

In the following description of the embodiments reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration the specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized because structural changes may be made without departing from the scope of the present invention.

The present invention provides a method apparatus and program storage device for providing light weight system calls to improve user mode performance. A range of system call code for the light weight system calls is provided in a system call table. The light weight system calls skip the code for saving and restore processor context.

The computer system and the allocation of system resources to the computer system are controlled by operating system . For the purpose of the present discussion it is assumed that operating system is resident within primary memory although those skilled in the art will appreciate that certain infrequently utilized segments of operating system may be swapped out to secondary memory by memory manager . Operating system includes kernel which comprises the lowest layer of operating system that interacts most directly with the computer system . Kernel dispatches kernel threads to processors for execution provides services to device drivers interfacing with hardware within computer system and implements system services memory management network access and the file system utilized by computer system . In addition to kernel primary memory also stores frequently utilized segments of application software . As is well known to those skilled in the art application software communicates with operating system through an Application Programming Interface API .

Computer system also includes bus interface through which multiple nodes can interface to system resources available within computer system . As will be appreciated by those skilled in the art computer system may also include additional hardware coupled to system bus that is not necessary for an understanding of the present invention and is accordingly omitted for simplicity.

Processes that run in kernel mode can directly access system data and hardware and are not restricted like processing running in user mode . Performance sensitive drivers and services run in kernel mode to interact with hardware more efficiently. All components for processes running in kernel mode are fully protected from applications running in user mode . Processes that run in user mode are effectively isolated from processes running in kernel mode and other processes running in user mode .

In a thread for a process running in user mode is characterized as having its own context including registers and memory stack . A user stack is a data structure that includes a series of memory locations and a pointer to the initial location. All processors provide instructions for placing and retrieving values to and from the stack . The user memory is a block of memory that is dedicated to the use of a current process running in user mode . A complete user state of a thread is maintained in user registers .

The kernel operates in its own protected address space and includes its own registers and kernel stack . The kernel maintains the integrity of its own data structures and that of other processes. The kernel stack includes information used by the kernel. Kernel memory is generally shared by all processes but is only accessible in kernel mode . Context switches from one task to another happen on the kernel stack of the current process.

The system call requests a service to be performed by the kernel running in the kernel mode i.e. the core of the operating system such as input output I O or process creation i.e. creation of a new process . The kernel is the operating system software running in protected mode and having access to the hardware s privileged registers. The kernel is not a separate process running on the system. It is the core of the operating system which controls the scheduling of processes to achieve multitasking and provides a set of routines constantly in memory to which every program in the user space has access to. Some operating systems employ a microkernel architecture wherein device drivers and other code are loaded and executed on demand and are not necessarily always in memory.

The system call generates a trap and passes arguments and an index into a system call table for the service requested. The system call table is used to maintain a list of all registered system calls and includes a list of system call number that are assigned to each system call. The kernel processes the request by looking up the index passed to see the service that is to be performed and carries out the request. Upon completion of the system call the kernel returns a value that represents either successful completion of the request or an error. If an error occurs the kernel sets a flag or indicator for indicating the reason for the error. The return value is then delivered to the process that made the system call and the program continues its execution.

When a system call is issued a sequence of instructions is typically run to save the current context of the processor. This method by which the operating system makes one CPU suspend the execution of on process and continue or begin executing a second process is referred to as a context switch. During a context switch the CPU switches to using the full context of the second process i.e. its execution stack its memory area the values the registers contained when last executing this process. A context switch is invoked when the current process is preempted by a system call. However application programs do not expect context switch when calling those privileged instructions. Thus a light weight system call is provided to perform the privileged instructions without saving and restoring processor context during system call.

In order to invoke system calls that perform privileged instructions without requiring that the processor context be saved and restored entry points for lightweight system calls are also provided in the system call table . System call numbers for the entry points are designed for the light weight system calls. The light weight system calls will skip the code for saving and restore processor context. Thus the light weight system calls return without going through context switch.

For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device. The medium may be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD.

A system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly to the system or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the system to become coupled to other data processing systems remote printers or storage devices through intervening private or public networks . Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

Accordingly the computer program comprise instructions which when read and executed by the system of causes the system to perform the steps necessary to execute the steps or elements of the present invention

The foregoing description of the embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not with this detailed description but rather by the claims appended hereto.

