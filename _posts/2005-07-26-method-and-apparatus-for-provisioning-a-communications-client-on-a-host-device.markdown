---

title: Method and apparatus for provisioning a communications client on a host device
abstract: An apparatus for provisioning a data communications client on a host communications device, the host communications device adapted to operate on a communications network, the apparatus comprising: a first data store adapted to store variant configuration information; a second data store adapted to store provisioning information; a provisioning module adapted to select the provisioning information stored in said second data store as a function of the variant configuration information stored in said first data store and apply the selected provisioning information to provision the data communications client; and a user interface interacting with said provisioning module to enable a user of the host communications device to provision the data communications client.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07620705&OS=07620705&RS=07620705
owner: Research In Motion Limited
number: 07620705
owner_city: Waterloo
owner_country: CA
publication_date: 20050726
---
The present application deals with a method and apparatus for provisioning a communications client on a host device and in particular to a method and apparatus in which a user can provision various service types for a device without requiring a software download.

In a host wireless device it is sometimes desirable to add a client onto the host to perform functionality that the host normally would not include. The host is typically certified with its software and hardware to communicate over a wireless network whereas a client typically would not be. Further certification could occur prior to the client being added especially in the case that the client is integrated after market onto the wireless device.

It is further desirable that the client is able to communicate with the native applications on the host and that the host applications are able to communicate with client applications. This communication preferably includes controlling a user interface on the host device from a client application including registering inputs to the host device for the client application and displaying or outputting from the client application.

In some cases it is also desirable to be able to use device settings from the host environment in a client setting. Examples of this could include locale information time zones display themes or backgrounds. The automatic propagation of a change in host device setting would be preferable in some situations.

In one embodiment it is also desirable to have symbol inputs to a client correspond with symbol inputs to a host. It is further desirable that the input of symbols be simplified.

It is further desirable to be able to change the provisioning of a client directly from a host device without having to load new software onto the host device. In particular it is desirable to be able to select a service type from a list of service types to suit a user without having to change the device the user has or without having to perform software changes on the user s device

The present apparatus and method provide a divided architecture for integrating a client into a host wireless device. One key to the present system is that the host is recognized as the dominant determinant in a divided architecture due to the fact that device type certification efforts Global Certification Forum CGF PCS Type Certification Review Board PTCRB may happen prior to the client being integrated onto the host. This necessitates that the host and tightly tied applications to the host remain unfettered.

The present apparatus and method provide a virtual machine that is started upon start up of the host device and is used to run client applications. The virtual machine communicates through a client OS that would normally send client application commands and functions to host dependent features such as hardware software firmware or communications networks. However since the host dependent features are certified and controlled by the host device the operating system instead communicates with abstraction layers. The abstraction layers have a native interface for communicating with host applications allowing client applications to use the host dependent features by utilizing host applications.

Device setting such as locale time zone display themes and backgrounds can be set using a binary variable. In one mode the client settings are adapted to automatically adjust when host device settings are changed. This change is propagated by either having a listener at the host to signal a change in device settings or polling when a graphical interface of a client is brought to the foreground. In the other mode the client settings can be fixed at the client and changes at the host device are ignored.

A client application accesses the user interface of a host device using a host native application a platform abstraction layer and a host independent engine communicating between the user interface and a client application. The host independent engine is platform independent and relies on the platform abstraction layer to translate and or map function calls. The host native application depends on the user interface and host device and is used to control actions and updates to the user interface.

One example of an input for the host native application is the input of symbols. In a system for inputting symbols to a client where the host has a native system for inputting symbols from a host symbol table by navigating a host cursor to move between adjacent symbols displayed within a host grid and the host further has a keyboard the keyboard can be taken advantage of to map symbols to one keystroke. A client symbol table is created conforming to the host symbol table and a grid is made where the indicia of at least one keyboard key is associated with a symbol such that when a user actuates a key in the keyboard the cursor jumps to the corresponding symbol.

Provisioning of the device can be accomplished from software that is already loaded onto the device. By following steps from a client application on a host device provisioning of the client can be changed. A host device user is thereby enabled to upgrade or downgrade client service i.e. to provision the data client.

The present application therefore provides an apparatus for provisioning a data communications client on a host communications device the host communications device adapted to operate on a communications network the apparatus comprising a first data store adapted to store variant configuration information a second data store adapted to store provisioning information a provisioning module adapted to select the provisioning information stored in said second data store as a function of the variant configuration information stored in said first data store and apply the selected provisioning information to provision the data communications client and a user interface interacting with said provisioning module to enable a user of the host communications device to provision the data communications client.

The present system and method is directed to a divided architecture for a client on a host device. One example of such an arrangement would be a data enabled cellular telephone with a data device client running on top of the host telephone environment. Other examples of clients running on host environments would however be known to those skilled the art and the above is not meant to limit the scope of the present method and system. The examples below will use a host that is a cellular telephone and a client that is a data device client merely for illustration purposes.

A host device will require certification prior to being released for sale and use in a given market. Examples of certification include GSF and PCS type certification review board PCTRB certifications. These certifications are for the hardware and tightly tied applications to this hardware.

In order to include a client that has communications capabilities without having to certify the client the integration of the client requires a divided architecture in which the phone and the tightly tied applications to the phone remain unaltered.

One example of an architecture to accomplish this is illustrated in . shows a method and system for a divided architecture which includes client applications running on top of a virtual machine .

Client applications can be any application that is designed to run on a virtual machine . In the example of these could include a messages application for viewing messages that have been received a contacts application which presents an address book including phone numbers e mail addresses or other contact information for individuals or companies calendar application for scheduling appointments and managing time a browser application for browsing the internet or other network a compose message application to compose messages for SMS or e mail a save messages application to view messages that have been saved a search messages application to search for a particular message a lock application to lock the keyboard and screen of the mobile device and a set up application to change the set up configuration for client . Other applications could also exist as part of client applications and the above listed applications are not meant to be limiting. Further other clients besides client could exist on the host device and these other clients could have applications which could be invoked from application .

Virtual machine is preferably started at power up of the host device and stays running no matter what. In one preferred embodiment the virtual machine is a JAVA virtual machine and client applications are JAVA applications.

All client applications use virtual machine to invoke instances of objects created by client applications .

A feature call such as a hardware call on system from client applications would normally go through client OS . Client OS includes a number of primitives for interacting with hardware. However in the case that client applications are built onto a host device and because the host device has acquired certification for its host dependent features such as hardware software and firmware it is preferable that instead of interacting with the features directly client OS interacts with a host abstraction layer . Host abstraction layer converts calls from client applications to host calls through a native interface . Native interface invokes host applications in order to use the host dependent features on the host device.

Because host applications invoke the features of the host device rather than client applications directly utilizing the features the above architecture provides that client applications can run on a host environment and use the features of the host device without having to re certify. This enables the client to be added to the host device after certification including an after market addition to the host device.

One example of a client application using the above includes the making of a telephone call when the host device is a cellular telephone. When in the host environment this simply involves using host applications to create the telephone call where these host applications use certified hardware firmware and software to connect through the wireless system. However when in a client application the above architecture requires the invoking of a host application in order to make the phone call. A client application could be an address book or contact application that includes phone numbers for individuals. A user may wish to select a phone number from the address book and have the wireless device phone that person. In order to accomplish this a user may select the phone number and select an option to phone that phone number. In this case contact application indicates through virtual machine to OS that it needs to make a phone call. Instead of using the host dependent feature directly from OS a notification is sent to host abstraction layer which through native interface invokes the correct host application to make the phone call. In the example of this would be phone application . Phone application then starts the phone call and the user proceeds as if the phone call was started from client application .

Similarly client application could give a user the option instead of phoning the phone number to use a short message service or a multi media message service to contact the individual. In each of these cases a different host application is invoked but this is done similarly through the host abstraction layer and native interface . In the example of these host applications include SMS application or MMS application .

An alternative example of a client application could be an e mail message that includes a phone number within it for example in messages application . Messages application could give a user the option to contact the phone number with the message. A phone related application short message service SMS application or multi media message service MMS application is started within host applications . This is done through the client OS to the host abstraction layer where the request is converted with a native interface for a host application .

As one skilled in the art will realize data is supplied between the applications and host applications . In the example above the phone number would be supplied to host application including phone application SMS application and MMS application .

It is further desirable that a client application can be activated from a host application . Reference is now made to . shows a screen capture of a host application. The host application lists a series of client applications that can be activated. As used herein activated can mean to both start a client application or to bring an already started client application to the foreground. In order to activate a client application the user scrolls to the client application that s he desires and selects the client application. Reference is made again to . When an application is selected in the host environment a client application selection application uses a set of application programming interfaces APIs by which the host operating system can request a client application to activate.

Client application selection application uses a client abstraction layer to activate an application within client applications . Client application selection application calls a function that is translated in client abstraction layer . Client abstraction layer then uses virtual machine to activate a client application .

Client abstraction layer in alternative embodiments can either inject the client OS event into virtual machine which causes the selected client application to become active or alternatively performs a reverse native call either through client OS or via client connect to manipulate the native representation of some client object which causes the selected client application to become active.

Client connect can be used for network features for client applications. This enables for example client to communicate using a specific protocol that was not originally supported on the host device. Client connect involves a protocol stack to perform this messaging and thereby increase and improve client functionality.

An example of the above is a client calendar application as illustrated in the screen capture or a client e mail application as illustrated in the screen capture . Requests for a client application to be activated are converted into function calls through native interface which in turn makes calls on client applications . These applications are then brought into the display foreground.

Alternatively client application selection application may communicate directly with virtual machine in order to activate a client application . This may occur for example in the case where client application selection application knows the code or a hook to start client application .

Once virtual machine receives a message to activate an application either from the client application selection application directly or through client abstraction layer a client application is activated and needs to assume control of the host user interface. In order to do this client application makes a call back to client application selection application indicating that client application needs the user interface. Client application selection application then uses host code to take over the UI and thus becomes a portal between client application and the host. Client application selection application adapts all of the host inputs to events for the client and takes over control of the user interface. Client application selection application is an uncertified embodiment of a host native application described in more detail below. As will be appreciated by one skilled in the art other embodiments could by certified.

If the host requires control of the user interface back client is notified through client application selection application of this.

It is further desirable when using a host and a client that the device settings be synchronized in certain situations. Device settings could include locale settings time zone settings or theme settings Locale as described herein includes various settings such as the language of the interface for example English or French or Spanish. It could also include the keyboard configuration e.g. QWERTY AZERTY QWERTZ or DVORAK. Theme settings could color patterns and background images.

In setup application referred in a user can choose between a mode that allows the user to use host settings for the device settings or custom settings. As one skilled in the art will appreciate a different mode setting could be used for theme locale and time zone or these could be all included in one mode setting.

If the mode is set to the host settings the device settings for the client are synchronized with the host s device settings. Any changes in the host s device settings are propagated to the client and the client s device settings are therefore also changed. For example if a user changes the language from French to English in a host application this is propagated to client and client applications will use English.

In the case where the client display is set to mimic the host display propagation of changes in the host display is accomplished by having a listener application monitoring the host device settings. Upon a change in the host device settings the host listener will notify setup application that a change has been made to the host device settings and this change will be reflected in the client device settings.

Alternatively propagation of a change in the device settings could include polling every time a graphical user interface from the client takes over. This polling involves comparing the host device settings with the client device settings and thereby determining if a change has been made. If a change has been made the client device settings are updated.

Thus if the mode is automatic or host settings changes in the host device settings are pushed to the client either through a listener or by polling as described above.

If conversely the mode is set to manual or client settings the user can update the device settings in the client and client applications will use these display setting instead of the host device settings. If the mode is set to client settings changes to the host s device settings will be ignored by client applications .

Reference is now made to . In order to interact with a user of a host device client applications need to provide a user interface . On a host device having one or more input devices such as a keypad keyboard roller wheel scrollstrip touch pad d pad or other navigation device and a screen a user must be able to input actions for client applications and the results of the input and client applications operations need to be displayed on the screen. In order to accomplish this three components are provided within the I O architecture of the present system. These are a host native application HNA platform abstraction layer PAL and a host independent engine HIE .

HIE is a platform independent component. Since PAL contains the host abstraction layer HAL and the client abstraction layer CAL translation between the client and the particular host is performed in it. In a preferred embodiment PAL is a C function interface.

HIE includes both virtual machine and client OS . These are used to activate start or call instances of objects in client applications when client is object oriented or call functions in client when it is not.

HNA resides beyond PAL and thus can adapt user interface to conform and adapt to a particular host on behalf of client applications . HNA can take radically different forms depending on the design of the host application infrastructure and the user interface requirements of the host operating system. For example it is envisaged that in alternate embodiments a keyboard and display user interface are required or alternatively a radically different voice only interface can be provided. HNA is responsible for creating the framework necessary to receive input and update output when a user brings a client application to the foreground. In a keyboard display embodiment this may involve creating windows buttons or graphics widgets of any kind. In a voice only host embodiment this may involve speech recognition and voice synthesis.

For input HNA is responsible for passing user actions to HIE through platform abstraction layer . Inputs can include button presses keystrokes stylus inputs roller wheel motions scrollstrip motions touch pad motions d pad motions voice commands accelerometer motions or other inputs that would be known to those skilled in the art. These inputs are translated and or mapped as received from the host operating system and fed through the input function of the platform abstraction layer .

For output HNA may receive screen updates from HIE at any time including when client application is not in the foreground. These updates must be stored and memory is used by HNA to maintain a complete frame buffer copy separate from the application display area. If HNA is in the foreground when receiving an update from HIE then the application display area must be updated as well as the frame buffer so that the display on the host device reflects the screen change immediately. Whenever HNA transitions into the foreground it must update the application display area with the complete contents of the frame buffer.

Other output types envisaged include audio tones voice and signals to actuate host specific features such as an offset motor or led for discrete notification or indication.

In a preferred embodiment HNA uses a framework that updates the user by simply displaying a graphic image provided by PAL and processes user actions by adapting them to be sent down as events to PAL . This greatly reduces the complexity of HNA thus enhancing the portability of the client to other host devices.

Reference is now made to which illustrate a specific example of how HNA adapts user actions and provides a user interface on behalf of client applications adapted to the semantics of a particular host.

First a system for symbolic input on a particular host is shown in . The system employs a particular semantic for symbolic input that the users of traditional application on the host will expect to be valid on all applications utilized on the host.

Operationally host graphical user interface element offers a 9 6 symbol table to a user. Cursor is moved along a 9 4 grid in order to select a symbol. Since the number of rows of the grid is smaller than that of the table the symbols are offered on two pages 

Referring now to the user may manipulate any number of input devices on a particular host including a keypad a 4 directional D pad rocker switches as well as a QWERTY keyboard provided in two portions a left keyboard portion L and a right keyboard portion R. Most notably the host semantics for symbolic input on this particular host require that cursor be moved on the grid by manipulating D pad to select a particular symbol.

In this particular example HNA preserves the semantics of symbolic input on the host while adapting actions a client application user is likely to desire for symbolic input given the data centric features of client applications .

Referring now to operationally client graphical user interface element offers a slightly different 9 6 symbol table on two pages wherein symbols can still be selected by operation of d pad thus preserving the host symbolic input semantics. Cursor is now moved however on a 9 3 grid instead of a 9 6 grid. This grid height is preferable in order to be able to map one row of each of the letter rows of the keyboard of to one of the symbol rows of the grid. The width of the grid is maintained the same as in the host graphical user element to allow a traditional host application user to quickly learn the layout of the symbol table while utilizing client applications and to continue to contemporaneously support the use of the d pad for selecting a symbol.

Thus a user is enabled to directly input one of symbols using one keystroke instead of having to resort to using the d pad D while still accepting input using d pad D.

Note that the embodiments of deliberately do not use the right most key of the top row of a standard keyboard i.e. in the case of the embodiment of the key marked by the P indicia in right keyboard portion R since the topmost rows of the three standard keyboards shown herein contains 10 keys. This has been shown above to provide advantages and thus should not be considered a limitation. Nonetheless it is envisaged that the techniques taught herein could be adapted to other keyboard layouts and grid sizes on a per host basis by those of skill in the art and thus those adaptations are also within the scope of this application.

In alternate embodiments the unused keys can remain unutilized or they can be assigned a function to further enhance symbolic input such as toggling between the various symbol pages. It is also envisaged that toggling between symbol pages can be accomplished by use of any one of the many other keys available on the particular keyboard available on the host keyboard.

To summarize the example for input HNA adapts keystrokes by mapping each grid location on the 9 3 grid onto a key on the keyboard graphical user interface element shown as QWERTY AZERTY and QWERTZ variants in FIGS. and respectively. For output HNA enhances the display by showing the indicia of a corresponding alphabetic key directly below each symbol.

Referring to the drawings is a block diagram illustrating a host mobile station including preferred embodiments of the techniques of the present application. Mobile station is preferably a two way wireless communication device having at least voice and data communication capabilities. Mobile station preferably has the capability to communicate with other computer systems on the Internet. Depending on the exact functionality provided the wireless device may be referred to as a data messaging device a two way pager a wireless e mail device a cellular telephone with data messaging capabilities a wireless Internet appliance or a data communication device as examples.

Where mobile station is enabled for two way communication it will incorporate a communication subsystem including both a receiver and a transmitter as well as associated components such as one or more preferably embedded or internal antenna elements and local oscillators LOs and a processing module such as a digital signal processor DSP . As will be apparent to those skilled in the field of communications the particular design of the communication subsystem will be dependent upon the communication network in which the device is intended to operate. For example mobile station may include a communication subsystem designed to operate within the Mobitex mobile communication system the DataTACT mobile communication system GPRS network UMTS network EDGE network or CDMA network.

Network access requirements will also vary depending upon the type of network . For example in the Mobitex and DataTAC networks mobile station is registered on the network using a unique identification number associated with each mobile station. In UMTS and GPRS networks and in some CDMA networks however network access is associated with a subscriber or user of mobile station . A GPRS mobile station therefore requires a subscriber identity module SIM card in order to operate on a GPRS network and a RUIM in order to operate on some CDMA networks. Without a valid SIM RUIM card a GPRS UMTS CDMA mobile station may not be fully functional. Local or non network communication functions as well as legally required functions if any such as 911 emergency calling may be available but mobile station will be unable to carry out any other functions involving communications over the network . The SIM RUIM interface is normally similar to a card slot into which a SIM RUIM card can be inserted and ejected like a diskette or PCMCIA card. The SIM RUIM card can have approximately 64K of memory and hold many key configuration and other information such as identification and subscriber related information.

When required network registration or activation procedures have been completed mobile station may send and receive communication signals over the network . Signals received by antenna through communication network are input to receiver which may perform such common receiver functions as signal amplification frequency down conversion filtering channel selection and the like and in the example system shown in analog to digital A D conversion. A D conversion of a received signal allows more complex communication functions such as demodulation and decoding to be performed in the DSP . In a similar manner signals to be transmitted are processed including modulation and encoding for example by DSP and input to transmitter for digital to analog conversion frequency up conversion filtering amplification and transmission over the communication network via antenna . DSP not only processes communication signals but also provides for receiver and transmitter control. For example the gains applied to communication signals in receiver and transmitter may be adaptively controlled through automatic gain control algorithms implemented in DSP .

Network may further communicate with multiple systems not shown . For example network may communicate with both an enterprise system and a web client system in order to accommodate various clients with various service levels.

Mobile station preferably includes a microprocessor which controls the overall operation of the device. Communication functions including at least data and voice communications are performed through communication subsystem . Microprocessor also interacts with further device subsystems such as the display flash memory random access memory RAM auxiliary input output I O subsystems serial port keyboard speaker microphone a short range communications subsystem and any other device subsystems generally designated as .

Some of the subsystems shown in perform communication related functions whereas other subsystems may provide resident or on device functions. Notably some subsystems such as keyboard and display for example may be used for both communication related functions such as entering a text message for transmission over a communication network and device resident functions such as a calculator or task list.

Operating system software used by the microprocessor is preferably stored in a persistent store such as flash memory which may instead be a read only memory ROM or similar storage element not shown . Those skilled in the art will appreciate that the operating system specific device applications or parts thereof may be temporarily loaded into a volatile memory such as RAM . Received communication signals may also be stored in RAM .

As shown flash memory can be segregated into different areas for both computer programs and program data storage and . These different storage types indicate that each program can allocate a portion of flash memory for their own data storage requirements. Microprocessor in addition to its operating system functions preferably enables execution of software applications on the mobile station. A predetermined set of applications that control basic operations including at least data and voice communication applications for example will normally be installed on mobile station during manufacturing. A preferred software application may be a personal information manager PIM application having the ability to organize and manage data items relating to the user of the mobile station such as but not limited to e mail calendar events voice mails appointments and task items. Naturally one or more memory stores would be available on the mobile station to facilitate storage of PIM data items. Such PIM application would preferably have the ability to send and receive data items via the wireless network . In a preferred embodiment the PIM data items are seamlessly integrated synchronized and updated via the wireless network with the mobile station user s corresponding data items stored or associated with a host computer system. Further applications may also be loaded onto the mobile station through the network an auxiliary I O subsystem serial port short range communications subsystem or any other suitable subsystem and installed by a user in the RAM or preferably a non volatile store not shown for execution by the microprocessor . Such flexibility in application installation increases the functionality of the device and may provide enhanced on device functions communication related functions or both. For example secure communication applications may enable electronic commerce functions and other such financial transactions to be performed using the mobile station .

In a data communication mode a received signal such as a text message or web page download will be processed by the communication subsystem and input to the microprocessor which preferably further processes the received signal for output to the display or alternatively to an auxiliary I O device . A user of mobile station may also compose data items such as email messages for example using the keyboard which is preferably a complete alphanumeric keyboard or telephone type keypad in conjunction with the display and possibly an auxiliary I O device . Such composed items may then be transmitted over a communication network through the communication subsystem .

For voice communications overall operation of mobile station is similar except that received signals would preferably be output to a speaker and signals for transmission would be generated by a microphone . Alternative voice or audio I O subsystems such as a voice message recording subsystem may also be implemented on mobile station . Although voice or audio signal output is preferably accomplished primarily through the speaker display may also be used to provide an indication of the identity of a calling party the duration of a voice call or other voice call related information for example.

Serial port in would normally be implemented in a personal digital assistant PDA type mobile station for which synchronization with a user s desktop computer not shown may be desirable but is an optional device component. Such a port would enable a user to set preferences through an external device or software application and would extend the capabilities of mobile station by providing for information or software downloads to mobile station other than through a wireless communication network. The alternate download path may for example be used to load an encryption key onto the device through a direct and thus reliable and trusted connection to thereby enable secure device communication.

Other communications subsystems such as a short range communications subsystem is a further optional component which may provide for communication between mobile station and different systems or devices which need not necessarily be similar devices. For example the subsystem may include an infrared device and associated circuits and components or a Bluetooth communication module to provide for communication with similarly enabled systems and devices.

A mobile communications device such as a phone is typically formed of software firmware and hardware adapted to provide communications services over a wireless communications network. This process of forming the relationship between the mobile communications device and the service is known in the art as provisioning. Typically a network operator provisions the mobile via a subscription to a service contract. Thus once the mobile has been provisioned the user of the mobile is often referred to as a subscriber.

In a voice and data network such as GSM Global System for Mobile Communication and GPRS General Packet Radio System CDMA Code Division Multiple Access or various other third generation networks such as EDGE Enhanced Data rates for GSM Evolution or UMTS Universal Mobile Telecommunications Systems both voice and data services may be available to mobile communications devices. Example voice services include voice calling and Short Messaging Service SMS . Example data services include Internet browsing email and Multimedia Messaging Service MMS .

Although many services may be available on a given network only those subscribers that use mobile communications devices that have been provisioned for those services will be able to benefit from them. This may present problems for the subscriber and the network operator alike. On one hand the subscriber may desire an existing service he does not have i.e. an upgrade or desire disabling a service i.e. a downgrade. On the other hand the operator may want to offer a new service but may hesitate if subscribers cannot benefit from them.

One known solution is to provide an out of band communications link such as a Universal Serial Bus on the mobile communications device and enable the subscriber to load new software onto the mobile via the out of band communication link using a personal computer thus re provisioning the device. This may be an unacceptable solution to both the subscriber and the operator as there is a significant risk that the mobile by error receives a wrong or incomplete load and may require servicing. Furthermore this solution may be unacceptable to the subscriber who does not have access to a personal computer.

However since mobile station is a host communications device that hosts client client may be provisioned directly by a user of mobile station .

Reference is now made to . is a version of in which the provisioning aspects of the present method and apparatus are shown.

Mobile device includes a data communications client and the certified portion of a host device as outlined above in more detail with reference to mobile device .

Within data communications client applications run on virtual machine . One such application is a provisioning application. A provisioning application communicates with a configuration application preferably through a configuration user interface in order to select provisioning information.

Mobile station includes a first data store adapted to store variant configuration information and a second data store adapted to store provisioning information. Specifically mobile station includes various provisioning configurations within the second data store to allow the user to select the provisioning of the device. Once the provisioning the device is selected a first data store can be used to configure the host and client side of the device for the selected provisioning information.

As will be appreciated by those skilled in the art provisioning information can be stored on the mobile device at various times. In a preferred embodiment however provisioning information is stored during the manufacturing process. In this way a mobile device with various service options can be distributed to carriers for resale without a specialized manufacturing process required for each service configuration. For example if a manufacturer allows a provisioning in a service type A or service type B second data store includes both service types and the service type a client desires can be configured prior to the client being sold the device. This results in savings since a carrier does not need to allocate a number of devices that are to be manufactured using a service type A and second number of devices manufactured using a service type B since it is difficult to determine beforehand the number of such devices that will be sold. In this way only one device can be manufactured and the provisioning done by the carrier or by the user subsequently.

If a user indicates through a configuration application that they wish to change the provisioning to different provisioning information stored in second data store configuration application goes to first data store to determine configuration information.

The configuration information from first data store is then propagated through to applications either through a global configuration or through selected configuration as will be known to those skilled in the art.

As with mobile device above configuration application communicates through a native interface and abstraction layer to first data store and second data store .

Once provisioning information has been changed at the client side the host side needs to be informed of the change. This can either be done through an explicit message sent to applications through a listener checking whether there has been a provisioning change or a flag being set in one of the data stores that is checked by host applications . In all cases applications go to the variant configuration information in first data store and any applications that need to be modified on the host side are changed.

Data communications client may further include a clear data store . Clear data store can be used to clean the client applications of data that may not be compatible with the new service type that has been provisioned. Similarly a clear data store on host can be used to clear host applications of data that may not be compatible with the service type that has been provisioned.

The above examples include only a first service type and a second service type. However this is note meant to be limiting and it would be appreciated by those skilled in the art that any number of service types can be stored on the mobile station and a user may move between these various service types.

Reference is now made to . shows user interaction through the provisioning process in order to change to a different service type. In the example of the service type being changed to has more functionality than the service type presently provisioned on the device.

In step a user selects a client mode from a user interface in the host mode. This brings up a list of options that the user can perform on the client side in step . In step the user can select to perform service configuration which moves the user to an exemplary screen as illustrated by reference numeral . In the device asks whether a user wishes to proceed and indicates that an operator may need to be contacted. If the user decides to proceed the mobile station proceeds to step in which a verification is requested to ask the user whether they really want to provision the new service type.

If the user selects YES in step the mobile station proceeds to step in which a warning is presented indicating that all personal data may be lost in the example of . As will be appreciated information can be lost with provisioning changes. For example if a new e mail client is used then personal data such as address books from the old e mail client may be lost. Other examples of data being lost would be known to those skilled in the art.

The user next proceeds to step if the user indicates that they are sure that they are willing to lose the personal data in step . In step the mobile station proceeds to change the provisioning information as indicated above with reference to .

Once the provisioning is completed the mobile station in step prompts the user to power down the device in order to complete the process. Alternatively the mobile device can simply give a warning and then power down on its own.

In step the mobile station is powered up and the new client applications or the old client applications with the new provisioning are displayed.

Referring to if provisioning is done to provide a service type with less functionality than the previous service type similar steps as those in may be included. In step a user selects a client function on the host user interface. This brings a menu up as illustrated in step for various options that the user can perform. If the user selects to perform service configuration in step the mobile station proceeds to step in which a verification screen is presented. The verification screen indicates what the service change will entail and asks the user if they are sure they want to proceed.

If the user proceeds in step then the mobile station in step presents a warning screen that certain data may be lost. In the example of in which a service type with less functionality is being provided all data for the higher service options in the old provisioning may be lost and the warning would display this sort of information.

If the user selects YES in step the mobile station proceeds to step . In step the provisioning occurs as presented in above. Once the provisioning is complete the mobile station may prompt the user to power down the device when they power down the device after presenting a warning to the user in step .

The above therefore presents the user with options to move between various service types defined preferably in the manufacturing process and to modify the configuration of various applications on both the host and client side through a first data store. This presents the advantage that only one mobile device needs to be created during the manufacturing process and the provisioning can be done by either the user or the operator prior to the device being sold. Further if the user decides that the services they currently have are either insufficient or excessive service type changes can be made through the selection of provisioning information stored in second data store.

The multiple configurations on the device therefore save inventory since the operators do not need to store various mobile stations that are manufactured to various provisioning types and further allows the use of a client on a host device where the client can be configured to a user s needs.

Thus the host device user is enabled to upgrade or downgrade client service i.e. to provision the data client.

The embodiments described herein are examples of structures systems or methods having elements corresponding to elements of the techniques of this application. This written description may enable those skilled in the art to make and use embodiments having alternative elements that likewise correspond to the elements of the techniques of this application. The intended scope of the techniques of this application thus includes other structures systems or methods that do not differ from the techniques of this application as described herein and further includes other structures systems or methods with insubstantial differences from the techniques of this application as described herein.

